/*
 * Availability support functions
 *
 * Copyright 2020 Broadcom
 *
 * This program is the proprietary software of Broadcom and/or
 * its licensors, and may only be used, duplicated, modified or distributed
 * pursuant to the terms and conditions of a separate, written license
 * agreement executed between you and Broadcom (an "Authorized License").
 * Except as set forth in an Authorized License, Broadcom grants no license
 * (express or implied), right to use, or waiver of any kind with respect to
 * the Software, and Broadcom expressly reserves all rights in and to the
 * Software and all intellectual property rights therein.  IF YOU HAVE NO
 * AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
 * WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
 * THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof, and to
 * use this information only in connection with your use of Broadcom
 * integrated circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR
 * OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL,
 * SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR
 * IN ANY WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
 * IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii)
 * ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF
 * OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 * <<Broadcom-WL-IPTag/Proprietary:>>
 *
 * $Id: wlu_subcounters.c 775170 2019-05-21 16:27:16Z $
 */
#include <bcmendian.h>
#include "wlu_common.h"
#include <bcmutils.h>
#include <wlioctl.h>
#include <wlioctl_utils.h>
#include "wlu_cmd.h"
#include "wlu.h"

#define CAT_TX    (1<<0) /**< counter is transmit related */
#define CAT_RX    (1<<1) /**< counter is receive related */
#define CAT_ERR   (1<<2) /**< counter signals a non optimal condition */
#define CAT_UCAST (1<<3) /**< unicast specific counter */
#define CAT_MCAST (1<<4) /**< multicast or broadcast specific counter */
#define CAT_AMPDU (1<<5) /**< AMPDU specific counter */
#define CAT_UCODE (1<<6) /**< Counter is generated by ucode (contained in SHM in d11 core) */
#define CAT_CTRL  (1<<7) /**< Counters related to d11 control or mgmt frames */
#define CAT_SEC   (1<<8) /**< Counters related to security/encryption */
#define CAT_ASSOC (1<<9) /**< Counters related to authentication/association */

#define PRINIT() prcnt_init()
#define PRNL1()  prcnt_prnl1(p_cnt_filters)

#define PRFMT1(name) #name " %u "  /* converts into the 'default' counters printf format string */

/** prints one string without arguments */
#define PRSTR(name, str)					\
	if (prcnt_filter1(p_cnt_filters, #name)) {		\
		printf("%s", str);				\
		at_start_of_line = FALSE;			\
	}

/** prints one variable with dtoh32 conversion */
#define PRVALV1(name)						\
	if (prcnt_filter(p_cnt_filters, #name, cnt_v1->name)) {	\
		printf(PRFMT1(name), dtoh32(cnt_v1->name));	\
		at_start_of_line = FALSE;			\
	}

#define PRVAL(name)						\
	if (prcnt_filter(p_cnt_filters, #name, cnt->name)) {	\
		printf(PRFMT1(name), dtoh32(cnt->name));	\
		at_start_of_line = FALSE;			\
	}
/** prints one variable with dtoh32 conversion */
#define PRVAL_RENAME(name, prname)				\
	if (prcnt_filter(p_cnt_filters, #name, cnt->name)) {	\
		printf(PRFMT1(prname), dtoh32(cnt->name));	\
		at_start_of_line = FALSE;			\
	}

/** Safe value print for only valid counter values, and when the counter is within len */
#define PRVALSF(name) \
	if ((dtoh32(cnt->name) != INVALID_CNT_VAL) &&		\
	    (len > ((uint8 *)&cnt->name - (uint8 *)cnt)))	\
	    PRVAL(name)

/** prints one variable with dtoh32 conversion */
#define PRVALSF_RENAME(varname, prname)				\
	if (dtoh32(cnt->varname) != INVALID_CNT_VAL)		\
		PRVAL_RENAME(varname, prname)

/** prints one variable with dtoh32 conversion */
#define PRVAL_FMTSTR1(varname, fmtstring, value)		\
	if (prcnt_filter(p_cnt_filters, #varname, value)) {	\
		printf(fmtstring, value);			\
		at_start_of_line = FALSE;			\
	}

/** prints two variables, no dtoh32 conversion */
#define PRVAL_FMTSTR2(varname, fmtstring, value1, value2)	\
	if (prcnt_filter(p_cnt_filters, #varname, value2)) {	\
		printf(fmtstring, value1, value2);		\
		at_start_of_line = FALSE;			\
	}

/** prints one float variable without dtoh32 conversion */
#define PRVAL_FMTSTR1F(varname, fmtstring, value1)	\
	if (prcnt_filter(p_cnt_filters, #varname, value1 != 0.0 ? TRUE : FALSE)) {	\
		printf(fmtstring, value1);						\
		at_start_of_line = FALSE;						\
	}

#define PRCNT_MACSTAT_TX_VER_GE11						\
do {										\
	/* UCODE SHM counters */						\
	/* tx start and those that do not end well */				\
	PRVAL(txallfrm); PRVAL(txbcnfrm); PRVAL(txrtsfrm); PRVAL(txctsfrm);	\
	PRVAL(txackfrm); PRVAL(txback); PRVAL(txdnlfrm); PRNL1();		\
	PRVAL(txampdu); PRVAL(txmpdu); PRVAL(txucast);				\
	PRVAL(rxrsptmout); PRVAL(txinrtstxop); PRVAL(txrtsfail); PRNL1();	\
	PRVAL_FMTSTR1F(txper_ucastdt, "txper_ucastdt %.1f%% ",			\
		cnt->txucast > 0 ?						\
		(float)(1000 - ((cnt->rxackucast + cnt->rxback) * 1000		\
		 / cnt->txucast))/10 : 0);					\
	PRVAL_FMTSTR1F(txper_rts, "txper_rts %.1f%%",				\
		cnt->txrtsfrm > 0 ?						\
		(float)(1000 - (cnt->rxctsucast * 1000				\
		/ cnt->txrtsfrm))/10 : 0);					\
	PRNL1();								\
	PRSTR(txfunfl, "txfunfl: ");						\
	for (i = 0; i < NFIFO_LEGACY; i++) {						\
		PRVAL_FMTSTR1(txfunfl, "%u ", cnt->txfunfl[i]);			\
	}									\
	PRVAL(txtplunfl); PRVAL(txphyerror); PRNL1(); PRNL1();			\
} while (0)

#define PRCNT_MACSTAT_RX_VER_GE11						\
do {										\
	/* rx with goodfcs */							\
	PRVAL(rxctlucast); PRVAL(rxrtsucast); PRVAL(rxctsucast);		\
	PRVAL(rxackucast); PRVAL(rxback); PRNL1();				\
	PRVAL(rxbeaconmbss); PRVAL(rxdtucastmbss);				\
	PRVAL(rxmgucastmbss); PRNL1();						\
	PRVAL(rxbeaconobss); PRVAL(rxdtucastobss); PRVAL(rxdtocast);		\
	PRVAL(rxmgocast); PRNL1();						\
	PRVAL(rxctlocast); PRVAL(rxrtsocast); PRVAL(rxctsocast); PRNL1();	\
	PRVAL(rxctlmcast); PRVAL(rxdtmcast); PRVAL(rxmgmcast); PRNL1(); PRNL1();	\
										\
	PRVAL(rxcgprqfrm); PRVAL(rxcgprsqovfl); PRVAL(txcgprsfail);		\
	PRVAL(txcgprssuc); PRVAL(prs_timeout); PRNL1();				\
	PRVAL(pktengrxducast); PRVAL(pktengrxdmcast);				\
	PRVAL(bcntxcancl);							\
} while (0)

extern int wlu_var_getbuf_minimal(void *wl, const char *iovar, void *param, int param_len,
		void **bufptr);

/** specifies filters to apply when printing counters */
struct cnt_filters_s {
	bool nonzero;		/**< only print nonzero counter values */
	bool filters_active;	/**< FALSE when user did not supply cmd line options */
	bool invert_selection;	/**< inverts entire selection */
	uint32 filter;  /**< only print counters falling into these categorie(s). Ignored if 0. */
};

typedef struct {
	char **pbuf_ptr;
	struct cnt_filters_s cnt_filters; /**< specifies filters to apply when printing counters */
} wl_cnt_cbfn_info_t;

typedef struct counter_offset_info {
	const char	*name;		/* Name for the counter */
	uint32		offset;		/* Offset of the counter in structure */
} counter_offset_info_t;

typedef struct ver_to_cntr_offset_info {
	counter_offset_info_t	*offset_info_tbl;
	uint32			cntr_ver;
} ver_to_cntr_offset_info_t;

/** specifies properties of each counter, so it can be optionally not printed on a criterium */
struct cnt_properties_s {
	char *name;
	uint32 categories; /**< a bitmask, '1' means that counter is a member of that category */
};

static counter_offset_info_t cntr_offset_info_v6[] = {
	{"txframe",		OFFSETOF(wl_cnt_ver_6_t, txframe)},
	{"txbyte",		OFFSETOF(wl_cnt_ver_6_t, txbyte)},
	{"txretrans",		OFFSETOF(wl_cnt_ver_6_t, txretrans)},
	{"txerror",		OFFSETOF(wl_cnt_ver_6_t, txerror)},
	{"txctl",		OFFSETOF(wl_cnt_ver_6_t, txctl)},
	{"txprshort",		OFFSETOF(wl_cnt_ver_6_t, txprshort)},
	{"txserr",		OFFSETOF(wl_cnt_ver_6_t, txserr)},
	{"txnobuf",		OFFSETOF(wl_cnt_ver_6_t, txnobuf)},
	{"txnoassoc",		OFFSETOF(wl_cnt_ver_6_t, txnoassoc)},
	{"txrunt",		OFFSETOF(wl_cnt_ver_6_t, txrunt)},
	{"txchit",		OFFSETOF(wl_cnt_ver_6_t, txchit)},
	{"txcmiss",		OFFSETOF(wl_cnt_ver_6_t, txcmiss)},
	{"txuflo",		OFFSETOF(wl_cnt_ver_6_t, txuflo)},
	{"txphyerr",		OFFSETOF(wl_cnt_ver_6_t, txphyerr)},
	{"txphycrs",		OFFSETOF(wl_cnt_ver_6_t, txphycrs)},
	{"rxframe",		OFFSETOF(wl_cnt_ver_6_t, rxframe)},
	{"rxbyte",		OFFSETOF(wl_cnt_ver_6_t, rxbyte)},
	{"rxerror",		OFFSETOF(wl_cnt_ver_6_t, rxerror)},
	{"rxctl",		OFFSETOF(wl_cnt_ver_6_t, rxctl)},
	{"rxnobuf",		OFFSETOF(wl_cnt_ver_6_t, rxnobuf)},
	{"rxnondata",		OFFSETOF(wl_cnt_ver_6_t, rxnondata)},
	{"rxbadds",		OFFSETOF(wl_cnt_ver_6_t, rxbadds)},
	{"rxbadcm",		OFFSETOF(wl_cnt_ver_6_t, rxbadcm)},
	{"rxfragerr",		OFFSETOF(wl_cnt_ver_6_t, rxfragerr)},
	{"rxrunt",		OFFSETOF(wl_cnt_ver_6_t, rxrunt)},
	{"rxgiant",		OFFSETOF(wl_cnt_ver_6_t, rxgiant)},
	{"rxnoscb",		OFFSETOF(wl_cnt_ver_6_t, rxnoscb)},
	{"rxbadproto",		OFFSETOF(wl_cnt_ver_6_t, rxbadproto)},
	{"rxbadsrcmac",		OFFSETOF(wl_cnt_ver_6_t, rxbadsrcmac)},
	{"rxbadda",		OFFSETOF(wl_cnt_ver_6_t, rxbadda)},
	{"rxfilter",		OFFSETOF(wl_cnt_ver_6_t, rxfilter)},
	{"rxoflo",		OFFSETOF(wl_cnt_ver_6_t, rxoflo)},
	{"rxuflo[0]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[0])},
	{"rxuflo[1]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[1])},
	{"rxuflo[2]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[2])},
	{"rxuflo[3]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[3])},
	{"rxuflo[4]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[4])},
	{"rxuflo[5]",		OFFSETOF(wl_cnt_ver_6_t, rxuflo[5])},
	{"d11cnt_txrts_off",	OFFSETOF(wl_cnt_ver_6_t, d11cnt_txrts_off)},
	{"d11cnt_rxcrc_off",	OFFSETOF(wl_cnt_ver_6_t, d11cnt_rxcrc_off)},
	{"d11cnt_txnocts_off",	OFFSETOF(wl_cnt_ver_6_t, d11cnt_txnocts_off)},
	{"dmade",		OFFSETOF(wl_cnt_ver_6_t, dmade)},
	{"dmada",		OFFSETOF(wl_cnt_ver_6_t, dmada)},
	{"dmape",		OFFSETOF(wl_cnt_ver_6_t, dmape)},
	{"reset",		OFFSETOF(wl_cnt_ver_6_t, reset)},
	{"tbtt",		OFFSETOF(wl_cnt_ver_6_t, tbtt)},
	{"txdmawar",		OFFSETOF(wl_cnt_ver_6_t, txdmawar)},
	{"pkt_callback_reg_fail", OFFSETOF(wl_cnt_ver_6_t, pkt_callback_reg_fail)},
	{"d11_txfrag",		OFFSETOF(wl_cnt_ver_6_t, txfrag)},
	{"d11_txmulti",		OFFSETOF(wl_cnt_ver_6_t, txmulti)},
	{"txfail",		OFFSETOF(wl_cnt_ver_6_t, txfail)},
	{"d11_txretry",		OFFSETOF(wl_cnt_ver_6_t, txretry)},
	{"d11_txretrie",	OFFSETOF(wl_cnt_ver_6_t, txretrie)},
	{"rxdup",		OFFSETOF(wl_cnt_ver_6_t, rxdup)},
	{"d11_txrts",		OFFSETOF(wl_cnt_ver_6_t, txrts)},
	{"d11_txnocts",		OFFSETOF(wl_cnt_ver_6_t, txnocts)},
	{"d11_txnoack",		OFFSETOF(wl_cnt_ver_6_t, txnoack)},
	{"d11_rxfrag",		OFFSETOF(wl_cnt_ver_6_t, rxfrag)},
	{"d11_rxmulti",		OFFSETOF(wl_cnt_ver_6_t, rxmulti)},
	{"rxcrc",		OFFSETOF(wl_cnt_ver_6_t, rxcrc)},
	{"d11_txfrmsnt",	OFFSETOF(wl_cnt_ver_6_t, txfrmsnt)},
	{"d11_rxundec",		OFFSETOF(wl_cnt_ver_6_t, rxundec)},
	{"tkipmicfaill",	OFFSETOF(wl_cnt_ver_6_t, tkipmicfaill)},
	{"tkipcntrmsr",		OFFSETOF(wl_cnt_ver_6_t, tkipcntrmsr)},
	{"tkipreplay",		OFFSETOF(wl_cnt_ver_6_t, tkipreplay)},
	{"ccmpfmterr",		OFFSETOF(wl_cnt_ver_6_t, ccmpfmterr)},
	{"ccmpreplay",		OFFSETOF(wl_cnt_ver_6_t, ccmpreplay)},
	{"ccmpundec",		OFFSETOF(wl_cnt_ver_6_t, ccmpundec)},
	{"fourwayfail",		OFFSETOF(wl_cnt_ver_6_t, fourwayfail)},
	{"wepundec",		OFFSETOF(wl_cnt_ver_6_t, wepundec)},
	{"wepicverr",		OFFSETOF(wl_cnt_ver_6_t, wepicverr)},
	{"decsuccess",		OFFSETOF(wl_cnt_ver_6_t, decsuccess)},
	{"tkipicverr",		OFFSETOF(wl_cnt_ver_6_t, tkipicverr)},
	{"wepexcluded",		OFFSETOF(wl_cnt_ver_6_t, wepexcluded)},
	{"txchanrej",		OFFSETOF(wl_cnt_ver_6_t, txchanrej)},
	{"psmwds",		OFFSETOF(wl_cnt_ver_6_t, psmwds)},
	{"phywatchdog",		OFFSETOF(wl_cnt_ver_6_t, phywatchdog)},
	{"prq_entries_handled",	OFFSETOF(wl_cnt_ver_6_t, prq_entries_handled)},
	{"prq_undirected_entries", OFFSETOF(wl_cnt_ver_6_t, prq_undirected_entries)},
	{"prq_bad_entries",	OFFSETOF(wl_cnt_ver_6_t, prq_bad_entries)},
	{"atim_suppress_count",	OFFSETOF(wl_cnt_ver_6_t, atim_suppress_count)},
	{"bcn_template_not_ready", OFFSETOF(wl_cnt_ver_6_t, bcn_template_not_ready)},
	{"bcn_template_not_ready_done",	OFFSETOF(wl_cnt_ver_6_t, bcn_template_not_ready_done)},
	{"late_tbtt_dpc",	OFFSETOF(wl_cnt_ver_6_t, late_tbtt_dpc)},
	{"rx1mbps",		OFFSETOF(wl_cnt_ver_6_t, rx1mbps)},
	{"rx2mbps",		OFFSETOF(wl_cnt_ver_6_t, rx2mbps)},
	{"rx5mbps5",		OFFSETOF(wl_cnt_ver_6_t, rx5mbps5)},
	{"rx6mbps",		OFFSETOF(wl_cnt_ver_6_t, rx6mbps)},
	{"rx9mbps",		OFFSETOF(wl_cnt_ver_6_t, rx9mbps)},
	{"rx11mbps",		OFFSETOF(wl_cnt_ver_6_t, rx11mbps)},
	{"rx12mbps",		OFFSETOF(wl_cnt_ver_6_t, rx12mbps)},
	{"rx18mbps",		OFFSETOF(wl_cnt_ver_6_t, rx18mbps)},
	{"rx24mbps",		OFFSETOF(wl_cnt_ver_6_t, rx24mbps)},
	{"rx36mbps",		OFFSETOF(wl_cnt_ver_6_t, rx36mbps)},
	{"rx48mbps",		OFFSETOF(wl_cnt_ver_6_t, rx48mbps)},
	{"rx54mbps",		OFFSETOF(wl_cnt_ver_6_t, rx54mbps)},
	{"rx108mbps",		OFFSETOF(wl_cnt_ver_6_t, rx108mbps)},
	{"rx162mbps",		OFFSETOF(wl_cnt_ver_6_t, rx162mbps)},
	{"rx216mbps",		OFFSETOF(wl_cnt_ver_6_t, rx216mbps)},
	{"rx270mbps",		OFFSETOF(wl_cnt_ver_6_t, rx270mbps)},
	{"rx324mbps",		OFFSETOF(wl_cnt_ver_6_t, rx324mbps)},
	{"rx378mbps",		OFFSETOF(wl_cnt_ver_6_t, rx378mbps)},
	{"rx432mbps",		OFFSETOF(wl_cnt_ver_6_t, rx432mbps)},
	{"rx486mbps",		OFFSETOF(wl_cnt_ver_6_t, rx486mbps)},
	{"rx540mbps",		OFFSETOF(wl_cnt_ver_6_t, rx540mbps)},
	{"rfdisable",		OFFSETOF(wl_cnt_ver_6_t, rfdisable)},
	{"txexptime",		OFFSETOF(wl_cnt_ver_6_t, txexptime)},
	{"txmpdu_sgi",		OFFSETOF(wl_cnt_ver_6_t, txmpdu_sgi)},
	{"rxmpdu_sgi",		OFFSETOF(wl_cnt_ver_6_t, rxmpdu_sgi)},
	{"txmpdu_stbc",		OFFSETOF(wl_cnt_ver_6_t, txmpdu_stbc)},
	{"rxmpdu_stbc",		OFFSETOF(wl_cnt_ver_6_t, rxmpdu_stbc)},
	{"rxundec_mcst",	OFFSETOF(wl_cnt_ver_6_t, rxundec_mcst)},
	{"tkipmicfaill_mcst",	OFFSETOF(wl_cnt_ver_6_t, tkipmicfaill_mcst)},
	{"tkipcntrmsr_mcst",	OFFSETOF(wl_cnt_ver_6_t, tkipcntrmsr_mcst)},
	{"tkipreplay_mcst",	OFFSETOF(wl_cnt_ver_6_t, tkipreplay_mcst)},
	{"ccmpfmterr_mcst",	OFFSETOF(wl_cnt_ver_6_t, ccmpfmterr_mcst)},
	{"ccmpreplay_mcst",	OFFSETOF(wl_cnt_ver_6_t, ccmpreplay_mcst)},
	{"ccmpundec_mcst",	OFFSETOF(wl_cnt_ver_6_t, ccmpundec_mcst)},
	{"fourwayfail_mcst",	OFFSETOF(wl_cnt_ver_6_t, fourwayfail_mcst)},
	{"wepundec_mcst",	OFFSETOF(wl_cnt_ver_6_t, wepundec_mcst)},
	{"wepicverr_mcst",	OFFSETOF(wl_cnt_ver_6_t, wepicverr_mcst)},
	{"decsuccess_mcst",	OFFSETOF(wl_cnt_ver_6_t, decsuccess_mcst)},
	{"tkipicverr_mcst",	OFFSETOF(wl_cnt_ver_6_t, tkipicverr_mcst)},
	{"wepexcluded_mcst",	OFFSETOF(wl_cnt_ver_6_t, wepexcluded_mcst)},
	/* macstat counters */
	{"txallfrm",		OFFSETOF(wl_cnt_ver_6_t, txallfrm)},
	{"txrtsfrm",		OFFSETOF(wl_cnt_ver_6_t, txrtsfrm)},
	{"txctsfrm",		OFFSETOF(wl_cnt_ver_6_t, txctsfrm)},
	{"txackfrm",		OFFSETOF(wl_cnt_ver_6_t, txackfrm)},
	{"txdnlfrm",		OFFSETOF(wl_cnt_ver_6_t, txdnlfrm)},
	{"txbcnfrm",		OFFSETOF(wl_cnt_ver_6_t, txbcnfrm)},
	{"txfunfl[0]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[0])},
	{"txfunfl[1]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[1])},
	{"txfunfl[2]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[2])},
	{"txfunfl[3]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[3])},
	{"txfunfl[4]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[4])},
	{"txfunfl[5]",		OFFSETOF(wl_cnt_ver_6_t, txfunfl[5])},
	{"txampdu",		OFFSETOF(wl_cnt_ver_6_t, txfbw)},
	{"txtplunfl",		OFFSETOF(wl_cnt_ver_6_t, txtplunfl)},
	{"txphyerror",		OFFSETOF(wl_cnt_ver_6_t, txphyerror)},
	{"pktengrxducast",	OFFSETOF(wl_cnt_ver_6_t, pktengrxducast)},
	{"pktengrxdmcast",	OFFSETOF(wl_cnt_ver_6_t, pktengrxdmcast)},
	{"rxfrmtoolong",	OFFSETOF(wl_cnt_ver_6_t, rxfrmtoolong)},
	{"rxfrmtooshrt",	OFFSETOF(wl_cnt_ver_6_t, rxfrmtooshrt)},
	{"rxanyerr",		OFFSETOF(wl_cnt_ver_6_t, rxinvmachdr)},
	{"rxbadfcs",		OFFSETOF(wl_cnt_ver_6_t, rxbadfcs)},
	{"rxbadplcp",		OFFSETOF(wl_cnt_ver_6_t, rxbadplcp)},
	{"rxcrsglitch",		OFFSETOF(wl_cnt_ver_6_t, rxcrsglitch)},
	{"rxstrt",		OFFSETOF(wl_cnt_ver_6_t, rxstrt)},
	{"rxdtucastmbss",	OFFSETOF(wl_cnt_ver_6_t, rxdfrmucastmbss)},
	{"rxmgucastmbss",	OFFSETOF(wl_cnt_ver_6_t, rxmfrmucastmbss)},
	{"rxctlucast",		OFFSETOF(wl_cnt_ver_6_t, rxcfrmucast)},
	{"rxrtsucast",		OFFSETOF(wl_cnt_ver_6_t, rxrtsucast)},
	{"rxctsucast",		OFFSETOF(wl_cnt_ver_6_t, rxctsucast)},
	{"rxackucast",		OFFSETOF(wl_cnt_ver_6_t, rxackucast)},
	{"rxdtocast",		OFFSETOF(wl_cnt_ver_6_t, rxdfrmocast)},
	{"rxmgocast",		OFFSETOF(wl_cnt_ver_6_t, rxmfrmocast)},
	{"rxctlocast",		OFFSETOF(wl_cnt_ver_6_t, rxcfrmocast)},
	{"rxrtsocast",		OFFSETOF(wl_cnt_ver_6_t, rxrtsocast)},
	{"rxctsocast",		OFFSETOF(wl_cnt_ver_6_t, rxctsocast)},
	{"rxdtmcast",		OFFSETOF(wl_cnt_ver_6_t, rxdfrmmcast)},
	{"rxmgmcast",		OFFSETOF(wl_cnt_ver_6_t, rxmfrmmcast)},
	{"rxctlmcast",		OFFSETOF(wl_cnt_ver_6_t, rxcfrmmcast)},
	{"rxbeaconmbss",	OFFSETOF(wl_cnt_ver_6_t, rxbeaconmbss)},
	{"rxdtucastobss",	OFFSETOF(wl_cnt_ver_6_t, rxdfrmucastobss)},
	{"rxbeaconobss",	OFFSETOF(wl_cnt_ver_6_t, rxbeaconobss)},
	{"rxrsptmout",		OFFSETOF(wl_cnt_ver_6_t, rxrsptmout)},
	{"bcntxcancl",		OFFSETOF(wl_cnt_ver_6_t, bcntxcancl)},
	{"rxf0ovfl",		OFFSETOF(wl_cnt_ver_6_t, rxf0ovfl)},
	{"rxf1ovfl",		OFFSETOF(wl_cnt_ver_6_t, rxf1ovfl)},
	{"rxhlovfl",		OFFSETOF(wl_cnt_ver_6_t, rxf2ovfl)},
	{"missbcn_dbg",		OFFSETOF(wl_cnt_ver_6_t, txsfovfl)},
	{"pmqovfl",		OFFSETOF(wl_cnt_ver_6_t, pmqovfl)},
	{"rxcgprqfrm",		OFFSETOF(wl_cnt_ver_6_t, rxcgprqfrm)},
	{"rxcgprsqovfl",	OFFSETOF(wl_cnt_ver_6_t, rxcgprsqovfl)},
	{"txcgprsfail",		OFFSETOF(wl_cnt_ver_6_t, txcgprsfail)},
	{"txcgprssuc",		OFFSETOF(wl_cnt_ver_6_t, txcgprssuc)},
	{"prs_timeout",		OFFSETOF(wl_cnt_ver_6_t, prs_timeout)},
	{"txrtsfail",		OFFSETOF(wl_cnt_ver_6_t, rxnack)},
	{"txucast",		OFFSETOF(wl_cnt_ver_6_t, frmscons)},
	{"txinrtstxop",		OFFSETOF(wl_cnt_ver_6_t, txnack)},
	{"rxback",		OFFSETOF(wl_cnt_ver_6_t, rxback)},
	{"txback",		OFFSETOF(wl_cnt_ver_6_t, txback)},
	{"bphy_rxcrsglitch",	OFFSETOF(wl_cnt_ver_6_t, bphy_rxcrsglitch)},
	{"rxdrop20s",		OFFSETOF(wl_cnt_ver_6_t, rxdrop20s)},
	{"rxtoolate",		OFFSETOF(wl_cnt_ver_6_t, rxtoolate)},
	{"bphy_badplcp",	OFFSETOF(wl_cnt_ver_6_t, bphy_badplcp)},
	{NULL, 0},
};

static counter_offset_info_t cntr_offset_info_v11[] = {
	{"txframe",		OFFSETOF(wl_cnt_ver_11_t, txframe)},
	{"txbyte",		OFFSETOF(wl_cnt_ver_11_t, txbyte)},
	{"txretrans",		OFFSETOF(wl_cnt_ver_11_t, txretrans)},
	{"txerror",		OFFSETOF(wl_cnt_ver_11_t, txerror)},
	{"txctl",		OFFSETOF(wl_cnt_ver_11_t, txctl)},
	{"txprshort",		OFFSETOF(wl_cnt_ver_11_t, txprshort)},
	{"txserr",		OFFSETOF(wl_cnt_ver_11_t, txserr)},
	{"txnobuf",		OFFSETOF(wl_cnt_ver_11_t, txnobuf)},
	{"txnoassoc",		OFFSETOF(wl_cnt_ver_11_t, txnoassoc)},
	{"txrunt",		OFFSETOF(wl_cnt_ver_11_t, txrunt)},
	{"txchit",		OFFSETOF(wl_cnt_ver_11_t, txchit)},
	{"txcmiss",		OFFSETOF(wl_cnt_ver_11_t, txcmiss)},
	{"txuflo",		OFFSETOF(wl_cnt_ver_11_t, txuflo)},
	{"txphyerr",		OFFSETOF(wl_cnt_ver_11_t, txphyerr)},
	{"txphycrs",		OFFSETOF(wl_cnt_ver_11_t, txphycrs)},
	{"rxframe",		OFFSETOF(wl_cnt_ver_11_t, rxframe)},
	{"rxbyte",		OFFSETOF(wl_cnt_ver_11_t, rxbyte)},
	{"rxerror",		OFFSETOF(wl_cnt_ver_11_t, rxerror)},
	{"rxctl",		OFFSETOF(wl_cnt_ver_11_t, rxctl)},
	{"rxnobuf",		OFFSETOF(wl_cnt_ver_11_t, rxnobuf)},
	{"rxnondata",		OFFSETOF(wl_cnt_ver_11_t, rxnondata)},
	{"rxbadds",		OFFSETOF(wl_cnt_ver_11_t, rxbadds)},
	{"rxbadcm",		OFFSETOF(wl_cnt_ver_11_t, rxbadcm)},
	{"rxfragerr",		OFFSETOF(wl_cnt_ver_11_t, rxfragerr)},
	{"rxrunt",		OFFSETOF(wl_cnt_ver_11_t, rxrunt)},
	{"rxgiant",		OFFSETOF(wl_cnt_ver_11_t, rxgiant)},
	{"rxnoscb",		OFFSETOF(wl_cnt_ver_11_t, rxnoscb)},
	{"rxbadproto",		OFFSETOF(wl_cnt_ver_11_t, rxbadproto)},
	{"rxbadsrcmac",		OFFSETOF(wl_cnt_ver_11_t, rxbadsrcmac)},
	{"rxbadda",		OFFSETOF(wl_cnt_ver_11_t, rxbadda)},
	{"rxfilter",		OFFSETOF(wl_cnt_ver_11_t, rxfilter)},
	{"rxoflo",		OFFSETOF(wl_cnt_ver_11_t, rxoflo)},
	{"rxuflo[0]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[0])},
	{"rxuflo[1]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[1])},
	{"rxuflo[2]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[2])},
	{"rxuflo[3]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[3])},
	{"rxuflo[4]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[4])},
	{"rxuflo[5]",		OFFSETOF(wl_cnt_ver_11_t, rxuflo[5])},
	{"d11cnt_txrts_off",	OFFSETOF(wl_cnt_ver_11_t, d11cnt_txrts_off)},
	{"d11cnt_rxcrc_off",	OFFSETOF(wl_cnt_ver_11_t, d11cnt_rxcrc_off)},
	{"d11cnt_txnocts_off",	OFFSETOF(wl_cnt_ver_11_t, d11cnt_txnocts_off)},
	{"dmade",		OFFSETOF(wl_cnt_ver_11_t, dmade)},
	{"dmada",		OFFSETOF(wl_cnt_ver_11_t, dmada)},
	{"dmape",		OFFSETOF(wl_cnt_ver_11_t, dmape)},
	{"reset",		OFFSETOF(wl_cnt_ver_11_t, reset)},
	{"tbtt",		OFFSETOF(wl_cnt_ver_11_t, tbtt)},
	{"txdmawar",		OFFSETOF(wl_cnt_ver_11_t, txdmawar)},
	{"pkt_callback_reg_fail", OFFSETOF(wl_cnt_ver_11_t, pkt_callback_reg_fail)},
	{"d11_txfrag",		OFFSETOF(wl_cnt_ver_11_t, txfrag)},
	{"d11_txmulti",		OFFSETOF(wl_cnt_ver_11_t, txmulti)},
	{"txfail",		OFFSETOF(wl_cnt_ver_11_t, txfail)},
	{"d11_txretry",		OFFSETOF(wl_cnt_ver_11_t, txretry)},
	{"d11_txretrie",	OFFSETOF(wl_cnt_ver_11_t, txretrie)},
	{"rxdup",		OFFSETOF(wl_cnt_ver_11_t, rxdup)},
	{"d11_txrts",		OFFSETOF(wl_cnt_ver_11_t, txrts)},
	{"d11_txnocts",		OFFSETOF(wl_cnt_ver_11_t, txnocts)},
	{"d11_txnoack",		OFFSETOF(wl_cnt_ver_11_t, txnoack)},
	{"d11_rxfrag",		OFFSETOF(wl_cnt_ver_11_t, rxfrag)},
	{"d11_rxmulti",		OFFSETOF(wl_cnt_ver_11_t, rxmulti)},
	{"rxcrc",		OFFSETOF(wl_cnt_ver_11_t, rxcrc)},
	{"d11_txfrmsnt",	OFFSETOF(wl_cnt_ver_11_t, txfrmsnt)},
	{"d11_rxundec",		OFFSETOF(wl_cnt_ver_11_t, rxundec)},
	{"tkipmicfaill",	OFFSETOF(wl_cnt_ver_11_t, tkipmicfaill)},
	{"tkipcntrmsr",		OFFSETOF(wl_cnt_ver_11_t, tkipcntrmsr)},
	{"tkipreplay",		OFFSETOF(wl_cnt_ver_11_t, tkipreplay)},
	{"ccmpfmterr",		OFFSETOF(wl_cnt_ver_11_t, ccmpfmterr)},
	{"ccmpreplay",		OFFSETOF(wl_cnt_ver_11_t, ccmpreplay)},
	{"ccmpundec",		OFFSETOF(wl_cnt_ver_11_t, ccmpundec)},
	{"fourwayfail",		OFFSETOF(wl_cnt_ver_11_t, fourwayfail)},
	{"wepundec",		OFFSETOF(wl_cnt_ver_11_t, wepundec)},
	{"wepicverr",		OFFSETOF(wl_cnt_ver_11_t, wepicverr)},
	{"decsuccess",		OFFSETOF(wl_cnt_ver_11_t, decsuccess)},
	{"tkipicverr",		OFFSETOF(wl_cnt_ver_11_t, tkipicverr)},
	{"wepexcluded",		OFFSETOF(wl_cnt_ver_11_t, wepexcluded)},
	{"txchanrej",		OFFSETOF(wl_cnt_ver_11_t, txchanrej)},
	{"psmwds",		OFFSETOF(wl_cnt_ver_11_t, psmwds)},
	{"phywatchdog",		OFFSETOF(wl_cnt_ver_11_t, phywatchdog)},
	{"prq_entries_handled",	OFFSETOF(wl_cnt_ver_11_t, prq_entries_handled)},
	{"prq_undirected_entries", OFFSETOF(wl_cnt_ver_11_t, prq_undirected_entries)},
	{"prq_bad_entries",	OFFSETOF(wl_cnt_ver_11_t, prq_bad_entries)},
	{"atim_suppress_count",	OFFSETOF(wl_cnt_ver_11_t, atim_suppress_count)},
	{"bcn_template_not_ready", OFFSETOF(wl_cnt_ver_11_t, bcn_template_not_ready)},
	{"bcn_template_not_ready_done",	OFFSETOF(wl_cnt_ver_11_t, bcn_template_not_ready_done)},
	{"late_tbtt_dpc",	OFFSETOF(wl_cnt_ver_11_t, late_tbtt_dpc)},
	{"rx1mbps",		OFFSETOF(wl_cnt_ver_11_t, rx1mbps)},
	{"rx2mbps",		OFFSETOF(wl_cnt_ver_11_t, rx2mbps)},
	{"rx5mbps5",		OFFSETOF(wl_cnt_ver_11_t, rx5mbps5)},
	{"rx6mbps",		OFFSETOF(wl_cnt_ver_11_t, rx6mbps)},
	{"rx9mbps",		OFFSETOF(wl_cnt_ver_11_t, rx9mbps)},
	{"rx11mbps",		OFFSETOF(wl_cnt_ver_11_t, rx11mbps)},
	{"rx12mbps",		OFFSETOF(wl_cnt_ver_11_t, rx12mbps)},
	{"rx18mbps",		OFFSETOF(wl_cnt_ver_11_t, rx18mbps)},
	{"rx24mbps",		OFFSETOF(wl_cnt_ver_11_t, rx24mbps)},
	{"rx36mbps",		OFFSETOF(wl_cnt_ver_11_t, rx36mbps)},
	{"rx48mbps",		OFFSETOF(wl_cnt_ver_11_t, rx48mbps)},
	{"rx54mbps",		OFFSETOF(wl_cnt_ver_11_t, rx54mbps)},
	{"rx108mbps",		OFFSETOF(wl_cnt_ver_11_t, rx108mbps)},
	{"rx162mbps",		OFFSETOF(wl_cnt_ver_11_t, rx162mbps)},
	{"rx216mbps",		OFFSETOF(wl_cnt_ver_11_t, rx216mbps)},
	{"rx270mbps",		OFFSETOF(wl_cnt_ver_11_t, rx270mbps)},
	{"rx324mbps",		OFFSETOF(wl_cnt_ver_11_t, rx324mbps)},
	{"rx378mbps",		OFFSETOF(wl_cnt_ver_11_t, rx378mbps)},
	{"rx432mbps",		OFFSETOF(wl_cnt_ver_11_t, rx432mbps)},
	{"rx486mbps",		OFFSETOF(wl_cnt_ver_11_t, rx486mbps)},
	{"rx540mbps",		OFFSETOF(wl_cnt_ver_11_t, rx540mbps)},
	{"rfdisable",		OFFSETOF(wl_cnt_ver_11_t, rfdisable)},
	{"txexptime",		OFFSETOF(wl_cnt_ver_11_t, txexptime)},
	{"txmpdu_sgi",		OFFSETOF(wl_cnt_ver_11_t, txmpdu_sgi)},
	{"rxmpdu_sgi",		OFFSETOF(wl_cnt_ver_11_t, rxmpdu_sgi)},
	{"txmpdu_stbc",		OFFSETOF(wl_cnt_ver_11_t, txmpdu_stbc)},
	{"rxmpdu_stbc",		OFFSETOF(wl_cnt_ver_11_t, rxmpdu_stbc)},
	{"rxundec_mcst",	OFFSETOF(wl_cnt_ver_11_t, rxundec_mcst)},
	{"tkipmicfaill_mcst",	OFFSETOF(wl_cnt_ver_11_t, tkipmicfaill_mcst)},
	{"tkipcntrmsr_mcst",	OFFSETOF(wl_cnt_ver_11_t, tkipcntrmsr_mcst)},
	{"tkipreplay_mcst",	OFFSETOF(wl_cnt_ver_11_t, tkipreplay_mcst)},
	{"ccmpfmterr_mcst",	OFFSETOF(wl_cnt_ver_11_t, ccmpfmterr_mcst)},
	{"ccmpreplay_mcst",	OFFSETOF(wl_cnt_ver_11_t, ccmpreplay_mcst)},
	{"ccmpundec_mcst",	OFFSETOF(wl_cnt_ver_11_t, ccmpundec_mcst)},
	{"fourwayfail_mcst",	OFFSETOF(wl_cnt_ver_11_t, fourwayfail_mcst)},
	{"wepundec_mcst",	OFFSETOF(wl_cnt_ver_11_t, wepundec_mcst)},
	{"wepicverr_mcst",	OFFSETOF(wl_cnt_ver_11_t, wepicverr_mcst)},
	{"decsuccess_mcst",	OFFSETOF(wl_cnt_ver_11_t, decsuccess_mcst)},
	{"tkipicverr_mcst",	OFFSETOF(wl_cnt_ver_11_t, tkipicverr_mcst)},
	{"wepexcluded_mcst",	OFFSETOF(wl_cnt_ver_11_t, wepexcluded_mcst)},
	{"dma_hang",		OFFSETOF(wl_cnt_ver_11_t, dma_hang)},
	{"reinit",		OFFSETOF(wl_cnt_ver_11_t, reinit)},
	{"pstatxucast",		OFFSETOF(wl_cnt_ver_11_t, pstatxucast)},
	{"pstatxnoassoc",	OFFSETOF(wl_cnt_ver_11_t, pstatxnoassoc)},
	{"pstarxucast",		OFFSETOF(wl_cnt_ver_11_t, pstarxucast)},
	{"pstarxbcmc",		OFFSETOF(wl_cnt_ver_11_t, pstarxbcmc)},
	{"pstatxbcmc",		OFFSETOF(wl_cnt_ver_11_t, pstatxbcmc)},
	{"cso_passthrough",	OFFSETOF(wl_cnt_ver_11_t, cso_passthrough)},
	{"cso_normal",		OFFSETOF(wl_cnt_ver_11_t, cso_normal)},
	{"chained",		OFFSETOF(wl_cnt_ver_11_t, chained)},
	{"chainedsz1",		OFFSETOF(wl_cnt_ver_11_t, chainedsz1)},
	{"unchained",		OFFSETOF(wl_cnt_ver_11_t, unchained)},
	{"maxchainsz",		OFFSETOF(wl_cnt_ver_11_t, maxchainsz)},
	{"currchainsz",		OFFSETOF(wl_cnt_ver_11_t, currchainsz)},
	{"pciereset",		OFFSETOF(wl_cnt_ver_11_t, pciereset)},
	{"cfgrestore",		OFFSETOF(wl_cnt_ver_11_t, cfgrestore)},
	{"reinit",		OFFSETOF(wl_cnt_ver_11_t, reinit)},
	{"reinitreason[0]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[0])},
	{"reinitreason[1]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[1])},
	{"reinitreason[2]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[2])},
	{"reinitreason[3]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[3])},
	{"reinitreason[4]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[4])},
	{"reinitreason[5]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[5])},
	{"reinitreason[6]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[6])},
	{"reinitreason[7]",	OFFSETOF(wl_cnt_ver_11_t, reinitreason[7])},
	{"rxrtry",		OFFSETOF(wl_cnt_ver_11_t, rxrtry)},
	{"rxmpdu_mu",		OFFSETOF(wl_cnt_ver_11_t, rxmpdu_mu)},
	{"txbar",		OFFSETOF(wl_cnt_ver_11_t, txbar)},
	{"rxbar",		OFFSETOF(wl_cnt_ver_11_t, rxbar)},
	{"txpspoll",		OFFSETOF(wl_cnt_ver_11_t, txpspoll)},
	{"rxpspoll",		OFFSETOF(wl_cnt_ver_11_t, rxpspoll)},
	{"txnull",		OFFSETOF(wl_cnt_ver_11_t, txnull)},
	{"rxnull",		OFFSETOF(wl_cnt_ver_11_t, rxnull)},
	{"txqosnull",		OFFSETOF(wl_cnt_ver_11_t, txqosnull)},
	{"rxqosnull",		OFFSETOF(wl_cnt_ver_11_t, rxqosnull)},
	{"txassocreq",		OFFSETOF(wl_cnt_ver_11_t, txassocreq)},
	{"rxassocreq",		OFFSETOF(wl_cnt_ver_11_t, rxassocreq)},
	{"txreassocreq",	OFFSETOF(wl_cnt_ver_11_t, txreassocreq)},
	{"rxreassocreq",	OFFSETOF(wl_cnt_ver_11_t, rxreassocreq)},
	{"txdisassoc",		OFFSETOF(wl_cnt_ver_11_t, txdisassoc)},
	{"rxdisassoc",		OFFSETOF(wl_cnt_ver_11_t, rxdisassoc)},
	{"txassocrsp",		OFFSETOF(wl_cnt_ver_11_t, txassocrsp)},
	{"rxassocrsp",		OFFSETOF(wl_cnt_ver_11_t, rxassocrsp)},
	{"txreassocrsp",	OFFSETOF(wl_cnt_ver_11_t, txreassocrsp)},
	{"rxreassocrsp",	OFFSETOF(wl_cnt_ver_11_t, rxreassocrsp)},
	{"txauth",		OFFSETOF(wl_cnt_ver_11_t, txauth)},
	{"rxauth",		OFFSETOF(wl_cnt_ver_11_t, rxauth)},
	{"txdeauth",		OFFSETOF(wl_cnt_ver_11_t, txdeauth)},
	{"rxdeauth",		OFFSETOF(wl_cnt_ver_11_t, rxdeauth)},
	{"txprobereq",		OFFSETOF(wl_cnt_ver_11_t, txprobereq)},
	{"rxprobereq",		OFFSETOF(wl_cnt_ver_11_t, rxprobereq)},
	{"txprobersp",		OFFSETOF(wl_cnt_ver_11_t, txprobersp)},
	{"rxprobersp",		OFFSETOF(wl_cnt_ver_11_t, rxprobersp)},
	{"txaction",		OFFSETOF(wl_cnt_ver_11_t, txaction)},
	{"rxaction",		OFFSETOF(wl_cnt_ver_11_t, rxaction)},
	/* macstats counters */
	{"txallfrm",		OFFSETOF(wl_cnt_ver_11_t, txallfrm)},
	{"txrtsfrm",		OFFSETOF(wl_cnt_ver_11_t, txrtsfrm)},
	{"txctsfrm",		OFFSETOF(wl_cnt_ver_11_t, txctsfrm)},
	{"txackfrm",		OFFSETOF(wl_cnt_ver_11_t, txackfrm)},
	{"txdnlfrm",		OFFSETOF(wl_cnt_ver_11_t, txdnlfrm)},
	{"txbcnfrm",		OFFSETOF(wl_cnt_ver_11_t, txbcnfrm)},
	{"txfunfl[0]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[0])},
	{"txfunfl[1]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[1])},
	{"txfunfl[2]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[2])},
	{"txfunfl[3]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[3])},
	{"txfunfl[4]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[4])},
	{"txfunfl[5]",		OFFSETOF(wl_cnt_ver_11_t, txfunfl[5])},
	{"txampdu",		OFFSETOF(wl_cnt_ver_11_t, txfbw)},
	{"txmpdu",		OFFSETOF(wl_cnt_ver_11_t, txmpdu)},
	{"txtplunfl",		OFFSETOF(wl_cnt_ver_11_t, txtplunfl)},
	{"txphyerror",		OFFSETOF(wl_cnt_ver_11_t, txphyerror)},
	{"pktengrxducast",	OFFSETOF(wl_cnt_ver_11_t, pktengrxducast)},
	{"pktengrxdmcast",	OFFSETOF(wl_cnt_ver_11_t, pktengrxdmcast)},
	{"rxfrmtoolong",	OFFSETOF(wl_cnt_ver_11_t, rxfrmtoolong)},
	{"rxfrmtooshrt",	OFFSETOF(wl_cnt_ver_11_t, rxfrmtooshrt)},
	{"rxanyerr",		OFFSETOF(wl_cnt_ver_11_t, rxinvmachdr)},
	{"rxbadfcs",		OFFSETOF(wl_cnt_ver_11_t, rxbadfcs)},
	{"rxbadplcp",		OFFSETOF(wl_cnt_ver_11_t, rxbadplcp)},
	{"rxcrsglitch",		OFFSETOF(wl_cnt_ver_11_t, rxcrsglitch)},
	{"rxstrt",		OFFSETOF(wl_cnt_ver_11_t, rxstrt)},
	{"rxdtucastmbss",	OFFSETOF(wl_cnt_ver_11_t, rxdfrmucastmbss)},
	{"rxmgucastmbss",	OFFSETOF(wl_cnt_ver_11_t, rxmfrmucastmbss)},
	{"rxctlucast",		OFFSETOF(wl_cnt_ver_11_t, rxcfrmucast)},
	{"rxrtsucast",		OFFSETOF(wl_cnt_ver_11_t, rxrtsucast)},
	{"rxctsucast",		OFFSETOF(wl_cnt_ver_11_t, rxctsucast)},
	{"rxackucast",		OFFSETOF(wl_cnt_ver_11_t, rxackucast)},
	{"rxdtocast",		OFFSETOF(wl_cnt_ver_11_t, rxdfrmocast)},
	{"rxmgocast",		OFFSETOF(wl_cnt_ver_11_t, rxmfrmocast)},
	{"rxctlocast",		OFFSETOF(wl_cnt_ver_11_t, rxcfrmocast)},
	{"rxrtsocast",		OFFSETOF(wl_cnt_ver_11_t, rxrtsocast)},
	{"rxctsocast",		OFFSETOF(wl_cnt_ver_11_t, rxctsocast)},
	{"rxdtmcast",		OFFSETOF(wl_cnt_ver_11_t, rxdfrmmcast)},
	{"rxmgmcast",		OFFSETOF(wl_cnt_ver_11_t, rxmfrmmcast)},
	{"rxctlmcast",		OFFSETOF(wl_cnt_ver_11_t, rxcfrmmcast)},
	{"rxbeaconmbss",	OFFSETOF(wl_cnt_ver_11_t, rxbeaconmbss)},
	{"rxdtucastobss",	OFFSETOF(wl_cnt_ver_11_t, rxdfrmucastobss)},
	{"rxbeaconobss",	OFFSETOF(wl_cnt_ver_11_t, rxbeaconobss)},
	{"rxrsptmout",		OFFSETOF(wl_cnt_ver_11_t, rxrsptmout)},
	{"bcntxcancl",		OFFSETOF(wl_cnt_ver_11_t, bcntxcancl)},
	{"rxnodelim",		OFFSETOF(wl_cnt_ver_11_t, rxnodelim)},
	{"rxf0ovfl",		OFFSETOF(wl_cnt_ver_11_t, rxf0ovfl)},
	{"rxf1ovfl",		OFFSETOF(wl_cnt_ver_11_t, rxf1ovfl)},
	{"rxhlovfl",		OFFSETOF(wl_cnt_ver_11_t, rxf2ovfl)},
	{"missbcn_dbg",		OFFSETOF(wl_cnt_ver_11_t, txsfovfl)},
	{"pmqovfl",		OFFSETOF(wl_cnt_ver_11_t, pmqovfl)},
	{"rxcgprqfrm",		OFFSETOF(wl_cnt_ver_11_t, rxcgprqfrm)},
	{"rxcgprsqovfl",	OFFSETOF(wl_cnt_ver_11_t, rxcgprsqovfl)},
	{"txcgprsfail",		OFFSETOF(wl_cnt_ver_11_t, txcgprsfail)},
	{"txcgprssuc",		OFFSETOF(wl_cnt_ver_11_t, txcgprssuc)},
	{"prs_timeout",		OFFSETOF(wl_cnt_ver_11_t, prs_timeout)},
	{"txrtsfail",		OFFSETOF(wl_cnt_ver_11_t, rxnack)},
	{"txucast",		OFFSETOF(wl_cnt_ver_11_t, frmscons)},
	{"txinrtstxop",		OFFSETOF(wl_cnt_ver_11_t, txnack)},
	{"rxback",		OFFSETOF(wl_cnt_ver_11_t, rxback)},
	{"txback",		OFFSETOF(wl_cnt_ver_11_t, txback)},
	{"bphy_rxcrsglitch",	OFFSETOF(wl_cnt_ver_11_t, bphy_rxcrsglitch)},
	{"rxdrop20s",		OFFSETOF(wl_cnt_ver_11_t, rxdrop20s)},
	{"rxtoolate",		OFFSETOF(wl_cnt_ver_11_t, rxtoolate)},
	{"bphy_badplcp",	OFFSETOF(wl_cnt_ver_11_t, bphy_badplcp)},
	{"txbcast",		OFFSETOF(wl_cnt_ver_11_t, txbcast)},
	{"txdropped",		OFFSETOF(wl_cnt_ver_11_t, txdropped)},
	{"rxbcast",		OFFSETOF(wl_cnt_ver_11_t, rxbcast)},
	{"rxdropped",		OFFSETOF(wl_cnt_ver_11_t, rxdropped)},
	{NULL, 0},
};

#define OFFSET_MCST_V30(X) (OFFSETOF(wl_cnt_ge40mcst_v1_t, X) +\
	sizeof(wl_cnt_wlc_t))
#define OFFSET_RIRNS_V30(X) (sizeof(wl_cnt_wlc_t) +\
	WL_CNT_MCST_STRUCT_SZ + OFFSETOF(reinit_rsns_t, X))
static counter_offset_info_t cntr_offset_info_v30[] = {
	/* wl counters */
	{"txframe",		OFFSETOF(wl_cnt_wlc_t, txframe)},
	{"txbyte",		OFFSETOF(wl_cnt_wlc_t, txbyte)},
	{"txretrans",		OFFSETOF(wl_cnt_wlc_t, txretrans)},
	{"txerror",		OFFSETOF(wl_cnt_wlc_t, txerror)},
	{"txctl",		OFFSETOF(wl_cnt_wlc_t, txctl)},
	{"txprshort",		OFFSETOF(wl_cnt_wlc_t, txprshort)},
	{"txserr",		OFFSETOF(wl_cnt_wlc_t, txserr)},
	{"txnobuf",		OFFSETOF(wl_cnt_wlc_t, txnobuf)},
	{"txnoassoc",		OFFSETOF(wl_cnt_wlc_t, txnoassoc)},
	{"txrunt",		OFFSETOF(wl_cnt_wlc_t, txrunt)},
	{"txchit",		OFFSETOF(wl_cnt_wlc_t, txchit)},
	{"txcmiss",		OFFSETOF(wl_cnt_wlc_t, txcmiss)},
	{"txuflo",		OFFSETOF(wl_cnt_wlc_t, txuflo)},
	{"txphyerr",		OFFSETOF(wl_cnt_wlc_t, txphyerr)},
	{"txphycrs",		OFFSETOF(wl_cnt_wlc_t, txphycrs)},
	{"rxframe",		OFFSETOF(wl_cnt_wlc_t, rxframe)},
	{"rxbyte",		OFFSETOF(wl_cnt_wlc_t, rxbyte)},
	{"rxerror",		OFFSETOF(wl_cnt_wlc_t, rxerror)},
	{"rxctl",		OFFSETOF(wl_cnt_wlc_t, rxctl)},
	{"rxnobuf",		OFFSETOF(wl_cnt_wlc_t, rxnobuf)},
	{"rxnondata",		OFFSETOF(wl_cnt_wlc_t, rxnondata)},
	{"rxbadds",		OFFSETOF(wl_cnt_wlc_t, rxbadds)},
	{"rxbadcm",		OFFSETOF(wl_cnt_wlc_t, rxbadcm)},
	{"rxfragerr",		OFFSETOF(wl_cnt_wlc_t, rxfragerr)},
	{"rxrunt",		OFFSETOF(wl_cnt_wlc_t, rxrunt)},
	{"rxgiant",		OFFSETOF(wl_cnt_wlc_t, rxgiant)},
	{"rxnoscb",		OFFSETOF(wl_cnt_wlc_t, rxnoscb)},
	{"rxbadproto",		OFFSETOF(wl_cnt_wlc_t, rxbadproto)},
	{"rxbadsrcmac",		OFFSETOF(wl_cnt_wlc_t, rxbadsrcmac)},
	{"rxbadda",		OFFSETOF(wl_cnt_wlc_t, rxbadda)},
	{"rxfilter",		OFFSETOF(wl_cnt_wlc_t, rxfilter)},
	{"rxoflo",		OFFSETOF(wl_cnt_wlc_t, rxoflo)},
	{"rxuflo[0]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[0])},
	{"rxuflo[1]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[1])},
	{"rxuflo[2]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[2])},
	{"rxuflo[3]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[3])},
	{"rxuflo[4]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[4])},
	{"rxuflo[5]",		OFFSETOF(wl_cnt_wlc_t, rxuflo[5])},
	{"d11cnt_txrts_off",	OFFSETOF(wl_cnt_wlc_t, d11cnt_txrts_off)},
	{"d11cnt_rxcrc_off",	OFFSETOF(wl_cnt_wlc_t, d11cnt_rxcrc_off)},
	{"d11cnt_txnocts_off",	OFFSETOF(wl_cnt_wlc_t, d11cnt_txnocts_off)},
	{"dmade",		OFFSETOF(wl_cnt_wlc_t, dmade)},
	{"dmada",		OFFSETOF(wl_cnt_wlc_t, dmada)},
	{"dmape",		OFFSETOF(wl_cnt_wlc_t, dmape)},
	{"reset",		OFFSETOF(wl_cnt_wlc_t, reset)},
	{"tbtt",		OFFSETOF(wl_cnt_wlc_t, tbtt)},
	{"txdmawar",		OFFSETOF(wl_cnt_wlc_t, txdmawar)},
	{"pkt_callback_reg_fail", OFFSETOF(wl_cnt_wlc_t, pkt_callback_reg_fail)},
	{"d11_txfrag",		OFFSETOF(wl_cnt_wlc_t, txfrag)},
	{"d11_txmulti",		OFFSETOF(wl_cnt_wlc_t, txmulti)},
	{"txfail",		OFFSETOF(wl_cnt_wlc_t, txfail)},
	{"d11_txretry",		OFFSETOF(wl_cnt_wlc_t, txretry)},
	{"d11_txretrie",	OFFSETOF(wl_cnt_wlc_t, txretrie)},
	{"rxdup",		OFFSETOF(wl_cnt_wlc_t, rxdup)},
	{"d11_txrts",		OFFSETOF(wl_cnt_wlc_t, txrts)},
	{"d11_txnocts",		OFFSETOF(wl_cnt_wlc_t, txnocts)},
	{"d11_txnoack",		OFFSETOF(wl_cnt_wlc_t, txnoack)},
	{"d11_rxfrag",		OFFSETOF(wl_cnt_wlc_t, rxfrag)},
	{"d11_rxmulti",		OFFSETOF(wl_cnt_wlc_t, rxmulti)},
	{"rxcrc",		OFFSETOF(wl_cnt_wlc_t, rxcrc)},
	{"d11_txfrmsnt",	OFFSETOF(wl_cnt_wlc_t, txfrmsnt)},
	{"d11_rxundec",		OFFSETOF(wl_cnt_wlc_t, rxundec)},
	{"tkipmicfaill",	OFFSETOF(wl_cnt_wlc_t, tkipmicfaill)},
	{"tkipcntrmsr",		OFFSETOF(wl_cnt_wlc_t, tkipcntrmsr)},
	{"tkipreplay",		OFFSETOF(wl_cnt_wlc_t, tkipreplay)},
	{"ccmpfmterr",		OFFSETOF(wl_cnt_wlc_t, ccmpfmterr)},
	{"ccmpreplay",		OFFSETOF(wl_cnt_wlc_t, ccmpreplay)},
	{"ccmpundec",		OFFSETOF(wl_cnt_wlc_t, ccmpundec)},
	{"fourwayfail",		OFFSETOF(wl_cnt_wlc_t, fourwayfail)},
	{"wepundec",		OFFSETOF(wl_cnt_wlc_t, wepundec)},
	{"wepicverr",		OFFSETOF(wl_cnt_wlc_t, wepicverr)},
	{"decsuccess",		OFFSETOF(wl_cnt_wlc_t, decsuccess)},
	{"tkipicverr",		OFFSETOF(wl_cnt_wlc_t, tkipicverr)},
	{"wepexcluded",		OFFSETOF(wl_cnt_wlc_t, wepexcluded)},
	{"txchanrej",		OFFSETOF(wl_cnt_wlc_t, txchanrej)},
	{"psmwds",		OFFSETOF(wl_cnt_wlc_t, psmwds)},
	{"phywatchdog",		OFFSETOF(wl_cnt_wlc_t, phywatchdog)},
	{"prq_entries_handled",	OFFSETOF(wl_cnt_wlc_t, prq_entries_handled)},
	{"prq_undirected_entries", OFFSETOF(wl_cnt_wlc_t, prq_undirected_entries)},
	{"prq_bad_entries",	OFFSETOF(wl_cnt_wlc_t, prq_bad_entries)},
	{"atim_suppress_count",	OFFSETOF(wl_cnt_wlc_t, atim_suppress_count)},
	{"bcn_template_not_ready", OFFSETOF(wl_cnt_wlc_t, bcn_template_not_ready)},
	{"bcn_template_not_ready_done",	OFFSETOF(wl_cnt_wlc_t, bcn_template_not_ready_done)},
	{"late_tbtt_dpc",	OFFSETOF(wl_cnt_wlc_t, late_tbtt_dpc)},
	{"rx1mbps",		OFFSETOF(wl_cnt_wlc_t, rx1mbps)},
	{"rx2mbps",		OFFSETOF(wl_cnt_wlc_t, rx2mbps)},
	{"rx5mbps5",		OFFSETOF(wl_cnt_wlc_t, rx5mbps5)},
	{"rx6mbps",		OFFSETOF(wl_cnt_wlc_t, rx6mbps)},
	{"rx9mbps",		OFFSETOF(wl_cnt_wlc_t, rx9mbps)},
	{"rx11mbps",		OFFSETOF(wl_cnt_wlc_t, rx11mbps)},
	{"rx12mbps",		OFFSETOF(wl_cnt_wlc_t, rx12mbps)},
	{"rx18mbps",		OFFSETOF(wl_cnt_wlc_t, rx18mbps)},
	{"rx24mbps",		OFFSETOF(wl_cnt_wlc_t, rx24mbps)},
	{"rx36mbps",		OFFSETOF(wl_cnt_wlc_t, rx36mbps)},
	{"rx48mbps",		OFFSETOF(wl_cnt_wlc_t, rx48mbps)},
	{"rx54mbps",		OFFSETOF(wl_cnt_wlc_t, rx54mbps)},
	{"rx108mbps",		OFFSETOF(wl_cnt_wlc_t, rx108mbps)},
	{"rx162mbps",		OFFSETOF(wl_cnt_wlc_t, rx162mbps)},
	{"rx216mbps",		OFFSETOF(wl_cnt_wlc_t, rx216mbps)},
	{"rx270mbps",		OFFSETOF(wl_cnt_wlc_t, rx270mbps)},
	{"rx324mbps",		OFFSETOF(wl_cnt_wlc_t, rx324mbps)},
	{"rx378mbps",		OFFSETOF(wl_cnt_wlc_t, rx378mbps)},
	{"rx432mbps",		OFFSETOF(wl_cnt_wlc_t, rx432mbps)},
	{"rx486mbps",		OFFSETOF(wl_cnt_wlc_t, rx486mbps)},
	{"rx540mbps",		OFFSETOF(wl_cnt_wlc_t, rx540mbps)},
	{"rfdisable",		OFFSETOF(wl_cnt_wlc_t, rfdisable)},
	{"txexptime",		OFFSETOF(wl_cnt_wlc_t, txexptime)},
	{"txmpdu_sgi",		OFFSETOF(wl_cnt_wlc_t, txmpdu_sgi)},
	{"rxmpdu_sgi",		OFFSETOF(wl_cnt_wlc_t, rxmpdu_sgi)},
	{"txmpdu_stbc",		OFFSETOF(wl_cnt_wlc_t, txmpdu_stbc)},
	{"rxmpdu_stbc",		OFFSETOF(wl_cnt_wlc_t, rxmpdu_stbc)},
	{"rxundec_mcst",	OFFSETOF(wl_cnt_wlc_t, rxundec_mcst)},
	{"tkipmicfaill_mcst",	OFFSETOF(wl_cnt_wlc_t, tkipmicfaill_mcst)},
	{"tkipcntrmsr_mcst",	OFFSETOF(wl_cnt_wlc_t, tkipcntrmsr_mcst)},
	{"tkipreplay_mcst",	OFFSETOF(wl_cnt_wlc_t, tkipreplay_mcst)},
	{"ccmpfmterr_mcst",	OFFSETOF(wl_cnt_wlc_t, ccmpfmterr_mcst)},
	{"ccmpreplay_mcst",	OFFSETOF(wl_cnt_wlc_t, ccmpreplay_mcst)},
	{"ccmpundec_mcst",	OFFSETOF(wl_cnt_wlc_t, ccmpundec_mcst)},
	{"fourwayfail_mcst",	OFFSETOF(wl_cnt_wlc_t, fourwayfail_mcst)},
	{"wepundec_mcst",	OFFSETOF(wl_cnt_wlc_t, wepundec_mcst)},
	{"wepicverr_mcst",	OFFSETOF(wl_cnt_wlc_t, wepicverr_mcst)},
	{"decsuccess_mcst",	OFFSETOF(wl_cnt_wlc_t, decsuccess_mcst)},
	{"tkipicverr_mcst",	OFFSETOF(wl_cnt_wlc_t, tkipicverr_mcst)},
	{"wepexcluded_mcst",	OFFSETOF(wl_cnt_wlc_t, wepexcluded_mcst)},
	{"dma_hang",		OFFSETOF(wl_cnt_wlc_t, dma_hang)},
	{"reinit",		OFFSETOF(wl_cnt_wlc_t, reinit)},
	{"pstatxucast",		OFFSETOF(wl_cnt_wlc_t, pstatxucast)},
	{"pstatxnoassoc",	OFFSETOF(wl_cnt_wlc_t, pstatxnoassoc)},
	{"pstarxucast",		OFFSETOF(wl_cnt_wlc_t, pstarxucast)},
	{"pstarxbcmc",		OFFSETOF(wl_cnt_wlc_t, pstarxbcmc)},
	{"pstatxbcmc",		OFFSETOF(wl_cnt_wlc_t, pstatxbcmc)},
	{"cso_passthrough",	OFFSETOF(wl_cnt_wlc_t, cso_passthrough)},
	{"cso_normal",		OFFSETOF(wl_cnt_wlc_t, cso_normal)},
	{"chained",		OFFSETOF(wl_cnt_wlc_t, chained)},
	{"chainedsz1",		OFFSETOF(wl_cnt_wlc_t, chainedsz1)},
	{"unchained",		OFFSETOF(wl_cnt_wlc_t, unchained)},
	{"maxchainsz",		OFFSETOF(wl_cnt_wlc_t, maxchainsz)},
	{"currchainsz",		OFFSETOF(wl_cnt_wlc_t, currchainsz)},
	{"pciereset",		OFFSETOF(wl_cnt_wlc_t, pciereset)},
	{"cfgrestore",		OFFSETOF(wl_cnt_wlc_t, cfgrestore)},
	{"reinitreason[0]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[0])},
	{"reinitreason[1]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[1])},
	{"reinitreason[2]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[2])},
	{"reinitreason[3]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[3])},
	{"reinitreason[4]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[4])},
	{"reinitreason[5]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[5])},
	{"reinitreason[6]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[6])},
	{"reinitreason[7]",	OFFSETOF(wl_cnt_wlc_t, reinitreason[7])},
	{"rxrtry",		OFFSETOF(wl_cnt_wlc_t, rxrtry)},
	{"rxmpdu_mu",		OFFSETOF(wl_cnt_wlc_t, rxmpdu_mu)},
	{"txbar",		OFFSETOF(wl_cnt_wlc_t, txbar)},
	{"rxbar",		OFFSETOF(wl_cnt_wlc_t, rxbar)},
	{"txpspoll",		OFFSETOF(wl_cnt_wlc_t, txpspoll)},
	{"rxpspoll",		OFFSETOF(wl_cnt_wlc_t, rxpspoll)},
	{"txnull",		OFFSETOF(wl_cnt_wlc_t, txnull)},
	{"rxnull",		OFFSETOF(wl_cnt_wlc_t, rxnull)},
	{"txqosnull",		OFFSETOF(wl_cnt_wlc_t, txqosnull)},
	{"rxqosnull",		OFFSETOF(wl_cnt_wlc_t, rxqosnull)},
	{"txassocreq",		OFFSETOF(wl_cnt_wlc_t, txassocreq)},
	{"rxassocreq",		OFFSETOF(wl_cnt_wlc_t, rxassocreq)},
	{"txreassocreq",	OFFSETOF(wl_cnt_wlc_t, txreassocreq)},
	{"rxreassocreq",	OFFSETOF(wl_cnt_wlc_t, rxreassocreq)},
	{"txdisassoc",		OFFSETOF(wl_cnt_wlc_t, txdisassoc)},
	{"rxdisassoc",		OFFSETOF(wl_cnt_wlc_t, rxdisassoc)},
	{"txassocrsp",		OFFSETOF(wl_cnt_wlc_t, txassocrsp)},
	{"rxassocrsp",		OFFSETOF(wl_cnt_wlc_t, rxassocrsp)},
	{"txreassocrsp",	OFFSETOF(wl_cnt_wlc_t, txreassocrsp)},
	{"rxreassocrsp",	OFFSETOF(wl_cnt_wlc_t, rxreassocrsp)},
	{"txauth",		OFFSETOF(wl_cnt_wlc_t, txauth)},
	{"rxauth",		OFFSETOF(wl_cnt_wlc_t, rxauth)},
	{"txdeauth",		OFFSETOF(wl_cnt_wlc_t, txdeauth)},
	{"rxdeauth",		OFFSETOF(wl_cnt_wlc_t, rxdeauth)},
	{"txprobereq",		OFFSETOF(wl_cnt_wlc_t, txprobereq)},
	{"rxprobereq",		OFFSETOF(wl_cnt_wlc_t, rxprobereq)},
	{"txprobersp",		OFFSETOF(wl_cnt_wlc_t, txprobersp)},
	{"rxprobersp",		OFFSETOF(wl_cnt_wlc_t, rxprobersp)},
	{"txaction",		OFFSETOF(wl_cnt_wlc_t, txaction)},
	{"rxaction",		OFFSETOF(wl_cnt_wlc_t, rxaction)},
	{"ampdu_wds",		OFFSETOF(wl_cnt_wlc_t, ampdu_wds)},
	{"txlost",		OFFSETOF(wl_cnt_wlc_t, txlost)},
	{"txdatamcast",		OFFSETOF(wl_cnt_wlc_t, txdatamcast)},
	{"txdatabcast",		OFFSETOF(wl_cnt_wlc_t, txdatabcast)},
	{"psmxwds",		OFFSETOF(wl_cnt_wlc_t, psmxwds)},
	{"rxback",		OFFSETOF(wl_cnt_wlc_t, rxback)},
	{"txback",		OFFSETOF(wl_cnt_wlc_t, txback)},
	{"p2p_tbtt",		OFFSETOF(wl_cnt_wlc_t, p2p_tbtt)},
	{"p2p_tbtt_miss",		OFFSETOF(wl_cnt_wlc_t, p2p_tbtt_miss)},
	{"txqueue_start",       OFFSETOF(wl_cnt_wlc_t, txqueue_start)},
	{"txqueue_end",         OFFSETOF(wl_cnt_wlc_t, txqueue_end)},
	{"txbcast",             OFFSETOF(wl_cnt_wlc_t, txbcast)},
	{"txdropped",           OFFSETOF(wl_cnt_wlc_t, txdropped)},
	{"rxbcast",             OFFSETOF(wl_cnt_wlc_t, rxbcast)},
	{"rxdropped",           OFFSETOF(wl_cnt_wlc_t, rxdropped)},
	/* macstats counters */
	{"txallfrm",		OFFSET_MCST_V30(txallfrm)},
	{"txrtsfrm",		OFFSET_MCST_V30(txrtsfrm)},
	{"txctsfrm",		OFFSET_MCST_V30(txctsfrm)},
	{"txackfrm",		OFFSET_MCST_V30(txackfrm)},
	{"txdnlfrm",		OFFSET_MCST_V30(txdnlfrm)},
	{"txbcnfrm",		OFFSET_MCST_V30(txbcnfrm)},
	{"txfunfl[0]",		OFFSET_MCST_V30(txfunfl[0])},
	{"txfunfl[1]",		OFFSET_MCST_V30(txfunfl[1])},
	{"txfunfl[2]",		OFFSET_MCST_V30(txfunfl[2])},
	{"txfunfl[3]",		OFFSET_MCST_V30(txfunfl[3])},
	{"txfunfl[4]",		OFFSET_MCST_V30(txfunfl[4])},
	{"txfunfl[5]",		OFFSET_MCST_V30(txfunfl[5])},
	{"txampdu",		OFFSET_MCST_V30(txampdu)},
	{"txmpdu",		OFFSET_MCST_V30(txmpdu)},
	{"txtplunfl",		OFFSET_MCST_V30(txtplunfl)},
	{"txphyerror",		OFFSET_MCST_V30(txphyerror)},
	{"pktengrxducast",	OFFSET_MCST_V30(pktengrxducast)},
	{"pktengrxdmcast",	OFFSET_MCST_V30(pktengrxdmcast)},
	{"rxfrmtoolong",	OFFSET_MCST_V30(rxfrmtoolong)},
	{"rxfrmtooshrt",	OFFSET_MCST_V30(rxfrmtooshrt)},
	{"rxanyerr",		OFFSET_MCST_V30(rxanyerr)},
	{"rxbadfcs",		OFFSET_MCST_V30(rxbadfcs)},
	{"rxbadplcp",		OFFSET_MCST_V30(rxbadplcp)},
	{"rxcrsglitch",		OFFSET_MCST_V30(rxcrsglitch)},
	{"rxstrt",		OFFSET_MCST_V30(rxstrt)},
	{"rxdtucastmbss",	OFFSET_MCST_V30(rxdtucastmbss)},
	{"rxmgucastmbss",	OFFSET_MCST_V30(rxmgucastmbss)},
	{"rxctlucast",		OFFSET_MCST_V30(rxctlucast)},
	{"rxrtsucast",		OFFSET_MCST_V30(rxrtsucast)},
	{"rxctsucast",		OFFSET_MCST_V30(rxctsucast)},
	{"rxackucast",		OFFSET_MCST_V30(rxackucast)},
	{"rxdtocast",		OFFSET_MCST_V30(rxdtocast)},
	{"rxmgocast",		OFFSET_MCST_V30(rxmgocast)},
	{"rxctlocast",		OFFSET_MCST_V30(rxctlocast)},
	{"rxrtsocast",		OFFSET_MCST_V30(rxrtsocast)},
	{"rxctsocast",		OFFSET_MCST_V30(rxctsocast)},
	{"rxdtmcast",		OFFSET_MCST_V30(rxdtmcast)},
	{"rxmgmcast",		OFFSET_MCST_V30(rxmgmcast)},
	{"rxctlmcast",		OFFSET_MCST_V30(rxctlmcast)},
	{"rxbeaconmbss",	OFFSET_MCST_V30(rxbeaconmbss)},
	{"rxdtucastobss",	OFFSET_MCST_V30(rxdtucastobss)},
	{"rxbeaconobss",	OFFSET_MCST_V30(rxbeaconobss)},
	{"rxrsptmout",		OFFSET_MCST_V30(rxrsptmout)},
	{"bcntxcancl",		OFFSET_MCST_V30(bcntxcancl)},
	{"rxnodelim",		OFFSET_MCST_V30(rxnodelim)},
	{"rxf0ovfl",		OFFSET_MCST_V30(rxf0ovfl)},
	{"rxf1ovfl",		OFFSET_MCST_V30(rxf1ovfl)},
	{"rxhlovfl",		OFFSET_MCST_V30(rxhlovfl)},
	{"missbcn_dbg",		OFFSET_MCST_V30(missbcn_dbg)},
	{"pmqovfl",		OFFSET_MCST_V30(pmqovfl)},
	{"rxcgprqfrm",		OFFSET_MCST_V30(rxcgprqfrm)},
	{"rxcgprsqovfl",	OFFSET_MCST_V30(rxcgprsqovfl)},
	{"txcgprsfail",		OFFSET_MCST_V30(txcgprsfail)},
	{"txcgprssuc",		OFFSET_MCST_V30(txcgprssuc)},
	{"prs_timeout",		OFFSET_MCST_V30(prs_timeout)},
	{"txrtsfail",		OFFSET_MCST_V30(txrtsfail)},
	{"txucast",		OFFSET_MCST_V30(txucast)},
	{"txinrtstxop",		OFFSET_MCST_V30(txinrtstxop)},
	{"rxback",		OFFSET_MCST_V30(rxback)},
	{"txback",		OFFSET_MCST_V30(txback)},
	{"bphy_rxcrsglitch",	OFFSET_MCST_V30(bphy_rxcrsglitch)},
	{"rxdrop20s",		OFFSET_MCST_V30(rxdrop20s)},
	{"rxtoolate",		OFFSET_MCST_V30(rxtoolate)},
	{"bphy_badplcp",	OFFSET_MCST_V30(bphy_badplcp)},
	/* reinitreason counter */
	{"reinitreason_counts[0]",	OFFSET_RIRNS_V30(rsn[0])},
	{"reinitreason_counts[1]",	OFFSET_RIRNS_V30(rsn[1])},
	{"reinitreason_counts[2]",	OFFSET_RIRNS_V30(rsn[2])},
	{"reinitreason_counts[3]",	OFFSET_RIRNS_V30(rsn[3])},
	{"reinitreason_counts[4]",	OFFSET_RIRNS_V30(rsn[4])},
	{"reinitreason_counts[5]",	OFFSET_RIRNS_V30(rsn[5])},
	{"reinitreason_counts[6]",	OFFSET_RIRNS_V30(rsn[6])},
	{"reinitreason_counts[7]",	OFFSET_RIRNS_V30(rsn[7])},
	{"reinitreason_counts[8]",	OFFSET_RIRNS_V30(rsn[8])},
	{"reinitreason_counts[9]",	OFFSET_RIRNS_V30(rsn[9])},
	{"reinitreason_counts[10]",	OFFSET_RIRNS_V30(rsn[10])},
	{"reinitreason_counts[11]",	OFFSET_RIRNS_V30(rsn[11])},
	{"reinitreason_counts[12]",	OFFSET_RIRNS_V30(rsn[12])},
	{"reinitreason_counts[13]",	OFFSET_RIRNS_V30(rsn[13])},
	{"reinitreason_counts[14]",	OFFSET_RIRNS_V30(rsn[14])},
	{"reinitreason_counts[15]",	OFFSET_RIRNS_V30(rsn[15])},
	{"reinitreason_counts[16]",	OFFSET_RIRNS_V30(rsn[16])},
	{"reinitreason_counts[17]",	OFFSET_RIRNS_V30(rsn[17])},
	{"reinitreason_counts[18]",	OFFSET_RIRNS_V30(rsn[18])},
	{"reinitreason_counts[19]",	OFFSET_RIRNS_V30(rsn[19])},
	{"reinitreason_counts[20]",	OFFSET_RIRNS_V30(rsn[20])},
	{"reinitreason_counts[21]",	OFFSET_RIRNS_V30(rsn[21])},
	{"reinitreason_counts[22]",	OFFSET_RIRNS_V30(rsn[22])},
	{"reinitreason_counts[23]",	OFFSET_RIRNS_V30(rsn[23])},
	{"reinitreason_counts[24]",	OFFSET_RIRNS_V30(rsn[24])},
	{"reinitreason_counts[25]",	OFFSET_RIRNS_V30(rsn[25])},
	{"reinitreason_counts[26]",	OFFSET_RIRNS_V30(rsn[26])},
	{"reinitreason_counts[27]",	OFFSET_RIRNS_V30(rsn[27])},
	{"reinitreason_counts[28]",	OFFSET_RIRNS_V30(rsn[28])},
	{"reinitreason_counts[29]",	OFFSET_RIRNS_V30(rsn[29])},
	{"reinitreason_counts[30]",	OFFSET_RIRNS_V30(rsn[30])},
	{"reinitreason_counts[31]",	OFFSET_RIRNS_V30(rsn[31])},
	{"reinitreason_counts[32]",	OFFSET_RIRNS_V30(rsn[32])},
	{"reinitreason_counts[33]",	OFFSET_RIRNS_V30(rsn[33])},
	{"reinitreason_counts[34]",	OFFSET_RIRNS_V30(rsn[34])},
	{"reinitreason_counts[35]",	OFFSET_RIRNS_V30(rsn[35])},
	{"reinitreason_counts[36]",	OFFSET_RIRNS_V30(rsn[36])},
	{"reinitreason_counts[37]",	OFFSET_RIRNS_V30(rsn[37])},
	{"reinitreason_counts[38]",	OFFSET_RIRNS_V30(rsn[38])},
	{"reinitreason_counts[39]",	OFFSET_RIRNS_V30(rsn[39])},
	{"reinitreason_counts[40]",	OFFSET_RIRNS_V30(rsn[40])},
	{"reinitreason_counts[41]",	OFFSET_RIRNS_V30(rsn[41])},
	{"reinitreason_counts[42]",	OFFSET_RIRNS_V30(rsn[42])},
	{"reinitreason_counts[43]",	OFFSET_RIRNS_V30(rsn[43])},
	{"reinitreason_counts[44]",	OFFSET_RIRNS_V30(rsn[44])},
	{"reinitreason_counts[45]",	OFFSET_RIRNS_V30(rsn[45])},
	{"reinitreason_counts[46]",	OFFSET_RIRNS_V30(rsn[46])},
	{"reinitreason_counts[47]",	OFFSET_RIRNS_V30(rsn[47])},
	{"reinitreason_counts[48]",	OFFSET_RIRNS_V30(rsn[48])},
	{"reinitreason_counts[49]",	OFFSET_RIRNS_V30(rsn[49])},
	{"reinitreason_counts[50]",	OFFSET_RIRNS_V30(rsn[50])},
	{"reinitreason_counts[51]",	OFFSET_RIRNS_V30(rsn[51])},
	{NULL, 0},
};

static ver_to_cntr_offset_info_t ver_to_cntr_offset_info_tbl[] = {
	{&cntr_offset_info_v6[0],	6},
	{&cntr_offset_info_v11[0],	11},
	{&cntr_offset_info_v30[0],	30},
	{NULL,				0}
};

static const struct cnt_properties_s cnt_props[] = {
	{"active_ant", 0},
	{"ampdu_wds", CAT_AMPDU},
	{"auto_en", 0},
	{"avg_snr_per_ant0", 0},
	{"avg_snr_per_ant1", 0},
	{"avg_snr_per_ant2", 0},
	{"bcntxcancl",       CAT_TX | CAT_ERR | CAT_MCAST | CAT_UCODE},
	{"bphy_badplcp",     CAT_ERR | CAT_UCODE},
	{"bphy_rxcrsglitch", CAT_RX | CAT_ERR | CAT_UCODE},
	{"ccmpfmterr",       CAT_SEC | CAT_ERR},
	{"ccmpreplay",       CAT_SEC | CAT_ERR},
	{"ccmpundec",        CAT_SEC | CAT_ERR},
	{"cell_policy",      0},
	{"cfgrestore",       0},
	{"chained",          0},
	{"chainedsz1",       0},
	{"cso_normal",       0},
	{"cso_passthrough",  0},
	{"currchainsz",      0},
	{"dbgoff46", CAT_UCODE},
	{"dbgoff47", CAT_UCODE},
	{"dbgoff48", CAT_UCODE},
	{"decsuccess",       0},
	{"dma_hang",         CAT_ERR},
	{"fourwayfail",      CAT_ERR | CAT_CTRL | CAT_SEC | CAT_ASSOC},
	{"frmscons",         0},
	{"m2vmsg",           0},
	{"macxsusp",         0},
	{"maxchainsz",       0},
	{"mboxout",          0},
	{"missbcn_dbg",      CAT_ERR | CAT_MCAST | CAT_UCODE | CAT_CTRL},
	{"musnd",            CAT_CTRL},
	{"mws_antsel_ovr_rx", CAT_RX},
	{"mws_antsel_ovr_tx", CAT_TX},
	{"p2p_tbtt",       0},
	{"p2p_tbtt_miss",  CAT_ERR},
	{"pciereset",      CAT_ERR},
	{"phywatch",       CAT_UCODE},
	{"pktengrxdmcast", CAT_RX | CAT_MCAST | CAT_UCODE},
	{"pktengrxducast", CAT_RX | CAT_UCAST | CAT_UCODE},
	{"pmqovfl",        CAT_ERR | CAT_UCODE},
	{"prs_timeout",    CAT_ERR | CAT_UCODE},
	{"reinit",     CAT_ERR},
	{"reinitreason_counts",     CAT_ERR},
	{"reset",      CAT_ERR},
	{"rx11mbps",   CAT_RX},
	{"rx12mbps",   CAT_RX},
	{"rx18mbps",   CAT_RX},
	{"rx1mbps",    CAT_RX},
	{"rx24mbps",   CAT_RX},
	{"rx2mbps",    CAT_RX},
	{"rx36mbps",   CAT_RX},
	{"rx48mbps",   CAT_RX},
	{"rx54mbps",   CAT_RX},
	{"rx5mbps5",   CAT_RX},
	{"rx6mbps",    CAT_RX},
	{"rx9mbps",    CAT_RX},
	{"rx_policy",  CAT_RX},
	{"rxackucast", CAT_RX | CAT_UCAST | CAT_UCODE},
	{"rxaction",   CAT_RX | CAT_CTRL},
	{"rxanyerr",   CAT_RX | CAT_UCODE},
	{"rxassocreq", CAT_RX | CAT_CTRL | CAT_ASSOC},
	{"rxassocrsp", CAT_RX | CAT_CTRL | CAT_ASSOC},
	{"rxauth",  CAT_RX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
	{"rxback",  CAT_RX | CAT_UCODE},
	{"rxbadcm", CAT_RX | CAT_ERR | CAT_SEC},
	{"rxbadda", CAT_RX | CAT_CTRL},
	{"rxbadds", CAT_RX | CAT_CTRL},
	{"rxbadfcs",     CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxbadplcp",    CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxbadproto",   CAT_RX | CAT_ERR},
	{"rxbadsrcmac",  CAT_RX | CAT_ERR},
	{"rxbar",        CAT_RX | CAT_AMPDU | CAT_CTRL},
	{"rxbeaconmbss", CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxbeaconobss", CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxbyte",       CAT_RX},
	{"rxcfrmmcast",  CAT_RX | CAT_MCAST | CAT_CTRL},
	{"rxcfrmocast",  CAT_RX | CAT_CTRL},
	{"rxcfrmucast",  CAT_RX | CAT_UCAST | CAT_CTRL},
	{"rxcgprqfrm",   CAT_RX | CAT_UCODE},
	{"rxcgprsqovfl", CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxcount",      CAT_RX},
	{"rxcrc",        CAT_RX},
	{"rxcrsglitch",  CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxctl",        CAT_RX | CAT_CTRL},
	{"rxctlmcast",   CAT_RX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
	{"rxctlocast",      CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxctlucast",      CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
	{"rxctsocast",      CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxctsucast",      CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
	{"rxdeauth",        CAT_RX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
	{"rxdfrmmcast",     CAT_RX | CAT_MCAST},
	{"rxdfrmocast",     CAT_RX},
	{"rxdfrmucastmbss", CAT_RX | CAT_UCAST},
	{"rxdfrmucastobss", CAT_RX | CAT_UCAST},
	{"rxdisassoc",      CAT_RX | CAT_ERR | CAT_ASSOC},
	{"rxdrop20s",       CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxdtmcast",       CAT_RX | CAT_MCAST | CAT_UCODE},
	{"rxdtocast",       CAT_RX | CAT_UCODE},
	{"rxdtucastmbss",   CAT_RX | CAT_UCAST | CAT_UCODE},
	{"rxdtucastobss",   CAT_RX | CAT_UCAST | CAT_UCODE},
	{"rxdup",        CAT_RX | CAT_ERR},
	{"rxerror",      CAT_RX | CAT_ERR},
	{"rxf0ovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxf1ovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxf2ovfl",     CAT_RX | CAT_ERR},
	{"rxfilter",     CAT_RX},
	{"rxfrag",       CAT_RX},
	{"rxfragerr",    CAT_RX | CAT_ERR},
	{"rxframe",      CAT_RX},
	{"rxfrmtoolong", CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxfrmtooshrt", CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxgiant",      CAT_RX},
	{"rxhlovfl",     CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxinvmachdr",  CAT_RX},
	{"rxmfrmmcast",  CAT_RX | CAT_MCAST},
	{"rxmfrmocast",  CAT_RX},
	{"rxmfrmucastmbss", CAT_RX | CAT_UCAST},
	{"rxmgmcast",       CAT_RX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
	{"rxmgocast",       CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxmgucastmbss",   CAT_RX| CAT_UCAST | CAT_UCODE | CAT_CTRL},
	{"rxmpdu_mu",    CAT_RX},
	{"rxmpdu_sgi",   CAT_RX},
	{"rxmpdu_stbc",  CAT_RX},
	{"rxmulti",      CAT_RX | CAT_MCAST},
	{"rxnack",       CAT_RX | CAT_ERR},
	{"rxnobuf",      CAT_RX | CAT_ERR},
	{"rxnodelim",    CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxnondata",    CAT_RX | CAT_ERR | CAT_CTRL},
	{"rxnoscb",      CAT_RX | CAT_ERR},
	{"rxnull",       CAT_RX | CAT_ERR},
	{"rxprobereq",   CAT_RX | CAT_CTRL},
	{"rxprobersp",   CAT_RX | CAT_CTRL},
	{"rxpspoll",     CAT_RX | CAT_CTRL},
	{"rxqosnull",    CAT_RX},
	{"rxreassocreq", CAT_RX | CAT_CTRL | CAT_ASSOC},
	{"rxreassocrsp", CAT_RX | CAT_CTRL | CAT_ASSOC},
	{"rxrsptmout",   CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxrtry",       CAT_RX | CAT_ERR},
	{"rxrtsocast",   CAT_RX | CAT_UCODE | CAT_CTRL},
	{"rxrtsucast",   CAT_RX | CAT_UCAST | CAT_UCODE | CAT_CTRL},
	{"rxrunt",       CAT_RX | CAT_ERR},
	{"rxstrt",       CAT_RX | CAT_UCODE},
	{"rxtoolate",    CAT_RX | CAT_ERR | CAT_UCODE},
	{"rxuflo",    CAT_RX | CAT_ERR},
	{"rxundec",      CAT_RX | CAT_SEC},
	{"sfb2v",        0},
	{"swap_alivecheck0",   0},
	{"swap_alivecheck1",   0},
	{"swap_ge_rxcount0",   CAT_RX},
	{"swap_ge_rxcount1",   CAT_RX},
	{"swap_ge_snrthresh0", 0},
	{"swap_ge_snrthresh1", 0},
	{"swap_snrdrop0", 0},
	{"swap_snrdrop1", 0},
	{"swap_timer0", 0},
	{"swap_timer1", 0},
	{"swap_trig_event_id", 0},
	{"swap_txfail0", CAT_TX | CAT_ERR},
	{"swap_txfail1", CAT_TX | CAT_ERR},
	{"tbtt", 0},
	{"tkipcntrmsr", CAT_SEC},
	{"tkipicverr", CAT_SEC},
	{"tkipmicfaill", CAT_ERR | CAT_SEC},
	{"tkipreplay", CAT_ERR | CAT_SEC},
	{"tx_active_ant", CAT_TX},
	{"tx_auto_en", CAT_TX},
	{"tx_policy", CAT_TX},
	{"txackfrm", CAT_TX | CAT_UCAST | CAT_UCODE},
	{"txaction", CAT_TX | CAT_CTRL},
	{"txallfrm", CAT_TX | CAT_UCODE},
	{"txampdu", CAT_TX | CAT_AMPDU | CAT_UCODE},
	{"txassocreq", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txassocrsp", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txauth", CAT_TX | CAT_CTRL | CAT_SEC | CAT_ASSOC},
	{"txback", CAT_TX | CAT_UCODE},
	{"txbar", CAT_TX | CAT_AMPDU},
	{"txbcnfrm", CAT_TX | CAT_MCAST | CAT_UCODE | CAT_CTRL},
	{"txbyte", CAT_TX},
	{"txcgprsfail", CAT_TX | CAT_ERR | CAT_UCODE},
	{"txcgprssuc", CAT_TX | CAT_UCODE},
	{"txchanrej", CAT_TX | CAT_ERR},
	{"txchit", CAT_TX},
	{"txcmiss", CAT_TX | CAT_ERR},
	{"txctsfrm", CAT_TX | CAT_UCODE | CAT_CTRL},
	{"txdatabcast", CAT_TX | CAT_MCAST},
	{"txdatamcast", CAT_TX | CAT_MCAST},
	{"txdeauth", CAT_TX | CAT_ERR | CAT_CTRL | CAT_SEC | CAT_ASSOC},
	{"txdisassoc", CAT_TX | CAT_ERR | CAT_CTRL | CAT_ASSOC},
	{"txdmawar", CAT_TX | CAT_ERR},
	{"txdnlfrm", CAT_TX | CAT_UCODE},
	{"txerror", CAT_TX | CAT_ERR},
	{"txfail", CAT_TX | CAT_ERR},
	{"txfbw", CAT_TX},
	{"txfrag", CAT_TX},
	{"txfrag", CAT_TX},
	{"txframe", CAT_TX},
	{"txfrmsnt", CAT_TX},
	{"txfunfl", CAT_TX | CAT_UCODE},
	{"txinrtstxop", CAT_TX | CAT_UCODE},
	{"txlost", CAT_TX | CAT_ERR},
	{"txmpdu", CAT_TX | CAT_UCODE},
	{"txmpdu_sgi", CAT_TX},
	{"txmpdu_stbc", CAT_TX},
	{"txmulti", CAT_TX | CAT_MCAST},
	{"txnack", CAT_TX | CAT_ERR | CAT_UCAST},
	{"txnoack", CAT_TX | CAT_ERR | CAT_UCAST},
	{"txnoassoc", CAT_TX | CAT_ERR | CAT_ASSOC},
	{"txnobuf", CAT_TX | CAT_ERR},
	{"txnocts", CAT_TX},
	{"txnull", CAT_TX},
	{"txper_rts", CAT_TX | CAT_ERR | CAT_CTRL},
	{"txper_ucastdt", CAT_TX | CAT_ERR | CAT_UCAST},
	{"txphycrs", CAT_TX},
	{"txphyerr", CAT_TX | CAT_ERR},
	{"txphyerror", CAT_TX | CAT_ERR | CAT_UCODE},
	{"txprobereq", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txprobersp", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txprshort", CAT_TX},
	{"txpspoll", CAT_TX | CAT_CTRL},
	{"txqosnull", CAT_TX | CAT_CTRL},
	{"txreassocreq", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txreassocrsp", CAT_TX | CAT_CTRL | CAT_ASSOC},
	{"txretrans", CAT_TX | CAT_ERR},
	{"txretrie", CAT_TX | CAT_ERR | CAT_UCAST},
	{"txretry", CAT_TX | CAT_ERR | CAT_UCAST},
	{"txrts", CAT_TX | CAT_CTRL},
	{"txrtsfail", CAT_TX | CAT_ERR | CAT_UCODE | CAT_CTRL},
	{"txrtsfrm", CAT_TX | CAT_UCODE | CAT_CTRL},
	{"txserr", CAT_TX | CAT_ERR},
	{"txsfovfl", CAT_TX | CAT_ERR},
	{"txtplunfl", CAT_TX | CAT_UCODE},
	{"txucast", CAT_TX | CAT_UCAST | CAT_UCODE},
	{"unchained", 0},
	{"v2mmsg",    0},
	{"wepicverr", CAT_ERR | CAT_SEC},
	{"wepundec", CAT_SEC},
	{NULL, 0}
};

static bool at_start_of_line; /**< prevents printing of empty lines */

static int
cntr_ver_to_tbl_info(uint8 counter_ver, counter_offset_info_t **cntr_offset_info_tbl)
{
	uint32 index = 0;

	while (ver_to_cntr_offset_info_tbl[index].offset_info_tbl != NULL) {
		if (ver_to_cntr_offset_info_tbl[index].cntr_ver == counter_ver) {
			*cntr_offset_info_tbl = ver_to_cntr_offset_info_tbl[index].offset_info_tbl;
			return BCME_OK;
		}
		index++;
	}

	*cntr_offset_info_tbl = NULL;
	return BCME_ERROR;
}

/* Returns the offset of the counter in respective version of counters structure */
/* Returns 0  - Found the offset of the counter */
/* Returns -1 - Counter name passed do not match to any counter name */
int
get_counter_offset(char *name, uint32 *offset, uint8 counter_ver)
{
	uint32 index = 0;
	counter_offset_info_t *offset_info_tbl = NULL;

	if (cntr_ver_to_tbl_info(counter_ver, &offset_info_tbl) != BCME_OK) {
		fprintf(stderr, "Unsupported counter ver %d\n", counter_ver);
		return BCME_ERROR;
	}

	while (offset_info_tbl[index].name != NULL) {
		if (!strcmp(offset_info_tbl[index].name, name)) {
			*offset = htod32(offset_info_tbl[index].offset);
			return BCME_OK;
		}
		index++;
	}

	fprintf(stderr, "Invalid counter name %s\n", name);
	return BCME_ERROR;
}

int
print_counter_help(uint8 counter_ver)
{
	uint32 index = 0;
	counter_offset_info_t *offset_info_tbl = NULL;

	if (cntr_ver_to_tbl_info(counter_ver, &offset_info_tbl) != BCME_OK) {
		fprintf(stderr, "Unsupported counter ver %d\n", counter_ver);
		return BCME_ERROR;
	}

	while (offset_info_tbl[index].name != NULL) {
		if (index % 5 == 0) {
			printf("\n");
		}
		printf("%s ", offset_info_tbl[index].name);
		index++;
	}
	return BCME_OK;
}

int
wl_subcounters(void *wl, cmd_t *cmd, char **argv)
{
	int err;
	void *ptr;
	char *endptr;
	uint8 subcntdata[(MAX_SUBCOUNTER_SUPPORTED * sizeof(uint32)) +
		OFFSETOF(wl_subcnt_info_t, data)];
	int32 cntr_ver = -1;
	uint32 cntr_num = 0;
	uint32 req_len = 0;
	uint32 arg_index = 1;	/* 0th arg is command_name */
	wl_subcnt_info_t *subcntinfo;

	memset(subcntdata, 0, sizeof(subcntdata));

	if (argv[arg_index] != NULL) {
		cntr_ver = strtoul(argv[arg_index], &endptr, 0);
		if (*endptr != '\0') {
			fprintf(stderr, "Invalid cntr ver %s\n", argv[arg_index]);
			return BCME_BADARG;
		}
		arg_index++;
	}

	subcntinfo = (wl_subcnt_info_t *)subcntdata;
	while (argv[arg_index] != NULL)	{
		if (cntr_num >= MAX_SUBCOUNTER_SUPPORTED) {
			fprintf(stderr, "Max counters supported: %d\n", MAX_SUBCOUNTER_SUPPORTED);
			return BCME_BADARG;
		}

		if (get_counter_offset(argv[arg_index],
				&subcntinfo->data[cntr_num], cntr_ver)) {
			return BCME_BADARG;
		}
		arg_index++;
		cntr_num++;
	}

	if ((cntr_ver != -1) && (cntr_num == 0)) {
		print_counter_help(cntr_ver);
		return BCME_OK;
	}

	req_len = OFFSETOF(wl_subcnt_info_t, data) + (cntr_num * sizeof(subcntinfo->data[0]));
	subcntinfo->version = htod16(WL_SUBCNTR_IOV_VER);
	subcntinfo->counters_version = htod16(cntr_ver);
	subcntinfo->num_subcounters = htod16(cntr_num);
	subcntinfo->length = htod16(req_len);

	if ((err = wlu_var_getbuf_minimal(wl, cmd->name, subcntdata, req_len, &ptr))) {
		return (err);
	}

	subcntinfo = ptr;
	subcntinfo->version = dtoh16(subcntinfo->version);
	subcntinfo->counters_version = dtoh16(subcntinfo->counters_version);
	subcntinfo->num_subcounters = dtoh16(subcntinfo->num_subcounters);
	subcntinfo->length = dtoh16(subcntinfo->length);

	if ((cntr_ver == -1) || (cntr_num == 0) || (subcntinfo->num_subcounters == 0)) {
		printf("FW counter Version %d\n", subcntinfo->counters_version);
		return BCME_OK;
	}

	if ((subcntinfo->num_subcounters > MAX_SUBCOUNTER_SUPPORTED) ||
			(subcntinfo->length != req_len) ||
			(subcntinfo->length != OFFSETOF(wl_subcnt_info_t, data) +
			(subcntinfo->num_subcounters * sizeof(subcntinfo->data[0])))) {
		fprintf(stderr,
			"Mismatch App:FW cntr_ver %d:%d iov_ver %d:%d num_cntr %d:%d len %d:%d\n",
			cntr_ver, subcntinfo->counters_version,
			WL_SUBCNTR_IOV_VER, subcntinfo->version, cntr_num,
			subcntinfo->num_subcounters, req_len, subcntinfo->length);
		return BCME_BADARG;
	}

	for (cntr_num = 0; cntr_num < subcntinfo->num_subcounters; cntr_num++) {
		/* Print max 5 counters value in a single row */
		if (cntr_num % 5 == 0)
			printf("\n");
		printf("%s %d ", argv[cntr_num + 2],
			dtoh32(subcntinfo->data[cntr_num]));
	}
	printf("\n");

	return 0;
}

/***************************************************************************************************
 * The prcnt_*() functions print counter values. The purpose of the functions is to facilitate
 * filtering of the counter values, e.g. when the user only wants to see non-zero values.
 */

/** Must be called before any of the other prcnt_*() functions */
void prcnt_init()
{
	at_start_of_line = TRUE;
}

/**
 * Returns TRUE if a counter value is allowed by the filters to be printed.
 * @param cnt_filters   Specifies the filters to be applied
 * @param cntname        The name of the variable in the 'cnt' structure
 */
static bool prcnt_filter1(struct cnt_filters_s *cnt_filters, char *cntname)
{
	if (cnt_filters->filter != 0) {
		const struct cnt_properties_s *cnt = &cnt_props[0];
		while (cnt->name != NULL) {
			if (!strcmp(cntname, cnt->name)) {
				if ((cnt_filters->filter & cnt->categories) !=
					cnt_filters->filter) {
					// returns FALSE in non inverted case
					return cnt_filters->invert_selection;
				}
				break;
			}
			cnt++;
		}
		if (cnt->name == NULL)
			fprintf(stderr, "could not find this entry... %s\n", cntname);
	}

	return !cnt_filters->invert_selection;
}

/**
 * Returns TRUE if a counter value is allowed by the filters to be printed.
 * @param cnt_filters   Specifies the filters to be applied
 * @param cntname       The name of the variable in the 'cnt' structure
 * @param cntvalue      The value of the counter
 */
static bool prcnt_filter(struct cnt_filters_s *cnt_filters, char *cntname, uint32 cntvalue)
{
	if (cnt_filters->nonzero == TRUE && cntvalue == 0)
		return FALSE;

	return prcnt_filter1(cnt_filters, cntname);
}

/**
 * For non-legacy mode (so user specified filter options): prevents empty lines when printing
 * counter values. For legacy mode: empty lines are preserved for backwards compatibility of tools
 * that interpret wl utility output.
 * @param cnt_filters  User specified filters to apply
 * @param ppbuf        Output buffer for the sprintf
 */
void prcnt_prnl1(struct cnt_filters_s *cnt_filters)
{
	if (at_start_of_line == FALSE || cnt_filters->filters_active == FALSE) {
		printf("\n");
		at_start_of_line = TRUE;
	}
}

static int wl_counters_cbfn(void *ctx, const uint8 *data, uint16 type, uint16 len)
{
	int err = BCME_OK;
	wl_cnt_cbfn_info_t *cbfn_info = ctx;
	uint i;
	struct cnt_filters_s *p_cnt_filters = &cbfn_info->cnt_filters;

	PRINIT(); /* initializes printing of counter values */

	switch (type) {
		case WL_CNT_XTLV_SLICE_IDX: {
			printf("Slice_index: %d\n", *(uint8*)data);
			break;
		}
		case WL_CNT_XTLV_WLC_RINIT_RSN: {
			/* reinit reason counters */
			reinit_rsns_t *cnt = (reinit_rsns_t *)data;
			uint32 *val = cnt->rsn;
			uint maxoffset = len/sizeof(uint32);

			if (len > sizeof(reinit_rsns_t)) {
				printf("type %d: cntbuf length too long! %d > %d\n"
					"May need to use up-to-date wl utility.\n",
					type, len, (int)sizeof(reinit_rsns_t));
			}

			if (cnt->rsn[0] != INVALID_CNT_VAL) {
				PRSTR(reinitreason_counts, "reinitreason_counts: ");
				for (i = 0; i < WL_REINIT_RC_LAST && i < maxoffset; i++) {
					PRVAL_FMTSTR2(reinitreason_counts, "%d(%d) ", i, val[i]);
				}
				PRNL1();
			}
			break;
		}
		case WL_CNT_XTLV_WLC: {
			/* WLC layer counters */
			wl_cnt_wlc_t *cnt = (wl_cnt_wlc_t *)data;

			if (len > sizeof(wl_cnt_wlc_t)) {
				printf("type %d: cntbuf length too long! %d > %d\n"
					"May need to use up-to-date wl utility.\n",
					type, len, (int)sizeof(wl_cnt_wlc_t));
			}
			PRVALSF(reinit);

			/* Display old reinitreason counts */
			if (cnt->reinitreason[0] != INVALID_CNT_VAL) {
				PRSTR(reinitreason_counts, "reinitreason_counts: ");
				for (i = 0; i < NREINITREASONCOUNT; i++)
					PRVAL_FMTSTR2(reinitreason_counts, "%d(%d) ",
						i, cnt->reinitreason[i]);
				PRNL1();
			}

			PRVALSF(reset); PRVALSF(pciereset); PRVALSF(cfgrestore);
			PRVALSF(dma_hang); PRVALSF(ampdu_wds); PRNL1();

			PRVALSF(txframe); PRVALSF(txbyte); PRVALSF(txretrans); PRVALSF(txlost);
			PRVALSF(txfail); PRVALSF(txchanrej); PRNL1();
			PRVALSF(txdatamcast); PRVALSF(txdatabcast); PRNL1();
			PRVALSF(tbtt); PRVALSF(p2p_tbtt); PRVALSF(p2p_tbtt_miss); PRNL1();
			PRVALSF(rxframe); PRVALSF(rxbyte); PRVALSF(rxerror); PRNL1();
			PRVALSF(txdropped); PRVALSF(txprshort); PRVALSF(txdmawar);
			PRVALSF(txnobuf); PRVALSF(txnoassoc); PRVALSF(txchit); PRVALSF(txcmiss);
			PRNL1();
			PRVALSF(txserr); PRVALSF(txphyerr); PRVALSF(txphycrs); PRVALSF(txerror);
			PRNL1();
			PRVALSF_RENAME(txfrag, d11_txfrag); PRVALSF_RENAME(txmulti, d11_txmulti);
			PRVALSF_RENAME(txbcast, d11_txbcast); PRVALSF_RENAME(txretry, d11_txretry);
			PRVALSF_RENAME(txretrie, d11_txretrie); PRNL1();
			PRVALSF_RENAME(txrts, d11_txrts); PRVALSF_RENAME(txnocts, d11_txnocts);
			PRVALSF_RENAME(txnoack, d11_txnoack);
			PRVALSF_RENAME(txfrmsnt, d11_txfrmsnt); PRNL1();

			PRVALSF(rxdropped); PRVALSF(rxcrc); PRVALSF(rxnobuf); PRVALSF(rxnondata);
			PRVALSF(rxbadds); PRVALSF(rxbadcm); PRVALSF(rxdup); PRVALSF(rxfragerr);
			PRNL1();

			PRVALSF(rxrunt); PRVALSF(rxgiant); PRVALSF(rxnoscb); PRVALSF(rxbadproto);
			PRVALSF(rxbadsrcmac); PRVALSF(rxrtry); PRNL1();
			PRVALSF_RENAME(rxfrag, d11_rxfrag); PRVALSF_RENAME(rxmulti, d11_rxmulti);
			PRVALSF_RENAME(rxbcast, d11_rxbcast);
			PRVALSF_RENAME(rxundec, d11_rxundec); PRNL1();
			PRVALSF(rxctl); PRVALSF(rxbadda); PRVALSF(rxfilter);
			if (cnt->rxuflo[0] != INVALID_CNT_VAL) {
				PRSTR(rxuflo, "rxuflo: ");
				for (i = 0; i < NFIFO_LEGACY; i++)
					PRVAL_FMTSTR1(rxuflo, "%u ", cnt->rxuflo[i]);
				PRNL1();
			}

			/* WPA2 counters */
			PRNL1();
			PRVALSF(tkipmicfaill); PRVALSF(tkipicverr); PRVALSF(tkipcntrmsr); PRNL1();
			PRVALSF(tkipreplay); PRVALSF(ccmpfmterr); PRVALSF(ccmpreplay); PRNL1();
			PRVALSF(ccmpundec); PRVALSF(fourwayfail); PRVALSF(wepundec); PRNL1();
			PRVALSF(wepicverr); PRVALSF(decsuccess); PRVALSF(rxundec); PRNL1();
			PRNL1();

			/* per-rate receive counters */
			PRVALSF(rx1mbps); PRVALSF(rx2mbps); PRVALSF(rx5mbps5);
			PRVALSF(rx11mbps); PRNL1();
			PRVALSF(rx6mbps); PRVALSF(rx9mbps); PRVALSF(rx12mbps);
			PRVALSF(rx18mbps); PRNL1();
			PRVALSF(rx24mbps); PRVALSF(rx36mbps); PRVALSF(rx48mbps);
			PRVALSF(rx54mbps); PRNL1();

			PRVALSF(txmpdu_sgi); PRVALSF(rxmpdu_sgi); PRVALSF(txmpdu_stbc);
			PRVALSF(rxmpdu_stbc); PRVALSF(rxmpdu_mu); PRNL1();

			PRVALSF(cso_normal); PRVALSF(cso_passthrough);
			PRNL1();
			PRVALSF(chained); PRVALSF(chainedsz1); PRVALSF(unchained);
			PRVALSF(maxchainsz); PRVALSF(currchainsz); PRNL1();
			PRNL1();

			/* detailed amangement and control frame counters */
			PRVALSF(txbar); PRVALSF(txpspoll); PRVALSF(rxbar);
			PRVALSF(rxpspoll); PRNL1();
			PRVALSF(txnull); PRVALSF(txqosnull); PRVALSF(rxnull);
			PRVALSF(rxqosnull); PRNL1();
			PRVALSF(txassocreq); PRVALSF(txreassocreq); PRVALSF(txdisassoc);
			PRVALSF(txassocrsp); PRVALSF(txreassocrsp); PRNL1();
			PRVALSF(txauth); PRVALSF(txdeauth); PRVALSF(txprobereq);
			PRVALSF(txprobersp); PRVALSF(txaction); PRNL1();
			PRVALSF(rxassocreq); PRVALSF(rxreassocreq); PRVALSF(rxdisassoc);
			PRVALSF(rxassocrsp); PRVALSF(rxreassocrsp); PRNL1();
			PRVALSF(rxauth); PRVALSF(rxdeauth); PRVALSF(rxprobereq);
			PRVALSF(rxprobersp); PRVALSF(rxaction); PRNL1();
			break;
		}
		case WL_CNT_XTLV_CNTV_LE10_UCODE: {
			wl_cnt_v_le10_mcst_t *cnt = (wl_cnt_v_le10_mcst_t *)data;
			if (len != sizeof(wl_cnt_v_le10_mcst_t)) {
				printf("type %d: cnt struct length mismatch! %d != %d\n",
					type, len, (int)sizeof(wl_cnt_v_le10_mcst_t));
			}

			/* UCODE SHM counters */
			PRVAL(txallfrm); PRVAL(txbcnfrm); PRVAL(txrtsfrm);
			PRVAL(txctsfrm); PRVAL(txackfrm); PRVAL(txback);
			PRVAL(txdnlfrm); PRNL1();
			PRSTR(txfunfl, "txfunfl: ");
			for (i = 0; i < NFIFO_LEGACY; i++) {
				PRVAL_FMTSTR1(txfunfl, "%u ", cnt->txfunfl[i]);
			}
			PRVAL(txtplunfl); PRVAL(txphyerror); PRNL1();
			PRNL1();

			PRVAL(rxstrt); PRVAL(rxbadplcp); PRVAL(rxcrsglitch);
			PRVAL(rxtoolate); PRNL1();
			PRVAL(rxdrop20s); PRVAL(rxrsptmout);  PRNL1();
			PRVAL(rxbadfcs); PRVAL(rxfrmtoolong); PRVAL(rxfrmtooshrt);
			PRVAL(rxinvmachdr); PRNL1();
			PRVAL(rxf0ovfl); PRVAL(rxf1ovfl); PRVAL(rxf2ovfl);
			PRVAL(txsfovfl); PRVAL(pmqovfl); PRNL1();
			PRVAL(rxcfrmucast); PRVAL(rxrtsucast); PRVAL(rxctsucast);
			PRVAL(rxackucast); PRVAL(rxback); PRNL1();
			PRVAL(rxbeaconmbss); PRVAL(rxdfrmucastmbss);
			PRVAL(rxmfrmucastmbss); PRNL1();
			PRVAL(rxbeaconobss); PRVAL(rxdfrmucastobss);
			PRVAL(rxdfrmocast); PRVAL(rxmfrmocast); PRNL1();
			PRVAL(rxcfrmocast); PRVAL(rxrtsocast); PRVAL(rxctsocast); PRNL1();
			PRVAL(rxcfrmmcast); PRVAL(rxdfrmmcast); PRVAL(rxmfrmmcast); PRNL1();
			PRNL1();

			PRVAL(rxcgprqfrm); PRVAL(rxcgprsqovfl);
			PRVAL(txcgprsfail); PRVAL(txcgprssuc); PRVAL(prs_timeout); PRNL1();
			PRVAL(pktengrxducast); PRVAL(pktengrxdmcast);
			PRVAL(bcntxcancl); PRNL1();
			PRVAL(txfbw); PRVAL(rxnack); PRVAL(frmscons);
			PRVAL(txnack); PRNL1();
			PRNL1();
			break;
		}
		case WL_CNT_XTLV_LT40_UCODE_V1: {
			wl_cnt_lt40mcst_v1_t *cnt = (wl_cnt_lt40mcst_v1_t *)data;
			if (len != sizeof(wl_cnt_lt40mcst_v1_t)) {
				printf("type %d: cnt struct length mismatch! %d != %d\n",
					type, len, (int)sizeof(wl_cnt_lt40mcst_v1_t));
			}
			PRCNT_MACSTAT_TX_VER_GE11;
			/* rx start and those that do not end well */
			PRVAL(rxstrt); PRVAL(rxbadplcp); PRVAL(rxcrsglitch);
			PRVAL(rxtoolate); PRVAL(rxnodelim); PRNL1();
			PRVAL(bphy_badplcp); PRVAL(bphy_rxcrsglitch); PRNL1();
			PRVAL(rxbadfcs); PRVAL(rxfrmtoolong); PRVAL(rxfrmtooshrt);
			PRVAL(rxanyerr); PRNL1();
			PRVAL(rxf0ovfl); PRVAL(pmqovfl); PRNL1();
			PRCNT_MACSTAT_RX_VER_GE11;
			PRNL1();
			PRVAL(dbgoff46); PRVAL(dbgoff47);
			PRVAL(dbgoff48); PRVAL(phywatch); PRNL1();
			PRNL1();
			break;
		}
		case WL_CNT_XTLV_GE40_UCODE_V1: {
			wl_cnt_ge40mcst_v1_t *cnt = (wl_cnt_ge40mcst_v1_t *)data;
			if (len != sizeof(wl_cnt_ge40mcst_v1_t)) {
				printf("type %d: cnt struct length mismatch! %d != %d\n",
					type, len, (int)sizeof(wl_cnt_ge40mcst_v1_t));
			}
			PRCNT_MACSTAT_TX_VER_GE11;
			/* rx start and those that do not end well */
			PRVAL(rxstrt); PRVAL(rxbadplcp); PRVAL(rxcrsglitch);
			PRVAL(rxtoolate); PRVAL(rxnodelim); PRNL1();
			PRVAL(rxdrop20s); PRVAL(bphy_badplcp); PRVAL(bphy_rxcrsglitch); PRNL1();
			PRVAL(rxbadfcs); PRVAL(rxfrmtoolong); PRVAL(rxfrmtooshrt);
			PRVAL(rxanyerr); PRNL1();
			PRVAL(rxf0ovfl); PRVAL(rxf1ovfl); PRVAL(rxhlovfl); PRVAL(pmqovfl); PRNL1();
			PRCNT_MACSTAT_RX_VER_GE11;
			PRVAL(missbcn_dbg); PRNL1();
			PRNL1();
			break;
		}
		case WL_CNT_XTLV_GE64_UCODEX_V1: {
			wl_cnt_ge64mcxst_v1_t *cnt = (wl_cnt_ge64mcxst_v1_t *)data;
			if (len != sizeof(wl_cnt_ge64mcxst_v1_t)) {
				printf("type %d: cnt struct length mismatch! %d != %d\n",
					type, len, (int)sizeof(wl_cnt_ge64mcxst_v1_t));
			}
			PRVAL(macxsusp); PRVAL(m2vmsg); PRVAL(v2mmsg); PRNL1();
			PRVAL(mboxout); PRVAL(musnd); PRVAL(sfb2v);
			PRNL1();
			break;
		}
		default:
			printf("Unknown counters type %d!! You may try updating wl utility.\n",
				type);
			break;
	}

	return err;
}

int
wl_counters(void *wl, cmd_t *cmd, char **argv)
{
	wl_cnt_info_t *cntinfo;
	int err;
	void *ptr;
	uint16 ver;
	uint8 *cntdata;
	uint32 corerev = 0;
	wl_cnt_cbfn_info_t cbfn_info;

	memset(&cbfn_info, 0, sizeof(cbfn_info));
	while (*++argv != NULL) {
		cbfn_info.cnt_filters.filters_active = TRUE;
		if (!strcmp(*argv, "--nz"))
			cbfn_info.cnt_filters.nonzero = TRUE;
		else if (!strcmp(*argv, "--invert")) /* inverts entire selection */
			cbfn_info.cnt_filters.invert_selection = TRUE;
		else if (!strcmp(*argv, "--rx"))
			cbfn_info.cnt_filters.filter |= CAT_RX;
		else if (!strcmp(*argv, "--tx"))
			cbfn_info.cnt_filters.filter |= CAT_TX;
		else if (!strcmp(*argv, "--err"))
			cbfn_info.cnt_filters.filter |= CAT_ERR;
		else if (!strcmp(*argv, "--ucast"))
			cbfn_info.cnt_filters.filter |= CAT_UCAST;
		else if (!strcmp(*argv, "--mcast")) /* includes broadcast frames */
			cbfn_info.cnt_filters.filter |= CAT_MCAST;
		else if (!strcmp(*argv, "--ampdu"))
			cbfn_info.cnt_filters.filter |= CAT_AMPDU;
		else if (!strcmp(*argv, "--ucode"))
			cbfn_info.cnt_filters.filter |= CAT_UCODE;
		else if (!strcmp(*argv, "--ctrl"))
			cbfn_info.cnt_filters.filter |= CAT_CTRL;
		else if (!strcmp(*argv, "--sec"))
			cbfn_info.cnt_filters.filter |= CAT_SEC;
		else if (!strcmp(*argv, "--assoc"))
			cbfn_info.cnt_filters.filter |= CAT_ASSOC;
		else {
			fprintf(stderr, "unrecognized option %s\n", *argv);
			err = BCME_ERROR;
			goto exit;
		}
	}

	if ((err = wlu_var_getbuf (wl, cmd->name, NULL, 0, &ptr))) {
		goto exit;
	}

	cntinfo = ptr;
	cntinfo->version = dtoh16(cntinfo->version);
	cntinfo->datalen = dtoh16(cntinfo->datalen);
	CHK_CNTBUF_DATALEN(cntinfo, WLC_IOCTL_MAXLEN);
	ver = cntinfo->version;
	if (ver > WL_CNT_T_VERSION) {
		printf("\tIncorrect version of counters struct: expected %d; got %d\n",
		       WL_CNT_T_VERSION, ver);
		err = BCME_ERROR;
		goto exit;
	}

	printf("counters_version %2d\n", ver);

	if (ver == WL_CNT_VERSION_11) {
		/* XXX: This version of FW/driver's ucode has significant MACSTAT SHM
		 * layout change, but use of xtlv format is not implemented in wlc layer
		 * due to rom invalidation.
		 * It uses the deprecated wl cnt struct (wl_cnt_ver_11_t), each macstat
		 * variable of which has only one name, but they need to be copied to
		 * different macstat structs according to corerev.
		 */
		wlc_rev_info_t revinfo;
		memset(&revinfo, 0, sizeof(revinfo));
		err = wlu_get(wl, WLC_GET_REVINFO, &revinfo, sizeof(revinfo));
		if (err) {
			printf("%s: WLC_GET_REVINFO failed %d\n", __FUNCTION__, err);
			goto exit;
		}
		corerev = dtoh32(revinfo.corerev);
	}
	err = wl_cntbuf_to_xtlv_format(NULL, cntinfo, WLC_IOCTL_MAXLEN, corerev);

	if (err) {
		printf("%s: wl_cntbuf_to_xtlv_format failed %d\n", __FUNCTION__, err);
		goto exit;
	}

	/* Now counter buffer of all versions is translated to xtlv format */
	printf("datalen %d\n", cntinfo->datalen);

	cntdata = (uint8 *)malloc(cntinfo->datalen);
	if (cntdata == NULL) {
		err = BCME_NOMEM;
		printf("malloc fail!\n");
		goto exit;
	};

	memcpy(cntdata, cntinfo->data, cntinfo->datalen);

	if ((err = bcm_unpack_xtlv_buf(&cbfn_info, cntdata, cntinfo->datalen,
		BCM_XTLV_OPTION_ALIGN32, wl_counters_cbfn))) {
		printf("error %d\n", err);
	}
	free(cntdata);

exit:

	return err;
}

static int wl_if_counters_cbfn(void *ctx, const uint8 *data, uint16 type, uint16 len)
{
	int err = BCME_OK;
	wl_cnt_cbfn_info_t *cbfn_info = ctx;
	struct cnt_filters_s *p_cnt_filters = &cbfn_info->cnt_filters;

	PRINIT(); /* initializes printing of counter values */
	UNUSED_PARAMETER(ctx);
	UNUSED_PARAMETER(data);

	switch (type) {
		case WL_IFSTATS_XTLV_IF_INDEX: {
			printf("Stats received on interface index: %d\n", *data);
			break;
		}
		case WL_IFSTATS_XTLV_GENERIC: {
			wl_if_stats_t *cnt = (wl_if_stats_t*)data;

			if (len > sizeof(wl_if_stats_t)) {
				printf("type %d: cntbuf length too long! %d > %d\n"
					"May need to use up-to-date wl utility.\n",
					type, len, (int)sizeof(wl_if_stats_t));
			}

			/* summary stat counter line */
			PRINIT();
			PRVAL(txframe); PRVAL(txbyte); PRVAL(txerror);
			PRVAL(rxframe); PRVAL(rxbyte); PRVAL(rxerror); PRNL1();

			PRVAL(txnobuf); PRVAL(txfail); PRVAL(txretrans); PRNL1();
			PRVALSF_RENAME(txfrag, d11_txfrag);
			PRVALSF_RENAME(txmulti, d11_txmulti);
			PRVALSF_RENAME(txretry, d11_txretry);
			PRVALSF_RENAME(txretrie, d11_txretrie);
			PRNL1();
			PRVALSF_RENAME(txfrmsnt, d11_txfrmsnt);
			PRNL1();

			PRVAL(rxnobuf);	PRVAL(rxfragerr); PRNL1();
			PRVAL(rxrunt); PRNL1();
			PRVALSF_RENAME(rxmulti, d11_rxmulti);
			PRNL1();

			break;
		}
		case WL_IFSTATS_XTLV_INFRA_SPECIFIC: {
			wl_if_infra_stats_t *cnt = (wl_if_infra_stats_t *)data;

			PRINIT();
			PRVAL(rxbeaconmbss); PRVAL(tbtt);
			PRNL1();
			break;
		}
		case WL_IFSTATS_XTLV_MGT_CNT: {
			wl_if_mgt_stats_t *cnt = (wl_if_mgt_stats_t *)data;

			PRINIT();
			PRVAL(txnull); PRVAL(rxnull); PRNL1();
			PRVAL(txqosnull); PRVAL(rxqosnull); PRNL1();
			PRVAL(txassocreq); PRVAL(rxassocreq); PRNL1();
			PRVAL(txreassocreq); PRVAL(rxreassocreq); PRNL1();
			PRVAL(txdisassoc); PRVAL(rxdisassoc); PRNL1();
			PRVAL(txassocrsp); PRVAL(rxassocrsp); PRNL1();
			PRVAL(txreassocrsp); PRVAL(rxreassocrsp); PRNL1();
			PRVAL(txauth); PRVAL(rxauth); PRNL1();
			PRVAL(txdeauth); PRVAL(rxdeauth); PRNL1();
			PRVAL(txprobereq); PRVAL(rxprobereq); PRNL1();
			PRVAL(txprobersp); PRVAL(rxprobersp); PRNL1();
			PRVAL(txaction); PRVAL(rxaction); PRNL1();
			PRVAL(txpspoll); PRVAL(rxpspoll); PRNL1();

			break;
		}
		default:
			printf("Unknown counters type %d!! You may try updating wl utility.\n",
				type);
			break;
	}

	return err;
}

/* Parameters to if_counters iovar need to be converted to XTLV format
 * before sending to FW. The length of the top level XTLV container
 * containing parameters should not exceed 228 bytes
 */
#define WLUC_IF_COUNTERS_PARAM_CONTAINER_LEN_MAX	228

int
wl_ifstats_counters(void *wl, cmd_t *cmd, char **argv)
{
	void  *ptr;
	bcm_xtlvbuf_t xtlvbuf, local_xtlvbuf;
	bcm_xtlv_t *xtlv;
	wl_cnt_cbfn_info_t cbfn_info;
	uint16 expected_resp_len;
	int rc = BCME_OK;
	wl_stats_report_t *request = NULL, *response = NULL;

	UNUSED_PARAMETER(wl);
	UNUSED_PARAMETER(cmd);
	UNUSED_PARAMETER(argv);

	memset(&cbfn_info, 0, sizeof(cbfn_info));

	/* top level container length cannot exceed 228 bytes.
	 * This is because the output buffer is 1536 bytes long.
	 * Allow 1300 bytes for reporting stats coming in XTLV format
	 */
	request = (wl_stats_report_t *)
		calloc(WLUC_IF_COUNTERS_PARAM_CONTAINER_LEN_MAX, sizeof(uint8));

	if (request == NULL) {
		return BCME_NOMEM;
	}

	request->version = WL_STATS_REPORT_REQUEST_VERSION_V2;

	/* Top level container... we will create it ourselves */
	/* Leave space for report version, length, and top level XTLV
	 * WL_IFSTATS_XTLV_IF.
	 */
	rc = bcm_xtlv_buf_init(&local_xtlvbuf,
		(uint8*) request->data + BCM_XTLV_HDR_SIZE,
		WLUC_IF_COUNTERS_PARAM_CONTAINER_LEN_MAX -
		OFFSETOF(wl_stats_report_t, data) - BCM_XTLV_HDR_SIZE,
		BCM_XTLV_OPTION_ALIGN32);

	if (rc) {
		goto fail;
	}

	/* Populate requests using this the local_xtlvbuf context. The xtlvbuf
	 * is used to fill the container containing the XTLVs populated using
	 * local_xtlvbuf.
	 */
	rc = bcm_xtlv_buf_init(&xtlvbuf,
		(uint8*) request->data,
		WLUC_IF_COUNTERS_PARAM_CONTAINER_LEN_MAX -
		OFFSETOF(wl_stats_report_t, data),
		BCM_XTLV_OPTION_ALIGN32);

	if (rc) {
		goto fail;
	}

	/* An iovar comes on an interface specificed by -i option
	 * Send following types to report for now on the interface on
	 * which this iovar is issued
	 * WL_IFSTATS_XTLV_GENERIC = 0x502,
	 * WL_IFSTATS_XTLV_INFRA_SPECIFIC = 0x503,
	 * WL_IFSTATS_XTLV_MGT_CNT = 0x504,
	 */
	/* Request generic stats */
	rc = bcm_xtlv_put_data(&local_xtlvbuf,
		WL_IFSTATS_XTLV_GENERIC, NULL, 0);
	if (rc) {
		goto fail;
	}

	rc = bcm_xtlv_put_data(&local_xtlvbuf,
		WL_IFSTATS_XTLV_INFRA_SPECIFIC, NULL, 0);
	if (rc) {
		goto fail;
	}

	rc = bcm_xtlv_put_data(&local_xtlvbuf,
		WL_IFSTATS_XTLV_MGT_CNT, NULL, 0);
	if (rc) {
		goto fail;
	}

	/* Complete the outer container with type and length
	 * only.
	 */
	rc = bcm_xtlv_put_data(&xtlvbuf,
		WL_IFSTATS_XTLV_IF,
		NULL, bcm_xtlv_buf_len(&local_xtlvbuf));

	if (rc) {
		goto fail;
	}

	request->length = bcm_xtlv_buf_len(&xtlvbuf) +
		OFFSETOF(wl_stats_report_t, data);

	/* send the command over to the device and get teh output */
	if ((rc = wlu_var_getbuf_med(wl, cmd->name, request,
		request->length, &ptr))) {
		goto fail;
	}

	/* Reuse request to process response */
	response = (wl_stats_report_t *)ptr;

	/* version check */
	if (response->version != WL_STATS_REPORT_REQUEST_VERSION_V2) {
		rc = BCME_VERSION;
		goto fail;
	}

	xtlv = (bcm_xtlv_t *)(response->data);

	expected_resp_len =
		(BCM_XTLV_LEN(xtlv) + OFFSETOF(wl_stats_report_t, data));

	/* Check if the received length is as expected */
	if ((response->length > WLC_IOCTL_MEDLEN) ||
		(response->length < expected_resp_len)) {
		fprintf(stderr, "Illegal response length received. Got: %d"
			" Expected: %d. Expected len must be <= %u\n",
			response->length, expected_resp_len, WLC_IOCTL_MEDLEN);
		goto fail;
	}

	/* check the type. The return data will be in
	 * WL_IFSTATS_XTLV_IF container. So check if that container is
	 * present
	 */
	if (BCM_XTLV_ID(xtlv) != WL_IFSTATS_XTLV_IF) {
		rc = BCME_ERROR;
		fprintf(stderr,
			"unexpected type received: %d Expected: %d\n",
			BCM_XTLV_ID(xtlv), WL_IFSTATS_XTLV_IF);
		goto fail;
	}

	/* Process XTLVs within WL_IFSTATS_XTLV_IF container */
	if ((rc = bcm_unpack_xtlv_buf(&cbfn_info,
		(uint8*)response->data + BCM_XTLV_HDR_SIZE,
		BCM_XTLV_LEN(xtlv), /* total length of all TLVs in container */
		BCM_XTLV_OPTION_ALIGN32, wl_if_counters_cbfn))) {
		fprintf(stderr,
			"error unpacking XTLVs in wl_ifstats_counters: %d\n", rc);
		goto fail;
	}
fail:
	free(request);
	return rc;
}

/* old if_counters befire if_stats came in */
int
wl_if_counters_before_ifstats(void *wl, cmd_t *cmd, char **argv)
{
	char *statsbuf;
	wl_if_stats_t *cnt;
	int err;
	void *ptr;
	struct cnt_filters_s cnt_filters;
	struct cnt_filters_s *p_cnt_filters = &cnt_filters;

	UNUSED_PARAMETER(argv);

	memset(&cnt_filters, 0, sizeof(cnt_filters));
	if ((err = wlu_var_getbuf_med (wl, cmd->name, NULL, 0, &ptr)))
		return (err);

	statsbuf = (char *)ptr;
	cnt = (wl_if_stats_t*)malloc(sizeof(wl_if_stats_t));
	if (cnt == NULL) {
		printf("\tCan not allocate %d bytes for counters struct\n",
		       (int)sizeof(wl_if_stats_t));
		return BCME_NOMEM;
	} else
		memcpy(cnt, statsbuf, sizeof(wl_if_stats_t));
	/* summary stat counter line */
	PRINIT();
	PRVAL(txframe); PRVAL(txbyte); PRVAL(txerror);
	PRVAL(rxframe); PRVAL(rxbyte); PRVAL(rxerror); PRNL1();

	PRVAL(txnobuf); PRVAL(txfail); PRNL1();
	PRVALSF_RENAME(txfrag, d11_txfrag);
	PRVALSF_RENAME(txmulti, d11_txmulti);
	PRVALSF_RENAME(txretry, d11_txretry);
	PRVALSF_RENAME(txretrie, d11_txretrie);
	PRNL1();
	PRVALSF_RENAME(txfrmsnt, d11_txfrmsnt); PRVALSF_RENAME(rxmulti, d11_rxmulti);
	PRNL1();

	PRVAL(rxnobuf);	PRVAL(rxfragerr);
	PRVAL(rxrunt); PRVAL(rxerror);
	PRNL1();
	if (dtoh16(cnt->length) > OFFSETOF(wl_if_stats_t, txexptime)) {
		PRVAL(txexptime);
		PRVAL(txrts); PRVAL(txnocts);
	}
	PRNL1();

	if (cnt)
		free(cnt);

	return (0);
}

#define WL_IFSTATS_IFST_CAP_STRING	"ifst "
int
wl_if_counters(void *wl, cmd_t *cmd, char **argv)
{
	int err;
	char *local_buf;
	char *cap_argv[2] = { "cap", NULL };
	char *ifst_ptr;

	/* this implementation will change as version checking based approach
	 * is preferred over caps based approach. Implementation will change at the
	 * time ecounters is implemented.
	 */
	/* Send the caps iovar and get its output */
	if ((err = wl_var_get(wl, NULL, cap_argv)))
		return (err);

	local_buf = wl_get_buf();
	/* Look in the buf to see if "ifst " is present */
	ifst_ptr = strstr(local_buf, WL_IFSTATS_IFST_CAP_STRING);

	/* check to see if "ifst" word is detected */
	if ((ifst_ptr != NULL) &&
		((ifst_ptr == local_buf) || /* The string is at the start */
			/* or string is somewhere in the middle
			 * check if the previous character is a space
			 */
			(*(ifst_ptr - 1) == ' '))) {

		err = wl_ifstats_counters(wl, cmd, argv);
	} else {
		err = wl_if_counters_before_ifstats(wl, cmd, argv);
	}

	return err;
}

int
wl_delta_stats(void *wl, cmd_t *cmd, char **argv)
{
	char *statsbuf;
	wl_delta_stats_t *cnt;
	int err;
	void *ptr;
	struct cnt_filters_s cnt_filters;
	struct cnt_filters_s *p_cnt_filters = &cnt_filters;

	UNUSED_PARAMETER(cmd);
	UNUSED_PARAMETER(argv);
	memset(&cnt_filters, 0, sizeof(cnt_filters));

	if ((err = wlu_var_getbuf_med (wl, cmd->name, NULL, 0, &ptr)))
		return (err);

	statsbuf = (char *)ptr;

	cnt = (wl_delta_stats_t*)malloc(sizeof(wl_delta_stats_t));
	if (cnt == NULL) {
		printf("\tCan not allocate %d bytes for wl delta stats struct\n",
		       (int)sizeof(wl_delta_stats_t));
		return BCME_NOMEM;
	}
	memcpy(cnt, statsbuf, sizeof(wl_delta_stats_t));
	cnt->version = dtoh16(cnt->version);
	cnt->length = dtoh16(cnt->length);

	if (cnt->version != WL_DELTA_STATS_T_VERSION) {
		printf("\tIncorrect version of delta stats struct: expected %d; got %d\n",
			WL_DELTA_STATS_T_VERSION, cnt->version);
		free(cnt);
		return -1;
	}

	PRINIT();
	PRVAL(slice_index); PRNL1();
	PRVAL(txframe); PRVAL(txbyte); PRVAL(txretrans); PRVAL(txfail); PRNL1();
	PRVAL(rxframe); PRVAL(rxbyte); PRNL1();
	PRVAL(rx1mbps); PRVAL(rx2mbps); PRVAL(rx5mbps5); PRVAL(rx6mbps); PRNL1();
	PRVAL(rx9mbps); PRVAL(rx11mbps); PRVAL(rx12mbps); PRVAL(rx18mbps); PRNL1();
	PRVAL(rx24mbps); PRVAL(rx36mbps); PRVAL(rx48mbps); PRVAL(rx54mbps); PRNL1();
	PRNL1();

	PRVAL(rxbadplcp); PRVAL(rxcrsglitch); PRVAL(bphy_rxcrsglitch); PRVAL(bphy_badplcp);
	PRNL1();

	if (cnt != NULL)
		free(cnt);

	return (0);
}

int
wl_swdiv_stats(void *wl, cmd_t *cmd, char **argv)
{
	char *statsbuf;
	struct wlc_swdiv_stats_v1 *cnt_v1;
	struct wlc_swdiv_stats_v2 *cnt;
	int err = BCME_OK;
	void *ptr;
	struct cnt_filters_s cnt_filters;
	struct cnt_filters_s *p_cnt_filters = &cnt_filters;

	memset(&cnt_filters, 0, sizeof(cnt_filters));
	UNUSED_PARAMETER(cmd);
	UNUSED_PARAMETER(argv);

	if ((err = wlu_var_getbuf_med (wl, cmd->name, NULL, 0, &ptr)))
		return (err);

	statsbuf = (char *)ptr;

	/* Check for the firmware version and process accordingly */
	if (wlc_ver_major(wl) <= 5) {
		cnt_v1 = (struct wlc_swdiv_stats_v1*)malloc(sizeof(struct wlc_swdiv_stats_v1));
		if (cnt_v1 == NULL) {
			printf("\tCan not allocate %d bytes for wl swdiv stats struct\n",
				(int)sizeof(struct wlc_swdiv_stats_v2));
			return (-1);
		}
		memcpy(cnt_v1, statsbuf, sizeof(struct wlc_swdiv_stats_v1));
		PRINIT();
		PRVALV1(mws_antsel_ovr_tx); PRVALV1(mws_antsel_ovr_rx); PRNL1();
		PRVALV1(rx_policy); PRVALV1(tx_policy); PRVALV1(cell_policy); PRNL1();
		PRVALV1(auto_en); PRVALV1(active_ant); PRVALV1(rxcount); PRNL1();
		PRVALV1(tx_auto_en); PRVALV1(tx_active_ant); PRNL1();
		PRVALV1(avg_snr_per_ant0); PRVALV1(avg_snr_per_ant1);
		PRVALV1(avg_snr_per_ant2); PRNL1();
		PRVALV1(swap_ge_rxcount0); PRVALV1(swap_ge_rxcount1); PRNL1();
		PRVALV1(swap_ge_snrthresh0); PRVALV1(swap_ge_snrthresh1); PRNL1();
		PRVALV1(swap_txfail0); PRVALV1(swap_txfail1); PRNL1();
		PRVALV1(swap_timer0); PRVALV1(swap_timer1); PRNL1();
		PRVALV1(swap_alivecheck0); PRVALV1(swap_alivecheck1); PRNL1();
		PRVALV1(swap_snrdrop0); PRVALV1(swap_snrdrop1); PRNL1();
		PRVALV1(swap_trig_event_id); PRNL1();
		PRNL1();

	} else {
		cnt = (struct wlc_swdiv_stats_v2*)malloc(sizeof(struct wlc_swdiv_stats_v2));
		if (cnt == NULL) {
			printf("\tCan not allocate %d bytes for wl swdiv stats struct\n",
					(int)sizeof(struct wlc_swdiv_stats_v2));
			return (-1);
		}
		memcpy(cnt, statsbuf, sizeof(struct wlc_swdiv_stats_v2));
		if (cnt->version != 0) {
			err = BCME_USAGE_ERROR;
			goto exit;
		}
		PRINIT();
		PRVAL(mws_antsel_ovr_tx); PRVAL(mws_antsel_ovr_rx); PRNL1();
		PRVAL(rx_policy); PRVAL(tx_policy); PRVAL(cell_policy); PRNL1();
		PRVAL(auto_en); PRVAL(active_ant); PRVAL(rxcount); PRNL1();
		PRVAL(tx_auto_en); PRVAL(tx_active_ant); PRNL1();
		PRVAL(avg_snr_per_ant0); PRVAL(avg_snr_per_ant1);
		PRVAL(avg_snr_per_ant2); PRNL1();
		PRVAL(swap_ge_rxcount0); PRVAL(swap_ge_rxcount1); PRNL1();
		PRVAL(swap_ge_snrthresh0); PRVAL(swap_ge_snrthresh1); PRNL1();
		PRVAL(swap_txfail0); PRVAL(swap_txfail1); PRNL1();
		PRVAL(swap_timer0); PRVAL(swap_timer1); PRNL1();
		PRVAL(swap_alivecheck0); PRVAL(swap_alivecheck1); PRNL1();
		PRVAL(swap_snrdrop0); PRVAL(swap_snrdrop1); PRNL1();
		PRVAL(swap_trig_event_id); PRNL1();
		PRNL1();
	}

exit :
	if (wlc_ver_major(wl) <= 5) {
		if (cnt_v1 != NULL)
			free(cnt_v1);
	} else {
		if (cnt)
			free(cnt);
	}

	return err;
}

int
wl_clear_counters(void *wl, cmd_t *cmd, char **argv)
{
	int err;
	int val;

	UNUSED_PARAMETER(argv);

	if ((err = wlu_iovar_getint(wl, cmd->name, &val)))
		return (err);

	return (0);
}
