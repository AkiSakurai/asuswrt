/*
 * PHY and RADIO specific portion of Broadcom BCM43XX 802.11 Networking Device Driver.
 *
 * Copyright 2020 Broadcom
 *
 * This program is the proprietary software of Broadcom and/or
 * its licensors, and may only be used, duplicated, modified or distributed
 * pursuant to the terms and conditions of a separate, written license
 * agreement executed between you and Broadcom (an "Authorized License").
 * Except as set forth in an Authorized License, Broadcom grants no license
 * (express or implied), right to use, or waiver of any kind with respect to
 * the Software, and Broadcom expressly reserves all rights in and to the
 * Software and all intellectual property rights therein.  IF YOU HAVE NO
 * AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
 * WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
 * THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof, and to
 * use this information only in connection with your use of Broadcom
 * integrated circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR
 * OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL,
 * SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR
 * IN ANY WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
 * IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii)
 * ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF
 * OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 * $Id: wlc_phy_cmn.c 687024 2017-02-27 06:01:22Z $
 */

/* XXX WARNING: phy structure has been changed, read this first
 *
 * This is top level of PHY common module for WLAN chips. Major components are
 *         macro, typedef, enum, structure, global variable
 *         common PHY utilities: register read/write, table read/write
 *         common PHY operations: attach/detach/reset/init/down/up
 *         chanspec
 *         tx power control
 *         calibration: tx/rx, aci, PAPD etc
 *         radar
 *         user control: ioctl, iovar, dump
 * ================================================================================================
 * 2009 March: in TOT, the old monolithic wlc_phy.c was split into this common module and several
 *   submodule to serve different PHY and radio.
 *   To get old cvs history before split: cvs annorate -r 1.2084 wlc_phy_cmn.c
 *   Refer to http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/WlDriverModulePhy for details
 *   The PHY module architecture is below
 *         wlc_phy.h(public interface)
 *         --------------------------------------------
 *         wlc_phy_cmn.c (common, shared PHY submodule)
 *         --------------------------------------------
 *         wlc_phy_int.h(private interface)
 *         --------------------------------------------
 *         wlc_phy_abg.c wlc_phy_lpssn.c wlc_phy_n.c(PHY type specific code)
 *
 * ================================================================================================
 * Naming convention is
 *         wlc_phy_submodule_noun_verb_<phytype>
 *         i.e. wlc_phy_radar_detect_run
 *              wlc_phy_radar_detect_run_nphy
 * compile flags:
 *     BCMINTERNAL is for internal code, not available to any external customer release
 *     BCMDBG is for debug code, available to customer in external debug build.
 *     WLTEST is needed for manufacturing feature code
 *     BCMINITFN() will make the code reclaimable (after driver up)
 *
 * MERGE: manual merge(instead of cvs auto merge) is required for any old branch code
 *        test your change on GPHY(4318, 4306), LPPHY(4325, 4312), NPHY(4321, 4322), SSLPNPHY(4319)
 *
 * Good practice:
 *  Avoid using macros due to lack of type checking, encapsulation and code replication
 *  reduce using ifdef except for NCONF/LPCONF/SSLPNPHY for code size optimization
 *  Define/enum constant, hard numbers are difficult to understand and maintain
 *  Sharing code as much as possible
 *  write simple/clean code(fewer if-else, goto), think of scalability
 * ================================================================================================
 * TODO:
 *        shared more common flow
 *        unify iovar/ioctl
 *        optimize code
*/

#include <wlc_cfg.h>
#include <typedefs.h>
#include <qmath.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmutils.h>
#include <siutils.h>
#include <bcmendian.h>
#include <wlioctl.h>
#include <bitfuncs.h>
#include <bcmdevs.h>
#include <bcmnvram.h>
#include <proto/802.11.h>
#include <sbchipc.h>
#include <hndpmu.h>
#include <bcmsrom_fmt.h>
#include <sbsprom.h>
#include <bcmutils.h>
#include <d11.h>

#include <wlc_phy_hal.h>
#include <wlc_phy_int.h>
#include <wlc_phyreg_abg.h>
#include <wlc_phyreg_n.h>
#include <wlc_phyreg_ht.h>
#include <wlc_phyreg_ac.h>
#include <wlc_phyreg_lp.h>
#include <wlc_phyreg_ssn.h>
#include <wlc_phyreg_lcn.h>
#include <wlc_phyreg_lcn40.h>
#include <wlc_phytbl_n.h>
#include <wlc_phytbl_ht.h>
#include <wlc_phytbl_ac.h>
#include <wlc_phytbl_20691.h>
#include <wlc_phy_radio.h>
#include <wlc_phy_lcn.h>
#if (defined(LCN20CONF) && (LCN20CONF != 0))
#include <wlc_phy_lcn20.h>
#endif /* #if ((defined(LCN20CONF) && (LCN20CONF != 0))) */
#include <wlc_phy_lcn40.h>
#include <wlc_phy_lp.h>
#include <wlc_phy_ssn.h>
#include <wlc_phy_abg.h>
#include <wlc_phy_n.h>
#include <wlc_phy_ht.h>
#if ACCONF != 0
#include <wlc_phy_ac.h>
#endif /* ACCONF != 0 */
#include <bcmwifi_channels.h>
#include <bcmotp.h>
#include <wlc_phy_shim.h>

#if     defined(BCM_OL_DEV)
int8 wlc_phy_noise_sample_acphy(wlc_phy_t *pih);
#endif /* defined(BCM_OL_DEV) */

#ifdef  WLOFFLD
extern int8 wlc_ol_noise_avg_offload(void *wlc);
#endif // endif
#ifdef WLSRVSDB
#include <saverestore.h>
#endif // endif

#ifdef WLNOKIA_NVMEM
#include <wlc_phy_noknvmem.h>
#endif /* WLNOKIA_NVMEM */

#ifdef EVENT_LOG_COMPILE
#include <event_log.h>
#endif // endif

/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
/*  macro, typedef, enum, structure, global variable		*/
/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
#define RSSI_IQEST_DEBUG 0
#define RSSI_CORR_EN 1
#define ACPHY_RXGAIN_UNSPECIFIED (-100)

#if defined(WLTEST)
#define BFECONFIGREF_FORCEVAL    0x9
#define BFMCON_FORCEVAL          0x8c03
#define BFMCON_RELEASEVAL        0x8c1d
#define REFRESH_THR_FORCEVAL     0xffff
#define REFRESH_THR_RELEASEVAL   0x186a
#define BFRIDX_POS_FORCEVAL      0x100
#define BFRIDX_POS_RELEASEVAL    0x0
#endif // endif

#if !defined(DEFAULT_PHYHAL_MSG_LEVEL) /* over-rideable */
#define DEFAULT_PHYHAL_MSG_LEVEL (PHYHAL_ERROR)
#endif /* DEFAULT_PHYHAL_MSG_LEVEL */

uint32 phyhal_msg_level = DEFAULT_PHYHAL_MSG_LEVEL;

#ifdef BCMLTECOEX
/* ED assert threshold for ltecx */
#define LTECX_ED_THRESH				-40
#endif /* BCMLTECOEX */

/* channel info structure */
typedef struct _chan_info_basic {
	uint16	chan;		/* channel number */
	uint16	freq;		/* in Mhz */
} chan_info_basic_t;

static chan_info_basic_t chan_info_all[] = {
	/* 11b/11g */
/* 0 */		{1,	2412},
/* 1 */		{2,	2417},
/* 2 */		{3,	2422},
/* 3 */		{4,	2427},
/* 4 */		{5,	2432},
/* 5 */		{6,	2437},
/* 6 */		{7,	2442},
/* 7 */		{8,	2447},
/* 8 */		{9,	2452},
/* 9 */		{10,	2457},
/* 10 */	{11,	2462},
/* 11 */	{12,	2467},
/* 12 */	{13,	2472},
/* 13 */	{14,	2484},

#ifdef BAND5G
/* 11a japan high */
/* 14 */	{34,	5170},
/* 15 */	{38,	5190},
/* 16 */	{42,	5210},
/* 17 */	{46,	5230},

/* 11a usa low */
/* 18 */	{36,	5180},
/* 19 */	{40,	5200},
/* 20 */	{44,	5220},
/* 21 */	{48,	5240},
/* 22 */	{52,	5260},
/* 23 */	{54,	5270},
/* 24 */	{56,	5280},
/* 25 */	{60,	5300},
/* 26 */	{62,	5310},
/* 27 */	{64,	5320},

/* 11a Europe */
/* 28 */	{100,	5500},
/* 29 */	{102,	5510},
/* 30 */	{104,	5520},
/* 31 */	{108,	5540},
/* 31 */	{110,	5550},
/* 32 */	{112,	5560},
/* 33 */	{116,	5580},
/* 34 */	{118,	5590},
/* 35 */	{120,	5600},
/* 36 */	{124,	5620},
/* 37 */	{126,	5630},
/* 38 */	{128,	5640},
/* 39 */	{132,	5660},
/* 39 */	{134,	5660},
/* 40 */	{136,	5680},
/* 41 */	{140,	5700},

#ifdef WL11AC
/* 42 */	{144,   5720},

/* 11a usa high, ref5 only */
/* 43 */	{149,   5745},
/* 44 */	{151,   5755},
/* 45 */	{153,   5765},
/* 46 */	{157,   5785},
/* 47 */	{159,   5795},
/* 48 */	{161,   5805},
/* 49 */	{165,   5825},

/* 11a japan */
/* 50 */	{184,   4920},
/* 51 */	{185,   4925},
/* 52 */	{187,   4935},
/* 53 */	{188,   4940},
/* 54 */	{189,   4945},
/* 55 */	{192,   4960},
/* 56 */	{196,   4980},
/* 57 */	{200,   5000},
/* 58 */	{204,   5020},
/* 59 */	{207,   5035},
/* 60 */	{208,   5040},
/* 61 */	{209,   5045},
/* 62 */	{210,   5050},
/* 63 */	{212,   5060},
/* 64 */	{216,   5080}

#else

/* 11a usa high, ref5 only */
/* 42 */	{149,	5745},
/* 43 */	{151,	5755},
/* 44 */	{153,	5765},
/* 45 */	{157,	5785},
/* 46 */	{159,	5795},
/* 47 */	{161,	5805},
/* 48 */	{165,	5825},

/* 11a japan */
/* 49 */	{184,	4920},
/* 50 */	{185,	4925},
/* 51 */	{187,	4935},
/* 52 */	{188,	4940},
/* 53 */	{189,	4945},
/* 54 */	{192,	4960},
/* 55 */	{196,	4980},
/* 56 */	{200,	5000},
/* 57 */	{204,	5020},
/* 58 */	{207,	5035},
/* 59 */	{208,	5040},
/* 60 */	{209,	5045},
/* 61 */	{210,	5050},
/* 62 */	{212,	5060},
/* 63 */	{216,	5080}
#endif /* WL11AC */

#endif /* BAND5G */
};

uint16 ltrn_list[PHY_LTRN_LIST_LEN] = {
	0x18f9, 0x0d01, 0x00e4, 0xdef4, 0x06f1, 0x0ffc,
	0xfa27, 0x1dff, 0x10f0, 0x0918, 0xf20a, 0xe010,
	0x1417, 0x1104, 0xf114, 0xf2fa, 0xf7db, 0xe2fc,
	0xe1fb, 0x13ee, 0xff0d, 0xe91c, 0x171a, 0x0318,
	0xda00, 0x03e8, 0x17e6, 0xe9e4, 0xfff3, 0x1312,
	0xe105, 0xe204, 0xf725, 0xf206, 0xf1ec, 0x11fc,
	0x14e9, 0xe0f0, 0xf2f6, 0x09e8, 0x1010, 0x1d01,
	0xfad9, 0x0f04, 0x060f, 0xde0c, 0x001c, 0x0dff,
	0x1807, 0xf61a, 0xe40e, 0x0f16, 0x05f9, 0x18ec,
	0x0a1b, 0xff1e, 0x2600, 0xffe2, 0x0ae5, 0x1814,
	0x0507, 0x0fea, 0xe4f2, 0xf6e6
};

/* Decode OFDM PLCP SIGNAL field RATE sub-field bits 0:2 (labeled R1-R3) into
 * 802.11 MAC rate in 500kbps units
 *
 * Table from 802.11-2012, sec 18.3.4.2.
 */
const uint8 ofdm_rate_lookup[] = {
	DOT11_RATE_48M, /* 8: 48Mbps */
	DOT11_RATE_24M, /* 9: 24Mbps */
	DOT11_RATE_12M, /* A: 12Mbps */
	DOT11_RATE_6M,  /* B:  6Mbps */
	DOT11_RATE_54M, /* C: 54Mbps */
	DOT11_RATE_36M, /* D: 36Mbps */
	DOT11_RATE_18M, /* E: 18Mbps */
	DOT11_RATE_9M   /* F:  9Mbps */
};

#ifdef LP_P2P_SOFTAP
uint8 pwr_lvl_qdB[LCNPHY_TX_PWR_CTRL_MACLUT_LEN];
#endif /* LP_P2P_SOFTAP */

#define PHY_WREG_LIMIT	24	/* number of consecutive phy register write before a readback */
#define PHY_WREG_LIMIT_VENDOR 1	/* num of consec phy reg write before a readback for vendor */
/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
/*  local prototype						*/
/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */

void phy_reg_write_array(void* pi, const uint16* regp, int length);

void wlc_phy_chanspec_shm_set(phy_info_t *pi, chanspec_t chanspec);

/* %%%%%% major operations */
static void wlc_set_phy_uninitted(phy_info_t *pi);
static uint32 wlc_phy_get_radio_ver(phy_info_t *pi);
static void wlc_phy_timercb_phycal(void *arg);

/* %%%%%% Calibration, ACI, noise/rssi measurement */
static void wlc_phy_noise_calc(phy_info_t *pi, uint32 *cmplx_pwr, int8 *pwr_ant,
                               uint8 extra_gain_1dB);
static void wlc_phy_noise_save(phy_info_t *pi, int8 *noise_dbm_ant, int8 *max_noise_dbm);
static uint8 wlc_phy_calc_extra_init_gain(phy_info_t *pi, uint8 extra_gain_3dB,
                                        rxgain_t rxgain[]);

#ifndef WLC_DISABLE_ACI
static void wlc_phy_aci_upd(phy_info_t *pi);
static void wlc_phy_noisemode_upd(phy_info_t *pi);
static int8 wlc_phy_cmn_noisemode_glitch_chk_adj(phy_info_t *pi, uint16 glitch_badplcp_sum_ma,
	noise_thresholds_t *thresholds);
static void wlc_phy_cmn_noise_limit_desense(phy_info_t *pi);
#if defined(WLTEST) || defined(WL_PHYACIARGS)
static int  wlc_phy_aci_args(phy_info_t *pi, wl_aci_args_t *params, bool get, int len);
#endif // endif
static void wlc_phy_aci_enter(phy_info_t *pi);
static void wlc_phy_aci_exit(phy_info_t *pi);
static void wlc_phy_aci_update_ma(phy_info_t *pi);
void wlc_phy_aci_noise_reset_nphy(phy_info_t *pi, uint channel, bool clear_aci_state,
	bool clear_noise_state, bool disassoc);

#ifdef WLPHYACICACHE
static void wlc_phy_init_aci_chanctx(phy_info_t *pi, ch_acicache_t *ctx);
static void wlc_phy_aci_upd_multilink(phy_info_t *pi, ch_acicache_t *ctx);
static void wlc_phy_aci_update_counters_multilink(phy_info_t *pi, ch_acicache_t *ctx);
#endif /* WLPHYACICACHE */
#ifdef DYNAMIC_THRESH_UPD
static void wlc_phy_update_glitch_thresholds(phy_info_t *pi);
#endif /* DYNAMIC_THRESH_UPD */
#endif /* Compiling out ACI code for 4324 */
static int wlc_phy_set_interference_override_mode(phy_info_t* pi, int val);

void wlc_phy_aci_noise_reset_htphy(phy_info_t *pi, uint channel, bool clear_aci_state,
	bool clear_noise_state, bool disassoc);

#ifndef WLC_DISABLE_ACI
static bool wlc_phy_interference(phy_info_t *pi, int wanted_mode, bool init);
#endif /* Compiling out ACI code for 4324 */
static void wlc_phy_vco_cal(phy_info_t *pi);
static void wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay);
static void wlc_phy_noise_sample_request(wlc_phy_t *pih, uint8 reason, uint8 ch);
/* %%%%%% temperature-based fallback to 1-Tx */
static void wlc_phy_txcore_temp(phy_info_t *pi);

/* %%%%%% power control */
static void wlc_phy_txpwr_srom_convert_mcs_offset(uint32 po, uint8 offset, uint8 max_pwr,
	ppr_ht_mcs_rateset_t* mcs, int8 mcs7_15_offset);
static void wlc_phy_txpower_recalc_target(phy_info_t *pi, ppr_t *txpwr_reg, ppr_t *txpwr_targets);

#ifdef WLTXPWR_CACHE
static void wlc_phy_txpower_retrieve_cached_target(phy_info_t *pi);
#if defined(WLC_LOW_ONLY)
static void wlc_phy_pwr_cache_reserve(phy_info_t *pi, chanspec_t chanspec);
#endif /* WLC_LOW_ONLY */
#endif /* WLTXPWR_CACHE */
static void wlc_phy_txpower_reg_limit_calc(phy_info_t *pi, ppr_t *txpwr, chanspec_t chanspec,
	ppr_t *txpwr_limit);
static bool wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi);

/* %%%%%% testing */
#if defined(BCMDBG) || defined(WLTEST)
static int wlc_phy_test_carrier_suppress(phy_info_t *pi, int channel);
static int wlc_phy_test_freq_accuracy(phy_info_t *pi, int channel);
static int wlc_phy_test_evm(phy_info_t *pi, int channel, uint rate, int txpwr);
#endif // endif

static uint32 wlc_phy_rx_iq_est(phy_info_t *pi, uint8 samples, uint8 antsel, uint8 resolution,
	uint8 lpf_hpc, uint8 dig_lpf, uint8 gain_correct,
                                uint8 extra_gain_3dB, uint8 wait_for_crs, uint8 force_gain_type);
#ifdef SAMPLE_COLLECT
static int wlc_phy_sample_collect(phy_info_t *pi, wl_samplecollect_args_t *collect, void *buff);
static int wlc_phy_sample_data(phy_info_t *pi, wl_sampledata_t *sample_data, void *b);
static int wlc_phy_sample_collect_old(phy_info_t *pi, wl_samplecollect_args_t *collect, void *buff);
static int wlc_phy_mac_triggered_sample_collect(phy_info_t *pi, wl_samplecollect_args_t *collect,
void *buff);
static int wlc_phy_mac_triggered_sample_data(phy_info_t *pi, wl_sampledata_t *sample_data,
void *b);
#endif // endif

#ifdef PHY_XTAL_SPUR_CAL
#if defined(WLTEST)
static int wlc_phy_cal_xtal_spur(phy_info_t *pi, phy_cal_xtal_spur_t *params);
#endif // endif
#endif /* PHY_XTAL_SPUR_CAL */

/* attaches common part of phy code */
static bool wlc_phy_cmn_attach(phy_info_t *pi);
static void wlc_phy_cmn_detach(phy_info_t *pi);

/* %%%%%% radar */
#if defined(AP) && defined(RADAR)
static void wlc_phy_radar_read_table_aphy(phy_info_t *pi, radar_work_t *rt, int min_pulses);
static void wlc_phy_radar_generate_tlist(uint32 *inlist, int *outlist, int length, int n);
static void wlc_phy_radar_generate_tpw(uint16 *inlist, uint16 *outlist, int length, int n);
static void wlc_phy_radar_generate_tfm(int16 *inlist, int16 *outlist, int length, int n);
static void wlc_phy_radar_filter_list(int *inlist, int *length, int min_val, int max_val);
static void wlc_shell_sort(int len, int *vector);
static int  wlc_phy_radar_select_nfrequent(int *inlist, int length, int n, int *val,
	int *pos, int *f, int *vlist, int *flist);
static int  wlc_phy_radar_detect_run_aphy(phy_info_t *pi);
static void wlc_phy_radar_detect_init_aphy(phy_info_t *pi, bool on);
static int  wlc_phy_radar_detect_run_nphy(phy_info_t *pi);
static void wlc_phy_radar_detect_init_nphy(phy_info_t *pi, bool on);
static void wlc_phy_radar_detect_init_htphy(phy_info_t *pi, bool on);
static void wlc_phy_radar_detect_init_acphy(phy_info_t *pi, bool on);
static void wlc_phy_radar_params_attach(phy_info_t *pi);
#endif /* defined(AP) && defined(RADAR) */

static int wlc_phy_iovar_dispatch_old(phy_info_t *pi, uint32 actionid, void *p, void *a, int vsize,
	int32 int_val, bool bool_val);

static int wlc_phy_iovars_nphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_acphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_lcncmnphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_phy_specific(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);

static int wlc_phy_iovars_aci(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_rssi(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_calib(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
#ifndef PHYMOD3_TRUNK_MERGE
static int wlc_phy_iovars_radar(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
#endif // endif
static int wlc_phy_iovars_generic(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
static int wlc_phy_iovars_txpwrctl(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
#ifdef SAMPLE_COLLECT
static int wlc_phy_iovars_sample_collect(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);
#endif /* SAMPLE_COLLECT */

#ifdef PREASSOC_PWRCTRL
static void wlc_phy_store_tx_pwrctrl_setting(phy_info_t *pi, chanspec_t previous_chanspec);
static void wlc_phy_pwrctrl_shortwindow_upd(phy_info_t *pi, bool new_channel);
#endif // endif

static void wlc_phy_btc_adjust(phy_info_t *pi, bool btactive, uint16 btperiod);
#if defined(WLMCHAN) && defined(BCMDBG)
static void wlc_phydump_chanctx(phy_info_t *phi, struct bcmstrbuf *b);
#endif // endif
#if !defined(EFI)
static void mat_print(int64 *a, int m, int n, const char *name);
static void mat_rho(int64 *n, int64 *p, int64 *rho, int m);
static void mat_transpose(int64 *a, int64 *b, int m, int n);
static void mat_mult(int64 *a, int64 *b, int64 *c, int m, int n, int r);
static void mat_inv_prod_det(int64 *a, int64 *b);
static void mat_det(int64 *a, int64 *det);
static void ratmodel_paparams_fix64(ratmodel_paparams_t* rsd, int m);
#if PHY_TSSI_CAL_DBG_EN
static void print_int64(int64 *a);
#endif // endif
static uint16 tssi_cal_sweep(phy_info_t *pi);
int wlc_phy_tssi_cal(phy_info_t *pi);
#else
#define wlc_phy_tssi_cal(a)	do {} while (0)
#endif // endif

static int8 wlc_phy_channel_gain_adjust(phy_info_t *pi);

#if defined(LINUX_HYBRID) || defined(BCMDBG)
static char * BCMATTACHFN(phy_getvar_internal)(phy_info_t *pi, const char *name);
#endif /* LINUX_HYBRID || BCMDBG */
#ifdef BCMDBG
static char *
BCMATTACHFN(phy_getvar_fabid_internal)(phy_info_t *pi, const char *name, const char *function);
static int
BCMATTACHFN(phy_getintvararray_default_internal)(phy_info_t *pi, const char *name, int idx,
	int default_value, const char *function);
#else
static char *
BCMATTACHFN(phy_getvar_fabid_internal)(phy_info_t *pi, const char *name);
static int
BCMATTACHFN(phy_getintvararray_default_internal)(phy_info_t *pi, const char *name, int idx,
	int default_value);
#endif /* BCMDBG */

#ifdef ENABLE_FCBS
bool wlc_phy_hw_fcbs_init(wlc_phy_t *ppi, int chanidx);
bool wlc_phy_hw_fcbs_init_chanidx(wlc_phy_t *ppi, int chanidx);
int wlc_phy_hw_fcbs(wlc_phy_t *ppi, int chanidx, bool set);
#endif /* ENABLE_FCBS */
extern void wlc_phy_init_test_acphy(phy_info_t *pi);
uint32 si_gci_chipstatus_acphy(si_t *sih, uint reg);
bool
wlc_phy_check_antdiv_enable_acphy(wlc_phy_t *pi);

/* Modularise and clean up attach functions */
static void BCMATTACHFN(wlc_phy_srom_attach)(phy_info_t *pi, int bandtype);
static void BCMATTACHFN(wlc_phy_std_params_attach)(phy_info_t *pi);
static void BCMATTACHFN(wlc_phy_interference_mode_attach)(phy_info_t *pi, int bandtype);
#if ((ACCONF != 0) || (NCONF != 0) || (HTCONF != 0) || (LCN40CONF != 0))
static int
wlc_phy_adjust_ed_thres(phy_info_t *pi, int32 *assert_thresh_dbm, bool set_threshold);
#endif // endif

#if (defined(WLTEST) || defined(WLPKTENG))
bool wlc_phy_isperratedpden(wlc_phy_t *ppi);
void wlc_phy_perratedpdset(wlc_phy_t *ppi, bool enable);
#endif // endif
static int wlc_phy_iovar_ocl_force_core0(phy_info_t *pi, int32 int_val,
	int32 *ret_int_ptr, bool set);

#if defined(WLTEST)
static int wlc_phy_iovar_txpwrindex_set(phy_info_t *pi, void *p);
#endif // endif

#ifdef WLC_TXCAL
static int
wlc_phy_iovar_adjusted_tssi(phy_info_t *pi, int32 *ret_int_ptr, uint8 int_val);
static int
wlc_phy_txcal_generate_pwr_tssi_tbl(phy_info_t *pi);
static int
wlc_phy_txcal_get_pwr_tssi_tbl(phy_info_t *pi, uint8 channel);
static int
wlc_phy_txcal_store_pwr_tssi_tbl(phy_info_t *pi);
#if defined(WLTEST)
static int
wlc_phy_txcal_gainsweep(phy_info_t *pi, wl_txcal_params_t *txcal_params);
#endif // endif
int
wlc_phy_txcal_generate_estpwr_lut(wl_txcal_power_tssi_t *txcal_pwr_tssi,
	uint16 *estpwr, uint8 core);
int
wlc_phy_txcal_apply_pwr_tssi_tbl(phy_info_t *pi, wl_txcal_power_tssi_t *txcal_pwr_tssi);
int
wlc_phy_txcal_apply_pa_params(phy_info_t *pi);
#endif /* WLC_TXCAL */

/* XXXX FIXME: The below macro PHY_TXFIFO_END_BLK_REV35 is a mac
* specific value ( equal to xmtfifo_sz )
* shouldn't be really defined here - Refer to PR 103560
*/
#define PHY_TXFIFO_END_BLK_REV35	(0x7900 >> 2)

/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
/*  function implementation                                     */
/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */

#define MAX_FABID_CHARS	16

#if defined(LINUX_HYBRID) || defined(BCMDBG)
char *
#ifdef BCMDBG
BCMRAMFN(phy_getvar)(phy_info_t *pi, const char *name, const char *function)
#else
BCMRAMFN(phy_getvar)(phy_info_t *pi, const char *name)
#endif // endif
{
#ifdef _MINOSL_
	return NULL;
#else
#ifdef BCMDBG
	/* Use vars pointing to itself as a flag that wlc_phy_attach is complete.
	 * Can't use NULL because it means there are no vars but we still
	 * need to potentially search NVRAM.
	 */

	if (pi->vars == (char *)&pi->vars)
		PHY_ERROR(("Usage of phy_getvar/phy_getintvar by %s after wlc_phy_attach\n",
			function));
#endif /* BCMDBG */

	ASSERT(pi->vars != (char *)&pi->vars);

	NVRAM_RECLAIM_CHECK(name);
	return phy_getvar_internal(pi, name);
#endif	/* _MINOSL_ */
}

static char *
BCMATTACHFN(phy_getvar_internal)(phy_info_t *pi, const char *name)
{
	char *vars = pi->vars;
	char *s;
	int len;

	if (!name)
		return NULL;

	len = strlen(name);
	if (len == 0)
		return NULL;

	/* first look in vars[] */
	for (s = vars; s && *s;) {
		if ((bcmp(s, name, len) == 0) && (s[len] == '='))
			return (&s[len+1]);

		while (*s++)
			;
	}

#ifdef LINUX_HYBRID
	/* Don't look elsewhere! */
	return NULL;
#else
	/* Query nvram */
	return (nvram_get(name));

#endif /* LINUX_HYBRID */
}
#else /* LINUX_HYBRID || BCMDBG */
#ifdef _MINOSL_
#define phy_getvar(pi, name)	(NULL)
#else
#define phy_getvar(pi, name)	getvar((pi)->vars, (name))
#endif /* _MINOSL_ */
#endif /* LINUX_HYBRID || BCMDBG */

char *
#ifdef BCMDBG
BCMRAMFN(phy_getvar_fabid)(phy_info_t *pi, const char *name, const char *function)
#else
BCMRAMFN(phy_getvar_fabid)(phy_info_t *pi, const char *name)
#endif // endif
{
	NVRAM_RECLAIM_CHECK(name);
#ifdef BCMDBG
	return phy_getvar_fabid_internal(pi, name, function);
#else
	return phy_getvar_fabid_internal(pi, name);
#endif // endif
}

static const char BCMATTACHDATA(rstr_dotfabdot)[] = ".fab.";
static const char BCMATTACHDATA(rstr_SdotfabdotNd)[] = "%s.fab.%d";

static char *
#ifdef BCMDBG
BCMATTACHFN(phy_getvar_fabid_internal)(phy_info_t *pi, const char *name, const char *function)
#else
BCMATTACHFN(phy_getvar_fabid_internal)(phy_info_t *pi, const char *name)
#endif // endif
{
	char *val = NULL;

	if (pi->fabid) {
		uint16 sz = (strlen(name) + strlen(rstr_dotfabdot) + MAX_FABID_CHARS);
		char *fab_name = (char *) MALLOC(pi->sh->osh, sz);
		/* Prepare fab name */
		if (fab_name == NULL) {
			PHY_ERROR(("wl%d: %s: MALLOC failure\n",
				pi->sh->unit, __FUNCTION__));
			return FALSE;
		}
		snprintf(fab_name, sz, rstr_SdotfabdotNd, name, pi->fabid);

#ifdef BCMDBG
		val = phy_getvar(pi, (const char *)fab_name, function);
#else
		val = phy_getvar(pi, (const char *)fab_name);
#endif /* BCMDBG */
		MFREE(pi->sh->osh, fab_name, sz);
	}

	if (val == NULL) {
#ifdef BCMDBG
		val = phy_getvar(pi, (const char *)name, function);
#else
		val = phy_getvar(pi, (const char *)name);
#endif /* BCMDBG */
	}

	return val;
}

int
#ifdef BCMDBG
BCMRAMFN(phy_getintvar)(phy_info_t *pi, const char *name, const char *function)
#else
BCMRAMFN(phy_getintvar)(phy_info_t *pi, const char *name)
#endif // endif
{
	return phy_getintvar_default(pi, name, 0);
}

int
BCMRAMFN(phy_getintvar_default)(phy_info_t *pi, const char *name, int default_value)
{
#ifdef _MINOSL_
	return 0;
#else
	char *val = PHY_GETVAR(pi, name);
	if (val != NULL)
		return (bcm_strtoul(val, NULL, 0));

	return (default_value);
#endif	/* _MINOSL_ */
}

int
#ifdef BCMDBG
BCMRAMFN(phy_getintvararray)(phy_info_t *pi, const char *name, int idx, const char *function)
#else
BCMRAMFN(phy_getintvararray)(phy_info_t *pi, const char *name, int idx)
#endif // endif
{
	return PHY_GETINTVAR_ARRAY_DEFAULT(pi, name, idx, 0);
}

int
#ifdef BCMDBG
BCMRAMFN(phy_getintvararray_default)(phy_info_t *pi, const char *name, int idx, int default_value,
	const char *function)
#else
BCMRAMFN(phy_getintvararray_default)(phy_info_t *pi, const char *name, int idx, int default_value)
#endif // endif
{
	/* Rely on PHY_GETVAR() doing the NVRAM_RECLAIM_CHECK() */
	if (PHY_GETVAR(pi, name)) {
#ifdef BCMDBG
		return phy_getintvararray_default_internal(pi, name, idx, default_value, function);
#else
		return phy_getintvararray_default_internal(pi, name, idx, default_value);
#endif // endif
	} else return default_value;
}
static int
#ifdef BCMDBG
BCMATTACHFN(phy_getintvararray_default_internal)(phy_info_t *pi, const char *name, int idx,
	int default_value, const char *function)
#else
BCMATTACHFN(phy_getintvararray_default_internal)(phy_info_t *pi, const char *name, int idx,
	int default_value)
#endif // endif
{
	int i, val;
	char *vars = pi->vars;
	char *fabspf = NULL;

	val = default_value;
	/* Check if fab specific values are present in the NVRAM
	*  if present, replace the regular value with the fab specific
	*/
	if (pi->fabid) {
		uint16 sz = (strlen(name) + strlen(rstr_dotfabdot) + MAX_FABID_CHARS);
		char *fab_name = (char *) MALLOC(pi->sh->osh, sz);
		/* Prepare fab name */
		if (fab_name == NULL) {
			PHY_ERROR(("wl%d: %s: MALLOC failure\n",
				pi->sh->unit, __FUNCTION__));
			return FALSE;
		}
		snprintf(fab_name, sz, rstr_SdotfabdotNd, name, pi->fabid);
		/* Get the value from fabid specific first if present
		*  Assumption: param.fab.<fabid>.fab.<fabid> never exist
		*/
		fabspf = PHY_GETVAR(pi, (const char *)fab_name);
		if (fabspf != NULL) {
			i = getintvararraysize(vars, fab_name);
			if ((i == 0) || (i <= idx))
				val = default_value;
			else
				val = getintvararray(vars, fab_name, idx);
		}
		MFREE(pi->sh->osh, fab_name, sz);
	}

	if (fabspf == NULL) {
		i = getintvararraysize(vars, name);
		if ((i == 0) || (i <= idx))
			val = default_value;
		else
			val = getintvararray(vars, name, idx);
	}
	return val;
}

/* coordinate with MAC before access PHY register */
void
wlc_phyreg_enter(wlc_phy_t *pih)
{
#ifdef STA
	phy_info_t *pi = (phy_info_t*)pih;

	/* track the nested enter calls */
	pi->phyreg_enter_depth++;
	if (pi->phyreg_enter_depth > 1)
		return;

	wlapi_bmac_ucode_wake_override_phyreg_set(pi->sh->physhim);
#endif // endif
}

void
wlc_phyreg_exit(wlc_phy_t *pih)
{
#ifdef STA
	phy_info_t *pi = (phy_info_t*)pih;

	ASSERT(pi->phyreg_enter_depth > 0);
	pi->phyreg_enter_depth--;
	if (pi->phyreg_enter_depth > 0)
		return;

	wlapi_bmac_ucode_wake_override_phyreg_clear(pi->sh->physhim);
#endif // endif
}

/* coordinate with MAC before access RADIO register */
void
wlc_radioreg_enter(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, MCTL_LOCK_RADIO);

	/* allow any ucode radio reg access to complete */
	OSL_DELAY(10);
}

void
wlc_radioreg_exit(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	volatile uint16 dummy;

	/* allow our radio reg access to complete */
	dummy = R_REG(pi->sh->osh, &pi->regs->phyversion);
	BCM_REFERENCE(dummy);

	pi->phy_wreg = 0;
	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_LOCK_RADIO, 0);
}

/* All radio regs other than idcode are less than 16bits, so
 * {read, write}_radio_reg access the low 16bits only.
 * When reading the idcode use read_radio_id instead.
 */
uint16
read_radio_reg(phy_info_t *pi, uint16 addr)
{
	uint16 data;

	if ((addr == RADIO_IDCODE) && (!ISHTPHY(pi)) && (!ISACPHY(pi)))
		return 0xffff;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid radio address access */

	switch (pi->pubpi.phy_type) {
	case PHY_TYPE_A:
		CASECHECK(PHYTYPE, PHY_TYPE_A);
		addr |= RADIO_2060WW_READ_OFF;
		break;

	case PHY_TYPE_G:
		CASECHECK(PHYTYPE, PHY_TYPE_G);
		addr |= RADIO_2050_READ_OFF;
		break;

	case PHY_TYPE_N:
		CASECHECK(PHYTYPE, PHY_TYPE_N);
		if (NREV_GE(pi->pubpi.phy_rev, 7)) {
			if (NREV_IS(pi->pubpi.phy_rev, 19))
				addr |= RADIO_20671_READ_OFF;
			else
				addr |= RADIO_2057_READ_OFF;
		} else
			addr |= RADIO_2055_READ_OFF;  /* works for 2056 too */
		break;

	case PHY_TYPE_HT:
		CASECHECK(PHYTYPE, PHY_TYPE_HT);
		addr |= RADIO_2059_READ_OFF;
		break;

	case PHY_TYPE_AC:
		/* No need to add any offset to the read address for ACPHY */
		CASECHECK(PHYTYPE, PHY_TYPE_AC);
		break;

	case PHY_TYPE_LP:
		CASECHECK(PHYTYPE, PHY_TYPE_LP);
		if (BCM2063_ID == LPPHY_RADIO_ID(pi)) {
			addr |= RADIO_2063_READ_OFF;
		} else {
			addr |= RADIO_2062_READ_OFF;
		}
		break;

	case PHY_TYPE_SSN:
		CASECHECK(PHYTYPE, PHY_TYPE_SSN);
		addr |= RADIO_2063_READ_OFF;
		break;
	case PHY_TYPE_LCN:
		CASECHECK(PHYTYPE, PHY_TYPE_LCN);
		addr |= RADIO_2064_READ_OFF;
		break;
	case PHY_TYPE_LCN20:
		break;
	case PHY_TYPE_LCN40:
		CASECHECK(PHYTYPE, PHY_TYPE_LCN40);
		addr |= RADIO_2065_READ_OFF;
		break;
	default:
		ASSERT(VALID_PHYTYPE(pi));
	}

	if ((D11REV_GE(pi->sh->corerev, 24) && !D11REV_IS(pi->sh->corerev, 27)) ||
	    (D11REV_IS(pi->sh->corerev, 22) && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, addr);
#ifdef __mips__
		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
#endif // endif
		data = R_REG(pi->sh->osh, &pi->regs->radioregdata);
	} else {
		W_REG(pi->sh->osh, &pi->regs->phy4waddr, addr);
#ifdef __mips__
		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
#endif // endif

#ifdef __ARM_ARCH_4T__
		__asm__(" .align 4 ");
		__asm__(" nop ");
		data = R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
#else
		data = R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
#endif // endif

	}
	pi->phy_wreg = 0;	/* clear reg write metering */

	return data;
}

#if defined(BCMDBG_PHYREGS_TRACE)
uint16
read_radio_reg_debug(phy_info_t *pi, uint16 addr, const char *reg_name)
{
	/* Check for valid radio address access */
	if (addr == INVALID_ADDRESS) {
		PHY_ERROR(("wl%d: Reg \"%s\" invalid for radio rev %d\n", pi->sh->unit,
		          reg_name, RADIOREV(pi->pubpi.radiorev)));

		ASSERT(addr != INVALID_ADDRESS);

		return 0xffffU;
	}

	return read_radio_reg(pi, addr);
}
#endif /* BCMDBG_PHYREGS_TRACE */

void
write_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
{
	osl_t *osh;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	osh = pi->sh->osh;

	/* The nphy chips with with corerev 22 have the new i/f, the one with
	 * ssnphy (4319b0) does not.
	 */
	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
			(void)R_REG(osh, &pi->regs->maccontrol);
			pi->phy_wreg = 0;
		}
	}
	if ((D11REV_GE(pi->sh->corerev, 24) && !D11REV_IS(pi->sh->corerev, 27)) ||
	    (D11REV_IS(pi->sh->corerev, 22) && (pi->pubpi.phy_type != PHY_TYPE_SSN))) {

		W_REG(osh, &pi->regs->radioregaddr, addr);
#ifdef __mips__
		(void)R_REG(osh, &pi->regs->radioregaddr);
#endif // endif
		W_REG(osh, &pi->regs->radioregdata, val);
	} else {
		W_REG(osh, &pi->regs->phy4waddr, addr);
#ifdef __mips__
		(void)R_REG(osh, &pi->regs->phy4waddr);
#endif // endif
		W_REG(osh, &pi->regs->phy4wdatalo, val);
	}

	if ((BUSTYPE(pi->sh->bustype) == PCMCIA_BUS) &&
	    (pi->sh->buscorerev <= 3)) {
		volatile uint16 dummy = R_REG(osh, &pi->regs->phyversion);

		BCM_REFERENCE(dummy);
	}
}

static uint32
read_radio_id(phy_info_t *pi)
{
	uint32 id;

	/* XXX: Router build failures using this:
	 * XXX:   D11REV_IS(pi->sh->corerev, 33)
	 * XXX: Temp fix for now.
	 */
	if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
		uint32 rnum;

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
		rnum = (uint32)R_REG(pi->sh->osh, &pi->regs->radioregdata);
		if (CHIP_4324_B3(pi) || CHIP_4324_B4(pi) || CHIP_4324_B5(pi)) {
			rnum = (rnum >> 4) & 0xF;
		} else {
			rnum = (rnum >> 0) & 0xF;
		}
		if (CHIPID_4324X_MEDIA_A1(pi)) {
			ASSERT(rnum == 1);
			/* patch radiorev to 2 to differentiate from 4324B4 */
			rnum = 2;
		}

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
		id = (R_REG(pi->sh->osh, &pi->regs->radioregdata) <<
			IDCODE_ID_SHIFT) | (rnum << IDCODE_REV_SHIFT);

	} else if (ISLCN40PHY(pi)) {
		uint32 rev, ver;

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
		rev = (uint32)R_REG(pi->sh->osh, &pi->regs->radioregdata);
		ver = rev & 0xF;
		rev = (rev >> 4) & 0xF;

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
		id = R_REG(pi->sh->osh, &pi->regs->radioregdata);
		/* The format of all other PHY is like the following:
		 * id = (rev << IDCODE_REV_SHIFT) | (R_REG(pi->sh->osh, &pi->regs->radioregdata)
		 * 	<< IDCODE_ID_SHIFT) | ver;
		 * the LCN40PHY team decided that we should use RADIOVER only, so
		 * it becomes the following format:
		 */
		if (RADIOID(id) == BCM2065_ID && RADIOVER(ver) == 2)
			id = (rev << IDCODE_REV_SHIFT) | (id << IDCODE_ID_SHIFT) | ver;
		else if (rev == 6)
			id = (id << IDCODE_ID_SHIFT) | ver;
		else
			id = (id << IDCODE_ID_SHIFT) | rev;
	} else if (D11REV_GE(pi->sh->corerev, 24) && !D11REV_IS(pi->sh->corerev, 27)) {
		uint32 b0, b1, b2;

		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 0);
#ifdef __mips__
		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
#endif // endif
		b0 = (uint32)R_REG(pi->sh->osh, &pi->regs->radioregdata);
		W_REG(pi->sh->osh, &pi->regs->radioregaddr, 1);
#ifdef __mips__
		(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
#endif // endif
		b1 = (uint32)R_REG(pi->sh->osh, &pi->regs->radioregdata);

		if (ISACPHY(pi)) {
			/* For ACPHY (starting with 4360A0), address 0 has the revid and
			   address 1 has the devid
			*/
			id = (b0 << 16) | b1;
		} else {
			W_REG(pi->sh->osh, &pi->regs->radioregaddr, 2);
#ifdef __mips__
			(void)R_REG(pi->sh->osh, &pi->regs->radioregaddr);
#endif // endif
			b2 = (uint32)R_REG(pi->sh->osh, &pi->regs->radioregdata);
			id = ((b0  & 0xf) << 28) | (((b2 << 8) | b1) << 12) | ((b0 >> 4) & 0xf);
		}
	} else {
		W_REG(pi->sh->osh, &pi->regs->phy4waddr, RADIO_IDCODE);
#ifdef __mips__
		(void)R_REG(pi->sh->osh, &pi->regs->phy4waddr);
#endif // endif
		id = (uint32)R_REG(pi->sh->osh, &pi->regs->phy4wdatalo);
		id |= (uint32)R_REG(pi->sh->osh, &pi->regs->phy4wdatahi) << 16;
	}
	pi->phy_wreg = 0;	/* clear reg write metering */

#ifdef BCMRADIOREV
	/*
	 * Override the radiorev to a fixed value if running in QT/Sim.  This is to avoid needing
	 * a different QTDB build for each radio rev build (for the same chip).
	 * Note: if BCMRADIOREV is not known, then use whatever is read from the chip (i.e. no
	 *       override).
	 */
	if (ISSIM_ENAB(pi->sh->sih)) {
		if (ISACPHY(pi)) {
			id = (id & ~IDCODE_ACPHY_REV_MASK) |
			     (BCMRADIOREV << IDCODE_ACPHY_REV_SHIFT);
		} else {
			id = (id & ~IDCODE_REV_MASK) | (BCMRADIOREV << IDCODE_REV_SHIFT);
		}
	}
#endif	/* BCMRADIOREV */

	return id;
}

void
and_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
{
	uint16 rval = read_radio_reg(pi, addr);

	write_radio_reg(pi, addr, (rval & val));
}

void
or_radio_reg(phy_info_t *pi, uint16 addr, uint16 val)
{
	uint16 rval = read_radio_reg(pi, addr);

	write_radio_reg(pi, addr, (rval | val));
}

void
xor_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask)
{
	uint16 rval = read_radio_reg(pi, addr);

	write_radio_reg(pi, addr, (rval ^ mask));
}

void
mod_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
{
	uint16 rval = read_radio_reg(pi, addr);

	write_radio_reg(pi, addr, (rval & ~mask) | (val & mask));
}

#if defined(BCMDBG_PHYREGS_TRACE)
void
mod_radio_reg_debug(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val, const char *reg_name)
{
	/* Check for valid radio address access */
	if (addr == INVALID_ADDRESS) {
		PHY_ERROR(("wl%d: Reg \"%s\" invalid for radio rev %d\n", pi->sh->unit,
		          reg_name, RADIOREV(pi->pubpi.radiorev)));

		ASSERT(addr != INVALID_ADDRESS);
	} else {
		mod_radio_reg(pi, addr, mask, val);
	}
}
#endif /* BCMDBG_PHYREGS_TRACE */

void
gen_radio_reg(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val,
	uint16* orig_reg_addr, uint16* orig_reg_data,
	uint16* updated_reg_addr, uint16* updated_reg_data)
{
	*orig_reg_addr = addr;
	*orig_reg_data = read_radio_reg(pi, addr);

	*updated_reg_addr = addr;
	*updated_reg_data = ((*orig_reg_data) & ~mask) | (val & mask);
}

void
write_phy_channel_reg(phy_info_t *pi, uint val)
{
	volatile uint16 dummy;

	W_REG(pi->sh->osh, &pi->regs->phychannel, val);

	if ((BUSTYPE(pi->sh->bustype) == PCMCIA_BUS) &&
	    (pi->sh->buscorerev <= 3)) {
		dummy = R_REG(pi->sh->osh, &pi->regs->phyversion);
		BCM_REFERENCE(dummy);
	}
}

#if defined(BCMASSERT_SUPPORT)
static bool
wlc_phy_war41476(phy_info_t *pi)
{
	/*
	 * XXX PR41476 WAR: Prevent MAC from accessing PHY registers while the host is
	 * For Corerev 11 and 12, make sure that
	 *       * either the MAC is disabled, or
	 *       * MCTL_PHYLOCK is set that ucode checks before reading phyreg
	 * This prevents collision for phy read access between Host and Ucode
	 */
	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);

	return ((mc & MCTL_EN_MAC) == 0) || ((mc & MCTL_PHYLOCK) == MCTL_PHYLOCK);
}
#endif /* BCMASSERT_SUPPORT */

uint16
phy_reg_read(phy_info_t *pi, uint16 addr)
{
	d11regs_t *regs = pi->regs;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid PHY address access */

	W_REG(pi->sh->osh, &regs->phyregaddr, addr);
#ifdef __mips__
	(void)R_REG(pi->sh->osh, &regs->phyregaddr);
#endif // endif

	/* PR41476 for core 11/12
	 * Don't check the WAR for non-11/12 cores
	 */
	ASSERT(!(D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) ||
	       wlc_phy_war41476(pi));

	pi->phy_wreg = 0;	/* clear reg write metering */
	return (R_REG(pi->sh->osh, &regs->phyregdata));
}

#if defined(BCMDBG_PHYREGS_TRACE)
uint16
phy_reg_read_debug(phy_info_t *pi, uint16 addr, const char *reg_name)
{
	/* Check for valid phy address access */
	if (addr == INVALID_ADDRESS) {
		PHY_ERROR(("wl%d: Reg \"%s\" invalid for phy rev %d\n", pi->sh->unit,
		          reg_name, pi->pubpi.phy_rev));

		ASSERT(addr != INVALID_ADDRESS);

		return 0xffffU;
	}

	return phy_reg_read(pi, addr);
}
#endif /* BCMDBG_PHYREGS_TRACE */

uint16
phy_reg_read_wide(phy_info_t *pi)
{
	pi->phy_wreg = 0;	/* clear reg write metering */

	return (R_REG(pi->sh->osh, &pi->regs->phyregdata));
}

void phy_reg_write_array(void* pi, const uint16* regp, int length)
{
	ASSERT(regp != NULL && length > 0);
	while (length-- > 0)
	{
		uint16 addr;
		uint16 access_type;
#if defined(DONGLEBUILD) && (BCMCHIPID != BCM4328_CHIP_ID)
		access_type = *regp & PHY_RADIO_REG_MASK_TYPE;
		addr = *regp++ & ~PHY_RADIO_REG_MASK_TYPE;
#else
		access_type = *regp++ & PHY_RADIO_REG_MASK_TYPE;
		--length;
		addr = *regp++ & ~PHY_RADIO_REG_MASK_TYPE;
#endif // endif
		switch (access_type)
		{
			case PHY_REG_MOD_TYPE:
				phy_reg_mod(pi, addr, *regp, *(regp+1));
				++regp;
				--length;
				break;
			case PHY_REG_MOD_TYPE | RADIO_REG_TYPE:
				mod_radio_reg(pi, addr, *regp, *(regp+1));
				++regp;
				--length;
				break;

			case PHY_REG_WRITE_TYPE:
				phy_reg_write(pi, addr, *regp);
				break;

			case PHY_REG_WRITE_TYPE | RADIO_REG_TYPE:
				write_radio_reg(pi, addr, *regp);
				break;

			case PHY_REG_AND_TYPE:
				phy_reg_and(pi, addr, *regp);
				break;

			case PHY_REG_AND_TYPE | RADIO_REG_TYPE:
				and_radio_reg(pi, addr, *regp);
				break;

			case PHY_REG_OR_TYPE:
				phy_reg_or(pi, addr, *regp);
				break;

			case PHY_REG_OR_TYPE | RADIO_REG_TYPE:
				or_radio_reg(pi, addr, *regp);
				break;

			default: ASSERT(0);
		}
		++regp;
		--length;
	}
}

void
phy_reg_write(phy_info_t *pi, uint16 addr, uint16 val)
{
	d11regs_t *regs = pi->regs;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid PHY address access */

#ifdef __mips__
	W_REG(pi->sh->osh, &regs->phyregaddr, addr);
	(void)R_REG(pi->sh->osh, &regs->phyregaddr);
	W_REG(pi->sh->osh, &regs->phyregdata, val);
	if (addr == NPHY_TableAddress)
		(void)R_REG(pi->sh->osh, &regs->phyregdata);
#else
	if (BUSTYPE(pi->sh->bustype) == PCI_BUS) {
		if (++pi->phy_wreg >= pi->phy_wreg_limit) {
			pi->phy_wreg = 0;
			(void)R_REG(pi->sh->osh, &regs->phyversion);
		}
	}
	W_REG(pi->sh->osh, (volatile uint32 *)(uintptr)(&regs->phyregaddr), addr | (val << 16));
#endif /* __mips__ */
}

#if defined(BCMDBG_PHYREGS_TRACE)
void
phy_reg_write_debug(phy_info_t *pi, uint16 addr, uint16 val, const char *reg_name)
{
	/* Check for valid phy address access */
	if (addr == INVALID_ADDRESS) {
		PHY_ERROR(("wl%d: Reg \"%s\" invalid for phy rev %d\n", pi->sh->unit,
		          reg_name, pi->pubpi.phy_rev));

		ASSERT(addr != INVALID_ADDRESS);
	}

	phy_reg_write(pi, addr, val);
}
#endif /* BCMDBG_PHYREGS_TRACE */

void
phy_reg_write_wide(phy_info_t *pi, uint16 val)
{
	W_REG(pi->sh->osh, &pi->regs->phyregdata, val);
}

void
phy_reg_and(phy_info_t *pi, uint16 addr, uint16 val)
{
	d11regs_t *regs = pi->regs;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid PHY address access */

	W_REG(pi->sh->osh, &regs->phyregaddr, addr);
#ifdef __mips__
	(void)R_REG(pi->sh->osh, &regs->phyregaddr);
#endif // endif

	ASSERT(!(D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) ||
	       wlc_phy_war41476(pi));

	W_REG(pi->sh->osh, &regs->phyregdata, (R_REG(pi->sh->osh, &regs->phyregdata) & val));
	pi->phy_wreg = 0;	/* clear reg write metering */
}

void
phy_reg_or(phy_info_t *pi, uint16 addr, uint16 val)
{
	d11regs_t *regs = pi->regs;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid PHY address access */

	W_REG(pi->sh->osh, &regs->phyregaddr, addr);
#ifdef __mips__
	(void)R_REG(pi->sh->osh, &regs->phyregaddr);
#endif // endif

	ASSERT(!(D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) ||
	       wlc_phy_war41476(pi));

	W_REG(pi->sh->osh, &regs->phyregdata, (R_REG(pi->sh->osh, &regs->phyregdata) | val));
	pi->phy_wreg = 0;	/* clear reg write metering */
}

void
phy_reg_mod(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val)
{
	d11regs_t *regs = pi->regs;

	ASSERT(addr != INVALID_ADDRESS);	/* Check for valid PHY address access */

	W_REG(pi->sh->osh, &regs->phyregaddr, addr);
#ifdef __mips__
	(void)R_REG(pi->sh->osh, &regs->phyregaddr);
#endif // endif

	ASSERT(!(D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) ||
	       wlc_phy_war41476(pi));

	W_REG(pi->sh->osh, &regs->phyregdata,
	      ((R_REG(pi->sh->osh, &regs->phyregdata) & ~mask) | (val & mask)));
	pi->phy_wreg = 0;	/* clear reg write metering */
}

#if defined(BCMDBG_PHYREGS_TRACE)
void
phy_reg_mod_debug(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val, const char *reg_name)
{
	/* Check for valid phy address access */
	if (addr == INVALID_ADDRESS) {
		PHY_ERROR(("wl%d: Reg \"%s\" invalid for phy rev %d\n", pi->sh->unit,
		          reg_name, pi->pubpi.phy_rev));

		ASSERT(addr != INVALID_ADDRESS);
	} else {
		phy_reg_mod(pi, addr, mask, val);
	}
}
#endif /* BCMDBG_PHYREGS_TRACE */

void
phy_reg_gen(phy_info_t *pi, uint16 addr, uint16 mask, uint16 val,
	uint16* orig_reg_addr, uint16* orig_reg_data,
	uint16* updated_reg_addr, uint16* updated_reg_data)
{
	*orig_reg_addr = addr;
	*orig_reg_data = phy_reg_read(pi, addr);

	*updated_reg_addr = addr;
	*updated_reg_data = (((*orig_reg_data) & ~mask) | (val & mask));
}

static void
WLBANDINITFN(wlc_set_phy_uninitted)(phy_info_t *pi)
{
	int i = 0;
	/* Prepare for one-time initializations */
	pi->initialized = FALSE;
	pi->txpwridx = -1;
	pi->phy_spuravoid = SPURAVOID_AUTO;
	if (ISABGPHY(pi))
		wlc_set_uninitted_abgphy(pi);

	if (ISNPHY(pi)) {
		wlc_set_uninitted_nphy(pi);
	} else if (ISHTPHY(pi)) {
		for (i = 0; i < PHY_CORE_MAX; i++)
			pi->u.pi_htphy->txpwrindex[i] = 40;
	} else if (ISACPHY(pi)) {
		for (i = 0; i < PHY_CORE_MAX; i++) {
			if (ACMAJORREV_1(pi->pubpi.phy_rev))
				pi->u.pi_acphy->txpwrindex[i] = 60;
			else
				pi->u.pi_acphy->txpwrindex[i] = 64;
		}
	}
}

/* returns a pointer to per interface instance data */
shared_phy_t *
BCMATTACHFN(wlc_phy_shared_attach)(shared_phy_params_t *shp)
{
	shared_phy_t *sh;
#ifdef EVENT_LOG_COMPILE
	/* First thing to do.. initialize the PHY_ERROR tag's attributes. */
	/* This is the attach function for the PHY component. */
	event_log_tag_start(EVENT_LOG_TAG_PHY_ERROR, EVENT_LOG_SET_ERROR,
		EVENT_LOG_TAG_FLAG_LOG);
#endif // endif

	/* allocate wlc_info_t state structure */
	if ((sh = (shared_phy_t*) MALLOC(shp->osh, sizeof(shared_phy_t))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
			shp->unit, __FUNCTION__, MALLOCED(shp->osh)));
		return NULL;
	}
	bzero((char*)sh, sizeof(shared_phy_t));

	sh->osh = shp->osh;
	sh->sih = shp->sih;
	sh->physhim = shp->physhim;
	sh->unit = shp->unit;
	sh->corerev = shp->corerev;

	sh->vid = shp->vid;
	sh->did = shp->did;
	sh->chip = shp->chip;
	sh->chiprev = shp->chiprev;
	sh->chippkg = shp->chippkg;
	sh->sromrev = shp->sromrev;
	sh->boardtype = shp->boardtype;
	sh->boardrev = shp->boardrev;
	sh->boardvendor = shp->boardvendor;
	sh->boardflags = shp->boardflags;
	sh->boardflags2 = shp->boardflags2;
	sh->bustype = shp->bustype;
	sh->buscorerev = shp->buscorerev;

	/* create our timers */
	sh->fast_timer = PHY_SW_TIMER_FAST;
	sh->slow_timer = PHY_SW_TIMER_SLOW;
	sh->glacial_timer = PHY_SW_TIMER_GLACIAL;
	sh->noise_meas_timer = PHY_SW_TIMER_NOISE_MEAS;

	/* ACI mitigation mode is auto by default */
	sh->interference_mode = WLAN_AUTO;
	sh->rssi_mode = RSSI_ANT_MERGE_MAX;
	/* sh->snr_mode = SNR_ANT_MERGE_MAX; */
#ifdef WLMEDIA_TXFILTER_OVERRIDE
	sh->txfilter_sm_override = WLC_TXFILTER_OVERRIDE_DISABLED;
#endif /* WLMEDIA_TXFILTER_OVERRIDE */

	return sh;
}

void
BCMATTACHFN(wlc_phy_shared_detach)(shared_phy_t *phy_sh)
{
	if (phy_sh) {
		/* phy_head must have been all detached */
		if (phy_sh->phy_head) {
			PHY_ERROR(("wl%d: %s non NULL phy_head\n", phy_sh->unit, __FUNCTION__));
			ASSERT(!phy_sh->phy_head);
		}
		MFREE(phy_sh->osh, phy_sh, sizeof(shared_phy_t));
	}
}

static int
BCMATTACHFN(wlc_phy_radio_attach)(phy_info_t *pi)
{
	int bcmerror = BCME_OK;
	uint32 idcode = wlc_phy_get_radio_ver(pi);

#ifdef UNRELEASEDCHIP
	if (CHIPID(pi->sh->chip) == BCM43430_CHIP_ID) {
		/* ****** Hack for now */
		if (ISLCN20PHY(pi))
			return bcmerror;
	}
#endif /* UNRELEASEDCHIP */

#if ACCONF != 0
	if (ISACPHY(pi)) {
		pi->pubpi.radioid = (idcode & IDCODE_ACPHY_ID_MASK) >> IDCODE_ACPHY_ID_SHIFT;
		pi->pubpi.radiorev = (idcode & IDCODE_ACPHY_REV_MASK) >> IDCODE_ACPHY_REV_SHIFT;
		pi->pubpi.radiorev_orig = pi->pubpi.radiorev;

		if (TINY_RADIO(pi)) {
			/*
			 * For the 20691, rev 81 is treated exactly the same as rev 68.
			 * This hack is to prevent duplicating code and tables.
			 */
			if (RADIOID(pi->pubpi.radioid) == BCM20691_ID && pi->pubpi.radiorev == 81) {
				PHY_INFORM(("wl%d: changing 20691 radio revid from 81 to 68\n",
				            pi->sh->unit));
				pi->pubpi.radiorev = 68;
			}

			pi->pubpi.radiomajorrev = RADIO20691_MAJORREV(pi->pubpi.radiorev);
			pi->pubpi.radiominorrev = RADIO20691_MINORREV(pi->pubpi.radiorev);
		} else {
			pi->pubpi.radiomajorrev = (idcode & IDCODE_ACPHY_MAJORREV_MASK) >>
			                          IDCODE_ACPHY_MAJORREV_SHIFT;
			pi->pubpi.radiominorrev = (idcode & IDCODE_ACPHY_MINORREV_MASK) >>
			                          IDCODE_ACPHY_MINORREV_SHIFT;
			if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
			    (pi->pubpi.radiorev == 45 || pi->pubpi.radiorev == 43)) {
				PHY_INFORM(("wl%d: changing 2069 radio revid from %d to 42\n",
				            pi->sh->unit, pi->pubpi.radiorev));
				pi->pubpi.radiorev = 42;
				pi->pubpi.radiominorrev = 10;
			}
		}
		pi->pubpi.radiover = 0;
	} else
#endif /* ACCONF != 0 */
	{
		pi->pubpi.radioid = (idcode & IDCODE_ID_MASK) >> IDCODE_ID_SHIFT;
		pi->pubpi.radiorev = (idcode & IDCODE_REV_MASK) >> IDCODE_REV_SHIFT;
		pi->pubpi.radiorev_orig = RADIOREV(pi->pubpi.radiorev);
		/* PR 81520: radiover is a new radio ID field post corerev 24
		 * FIXME: need to handle pre corerev 24 radios, eg, init radiover to 0xff
		 */

		if (ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 4) ||
		    CHIPID_4324X_MEDIA_FAMILY(pi))) {
			/* 4324B0, 4324B2, 43242/43243, 4324B1/B3/B5 */
			pi->pubpi.radiover = RADIOVER(pi->pubpi.radiover);
		} else {
			pi->pubpi.radiover = (idcode & IDCODE_VER_MASK) >> IDCODE_VER_SHIFT;
		}
	}

#if defined(DSLCPE) && defined(CONFIG_BCM963268)
	if (CHIPID(pi->sh->chip) == BCM6362_CHIP_ID) {
		/* overriding radiover to 8 */
		pi->pubpi.radiorev = 8;
	}
#endif /* defined(DSLCPE) && defined(CONFIG_BCM963268) */

	if (VALID_RADIO(pi, RADIOID(pi->pubpi.radioid))) {
		/* ensure that the built image matches the target */
#ifdef BCMRADIOID
		if (pi->pubpi.radioid != BCMRADIOID)
			PHY_ERROR(("%s: Chip's radioid=0x%x, BCMRADIOID=0x%x\n",
			           __FUNCTION__, pi->pubpi.radioid, BCMRADIOID));
		ASSERT(pi->pubpi.radioid == BCMRADIOID);
#endif // endif
#ifdef BCMRADIOREV
		if (pi->pubpi.radiorev != BCMRADIOREV)
			PHY_ERROR(("%s: Chip's radiorev=%d, BCMRADIOREV=%d\n",
			           __FUNCTION__, pi->pubpi.radiorev, BCMRADIOREV));
		ASSERT(pi->pubpi.radiorev == BCMRADIOREV);
#endif // endif
	} else {
		PHY_ERROR(("wl%d: %s: Unknown radio ID: 0x%x rev 0x%x phy %d, phyrev %d\n",
		          pi->sh->unit, __FUNCTION__,
		          RADIOID(pi->pubpi.radioid), RADIOREV(pi->pubpi.radiorev),
		          pi->pubpi.phy_type, pi->pubpi.phy_rev));
		bcmerror = BCME_UNSUPPORTED;
	}

	return bcmerror;
}

static const char BCMATTACHDATA(rstr_interference)[] = "interference";
static const char BCMATTACHDATA(rstr_txpwrbckof)[] = "txpwrbckof";
static const char BCMATTACHDATA(rstr_tssilimucod)[] = "tssilimucod";
static const char BCMATTACHDATA(rstr_rssicorrnorm)[] = "rssicorrnorm";
static const char BCMATTACHDATA(rstr_rssicorratten)[] = "rssicorratten";
static const char BCMATTACHDATA(rstr_rssicorrnorm5g)[] = "rssicorrnorm5g";
static const char BCMATTACHDATA(rstr_rssicorratten5g)[] = "rssicorratten5g";
static const char BCMATTACHDATA(rstr_rssicorrperrg2g)[] = "rssicorrperrg2g";
static const char BCMATTACHDATA(rstr_rssicorrperrg5g)[] = "rssicorrperrg5g";
static const char BCMATTACHDATA(rstr_5g_cga)[] = "5g_cga";
static const char BCMATTACHDATA(rstr_2g_cga)[] = "2g_cga";
static const char BCMATTACHDATA(rstr_phycal)[] = "phycal";

static const char BCMATTACHDATA(rstr_phycal_tempdelta)[] = "phycal_tempdelta";
static const char BCMATTACHDATA(rstr_mintxpower)[] = "mintxpower";
#if defined(RXDESENS_EN)
static const char BCMATTACHDATA(rstr_phyrxdesens)[] = "phyrxdesens";
#endif // endif

/*
 * Read the phy calibration temperature delta parameters from NVRAM.
 */
static void
BCMATTACHFN(wlc_phy_read_tempdelta_settings)(phy_info_t *pi, int maxtempdelta)
{
	/* Read the temperature delta from NVRAM */
	pi->phycal_tempdelta = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_phycal_tempdelta, 0);

	/* For ACPHY, if the SROM contains a bogus value, then tempdelta
	 * will default to ACPHY_DEFAULT_CAL_TEMPDELTA. If the SROM contains
	 * a valid value, then the default will be overwritten with this value
	 */
		pi->phycal_tempdelta_default = ACPHY_DEFAULT_CAL_TEMPDELTA;

	/* Range check, disable if incorrect configuration parameter */
	/* Preserve default, in case someone wants to use it. */
	if (pi->phycal_tempdelta > maxtempdelta)
		pi->phycal_tempdelta = pi->phycal_tempdelta_default;
	else
		pi->phycal_tempdelta_default = pi->phycal_tempdelta;
}

/* Figure out if we have a phy for the requested band and attach to it */
wlc_phy_t *
BCMATTACHFN(wlc_phy_attach)(shared_phy_t *sh, void *regs, int bandtype, char *vars)
{
	phy_info_t *pi;
	uint32 sflags = 0;
	uint phyversion;
	int i, j;
	osl_t *osh = sh->osh;

	PHY_TRACE(("wl: %s(%p, %d, %p)\n", __FUNCTION__, regs, bandtype, sh));

	if (D11REV_IS(sh->corerev, 4))
		sflags = SISF_2G_PHY | SISF_5G_PHY;
	else
		sflags = si_core_sflags(sh->sih, 0, 0);

	if (BAND_5G(bandtype)) {
		if ((sflags & (SISF_5G_PHY | SISF_DB_PHY)) == 0) {
			PHY_ERROR(("wl%d: %s: No phy available for 5G\n",
			          sh->unit, __FUNCTION__));
			return NULL;
		}
	}

	if ((sflags & SISF_DB_PHY) && (pi = sh->phy_head)) {
		pi->vars = vars;
		/* For the second band in dualband phys, load the band specific
		  * NVRAM parameters
		  * The second condition excludes UNO3 inorder to
		  * keep the device id as 0x4360 (dual band).
		  * Purely to be backward compatible to previous UNO3 NVRAM file.
		  *
		*/
		if (ISLCNPHY(pi) &&
		    !(pi->sh->boardtype == 0x0551 && CHIPID(pi->sh->chip) == BCM4330_CHIP_ID) &&
		    !wlc_phy_txpwr_srom_read_lcnphy(pi, bandtype)) {
			pi->refcnt++;
			goto err;
		}
		/* For the second band in dualband phys, just bring the core back out of reset */
		wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);

		pi->refcnt++;
		goto exit;
	}

	/* ONLY common PI is allocated. pi->u.pi_xphy is not available yet */
	if ((pi = (phy_info_t *)MALLOC(osh, sizeof(phy_info_t))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", sh->unit,
		          __FUNCTION__, MALLOCED(osh)));
		return NULL;
	}
	bzero((char *)pi, sizeof(phy_info_t));

#ifdef WLTXPWR_PER_CORE
	/* Allocated power targets. */
	if ((pi->p_tx_user_target = (int8*)MALLOCZ(osh, WL_TXPWR_CORE_MAX)) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", sh->unit,
		          __FUNCTION__, MALLOCED(osh)));
		goto err;
	}

	if ((pi->p_openlp_tx_power_min = (int8*)MALLOCZ(osh, WL_TXPWR_CORE_MAX)) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", sh->unit,
		          __FUNCTION__, MALLOCED(osh)));
		goto err;
	}
#endif /* WLTXPWR_PER_CORE */

	pi->regs = (d11regs_t *)regs;
	pi->sh = sh;
	pi->vars = vars;

	/* Good phy, increase refcnt and put it in list */
	pi->refcnt++;
	pi->next = pi->sh->phy_head;
	sh->phy_head = pi;

	/* set init power on reset to TRUE */
	pi->phy_init_por = TRUE;

#ifdef WLNOKIA_NVMEM
	pi->noknvmem = wlc_phy_noknvmem_attach(osh, pi);
	if (pi->noknvmem == NULL) {
		PHY_ERROR(("wl%d: %s: wlc_phy_noknvmem_attach failed \n", sh->unit, __FUNCTION__));
		goto err;
	}
#endif /* WLNOKIA_NVMEM */

	if ((pi->sh->boardvendor == VENDOR_APPLE) &&
	    (pi->sh->boardtype == 0x0093)) {
		pi->phy_wreg_limit = PHY_WREG_LIMIT_VENDOR;
	}
	else {
		pi->phy_wreg_limit = PHY_WREG_LIMIT;
	}
	if (BAND_2G(bandtype) && (sflags & SISF_2G_PHY)) {
		/* Set the sflags gmode indicator */
		pi->pubpi.coreflags = SICF_GMODE;
	}

	/* get the phy type & revision */
	/* Note: corereset seems to be required to get the phyversion read correctly */
	wlapi_bmac_corereset(pi->sh->physhim, pi->pubpi.coreflags);
	phyversion = R_REG(osh, &pi->regs->phyversion);
	pi->pubpi.phy_type = PHY_TYPE(phyversion);
	pi->pubpi.phy_rev = phyversion & PV_PV_MASK;

	/* Read the fabid */
	pi->fabid = si_fabid(GENERIC_PHY_INFO(pi)->sih);

	if (((pi->sh->chip == BCM43235_CHIP_ID) ||
		(pi->sh->chip == BCM43236_CHIP_ID) ||
		(pi->sh->chip == BCM43238_CHIP_ID) ||
		(pi->sh->chip == BCM43234_CHIP_ID)) && ((pi->sh->chiprev == 2) ||
		(pi->sh->chiprev == 3))) {
		pi->pubpi.phy_rev = 9;
	}

	/* LCNXN */
	if (pi->pubpi.phy_type == PHY_TYPE_LCNXN) {
		pi->pubpi.phy_type = PHY_TYPE_N;
		pi->pubpi.phy_rev += LCNXN_BASEREV;
	}

	/* Note: For ACPHY, phy_corenum is set in the wlc_phy_attach_acphy function after reading
	 * the ACPHY_PhyCapability0 register
	 */
	pi->pubpi.phy_corenum = ISHTPHY(pi) ? PHY_CORE_NUM_3 :
		(ISNPHY(pi) ? PHY_CORE_NUM_2 : PHY_CORE_NUM_1);
	pi->pubpi.ana_rev = (phyversion & PV_AV_MASK) >> PV_AV_SHIFT;

	if (!VALID_PHYTYPE(pi)) {
		PHY_ERROR(("wl%d: %s: invalid phy_type %d\n",
		          sh->unit, __FUNCTION__, pi->pubpi.phy_type));
		goto err;
	}
	if (BAND_5G(bandtype)) {
		if (!ISAPHY(pi) && !ISNPHY(pi) && !ISLPPHY(pi) && !ISSSLPNPHY(pi) &&
			!ISLCN40PHY(pi) && !ISHTPHY(pi) && !ISLCNPHY(pi) && !ISACPHY(pi)) {
			PHY_ERROR(("wl%d: %s: invalid phy_type %d for band 5G\n",
			          sh->unit, __FUNCTION__, pi->pubpi.phy_type));
			goto err;
		}
	} else {
		if (!ISGPHY(pi) && !ISNPHY(pi) && !ISLPPHY(pi) && !ISSSLPNPHY(pi) &&
			!ISLCN20PHY(pi) &&
			!ISLCNCOMMONPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi))
		{
			PHY_ERROR(("wl%d: %s: invalid phy_type %d for band 2G\n",
			          sh->unit, __FUNCTION__, pi->pubpi.phy_type));
			goto err;
		}
	}

	if (wlc_phy_radio_attach(pi) != BCME_OK)
		goto err;

	/* default channel and channel bandwidth is 20 MHZ */
	pi->bw = WL_CHANSPEC_BW_20;
	pi->radio_chanspec = BAND_2G(bandtype) ? CH20MHZ_CHSPEC(1) : CH20MHZ_CHSPEC(36);

	if (!wlc_phy_cmn_attach(pi))
		goto err;

	/* attach nvram driven variables */
	wlc_phy_srom_attach(pi, bandtype);

	/* update standard configuration params to defaults */
	wlc_phy_std_params_attach(pi);

#if defined(AP) && defined(RADAR)
	wlc_phy_radar_params_attach(pi);
#endif // endif

	/* WARNING: each individual PHY attach and it's pi->u.pi_xphy is allocated
	 * NO member pi->u.pi-xphy->xx should be dereferenced above this point
	 */
	if (ISABGPHY(pi)) {
		if (!wlc_phy_attach_abgphy(pi, bandtype))
			goto err;
	} else if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		/* only use for NPHY for now */
		if (!(pi->phycal_timer = wlapi_init_timer(pi->sh->physhim,
			wlc_phy_timercb_phycal, pi, rstr_phycal))) {
			PHY_ERROR(("%s: wlapi_init_timer for phycal_timer failed\n", __FUNCTION__));
			goto err;
		}

		if (ISNPHY(pi)) {
			if (!wlc_phy_attach_nphy(pi))
				goto err;
		} else if (ISHTPHY(pi)) {
			if (!wlc_phy_attach_htphy(pi))
				goto err;
		} else if (ISACPHY(pi)) {
			if (!wlc_phy_attach_acphy(pi))
				goto err;
		}
	} else if (ISLPPHY(pi)) {
		if (!wlc_phy_attach_lpphy(pi))
			goto err;

	} else if (ISSSLPNPHY(pi)) {
		if (!wlc_phy_attach_sslpnphy(pi))
			goto err;

	} else if (ISLCNPHY(pi)) {
		if (!wlc_phy_attach_lcnphy(pi, bandtype))
			goto err;

	} else if (ISLCN40PHY(pi)) {
		if (!wlc_phy_attach_lcn40phy(pi))
			goto err;
	} else if (ISACPHY(pi)) {
		if (!wlc_phy_attach_acphy(pi))
			goto err;
/* FIXME: The below LCN20CONF protection is not required if
* we do it right
*/
#if (defined(LCN20CONF) && (LCN20CONF != 0))
	} else if (ISLCN20PHY(pi)) {
		if (!wlc_phy_attach_lcn20phy(pi))
			goto err;
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
	} else {
		/* This is here to complete the preceding if */
		PHY_ERROR(("%s: unknown phytype %d\n", __FUNCTION__, pi->pubpi.phy_type));
	}

	/* attach interference modes for respective PHYs */
	wlc_phy_interference_mode_attach(pi, bandtype);

	/* Parameters for temperature-based fallback to 1-Tx chain */
	wlc_phy_txcore_temp(pi);

	/* Prepare for one-time initializations */
	wlc_set_phy_uninitted(pi);

#ifndef BCM_OL_DEV
	if (!ISLCN40PHY (pi))
		wlc_phy_anacore((wlc_phy_t*)pi, ON);

	/* make sure the radio is off until we do an "up" */
	wlc_phy_switch_radio((wlc_phy_t*)pi, OFF);
#endif // endif

	for (i = 0; i < 2; i++)
		for (j = 0; j < 4; j++)
			pi->chan_set_est_time[i][j] = -1;

	/* Make a public copy of the attach time constant phy attributes */
	bcopy(&pi->pubpi, &pi->pubpi_ro, sizeof(wlc_phy_t));
#ifdef WLTXPWR_CACHE
	pi->txpwr_cache = wlc_phy_txpwr_cache_create(pi->sh->osh);
#endif // endif

	/* initialized value for non-radar detection operation */
	wlc_phy_radar_detect_on_off_cfg((wlc_phy_t *)pi, FALSE);

	/*
	 * Sometimes we have region-specific
	 * tuning, such as EU energy detect.
	 * Default is "unknown/other" for region
	 * and it'll be updated later when the
	 * operating region is known. This can subseuqently
	 * be examined and used to adjust tuning.
	 */
	pi->region_group = REGION_OTHER;

exit:
	/* Mark that they are not longer available so we can error/assert.  Use a pointer
	 * to self as a flag.
	 */
	pi->vars = (char *)&pi->vars;
	return &pi->pubpi_ro;

err:
	wlc_phy_detach((wlc_phy_t *)pi);
	return NULL;
}

void
BCMATTACHFN(wlc_phy_detach)(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	PHY_TRACE(("wl: %s: pi = %p\n", __FUNCTION__, pi));

	if (pih == NULL)
		return;

	ASSERT(pi->refcnt > 0);
	if (--pi->refcnt) {
		return;
	}

	wlc_phy_cmn_detach(pi);

	if (ISABGPHY(pi))
		wlc_phy_detach_abgphy(pi);

	if (pi->phycal_timer) {
		wlapi_free_timer(pi->sh->physhim, pi->phycal_timer);
		pi->phycal_timer = NULL;
	}
#ifdef WLNOKIA_NVMEM
	if (pi->noknvmem)
		wlc_phy_noknvmem_detach(pi->sh->osh, pi->noknvmem);
#endif /* WLNOKIA_NVMEM */
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	pi->phy_calcache_on = FALSE;
	wlc_phy_cal_cache_deinit((wlc_phy_t *)pi);
#endif // endif

	/* Quick-n-dirty remove from list */
	if (pi->sh->phy_head == pi)
		pi->sh->phy_head = pi->next;
	else if (pi->sh->phy_head->next == pi)
		pi->sh->phy_head->next = NULL;
	else
		ASSERT(0);

	if (pi->pi_fptr.detach)
		(pi->pi_fptr.detach)(pi);

#ifdef WLTXPWR_CACHE
	if (pi->tx_power_offset != NULL)
		wlc_phy_clear_tx_power_offset(pih);

#if defined(WLC_LOW_ONLY) || defined(WLTXPWR_CACHE_PHY_ONLY)
	if (pi->txpwr_cache != NULL)
		wlc_phy_txpwr_cache_close(pi->sh->osh, pi->txpwr_cache);
#endif // endif
#else
	if (pi->tx_power_offset != NULL)
		ppr_delete(pi->sh->osh, pi->tx_power_offset);
#endif	/* WLTXPWR_CACHE */

#ifdef WLTXPWR_PER_CORE
	if (pi->p_tx_user_target != NULL) {
		MFREE(pi->sh->osh, pi->p_tx_user_target, WL_TXPWR_CORE_MAX);
		pi->p_tx_user_target = NULL;
	}
	if (pi->p_openlp_tx_power_min != NULL) {
		MFREE(pi->sh->osh, pi->p_openlp_tx_power_min, WL_TXPWR_CORE_MAX);
		pi->p_openlp_tx_power_min = NULL;
	}
#endif /* WLTXPWR_PER_CORE */
	MFREE(pi->sh->osh, pi, sizeof(phy_info_t));
}

bool
BCMATTACHFN(wlc_phy_get_phyversion)(wlc_phy_t *pih, uint16 *phytype, uint16 *phyrev,
	uint16 *radioid, uint16 *radiover)
{
	phy_info_t *pi = (phy_info_t *)pih;
	*phytype = (uint16)pi->pubpi.phy_type;
	*phyrev = (uint16)pi->pubpi.phy_rev;
	*radioid = RADIOID(pi->pubpi.radioid);
	*radiover = pi->pubpi.radiorev_orig;

	return TRUE;
}

bool
BCMATTACHFN(wlc_phy_get_encore)(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	return pi->pubpi.abgphy_encore;
}

uint32
BCMATTACHFN(wlc_phy_get_coreflags)(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	return pi->pubpi.coreflags;
}

/* Break a lengthy algorithm into smaller pieces using 0-length timer */
static void
wlc_phy_timercb_phycal(void *arg)
{
	phy_info_t *pi = (phy_info_t*)arg;
	phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
	uint delay_val = pi->phy_cal_delay;
	bool edcrs = FALSE;
#if defined(WLMCHAN)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif

	/* Increase delay between phases to be longer than 2 video frames interval 16.7*2 */
#if !defined(PHYCAL_SPLIT_4324x) && !defined(WFD_PHY_LL)
	if (CHIPID(pi->sh->chip) == BCM43237_CHIP_ID)
#endif // endif
		delay_val = 40;

	if (PHY_PERICAL_MPHASE_PENDING(pi)) {

		PHY_CAL(("wlc_phy_timercb_phycal: phase_id %d\n", pi->cal_info->cal_phase_id));

		/* XXX phy_init can be called after "wl out"(due to bandwidth switch.
		 * but scheduling calibration seems inappropriate. test cals after "wl out"
		 * can invoke the wlc_phy_cal_perical_nphy_run() directly if desired.
		 */
		if (!pi->sh->up) {
			wlc_phy_cal_perical_mphase_reset(pi);
			return;
		}

		if (ISNPHY(pi))
			edcrs = wlc_phy_eu_edcrs_status_nphy(pi);

		if (SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || PHY_MUTED(pi)) {
			/* delay percal until scan completed */
			PHY_CAL(("wlc_phy_timercb_phycal: scan in progress, delay 1 sec\n"));
			delay_val = 1000;	/* delay 1 sec */
			/* PHYCAL_CACHING does not interact with mphase */
#if defined(WLMCHAN)
			if (!ctx)
#endif // endif
				wlc_phy_cal_perical_mphase_restart(pi);
		} else if (edcrs) {
			PHY_CAL(("wlc_phy_timercb_phycal: ed high, delay 1 sec\n"));
			delay_val = 1000;	/* delay 1 sec */
		} else {
			if (ISNPHY(pi)) {
				wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_AUTO);
			} else if (ISHTPHY(pi)) {
				/* pick up the search type from what the scheduler requested
				 * (INITIAL or INCREMENTAL) and call the calibration
				 */
				wlc_phy_cals_htphy(pi, pi->cal_info->cal_searchmode);
			} else if (ISACPHY(pi)) {
				wlc_phy_cals_acphy(pi, pi->cal_info->cal_searchmode);
			} else {
				ASSERT(0); /* other phys not expected here */
			}
		}

		if (ISNPHY(pi)) {
			if (!(pi_nphy->ntd_papdcal_dcs == TRUE &&
				pi->cal_info->cal_phase_id == MPHASE_CAL_STATE_RXCAL))
				wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay_val, 0);
			else {
				pi_nphy->ntd_papdcal_dcs = FALSE;
				wlc_phy_cal_perical_mphase_reset(pi);
			}
		} else {
			if (!pi->cal_info->cal_phase_id == MPHASE_CAL_STATE_IDLE) {
				wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay_val, 0);
			} else {
				wlc_phy_cal_perical_mphase_reset(pi);
			}
		}
		return;
	}

	PHY_CAL(("wlc_phy_timercb_phycal: mphase phycal is done\n"));
}

void
wlc_phy_anacore(wlc_phy_t *pih, bool on)
{
	phy_info_t *pi = (phy_info_t*)pih;

	ASSERT(pi != NULL);

	PHY_TRACE(("wl%d: %s %i\n", pi->sh->unit, __FUNCTION__, on));

	/* Below code causes driver hang randomly for 4324 */
	/* Enable after root causing */
	if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
		return;
	if (ISNPHY(pi)) {
		if (on) {
			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
				if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
					PHY_REG_LIST_START
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore1,     0x0d)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride1, 0x0)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore2,     0x0d)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride2, 0x0)
					PHY_REG_LIST_EXECUTE(pi);
					wlc_phy_nphy_afectrl_override(pi, NPHY_ADC_PD, 0, 0, 0x3);
					PHY_REG_LIST_START
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlOverride1,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlOverride2,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlCore1,
							NPHY_REV19_AfectrlCore_adc_pd_MASK,
							0)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlCore2,
							NPHY_REV19_AfectrlCore_adc_pd_MASK,
							0)
					PHY_REG_LIST_EXECUTE(pi);
					/* dac pd */
					wlc_phy_nphy_afectrl_override(pi, NPHY_DAC_PD, 0, 0, 0x3);
					/* aux_en */
				        wlc_phy_rfctrl_override_nphy_rev19(pi,
				                NPHY_REV19_RfctrlOverride_aux_en_MASK,
				                0, 0, 1, NPHY_REV19_RFCTRLOVERRIDE_ID4);

				} else {
					PHY_REG_LIST_START
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore1,     0x0d)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride1, 0x0)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore2,     0x0d)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride2, 0x0)
					PHY_REG_LIST_EXECUTE(pi);
				}
			} else {
				phy_reg_write(pi, NPHY_AfectrlOverride, 0x0);
			}
		} else {
			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
				if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
					PHY_REG_LIST_START
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride1, 0x07ff)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore1,     0x0fd)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride2, 0x07ff)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore2,     0x0fd)
					PHY_REG_LIST_EXECUTE(pi);
					wlc_phy_nphy_afectrl_override(pi, NPHY_ADC_PD, 1, 0, 0x3);
					PHY_REG_LIST_START
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlOverride1,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlOverride2,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK,
							NPHY_REV3_AfectrlOverride_adc_pd_MASK)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlCore1,
							NPHY_REV19_AfectrlCore_adc_pd_MASK,
							NPHY_REV19_AfectrlCore_adc_pd_MASK)
						PHY_REG_MOD_RAW_ENTRY(NPHY_AfectrlCore2,
							NPHY_REV19_AfectrlCore_adc_pd_MASK,
							NPHY_REV19_AfectrlCore_adc_pd_MASK)
					PHY_REG_LIST_EXECUTE(pi);
					wlc_phy_nphy_afectrl_override(pi, NPHY_DAC_PD, 1, 0, 0x3);
					/* aux_en */
				        wlc_phy_rfctrl_override_nphy_rev19(pi,
				                NPHY_REV19_RfctrlOverride_aux_en_MASK,
				                0, 0, 0, NPHY_REV19_RFCTRLOVERRIDE_ID4);
				} else {

					PHY_REG_LIST_START
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride1, 0x07ff)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore1,     0x0fd)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlOverride2, 0x07ff)
						PHY_REG_WRITE_ENTRY(NPHY, AfectrlCore2,     0x0fd)
					PHY_REG_LIST_EXECUTE(pi);
				}

			} else {
				phy_reg_write(pi, NPHY_AfectrlOverride, 0x7fff);
			}
		}
	} else if (ISHTPHY(pi)) {
		wlc_phy_anacore_htphy(pi, on);
	} else if (ISLPPHY(pi)) {
		if (on)
			phy_reg_and(pi, LPPHY_AfeCtrlOvr,
				~(LPPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
				LPPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
				LPPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK));
		else {
			PHY_REG_LIST_START
				PHY_REG_OR_ENTRY(LPPHY, AfeCtrlOvrVal,
					LPPHY_AfeCtrlOvrVal_pwdn_adc_ovr_val_MASK |
					LPPHY_AfeCtrlOvrVal_pwdn_dac_ovr_val_MASK |
					LPPHY_AfeCtrlOvrVal_pwdn_rssi_ovr_val_MASK)
				PHY_REG_OR_ENTRY(LPPHY, AfeCtrlOvr,
					LPPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
					LPPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
					LPPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);
		}
	} else if (ISSSLPNPHY(pi))  {
		if (on) {
			PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(SSLPNPHY, AfeCtrlOvrVal,
					~(SSLPNPHY_AfeCtrlOvrVal_pwdn_adc_ovr_val_MASK |
					SSLPNPHY_AfeCtrlOvrVal_pwdn_dac_ovr_val_MASK |
					SSLPNPHY_AfeCtrlOvrVal_pwdn_rssi_ovr_val_MASK))
				PHY_REG_AND_ENTRY(SSLPNPHY, AfeCtrlOvr,
					~(SSLPNPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
					SSLPNPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
					SSLPNPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK))
			PHY_REG_LIST_EXECUTE(pi);
		} else  {
			PHY_REG_LIST_START
				PHY_REG_OR_ENTRY(SSLPNPHY, AfeCtrlOvrVal,
					SSLPNPHY_AfeCtrlOvrVal_pwdn_adc_ovr_val_MASK |
					SSLPNPHY_AfeCtrlOvrVal_pwdn_dac_ovr_val_MASK |
					SSLPNPHY_AfeCtrlOvrVal_pwdn_rssi_ovr_val_MASK)
				PHY_REG_OR_ENTRY(SSLPNPHY, AfeCtrlOvr,
					SSLPNPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
					SSLPNPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
					SSLPNPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);
		}
	} else if (ISLCNPHY(pi)) {
		if (on) {
			phy_reg_and(pi, LCNPHY_AfeCtrlOvr,
				~(LCNPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
				LCNPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
				LCNPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK));
		} else  {
			PHY_REG_LIST_START
				PHY_REG_OR_ENTRY(LCNPHY, AfeCtrlOvrVal,
					LCNPHY_AfeCtrlOvrVal_pwdn_adc_ovr_val_MASK |
					LCNPHY_AfeCtrlOvrVal_pwdn_dac_ovr_val_MASK |
					LCNPHY_AfeCtrlOvrVal_pwdn_rssi_ovr_val_MASK)
				PHY_REG_OR_ENTRY(LCNPHY, AfeCtrlOvr,
					LCNPHY_AfeCtrlOvr_pwdn_adc_ovr_MASK |
					LCNPHY_AfeCtrlOvr_pwdn_dac_ovr_MASK |
					LCNPHY_AfeCtrlOvr_pwdn_rssi_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);
		}
	} else if (pi->pi_fptr.anacore) {
		pi->pi_fptr.anacore(pi, on);
	} else {
		if (on)
			W_REG(pi->sh->osh, &pi->regs->phyanacore, 0x0);
		else
			W_REG(pi->sh->osh, &pi->regs->phyanacore, 0xF4);
	}
}

static const char BCMATTACHDATA(rstr_tempthresh)[] = "tempthresh";
static const char BCMATTACHDATA(rstr_temps_hysteresis)[] = "temps_hysteresis";

void
BCMATTACHFN(wlc_phy_txcore_temp)(phy_info_t *pi)
{
	/* XXX Temperature (in degrees centigrade) at which one Tx chain is disabled
	 * to prevent further heating
	 *
	 * PR 83721 FIXME: add 25C offset to tempthresh once chips are qualed at 150C
	 *                 if BFL2_TEMPSENSE_HIGHER is high
	 */
	uint8 init_txrxchain = (1 << PHYCORENUM(pi->pubpi.phy_corenum)) - 1;

	pi->txcore_temp.disable_temp = (uint8)PHY_GETINTVAR(pi, rstr_tempthresh);
	if ((pi->txcore_temp.disable_temp == 0) || (pi->txcore_temp.disable_temp == 0xff)) {
		if (ISHTPHY(pi)) {
			pi->txcore_temp.disable_temp = HTPHY_CHAIN_TX_DISABLE_TEMP;
		} else if (ISACPHY(pi)) {
			pi->txcore_temp.disable_temp = ACPHY_CHAIN_TX_DISABLE_TEMP;
		} else {
			pi->txcore_temp.disable_temp = PHY_CHAIN_TX_DISABLE_TEMP;
		}
	}

#if defined(BCM94360X51) && defined(BCM94360X52C)
	if (ISACPHY(pi) &&
	    (CHIPID(pi->sh->chip) == BCM4360_CHIP_ID) &&
	    ((pi->sh->boardtype == BCM94360X51) ||
	     (pi->sh->boardtype == BCM94360X51P3) ||
	     (pi->sh->boardtype == BCM94360X52C))) {
		pi->txcore_temp.disable_temp = 120;
	}
#endif /* BCM94360X51 && BCM94360X52C */

	pi->txcore_temp.disable_temp_max_cap = pi->txcore_temp.disable_temp;

	pi->txcore_temp.hysteresis = (uint8)PHY_GETINTVAR(pi, rstr_temps_hysteresis);
	if ((pi->txcore_temp.hysteresis == 0) || (pi->txcore_temp.hysteresis == 0xf)) {
		pi->txcore_temp.hysteresis = PHY_HYSTERESIS_DELTATEMP;
	}

	pi->txcore_temp.enable_temp =
		pi->txcore_temp.disable_temp - pi->txcore_temp.hysteresis;

	pi->txcore_temp.heatedup = FALSE;
	pi->txcore_temp.degrade1RXen = FALSE;

	pi->txcore_temp.bitmap = (init_txrxchain << 4 | init_txrxchain);
	return;

}

void
WLBANDINITFN(wlc_phy_por_inform)(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	pi->phy_init_por = TRUE;
}

void
wlc_phy_btclock_war(wlc_phy_t *ppi, bool enable)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	pi->btclock_tune = enable;
}

void
wlc_phy_preamble_override_set(wlc_phy_t *ppi, int8 val)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if ((ISACPHY(pi)) && (val != WLC_N_PREAMBLE_MIXEDMODE)) {
		PHY_ERROR(("wl%d:%s: AC Phy: Ignore request to set preamble mode %d\n",
			pi->sh->unit, __FUNCTION__, val));
		return;
	}

	pi->n_preamble_override = val;
}

int8
wlc_phy_preamble_override_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return pi->n_preamble_override;
}

/* increase the threshold to avoid false edcrs detection, non-11n only */
void
wlc_phy_edcrs_lock(wlc_phy_t *pih, bool lock)
{
	phy_info_t *pi = (phy_info_t *)pih;
	pi->edcrs_threshold_lock = lock;

	/* assertion: -59dB, deassertion: -67dB */
	PHY_REG_LIST_START
		PHY_REG_WRITE_ENTRY(NPHY, ed_crs20UAssertThresh0, 0x46b)
		PHY_REG_WRITE_ENTRY(NPHY, ed_crs20UAssertThresh1, 0x46b)
		PHY_REG_WRITE_ENTRY(NPHY, ed_crs20UDeassertThresh0, 0x3c0)
		PHY_REG_WRITE_ENTRY(NPHY, ed_crs20UDeassertThresh1, 0x3c0)
	PHY_REG_LIST_EXECUTE(pi);
}

void
wlc_phy_initcal_enable(wlc_phy_t *pih, bool initcal)
{
	phy_info_t *pi = (phy_info_t *)pih;
	if (ISNPHY(pi))
		pi->u.pi_nphy->do_initcal = initcal;
}

void
wlc_phy_hw_clk_state_upd(wlc_phy_t *pih, bool newstate)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (!pi || !pi->sh)
		return;

	pi->sh->clk = newstate;
}

void
wlc_phy_hw_state_upd(wlc_phy_t *pih, bool newstate)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (!pi || !pi->sh)
		return;

	pi->sh->up = newstate;
}

#ifdef WFD_PHY_LL
void
wlc_phy_wfdll_chan_active(wlc_phy_t * ppi, bool chan_active)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISNPHY(pi) || ISACPHY(pi))
		pi->wfd_ll_chan_active = chan_active;
}
#endif /* WFD_PHY_LL */

void
WLBANDINITFN(wlc_phy_init)(wlc_phy_t *pih, chanspec_t chanspec)
{
	uint32	mc;
	initfn_t phy_init = NULL;
	phy_info_t *pi = (phy_info_t *)pih;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
#ifdef BCMDBG
	char chbuf[CHANSPEC_STR_LEN];
#endif // endif
#if defined(PHYCAL_CACHING)
	ch_calcache_t *ctx;
#endif // endif
	ASSERT(pi != NULL);
#ifdef BCMDBG
	PHY_TRACE(("wl%d: %s chanspec %s\n", pi->sh->unit, __FUNCTION__,
		wf_chspec_ntoa(chanspec, chbuf)));
#endif // endif

#if defined(PHYCAL_CACHING)
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif

	/* skip if this function is called recursively(e.g. when bw is changed) */
	if (pi->init_in_progress)
		return;

	pi->init_in_progress = TRUE;
	wlc_phy_chanspec_radio_set(pih, chanspec);
	pi->phynoise_state = 0;
	/* Update ucode channel value */
	wlc_phy_chanspec_shm_set(pi, chanspec);

	mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
	if ((mc & MCTL_EN_MAC) != 0) {
		if (mc == 0xffffffff)
			PHY_ERROR(("wl%d: %s: chip is dead !!!\n", pi->sh->unit, __FUNCTION__));
		else
			PHY_ERROR(("wl%d: %s: MAC running! mc=0x%x\n",
			          pi->sh->unit, __FUNCTION__, mc));
		ASSERT((const char*)"wlc_phy_init: Called with the MAC running!" == NULL);
	}

	/* clear during init. To be set by higher level wlc code */
	pi->cur_interference_mode = INTERFERE_NONE;

	/* init PUB_NOT_ASSOC */
	if (!(pi->measure_hold & PHY_HOLD_FOR_SCAN) &&
		!(pi->interf.aci.nphy.detection_in_progress)) {
#ifdef WLSRVSDB
		if (!pi->srvsdb_state.srvsdb_active)
			pi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;
#else
		pi->measure_hold |= PHY_HOLD_FOR_NOT_ASSOC;
#endif // endif
	}

	/* check D11 is running on Fast Clock */
	if (D11REV_GE(pi->sh->corerev, 5))
		ASSERT(si_core_sflags(pi->sh->sih, 0, 0) & SISF_FCLKA);

	phy_init = pi->pi_fptr.init;

	if (phy_init == NULL) {
		PHY_ERROR(("wl%d: %s: No phy_init found for phy_type %d, rev %d\n",
		          pi->sh->unit, __FUNCTION__, pi->pubpi.phy_type, pi->pubpi.phy_rev));
		ASSERT(phy_init != NULL);
		return;
	}

	wlc_phy_anacore(pih, ON);

	/* sanitize bw here to avoid later mess. wlc_set_bw will invoke phy_reset,
	 *  but phy_init recursion is avoided by using init_in_progress
	 */
	if (CHSPEC_BW(pi->radio_chanspec) != pi->bw)
		wlapi_bmac_bw_set(pi->sh->physhim, CHSPEC_BW(pi->radio_chanspec));

	/* Reset gain_boost & aci on band-change */
	pi->nphy_gain_boost = TRUE;
#ifndef WLC_DISABLE_ACI
	if (ISNPHY(pi) || ISHTPHY(pi)) {
		if (ISNPHY(pi) && NREV_LT(pi->pubpi.phy_rev, 3)) {
			/* when scanning to different band, don't change aci_state */
			/* but keep phy rev < 3 the same as before */
			pi->aci_state &= ~ACI_ACTIVE;
		}
		/* Reset ACI internals if not scanning and not in aci_detection */
		if (!(SCAN_INPROG_PHY(pi) ||
			pi->interf.aci.nphy.detection_in_progress)) {
			if (ISNPHY(pi))
				wlc_phy_aci_sw_reset_nphy(pi);
			else if (ISHTPHY(pi))
				wlc_phy_aci_sw_reset_htphy(pi);
		}
	}
#endif /* Compiling out ACI code for 4324 */
	/* radio on */
	if (ISACPHY(pi)) {
	  pi_ac->init_done = FALSE; /* To make sure that chanspec_set_acphy */

	  /* sync up soft_radio_state with hard_radio_state */
	  pi->radio_is_on = FALSE;
	}
	wlc_phy_switch_radio((wlc_phy_t*)pi, ON);

#ifndef WLC_DISABLE_ACI
	/* initialize interference algorithms */
	if (((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi) || ISACPHY(pi)) &&
		(SCAN_INPROG_PHY(pi))) {
		/* do not reinitialize interference mode, could be scanning */
	} else {
		if (pi->sh->interference_mode_override == TRUE) {
			/* keep the same values */
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				pi->sh->interference_mode =
					pi->sh->interference_mode_2G_override;
			} else {
				/* for 5G, only values 0 and 1 are valid options */
				if (pi->sh->interference_mode_5G_override == 0 ||
					pi->sh->interference_mode_5G_override == 1) {
					pi->sh->interference_mode =
						pi->sh->interference_mode_5G_override;
				} else {
					/* used invalid value. so default to 0 */
					pi->sh->interference_mode = 0;
				}
			}
		} else {
		        if (CHSPEC_IS2G(pi->radio_chanspec)) {
			        pi->sh->interference_mode = pi->sh->interference_mode_2G;
		        } else {
			        pi->sh->interference_mode = pi->sh->interference_mode_5G;
		        }
		}
		wlc_phy_interference(pi, pi->sh->interference_mode, FALSE);
	}
#endif /* Compiling out ACI code for 4324 */

	/* !! kick off the phy init !! */
	(*phy_init)(pi);

	/* Indicate a power on reset isn't needed for future phy init's */
	pi->phy_init_por = FALSE;

	/* WAR for PR37973/37974: PHY RESETS can cause the first byte of a subsequent Tx frame
	 * to be bogus, causing txphy errors - So send a dummy frame as the first frame after reset
	 */
	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
		wlc_phy_do_dummy_tx(pi, TRUE, OFF);

	/* Save the w/b frequency tracking registers */
	if (ISGPHY(pi)) {
		pi->freqtrack_saved_regs[0] = phy_reg_read(pi, BPHY_COEFFS);
		pi->freqtrack_saved_regs[1] = phy_reg_read(pi, BPHY_STEP);
	}

	/* init txpwr shared memory if sw or ucode are doing tx power control */
	if (ISABGPHY(pi))
		wlc_phy_txpower_update_shm(pi);

	/* initialize rx antenna diversity */
	wlc_phy_ant_rxdiv_set((wlc_phy_t *)pi, pi->sh->rx_antdiv);

	pi->init_in_progress = FALSE;

	pi->bt_shm_addr = 2 * wlapi_bmac_read_shm(pi->sh->physhim, M_BTCX_BLK_PTR);

	if (ISLCN40PHY(pi) && (pi->u.pi_lcnphy->txpwrindex5g_nvram ||
		pi->u.pi_lcnphy->txpwrindex_nvram)) {
		uint8 txpwrindex;
#ifdef BAND5G
		if (CHSPEC_IS5G(pi->radio_chanspec))
			txpwrindex = pi->u.pi_lcnphy->txpwrindex5g_nvram;
		else
#endif /* BAND5G */
			txpwrindex = pi->u.pi_lcnphy->txpwrindex_nvram;

		if (ISLCNCOMMONPHY(pi) && txpwrindex)
#if defined(PHYCAL_CACHING)
			wlc_iovar_txpwrindex_set_lcncommon(pi, txpwrindex, ctx);
#else
			wlc_iovar_txpwrindex_set_lcncommon(pi, txpwrindex);
#endif /* defined(PHYCAL_CACHING) */
	}
	if (pi->region_group ==  REGION_EU) {
	        pi->phy_cal_delay = PHY_PERICAL_DELAY_EU;
	}
}

/*
 * Do one-time phy initializations and calibration.
 *
 * Note: no register accesses allowed; we have not yet waited for PLL
 * since the last corereset.
 */
void
BCMINITFN(wlc_phy_cal_init)(wlc_phy_t *pih)
{
	int i;
	phy_info_t *pi = (phy_info_t *)pih;
	initfn_t cal_init = NULL;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

#ifndef BCM_OL_DEV
	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);
#endif /* BCM_OL_DEV */

	if (ISAPHY(pi))
		pi->txpwridx = DEFAULT_11A_TXP_IDX;

	if (!pi->initialized) {
		/* glitch counter init */
		/* detection is called only if high glitches are observed */
		pi->interf.aci.glitch_ma = ACI_INIT_MA;
		pi->interf.aci.glitch_ma_previous = ACI_INIT_MA;
		pi->interf.aci.pre_glitch_cnt = 0;
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
		     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
			pi->interf.aci.ma_total = PHY_NOISE_MA_WINDOW_SZ * ACI_INIT_MA;
		} else {
			pi->interf.aci.ma_total = MA_WINDOW_SZ * ACI_INIT_MA;
		}
		for (i = 0; i < MA_WINDOW_SZ; i++)
			pi->interf.aci.ma_list[i] = ACI_INIT_MA;

		for (i = 0; i < PHY_NOISE_MA_WINDOW_SZ; i++) {
			pi->interf.noise.ofdm_glitch_ma_list[i] = PHY_NOISE_GLITCH_INIT_MA;
			pi->interf.noise.ofdm_badplcp_ma_list[i] = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
			pi->interf.noise.bphy_glitch_ma_list[i] = PHY_NOISE_GLITCH_INIT_MA;
			pi->interf.noise.bphy_badplcp_ma_list[i] = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		}

		pi->interf.noise.ofdm_glitch_ma = PHY_NOISE_GLITCH_INIT_MA;
		pi->interf.noise.bphy_glitch_ma = PHY_NOISE_GLITCH_INIT_MA;
		pi->interf.noise.ofdm_glitch_ma_previous = PHY_NOISE_GLITCH_INIT_MA;
		pi->interf.noise.bphy_glitch_ma_previous = PHY_NOISE_GLITCH_INIT_MA;
		pi->interf.noise.bphy_pre_glitch_cnt = 0;
		pi->interf.noise.ofdm_ma_total = PHY_NOISE_GLITCH_INIT_MA * PHY_NOISE_MA_WINDOW_SZ;
		pi->interf.noise.bphy_ma_total = PHY_NOISE_GLITCH_INIT_MA * PHY_NOISE_MA_WINDOW_SZ;

		pi->interf.badplcp_ma = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		pi->interf.badplcp_ma_previous = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
		     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
			pi->interf.badplcp_ma_total = PHY_NOISE_GLITCH_INIT_MA_BADPlCP *
			        PHY_NOISE_MA_WINDOW_SZ;
		} else {
			pi->interf.badplcp_ma_total = PHY_NOISE_GLITCH_INIT_MA_BADPlCP *
			        MA_WINDOW_SZ;
		}
		pi->interf.pre_badplcp_cnt = 0;
		pi->interf.bphy_pre_badplcp_cnt = 0;

		pi->interf.noise.ofdm_badplcp_ma = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		pi->interf.noise.bphy_badplcp_ma = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;

		pi->interf.noise.ofdm_badplcp_ma_previous = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		pi->interf.noise.bphy_badplcp_ma_previous = PHY_NOISE_GLITCH_INIT_MA_BADPlCP;
		pi->interf.noise.ofdm_badplcp_ma_total =
			PHY_NOISE_GLITCH_INIT_MA_BADPlCP * PHY_NOISE_MA_WINDOW_SZ;
		pi->interf.noise.bphy_badplcp_ma_total =
			PHY_NOISE_GLITCH_INIT_MA_BADPlCP * PHY_NOISE_MA_WINDOW_SZ;

		pi->interf.noise.ofdm_badplcp_ma_index = 0;
		pi->interf.noise.bphy_badplcp_ma_index = 0;

		pi->interf.cca_stats_func_called = FALSE;
		pi->interf.cca_stats_total_glitch = 0;
		pi->interf.cca_stats_bphy_glitch = 0;
		pi->interf.cca_stats_total_badplcp = 0;
		pi->interf.cca_stats_bphy_badplcp = 0;
		pi->interf.cca_stats_mbsstime = 0;

		cal_init = pi->pi_fptr.calinit;
		if (cal_init)
			(*cal_init)(pi);

		/* XXX: It would be cleaner to actually call the
		 * initializations here rather than as side-effects
		 * of the phy_init's, but each one needs to be
		 * reviewed for requirements.
		 */
		pi->initialized = TRUE;
	}
}

#ifndef BCMNODOWN
#endif	/* BCMNODOWN */

int
BCMUNINITFN(wlc_phy_down)(wlc_phy_t *pih)
{
#ifndef BCMNODOWN
	phy_info_t *pi = (phy_info_t *)pih;
	int callbacks = 0;

	/* all activate phytest should have been stopped */
	ASSERT(pi->phytest_on == FALSE);

	/* cancel phycal timer if exists */
	if (pi->phycal_timer && !wlapi_del_timer(pi->sh->physhim, pi->phycal_timer))
		callbacks++;

	if (ISNPHY(pi)) {
		pi->u.pi_nphy->nphy_iqcal_chanspec_2G = 0;
		pi->u.pi_nphy->nphy_iqcal_chanspec_5G = 0;
	}

	return callbacks;
#else
	return 0;
#endif /* BCMNODOWN */
}

static uint32
wlc_phy_get_radio_ver(phy_info_t *pi)
{
	uint32 ver;

	ver = read_radio_id(pi);

	PHY_INFORM(("wl%d: %s: IDCODE = 0x%x\n", pi->sh->unit, __FUNCTION__, ver));
	return ver;
}

#ifndef WLC_DISABLE_ACI
#if defined(WLTEST) || defined(WL_PHYACIARGS)
static int
wlc_phy_aci_args(phy_info_t *pi, wl_aci_args_t *params, bool get, int len)
{
	bool nphy_aciarg;

	if (len == WL_ACI_ARGS_LEGACY_LENGTH)
		nphy_aciarg = FALSE;
	else if (len == sizeof(wl_aci_args_t))
		nphy_aciarg = TRUE;
	else
		return BCME_BUFTOOSHORT;

	if (get) {
		params->enter_aci_thresh = pi->interf.aci.enter_thresh;
		params->exit_aci_thresh = pi->interf.aci.exit_thresh;
		params->usec_spin = pi->interf.aci.usec_spintime;
		params->glitch_delay = pi->interf.aci.glitch_delay;
	} else {
		if (params->enter_aci_thresh > 0)
			pi->interf.aci.enter_thresh = params->enter_aci_thresh;
		if (params->exit_aci_thresh > 0)
			pi->interf.aci.exit_thresh = params->exit_aci_thresh;
		if (params->usec_spin > 0)
			pi->interf.aci.usec_spintime = params->usec_spin;
		if (params->glitch_delay > 0)
			pi->interf.aci.glitch_delay = params->glitch_delay;
	}

	if (nphy_aciarg) {
		if (get) {
			params->nphy_adcpwr_enter_thresh = pi->interf.aci.nphy.adcpwr_enter_thresh;
			params->nphy_adcpwr_exit_thresh = pi->interf.aci.nphy.adcpwr_exit_thresh;
			params->nphy_repeat_ctr = pi->interf.aci.nphy.detect_repeat_ctr;
			params->nphy_num_samples = pi->interf.aci.nphy.detect_num_samples;
			params->nphy_undetect_window_sz = pi->interf.aci.nphy.undetect_window_sz;
			params->nphy_b_energy_lo_aci = pi->interf.aci.nphy.b_energy_lo_aci;
			params->nphy_b_energy_md_aci = pi->interf.aci.nphy.b_energy_md_aci;
			params->nphy_b_energy_hi_aci = pi->interf.aci.nphy.b_energy_hi_aci;

			params->nphy_noise_noassoc_glitch_th_up =
				pi->interf.noise.nphy_noise_noassoc_glitch_th_up;
			params->nphy_noise_noassoc_glitch_th_dn =
				pi->interf.noise.nphy_noise_noassoc_glitch_th_dn;
			params->nphy_noise_assoc_glitch_th_up =
				pi->interf.noise.nphy_noise_assoc_glitch_th_up;
			params->nphy_noise_assoc_glitch_th_dn =
				pi->interf.noise.nphy_noise_assoc_glitch_th_dn;
			params->nphy_noise_assoc_aci_glitch_th_up =
				pi->interf.noise.nphy_noise_assoc_aci_glitch_th_up;
			params->nphy_noise_assoc_aci_glitch_th_dn =
				pi->interf.noise.nphy_noise_assoc_aci_glitch_th_dn;
			params->nphy_noise_assoc_enter_th =
				pi->interf.noise.nphy_noise_assoc_enter_th;
			params->nphy_noise_noassoc_enter_th =
				pi->interf.noise.nphy_noise_noassoc_enter_th;
			params->nphy_noise_assoc_rx_glitch_badplcp_enter_th=
				pi->interf.noise.nphy_noise_assoc_rx_glitch_badplcp_enter_th;
			params->nphy_noise_noassoc_crsidx_incr=
				pi->interf.noise.nphy_noise_noassoc_crsidx_incr;
			params->nphy_noise_assoc_crsidx_incr=
				pi->interf.noise.nphy_noise_assoc_crsidx_incr;
			params->nphy_noise_crsidx_decr=
				pi->interf.noise.nphy_noise_crsidx_decr;

		} else {
			pi->interf.aci.nphy.adcpwr_enter_thresh = params->nphy_adcpwr_enter_thresh;
			pi->interf.aci.nphy.adcpwr_exit_thresh = params->nphy_adcpwr_exit_thresh;
			pi->interf.aci.nphy.detect_repeat_ctr = params->nphy_repeat_ctr;
			pi->interf.aci.nphy.detect_num_samples = params->nphy_num_samples;
			pi->interf.aci.nphy.undetect_window_sz =
				MIN(params->nphy_undetect_window_sz,
				ACI_MAX_UNDETECT_WINDOW_SZ);
			pi->interf.aci.nphy.b_energy_lo_aci = params->nphy_b_energy_lo_aci;
			pi->interf.aci.nphy.b_energy_md_aci = params->nphy_b_energy_md_aci;
			pi->interf.aci.nphy.b_energy_hi_aci = params->nphy_b_energy_hi_aci;

			pi->interf.noise.nphy_noise_noassoc_glitch_th_up =
				params->nphy_noise_noassoc_glitch_th_up;
			pi->interf.noise.nphy_noise_noassoc_glitch_th_dn =
				params->nphy_noise_noassoc_glitch_th_dn;
			pi->interf.noise.nphy_noise_assoc_glitch_th_up =
				params->nphy_noise_assoc_glitch_th_up;
			pi->interf.noise.nphy_noise_assoc_glitch_th_dn =
				params->nphy_noise_assoc_glitch_th_dn;
			pi->interf.noise.nphy_noise_assoc_aci_glitch_th_up =
				params->nphy_noise_assoc_aci_glitch_th_up;
			pi->interf.noise.nphy_noise_assoc_aci_glitch_th_dn =
				params->nphy_noise_assoc_aci_glitch_th_dn;
			pi->interf.noise.nphy_noise_assoc_enter_th =
				params->nphy_noise_assoc_enter_th;
			pi->interf.noise.nphy_noise_noassoc_enter_th =
				params->nphy_noise_noassoc_enter_th;
			pi->interf.noise.nphy_noise_assoc_rx_glitch_badplcp_enter_th =
				params->nphy_noise_assoc_rx_glitch_badplcp_enter_th;
			pi->interf.noise.nphy_noise_noassoc_crsidx_incr =
				params->nphy_noise_noassoc_crsidx_incr;
			pi->interf.noise.nphy_noise_assoc_crsidx_incr =
				params->nphy_noise_assoc_crsidx_incr;
			pi->interf.noise.nphy_noise_crsidx_decr =
				params->nphy_noise_crsidx_decr;
		}
	}

	return BCME_OK;
}
#endif // endif
#endif /* Compiling out ACI code for 4324 */

#if defined(DBG_PHY_IOV) || defined(BCMDBG_PHYDUMP)

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP)
typedef struct _phy_regs {
	uint16	base;
	uint16	num;
} phy_regs_t;

#ifdef WLC_LOW_ONLY
#define BUF_LIMIT 1024
#define BUF_CHARS_LINE_PHY 20
#define BUF_MAX_LINE 50  /* (BUF_LIMIT/BUF_CHARS_LINE_PHY)approax */
static void
dump_phyregs(phy_info_t *pi, const char *str, phy_regs_t *reglist, uint16 off, struct bcmstrbuf *b
, int *offset)
#else
static void
dump_phyregs(phy_info_t *pi, const char *str, phy_regs_t *reglist, uint16 off, struct bcmstrbuf *b)
#endif // endif
{
	uint16 addr, val = 0, num;
#ifdef WLC_LOW_ONLY
	int buf_line = BUF_MAX_LINE;
#endif // endif
#if defined(WLTEST)
	uint16 i = 0;
	bool skip;
#endif // endif

	if (reglist == NULL)
		return;

#ifdef WLC_LOW_ONLY
	reglist = reglist+*offset;
#endif // endif
	while ((num = reglist->num) > 0) {
#if defined(WLTEST)
		skip = FALSE;

		for (i = 0; i < pi->nphy_phyreg_skipcnt; i++) {
			if (pi->nphy_phyreg_skipaddr[i] == reglist->base) {
				skip = TRUE;
				break;
			}
		}

		if (skip) {
			reglist++;
			continue;
		}
#endif // endif
#ifdef WLC_LOW_ONLY
		for (addr = reglist->base + off; num; addr++, num--, buf_line--) {
		if (buf_line < num)
				 break;
#else
		for (addr = reglist->base + off; num; addr++, num--) {
#endif // endif
			/* XXX PR41476 WAR: Prevent MAC from accessing PHY registers while the
			 * host is
			 */

			if (D11REV_IS(pi->sh->corerev, 11) ||
			    D11REV_IS(pi->sh->corerev, 12)) {
				wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
				(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
				OSL_DELAY(1);
			}

			/*
			 * The TableDataWide register is only valid to read once the TableID and
			 * TableOffset registers are set.
			 */
			if (ISACPHY(pi) && addr == ACPHY_TableDataWide(pi->pubpi.phy_rev)) {
				val = 0;
			} else {
				val = phy_reg_read(pi, addr);
			}

			if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
				wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);

			if (PHY_INFORM_ON() && si_taclear(pi->sh->sih, FALSE)) {
				PHY_INFORM(("%s: TA reading phy reg %s:0x%x\n",
				           __FUNCTION__, str, addr));
				bcm_bprintf(b, "%s: 0x%03x tabort\n", str, addr);
			} else
				bcm_bprintf(b, "%s: 0x%03x 0x%04x\n",
				            str, addr, val);
		}
#ifdef WLC_LOW_ONLY
		if (buf_line < num)
		break;
		(*offset)++;
#endif // endif
		reglist++;
	}
#ifdef WLC_LOW_ONLY
		if (num == 0)
		*offset = 0;
#endif // endif
}

static phy_regs_t bphy5_regs[] = {
	{ 0,	9 },		/* 0 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	6 },		/* 0x10 - 0x15 */
	{ 0x18,	5 },		/* 0x18 - 0x1c */
	{ 0x20,	0x16 },		/* 0x20 - 0x35 */
	{ 0x38,	6 },		/* 0x38 - 0x3d */
	{ 0x40,	0xe },		/* 0x40 - 0x4d */
	{ 0x50,	6 },		/* 0x50 - 0x55 */
	{ 0x58,	0xa },		/* 0x58 - 0x61 */
	{ 0x80,	0x2a0 },	/* 0x80 - 0x31f */
	{ 0,	0 }
};

static phy_regs_t bphy6_regs[] = {
	{ 0,	9 },		/* 0 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	0x26 },		/* 0x10 - 0x35 */
	{ 0x38,	2 },		/* 0x38 - 0x39 */
	{ 0x3d,	0x11 },		/* 0x3d - 0x4d */
	{ 0x50,	6 },		/* 0x50 - 0x55 */
	{ 0x58,	0xa },		/* 0x58 - 0x61 */
	{ 0x63,	1 },		/* 0x63 */
	{ 0x80,	0x2a0 },	/* 0x80 - 0x31f */
	{ 0,	0 }
};

static phy_regs_t bphy8_regs[] = {
	{ 0,    9 },            /* 0 - 8 */
	{ 0xa,	5 },		/* 0xa - 0xe */
	{ 0x10,	0x2a },		/* 0x10 - 0x39 */
	{ 0x3d,	0x19 },		/* 0x3d - 0x55 */
	{ 0x58,	0xa },		/* 0x58 - 0x61 */
	{ 0x63,	0x12 },		/* 0x63 - 0x74 */
	{ 0,	0 }
};

static phy_regs_t nphy3_bphy_regs[] = {
	{ 1,	1 },		/* 1 */
	{ 4,	5 },		/* 4 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0xe,	1 },		/* 0xe */
	{ 0x10,	4 },		/* 0x10 - 0x13 */
	{ 0x18,	2 },		/* 0x18 - 0x19 */
	{ 0x20,	22 },		/* 0x20 - 0x35 */
	{ 0x38,	2 },		/* 0x38 - 0x39 */
	{ 0x40,	14 },		/* 0x40 - 0x4d */
	{ 0x4f,	7 },		/* 0x4f - 0x55 */
	{ 0x5b,	5 },		/* 0x5b - 0x5f */
	{ 0x63,	1 },		/* 0x63 */
	{ 0x67,	12 },		/* 0x67 - 0x72 */
	{ 0x75,	1 },		/* 0x75 */
	{ 0,	0 }
};

static phy_regs_t htphy0_bphy_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 - 0x001 */
	{ 0x004,	0x005 },	/* 0x004 - 0x008 */
	{ 0x00a,	0x001 },	/* 0x00a - 0x00a */
	{ 0x010,	0x004 },	/* 0x010 - 0x013 */
	{ 0x018,	0x002 },	/* 0x018 - 0x019 */
	{ 0x020,	0x016 },	/* 0x020 - 0x035 */
	{ 0x038,	0x002 },	/* 0x038 - 0x039 */
	{ 0x03d,	0x001 },	/* 0x03d - 0x03d */
	{ 0x040,	0x00e },	/* 0x040 - 0x04d */
	{ 0x04f,	0x007 },	/* 0x04f - 0x055 */
	{ 0x05b,	0x005 },	/* 0x05b - 0x05f */
	{ 0x063,	0x001 },	/* 0x063 - 0x063 */
	{ 0x067,	0x00c },	/* 0x067 - 0x072 */
	{ 0,	0 }
};

static phy_regs_t aphy2_regs[] = {
	{ 0,	9 },		/* 0 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	5 },		/* 0x10 - 0x14 */
	{ 0x18,	0xa },		/* 0x18 - 0x21 */
	{ 0x24,	0xe },		/* 0x24 - 0x31 */
	{ 0x33,	9 },		/* 0x33 - 0x3b */
	{ 0x3d,	2 },		/* 0x3d - 0x3e */
	{ 0x41,	0xa },		/* 0x41 - 0x4a */
	{ 0x50,	0xd },		/* 0x50 - 0x5c */
	{ 0x5f,	1 },		/* 0x5f */
	{ 0x61,	3 },		/* 0x61 - 0x63 */
	{ 0x68,	4 },		/* 0x68 - 0x6b */
	{ 0x6e,	2 },		/* 0x6e - 0x6f */
	{ 0x72,	0x25 },		/* 0x72 - 0x96 */
	{ 0xa0,	0xd },		/* 0xa0 - 0xac */
	{ 0,	0 }
};

static phy_regs_t aphy3_regs[] = {
	{ 0,	6 },		/* 0 - 5 */
	{ 7,	2 },		/* 7 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	5 },		/* 0x10 - 0x14 */
	{ 0x18,	0xa },		/* 0x18 - 0x21 */
	{ 0x24,	2 },		/* 0x24 - 0x25 */
	{ 0x27,	0x15 },		/* 0x27 - 0x3b */
	{ 0x3e,	1 },		/* 0x3e */
	{ 0x41,	0xa },		/* 0x41 - 0x4a */
	{ 0x50,	6 },		/* 0x50 - 0x55 */
	{ 0x58,	6 },		/* 0x58 - 0x5d */
	{ 0x5f,	5 },		/* 0x5f - 0x63 */
	{ 0x68,	4 },		/* 0x68 - 0x6b */
	{ 0x6e,	7 },		/* 0x6e - 0x74 */
	{ 0x7a,	0x1d },		/* 0x7a - 0x96 */
	{ 0xa0,	0xf },		/* 0xa0 - 0xae */
	{ 0xb0,	0xc },		/* 0xb0 - 0xbb */
	{ 0xc0,	9 },		/* 0xc0 - 0xc8 */
	{ 0,	0 }
};

static phy_regs_t aphy4_regs[] = {
	{ 0,	6 },		/* 0 - 5 */
	{ 7,	2 },		/* 7 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	0x13 },		/* 0x10 - 0x22 */
	{ 0x24,	0x18 },		/* 0x24 - 0x3b */
	{ 0x3e,	1 },		/* 0x3e */
	{ 0x41,	0xe },		/* 0x41 - 0x4e */
	{ 0x50,	6 },		/* 0x50 - 0x55 */
	{ 0x58,	6 },		/* 0x58 - 0x5d */
	{ 0x5f,	5 },		/* 0x5f - 0x63 */
	{ 0x68,	4 },		/* 0x68 - 0x6b */
	{ 0x6e,	0x2f },		/* 0x6e - 0x9c */
	{ 0xa0,	0xe },		/* 0xa0 - 0xad */
	{ 0xb0,	0xd },		/* 0xb0 - 0xbc */
	{ 0xc0,	0x1c },		/* 0xc0 - 0xdb */
	{ 0,	0 }
};

static phy_regs_t aphy6_regs[] = {
	{ 0,	6 },		/* 0 - 5 */
	{ 7,	2 },		/* 7 - 8 */
	{ 0xa,	1 },		/* 0xa */
	{ 0x10,	0x13 },		/* 0x10 - 0x22 */
	{ 0x24,	0x18 },		/* 0x24 - 0x3b */
	{ 0x3e,	1 },		/* 0x3e */
	{ 0x41,	0xe },		/* 0x41 - 0x4e */
	{ 0x50,	6 },		/* 0x50 - 0x55 */
	{ 0x58,	6 },		/* 0x58 - 0x5d */
	{ 0x5f,	5 },		/* 0x5f - 0x63 */
	{ 0x68,	4 },		/* 0x68 - 0x6b */
	{ 0x6e,	0x2f },		/* 0x6e - 0x9c */
	{ 0xa0,	0xe },		/* 0xa0 - 0xad */
	{ 0xb0,	0xd },		/* 0xb0 - 0xbc */
	{ 0xc0,	0x1f },		/* 0xc0 - 0xde */
	{ 0,	0 }
};

static phy_regs_t gphy1_regs[] = {
	{ 0x800,	0x14 },	/* 0x800 - 0x813 */
	{ 0,	0 }
};

static phy_regs_t gphy2_regs[] = {
	{ 0x800,	5 },	/* 0x800 - 0x804 */
	{ 0x80f,	7 },	/* 0x80f - 0x815 */
	{ 0,	0 }
};

static phy_regs_t nphy2_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x005,	0x001 },	/* 0x005 -  */
	{ 0x007,	0x001 },	/* 0x007 -  */
	{ 0x009,	0x001 },	/* 0x009 -  */
	{ 0x00b,	0x002 },	/* 0x00b -  0x00c */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x045 },	/* 0x018 -  */
	{ 0x060,	0x019 },	/* 0x060 -  */
	{ 0x07a,	0x00c },	/* 0x07a -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x00e },	/* 0x090 -  */
	{ 0x0a0,	0x02c },	/* 0x0a0 -  */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0d9,	0x005 },	/* 0x0d9 -  */
	{ 0x0ea,	0x026 },	/* 0x0ea -  */
	{ 0x111,	0x002 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x004 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x141,	0x00e },	/* 0x141 -  */
	{ 0x150,	0x001 },	/* 0x150 -  */
	{ 0x152,	0x002 },	/* 0x152 -  */
	{ 0x156,	0x009 },	/* 0x156 -  */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x04f },	/* 0x16f -  */
	{ 0x1c4,	0x04b },	/* 0x1c4 -  */
	{ 0x210,	0x00b },	/* 0x210 -  */
	{ 0x21d,	0x022 },	/* 0x21d -  */
	{ 0,	0 }
};
static phy_regs_t nphy3_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x004,	0x002 },	/* 0x004 -  */
	{ 0x007,	0x003 },	/* 0x007 -  */
	{ 0x00b,	0x002 },	/* 0x00b -  0x00c */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x008 },	/* 0x018 -  */
	{ 0x025,	0x011 },	/* 0x025 -  */
	{ 0x03b,	0x022 },	/* 0x03b -  */
	{ 0x060,	0x018 },	/* 0x060 -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x001 },	/* 0x090 -  */
	{ 0x095,	0x009 },	/* 0x095 -  */
	{ 0x0a0,	0x001 },	/* 0x0a0 -  */
	{ 0x0ae,	0x01e },	/* 0x0ae -  */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0d9,	0x005 },	/* 0x0d9 -  */
	{ 0x0e0,	0x005 },	/* 0x0e0 -  */
	{ 0x0ea,	0x002 },	/* 0x0ea -  */
	{ 0x0ed,	0x001 },	/* 0x0ed -  */
	{ 0x0ee,	0x00a },	/* 0x0ee -  */
	{ 0x104,	0x009 },	/* 0x104 -  */
	{ 0x111,	0x001 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x002 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x144,	0x00a },	/* 0x144 -  */
	{ 0x150,	0x001 },	/* 0x150 -  */
	{ 0x152,	0x003 },	/* 0x152 -  */
	{ 0x156,	0x009 },	/* 0x156 -  */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x04f },	/* 0x16f -  */
	{ 0x1c4,	0x03c },	/* 0x1c4 -  */
	{ 0x204,	0x004 },	/* 0x204 -  */
	{ 0x20a,	0x005 },	/* 0x20a -  */
	{ 0x210,	0x00b },	/* 0x210 -  */
	{ 0x21d,	0x019 },	/* 0x21d -  */
	{ 0x23e,	0x005 },	/* 0x23e -  */
	{ 0x245,	0x008 },	/* 0x245 -  */
	{ 0x250,	0x086 },	/* 0x250 -  */
	{ 0x20,		0x005 },	/* 0x20 -  */
	{ 0x36,		0x005 },	/* 0x36 -  */
	{ 0x78,		0x001 },	/* 0x78 -  */
	{ 0x7a,		0x001 },	/* 0x7a -  */
	{ 0x7b,		0x00b },	/* 0x7b -  */
	{ 0x8f,		0x001 },	/* 0x8f -  */
	{ 0x91,		0x004 },	/* 0x91 -  */
	{ 0xa1,		0x00d },	/* 0xa1 -  */
	{ 0xcc,		0x004 },	/* 0xcc -  */
	{ 0xe5,		0x005 },	/* 0xe5 -  */
	{ 0xec,		0x001 },	/* 0xec -  */
	{ 0xf8,		0x00c },	/* 0xf8 -  */
	{ 0x10d,	0x003 },	/* 0x10d -  */
	{ 0x112,	0x001 },	/* 0x112 -  */
	{ 0x14e,	0x001 },	/* 0x14e -  */
	{ 0x200,	0x004 },	/* 0x200 -  */
	{ 0x208,	0x002 },	/* 0x208 -  */
	{ 0x236,	0x008 },	/* 0x236 -  */
	{ 0x243,	0x002 },	/* 0x243 -  */
	{ 0,	0 }
};

static phy_regs_t nphy5_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x004,	0x002 },	/* 0x004 -  */
	{ 0x007,	0x003 },	/* 0x007 -  */
	{ 0x00b,	0x002 },	/* 0x00b -  0x00c */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x008 },	/* 0x018 -  */
	{ 0x025,	0x011 },	/* 0x025 -  */
	{ 0x03b,	0x022 },	/* 0x03b -  */
	{ 0x060,	0x018 },	/* 0x060 -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x001 },	/* 0x090 -  */
	{ 0x095,	0x009 },	/* 0x095 -  */
	{ 0x0a0,	0x001 },	/* 0x0a0 -  */
	{ 0x0ae,	0x01e },	/* 0x0ae -  */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0d9,	0x005 },	/* 0x0d9 -  */
	{ 0x0e0,	0x005 },	/* 0x0e0 -  */
	{ 0x0ea,	0x002 },	/* 0x0ea -  */
	{ 0x0ed,	0x001 },	/* 0x0ed -  */
	{ 0x0ee,	0x00a },	/* 0x0ee -  */
	{ 0x104,	0x009 },	/* 0x104 -  */
	{ 0x111,	0x001 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x002 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x144,	0x00a },	/* 0x144 -  */
	{ 0x150,	0x001 },	/* 0x150 -  */
	{ 0x152,	0x003 },	/* 0x152 -  */
	{ 0x156,	0x009 },	/* 0x156 -  */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x04f },	/* 0x16f -  */
	{ 0x1c4,	0x03c },	/* 0x1c4 -  */
	{ 0x204,	0x004 },	/* 0x204 -  */
	{ 0x20a,	0x005 },	/* 0x20a -  */
	{ 0x210,	0x00b },	/* 0x210 -  */
	{ 0x21d,	0x019 },	/* 0x21d -  */
	{ 0x23e,	0x005 },	/* 0x23e -  */
	{ 0x245,	0x008 },	/* 0x245 -  */
	{ 0x250,	0x086 },	/* 0x250 -  */
	{ 0x20,		0x005 },	/* 0x20 -  */
	{ 0x36,		0x005 },	/* 0x36 -  */
	{ 0x78,		0x001 },	/* 0x78 -  */
	{ 0x7a,		0x001 },	/* 0x7a -  */
	{ 0x7b,		0x005 },	/* 0x7b -  */
	{ 0x8f,		0x001 },	/* 0x8f -  */
	{ 0x91,		0x002 },	/* 0x91 -  */
	{ 0xa1,		0x007 },	/* 0xa1 -  */
	{ 0xaa,		0x002 },	/* 0xaa -  */
	{ 0xcc,		0x002 },	/* 0xcc -  */
	{ 0xe5,		0x005 },	/* 0xe5 -  */
	{ 0xec,		0x001 },	/* 0xec -  */
	{ 0xf8,		0x004 },	/* 0xf8 -  */
	{ 0x100,	0x002 },	/* 0x100 -  */
	{ 0x10d,	0x003 },	/* 0x10d -  */
	{ 0x112,	0x001 },	/* 0x112 -  */
	{ 0x200,	0x004 },	/* 0x200 -  */
	{ 0x208,	0x002 },	/* 0x208 -  */
	{ 0x236,	0x008 },	/* 0x236 -  */
	{ 0x243,	0x002 },	/* 0x243 -  */
	{ 0,	0 }
};

static phy_regs_t nphy7_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x004,	0x002 },	/* 0x004 -  */
	{ 0x007,	0x003 },	/* 0x007 -  */
	{ 0x00c,	0x001 },	/* 0x00c -  */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x008 },	/* 0x018 -  */
	{ 0x025,	0x011 },	/* 0x025 -  */
	{ 0x03b,	0x022 },	/* 0x03b -  */
	{ 0x060,	0x018 },	/* 0x060 -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x001 },	/* 0x090 -  */
	{ 0x095,	0x009 },	/* 0x095 -  */
	{ 0x0a0,	0x001 },	/* 0x0a0 -  */
	{ 0x0ae,	0x01e },	/* 0x0ae -  */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0d9,	0x005 },	/* 0x0d9 -  */
	{ 0x0e0,	0x005 },	/* 0x0e0 -  */
	{ 0x0ea,	0x002 },	/* 0x0ea -  */
	{ 0x0ed,	0x001 },	/* 0x0ed -  */
	{ 0x0ee,	0x00a },	/* 0x0ee -  */
	{ 0x104,	0x009 },	/* 0x104 -  */
	{ 0x111,	0x001 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x002 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x144,	0x00a },	/* 0x144 -  */
	{ 0x152,	0x003 },	/* 0x152 -  */
	{ 0x156,	0x009 },	/* 0x156 -  */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x04f },	/* 0x16f -  */
	{ 0x1c4,	0x03c },	/* 0x1c4 -  */
	{ 0x204,	0x004 },	/* 0x204 -  */
	{ 0x20a,	0x005 },	/* 0x20a -  */
	{ 0x210,	0x00b },	/* 0x210 -  */
	{ 0x21d,	0x019 },	/* 0x21d -  */
	{ 0x23e,	0x005 },	/* 0x23e -  */
	{ 0x246,	0x007 },	/* 0x245 -  */
	{ 0x250,	0x057 },	/* 0x250 -  */
	{ 0x2b1,	0x025 },
	{ 0x2d6,	0x001 },
	{ 0x2d8,	0x00f },
	{ 0x2e8,	0x003 },
	{ 0x2f0,	0x007 },
	{ 0x2f8,	0x007 },
	{ 0x300,	0x004 },
	{ 0x30b,	0x003 },
	{ 0x310,	0x004 },
	{ 0x318,	0x004 },
	{ 0x320,	0x007 },
	{ 0x32f,	0x001 },
	{ 0x330,	0x004 },
	{ 0x335,	0x001 },
	{ 0x338,	0x008 },
	{ 0x34a,	0x001 },
	{ 0x350,	0x007 },
	{ 0x00b,	0x001 },
	{ 0x20,		0x005 },	/* 0x20 -  */
	{ 0x36,		0x005 },	/* 0x36 -  */
	{ 0x78,		0x002 },	/* 0x78 -  */
	{ 0x7a,		0x001 },	/* 0x7a -  */
	{ 0x7b,		0x005 },	/* 0x7b -  */
	{ 0x8f,		0x001 },	/* 0x8f -  */
	{ 0x91,		0x002 },	/* 0x91 -  */
	{ 0xa1,		0x007 },	/* 0xa1 -  */
	{ 0xaa,		0x002 },	/* 0xaa -  */
	{ 0xcc,		0x002 },	/* 0xcc -  */
	{ 0xe5,		0x005 },	/* 0xe5 -  */
	{ 0xec,		0x001 },	/* 0xec -  */
	{ 0xf8,		0x004 },	/* 0xf8 -  */
	{ 0x100,	0x002 },	/* 0x100 -  */
	{ 0x112,	0x001 },	/* 0x112 -  */
	{ 0x150,	0x001 },
	{ 0x200,	0x004 },	/* 0x200 -  */
	{ 0x208,	0x002 },	/* 0x208 -  */
	{ 0x236,	0x008 },	/* 0x236 -  */
	{ 0x243,	0x003 },	/* 0x243 -  */
	{ 0x2a7,	0x00a },
	{ 0x2ff,	0x001 },
	{ 0x304,	0x007 },
	{ 0x340,	0x00a },
	{ 0x357,	0x001 },
	{ 0,	0 }
};

/* 6362B0 (rev8) crashes when accessing a non-existing table address, so skip PHY regs 0x73-74 */
static phy_regs_t nphy8_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x004,	0x002 },	/* 0x004 -  */
	{ 0x007,	0x003 },	/* 0x007 -  */
	{ 0x00c,	0x001 },	/* 0x00c -  */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x008 },	/* 0x018 -  */
	{ 0x025,	0x001 },	/* 0x025 -  */
	{ 0x029,	0x00d },	/* 0x029 -  */
	{ 0x03b,	0x001 },	/* 0x03b -  */
	{ 0x03f,	0x01e },	/* 0x03f -  */
	{ 0x060,	0x013 },	/* 0x060 -  */
	{ 0x075,	0x001 },	/* 0x075 -  */
	{ 0x077,	0x001 },	/* 0x077 -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x001 },	/* 0x090 -  */
	{ 0x095,	0x001 },	/* 0x095 -  */
	{ 0x097,	0x001 },	/* 0x097 -  */
	{ 0x09a,	0x004 },	/* 0x09a -  */
	{ 0x0a0,	0x001 },	/* 0x0a0 -  */
	{ 0x0ae,	0x00c },	/* 0x0ae -  */
	{ 0x0bc,	0x010 },	/* 0x0bc -  */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0d9,	0x005 },	/* 0x0d9 -  */
	{ 0x0e0,	0x005 },	/* 0x0e0 -  */
	{ 0x0ea,	0x002 },	/* 0x0ea -  */
	{ 0x0ed,	0x001 },	/* 0x0ed -  */
	{ 0x0ee,	0x00a },	/* 0x0ee -  */
	{ 0x109,	0x004 },	/* 0x109 -  */
	{ 0x111,	0x001 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x002 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x144,	0x00a },	/* 0x144 -  */
	{ 0x152,	0x003 },	/* 0x152 -  */
	{ 0x156,	0x009 },	/* 0x156 -  */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x004 },	/* 0x16f -  */
	{ 0x175,	0x008 },	/* 0x175 -  */
	{ 0x17e,	0x040 },	/* 0x17e -  */
	{ 0x1c4,	0x03c },	/* 0x1c4 -  */
	{ 0x204,	0x004 },	/* 0x204 -  */
	{ 0x20a,	0x005 },	/* 0x20a -  */
	{ 0x210,	0x006 },	/* 0x210 -  */
	{ 0x217,	0x001 },	/* 0x217 -  */
	{ 0x219,	0x002 },	/* 0x219 -  */
	{ 0x21d,	0x019 },	/* 0x21d -  */
	{ 0x23e,	0x005 },	/* 0x23e -  */
	{ 0x246,	0x007 },	/* 0x245 -  */
	{ 0x250,	0x057 },	/* 0x250 -  */
	{ 0x2b1,	0x025 },
	{ 0x2d6,	0x001 },
	{ 0x2d8,	0x00f },
	{ 0x2e8,	0x004 },
	{ 0x2f0,	0x007 },
	{ 0x2f8,	0x007 },
	{ 0x300,	0x004 },
	{ 0x30b,	0x003 },
	{ 0x310,	0x004 },
	{ 0x318,	0x004 },
	{ 0x320,	0x007 },
	{ 0x32f,	0x001 },
	{ 0x330,	0x004 },
	{ 0x335,	0x001 },
	{ 0x338,	0x008 },
	{ 0x34a,	0x001 },
	{ 0x350,	0x007 },
	{ 0x358,	0x002 },        /* 0x358 -  */
	{ 0x360,	0x003 },        /* 0x360 -  */
	{ 0x00b,	0x001 },
	{ 0x20,		0x005 },	/* 0x20 -  */
	{ 0x36,		0x005 },	/* 0x36 -  */
	{ 0x78,		0x002 },	/* 0x78 -  */
	{ 0x7a,		0x001 },	/* 0x7a -  */
	{ 0x7b,		0x005 },	/* 0x7b -  */
	{ 0x8f,		0x001 },	/* 0x8f -  */
	{ 0x91,		0x002 },	/* 0x91 -  */
	{ 0xa1,		0x007 },	/* 0xa1 -  */
	{ 0xaa,		0x002 },	/* 0xaa -  */
	{ 0xcc,		0x002 },	/* 0xcc -  */
	{ 0xe5,		0x005 },	/* 0xe5 -  */
	{ 0xec,		0x001 },	/* 0xec -  */
	{ 0xf8,		0x004 },	/* 0xf8 -  */
	{ 0x100,	0x002 },	/* 0x100 -  */
	{ 0x112,	0x001 },	/* 0x112 -  */
	{ 0x150,	0x001 },
	{ 0x200,	0x004 },	/* 0x200 -  */
	{ 0x208,	0x002 },	/* 0x208 -  */
	{ 0x236,	0x008 },	/* 0x236 -  */
	{ 0x243,	0x003 },	/* 0x243 -  */
	{ 0x2a7,	0x00a },
	{ 0x2ff,	0x001 },
	{ 0x304,	0x007 },
	{ 0x340,	0x00a },
	{ 0x357,	0x001 },
	{ 0,	0 }
};

/* 53572/43217 (rev17) */
static phy_regs_t nphy17_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 -  */
	{ 0x004,	0x002 },	/* 0x004 -  */
	{ 0x007,	0x003 },	/* 0x007 -  */
	{ 0x00c,	0x001 },	/* 0x00c -  */
	{ 0x00e,	0x002 },	/* 0x00e -  */
	{ 0x018,	0x008 },	/* 0x018 -  */
	{ 0x025,	0x001 },	/* 0x025 -  */
	{ 0x029,	0x00d },	/* 0x029 -  */
	{ 0x03b,	0x001 },	/* 0x03b -  */
	{ 0x03f,	0x00a },	/* 0x03f -  0x048 */
	{ 0x053,	0x00a },	/* 0x053 -  0x05c */
	{ 0x060,	0x016 },	/* 0x060 -  0x075 */
	{ 0x077,	0x001 },	/* 0x077 -  */
	{ 0x08b,	0x002 },	/* 0x08b -  */
	{ 0x090,	0x001 },	/* 0x090 -  */
	{ 0x095,	0x002 },	/* 0x095 -  0x096 */
	{ 0x097,	0x001 },	/* 0x097 -  */
	{ 0x09a,	0x007 },	/* 0x09a -  0x0a0 */
	{ 0x0ae,	0x00a },	/* 0x0ae -  0x0b7 */
	{ 0x0bd,	0x00f },	/* 0x0bd -  0x0cb */
	{ 0x0d5,	0x002 },	/* 0x0d5 -  */
	{ 0x0dc,	0x002 },	/* 0x0dc -  0x0dd */
	{ 0x0e0,	0x005 },	/* 0x0e0 -  */
	{ 0x0ed,	0x001 },	/* 0x0ed -  */
	{ 0x0ee,	0x00a },	/* 0x0ee -  */
	{ 0x111,	0x001 },	/* 0x111 -  */
	{ 0x114,	0x002 },	/* 0x114 -  */
	{ 0x118,	0x002 },	/* 0x118 -  */
	{ 0x11c,	0x002 },	/* 0x11c -  */
	{ 0x122,	0x010 },	/* 0x122 -  */
	{ 0x134,	0x009 },	/* 0x134 -  */
	{ 0x13f,	0x001 },	/* 0x13f -  */
	{ 0x144,	0x00a },	/* 0x144 -  */
	{ 0x152,	0x003 },	/* 0x152 -  */
	{ 0x157,	0x008 },	/* 0x157 -  0x15e */
	{ 0x160,	0x00c },	/* 0x160 -  */
	{ 0x16f,	0x002 },	/* 0x16f -  0x0170 */
	{ 0x17a,	0x003 },	/* 0x17a -  0x17c */
	{ 0x17e,	0x001 },	/* 0x17e -  0x17e */
	{ 0x183,	0x001 },	/* 0x183 -  0x183 */
	{ 0x186,	0x038 },	/* 0x186 -  0x1bd */
	{ 0x1c4,	0x033 },	/* 0x1c4 -  0x1f6 */
	{ 0x1ff,	0x001 },	/* 0x1ff -  0x1ff */
	{ 0x204,	0x001 },	/* 0x204 -  0x204 */
	{ 0x20a,	0x005 },	/* 0x20a -  */
	{ 0x210,	0x006 },	/* 0x210 -  */
	{ 0x217,	0x001 },	/* 0x217 -  */
	{ 0x219,	0x002 },	/* 0x219 -  */
	{ 0x21d,	0x019 },	/* 0x21d -  */
	{ 0x23e,	0x005 },	/* 0x23e -  */
	{ 0x246,	0x007 },	/* 0x245 -  */
	{ 0x250,	0x00d },	/* 0x250 -  0x25c */
	{ 0x267,	0x026 },	/* 0x267 -  0x28c */
	{ 0x294,	0x013 },	/* 0x294 -  0x2a6 */
	{ 0x2b1,	0x025 },
	{ 0x2d6,	0x002 },    /* 0x2d6 -  0x2d7 */
	{ 0x2d8,	0x010 },    /* 0x2d8 -  0x2e7 */
	{ 0x2e8,	0x004 },
	{ 0x2f0,	0x007 },
	{ 0x2f8,	0x007 },
	{ 0x300,	0x004 },
	{ 0x30b,	0x003 },
	{ 0x310,	0x004 },
	{ 0x318,	0x004 },
	{ 0x320,	0x007 },
	{ 0x32f,	0x001 },
	{ 0x330,	0x004 },
	{ 0x335,	0x001 },
	{ 0x338,	0x008 },
	{ 0x34a,	0x001 },
	{ 0x350,	0x007 },
	{ 0x358,	0x003 },        /* 0x358 -  0x35a */
	{ 0x360,	0x050 },        /* 0x360 -  0x3af */
	{ 0x3b1,	0x001 },        /* 0x3b1 -  0x3b1 */
	{ 0xc73,	0x006 },        /* 0xc73 -  0xc78 */
	{ 0x00b,	0x001 },
	{ 0x20,		0x005 },	/* 0x20 -  */
	{ 0x36,		0x005 },	/* 0x36 -  */
	{ 0x78,		0x002 },	/* 0x78 -  */
	{ 0x7a,		0x001 },	/* 0x7a -  */
	{ 0x7b,		0x005 },	/* 0x7b -  */
	{ 0x8f,		0x001 },	/* 0x8f -  */
	{ 0x91,		0x002 },	/* 0x91 -  */
	{ 0xa1,		0x007 },	/* 0xa1 -  */
	{ 0xaa,		0x002 },	/* 0xaa -  */
	{ 0xcc,		0x002 },	/* 0xcc -  */
	{ 0xe5,		0x005 },	/* 0xe5 -  */
	{ 0xec,		0x001 },	/* 0xec -  */
	{ 0xf8,		0x004 },	/* 0xf8 -  */
	{ 0x100,	0x002 },	/* 0x100 -  */
	{ 0x112,	0x001 },	/* 0x112 -  */
	{ 0x150,	0x001 },
	{ 0x200,	0x004 },	/* 0x200 -  */
	{ 0x208,	0x002 },	/* 0x208 -  */
	{ 0x236,	0x008 },	/* 0x236 -  */
	{ 0x243,	0x003 },	/* 0x243 -  */
	{ 0x2a7,	0x00a },
	{ 0x2ff,	0x001 },
	{ 0x304,	0x007 },
	{ 0x340,	0x00a },
	{ 0x357,	0x001 },
	{ 0,	0 }
};

static phy_regs_t lcn40phy3_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 - 0x001 */
	{ 0x004,	0x002 },	/* 0x004 - 0x005 */
	{ 0x007,	0x001 },	/* 0x007 */
	{ 0x007,	0x004 },	/* 0x009 - 0x00c */
	{ 0x010,	0x001 },	/* 0x010 */
	{ 0x012,	0x002 },	/* 0x012 - 0x013 */
	{ 0x018,	0x002 },	/* 0x018 - 0x019 */
	{ 0x027,	0x001 },	/* 0x027 */
	{ 0x030,	0x002 },	/* 0x030 - 0x031 */
	{ 0x033,	0x003 },	/* 0x033 - 0x035 */
	{ 0x038,	0x002 },	/* 0x038 - 0x039 */
	{ 0x03d,	0x012 },	/* 0x03d - 0x04d */
	{ 0x04f,	0x001 },	/* 0x04f */
	{ 0x052,	0x002 },	/* 0x052 - 0x053 */
	{ 0x05d,	0x003 },	/* 0x05d - 0x05f */
	{ 0x068,	0x006 },	/* 0x068 - 0x006 */
	{ 0x070,	0x003 },	/* 0x070 - 0x072 */
	{ 0x0d9,	0x005 },	/* 0x0d9 - 0x0dd */
	{ 0x400,	0x00f },	/* 0x400 - 0x40e */
	{ 0x410,	0x02a },	/* 0x410 - 0x439 */
	{ 0x43b,	0x001 },	/* 0x43b */
	{ 0x440,	0x028 },	/* 0x440 - 0x467 */
	{ 0x469,	0x006 },	/* 0x469 - 0x46e */
	{ 0x470,	0x00b },	/* 0x470 - 0x47a */
	{ 0x47f,	0x017 },	/* 0x47f - 0x495 */
	{ 0x498,	0x001 },	/* 0x498 */
	{ 0x49a,	0x004 },	/* 0x49a - 0x49d */
	{ 0x4a2,	0x00c },	/* 0x4a2 - 0x4ad */
	{ 0x4b0,	0x002 },	/* 0x4b0 - 0x4b1 */
	{ 0x4b5,	0x001 },	/* 0x4b5 */
	{ 0x4b9,	0x008 },	/* 0x4b9 - 0x4c0 */
	{ 0x4d7,	0x00c },	/* 0x4d7 - 0x4e2 */
	{ 0x4e4,	0x008 },	/* 0x4e4 - 0x4eb */
	{ 0x4f0,	0x003 },	/* 0x4f0 - 0x4f2 */
	{ 0x4f9,	0x003 },	/* 0x4f9 - 0x4fb */
	{ 0x4fe,	0x004 },	/* 0x4fe - 0x501 */
	{ 0x503,	0x001 },	/* 0x503 */
	{ 0x506,	0x005 },	/* 0x506 - 0x50a */
	{ 0x50c,	0x003 },	/* 0x50c - 0x50e */
	{ 0x512,	0x001 },	/* 0x512 */
	{ 0x514,	0x035 },	/* 0x514 - 0x547 */
	{ 0x54b,	0x01e },	/* 0x54b - 0x568 */
	{ 0x570,	0x00b },	/* 0x570 - 0x580 */
	{ 0x583,	0x004 },	/* 0x583 - 0x586 */
	{ 0x589,	0x001 },	/* 0x589 */
	{ 0x591,	0x001 },	/* 0x591 */
	{ 0x593,	0x00b },	/* 0x593 - 0x59d */
	{ 0x5a1,	0x019 },	/* 0x5a1 - 0x5b9 */
	{ 0x5bb,	0x00f },	/* 0x5bb - 0x5c9 */
	{ 0x5cf,	0x006 },	/* 0x5cf - 0x5d4 */
	{ 0x5e0,	0x00e },	/* 0x5e0 - 0x5ed */
	{ 0x5f0,	0x014 },	/* 0x5f0 - 0x603 */
	{ 0x606,	0x023 },	/* 0x606 - 0x628 */
	{ 0x62a,	0x006 },	/* 0x62a - 0x62f */
	{ 0x631,	0x001 },	/* 0x631 */
	{ 0x634,	0x005 },	/* 0x634 - 0x638 */
	{ 0x63a,	0x050 },	/* 0x63a - 0x689 */
	{ 0x68b,	0x002 },	/* 0x68b - 0x68c */
	{ 0x690,	0x009 },	/* 0x690 - 0x698 */
	{ 0x69d,	0x001 },	/* 0x69d - 0x4eb */
	{ 0x6a1,	0x007 },	/* 0x6a1 - 0x6a7 */
	{ 0x6b2,	0x006 },	/* 0x6b2 - 0x6b7 */
	{ 0x6ba,	0x004 },	/* 0x6ba - 0x6bd */
	{ 0x6c2,	0x004 },	/* 0x6c2 - 0x6c5 */
	{ 0x6c8,	0x00f },	/* 0x6c8 - 0x6d6 */
	{ 0x6d8,	0x004 },	/* 0x6d8 - 0x6db */
	{ 0x6e1,	0x007 },	/* 0x6e1 - 0x6e7 */
	{ 0x6e2,	0x003 },	/* 0x6f0 - 0x6f2 */
	{ 0x775,	0x002 },	/* 0x775 - 0x776 */
	{ 0x77a,	0x003 },	/* 0x77a - 0x77c */
	{ 0x780,	0x00a },	/* 0x780 - 0x789 */
	{ 0x790,	0x00a },	/* 0x790 - 0x799 */
	{ 0x7c2,	0x005 },	/* 0x7c2 - 0x7c6 */
	{ 0x7d1,	0x006 },	/* 0x7d1 - 0x7d6 */
	{ 0x800,	0x001 },	/* 0x800 */
	{ 0x803,	0x007 },	/* 0x803 - 0x809 */
	{ 0x810,	0x003 },	/* 0x810 - 0x812 */
	{ 0x820,	0x00a },	/* 0x820 - 0x829 */
	{ 0x830,	0x003 },	/* 0x830 - 0x832 */
	{ 0x86c,	0x002 },	/* 0x86c - 0x86d */
	{ 0x87a,	0x001 },	/* 0x87a */
	{ 0x880,	0x002 },	/* 0x880 - 0x881 */
	{ 0x890,	0x001 },	/* 0x890 */
	{ 0x900,	0x013 },	/* 0x900 - 0x912 */
	{ 0x91e,	0x00c },	/* 0x91e - 0x929 */
	{ 0x930,	0x00a },	/* 0x930 - 0x939 */
	{ 0x93d,	0x005 },	/* 0x93d - 0x941 */
	{ 0x944,	0x006 },	/* 0x944 - 0x949 */
	{ 0x950,	0x008 },	/* 0x950 - 0x957 */
	{ 0x960,	0x004 },	/* 0x960 - 0x963 */
	{ 0xa00,	0x001 },	/* 0xa00 */
	{ 0xa04,	0x00d },	/* 0xa04 - 0xa10 */
	{ 0xa13,	0x07b },	/* 0xa13 - 0xa8d */
};

static phy_regs_t htphy0_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 - 0x001 */
	{ 0x004,	0x002 },	/* 0x004 - 0x005 */
	{ 0x007,	0x003 },	/* 0x007 - 0x009 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x020,	0x004 },	/* 0x020 - 0x023 */
	{ 0x044,	0x019 },	/* 0x044 - 0x05c */
	{ 0x060,	0x016 },	/* 0x060 - 0x075 */
	{ 0x077,	0x001 },	/* 0x077 - 0x077 */
	{ 0x08b,	0x003 },	/* 0x08b - 0x08d */
	{ 0x090,	0x001 },	/* 0x090 - 0x090 */
	{ 0x095,	0x001 },	/* 0x095 - 0x095 */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x09a,	0x008 },	/* 0x09a - 0x0a1 */
	{ 0x0ae,	0x00f },	/* 0x0ae - 0x0bc */
	{ 0x0be,	0x00e },	/* 0x0be - 0x0cb */
	{ 0x0d6,	0x001 },	/* 0x0d6 - 0x0d6 */
	{ 0x0d9,	0x005 },	/* 0x0d9 - 0x0dd */
	{ 0x0e0,	0x007 },	/* 0x0e0 - 0x0e6 */
	{ 0x0ed,	0x00b },	/* 0x0ed - 0x0f7 */
	{ 0x109,	0x004 },	/* 0x109 - 0x10c */
	{ 0x111,	0x001 },	/* 0x111 - 0x111 */
	{ 0x114,	0x003 },	/* 0x114 - 0x116 */
	{ 0x118,	0x003 },	/* 0x118 - 0x11a */
	{ 0x11c,	0x002 },	/* 0x11c - 0x11d */
	{ 0x122,	0x010 },	/* 0x122 - 0x131 */
	{ 0x134,	0x00c },	/* 0x134 - 0x13f */
	{ 0x144,	0x001 },	/* 0x144 - 0x144 */
	{ 0x14d,	0x003 },	/* 0x14d - 0x14f */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x157,	0x00a },	/* 0x157 - 0x160 */
	{ 0x171,	0x002 },	/* 0x171 - 0x172 */
	{ 0x175,	0x007 },	/* 0x175 - 0x17b */
	{ 0x17e,	0x040 },	/* 0x17e - 0x1bd */
	{ 0x1c8,	0x004 },	/* 0x1c8 - 0x1cb */
	{ 0x1cd,	0x033 },	/* 0x1cd - 0x1ff */
	{ 0x204,	0x004 },	/* 0x204 - 0x207 */
	{ 0x20a,	0x001 },	/* 0x20a - 0x20a */
	{ 0x20c,	0x002 },	/* 0x20c - 0x20d */
	{ 0x214,	0x002 },	/* 0x214 - 0x215 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x219,	0x003 },	/* 0x219 - 0x21b */
	{ 0x21d,	0x019 },	/* 0x21d - 0x235 */
	{ 0x23e,	0x005 },	/* 0x23e - 0x242 */
	{ 0x245,	0x003 },	/* 0x245 - 0x247 */
	{ 0x24c,	0x001 },	/* 0x24c - 0x24c */
	{ 0x259,	0x030 },	/* 0x259 - 0x288 */
	{ 0x28c,	0x022 },	/* 0x28c - 0x2ad */
	{ 0x2b1,	0x045 },	/* 0x2b1 - 0x2f5 */
	{ 0x308,	0x006 },	/* 0x308 - 0x30d */
	{ 0x310,	0x004 },	/* 0x310 - 0x313 */
	{ 0x318,	0x004 },	/* 0x318 - 0x31b */
	{ 0x320,	0x007 },	/* 0x320 - 0x326 */
	{ 0x32f,	0x001 },	/* 0x32f - 0x32f */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x358,	0x002 },	/* 0x358 - 0x359 */
	{ 0x400,	0x009 },	/* 0x400 - 0x408 */
	{ 0x40b,	0x012 },	/* 0x40b - 0x41c */
	{ 0x420,	0x009 },	/* 0x420 - 0x428 */
	{ 0x440,	0x009 },	/* 0x440 - 0x448 */
	{ 0x44b,	0x012 },	/* 0x44b - 0x45c */
	{ 0x460,	0x009 },	/* 0x460 - 0x468 */
	{ 0x480,	0x009 },	/* 0x480 - 0x488 */
	{ 0x48b,	0x012 },	/* 0x48b - 0x49c */
	{ 0x4a0,	0x009 },	/* 0x4a0 - 0x4a8 */
	{ 0x500,	0x003 },	/* 0x500 - 0x502 */
	{ 0x510,	0x009 },	/* 0x510 - 0x518 */
	{ 0x520,	0x003 },	/* 0x520 - 0x522 */
	{ 0x530,	0x006 },	/* 0x530 - 0x535 */
	{ 0x540,	0x00f },	/* 0x540 - 0x54e */
	{ 0x550,	0x002 },	/* 0x550 - 0x551 */
	{ 0x800,	0x002 },	/* 0x800 - 0x801 */
	{ 0x803,	0x004 },	/* 0x803 - 0x806 */
	{ 0x808,	0x002 },	/* 0x808 - 0x809 */
	{ 0x810,	0x003 },	/* 0x810 - 0x812 */
	{ 0x820,	0x003 },	/* 0x820 - 0x822 */
	{ 0x824,	0x003 },	/* 0x824 - 0x826 */
	{ 0x828,	0x001 },	/* 0x828 - 0x828 */
	{ 0x830,	0x00c },	/* 0x830 - 0x83b */
	{ 0x840,	0x00d },	/* 0x840 - 0x84c */
	{ 0x860,	0x00d },	/* 0x860 - 0x86c */
	{ 0x880,	0x00d },	/* 0x880 - 0x88c */
	{ 0x900,	0x006 },	/* 0x900 - 0x905 */
	{ 0x908,	0x001 },	/* 0x908 - 0x908 */
	{ 0x910,	0x003 },	/* 0x910 - 0x912 */
	{ 0x914,	0x003 },	/* 0x914 - 0x916 */
	{ 0x918,	0x003 },	/* 0x918 - 0x91a */
	{ 0x94f,	0x004 },	/* 0x94f - 0x952 */
	{ 0x955,	0x007 },	/* 0x955 - 0x95b */
	{ 0x960,	0x003 },	/* 0x960 - 0x962 */
	{ 0x964,	0x008 },	/* 0x964 - 0x96b */
	{ 0x970,	0x003 },	/* 0x970 - 0x972 */
	{ 0x980,	0x00f },	/* 0x980 - 0x98e */
	{ 0,	0 }
};

static phy_regs_t htphy1_regs[] = {
	{ 0x000,	0x002 },	/* 0x000 - 0x001 */
	{ 0x004,	0x002 },	/* 0x004 - 0x005 */
	{ 0x007,	0x003 },	/* 0x007 - 0x009 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x020,	0x004 },	/* 0x020 - 0x023 */
	{ 0x044,	0x005 },	/* 0x044 - 0x048 */
	{ 0x053,	0x00a },	/* 0x053 - 0x05c */
	{ 0x060,	0x016 },	/* 0x060 - 0x075 */
	{ 0x077,	0x001 },	/* 0x077 - 0x077 */
	{ 0x08b,	0x003 },	/* 0x08b - 0x08d */
	{ 0x090,	0x001 },	/* 0x090 - 0x090 */
	{ 0x095,	0x001 },	/* 0x095 - 0x095 */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x09a,	0x008 },	/* 0x09a - 0x0a1 */
	{ 0x0ae,	0x004 },	/* 0x0ae - 0x0b1 */
	{ 0x0b4,	0x002 },	/* 0x0b4 - 0x0b5 */
	{ 0x0b9,	0x004 },	/* 0x0b9 - 0x0bc */
	{ 0x0be,	0x00e },	/* 0x0be - 0x0cb */
	{ 0x0d6,	0x001 },	/* 0x0d6 - 0x0d6 */
	{ 0x0d9,	0x002 },	/* 0x0d9 - 0x0da */
	{ 0x0dc,	0x002 },	/* 0x0dc - 0x0dd */
	{ 0x0e0,	0x007 },	/* 0x0e0 - 0x0e6 */
	{ 0x0ed,	0x00a },	/* 0x0ed - 0x0f6 */
	{ 0x109,	0x004 },	/* 0x109 - 0x10c */
	{ 0x111,	0x001 },	/* 0x111 - 0x111 */
	{ 0x114,	0x003 },	/* 0x114 - 0x116 */
	{ 0x118,	0x003 },	/* 0x118 - 0x11a */
	{ 0x11c,	0x002 },	/* 0x11c - 0x11d */
	{ 0x122,	0x010 },	/* 0x122 - 0x131 */
	{ 0x134,	0x00c },	/* 0x134 - 0x13f */
	{ 0x144,	0x001 },	/* 0x144 - 0x144 */
	{ 0x14d,	0x003 },	/* 0x14d - 0x14f */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x157,	0x00a },	/* 0x157 - 0x160 */
	{ 0x171,	0x002 },	/* 0x171 - 0x172 */
	{ 0x175,	0x007 },	/* 0x175 - 0x17b */
	{ 0x17e,	0x001 },	/* 0x17e - 0x17e */
	{ 0x183,	0x001 },	/* 0x183 - 0x183 */
	{ 0x186,	0x038 },	/* 0x186 - 0x1bd */
	{ 0x1c8,	0x003 },	/* 0x1c8 - 0x1ca */
	{ 0x1cd,	0x011 },	/* 0x1cd - 0x1dd */
	{ 0x1df,	0x001 },	/* 0x1df - 0x1df */
	{ 0x1e1,	0x001 },	/* 0x1e1 - 0x1e1 */
	{ 0x1e5,	0x012 },	/* 0x1e5 - 0x1f6 */
	{ 0x1f9,	0x001 },	/* 0x1f9 - 0x1f9 */
	{ 0x1fb,	0x005 },	/* 0x1fb - 0x1ff */
	{ 0x204,	0x001 },	/* 0x204 - 0x204 */
	{ 0x20a,	0x001 },	/* 0x20a - 0x20a */
	{ 0x20c,	0x002 },	/* 0x20c - 0x20d */
	{ 0x214,	0x002 },	/* 0x214 - 0x215 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x219,	0x003 },	/* 0x219 - 0x21b */
	{ 0x21d,	0x007 },	/* 0x21d - 0x223 */
	{ 0x228,	0x00e },	/* 0x228 - 0x235 */
	{ 0x23e,	0x005 },	/* 0x23e - 0x242 */
	{ 0x245,	0x003 },	/* 0x245 - 0x247 */
	{ 0x24c,	0x001 },	/* 0x24c - 0x24c */
	{ 0x259,	0x004 },	/* 0x259 - 0x25c */
	{ 0x267,	0x01f },	/* 0x267 - 0x285 */
	{ 0x293,	0x001 },	/* 0x293 - 0x293 */
	{ 0x295,	0x019 },	/* 0x295 - 0x2ad */
	{ 0x2b1,	0x03b },	/* 0x2b1 - 0x2eb */
	{ 0x2ed,	0x009 },	/* 0x2ed - 0x2f5 */
	{ 0x308,	0x006 },	/* 0x308 - 0x30d */
	{ 0x310,	0x004 },	/* 0x310 - 0x313 */
	{ 0x318,	0x004 },	/* 0x318 - 0x31b */
	{ 0x320,	0x007 },	/* 0x320 - 0x326 */
	{ 0x32f,	0x001 },	/* 0x32f - 0x32f */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x358,	0x002 },	/* 0x358 - 0x359 */
	{ 0x400,	0x008 },	/* 0x400 - 0x407 */
	{ 0x40b,	0x012 },	/* 0x40b - 0x41c */
	{ 0x420,	0x009 },	/* 0x420 - 0x428 */
	{ 0x440,	0x008 },	/* 0x440 - 0x447 */
	{ 0x44b,	0x012 },	/* 0x44b - 0x45c */
	{ 0x460,	0x009 },	/* 0x460 - 0x468 */
	{ 0x480,	0x008 },	/* 0x480 - 0x487 */
	{ 0x48b,	0x012 },	/* 0x48b - 0x49c */
	{ 0x4a0,	0x009 },	/* 0x4a0 - 0x4a8 */
	{ 0x500,	0x003 },	/* 0x500 - 0x502 */
	{ 0x510,	0x009 },	/* 0x510 - 0x518 */
	{ 0x520,	0x003 },	/* 0x520 - 0x522 */
	{ 0x530,	0x006 },	/* 0x530 - 0x535 */
	{ 0x540,	0x00f },	/* 0x540 - 0x54e */
	{ 0x550,	0x002 },	/* 0x550 - 0x551 */
	{ 0x800,	0x002 },	/* 0x800 - 0x801 */
	{ 0x803,	0x004 },	/* 0x803 - 0x806 */
	{ 0x808,	0x002 },	/* 0x808 - 0x809 */
	{ 0x810,	0x003 },	/* 0x810 - 0x812 */
	{ 0x820,	0x003 },	/* 0x820 - 0x822 */
	{ 0x824,	0x003 },	/* 0x824 - 0x826 */
	{ 0x828,	0x001 },	/* 0x828 - 0x828 */
	{ 0x830,	0x00c },	/* 0x830 - 0x83b */
	{ 0x840,	0x00d },	/* 0x840 - 0x84c */
	{ 0x860,	0x00d },	/* 0x860 - 0x86c */
	{ 0x880,	0x00d },	/* 0x880 - 0x88c */
	{ 0x900,	0x006 },	/* 0x900 - 0x905 */
	{ 0x908,	0x001 },	/* 0x908 - 0x908 */
	{ 0x910,	0x003 },	/* 0x910 - 0x912 */
	{ 0x914,	0x003 },	/* 0x914 - 0x916 */
	{ 0x918,	0x003 },	/* 0x918 - 0x91a */
	{ 0x94f,	0x004 },	/* 0x94f - 0x952 */
	{ 0x955,	0x007 },	/* 0x955 - 0x95b */
	{ 0x960,	0x003 },	/* 0x960 - 0x962 */
	{ 0x964,	0x008 },	/* 0x964 - 0x96b */
	{ 0x970,	0x003 },	/* 0x970 - 0x972 */
	{ 0x980,	0x016 },	/* 0x980 - 0x995 */
	{ 0x9a0,	0x005 },	/* 0x9a0 - 0x9a4 */
	{ 0,	0 }
};

#if ACCONF != 0

static phy_regs_t acphy9_regs[] = {
	{ 0xc18,	0x001 },	/* 0xc18 - 0xc18 */
	{ 0xc15,	0x001 },	/* 0xc15 - 0xc15 */
	{ 0xc14,	0x001 },	/* 0xc14 - 0xc14 */
	{ 0xc16,	0x001 },	/* 0xc16 - 0xc16 */
	{ 0x1f8,	0x001 },	/* 0x1f8 - 0x1f8 */
	{ 0x5b0,	0x001 },	/* 0x5b0 - 0x5b0 */
	{ 0x5af,	0x001 },	/* 0x5af - 0x5af */
	{ 0x5b1,	0x001 },	/* 0x5b1 - 0x5b1 */
	{ 0x7aa,	0x001 },	/* 0x7aa - 0x7aa */
	{ 0x9aa,	0x001 },	/* 0x9aa - 0x9aa */
	{ 0xbaa,	0x001 },	/* 0xbaa - 0xbaa */
	{ 0x7f9,	0x001 },	/* 0x7f9 - 0x7f9 */
	{ 0x9f9,	0x001 },	/* 0x9f9 - 0x9f9 */
	{ 0xbf9,	0x001 },	/* 0xbf9 - 0xbf9 */
	{ 0x7a9,	0x001 },	/* 0x7a9 - 0x7a9 */
	{ 0x9a9,	0x001 },	/* 0x9a9 - 0x9a9 */
	{ 0xba9,	0x001 },	/* 0xba9 - 0xba9 */
	{ 0x7a8,	0x001 },	/* 0x7a8 - 0x7a8 */
	{ 0x9a8,	0x001 },	/* 0x9a8 - 0x9a8 */
	{ 0xba8,	0x001 },	/* 0xba8 - 0xba8 */
	{ 0x5a1,	0x001 },	/* 0x5a1 - 0x5a1 */
	{ 0x5a0,	0x001 },	/* 0x5a0 - 0x5a0 */
	{ 0x5c1,	0x001 },	/* 0x5c1 - 0x5c1 */
	{ 0x5a6,	0x001 },	/* 0x5a6 - 0x5a6 */
	{ 0x5c8,	0x001 },	/* 0x5c8 - 0x5c8 */
	{ 0x5a7,	0x001 },	/* 0x5a7 - 0x5a7 */
	{ 0x5c9,	0x001 },	/* 0x5c9 - 0x5c9 */
	{ 0x5a4,	0x001 },	/* 0x5a4 - 0x5a4 */
	{ 0x5c6,	0x001 },	/* 0x5c6 - 0x5c6 */
	{ 0x5a5,	0x001 },	/* 0x5a5 - 0x5a5 */
	{ 0x5c7,	0x001 },	/* 0x5c7 - 0x5c7 */
	{ 0x5aa,	0x001 },	/* 0x5aa - 0x5aa */
	{ 0x5a9,	0x001 },	/* 0x5a9 - 0x5a9 */
	{ 0x5a8,	0x001 },	/* 0x5a8 - 0x5a8 */
	{ 0x5c5,	0x001 },	/* 0x5c5 - 0x5c5 */
	{ 0x5ae,	0x001 },	/* 0x5ae - 0x5ae */
	{ 0x7a3,	0x001 },	/* 0x7a3 - 0x7a3 */
	{ 0x9a3,	0x001 },	/* 0x9a3 - 0x9a3 */
	{ 0xba3,	0x001 },	/* 0xba3 - 0xba3 */
	{ 0x7a1,	0x001 },	/* 0x7a1 - 0x7a1 */
	{ 0x9a1,	0x001 },	/* 0x9a1 - 0x9a1 */
	{ 0xba1,	0x001 },	/* 0xba1 - 0xba1 */
	{ 0x7a7,	0x001 },	/* 0x7a7 - 0x7a7 */
	{ 0x7a6,	0x001 },	/* 0x7a6 - 0x7a6 */
	{ 0x9a7,	0x001 },	/* 0x9a7 - 0x9a7 */
	{ 0x9a6,	0x001 },	/* 0x9a6 - 0x9a6 */
	{ 0xba7,	0x001 },	/* 0xba7 - 0xba7 */
	{ 0xba6,	0x001 },	/* 0xba6 - 0xba6 */
	{ 0x7f6,	0x001 },	/* 0x7f6 - 0x7f6 */
	{ 0x9f6,	0x001 },	/* 0x9f6 - 0x9f6 */
	{ 0xbf6,	0x001 },	/* 0xbf6 - 0xbf6 */
	{ 0x7f5,	0x001 },	/* 0x7f5 - 0x7f5 */
	{ 0x9f5,	0x001 },	/* 0x9f5 - 0x9f5 */
	{ 0xbf5,	0x001 },	/* 0xbf5 - 0xbf5 */
	{ 0x7f8,	0x001 },	/* 0x7f8 - 0x7f8 */
	{ 0x7f7,	0x001 },	/* 0x7f7 - 0x7f7 */
	{ 0x9f8,	0x001 },	/* 0x9f8 - 0x9f8 */
	{ 0x9f7,	0x001 },	/* 0x9f7 - 0x9f7 */
	{ 0xbf8,	0x001 },	/* 0xbf8 - 0xbf8 */
	{ 0xbf7,	0x001 },	/* 0xbf7 - 0xbf7 */
	{ 0x7ad,	0x001 },	/* 0x7ad - 0x7ad */
	{ 0x9ad,	0x001 },	/* 0x9ad - 0x9ad */
	{ 0xbad,	0x001 },	/* 0xbad - 0xbad */
	{ 0x7a2,	0x001 },	/* 0x7a2 - 0x7a2 */
	{ 0x9a2,	0x001 },	/* 0x9a2 - 0x9a2 */
	{ 0xba2,	0x001 },	/* 0xba2 - 0xba2 */
	{ 0x7a0,	0x001 },	/* 0x7a0 - 0x7a0 */
	{ 0x9a0,	0x001 },	/* 0x9a0 - 0x9a0 */
	{ 0xba0,	0x001 },	/* 0xba0 - 0xba0 */
	{ 0x7a5,	0x001 },	/* 0x7a5 - 0x7a5 */
	{ 0x7a4,	0x001 },	/* 0x7a4 - 0x7a4 */
	{ 0x9a5,	0x001 },	/* 0x9a5 - 0x9a5 */
	{ 0x9a4,	0x001 },	/* 0x9a4 - 0x9a4 */
	{ 0xba5,	0x001 },	/* 0xba5 - 0xba5 */
	{ 0xba4,	0x001 },	/* 0xba4 - 0xba4 */
	{ 0x7ac,	0x001 },	/* 0x7ac - 0x7ac */
	{ 0x9ac,	0x001 },	/* 0x9ac - 0x9ac */
	{ 0xbac,	0x001 },	/* 0xbac - 0xbac */
	{ 0x7fa,	0x001 },	/* 0x7fa - 0x7fa */
	{ 0x9fa,	0x001 },	/* 0x9fa - 0x9fa */
	{ 0xbfa,	0x001 },	/* 0xbfa - 0xbfa */
	{ 0x7ab,	0x001 },	/* 0x7ab - 0x7ab */
	{ 0x9ab,	0x001 },	/* 0x9ab - 0x9ab */
	{ 0xbab,	0x001 },	/* 0xbab - 0xbab */
	{ 0x5a2,	0x002 },	/* 0x5a2 - 0x5a3 */
	{ 0xd22,	0x001 },	/* 0xd22 - 0xd22 */
	{ 0x5b3,	0x001 },	/* 0x5b3 - 0x5b3 */
	{ 0x1fa,	0x001 },	/* 0x1fa - 0x1fa */
	{ 0x1fe,	0x001 },	/* 0x1fe - 0x1fe */
	{ 0x5ab,	0x001 },	/* 0x5ab - 0x5ab */
	{ 0xd20,	0x001 },	/* 0xd20 - 0xd20 */
	{ 0x5ca,	0x001 },	/* 0x5ca - 0x5ca */
	{ 0x1f9,	0x001 },	/* 0x1f9 - 0x1f9 */
	{ 0x1fd,	0x001 },	/* 0x1fd - 0x1fd */
	{ 0x5c2,	0x003 },	/* 0x5c2 - 0x5c4 */
	{ 0x5b2,	0x001 },	/* 0x5b2 - 0x5b2 */
	{ 0x5ad,	0x001 },	/* 0x5ad - 0x5ad */
	{ 0x5ac,	0x001 },	/* 0x5ac - 0x5ac */
	{ 0x200,	0x003 },	/* 0x200 - 0x202 */
	{ 0x165,	0x003 },	/* 0x165 - 0x167 */
	{ 0x52a,	0x001 },	/* 0x52a - 0x52a */
	{ 0x467,	0x001 },	/* 0x467 - 0x467 */
	{ 0x596,	0x001 },	/* 0x596 - 0x596 */
	{ 0x598,	0x001 },	/* 0x598 - 0x598 */
	{ 0x595,	0x001 },	/* 0x595 - 0x595 */
	{ 0x594,	0x001 },	/* 0x594 - 0x594 */
	{ 0x592,	0x002 },	/* 0x592 - 0x593 */
	{ 0x410,	0x001 },	/* 0x410 - 0x410 */
	{ 0x749,	0x001 },	/* 0x749 - 0x749 */
	{ 0x949,	0x001 },	/* 0x949 - 0x949 */
	{ 0xb49,	0x001 },	/* 0xb49 - 0xb49 */
	{ 0x751,	0x001 },	/* 0x751 - 0x751 */
	{ 0x951,	0x001 },	/* 0x951 - 0x951 */
	{ 0xb51,	0x001 },	/* 0xb51 - 0xb51 */
	{ 0x752,	0x001 },	/* 0x752 - 0x752 */
	{ 0x952,	0x001 },	/* 0x952 - 0x952 */
	{ 0xb52,	0x001 },	/* 0xb52 - 0xb52 */
	{ 0x753,	0x001 },	/* 0x753 - 0x753 */
	{ 0x953,	0x001 },	/* 0x953 - 0x953 */
	{ 0xb53,	0x001 },	/* 0xb53 - 0xb53 */
	{ 0x750,	0x001 },	/* 0x750 - 0x750 */
	{ 0x950,	0x001 },	/* 0x950 - 0x950 */
	{ 0xb50,	0x001 },	/* 0xb50 - 0xb50 */
	{ 0x40f,	0x001 },	/* 0x40f - 0x40f */
	{ 0x42d,	0x001 },	/* 0x42d - 0x42d */
	{ 0x42c,	0x001 },	/* 0x42c - 0x42c */
	{ 0x42b,	0x001 },	/* 0x42b - 0x42b */
	{ 0x42a,	0x001 },	/* 0x42a - 0x42a */
	{ 0x429,	0x001 },	/* 0x429 - 0x429 */
	{ 0x424,	0x001 },	/* 0x424 - 0x424 */
	{ 0x422,	0x001 },	/* 0x422 - 0x422 */
	{ 0x420,	0x001 },	/* 0x420 - 0x420 */
	{ 0x426,	0x001 },	/* 0x426 - 0x426 */
	{ 0x425,	0x001 },	/* 0x425 - 0x425 */
	{ 0x423,	0x001 },	/* 0x423 - 0x423 */
	{ 0x421,	0x001 },	/* 0x421 - 0x421 */
	{ 0x3b3,	0x001 },	/* 0x3b3 - 0x3b3 */
	{ 0x3d4,	0x001 },	/* 0x3d4 - 0x3d4 */
	{ 0x407,	0x001 },	/* 0x407 - 0x407 */
	{ 0x251,	0x001 },	/* 0x251 - 0x251 */
	{ 0x253,	0x001 },	/* 0x253 - 0x253 */
	{ 0x252,	0x001 },	/* 0x252 - 0x252 */
	{ 0x254,	0x001 },	/* 0x254 - 0x254 */
	{ 0x162,	0x001 },	/* 0x162 - 0x162 */
	{ 0xc40,	0x001 },	/* 0xc40 - 0xc40 */
	{ 0x161,	0x001 },	/* 0x161 - 0x161 */
	{ 0xc41,	0x001 },	/* 0xc41 - 0xc41 */
	{ 0x406,	0x001 },	/* 0x406 - 0x406 */
	{ 0x47a,	0x001 },	/* 0x47a - 0x47a */
	{ 0x478,	0x002 },	/* 0x478 - 0x479 */
	{ 0x47d,	0x001 },	/* 0x47d - 0x47d */
	{ 0x47b,	0x002 },	/* 0x47b - 0x47c */
	{ 0x691,	0x001 },	/* 0x691 - 0x691 */
	{ 0x891,	0x001 },	/* 0x891 - 0x891 */
	{ 0xa91,	0x001 },	/* 0xa91 - 0xa91 */
	{ 0x454,	0x006 },	/* 0x454 - 0x459 */
	{ 0x442,	0x002 },	/* 0x442 - 0x443 */
	{ 0x44a,	0x00a },	/* 0x44a - 0x453 */
	{ 0x446,	0x001 },	/* 0x446 - 0x446 */
	{ 0x445,	0x001 },	/* 0x445 - 0x445 */
	{ 0x444,	0x001 },	/* 0x444 - 0x444 */
	{ 0x447,	0x003 },	/* 0x447 - 0x449 */
	{ 0x45a,	0x001 },	/* 0x45a - 0x45a */
	{ 0x050,	0x001 },	/* 0x050 - 0x050 */
	{ 0x430,	0x004 },	/* 0x430 - 0x433 */
	{ 0x023,	0x001 },	/* 0x023 - 0x023 */
	{ 0x45b,	0x005 },	/* 0x45b - 0x45f */
	{ 0x434,	0x005 },	/* 0x434 - 0x438 */
	{ 0x3e6,	0x001 },	/* 0x3e6 - 0x3e6 */
	{ 0x363,	0x001 },	/* 0x363 - 0x363 */
	{ 0x1fb,	0x001 },	/* 0x1fb - 0x1fb */
	{ 0x15e,	0x001 },	/* 0x15e - 0x15e */
	{ 0x351,	0x003 },	/* 0x351 - 0x353 */
	{ 0x34d,	0x004 },	/* 0x34d - 0x350 */
	{ 0x3a1,	0x001 },	/* 0x3a1 - 0x3a1 */
	{ 0x3a8,	0x001 },	/* 0x3a8 - 0x3a8 */
	{ 0x390,	0x002 },	/* 0x390 - 0x391 */
	{ 0x397,	0x002 },	/* 0x397 - 0x398 */
	{ 0x396,	0x001 },	/* 0x396 - 0x396 */
	{ 0x399,	0x002 },	/* 0x399 - 0x39a */
	{ 0x293,	0x003 },	/* 0x293 - 0x295 */
	{ 0x3a6,	0x001 },	/* 0x3a6 - 0x3a6 */
	{ 0x174,	0x001 },	/* 0x174 - 0x174 */
	{ 0x35b,	0x008 },	/* 0x35b - 0x362 */
	{ 0x3a2,	0x004 },	/* 0x3a2 - 0x3a5 */
	{ 0x3a9,	0x001 },	/* 0x3a9 - 0x3a9 */
	{ 0x46a,	0x001 },	/* 0x46a - 0x46a */
	{ 0x3a7,	0x001 },	/* 0x3a7 - 0x3a7 */
	{ 0x3f0,	0x001 },	/* 0x3f0 - 0x3f0 */
	{ 0x29b,	0x001 },	/* 0x29b - 0x29b */
	{ 0x418,	0x001 },	/* 0x418 - 0x418 */
	{ 0x40a,	0x001 },	/* 0x40a - 0x40a */
	{ 0xc01,	0x003 },	/* 0xc01 - 0xc03 */
	{ 0x371,	0x006 },	/* 0x371 - 0x376 */
	{ 0x04f,	0x001 },	/* 0x04f - 0x04f */
	{ 0x795,	0x001 },	/* 0x795 - 0x795 */
	{ 0x995,	0x001 },	/* 0x995 - 0x995 */
	{ 0xb95,	0x001 },	/* 0xb95 - 0xb95 */
	{ 0x794,	0x001 },	/* 0x794 - 0x794 */
	{ 0x994,	0x001 },	/* 0x994 - 0x994 */
	{ 0xb94,	0x001 },	/* 0xb94 - 0xb94 */
	{ 0x1ea,	0x001 },	/* 0x1ea - 0x1ea */
	{ 0x496,	0x001 },	/* 0x496 - 0x496 */
	{ 0x10c,	0x001 },	/* 0x10c - 0x10c */
	{ 0x3d1,	0x002 },	/* 0x3d1 - 0x3d2 */
	{ 0x3d6,	0x001 },	/* 0x3d6 - 0x3d6 */
	{ 0x170,	0x001 },	/* 0x170 - 0x170 */
	{ 0x296,	0x001 },	/* 0x296 - 0x296 */
	{ 0x3d8,	0x002 },	/* 0x3d8 - 0x3d9 */
	{ 0x2d0,	0x001 },	/* 0x2d0 - 0x2d0 */
	{ 0x003,	0x002 },	/* 0x003 - 0x004 */
	{ 0x2d3,	0x002 },	/* 0x2d3 - 0x2d4 */
	{ 0xc30,	0x00c },	/* 0xc30 - 0xc3b */
	{ 0x140,	0x001 },	/* 0x140 - 0x140 */
	{ 0x30f,	0x005 },	/* 0x30f - 0x313 */
	{ 0x1e2,	0x001 },	/* 0x1e2 - 0x1e2 */
	{ 0x1e4,	0x001 },	/* 0x1e4 - 0x1e4 */
	{ 0x1e3,	0x001 },	/* 0x1e3 - 0x1e3 */
	{ 0x1e5,	0x001 },	/* 0x1e5 - 0x1e5 */
	{ 0x29e,	0x001 },	/* 0x29e - 0x29e */
	{ 0x2e7,	0x002 },	/* 0x2e7 - 0x2e8 */
	{ 0x6f8,	0x001 },	/* 0x6f8 - 0x6f8 */
	{ 0x6fd,	0x001 },	/* 0x6fd - 0x6fd */
	{ 0x6fb,	0x002 },	/* 0x6fb - 0x6fc */
	{ 0x6e9,	0x001 },	/* 0x6e9 - 0x6e9 */
	{ 0x6f9,	0x001 },	/* 0x6f9 - 0x6f9 */
	{ 0x6ed,	0x001 },	/* 0x6ed - 0x6ed */
	{ 0x6d2,	0x001 },	/* 0x6d2 - 0x6d2 */
	{ 0x6d5,	0x001 },	/* 0x6d5 - 0x6d5 */
	{ 0x6da,	0x002 },	/* 0x6da - 0x6db */
	{ 0x6e3,	0x001 },	/* 0x6e3 - 0x6e3 */
	{ 0x6d4,	0x001 },	/* 0x6d4 - 0x6d4 */
	{ 0x6d8,	0x001 },	/* 0x6d8 - 0x6d8 */
	{ 0x6ef,	0x001 },	/* 0x6ef - 0x6ef */
	{ 0x6e7,	0x001 },	/* 0x6e7 - 0x6e7 */
	{ 0x6eb,	0x002 },	/* 0x6eb - 0x6ec */
	{ 0x6d9,	0x001 },	/* 0x6d9 - 0x6d9 */
	{ 0x6f2,	0x001 },	/* 0x6f2 - 0x6f2 */
	{ 0x6f0,	0x002 },	/* 0x6f0 - 0x6f1 */
	{ 0x6f4,	0x001 },	/* 0x6f4 - 0x6f4 */
	{ 0x8f8,	0x001 },	/* 0x8f8 - 0x8f8 */
	{ 0x8fd,	0x001 },	/* 0x8fd - 0x8fd */
	{ 0x8fb,	0x002 },	/* 0x8fb - 0x8fc */
	{ 0x8e9,	0x001 },	/* 0x8e9 - 0x8e9 */
	{ 0x8f9,	0x001 },	/* 0x8f9 - 0x8f9 */
	{ 0x8ed,	0x001 },	/* 0x8ed - 0x8ed */
	{ 0x8d2,	0x001 },	/* 0x8d2 - 0x8d2 */
	{ 0x6a2,	0x002 },	/* 0x6a2 - 0x6a3 */
	{ 0x8d5,	0x001 },	/* 0x8d5 - 0x8d5 */
	{ 0x8da,	0x002 },	/* 0x8da - 0x8db */
	{ 0x8e3,	0x001 },	/* 0x8e3 - 0x8e3 */
	{ 0x8d4,	0x001 },	/* 0x8d4 - 0x8d4 */
	{ 0x8d8,	0x001 },	/* 0x8d8 - 0x8d8 */
	{ 0x8ef,	0x001 },	/* 0x8ef - 0x8ef */
	{ 0x8e7,	0x001 },	/* 0x8e7 - 0x8e7 */
	{ 0x8eb,	0x002 },	/* 0x8eb - 0x8ec */
	{ 0x6a0,	0x002 },	/* 0x6a0 - 0x6a1 */
	{ 0x8d9,	0x001 },	/* 0x8d9 - 0x8d9 */
	{ 0x8f2,	0x001 },	/* 0x8f2 - 0x8f2 */
	{ 0x8f0,	0x002 },	/* 0x8f0 - 0x8f1 */
	{ 0x8f4,	0x001 },	/* 0x8f4 - 0x8f4 */
	{ 0x600,	0x001 },	/* 0x600 - 0x600 */
	{ 0xaf8,	0x001 },	/* 0xaf8 - 0xaf8 */
	{ 0xafd,	0x001 },	/* 0xafd - 0xafd */
	{ 0xafb,	0x002 },	/* 0xafb - 0xafc */
	{ 0xae9,	0x001 },	/* 0xae9 - 0xae9 */
	{ 0xaf9,	0x001 },	/* 0xaf9 - 0xaf9 */
	{ 0xaed,	0x001 },	/* 0xaed - 0xaed */
	{ 0xad2,	0x001 },	/* 0xad2 - 0xad2 */
	{ 0x8a2,	0x002 },	/* 0x8a2 - 0x8a3 */
	{ 0xad5,	0x001 },	/* 0xad5 - 0xad5 */
	{ 0xada,	0x002 },	/* 0xada - 0xadb */
	{ 0xae3,	0x001 },	/* 0xae3 - 0xae3 */
	{ 0xad4,	0x001 },	/* 0xad4 - 0xad4 */
	{ 0xad8,	0x001 },	/* 0xad8 - 0xad8 */
	{ 0xaef,	0x001 },	/* 0xaef - 0xaef */
	{ 0xae7,	0x001 },	/* 0xae7 - 0xae7 */
	{ 0xaeb,	0x002 },	/* 0xaeb - 0xaec */
	{ 0x8a0,	0x002 },	/* 0x8a0 - 0x8a1 */
	{ 0xad9,	0x001 },	/* 0xad9 - 0xad9 */
	{ 0xaf2,	0x001 },	/* 0xaf2 - 0xaf2 */
	{ 0xaf0,	0x002 },	/* 0xaf0 - 0xaf1 */
	{ 0xaf4,	0x001 },	/* 0xaf4 - 0xaf4 */
	{ 0x800,	0x001 },	/* 0x800 - 0x800 */
	{ 0xaa2,	0x002 },	/* 0xaa2 - 0xaa3 */
	{ 0xaa0,	0x002 },	/* 0xaa0 - 0xaa1 */
	{ 0xa00,	0x001 },	/* 0xa00 - 0xa00 */
	{ 0x28a,	0x002 },	/* 0x28a - 0x28b */
	{ 0x160,	0x001 },	/* 0x160 - 0x160 */
	{ 0x31c,	0x001 },	/* 0x31c - 0x31c */
	{ 0x31e,	0x001 },	/* 0x31e - 0x31e */
	{ 0x31d,	0x001 },	/* 0x31d - 0x31d */
	{ 0x31f,	0x001 },	/* 0x31f - 0x31f */
	{ 0x2f1,	0x001 },	/* 0x2f1 - 0x2f1 */
	{ 0x2f9,	0x001 },	/* 0x2f9 - 0x2f9 */
	{ 0x2ed,	0x001 },	/* 0x2ed - 0x2ed */
	{ 0x2f5,	0x001 },	/* 0x2f5 - 0x2f5 */
	{ 0x3cc,	0x001 },	/* 0x3cc - 0x3cc */
	{ 0x304,	0x001 },	/* 0x304 - 0x304 */
	{ 0x30a,	0x001 },	/* 0x30a - 0x30a */
	{ 0x307,	0x001 },	/* 0x307 - 0x307 */
	{ 0x30d,	0x001 },	/* 0x30d - 0x30d */
	{ 0x302,	0x001 },	/* 0x302 - 0x302 */
	{ 0x308,	0x001 },	/* 0x308 - 0x308 */
	{ 0x305,	0x001 },	/* 0x305 - 0x305 */
	{ 0x30b,	0x001 },	/* 0x30b - 0x30b */
	{ 0x303,	0x001 },	/* 0x303 - 0x303 */
	{ 0x309,	0x001 },	/* 0x309 - 0x309 */
	{ 0x306,	0x001 },	/* 0x306 - 0x306 */
	{ 0x30c,	0x001 },	/* 0x30c - 0x30c */
	{ 0x355,	0x001 },	/* 0x355 - 0x355 */
	{ 0x354,	0x001 },	/* 0x354 - 0x354 */
	{ 0x357,	0x001 },	/* 0x357 - 0x357 */
	{ 0x356,	0x001 },	/* 0x356 - 0x356 */
	{ 0x32d,	0x003 },	/* 0x32d - 0x32f */
	{ 0x333,	0x003 },	/* 0x333 - 0x335 */
	{ 0x712,	0x001 },	/* 0x712 - 0x712 */
	{ 0x912,	0x001 },	/* 0x912 - 0x912 */
	{ 0xb12,	0x001 },	/* 0xb12 - 0xb12 */
	{ 0x713,	0x001 },	/* 0x713 - 0x713 */
	{ 0x913,	0x001 },	/* 0x913 - 0x913 */
	{ 0xb13,	0x001 },	/* 0xb13 - 0xb13 */
	{ 0x330,	0x003 },	/* 0x330 - 0x332 */
	{ 0x336,	0x003 },	/* 0x336 - 0x338 */
	{ 0x321,	0x003 },	/* 0x321 - 0x323 */
	{ 0x327,	0x003 },	/* 0x327 - 0x329 */
	{ 0x710,	0x001 },	/* 0x710 - 0x710 */
	{ 0x910,	0x001 },	/* 0x910 - 0x910 */
	{ 0xb10,	0x001 },	/* 0xb10 - 0xb10 */
	{ 0x711,	0x001 },	/* 0x711 - 0x711 */
	{ 0x911,	0x001 },	/* 0x911 - 0x911 */
	{ 0xb11,	0x001 },	/* 0xb11 - 0xb11 */
	{ 0x324,	0x003 },	/* 0x324 - 0x326 */
	{ 0x32a,	0x003 },	/* 0x32a - 0x32c */
	{ 0x176,	0x001 },	/* 0x176 - 0x176 */
	{ 0x2ee,	0x001 },	/* 0x2ee - 0x2ee */
	{ 0x2f6,	0x001 },	/* 0x2f6 - 0x2f6 */
	{ 0x2ea,	0x001 },	/* 0x2ea - 0x2ea */
	{ 0x2f2,	0x001 },	/* 0x2f2 - 0x2f2 */
	{ 0x2ef,	0x001 },	/* 0x2ef - 0x2ef */
	{ 0x2f7,	0x001 },	/* 0x2f7 - 0x2f7 */
	{ 0x2eb,	0x001 },	/* 0x2eb - 0x2eb */
	{ 0x2f3,	0x001 },	/* 0x2f3 - 0x2f3 */
	{ 0x2f0,	0x001 },	/* 0x2f0 - 0x2f0 */
	{ 0x2f8,	0x001 },	/* 0x2f8 - 0x2f8 */
	{ 0x2ec,	0x001 },	/* 0x2ec - 0x2ec */
	{ 0x2f4,	0x001 },	/* 0x2f4 - 0x2f4 */
	{ 0x2c3,	0x003 },	/* 0x2c3 - 0x2c5 */
	{ 0x2c1,	0x002 },	/* 0x2c1 - 0x2c2 */
	{ 0x046,	0x003 },	/* 0x046 - 0x048 */
	{ 0x747,	0x001 },	/* 0x747 - 0x747 */
	{ 0x947,	0x001 },	/* 0x947 - 0x947 */
	{ 0xb47,	0x001 },	/* 0xb47 - 0xb47 */
	{ 0xd00,	0x003 },	/* 0xd00 - 0xd02 */
	{ 0x17e,	0x001 },	/* 0x17e - 0x17e */
	{ 0x180,	0x001 },	/* 0x180 - 0x180 */
	{ 0x597,	0x001 },	/* 0x597 - 0x597 */
	{ 0x590,	0x001 },	/* 0x590 - 0x590 */
	{ 0x198,	0x001 },	/* 0x198 - 0x198 */
	{ 0x1de,	0x001 },	/* 0x1de - 0x1de */
	{ 0x1d7,	0x001 },	/* 0x1d7 - 0x1d7 */
	{ 0x3d7,	0x001 },	/* 0x3d7 - 0x3d7 */
	{ 0x299,	0x001 },	/* 0x299 - 0x299 */
	{ 0x3f1,	0x001 },	/* 0x3f1 - 0x3f1 */
	{ 0xc45,	0x001 },	/* 0xc45 - 0xc45 */
	{ 0xc42,	0x001 },	/* 0xc42 - 0xc42 */
	{ 0xc44,	0x001 },	/* 0xc44 - 0xc44 */
	{ 0xc43,	0x001 },	/* 0xc43 - 0xc43 */
	{ 0x1b6,	0x001 },	/* 0x1b6 - 0x1b6 */
	{ 0x1f5,	0x001 },	/* 0x1f5 - 0x1f5 */
	{ 0x1f2,	0x001 },	/* 0x1f2 - 0x1f2 */
	{ 0x358,	0x003 },	/* 0x358 - 0x35a */
	{ 0x1fc,	0x001 },	/* 0x1fc - 0x1fc */
	{ 0x5c0,	0x001 },	/* 0x5c0 - 0x5c0 */
	{ 0x7b0,	0x001 },	/* 0x7b0 - 0x7b0 */
	{ 0x9b0,	0x001 },	/* 0x9b0 - 0x9b0 */
	{ 0xbb0,	0x001 },	/* 0xbb0 - 0xbb0 */
	{ 0x7b5,	0x001 },	/* 0x7b5 - 0x7b5 */
	{ 0x9b5,	0x001 },	/* 0x9b5 - 0x9b5 */
	{ 0xbb5,	0x001 },	/* 0xbb5 - 0xbb5 */
	{ 0x7b6,	0x001 },	/* 0x7b6 - 0x7b6 */
	{ 0x9b6,	0x001 },	/* 0x9b6 - 0x9b6 */
	{ 0xbb6,	0x001 },	/* 0xbb6 - 0xbb6 */
	{ 0x7b1,	0x001 },	/* 0x7b1 - 0x7b1 */
	{ 0x9b1,	0x001 },	/* 0x9b1 - 0x9b1 */
	{ 0xbb1,	0x001 },	/* 0xbb1 - 0xbb1 */
	{ 0x7b2,	0x001 },	/* 0x7b2 - 0x7b2 */
	{ 0x9b2,	0x001 },	/* 0x9b2 - 0x9b2 */
	{ 0xbb2,	0x001 },	/* 0xbb2 - 0xbb2 */
	{ 0x7b9,	0x001 },	/* 0x7b9 - 0x7b9 */
	{ 0x9b9,	0x001 },	/* 0x9b9 - 0x9b9 */
	{ 0xbb9,	0x001 },	/* 0xbb9 - 0xbb9 */
	{ 0x7bc,	0x001 },	/* 0x7bc - 0x7bc */
	{ 0x9bc,	0x001 },	/* 0x9bc - 0x9bc */
	{ 0xbbc,	0x001 },	/* 0xbbc - 0xbbc */
	{ 0x7bf,	0x001 },	/* 0x7bf - 0x7bf */
	{ 0x9bf,	0x001 },	/* 0x9bf - 0x9bf */
	{ 0xbbf,	0x001 },	/* 0xbbf - 0xbbf */
	{ 0x7ba,	0x001 },	/* 0x7ba - 0x7ba */
	{ 0x9ba,	0x001 },	/* 0x9ba - 0x9ba */
	{ 0xbba,	0x001 },	/* 0xbba - 0xbba */
	{ 0x7bd,	0x001 },	/* 0x7bd - 0x7bd */
	{ 0x9bd,	0x001 },	/* 0x9bd - 0x9bd */
	{ 0xbbd,	0x001 },	/* 0xbbd - 0xbbd */
	{ 0x7bb,	0x001 },	/* 0x7bb - 0x7bb */
	{ 0x9bb,	0x001 },	/* 0x9bb - 0x9bb */
	{ 0xbbb,	0x001 },	/* 0xbbb - 0xbbb */
	{ 0x7be,	0x001 },	/* 0x7be - 0x7be */
	{ 0x9be,	0x001 },	/* 0x9be - 0x9be */
	{ 0xbbe,	0x001 },	/* 0xbbe - 0xbbe */
	{ 0x1f3,	0x001 },	/* 0x1f3 - 0x1f3 */
	{ 0x1e8,	0x001 },	/* 0x1e8 - 0x1e8 */
	{ 0x3cf,	0x002 },	/* 0x3cf - 0x3d0 */
	{ 0x3c6,	0x001 },	/* 0x3c6 - 0x3c6 */
	{ 0x3c4,	0x002 },	/* 0x3c4 - 0x3c5 */
	{ 0x044,	0x001 },	/* 0x044 - 0x044 */
	{ 0x4d6,	0x001 },	/* 0x4d6 - 0x4d6 */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x33a,	0x004 },	/* 0x33a - 0x33d */
	{ 0x342,	0x004 },	/* 0x342 - 0x345 */
	{ 0x33e,	0x004 },	/* 0x33e - 0x341 */
	{ 0x346,	0x004 },	/* 0x346 - 0x349 */
	{ 0x339,	0x001 },	/* 0x339 - 0x339 */
	{ 0x1ee,	0x001 },	/* 0x1ee - 0x1ee */
	{ 0x1ec,	0x001 },	/* 0x1ec - 0x1ec */
	{ 0x163,	0x001 },	/* 0x163 - 0x163 */
	{ 0x67a,	0x001 },	/* 0x67a - 0x67a */
	{ 0x87a,	0x001 },	/* 0x87a - 0x87a */
	{ 0xa7a,	0x001 },	/* 0xa7a - 0xa7a */
	{ 0x67b,	0x001 },	/* 0x67b - 0x67b */
	{ 0x87b,	0x001 },	/* 0x87b - 0x87b */
	{ 0xa7b,	0x001 },	/* 0xa7b - 0xa7b */
	{ 0x679,	0x001 },	/* 0x679 - 0x679 */
	{ 0x879,	0x001 },	/* 0x879 - 0x879 */
	{ 0xa79,	0x001 },	/* 0xa79 - 0xa79 */
	{ 0x642,	0x001 },	/* 0x642 - 0x642 */
	{ 0x842,	0x001 },	/* 0x842 - 0x842 */
	{ 0xa42,	0x001 },	/* 0xa42 - 0xa42 */
	{ 0x500,	0x001 },	/* 0x500 - 0x500 */
	{ 0x502,	0x001 },	/* 0x502 - 0x502 */
	{ 0x510,	0x001 },	/* 0x510 - 0x510 */
	{ 0x501,	0x001 },	/* 0x501 - 0x501 */
	{ 0x240,	0x002 },	/* 0x240 - 0x241 */
	{ 0x24a,	0x001 },	/* 0x24a - 0x24a */
	{ 0x242,	0x008 },	/* 0x242 - 0x249 */
	{ 0x234,	0x004 },	/* 0x234 - 0x237 */
	{ 0x230,	0x004 },	/* 0x230 - 0x233 */
	{ 0x212,	0x001 },	/* 0x212 - 0x212 */
	{ 0x219,	0x001 },	/* 0x219 - 0x219 */
	{ 0x218,	0x001 },	/* 0x218 - 0x218 */
	{ 0x238,	0x002 },	/* 0x238 - 0x239 */
	{ 0x067,	0x001 },	/* 0x067 - 0x067 */
	{ 0x066,	0x001 },	/* 0x066 - 0x066 */
	{ 0x419,	0x001 },	/* 0x419 - 0x419 */
	{ 0x177,	0x001 },	/* 0x177 - 0x177 */
	{ 0x16b,	0x001 },	/* 0x16b - 0x16b */
	{ 0x3e0,	0x001 },	/* 0x3e0 - 0x3e0 */
	{ 0x16d,	0x001 },	/* 0x16d - 0x16d */
	{ 0x16c,	0x001 },	/* 0x16c - 0x16c */
	{ 0x169,	0x001 },	/* 0x169 - 0x169 */
	{ 0x259,	0x001 },	/* 0x259 - 0x259 */
	{ 0x690,	0x001 },	/* 0x690 - 0x690 */
	{ 0x890,	0x001 },	/* 0x890 - 0x890 */
	{ 0xa90,	0x001 },	/* 0xa90 - 0xa90 */
	{ 0x29f,	0x001 },	/* 0x29f - 0x29f */
	{ 0x280,	0x009 },	/* 0x280 - 0x288 */
	{ 0x46b,	0x001 },	/* 0x46b - 0x46b */
	{ 0x2e0,	0x001 },	/* 0x2e0 - 0x2e0 */
	{ 0x2e5,	0x001 },	/* 0x2e5 - 0x2e5 */
	{ 0x2e3,	0x001 },	/* 0x2e3 - 0x2e3 */
	{ 0x2e6,	0x001 },	/* 0x2e6 - 0x2e6 */
	{ 0x2e4,	0x001 },	/* 0x2e4 - 0x2e4 */
	{ 0x2e2,	0x001 },	/* 0x2e2 - 0x2e2 */
	{ 0x2e1,	0x001 },	/* 0x2e1 - 0x2e1 */
	{ 0x793,	0x001 },	/* 0x793 - 0x793 */
	{ 0x993,	0x001 },	/* 0x993 - 0x993 */
	{ 0xb93,	0x001 },	/* 0xb93 - 0xb93 */
	{ 0x792,	0x001 },	/* 0x792 - 0x792 */
	{ 0x992,	0x001 },	/* 0x992 - 0x992 */
	{ 0xb92,	0x001 },	/* 0xb92 - 0xb92 */
	{ 0x3e3,	0x001 },	/* 0x3e3 - 0x3e3 */
	{ 0x5d1,	0x003 },	/* 0x5d1 - 0x5d3 */
	{ 0x5d7,	0x003 },	/* 0x5d7 - 0x5d9 */
	{ 0x5d0,	0x001 },	/* 0x5d0 - 0x5d0 */
	{ 0x5d4,	0x003 },	/* 0x5d4 - 0x5d6 */
	{ 0x473,	0x001 },	/* 0x473 - 0x473 */
	{ 0x472,	0x001 },	/* 0x472 - 0x472 */
	{ 0x395,	0x001 },	/* 0x395 - 0x395 */
	{ 0x013,	0x001 },	/* 0x013 - 0x013 */
	{ 0x393,	0x001 },	/* 0x393 - 0x393 */
	{ 0x012,	0x001 },	/* 0x012 - 0x012 */
	{ 0x392,	0x001 },	/* 0x392 - 0x392 */
	{ 0x394,	0x001 },	/* 0x394 - 0x394 */
	{ 0x39c,	0x001 },	/* 0x39c - 0x39c */
	{ 0x292,	0x001 },	/* 0x292 - 0x292 */
	{ 0x195,	0x002 },	/* 0x195 - 0x196 */
	{ 0x1f6,	0x002 },	/* 0x1f6 - 0x1f7 */
	{ 0x1b0,	0x001 },	/* 0x1b0 - 0x1b0 */
	{ 0x64d,	0x001 },	/* 0x64d - 0x64d */
	{ 0x84d,	0x001 },	/* 0x84d - 0x84d */
	{ 0xa4d,	0x001 },	/* 0xa4d - 0xa4d */
	{ 0x64e,	0x001 },	/* 0x64e - 0x64e */
	{ 0x84e,	0x001 },	/* 0x84e - 0x84e */
	{ 0xa4e,	0x001 },	/* 0xa4e - 0xa4e */
	{ 0x1e1,	0x001 },	/* 0x1e1 - 0x1e1 */
	{ 0x1e7,	0x001 },	/* 0x1e7 - 0x1e7 */
	{ 0x1ae,	0x001 },	/* 0x1ae - 0x1ae */
	{ 0x270,	0x001 },	/* 0x270 - 0x270 */
	{ 0x6c3,	0x001 },	/* 0x6c3 - 0x6c3 */
	{ 0x8c3,	0x001 },	/* 0x8c3 - 0x8c3 */
	{ 0xac3,	0x001 },	/* 0xac3 - 0xac3 */
	{ 0x6c2,	0x001 },	/* 0x6c2 - 0x6c2 */
	{ 0x8c2,	0x001 },	/* 0x8c2 - 0x8c2 */
	{ 0xac2,	0x001 },	/* 0xac2 - 0xac2 */
	{ 0x6c1,	0x001 },	/* 0x6c1 - 0x6c1 */
	{ 0x8c1,	0x001 },	/* 0x8c1 - 0x8c1 */
	{ 0xac1,	0x001 },	/* 0xac1 - 0xac1 */
	{ 0x6c0,	0x001 },	/* 0x6c0 - 0x6c0 */
	{ 0x8c0,	0x001 },	/* 0x8c0 - 0x8c0 */
	{ 0xac0,	0x001 },	/* 0xac0 - 0xac0 */
	{ 0x6c5,	0x001 },	/* 0x6c5 - 0x6c5 */
	{ 0x8c5,	0x001 },	/* 0x8c5 - 0x8c5 */
	{ 0xac5,	0x001 },	/* 0xac5 - 0xac5 */
	{ 0x6c4,	0x001 },	/* 0x6c4 - 0x6c4 */
	{ 0x8c4,	0x001 },	/* 0x8c4 - 0x8c4 */
	{ 0xac4,	0x001 },	/* 0xac4 - 0xac4 */
	{ 0x272,	0x001 },	/* 0x272 - 0x272 */
	{ 0x271,	0x001 },	/* 0x271 - 0x271 */
	{ 0x380,	0x001 },	/* 0x380 - 0x380 */
	{ 0x382,	0x001 },	/* 0x382 - 0x382 */
	{ 0x381,	0x001 },	/* 0x381 - 0x381 */
	{ 0x383,	0x001 },	/* 0x383 - 0x383 */
	{ 0x3b0,	0x001 },	/* 0x3b0 - 0x3b0 */
	{ 0x3af,	0x001 },	/* 0x3af - 0x3af */
	{ 0x3b1,	0x002 },	/* 0x3b1 - 0x3b2 */
	{ 0x3b5,	0x001 },	/* 0x3b5 - 0x3b5 */
	{ 0x3e9,	0x001 },	/* 0x3e9 - 0x3e9 */
	{ 0x46c,	0x002 },	/* 0x46c - 0x46d */
	{ 0x3b9,	0x001 },	/* 0x3b9 - 0x3b9 */
	{ 0x1a0,	0x001 },	/* 0x1a0 - 0x1a0 */
	{ 0x1a2,	0x001 },	/* 0x1a2 - 0x1a2 */
	{ 0x1a1,	0x001 },	/* 0x1a1 - 0x1a1 */
	{ 0x1a3,	0x001 },	/* 0x1a3 - 0x1a3 */
	{ 0x2b3,	0x001 },	/* 0x2b3 - 0x2b3 */
	{ 0x2b1,	0x001 },	/* 0x2b1 - 0x2b1 */
	{ 0x2b0,	0x001 },	/* 0x2b0 - 0x2b0 */
	{ 0x15f,	0x001 },	/* 0x15f - 0x15f */
	{ 0x2ba,	0x001 },	/* 0x2ba - 0x2ba */
	{ 0x2b9,	0x001 },	/* 0x2b9 - 0x2b9 */
	{ 0x2b8,	0x001 },	/* 0x2b8 - 0x2b8 */
	{ 0x2b5,	0x001 },	/* 0x2b5 - 0x2b5 */
	{ 0x2b4,	0x001 },	/* 0x2b4 - 0x2b4 */
	{ 0x2b7,	0x001 },	/* 0x2b7 - 0x2b7 */
	{ 0x2b6,	0x001 },	/* 0x2b6 - 0x2b6 */
	{ 0x2b2,	0x001 },	/* 0x2b2 - 0x2b2 */
	{ 0x3e2,	0x001 },	/* 0x3e2 - 0x3e2 */
	{ 0x3ea,	0x002 },	/* 0x3ea - 0x3eb */
	{ 0x3e1,	0x001 },	/* 0x3e1 - 0x3e1 */
	{ 0x3e5,	0x001 },	/* 0x3e5 - 0x3e5 */
	{ 0x1b7,	0x001 },	/* 0x1b7 - 0x1b7 */
	{ 0x3b4,	0x001 },	/* 0x3b4 - 0x3b4 */
	{ 0x3dc,	0x002 },	/* 0x3dc - 0x3dd */
	{ 0x3e7,	0x002 },	/* 0x3e7 - 0x3e8 */
	{ 0x40c,	0x002 },	/* 0x40c - 0x40d */
	{ 0x3bb,	0x001 },	/* 0x3bb - 0x3bb */
	{ 0x3ba,	0x001 },	/* 0x3ba - 0x3ba */
	{ 0x17c,	0x002 },	/* 0x17c - 0x17d */
	{ 0x377,	0x001 },	/* 0x377 - 0x377 */
	{ 0x78f,	0x001 },	/* 0x78f - 0x78f */
	{ 0x98f,	0x001 },	/* 0x98f - 0x98f */
	{ 0xb8f,	0x001 },	/* 0xb8f - 0xb8f */
	{ 0x78e,	0x001 },	/* 0x78e - 0x78e */
	{ 0x98e,	0x001 },	/* 0x98e - 0x98e */
	{ 0xb8e,	0x001 },	/* 0xb8e - 0xb8e */
	{ 0x28d,	0x001 },	/* 0x28d - 0x28d */
	{ 0x28f,	0x001 },	/* 0x28f - 0x28f */
	{ 0x291,	0x001 },	/* 0x291 - 0x291 */
	{ 0x28c,	0x001 },	/* 0x28c - 0x28c */
	{ 0x28e,	0x001 },	/* 0x28e - 0x28e */
	{ 0x290,	0x001 },	/* 0x290 - 0x290 */
	{ 0x471,	0x001 },	/* 0x471 - 0x471 */
	{ 0x49d,	0x001 },	/* 0x49d - 0x49d */
	{ 0x4f5,	0x002 },	/* 0x4f5 - 0x4f6 */
	{ 0x4f4,	0x001 },	/* 0x4f4 - 0x4f4 */
	{ 0x1ce,	0x001 },	/* 0x1ce - 0x1ce */
	{ 0x1ef,	0x001 },	/* 0x1ef - 0x1ef */
	{ 0x1bb,	0x001 },	/* 0x1bb - 0x1bb */
	{ 0x1ba,	0x001 },	/* 0x1ba - 0x1ba */
	{ 0x1b9,	0x001 },	/* 0x1b9 - 0x1b9 */
	{ 0x2d1,	0x001 },	/* 0x2d1 - 0x2d1 */
	{ 0x609,	0x001 },	/* 0x609 - 0x609 */
	{ 0x809,	0x001 },	/* 0x809 - 0x809 */
	{ 0xa09,	0x001 },	/* 0xa09 - 0xa09 */
	{ 0x2d9,	0x002 },	/* 0x2d9 - 0x2da */
	{ 0x2d8,	0x001 },	/* 0x2d8 - 0x2d8 */
	{ 0x2db,	0x001 },	/* 0x2db - 0x2db */
	{ 0x583,	0x001 },	/* 0x583 - 0x583 */
	{ 0x586,	0x001 },	/* 0x586 - 0x586 */
	{ 0x588,	0x001 },	/* 0x588 - 0x588 */
	{ 0x58a,	0x001 },	/* 0x58a - 0x58a */
	{ 0x58c,	0x001 },	/* 0x58c - 0x58c */
	{ 0x58e,	0x001 },	/* 0x58e - 0x58e */
	{ 0x585,	0x001 },	/* 0x585 - 0x585 */
	{ 0x587,	0x001 },	/* 0x587 - 0x587 */
	{ 0x589,	0x001 },	/* 0x589 - 0x589 */
	{ 0x58b,	0x001 },	/* 0x58b - 0x58b */
	{ 0x58d,	0x001 },	/* 0x58d - 0x58d */
	{ 0x580,	0x001 },	/* 0x580 - 0x580 */
	{ 0x591,	0x001 },	/* 0x591 - 0x591 */
	{ 0x584,	0x001 },	/* 0x584 - 0x584 */
	{ 0x582,	0x001 },	/* 0x582 - 0x582 */
	{ 0x523,	0x001 },	/* 0x523 - 0x523 */
	{ 0x522,	0x001 },	/* 0x522 - 0x522 */
	{ 0x521,	0x001 },	/* 0x521 - 0x521 */
	{ 0x171,	0x001 },	/* 0x171 - 0x171 */
	{ 0x29d,	0x001 },	/* 0x29d - 0x29d */
	{ 0x29a,	0x001 },	/* 0x29a - 0x29a */
	{ 0x041,	0x002 },	/* 0x041 - 0x042 */
	{ 0x1b2,	0x002 },	/* 0x1b2 - 0x1b3 */
	{ 0x1b5,	0x001 },	/* 0x1b5 - 0x1b5 */
	{ 0x767,	0x001 },	/* 0x767 - 0x767 */
	{ 0x967,	0x001 },	/* 0x967 - 0x967 */
	{ 0xb67,	0x001 },	/* 0xb67 - 0xb67 */
	{ 0x769,	0x001 },	/* 0x769 - 0x769 */
	{ 0x969,	0x001 },	/* 0x969 - 0x969 */
	{ 0xb69,	0x001 },	/* 0xb69 - 0xb69 */
	{ 0x490,	0x001 },	/* 0x490 - 0x490 */
	{ 0x4b8,	0x001 },	/* 0x4b8 - 0x4b8 */
	{ 0x48e,	0x001 },	/* 0x48e - 0x48e */
	{ 0x480,	0x004 },	/* 0x480 - 0x483 */
	{ 0x4f8,	0x001 },	/* 0x4f8 - 0x4f8 */
	{ 0x10b,	0x001 },	/* 0x10b - 0x10b */
	{ 0x16f,	0x001 },	/* 0x16f - 0x16f */
	{ 0x3de,	0x001 },	/* 0x3de - 0x3de */
	{ 0x3d5,	0x001 },	/* 0x3d5 - 0x3d5 */
	{ 0x297,	0x002 },	/* 0x297 - 0x298 */
	{ 0x120,	0x001 },	/* 0x120 - 0x120 */
	{ 0x129,	0x001 },	/* 0x129 - 0x129 */
	{ 0x125,	0x001 },	/* 0x125 - 0x125 */
	{ 0x123,	0x001 },	/* 0x123 - 0x123 */
	{ 0x670,	0x001 },	/* 0x670 - 0x670 */
	{ 0x870,	0x001 },	/* 0x870 - 0x870 */
	{ 0xa70,	0x001 },	/* 0xa70 - 0xa70 */
	{ 0x671,	0x001 },	/* 0x671 - 0x671 */
	{ 0x871,	0x001 },	/* 0x871 - 0x871 */
	{ 0xa71,	0x001 },	/* 0xa71 - 0xa71 */
	{ 0x672,	0x001 },	/* 0x672 - 0x672 */
	{ 0x872,	0x001 },	/* 0x872 - 0x872 */
	{ 0xa72,	0x001 },	/* 0xa72 - 0xa72 */
	{ 0x673,	0x001 },	/* 0x673 - 0x673 */
	{ 0x873,	0x001 },	/* 0x873 - 0x873 */
	{ 0xa73,	0x001 },	/* 0xa73 - 0xa73 */
	{ 0x122,	0x001 },	/* 0x122 - 0x122 */
	{ 0x67c,	0x001 },	/* 0x67c - 0x67c */
	{ 0x87c,	0x001 },	/* 0x87c - 0x87c */
	{ 0xa7c,	0x001 },	/* 0xa7c - 0xa7c */
	{ 0x124,	0x001 },	/* 0x124 - 0x124 */
	{ 0x12a,	0x001 },	/* 0x12a - 0x12a */
	{ 0x674,	0x001 },	/* 0x674 - 0x674 */
	{ 0x874,	0x001 },	/* 0x874 - 0x874 */
	{ 0xa74,	0x001 },	/* 0xa74 - 0xa74 */
	{ 0x675,	0x001 },	/* 0x675 - 0x675 */
	{ 0x875,	0x001 },	/* 0x875 - 0x875 */
	{ 0xa75,	0x001 },	/* 0xa75 - 0xa75 */
	{ 0x121,	0x001 },	/* 0x121 - 0x121 */
	{ 0x676,	0x001 },	/* 0x676 - 0x676 */
	{ 0x876,	0x001 },	/* 0x876 - 0x876 */
	{ 0xa76,	0x001 },	/* 0xa76 - 0xa76 */
	{ 0x677,	0x001 },	/* 0x677 - 0x677 */
	{ 0x877,	0x001 },	/* 0x877 - 0x877 */
	{ 0xa77,	0x001 },	/* 0xa77 - 0xa77 */
	{ 0x678,	0x001 },	/* 0x678 - 0x678 */
	{ 0x878,	0x001 },	/* 0x878 - 0x878 */
	{ 0xa78,	0x001 },	/* 0xa78 - 0xa78 */
	{ 0x126,	0x003 },	/* 0x126 - 0x128 */
	{ 0x680,	0x001 },	/* 0x680 - 0x680 */
	{ 0x880,	0x001 },	/* 0x880 - 0x880 */
	{ 0xa80,	0x001 },	/* 0xa80 - 0xa80 */
	{ 0x681,	0x001 },	/* 0x681 - 0x681 */
	{ 0x881,	0x001 },	/* 0x881 - 0x881 */
	{ 0xa81,	0x001 },	/* 0xa81 - 0xa81 */
	{ 0x682,	0x001 },	/* 0x682 - 0x682 */
	{ 0x882,	0x001 },	/* 0x882 - 0x882 */
	{ 0xa82,	0x001 },	/* 0xa82 - 0xa82 */
	{ 0x683,	0x001 },	/* 0x683 - 0x683 */
	{ 0x883,	0x001 },	/* 0x883 - 0x883 */
	{ 0xa83,	0x001 },	/* 0xa83 - 0xa83 */
	{ 0x684,	0x001 },	/* 0x684 - 0x684 */
	{ 0x884,	0x001 },	/* 0x884 - 0x884 */
	{ 0xa84,	0x001 },	/* 0xa84 - 0xa84 */
	{ 0x67d,	0x001 },	/* 0x67d - 0x67d */
	{ 0x87d,	0x001 },	/* 0x87d - 0x87d */
	{ 0xa7d,	0x001 },	/* 0xa7d - 0xa7d */
	{ 0x67e,	0x001 },	/* 0x67e - 0x67e */
	{ 0x87e,	0x001 },	/* 0x87e - 0x87e */
	{ 0xa7e,	0x001 },	/* 0xa7e - 0xa7e */
	{ 0x67f,	0x001 },	/* 0x67f - 0x67f */
	{ 0x87f,	0x001 },	/* 0x87f - 0x87f */
	{ 0xa7f,	0x001 },	/* 0xa7f - 0xa7f */
	{ 0x080,	0x001 },	/* 0x080 - 0x080 */
	{ 0x660,	0x001 },	/* 0x660 - 0x660 */
	{ 0x860,	0x001 },	/* 0x860 - 0x860 */
	{ 0xa60,	0x001 },	/* 0xa60 - 0xa60 */
	{ 0x662,	0x001 },	/* 0x662 - 0x662 */
	{ 0x862,	0x001 },	/* 0x862 - 0x862 */
	{ 0xa62,	0x001 },	/* 0xa62 - 0xa62 */
	{ 0x661,	0x001 },	/* 0x661 - 0x661 */
	{ 0x861,	0x001 },	/* 0x861 - 0x861 */
	{ 0xa61,	0x001 },	/* 0xa61 - 0xa61 */
	{ 0x085,	0x002 },	/* 0x085 - 0x086 */
	{ 0x08a,	0x002 },	/* 0x08a - 0x08b */
	{ 0x082,	0x003 },	/* 0x082 - 0x084 */
	{ 0x087,	0x003 },	/* 0x087 - 0x089 */
	{ 0x081,	0x001 },	/* 0x081 - 0x081 */
	{ 0x090,	0x002 },	/* 0x090 - 0x091 */
	{ 0x095,	0x002 },	/* 0x095 - 0x096 */
	{ 0x08d,	0x003 },	/* 0x08d - 0x08f */
	{ 0x092,	0x003 },	/* 0x092 - 0x094 */
	{ 0x08c,	0x001 },	/* 0x08c - 0x08c */
	{ 0x09b,	0x002 },	/* 0x09b - 0x09c */
	{ 0x0a0,	0x002 },	/* 0x0a0 - 0x0a1 */
	{ 0x098,	0x003 },	/* 0x098 - 0x09a */
	{ 0x09d,	0x003 },	/* 0x09d - 0x09f */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x0a3,	0x003 },	/* 0x0a3 - 0x0a5 */
	{ 0x0a7,	0x002 },	/* 0x0a7 - 0x0a8 */
	{ 0x0a6,	0x001 },	/* 0x0a6 - 0x0a6 */
	{ 0x0a2,	0x001 },	/* 0x0a2 - 0x0a2 */
	{ 0x3ac,	0x001 },	/* 0x3ac - 0x3ac */
	{ 0x3aa,	0x001 },	/* 0x3aa - 0x3aa */
	{ 0x1b1,	0x001 },	/* 0x1b1 - 0x1b1 */
	{ 0x1cf,	0x008 },	/* 0x1cf - 0x1d6 */
	{ 0x469,	0x001 },	/* 0x469 - 0x469 */
	{ 0x1ed,	0x001 },	/* 0x1ed - 0x1ed */
	{ 0x3e4,	0x001 },	/* 0x3e4 - 0x3e4 */
	{ 0x3c2,	0x001 },	/* 0x3c2 - 0x3c2 */
	{ 0x3c1,	0x001 },	/* 0x3c1 - 0x3c1 */
	{ 0x078,	0x001 },	/* 0x078 - 0x078 */
	{ 0x07a,	0x001 },	/* 0x07a - 0x07a */
	{ 0x370,	0x001 },	/* 0x370 - 0x370 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x46e,	0x001 },	/* 0x46e - 0x46e */
	{ 0x15d,	0x001 },	/* 0x15d - 0x15d */
	{ 0x1c7,	0x001 },	/* 0x1c7 - 0x1c7 */
	{ 0x153,	0x001 },	/* 0x153 - 0x153 */
	{ 0x1c9,	0x001 },	/* 0x1c9 - 0x1c9 */
	{ 0x155,	0x001 },	/* 0x155 - 0x155 */
	{ 0x152,	0x001 },	/* 0x152 - 0x152 */
	{ 0x692,	0x001 },	/* 0x692 - 0x692 */
	{ 0x892,	0x001 },	/* 0x892 - 0x892 */
	{ 0xa92,	0x001 },	/* 0xa92 - 0xa92 */
	{ 0x1c4,	0x003 },	/* 0x1c4 - 0x1c6 */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x1c8,	0x001 },	/* 0x1c8 - 0x1c8 */
	{ 0x156,	0x001 },	/* 0x156 - 0x156 */
	{ 0x405,	0x001 },	/* 0x405 - 0x405 */
	{ 0x168,	0x001 },	/* 0x168 - 0x168 */
	{ 0xc13,	0x001 },	/* 0xc13 - 0xc13 */
	{ 0xc10,	0x001 },	/* 0xc10 - 0xc10 */
	{ 0xc12,	0x001 },	/* 0xc12 - 0xc12 */
	{ 0xc11,	0x001 },	/* 0xc11 - 0xc11 */
	{ 0x1e6,	0x001 },	/* 0x1e6 - 0x1e6 */
	{ 0x1f0,	0x002 },	/* 0x1f0 - 0x1f1 */
	{ 0x1e0,	0x001 },	/* 0x1e0 - 0x1e0 */
	{ 0x799,	0x001 },	/* 0x799 - 0x799 */
	{ 0x999,	0x001 },	/* 0x999 - 0x999 */
	{ 0xb99,	0x001 },	/* 0xb99 - 0xb99 */
	{ 0x798,	0x001 },	/* 0x798 - 0x798 */
	{ 0x998,	0x001 },	/* 0x998 - 0x998 */
	{ 0xb98,	0x001 },	/* 0xb98 - 0xb98 */
	{ 0x3ed,	0x001 },	/* 0x3ed - 0x3ed */
	{ 0x415,	0x001 },	/* 0x415 - 0x415 */
	{ 0x3ee,	0x001 },	/* 0x3ee - 0x3ee */
	{ 0x3da,	0x002 },	/* 0x3da - 0x3db */
	{ 0x3ce,	0x001 },	/* 0x3ce - 0x3ce */
	{ 0x7d3,	0x001 },	/* 0x7d3 - 0x7d3 */
	{ 0x9d3,	0x001 },	/* 0x9d3 - 0x9d3 */
	{ 0xbd3,	0x001 },	/* 0xbd3 - 0xbd3 */
	{ 0x7d7,	0x001 },	/* 0x7d7 - 0x7d7 */
	{ 0x9d7,	0x001 },	/* 0x9d7 - 0x9d7 */
	{ 0xbd7,	0x001 },	/* 0xbd7 - 0xbd7 */
	{ 0x7d9,	0x001 },	/* 0x7d9 - 0x7d9 */
	{ 0x9d9,	0x001 },	/* 0x9d9 - 0x9d9 */
	{ 0xbd9,	0x001 },	/* 0xbd9 - 0xbd9 */
	{ 0x7db,	0x001 },	/* 0x7db - 0x7db */
	{ 0x9db,	0x001 },	/* 0x9db - 0x9db */
	{ 0xbdb,	0x001 },	/* 0xbdb - 0xbdb */
	{ 0x7d5,	0x001 },	/* 0x7d5 - 0x7d5 */
	{ 0x9d5,	0x001 },	/* 0x9d5 - 0x9d5 */
	{ 0xbd5,	0x001 },	/* 0xbd5 - 0xbd5 */
	{ 0x7d1,	0x001 },	/* 0x7d1 - 0x7d1 */
	{ 0x9d1,	0x001 },	/* 0x9d1 - 0x9d1 */
	{ 0xbd1,	0x001 },	/* 0xbd1 - 0xbd1 */
	{ 0x7d2,	0x001 },	/* 0x7d2 - 0x7d2 */
	{ 0x9d2,	0x001 },	/* 0x9d2 - 0x9d2 */
	{ 0xbd2,	0x001 },	/* 0xbd2 - 0xbd2 */
	{ 0x7d6,	0x001 },	/* 0x7d6 - 0x7d6 */
	{ 0x9d6,	0x001 },	/* 0x9d6 - 0x9d6 */
	{ 0xbd6,	0x001 },	/* 0xbd6 - 0xbd6 */
	{ 0x7d8,	0x001 },	/* 0x7d8 - 0x7d8 */
	{ 0x9d8,	0x001 },	/* 0x9d8 - 0x9d8 */
	{ 0xbd8,	0x001 },	/* 0xbd8 - 0xbd8 */
	{ 0x7da,	0x001 },	/* 0x7da - 0x7da */
	{ 0x9da,	0x001 },	/* 0x9da - 0x9da */
	{ 0xbda,	0x001 },	/* 0xbda - 0xbda */
	{ 0x7d4,	0x001 },	/* 0x7d4 - 0x7d4 */
	{ 0x9d4,	0x001 },	/* 0x9d4 - 0x9d4 */
	{ 0xbd4,	0x001 },	/* 0xbd4 - 0xbd4 */
	{ 0x7d0,	0x001 },	/* 0x7d0 - 0x7d0 */
	{ 0x9d0,	0x001 },	/* 0x9d0 - 0x9d0 */
	{ 0xbd0,	0x001 },	/* 0xbd0 - 0xbd0 */
	{ 0x7dd,	0x001 },	/* 0x7dd - 0x7dd */
	{ 0x9dd,	0x001 },	/* 0x9dd - 0x9dd */
	{ 0xbdd,	0x001 },	/* 0xbdd - 0xbdd */
	{ 0x7dc,	0x001 },	/* 0x7dc - 0x7dc */
	{ 0x9dc,	0x001 },	/* 0x9dc - 0x9dc */
	{ 0xbdc,	0x001 },	/* 0xbdc - 0xbdc */
	{ 0x2c8,	0x003 },	/* 0x2c8 - 0x2ca */
	{ 0x2c6,	0x002 },	/* 0x2c6 - 0x2c7 */
	{ 0x3cd,	0x001 },	/* 0x3cd - 0x3cd */
	{ 0x78d,	0x001 },	/* 0x78d - 0x78d */
	{ 0x98d,	0x001 },	/* 0x98d - 0x98d */
	{ 0xb8d,	0x001 },	/* 0xb8d - 0xb8d */
	{ 0x78c,	0x001 },	/* 0x78c - 0x78c */
	{ 0x98c,	0x001 },	/* 0x98c - 0x98c */
	{ 0xb8c,	0x001 },	/* 0xb8c - 0xb8c */
	{ 0x789,	0x001 },	/* 0x789 - 0x789 */
	{ 0x989,	0x001 },	/* 0x989 - 0x989 */
	{ 0xb89,	0x001 },	/* 0xb89 - 0xb89 */
	{ 0x788,	0x001 },	/* 0x788 - 0x788 */
	{ 0x988,	0x001 },	/* 0x988 - 0x988 */
	{ 0xb88,	0x001 },	/* 0xb88 - 0xb88 */
	{ 0x78b,	0x001 },	/* 0x78b - 0x78b */
	{ 0x98b,	0x001 },	/* 0x98b - 0x98b */
	{ 0xb8b,	0x001 },	/* 0xb8b - 0xb8b */
	{ 0x78a,	0x001 },	/* 0x78a - 0x78a */
	{ 0x98a,	0x001 },	/* 0x98a - 0x98a */
	{ 0xb8a,	0x001 },	/* 0xb8a - 0xb8a */
	{ 0x3df,	0x001 },	/* 0x3df - 0x3df */
	{ 0x25e,	0x001 },	/* 0x25e - 0x25e */
	{ 0x25d,	0x001 },	/* 0x25d - 0x25d */
	{ 0x250,	0x001 },	/* 0x250 - 0x250 */
	{ 0x25f,	0x002 },	/* 0x25f - 0x260 */
	{ 0x264,	0x002 },	/* 0x264 - 0x265 */
	{ 0x25b,	0x001 },	/* 0x25b - 0x25b */
	{ 0x268,	0x001 },	/* 0x268 - 0x268 */
	{ 0x263,	0x001 },	/* 0x263 - 0x263 */
	{ 0x25c,	0x001 },	/* 0x25c - 0x25c */
	{ 0x261,	0x002 },	/* 0x261 - 0x262 */
	{ 0x255,	0x001 },	/* 0x255 - 0x255 */
	{ 0x266,	0x001 },	/* 0x266 - 0x266 */
	{ 0x257,	0x001 },	/* 0x257 - 0x257 */
	{ 0x256,	0x001 },	/* 0x256 - 0x256 */
	{ 0x267,	0x001 },	/* 0x267 - 0x267 */
	{ 0x258,	0x001 },	/* 0x258 - 0x258 */
	{ 0x850,	0x001 },	/* 0x850 - 0x850 */
	{ 0x830,	0x005 },	/* 0x830 - 0x834 */
	{ 0x858,	0x001 },	/* 0x858 - 0x858 */
	{ 0x83f,	0x001 },	/* 0x83f - 0x83f */
	{ 0x83c,	0x003 },	/* 0x83c - 0x83e */
	{ 0x83a,	0x002 },	/* 0x83a - 0x83b */
	{ 0x835,	0x005 },	/* 0x835 - 0x839 */
	{ 0x857,	0x001 },	/* 0x857 - 0x857 */
	{ 0x855,	0x002 },	/* 0x855 - 0x856 */
	{ 0x854,	0x001 },	/* 0x854 - 0x854 */
	{ 0x851,	0x003 },	/* 0x851 - 0x853 */
	{ 0x475,	0x001 },	/* 0x475 - 0x475 */
	{ 0x413,	0x001 },	/* 0x413 - 0x413 */
	{ 0x40b,	0x001 },	/* 0x40b - 0x40b */
	{ 0x409,	0x001 },	/* 0x409 - 0x409 */
	{ 0x748,	0x001 },	/* 0x748 - 0x748 */
	{ 0x948,	0x001 },	/* 0x948 - 0x948 */
	{ 0xb48,	0x001 },	/* 0xb48 - 0xb48 */
	{ 0x408,	0x001 },	/* 0x408 - 0x408 */
	{ 0x741,	0x004 },	/* 0x741 - 0x744 */
	{ 0x941,	0x004 },	/* 0x941 - 0x944 */
	{ 0xb41,	0x004 },	/* 0xb41 - 0xb44 */
	{ 0x739,	0x001 },	/* 0x739 - 0x739 */
	{ 0x939,	0x001 },	/* 0x939 - 0x939 */
	{ 0xb39,	0x001 },	/* 0xb39 - 0xb39 */
	{ 0x73a,	0x001 },	/* 0x73a - 0x73a */
	{ 0x93a,	0x001 },	/* 0x93a - 0x93a */
	{ 0xb3a,	0x001 },	/* 0xb3a - 0xb3a */
	{ 0x73c,	0x001 },	/* 0x73c - 0x73c */
	{ 0x93c,	0x001 },	/* 0x93c - 0x93c */
	{ 0xb3c,	0x001 },	/* 0xb3c - 0xb3c */
	{ 0x73d,	0x001 },	/* 0x73d - 0x73d */
	{ 0x93d,	0x001 },	/* 0x93d - 0x93d */
	{ 0xb3d,	0x001 },	/* 0xb3d - 0xb3d */
	{ 0x417,	0x001 },	/* 0x417 - 0x417 */
	{ 0x745,	0x001 },	/* 0x745 - 0x745 */
	{ 0x945,	0x001 },	/* 0x945 - 0x945 */
	{ 0xb45,	0x001 },	/* 0xb45 - 0xb45 */
	{ 0x73b,	0x001 },	/* 0x73b - 0x73b */
	{ 0x93b,	0x001 },	/* 0x93b - 0x93b */
	{ 0xb3b,	0x001 },	/* 0xb3b - 0xb3b */
	{ 0x735,	0x001 },	/* 0x735 - 0x735 */
	{ 0x935,	0x001 },	/* 0x935 - 0x935 */
	{ 0xb35,	0x001 },	/* 0xb35 - 0xb35 */
	{ 0x734,	0x001 },	/* 0x734 - 0x734 */
	{ 0x934,	0x001 },	/* 0x934 - 0x934 */
	{ 0xb34,	0x001 },	/* 0xb34 - 0xb34 */
	{ 0x737,	0x001 },	/* 0x737 - 0x737 */
	{ 0x937,	0x001 },	/* 0x937 - 0x937 */
	{ 0xb37,	0x001 },	/* 0xb37 - 0xb37 */
	{ 0x736,	0x001 },	/* 0x736 - 0x736 */
	{ 0x936,	0x001 },	/* 0x936 - 0x936 */
	{ 0xb36,	0x001 },	/* 0xb36 - 0xb36 */
	{ 0x746,	0x001 },	/* 0x746 - 0x746 */
	{ 0x946,	0x001 },	/* 0x946 - 0x946 */
	{ 0xb46,	0x001 },	/* 0xb46 - 0xb46 */
	{ 0x738,	0x001 },	/* 0x738 - 0x738 */
	{ 0x938,	0x001 },	/* 0x938 - 0x938 */
	{ 0xb38,	0x001 },	/* 0xb38 - 0xb38 */
	{ 0x730,	0x001 },	/* 0x730 - 0x730 */
	{ 0x930,	0x001 },	/* 0x930 - 0x930 */
	{ 0xb30,	0x001 },	/* 0xb30 - 0xb30 */
	{ 0x731,	0x001 },	/* 0x731 - 0x731 */
	{ 0x931,	0x001 },	/* 0x931 - 0x931 */
	{ 0xb31,	0x001 },	/* 0xb31 - 0xb31 */
	{ 0x729,	0x001 },	/* 0x729 - 0x729 */
	{ 0x929,	0x001 },	/* 0x929 - 0x929 */
	{ 0xb29,	0x001 },	/* 0xb29 - 0xb29 */
	{ 0x732,	0x001 },	/* 0x732 - 0x732 */
	{ 0x932,	0x001 },	/* 0x932 - 0x932 */
	{ 0xb32,	0x001 },	/* 0xb32 - 0xb32 */
	{ 0x733,	0x001 },	/* 0x733 - 0x733 */
	{ 0x933,	0x001 },	/* 0x933 - 0x933 */
	{ 0xb33,	0x001 },	/* 0xb33 - 0xb33 */
	{ 0x728,	0x001 },	/* 0x728 - 0x728 */
	{ 0x928,	0x001 },	/* 0x928 - 0x928 */
	{ 0xb28,	0x001 },	/* 0xb28 - 0xb28 */
	{ 0x73e,	0x001 },	/* 0x73e - 0x73e */
	{ 0x93e,	0x001 },	/* 0x93e - 0x93e */
	{ 0xb3e,	0x001 },	/* 0xb3e - 0xb3e */
	{ 0x725,	0x001 },	/* 0x725 - 0x725 */
	{ 0x925,	0x001 },	/* 0x925 - 0x925 */
	{ 0xb25,	0x001 },	/* 0xb25 - 0xb25 */
	{ 0x727,	0x001 },	/* 0x727 - 0x727 */
	{ 0x927,	0x001 },	/* 0x927 - 0x927 */
	{ 0xb27,	0x001 },	/* 0xb27 - 0xb27 */
	{ 0x722,	0x001 },	/* 0x722 - 0x722 */
	{ 0x922,	0x001 },	/* 0x922 - 0x922 */
	{ 0xb22,	0x001 },	/* 0xb22 - 0xb22 */
	{ 0x416,	0x001 },	/* 0x416 - 0x416 */
	{ 0x726,	0x001 },	/* 0x726 - 0x726 */
	{ 0x926,	0x001 },	/* 0x926 - 0x926 */
	{ 0xb26,	0x001 },	/* 0xb26 - 0xb26 */
	{ 0x723,	0x001 },	/* 0x723 - 0x723 */
	{ 0x923,	0x001 },	/* 0x923 - 0x923 */
	{ 0xb23,	0x001 },	/* 0xb23 - 0xb23 */
	{ 0x724,	0x001 },	/* 0x724 - 0x724 */
	{ 0x924,	0x001 },	/* 0x924 - 0x924 */
	{ 0xb24,	0x001 },	/* 0xb24 - 0xb24 */
	{ 0x721,	0x001 },	/* 0x721 - 0x721 */
	{ 0x921,	0x001 },	/* 0x921 - 0x921 */
	{ 0xb21,	0x001 },	/* 0xb21 - 0xb21 */
	{ 0x720,	0x001 },	/* 0x720 - 0x720 */
	{ 0x920,	0x001 },	/* 0x920 - 0x920 */
	{ 0xb20,	0x001 },	/* 0xb20 - 0xb20 */
	{ 0x40e,	0x001 },	/* 0x40e - 0x40e */
	{ 0x401,	0x001 },	/* 0x401 - 0x401 */
	{ 0x403,	0x002 },	/* 0x403 - 0x404 */
	{ 0x412,	0x001 },	/* 0x412 - 0x412 */
	{ 0x402,	0x001 },	/* 0x402 - 0x402 */
	{ 0x411,	0x001 },	/* 0x411 - 0x411 */
	{ 0x3ab,	0x001 },	/* 0x3ab - 0x3ab */
	{ 0x1f4,	0x001 },	/* 0x1f4 - 0x1f4 */
	{ 0x520,	0x001 },	/* 0x520 - 0x520 */
	{ 0x3ae,	0x001 },	/* 0x3ae - 0x3ae */
	{ 0x1cd,	0x001 },	/* 0x1cd - 0x1cd */
	{ 0x179,	0x001 },	/* 0x179 - 0x179 */
	{ 0x164,	0x001 },	/* 0x164 - 0x164 */
	{ 0x3ca,	0x002 },	/* 0x3ca - 0x3cb */
	{ 0x199,	0x001 },	/* 0x199 - 0x199 */
	{ 0x19b,	0x001 },	/* 0x19b - 0x19b */
	{ 0x19a,	0x001 },	/* 0x19a - 0x19a */
	{ 0x19c,	0x001 },	/* 0x19c - 0x19c */
	{ 0x6a4,	0x002 },	/* 0x6a4 - 0x6a5 */
	{ 0x6ae,	0x001 },	/* 0x6ae - 0x6ae */
	{ 0x6a6,	0x008 },	/* 0x6a6 - 0x6ad */
	{ 0x8a4,	0x002 },	/* 0x8a4 - 0x8a5 */
	{ 0x8ae,	0x001 },	/* 0x8ae - 0x8ae */
	{ 0x8a6,	0x008 },	/* 0x8a6 - 0x8ad */
	{ 0xaa4,	0x002 },	/* 0xaa4 - 0xaa5 */
	{ 0xaae,	0x001 },	/* 0xaae - 0xaae */
	{ 0xaa6,	0x008 },	/* 0xaa6 - 0xaad */
	{ 0x211,	0x001 },	/* 0x211 - 0x211 */
	{ 0x210,	0x001 },	/* 0x210 - 0x210 */
	{ 0x695,	0x001 },	/* 0x695 - 0x695 */
	{ 0x895,	0x001 },	/* 0x895 - 0x895 */
	{ 0xa95,	0x001 },	/* 0xa95 - 0xa95 */
	{ 0x696,	0x001 },	/* 0x696 - 0x696 */
	{ 0x896,	0x001 },	/* 0x896 - 0x896 */
	{ 0xa96,	0x001 },	/* 0xa96 - 0xa96 */
	{ 0x693,	0x001 },	/* 0x693 - 0x693 */
	{ 0x893,	0x001 },	/* 0x893 - 0x893 */
	{ 0xa93,	0x001 },	/* 0xa93 - 0xa93 */
	{ 0x694,	0x001 },	/* 0x694 - 0x694 */
	{ 0x894,	0x001 },	/* 0x894 - 0x894 */
	{ 0xa94,	0x001 },	/* 0xa94 - 0xa94 */
	{ 0x19e,	0x001 },	/* 0x19e - 0x19e */
	{ 0x19d,	0x001 },	/* 0x19d - 0x19d */
	{ 0x19f,	0x001 },	/* 0x19f - 0x19f */
	{ 0x184,	0x002 },	/* 0x184 - 0x185 */
	{ 0x189,	0x002 },	/* 0x189 - 0x18a */
	{ 0x181,	0x003 },	/* 0x181 - 0x183 */
	{ 0x186,	0x003 },	/* 0x186 - 0x188 */
	{ 0x3ad,	0x001 },	/* 0x3ad - 0x3ad */
	{ 0x783,	0x001 },	/* 0x783 - 0x783 */
	{ 0x983,	0x001 },	/* 0x983 - 0x983 */
	{ 0xb83,	0x001 },	/* 0xb83 - 0xb83 */
	{ 0x782,	0x001 },	/* 0x782 - 0x782 */
	{ 0x982,	0x001 },	/* 0x982 - 0x982 */
	{ 0xb82,	0x001 },	/* 0xb82 - 0xb82 */
	{ 0x785,	0x001 },	/* 0x785 - 0x785 */
	{ 0x985,	0x001 },	/* 0x985 - 0x985 */
	{ 0xb85,	0x001 },	/* 0xb85 - 0xb85 */
	{ 0x784,	0x001 },	/* 0x784 - 0x784 */
	{ 0x984,	0x001 },	/* 0x984 - 0x984 */
	{ 0xb84,	0x001 },	/* 0xb84 - 0xb84 */
	{ 0x787,	0x001 },	/* 0x787 - 0x787 */
	{ 0x987,	0x001 },	/* 0x987 - 0x987 */
	{ 0xb87,	0x001 },	/* 0xb87 - 0xb87 */
	{ 0x786,	0x001 },	/* 0x786 - 0x786 */
	{ 0x986,	0x001 },	/* 0x986 - 0x986 */
	{ 0xb86,	0x001 },	/* 0xb86 - 0xb86 */
	{ 0x796,	0x001 },	/* 0x796 - 0x796 */
	{ 0x996,	0x001 },	/* 0x996 - 0x996 */
	{ 0xb96,	0x001 },	/* 0xb96 - 0xb96 */
	{ 0x797,	0x001 },	/* 0x797 - 0x797 */
	{ 0x997,	0x001 },	/* 0x997 - 0x997 */
	{ 0xb97,	0x001 },	/* 0xb97 - 0xb97 */
	{ 0x15b,	0x001 },	/* 0x15b - 0x15b */
	{ 0x15a,	0x001 },	/* 0x15a - 0x15a */
	{ 0x15c,	0x001 },	/* 0x15c - 0x15c */
	{ 0x141,	0x001 },	/* 0x141 - 0x141 */
	{ 0x143,	0x006 },	/* 0x143 - 0x148 */
	{ 0x142,	0x001 },	/* 0x142 - 0x142 */
	{ 0x149,	0x009 },	/* 0x149 - 0x151 */
	{ 0x18e,	0x002 },	/* 0x18e - 0x18f */
	{ 0x193,	0x002 },	/* 0x193 - 0x194 */
	{ 0x18b,	0x003 },	/* 0x18b - 0x18d */
	{ 0x190,	0x003 },	/* 0x190 - 0x192 */
	{ 0x468,	0x001 },	/* 0x468 - 0x468 */
	{ 0x460,	0x001 },	/* 0x460 - 0x460 */
	{ 0x463,	0x001 },	/* 0x463 - 0x463 */
	{ 0x462,	0x001 },	/* 0x462 - 0x462 */
	{ 0x461,	0x001 },	/* 0x461 - 0x461 */
	{ 0x465,	0x001 },	/* 0x465 - 0x465 */
	{ 0x464,	0x001 },	/* 0x464 - 0x464 */
	{ 0x466,	0x001 },	/* 0x466 - 0x466 */
	{ 0x040,	0x001 },	/* 0x040 - 0x040 */
	{ 0x1c2,	0x002 },	/* 0x1c2 - 0x1c3 */
	{ 0x1bf,	0x003 },	/* 0x1bf - 0x1c1 */
	{ 0x1bc,	0x003 },	/* 0x1bc - 0x1be */
	{ 0x175,	0x001 },	/* 0x175 - 0x175 */
	{ 0x1a4,	0x001 },	/* 0x1a4 - 0x1a4 */
	{ 0x3c9,	0x001 },	/* 0x3c9 - 0x3c9 */
	{ 0x3c7,	0x002 },	/* 0x3c7 - 0x3c8 */
	{ 0x414,	0x001 },	/* 0x414 - 0x414 */
	{ 0x2c0,	0x001 },	/* 0x2c0 - 0x2c0 */
	{ 0x043,	0x001 },	/* 0x043 - 0x043 */
	{ 0x030,	0x001 },	/* 0x030 - 0x030 */
	{ 0xc00,	0x001 },	/* 0xc00 - 0xc00 */
	{ 0xc05,	0x004 },	/* 0xc05 - 0xc08 */
	{ 0x4f9,	0x002 },	/* 0x4f9 - 0x4fa */
	{ 0x1e9,	0x001 },	/* 0x1e9 - 0x1e9 */
	{ 0x16a,	0x001 },	/* 0x16a - 0x16a */
	{ 0x1b8,	0x001 },	/* 0x1b8 - 0x1b8 */
	{ 0x470,	0x001 },	/* 0x470 - 0x470 */
	{ 0x46f,	0x001 },	/* 0x46f - 0x46f */
	{ 0x476,	0x001 },	/* 0x476 - 0x476 */
	{ 0x474,	0x001 },	/* 0x474 - 0x474 */
	{ 0x477,	0x001 },	/* 0x477 - 0x477 */
	{ 0x178,	0x001 },	/* 0x178 - 0x178 */
	{ 0xd33,	0x001 },	/* 0xd33 - 0xd33 */
	{ 0xd40,	0x010 },	/* 0xd40 - 0xd4f */
	{ 0xd30,	0x002 },	/* 0xd30 - 0xd31 */
	{ 0xb03,	0x001 },	/* 0xb03 - 0xb03 */
	{ 0xb06,	0x001 },	/* 0xb06 - 0xb06 */
	{ 0xb04,	0x002 },	/* 0xb04 - 0xb05 */
	{ 0xb6a,	0x001 },	/* 0xb6a - 0xb6a */
	{ 0xb71,	0x001 },	/* 0xb71 - 0xb71 */
	{ 0xb79,	0x003 },	/* 0xb79 - 0xb7b */
	{ 0xb74,	0x002 },	/* 0xb74 - 0xb75 */
	{ 0xb7e,	0x002 },	/* 0xb7e - 0xb7f */
	{ 0xb78,	0x001 },	/* 0xb78 - 0xb78 */
	{ 0xb6d,	0x001 },	/* 0xb6d - 0xb6d */
	{ 0xb70,	0x001 },	/* 0xb70 - 0xb70 */
	{ 0xb6e,	0x001 },	/* 0xb6e - 0xb6e */
	{ 0xb6b,	0x002 },	/* 0xb6b - 0xb6c */
	{ 0xb6f,	0x001 },	/* 0xb6f - 0xb6f */
	{ 0xb73,	0x001 },	/* 0xb73 - 0xb73 */
	{ 0xb7d,	0x001 },	/* 0xb7d - 0xb7d */
	{ 0xb7c,	0x001 },	/* 0xb7c - 0xb7c */
	{ 0xb72,	0x001 },	/* 0xb72 - 0xb72 */
	{ 0xb76,	0x002 },	/* 0xb76 - 0xb77 */
	{ 0xb07,	0x001 },	/* 0xb07 - 0xb07 */
	{ 0xb0a,	0x001 },	/* 0xb0a - 0xb0a */
	{ 0xb08,	0x002 },	/* 0xb08 - 0xb09 */
	{ 0xb0b,	0x001 },	/* 0xb0b - 0xb0b */
	{ 0xb0e,	0x001 },	/* 0xb0e - 0xb0e */
	{ 0xb0c,	0x002 },	/* 0xb0c - 0xb0d */
	{ 0xd03,	0x001 },	/* 0xd03 - 0xd03 */
	{ 0xd06,	0x001 },	/* 0xd06 - 0xd06 */
	{ 0xd04,	0x002 },	/* 0xd04 - 0xd05 */
	{ 0xd6a,	0x001 },	/* 0xd6a - 0xd6a */
	{ 0xd71,	0x001 },	/* 0xd71 - 0xd71 */
	{ 0xd79,	0x003 },	/* 0xd79 - 0xd7b */
	{ 0xd74,	0x002 },	/* 0xd74 - 0xd75 */
	{ 0xd7e,	0x002 },	/* 0xd7e - 0xd7f */
	{ 0xd78,	0x001 },	/* 0xd78 - 0xd78 */
	{ 0xd6d,	0x001 },	/* 0xd6d - 0xd6d */
	{ 0xd70,	0x001 },	/* 0xd70 - 0xd70 */
	{ 0xd6e,	0x001 },	/* 0xd6e - 0xd6e */
	{ 0xd6b,	0x002 },	/* 0xd6b - 0xd6c */
	{ 0xd6f,	0x001 },	/* 0xd6f - 0xd6f */
	{ 0xd73,	0x001 },	/* 0xd73 - 0xd73 */
	{ 0xd7d,	0x001 },	/* 0xd7d - 0xd7d */
	{ 0xd7c,	0x001 },	/* 0xd7c - 0xd7c */
	{ 0xd72,	0x001 },	/* 0xd72 - 0xd72 */
	{ 0xd76,	0x002 },	/* 0xd76 - 0xd77 */
	{ 0xd07,	0x001 },	/* 0xd07 - 0xd07 */
	{ 0xd0a,	0x001 },	/* 0xd0a - 0xd0a */
	{ 0xd08,	0x002 },	/* 0xd08 - 0xd09 */
	{ 0xd0b,	0x001 },	/* 0xd0b - 0xd0b */
	{ 0xd0e,	0x001 },	/* 0xd0e - 0xd0e */
	{ 0xd0c,	0x002 },	/* 0xd0c - 0xd0d */
	{ 0xf03,	0x001 },	/* 0xf03 - 0xf03 */
	{ 0xf06,	0x001 },	/* 0xf06 - 0xf06 */
	{ 0xf04,	0x002 },	/* 0xf04 - 0xf05 */
	{ 0xf6a,	0x001 },	/* 0xf6a - 0xf6a */
	{ 0xf71,	0x001 },	/* 0xf71 - 0xf71 */
	{ 0xf79,	0x003 },	/* 0xf79 - 0xf7b */
	{ 0xf74,	0x002 },	/* 0xf74 - 0xf75 */
	{ 0xf7e,	0x002 },	/* 0xf7e - 0xf7f */
	{ 0xf78,	0x001 },	/* 0xf78 - 0xf78 */
	{ 0xf6d,	0x001 },	/* 0xf6d - 0xf6d */
	{ 0xf70,	0x001 },	/* 0xf70 - 0xf70 */
	{ 0xf6e,	0x001 },	/* 0xf6e - 0xf6e */
	{ 0xf6b,	0x002 },	/* 0xf6b - 0xf6c */
	{ 0xf6f,	0x001 },	/* 0xf6f - 0xf6f */
	{ 0xf73,	0x001 },	/* 0xf73 - 0xf73 */
	{ 0xf7d,	0x001 },	/* 0xf7d - 0xf7d */
	{ 0xf7c,	0x001 },	/* 0xf7c - 0xf7c */
	{ 0xf72,	0x001 },	/* 0xf72 - 0xf72 */
	{ 0xf76,	0x002 },	/* 0xf76 - 0xf77 */
	{ 0xf07,	0x001 },	/* 0xf07 - 0xf07 */
	{ 0xf0a,	0x001 },	/* 0xf0a - 0xf0a */
	{ 0xf08,	0x002 },	/* 0xf08 - 0xf09 */
	{ 0xf0b,	0x001 },	/* 0xf0b - 0xf0b */
	{ 0xf0e,	0x001 },	/* 0xf0e - 0xf0e */
	{ 0xf0c,	0x002 },	/* 0xf0c - 0xf0d */
	{ 0xd35,	0x001 },	/* 0xd35 - 0xd35 */
	{ 0xd34,	0x001 },	/* 0xd34 - 0xd34 */
	{ 0xd32,	0x001 },	/* 0xd32 - 0xd32 */
	{ 0xd37,	0x001 },	/* 0xd37 - 0xd37 */
	{ 0xd36,	0x001 },	/* 0xd36 - 0xd36 */
	{ 0x52b,	0x001 },	/* 0x52b - 0x52b */
	{ 0x315,	0x001 },	/* 0x315 - 0x315 */
	{ 0x317,	0x001 },	/* 0x317 - 0x317 */
	{ 0x314,	0x001 },	/* 0x314 - 0x314 */
	{ 0x316,	0x001 },	/* 0x316 - 0x316 */
	{ 0x319,	0x001 },	/* 0x319 - 0x319 */
	{ 0x31b,	0x001 },	/* 0x31b - 0x31b */
	{ 0x318,	0x001 },	/* 0x318 - 0x318 */
	{ 0x31a,	0x001 },	/* 0x31a - 0x31a */
	{ 0x30e,	0x001 },	/* 0x30e - 0x30e */
	{ 0x2ff,	0x001 },	/* 0x2ff - 0x2ff */
	{ 0x301,	0x001 },	/* 0x301 - 0x301 */
	{ 0x2fe,	0x001 },	/* 0x2fe - 0x2fe */
	{ 0x300,	0x001 },	/* 0x300 - 0x300 */
	{ 0x3c3,	0x001 },	/* 0x3c3 - 0x3c3 */
	{ 0x3c0,	0x001 },	/* 0x3c0 - 0x3c0 */
	{ 0x3bf,	0x001 },	/* 0x3bf - 0x3bf */
	{ 0x3be,	0x001 },	/* 0x3be - 0x3be */
	{ 0x014,	0x001 },	/* 0x014 - 0x014 */
	{ 0x010,	0x001 },	/* 0x010 - 0x010 */
	{ 0x00f,	0x001 },	/* 0x00f - 0x00f */
	{ 0x011,	0x001 },	/* 0x011 - 0x011 */
	{ 0x00e,	0x001 },	/* 0x00e - 0x00e */
	{ 0x16e,	0x001 },	/* 0x16e - 0x16e */
	{ 0x172,	0x001 },	/* 0x172 - 0x172 */
	{ 0x1eb,	0x001 },	/* 0x1eb - 0x1eb */
	{ 0x5b4,	0x001 },	/* 0x5b4 - 0x5b4 */
	{ 0x5bd,	0x003 },	/* 0x5bd - 0x5bf */
	{ 0x5b5,	0x008 },	/* 0x5b5 - 0x5bc */
	{ 0x47e,	0x002 },	/* 0x47e - 0x47f */
	{ 0x41a,	0x001 },	/* 0x41a - 0x41a */
	{ 0x3d3,	0x001 },	/* 0x3d3 - 0x3d3 */
	{ 0x3b8,	0x001 },	/* 0x3b8 - 0x3b8 */
	{ 0x289,	0x001 },	/* 0x289 - 0x289 */
	{ 0x3b7,	0x001 },	/* 0x3b7 - 0x3b7 */
	{ 0x077,	0x001 },	/* 0x077 - 0x077 */
	{ 0x079,	0x001 },	/* 0x079 - 0x079 */
	{ 0x3b6,	0x001 },	/* 0x3b6 - 0x3b6 */
	{ 0x076,	0x001 },	/* 0x076 - 0x076 */
	{ 0x072,	0x001 },	/* 0x072 - 0x072 */
	{ 0x648,	0x001 },	/* 0x648 - 0x648 */
	{ 0x848,	0x001 },	/* 0x848 - 0x848 */
	{ 0xa48,	0x001 },	/* 0xa48 - 0xa48 */
	{ 0x060,	0x001 },	/* 0x060 - 0x060 */
	{ 0x063,	0x002 },	/* 0x063 - 0x064 */
	{ 0x061,	0x002 },	/* 0x061 - 0x062 */
	{ 0x3ec,	0x001 },	/* 0x3ec - 0x3ec */
	{ 0x623,	0x001 },	/* 0x623 - 0x623 */
	{ 0x823,	0x001 },	/* 0x823 - 0x823 */
	{ 0xa23,	0x001 },	/* 0xa23 - 0xa23 */
	{ 0x624,	0x001 },	/* 0x624 - 0x624 */
	{ 0x824,	0x001 },	/* 0x824 - 0x824 */
	{ 0xa24,	0x001 },	/* 0xa24 - 0xa24 */
	{ 0x621,	0x001 },	/* 0x621 - 0x621 */
	{ 0x821,	0x001 },	/* 0x821 - 0x821 */
	{ 0xa21,	0x001 },	/* 0xa21 - 0xa21 */
	{ 0x620,	0x001 },	/* 0x620 - 0x620 */
	{ 0x820,	0x001 },	/* 0x820 - 0x820 */
	{ 0xa20,	0x001 },	/* 0xa20 - 0xa20 */
	{ 0x622,	0x001 },	/* 0x622 - 0x622 */
	{ 0x822,	0x001 },	/* 0x822 - 0x822 */
	{ 0xa22,	0x001 },	/* 0xa22 - 0xa22 */
	{ 0x3bc,	0x002 },	/* 0x3bc - 0x3bd */
	{ 0x007,	0x001 },	/* 0x007 - 0x007 */
	{ 0x02b,	0x001 },	/* 0x02b - 0x02b */
	{ 0x625,	0x007 },	/* 0x625 - 0x62b */
	{ 0x825,	0x007 },	/* 0x825 - 0x82b */
	{ 0xa25,	0x007 },	/* 0xa25 - 0xa2b */
	{ 0x065,	0x001 },	/* 0x065 - 0x065 */
	{ 0x7f2,	0x001 },	/* 0x7f2 - 0x7f2 */
	{ 0x9f2,	0x001 },	/* 0x9f2 - 0x9f2 */
	{ 0xbf2,	0x001 },	/* 0xbf2 - 0xbf2 */
	{ 0x7f3,	0x001 },	/* 0x7f3 - 0x7f3 */
	{ 0x9f3,	0x001 },	/* 0x9f3 - 0x9f3 */
	{ 0xbf3,	0x001 },	/* 0xbf3 - 0xbf3 */
	{ 0x7f1,	0x001 },	/* 0x7f1 - 0x7f1 */
	{ 0x9f1,	0x001 },	/* 0x9f1 - 0x9f1 */
	{ 0xbf1,	0x001 },	/* 0xbf1 - 0xbf1 */
	{ 0x7f0,	0x001 },	/* 0x7f0 - 0x7f0 */
	{ 0x9f0,	0x001 },	/* 0x9f0 - 0x9f0 */
	{ 0xbf0,	0x001 },	/* 0xbf0 - 0xbf0 */
	{ 0x7f4,	0x001 },	/* 0x7f4 - 0x7f4 */
	{ 0x9f4,	0x001 },	/* 0x9f4 - 0x9f4 */
	{ 0xbf4,	0x001 },	/* 0xbf4 - 0xbf4 */
	{ 0x605,	0x001 },	/* 0x605 - 0x605 */
	{ 0x805,	0x001 },	/* 0x805 - 0x805 */
	{ 0xa05,	0x001 },	/* 0xa05 - 0xa05 */
	{ 0x60b,	0x001 },	/* 0x60b - 0x60b */
	{ 0x80b,	0x001 },	/* 0x80b - 0x80b */
	{ 0xa0b,	0x001 },	/* 0xa0b - 0xa0b */
	{ 0x60e,	0x001 },	/* 0x60e - 0x60e */
	{ 0x80e,	0x001 },	/* 0x80e - 0x80e */
	{ 0xa0e,	0x001 },	/* 0xa0e - 0xa0e */
	{ 0x60c,	0x001 },	/* 0x60c - 0x60c */
	{ 0x80c,	0x001 },	/* 0x80c - 0x80c */
	{ 0xa0c,	0x001 },	/* 0xa0c - 0xa0c */
	{ 0x604,	0x001 },	/* 0x604 - 0x604 */
	{ 0x804,	0x001 },	/* 0x804 - 0x804 */
	{ 0xa04,	0x001 },	/* 0xa04 - 0xa04 */
	{ 0x60a,	0x001 },	/* 0x60a - 0x60a */
	{ 0x80a,	0x001 },	/* 0x80a - 0x80a */
	{ 0xa0a,	0x001 },	/* 0xa0a - 0xa0a */
	{ 0x60d,	0x001 },	/* 0x60d - 0x60d */
	{ 0x80d,	0x001 },	/* 0x80d - 0x80d */
	{ 0xa0d,	0x001 },	/* 0xa0d - 0xa0d */
	{ 0x60f,	0x001 },	/* 0x60f - 0x60f */
	{ 0x80f,	0x001 },	/* 0x80f - 0x80f */
	{ 0xa0f,	0x001 },	/* 0xa0f - 0xa0f */
	{ 0x0b9,	0x001 },	/* 0x0b9 - 0x0b9 */
	{ 0x0b0,	0x009 },	/* 0x0b0 - 0x0b8 */
	{ 0x0d7,	0x001 },	/* 0x0d7 - 0x0d7 */
	{ 0x0ce,	0x009 },	/* 0x0ce - 0x0d6 */
	{ 0x0e1,	0x001 },	/* 0x0e1 - 0x0e1 */
	{ 0x0d8,	0x009 },	/* 0x0d8 - 0x0e0 */
	{ 0x0c3,	0x001 },	/* 0x0c3 - 0x0c3 */
	{ 0x0ba,	0x009 },	/* 0x0ba - 0x0c2 */
	{ 0x0eb,	0x001 },	/* 0x0eb - 0x0eb */
	{ 0x0e2,	0x009 },	/* 0x0e2 - 0x0ea */
	{ 0x0cd,	0x001 },	/* 0x0cd - 0x0cd */
	{ 0x0c4,	0x009 },	/* 0x0c4 - 0x0cc */
	{ 0x10a,	0x001 },	/* 0x10a - 0x10a */
	{ 0x0f5,	0x001 },	/* 0x0f5 - 0x0f5 */
	{ 0x0ec,	0x009 },	/* 0x0ec - 0x0f4 */
	{ 0x0ff,	0x001 },	/* 0x0ff - 0x0ff */
	{ 0x0f6,	0x009 },	/* 0x0f6 - 0x0fe */
	{ 0x109,	0x001 },	/* 0x109 - 0x109 */
	{ 0x100,	0x009 },	/* 0x100 - 0x108 */
	{ 0x3ef,	0x001 },	/* 0x3ef - 0x3ef */
	{ 0x028,	0x001 },	/* 0x028 - 0x028 */
	{ 0x781,	0x001 },	/* 0x781 - 0x781 */
	{ 0x981,	0x001 },	/* 0x981 - 0x981 */
	{ 0xb81,	0x001 },	/* 0xb81 - 0xb81 */
	{ 0x780,	0x001 },	/* 0x780 - 0x780 */
	{ 0x980,	0x001 },	/* 0x980 - 0x980 */
	{ 0xb80,	0x001 },	/* 0xb80 - 0xb80 */
	{ 0x027,	0x001 },	/* 0x027 - 0x027 */
	{ 0x020,	0x001 },	/* 0x020 - 0x020 */
	{ 0x02a,	0x001 },	/* 0x02a - 0x02a */
	{ 0x029,	0x001 },	/* 0x029 - 0x029 */
	{ 0x643,	0x001 },	/* 0x643 - 0x643 */
	{ 0x843,	0x001 },	/* 0x843 - 0x843 */
	{ 0xa43,	0x001 },	/* 0xa43 - 0xa43 */
	{ 0x647,	0x001 },	/* 0x647 - 0x647 */
	{ 0x847,	0x001 },	/* 0x847 - 0x847 */
	{ 0xa47,	0x001 },	/* 0xa47 - 0xa47 */
	{ 0x073,	0x001 },	/* 0x073 - 0x073 */
	{ 0x070,	0x001 },	/* 0x070 - 0x070 */
	{ 0x641,	0x001 },	/* 0x641 - 0x641 */
	{ 0x841,	0x001 },	/* 0x841 - 0x841 */
	{ 0xa41,	0x001 },	/* 0xa41 - 0xa41 */
	{ 0x074,	0x001 },	/* 0x074 - 0x074 */
	{ 0x64a,	0x001 },	/* 0x64a - 0x64a */
	{ 0x84a,	0x001 },	/* 0x84a - 0x84a */
	{ 0xa4a,	0x001 },	/* 0xa4a - 0xa4a */
	{ 0x645,	0x001 },	/* 0x645 - 0x645 */
	{ 0x845,	0x001 },	/* 0x845 - 0x845 */
	{ 0xa45,	0x001 },	/* 0xa45 - 0xa45 */
	{ 0x64c,	0x001 },	/* 0x64c - 0x64c */
	{ 0x84c,	0x001 },	/* 0x84c - 0x84c */
	{ 0xa4c,	0x001 },	/* 0xa4c - 0xa4c */
	{ 0x644,	0x001 },	/* 0x644 - 0x644 */
	{ 0x844,	0x001 },	/* 0x844 - 0x844 */
	{ 0xa44,	0x001 },	/* 0xa44 - 0xa44 */
	{ 0x071,	0x001 },	/* 0x071 - 0x071 */
	{ 0x64b,	0x001 },	/* 0x64b - 0x64b */
	{ 0x84b,	0x001 },	/* 0x84b - 0x84b */
	{ 0xa4b,	0x001 },	/* 0xa4b - 0xa4b */
	{ 0x649,	0x001 },	/* 0x649 - 0x649 */
	{ 0x849,	0x001 },	/* 0x849 - 0x849 */
	{ 0xa49,	0x001 },	/* 0xa49 - 0xa49 */
	{ 0x075,	0x001 },	/* 0x075 - 0x075 */
	{ 0x64f,	0x001 },	/* 0x64f - 0x64f */
	{ 0x84f,	0x001 },	/* 0x84f - 0x84f */
	{ 0xa4f,	0x001 },	/* 0xa4f - 0xa4f */
	{ 0x640,	0x001 },	/* 0x640 - 0x640 */
	{ 0x840,	0x001 },	/* 0x840 - 0x840 */
	{ 0xa40,	0x001 },	/* 0xa40 - 0xa40 */
	{ 0x646,	0x001 },	/* 0x646 - 0x646 */
	{ 0x846,	0x001 },	/* 0x846 - 0x846 */
	{ 0xa46,	0x001 },	/* 0xa46 - 0xa46 */
	{ 0x026,	0x001 },	/* 0x026 - 0x026 */
	{ 0x601,	0x001 },	/* 0x601 - 0x601 */
	{ 0x801,	0x001 },	/* 0x801 - 0x801 */
	{ 0xa01,	0x001 },	/* 0xa01 - 0xa01 */
	{ 0x603,	0x001 },	/* 0x603 - 0x603 */
	{ 0x602,	0x001 },	/* 0x602 - 0x602 */
	{ 0x803,	0x001 },	/* 0x803 - 0x803 */
	{ 0x802,	0x001 },	/* 0x802 - 0x802 */
	{ 0xa03,	0x001 },	/* 0xa03 - 0xa03 */
	{ 0xa02,	0x001 },	/* 0xa02 - 0xa02 */
	{ 0x607,	0x001 },	/* 0x607 - 0x607 */
	{ 0x606,	0x001 },	/* 0x606 - 0x606 */
	{ 0x807,	0x001 },	/* 0x807 - 0x807 */
	{ 0x806,	0x001 },	/* 0x806 - 0x806 */
	{ 0xa07,	0x001 },	/* 0xa07 - 0xa07 */
	{ 0xa06,	0x001 },	/* 0xa06 - 0xa06 */
	{ 0x608,	0x001 },	/* 0x608 - 0x608 */
	{ 0x808,	0x001 },	/* 0x808 - 0x808 */
	{ 0xa08,	0x001 },	/* 0xa08 - 0xa08 */
	{ 0x025,	0x001 },	/* 0x025 - 0x025 */
	{ 0x022,	0x001 },	/* 0x022 - 0x022 */
	{ 0x049,	0x006 },	/* 0x049 - 0x04e */
	{ 0x045,	0x001 },	/* 0x045 - 0x045 */
	{ 0x791,	0x001 },	/* 0x791 - 0x791 */
	{ 0x991,	0x001 },	/* 0x991 - 0x991 */
	{ 0xb91,	0x001 },	/* 0xb91 - 0xb91 */
	{ 0x790,	0x001 },	/* 0x790 - 0x790 */
	{ 0x990,	0x001 },	/* 0x990 - 0x990 */
	{ 0xb90,	0x001 },	/* 0xb90 - 0xb90 */
	{ 0x158,	0x001 },	/* 0x158 - 0x158 */
	{ 0x157,	0x001 },	/* 0x157 - 0x157 */
	{ 0x024,	0x001 },	/* 0x024 - 0x024 */
	{ 0x1cc,	0x001 },	/* 0x1cc - 0x1cc */
	{ 0x1ca,	0x002 },	/* 0x1ca - 0x1cb */
	{ 0x1d8,	0x006 },	/* 0x1d8 - 0x1dd */
	{ 0x529,	0x001 },	/* 0x529 - 0x529 */
	{ 0x528,	0x001 },	/* 0x528 - 0x528 */
	{ 0x527,	0x001 },	/* 0x527 - 0x527 */
	{ 0x526,	0x001 },	/* 0x526 - 0x526 */
	{ 0x525,	0x001 },	/* 0x525 - 0x525 */
	{ 0x524,	0x001 },	/* 0x524 - 0x524 */
	{ 0x58f,	0x001 },	/* 0x58f - 0x58f */
	{ 0xd21,	0x001 },	/* 0xd21 - 0xd21 */
	{ 0x2d2,	0x001 },	/* 0x2d2 - 0x2d2 */
	{ 0x2d5,	0x001 },	/* 0x2d5 - 0x2d5 */
	{ 0x441,	0x001 },	/* 0x441 - 0x441 */
	{ 0x43f,	0x002 },	/* 0x43f - 0x440 */
	{ 0x43c,	0x003 },	/* 0x43c - 0x43e */
	{ 0x439,	0x003 },	/* 0x439 - 0x43b */
	{ 0x48b,	0x001 },	/* 0x48b - 0x48b */
	{ 0x39b,	0x001 },	/* 0x39b - 0x39b */
	{ 0x494,	0x001 },	/* 0x494 - 0x494 */
	{ 0x49b,	0x002 },	/* 0x49b - 0x49c */
	{ 0x531,	0x001 },	/* 0x531 - 0x531 */
	{ 0x530,	0x001 },	/* 0x530 - 0x530 */
	{ 0x533,	0x001 },	/* 0x533 - 0x533 */
	{ 0x532,	0x001 },	/* 0x532 - 0x532 */
	{ 0x537,	0x001 },	/* 0x537 - 0x537 */
	{ 0x536,	0x001 },	/* 0x536 - 0x536 */
	{ 0x535,	0x001 },	/* 0x535 - 0x535 */
	{ 0x534,	0x001 },	/* 0x534 - 0x534 */
	{ 0x539,	0x001 },	/* 0x539 - 0x539 */
	{ 0x538,	0x001 },	/* 0x538 - 0x538 */
	{ 0x53b,	0x001 },	/* 0x53b - 0x53b */
	{ 0x53a,	0x001 },	/* 0x53a - 0x53a */
	{ 0x489,	0x001 },	/* 0x489 - 0x489 */
	{ 0x488,	0x001 },	/* 0x488 - 0x488 */
	{ 0x48a,	0x001 },	/* 0x48a - 0x48a */
	{ 0x768,	0x001 },	/* 0x768 - 0x768 */
	{ 0x968,	0x001 },	/* 0x968 - 0x968 */
	{ 0xb68,	0x001 },	/* 0xb68 - 0xb68 */
	{ 0x4b7,	0x001 },	/* 0x4b7 - 0x4b7 */
	{ 0x48c,	0x002 },	/* 0x48c - 0x48d */
	{ 0x4e2,	0x001 },	/* 0x4e2 - 0x4e2 */
	{ 0x4e0,	0x002 },	/* 0x4e0 - 0x4e1 */
	{ 0x4df,	0x001 },	/* 0x4df - 0x4df */
	{ 0x4e6,	0x001 },	/* 0x4e6 - 0x4e6 */
	{ 0x4e4,	0x002 },	/* 0x4e4 - 0x4e5 */
	{ 0x4e3,	0x001 },	/* 0x4e3 - 0x4e3 */
	{ 0x4dd,	0x001 },	/* 0x4dd - 0x4dd */
	{ 0x4d9,	0x001 },	/* 0x4d9 - 0x4d9 */
	{ 0x4db,	0x001 },	/* 0x4db - 0x4db */
	{ 0x4d7,	0x001 },	/* 0x4d7 - 0x4d7 */
	{ 0x4de,	0x001 },	/* 0x4de - 0x4de */
	{ 0x4da,	0x001 },	/* 0x4da - 0x4da */
	{ 0x4dc,	0x001 },	/* 0x4dc - 0x4dc */
	{ 0x4d8,	0x001 },	/* 0x4d8 - 0x4d8 */
	{ 0x53d,	0x001 },	/* 0x53d - 0x53d */
	{ 0x53c,	0x001 },	/* 0x53c - 0x53c */
	{ 0x53f,	0x001 },	/* 0x53f - 0x53f */
	{ 0x53e,	0x001 },	/* 0x53e - 0x53e */
	{ 0x485,	0x001 },	/* 0x485 - 0x485 */
	{ 0x763,	0x001 },	/* 0x763 - 0x763 */
	{ 0x963,	0x001 },	/* 0x963 - 0x963 */
	{ 0xb63,	0x001 },	/* 0xb63 - 0xb63 */
	{ 0x764,	0x001 },	/* 0x764 - 0x764 */
	{ 0x964,	0x001 },	/* 0x964 - 0x964 */
	{ 0xb64,	0x001 },	/* 0xb64 - 0xb64 */
	{ 0x765,	0x001 },	/* 0x765 - 0x765 */
	{ 0x965,	0x001 },	/* 0x965 - 0x965 */
	{ 0xb65,	0x001 },	/* 0xb65 - 0xb65 */
	{ 0x760,	0x001 },	/* 0x760 - 0x760 */
	{ 0x960,	0x001 },	/* 0x960 - 0x960 */
	{ 0xb60,	0x001 },	/* 0xb60 - 0xb60 */
	{ 0x761,	0x001 },	/* 0x761 - 0x761 */
	{ 0x961,	0x001 },	/* 0x961 - 0x961 */
	{ 0xb61,	0x001 },	/* 0xb61 - 0xb61 */
	{ 0x762,	0x001 },	/* 0x762 - 0x762 */
	{ 0x962,	0x001 },	/* 0x962 - 0x962 */
	{ 0xb62,	0x001 },	/* 0xb62 - 0xb62 */
	{ 0x484,	0x001 },	/* 0x484 - 0x484 */
	{ 0x541,	0x001 },	/* 0x541 - 0x541 */
	{ 0x540,	0x001 },	/* 0x540 - 0x540 */
	{ 0x487,	0x001 },	/* 0x487 - 0x487 */
	{ 0x486,	0x001 },	/* 0x486 - 0x486 */
	{ 0x48f,	0x001 },	/* 0x48f - 0x48f */
	{ 0x766,	0x001 },	/* 0x766 - 0x766 */
	{ 0x966,	0x001 },	/* 0x966 - 0x966 */
	{ 0xb66,	0x001 },	/* 0xb66 - 0xb66 */
	{ 0x493,	0x001 },	/* 0x493 - 0x493 */
	{ 0x497,	0x002 },	/* 0x497 - 0x498 */
	{ 0x49e,	0x002 },	/* 0x49e - 0x49f */
	{ 0x4f2,	0x002 },	/* 0x4f2 - 0x4f3 */
	{ 0x495,	0x001 },	/* 0x495 - 0x495 */
	{ 0x492,	0x001 },	/* 0x492 - 0x492 */
	{ 0x491,	0x001 },	/* 0x491 - 0x491 */
	{ 0x4f7,	0x001 },	/* 0x4f7 - 0x4f7 */
	{ 0x4fb,	0x001 },	/* 0x4fb - 0x4fb */
	{ 0x001,	0x001 },	/* 0x001 - 0x001 */
	{ 0x6e6,	0x001 },	/* 0x6e6 - 0x6e6 */
	{ 0x6fa,	0x001 },	/* 0x6fa - 0x6fa */
	{ 0x6e4,	0x002 },	/* 0x6e4 - 0x6e5 */
	{ 0x6de,	0x002 },	/* 0x6de - 0x6df */
	{ 0x6e2,	0x001 },	/* 0x6e2 - 0x6e2 */
	{ 0x6e0,	0x002 },	/* 0x6e0 - 0x6e1 */
	{ 0x6e8,	0x001 },	/* 0x6e8 - 0x6e8 */
	{ 0x6dc,	0x002 },	/* 0x6dc - 0x6dd */
	{ 0x6d6,	0x001 },	/* 0x6d6 - 0x6d6 */
	{ 0x6ee,	0x001 },	/* 0x6ee - 0x6ee */
	{ 0x8e6,	0x001 },	/* 0x8e6 - 0x8e6 */
	{ 0x8fa,	0x001 },	/* 0x8fa - 0x8fa */
	{ 0x8e4,	0x002 },	/* 0x8e4 - 0x8e5 */
	{ 0x8de,	0x002 },	/* 0x8de - 0x8df */
	{ 0x8e2,	0x001 },	/* 0x8e2 - 0x8e2 */
	{ 0x8e0,	0x002 },	/* 0x8e0 - 0x8e1 */
	{ 0x8e8,	0x001 },	/* 0x8e8 - 0x8e8 */
	{ 0x8dc,	0x002 },	/* 0x8dc - 0x8dd */
	{ 0x8d6,	0x001 },	/* 0x8d6 - 0x8d6 */
	{ 0x8ee,	0x001 },	/* 0x8ee - 0x8ee */
	{ 0xae6,	0x001 },	/* 0xae6 - 0xae6 */
	{ 0xafa,	0x001 },	/* 0xafa - 0xafa */
	{ 0xae4,	0x002 },	/* 0xae4 - 0xae5 */
	{ 0xade,	0x002 },	/* 0xade - 0xadf */
	{ 0xae2,	0x001 },	/* 0xae2 - 0xae2 */
	{ 0xae0,	0x002 },	/* 0xae0 - 0xae1 */
	{ 0xae8,	0x001 },	/* 0xae8 - 0xae8 */
	{ 0xadc,	0x002 },	/* 0xadc - 0xadd */
	{ 0xad6,	0x001 },	/* 0xad6 - 0xad6 */
	{ 0xaee,	0x001 },	/* 0xaee - 0xaee */
	{ 0x197,	0x001 },	/* 0x197 - 0x197 */
	{ 0x213,	0x001 },	/* 0x213 - 0x213 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x214,	0x001 },	/* 0x214 - 0x214 */
	{ 0x216,	0x001 },	/* 0x216 - 0x216 */
	{ 0x215,	0x001 },	/* 0x215 - 0x215 */
	{ 0xc17,	0x001 },	/* 0xc17 - 0xc17 */
	{ 0x17a,	0x002 },	/* 0x17a - 0x17b */
	{ 0x2d6,	0x002 },	/* 0x2d6 - 0x2d7 */
	{ 0x1b4,	0x001 },	/* 0x1b4 - 0x1b4 */
	{ 0x400,	0x001 },	/* 0x400 - 0x400 */
	{ 0x6f7,	0x001 },	/* 0x6f7 - 0x6f7 */
	{ 0x8f7,	0x001 },	/* 0x8f7 - 0x8f7 */
	{ 0xaf7,	0x001 },	/* 0xaf7 - 0xaf7 */
	{ 0x29c,	0x001 },	/* 0x29c - 0x29c */
	{ 0x000,	0x001 },	/* 0x000 - 0x000 */
	{ 0,	0 }
};

static phy_regs_t acphy3_regs[] = {
	{ 0xc15,	0x001 },	/* 0xc15 - 0xc15 */
	{ 0xc14,	0x001 },	/* 0xc14 - 0xc14 */
	{ 0xc16,	0x001 },	/* 0xc16 - 0xc16 */
	{ 0x1f8,	0x001 },	/* 0x1f8 - 0x1f8 */
	{ 0x5b0,	0x001 },	/* 0x5b0 - 0x5b0 */
	{ 0x5af,	0x001 },	/* 0x5af - 0x5af */
	{ 0x5b1,	0x001 },	/* 0x5b1 - 0x5b1 */
	{ 0x7aa,	0x001 },	/* 0x7aa - 0x7aa */
	{ 0x9aa,	0x001 },	/* 0x9aa - 0x9aa */
	{ 0x7a9,	0x001 },	/* 0x7a9 - 0x7a9 */
	{ 0x9a9,	0x001 },	/* 0x9a9 - 0x9a9 */
	{ 0x7a8,	0x001 },	/* 0x7a8 - 0x7a8 */
	{ 0x9a8,	0x001 },	/* 0x9a8 - 0x9a8 */
	{ 0x5a1,	0x001 },	/* 0x5a1 - 0x5a1 */
	{ 0x5a0,	0x001 },	/* 0x5a0 - 0x5a0 */
	{ 0x5a6,	0x002 },	/* 0x5a6 - 0x5a7 */
	{ 0x5a4,	0x002 },	/* 0x5a4 - 0x5a5 */
	{ 0x5aa,	0x001 },	/* 0x5aa - 0x5aa */
	{ 0x5a9,	0x001 },	/* 0x5a9 - 0x5a9 */
	{ 0x5a8,	0x001 },	/* 0x5a8 - 0x5a8 */
	{ 0x5ae,	0x001 },	/* 0x5ae - 0x5ae */
	{ 0x7a3,	0x001 },	/* 0x7a3 - 0x7a3 */
	{ 0x9a3,	0x001 },	/* 0x9a3 - 0x9a3 */
	{ 0x7a1,	0x001 },	/* 0x7a1 - 0x7a1 */
	{ 0x9a1,	0x001 },	/* 0x9a1 - 0x9a1 */
	{ 0x7a7,	0x001 },	/* 0x7a7 - 0x7a7 */
	{ 0x7a6,	0x001 },	/* 0x7a6 - 0x7a6 */
	{ 0x9a7,	0x001 },	/* 0x9a7 - 0x9a7 */
	{ 0x9a6,	0x001 },	/* 0x9a6 - 0x9a6 */
	{ 0x7a2,	0x001 },	/* 0x7a2 - 0x7a2 */
	{ 0x9a2,	0x001 },	/* 0x9a2 - 0x9a2 */
	{ 0x7a0,	0x001 },	/* 0x7a0 - 0x7a0 */
	{ 0x9a0,	0x001 },	/* 0x9a0 - 0x9a0 */
	{ 0x7a5,	0x001 },	/* 0x7a5 - 0x7a5 */
	{ 0x7a4,	0x001 },	/* 0x7a4 - 0x7a4 */
	{ 0x9a5,	0x001 },	/* 0x9a5 - 0x9a5 */
	{ 0x9a4,	0x001 },	/* 0x9a4 - 0x9a4 */
	{ 0x7ac,	0x001 },	/* 0x7ac - 0x7ac */
	{ 0x9ac,	0x001 },	/* 0x9ac - 0x9ac */
	{ 0x7ab,	0x001 },	/* 0x7ab - 0x7ab */
	{ 0x9ab,	0x001 },	/* 0x9ab - 0x9ab */
	{ 0x5a2,	0x002 },	/* 0x5a2 - 0x5a3 */
	{ 0x1fa,	0x001 },	/* 0x1fa - 0x1fa */
	{ 0x5ab,	0x001 },	/* 0x5ab - 0x5ab */
	{ 0x1f9,	0x001 },	/* 0x1f9 - 0x1f9 */
	{ 0x5b2,	0x001 },	/* 0x5b2 - 0x5b2 */
	{ 0x5ad,	0x001 },	/* 0x5ad - 0x5ad */
	{ 0x5ac,	0x001 },	/* 0x5ac - 0x5ac */
	{ 0x165,	0x003 },	/* 0x165 - 0x167 */
	{ 0x52a,	0x001 },	/* 0x52a - 0x52a */
	{ 0x467,	0x001 },	/* 0x467 - 0x467 */
	{ 0x596,	0x001 },	/* 0x596 - 0x596 */
	{ 0x598,	0x001 },	/* 0x598 - 0x598 */
	{ 0x595,	0x001 },	/* 0x595 - 0x595 */
	{ 0x594,	0x001 },	/* 0x594 - 0x594 */
	{ 0x592,	0x002 },	/* 0x592 - 0x593 */
	{ 0x410,	0x001 },	/* 0x410 - 0x410 */
	{ 0x749,	0x001 },	/* 0x749 - 0x749 */
	{ 0x949,	0x001 },	/* 0x949 - 0x949 */
	{ 0x751,	0x001 },	/* 0x751 - 0x751 */
	{ 0x951,	0x001 },	/* 0x951 - 0x951 */
	{ 0x752,	0x001 },	/* 0x752 - 0x752 */
	{ 0x952,	0x001 },	/* 0x952 - 0x952 */
	{ 0x753,	0x001 },	/* 0x753 - 0x753 */
	{ 0x953,	0x001 },	/* 0x953 - 0x953 */
	{ 0x750,	0x001 },	/* 0x750 - 0x750 */
	{ 0x950,	0x001 },	/* 0x950 - 0x950 */
	{ 0x40f,	0x001 },	/* 0x40f - 0x40f */
	{ 0x42d,	0x001 },	/* 0x42d - 0x42d */
	{ 0x428,	0x001 },	/* 0x428 - 0x428 */
	{ 0x42c,	0x001 },	/* 0x42c - 0x42c */
	{ 0x42b,	0x001 },	/* 0x42b - 0x42b */
	{ 0x42a,	0x001 },	/* 0x42a - 0x42a */
	{ 0x429,	0x001 },	/* 0x429 - 0x429 */
	{ 0x424,	0x001 },	/* 0x424 - 0x424 */
	{ 0x422,	0x001 },	/* 0x422 - 0x422 */
	{ 0x420,	0x001 },	/* 0x420 - 0x420 */
	{ 0x426,	0x001 },	/* 0x426 - 0x426 */
	{ 0x425,	0x001 },	/* 0x425 - 0x425 */
	{ 0x423,	0x001 },	/* 0x423 - 0x423 */
	{ 0x421,	0x001 },	/* 0x421 - 0x421 */
	{ 0x427,	0x001 },	/* 0x427 - 0x427 */
	{ 0x3b3,	0x001 },	/* 0x3b3 - 0x3b3 */
	{ 0x3d4,	0x001 },	/* 0x3d4 - 0x3d4 */
	{ 0x407,	0x001 },	/* 0x407 - 0x407 */
	{ 0x251,	0x001 },	/* 0x251 - 0x251 */
	{ 0x253,	0x001 },	/* 0x253 - 0x253 */
	{ 0x252,	0x001 },	/* 0x252 - 0x252 */
	{ 0x254,	0x001 },	/* 0x254 - 0x254 */
	{ 0x162,	0x001 },	/* 0x162 - 0x162 */
	{ 0x161,	0x001 },	/* 0x161 - 0x161 */
	{ 0x406,	0x001 },	/* 0x406 - 0x406 */
	{ 0x691,	0x001 },	/* 0x691 - 0x691 */
	{ 0x891,	0x001 },	/* 0x891 - 0x891 */
	{ 0x001,	0x001 },	/* 0x001 - 0x001 */
	{ 0x454,	0x006 },	/* 0x454 - 0x459 */
	{ 0x442,	0x002 },	/* 0x442 - 0x443 */
	{ 0x44a,	0x00a },	/* 0x44a - 0x453 */
	{ 0x446,	0x001 },	/* 0x446 - 0x446 */
	{ 0x445,	0x001 },	/* 0x445 - 0x445 */
	{ 0x444,	0x001 },	/* 0x444 - 0x444 */
	{ 0x447,	0x003 },	/* 0x447 - 0x449 */
	{ 0x45a,	0x001 },	/* 0x45a - 0x45a */
	{ 0x430,	0x004 },	/* 0x430 - 0x433 */
	{ 0x023,	0x001 },	/* 0x023 - 0x023 */
	{ 0x434,	0x005 },	/* 0x434 - 0x438 */
	{ 0x441,	0x001 },	/* 0x441 - 0x441 */
	{ 0x43f,	0x002 },	/* 0x43f - 0x440 */
	{ 0x3e6,	0x001 },	/* 0x3e6 - 0x3e6 */
	{ 0x363,	0x001 },	/* 0x363 - 0x363 */
	{ 0x1fb,	0x001 },	/* 0x1fb - 0x1fb */
	{ 0x15e,	0x001 },	/* 0x15e - 0x15e */
	{ 0x351,	0x003 },	/* 0x351 - 0x353 */
	{ 0x34d,	0x004 },	/* 0x34d - 0x350 */
	{ 0x3a1,	0x001 },	/* 0x3a1 - 0x3a1 */
	{ 0x3a8,	0x001 },	/* 0x3a8 - 0x3a8 */
	{ 0x390,	0x002 },	/* 0x390 - 0x391 */
	{ 0x397,	0x002 },	/* 0x397 - 0x398 */
	{ 0x396,	0x001 },	/* 0x396 - 0x396 */
	{ 0x399,	0x002 },	/* 0x399 - 0x39a */
	{ 0x293,	0x003 },	/* 0x293 - 0x295 */
	{ 0x3a6,	0x001 },	/* 0x3a6 - 0x3a6 */
	{ 0x174,	0x001 },	/* 0x174 - 0x174 */
	{ 0x35b,	0x008 },	/* 0x35b - 0x362 */
	{ 0x3a2,	0x004 },	/* 0x3a2 - 0x3a5 */
	{ 0x3a9,	0x001 },	/* 0x3a9 - 0x3a9 */
	{ 0x46a,	0x001 },	/* 0x46a - 0x46a */
	{ 0x3a7,	0x001 },	/* 0x3a7 - 0x3a7 */
	{ 0x3f0,	0x001 },	/* 0x3f0 - 0x3f0 */
	{ 0x29b,	0x001 },	/* 0x29b - 0x29b */
	{ 0x418,	0x001 },	/* 0x418 - 0x418 */
	{ 0x40a,	0x001 },	/* 0x40a - 0x40a */
	{ 0xc01,	0x001 },	/* 0xc01 - 0xc01 */
	{ 0xc04,	0x001 },	/* 0xc04 - 0xc04 */
	{ 0xc02,	0x002 },	/* 0xc02 - 0xc03 */
	{ 0x371,	0x006 },	/* 0x371 - 0x376 */
	{ 0x04f,	0x001 },	/* 0x04f - 0x04f */
	{ 0x795,	0x001 },	/* 0x795 - 0x795 */
	{ 0x995,	0x001 },	/* 0x995 - 0x995 */
	{ 0x794,	0x001 },	/* 0x794 - 0x794 */
	{ 0x994,	0x001 },	/* 0x994 - 0x994 */
	{ 0x1ea,	0x001 },	/* 0x1ea - 0x1ea */
	{ 0x496,	0x001 },	/* 0x496 - 0x496 */
	{ 0x3d1,	0x002 },	/* 0x3d1 - 0x3d2 */
	{ 0x3d6,	0x001 },	/* 0x3d6 - 0x3d6 */
	{ 0x170,	0x001 },	/* 0x170 - 0x170 */
	{ 0x296,	0x001 },	/* 0x296 - 0x296 */
	{ 0x3d8,	0x002 },	/* 0x3d8 - 0x3d9 */
	{ 0x2d0,	0x001 },	/* 0x2d0 - 0x2d0 */
	{ 0x003,	0x002 },	/* 0x003 - 0x004 */
	{ 0x2d3,	0x002 },	/* 0x2d3 - 0x2d4 */
	{ 0xc30,	0x004 },	/* 0xc30 - 0xc33 */
	{ 0x140,	0x001 },	/* 0x140 - 0x140 */
	{ 0x30f,	0x005 },	/* 0x30f - 0x313 */
	{ 0x1e2,	0x001 },	/* 0x1e2 - 0x1e2 */
	{ 0x1e4,	0x001 },	/* 0x1e4 - 0x1e4 */
	{ 0x1e3,	0x001 },	/* 0x1e3 - 0x1e3 */
	{ 0x1e5,	0x001 },	/* 0x1e5 - 0x1e5 */
	{ 0x29e,	0x001 },	/* 0x29e - 0x29e */
	{ 0x48b,	0x001 },	/* 0x48b - 0x48b */
	{ 0x2e7,	0x002 },	/* 0x2e7 - 0x2e8 */
	{ 0x6e6,	0x001 },	/* 0x6e6 - 0x6e6 */
	{ 0x6ea,	0x001 },	/* 0x6ea - 0x6ea */
	{ 0x6f8,	0x001 },	/* 0x6f8 - 0x6f8 */
	{ 0x6fd,	0x001 },	/* 0x6fd - 0x6fd */
	{ 0x6fa,	0x003 },	/* 0x6fa - 0x6fc */
	{ 0x6e9,	0x001 },	/* 0x6e9 - 0x6e9 */
	{ 0x6f9,	0x001 },	/* 0x6f9 - 0x6f9 */
	{ 0x6ed,	0x001 },	/* 0x6ed - 0x6ed */
	{ 0x6d2,	0x002 },	/* 0x6d2 - 0x6d3 */
	{ 0x6d5,	0x001 },	/* 0x6d5 - 0x6d5 */
	{ 0x6d1,	0x001 },	/* 0x6d1 - 0x6d1 */
	{ 0x6d7,	0x001 },	/* 0x6d7 - 0x6d7 */
	{ 0x6da,	0x001 },	/* 0x6da - 0x6da */
	{ 0x6e4,	0x002 },	/* 0x6e4 - 0x6e5 */
	{ 0x6db,	0x001 },	/* 0x6db - 0x6db */
	{ 0x6de,	0x002 },	/* 0x6de - 0x6df */
	{ 0x6e2,	0x002 },	/* 0x6e2 - 0x6e3 */
	{ 0x6e0,	0x002 },	/* 0x6e0 - 0x6e1 */
	{ 0x6d4,	0x001 },	/* 0x6d4 - 0x6d4 */
	{ 0x6d0,	0x001 },	/* 0x6d0 - 0x6d0 */
	{ 0x6d8,	0x001 },	/* 0x6d8 - 0x6d8 */
	{ 0x6ef,	0x001 },	/* 0x6ef - 0x6ef */
	{ 0x6e8,	0x001 },	/* 0x6e8 - 0x6e8 */
	{ 0x6dc,	0x002 },	/* 0x6dc - 0x6dd */
	{ 0x6e7,	0x001 },	/* 0x6e7 - 0x6e7 */
	{ 0x6d6,	0x001 },	/* 0x6d6 - 0x6d6 */
	{ 0x6eb,	0x002 },	/* 0x6eb - 0x6ec */
	{ 0x6ee,	0x001 },	/* 0x6ee - 0x6ee */
	{ 0x6d9,	0x001 },	/* 0x6d9 - 0x6d9 */
	{ 0x6f2,	0x002 },	/* 0x6f2 - 0x6f3 */
	{ 0x6f0,	0x002 },	/* 0x6f0 - 0x6f1 */
	{ 0x6f4,	0x001 },	/* 0x6f4 - 0x6f4 */
	{ 0x8e6,	0x001 },	/* 0x8e6 - 0x8e6 */
	{ 0x8ea,	0x001 },	/* 0x8ea - 0x8ea */
	{ 0x8f8,	0x001 },	/* 0x8f8 - 0x8f8 */
	{ 0x8fd,	0x001 },	/* 0x8fd - 0x8fd */
	{ 0x8fa,	0x003 },	/* 0x8fa - 0x8fc */
	{ 0x8e9,	0x001 },	/* 0x8e9 - 0x8e9 */
	{ 0x8f9,	0x001 },	/* 0x8f9 - 0x8f9 */
	{ 0x8ed,	0x001 },	/* 0x8ed - 0x8ed */
	{ 0x8d2,	0x001 },	/* 0x8d2 - 0x8d2 */
	{ 0x6a2,	0x002 },	/* 0x6a2 - 0x6a3 */
	{ 0x8d3,	0x001 },	/* 0x8d3 - 0x8d3 */
	{ 0x8d5,	0x001 },	/* 0x8d5 - 0x8d5 */
	{ 0x8d1,	0x001 },	/* 0x8d1 - 0x8d1 */
	{ 0x8d7,	0x001 },	/* 0x8d7 - 0x8d7 */
	{ 0x8da,	0x001 },	/* 0x8da - 0x8da */
	{ 0x8e4,	0x002 },	/* 0x8e4 - 0x8e5 */
	{ 0x8db,	0x001 },	/* 0x8db - 0x8db */
	{ 0x8de,	0x002 },	/* 0x8de - 0x8df */
	{ 0x8e2,	0x002 },	/* 0x8e2 - 0x8e3 */
	{ 0x8e0,	0x002 },	/* 0x8e0 - 0x8e1 */
	{ 0x8d4,	0x001 },	/* 0x8d4 - 0x8d4 */
	{ 0x8d0,	0x001 },	/* 0x8d0 - 0x8d0 */
	{ 0x8d8,	0x001 },	/* 0x8d8 - 0x8d8 */
	{ 0x8ef,	0x001 },	/* 0x8ef - 0x8ef */
	{ 0x8e8,	0x001 },	/* 0x8e8 - 0x8e8 */
	{ 0x8dc,	0x002 },	/* 0x8dc - 0x8dd */
	{ 0x8e7,	0x001 },	/* 0x8e7 - 0x8e7 */
	{ 0x8d6,	0x001 },	/* 0x8d6 - 0x8d6 */
	{ 0x8eb,	0x002 },	/* 0x8eb - 0x8ec */
	{ 0x8ee,	0x001 },	/* 0x8ee - 0x8ee */
	{ 0x6a0,	0x002 },	/* 0x6a0 - 0x6a1 */
	{ 0x8d9,	0x001 },	/* 0x8d9 - 0x8d9 */
	{ 0x8f2,	0x002 },	/* 0x8f2 - 0x8f3 */
	{ 0x8f0,	0x002 },	/* 0x8f0 - 0x8f1 */
	{ 0x8f4,	0x001 },	/* 0x8f4 - 0x8f4 */
	{ 0x600,	0x001 },	/* 0x600 - 0x600 */
	{ 0x8a2,	0x002 },	/* 0x8a2 - 0x8a3 */
	{ 0x8a0,	0x002 },	/* 0x8a0 - 0x8a1 */
	{ 0x800,	0x001 },	/* 0x800 - 0x800 */
	{ 0x28a,	0x002 },	/* 0x28a - 0x28b */
	{ 0x160,	0x001 },	/* 0x160 - 0x160 */
	{ 0x173,	0x001 },	/* 0x173 - 0x173 */
	{ 0x31c,	0x001 },	/* 0x31c - 0x31c */
	{ 0x31e,	0x001 },	/* 0x31e - 0x31e */
	{ 0x31d,	0x001 },	/* 0x31d - 0x31d */
	{ 0x31f,	0x001 },	/* 0x31f - 0x31f */
	{ 0x2f1,	0x001 },	/* 0x2f1 - 0x2f1 */
	{ 0x2f9,	0x001 },	/* 0x2f9 - 0x2f9 */
	{ 0x2ed,	0x001 },	/* 0x2ed - 0x2ed */
	{ 0x2f5,	0x001 },	/* 0x2f5 - 0x2f5 */
	{ 0x3cc,	0x001 },	/* 0x3cc - 0x3cc */
	{ 0x304,	0x001 },	/* 0x304 - 0x304 */
	{ 0x30a,	0x001 },	/* 0x30a - 0x30a */
	{ 0x307,	0x001 },	/* 0x307 - 0x307 */
	{ 0x30d,	0x001 },	/* 0x30d - 0x30d */
	{ 0x302,	0x001 },	/* 0x302 - 0x302 */
	{ 0x308,	0x001 },	/* 0x308 - 0x308 */
	{ 0x305,	0x001 },	/* 0x305 - 0x305 */
	{ 0x30b,	0x001 },	/* 0x30b - 0x30b */
	{ 0x303,	0x001 },	/* 0x303 - 0x303 */
	{ 0x309,	0x001 },	/* 0x309 - 0x309 */
	{ 0x306,	0x001 },	/* 0x306 - 0x306 */
	{ 0x30c,	0x001 },	/* 0x30c - 0x30c */
	{ 0x355,	0x001 },	/* 0x355 - 0x355 */
	{ 0x354,	0x001 },	/* 0x354 - 0x354 */
	{ 0x357,	0x001 },	/* 0x357 - 0x357 */
	{ 0x356,	0x001 },	/* 0x356 - 0x356 */
	{ 0x32d,	0x003 },	/* 0x32d - 0x32f */
	{ 0x333,	0x003 },	/* 0x333 - 0x335 */
	{ 0x712,	0x001 },	/* 0x712 - 0x712 */
	{ 0x912,	0x001 },	/* 0x912 - 0x912 */
	{ 0x713,	0x001 },	/* 0x713 - 0x713 */
	{ 0x913,	0x001 },	/* 0x913 - 0x913 */
	{ 0x330,	0x003 },	/* 0x330 - 0x332 */
	{ 0x336,	0x003 },	/* 0x336 - 0x338 */
	{ 0x321,	0x003 },	/* 0x321 - 0x323 */
	{ 0x327,	0x003 },	/* 0x327 - 0x329 */
	{ 0x710,	0x001 },	/* 0x710 - 0x710 */
	{ 0x910,	0x001 },	/* 0x910 - 0x910 */
	{ 0x711,	0x001 },	/* 0x711 - 0x711 */
	{ 0x911,	0x001 },	/* 0x911 - 0x911 */
	{ 0x324,	0x003 },	/* 0x324 - 0x326 */
	{ 0x32a,	0x003 },	/* 0x32a - 0x32c */
	{ 0x176,	0x001 },	/* 0x176 - 0x176 */
	{ 0x2ee,	0x001 },	/* 0x2ee - 0x2ee */
	{ 0x2f6,	0x001 },	/* 0x2f6 - 0x2f6 */
	{ 0x2ea,	0x001 },	/* 0x2ea - 0x2ea */
	{ 0x2f2,	0x001 },	/* 0x2f2 - 0x2f2 */
	{ 0x2ef,	0x001 },	/* 0x2ef - 0x2ef */
	{ 0x2f7,	0x001 },	/* 0x2f7 - 0x2f7 */
	{ 0x2eb,	0x001 },	/* 0x2eb - 0x2eb */
	{ 0x2f3,	0x001 },	/* 0x2f3 - 0x2f3 */
	{ 0x2f0,	0x001 },	/* 0x2f0 - 0x2f0 */
	{ 0x2f8,	0x001 },	/* 0x2f8 - 0x2f8 */
	{ 0x2ec,	0x001 },	/* 0x2ec - 0x2ec */
	{ 0x2f4,	0x001 },	/* 0x2f4 - 0x2f4 */
	{ 0x2c3,	0x003 },	/* 0x2c3 - 0x2c5 */
	{ 0x2c1,	0x002 },	/* 0x2c1 - 0x2c2 */
	{ 0x046,	0x003 },	/* 0x046 - 0x048 */
	{ 0x747,	0x001 },	/* 0x747 - 0x747 */
	{ 0x947,	0x001 },	/* 0x947 - 0x947 */
	{ 0x180,	0x001 },	/* 0x180 - 0x180 */
	{ 0x597,	0x001 },	/* 0x597 - 0x597 */
	{ 0x590,	0x001 },	/* 0x590 - 0x590 */
	{ 0x197,	0x002 },	/* 0x197 - 0x198 */
	{ 0x1d7,	0x001 },	/* 0x1d7 - 0x1d7 */
	{ 0x3d7,	0x001 },	/* 0x3d7 - 0x3d7 */
	{ 0x299,	0x001 },	/* 0x299 - 0x299 */
	{ 0x3f1,	0x001 },	/* 0x3f1 - 0x3f1 */
	{ 0x1b6,	0x001 },	/* 0x1b6 - 0x1b6 */
	{ 0x1f5,	0x001 },	/* 0x1f5 - 0x1f5 */
	{ 0x1f2,	0x001 },	/* 0x1f2 - 0x1f2 */
	{ 0x358,	0x003 },	/* 0x358 - 0x35a */
	{ 0x5c0,	0x001 },	/* 0x5c0 - 0x5c0 */
	{ 0x7b0,	0x001 },	/* 0x7b0 - 0x7b0 */
	{ 0x9b0,	0x001 },	/* 0x9b0 - 0x9b0 */
	{ 0x7b5,	0x001 },	/* 0x7b5 - 0x7b5 */
	{ 0x9b5,	0x001 },	/* 0x9b5 - 0x9b5 */
	{ 0x7b6,	0x001 },	/* 0x7b6 - 0x7b6 */
	{ 0x9b6,	0x001 },	/* 0x9b6 - 0x9b6 */
	{ 0x7b1,	0x001 },	/* 0x7b1 - 0x7b1 */
	{ 0x9b1,	0x001 },	/* 0x9b1 - 0x9b1 */
	{ 0x7b2,	0x001 },	/* 0x7b2 - 0x7b2 */
	{ 0x9b2,	0x001 },	/* 0x9b2 - 0x9b2 */
	{ 0x7b9,	0x001 },	/* 0x7b9 - 0x7b9 */
	{ 0x9b9,	0x001 },	/* 0x9b9 - 0x9b9 */
	{ 0x7bc,	0x001 },	/* 0x7bc - 0x7bc */
	{ 0x9bc,	0x001 },	/* 0x9bc - 0x9bc */
	{ 0x7bf,	0x001 },	/* 0x7bf - 0x7bf */
	{ 0x9bf,	0x001 },	/* 0x9bf - 0x9bf */
	{ 0x7ba,	0x001 },	/* 0x7ba - 0x7ba */
	{ 0x9ba,	0x001 },	/* 0x9ba - 0x9ba */
	{ 0x7bd,	0x001 },	/* 0x7bd - 0x7bd */
	{ 0x9bd,	0x001 },	/* 0x9bd - 0x9bd */
	{ 0x7bb,	0x001 },	/* 0x7bb - 0x7bb */
	{ 0x9bb,	0x001 },	/* 0x9bb - 0x9bb */
	{ 0x7be,	0x001 },	/* 0x7be - 0x7be */
	{ 0x9be,	0x001 },	/* 0x9be - 0x9be */
	{ 0x1f3,	0x001 },	/* 0x1f3 - 0x1f3 */
	{ 0x1e8,	0x001 },	/* 0x1e8 - 0x1e8 */
	{ 0x3cf,	0x002 },	/* 0x3cf - 0x3d0 */
	{ 0x3c6,	0x001 },	/* 0x3c6 - 0x3c6 */
	{ 0x3c4,	0x002 },	/* 0x3c4 - 0x3c5 */
	{ 0x044,	0x001 },	/* 0x044 - 0x044 */
	{ 0x4d6,	0x001 },	/* 0x4d6 - 0x4d6 */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x33a,	0x004 },	/* 0x33a - 0x33d */
	{ 0x342,	0x004 },	/* 0x342 - 0x345 */
	{ 0x33e,	0x004 },	/* 0x33e - 0x341 */
	{ 0x346,	0x004 },	/* 0x346 - 0x349 */
	{ 0x6f5,	0x001 },	/* 0x6f5 - 0x6f5 */
	{ 0x8f5,	0x001 },	/* 0x8f5 - 0x8f5 */
	{ 0x6f6,	0x001 },	/* 0x6f6 - 0x6f6 */
	{ 0x8f6,	0x001 },	/* 0x8f6 - 0x8f6 */
	{ 0x339,	0x001 },	/* 0x339 - 0x339 */
	{ 0x1ee,	0x001 },	/* 0x1ee - 0x1ee */
	{ 0x1ec,	0x001 },	/* 0x1ec - 0x1ec */
	{ 0x163,	0x001 },	/* 0x163 - 0x163 */
	{ 0x67a,	0x001 },	/* 0x67a - 0x67a */
	{ 0x87a,	0x001 },	/* 0x87a - 0x87a */
	{ 0x67b,	0x001 },	/* 0x67b - 0x67b */
	{ 0x87b,	0x001 },	/* 0x87b - 0x87b */
	{ 0x679,	0x001 },	/* 0x679 - 0x679 */
	{ 0x879,	0x001 },	/* 0x879 - 0x879 */
	{ 0x642,	0x001 },	/* 0x642 - 0x642 */
	{ 0x842,	0x001 },	/* 0x842 - 0x842 */
	{ 0x500,	0x001 },	/* 0x500 - 0x500 */
	{ 0x510,	0x001 },	/* 0x510 - 0x510 */
	{ 0x501,	0x001 },	/* 0x501 - 0x501 */
	{ 0x240,	0x002 },	/* 0x240 - 0x241 */
	{ 0x24a,	0x001 },	/* 0x24a - 0x24a */
	{ 0x242,	0x008 },	/* 0x242 - 0x249 */
	{ 0x213,	0x001 },	/* 0x213 - 0x213 */
	{ 0x234,	0x004 },	/* 0x234 - 0x237 */
	{ 0x230,	0x004 },	/* 0x230 - 0x233 */
	{ 0x212,	0x001 },	/* 0x212 - 0x212 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x219,	0x001 },	/* 0x219 - 0x219 */
	{ 0x214,	0x001 },	/* 0x214 - 0x214 */
	{ 0x218,	0x001 },	/* 0x218 - 0x218 */
	{ 0x216,	0x001 },	/* 0x216 - 0x216 */
	{ 0x215,	0x001 },	/* 0x215 - 0x215 */
	{ 0x238,	0x002 },	/* 0x238 - 0x239 */
	{ 0x067,	0x001 },	/* 0x067 - 0x067 */
	{ 0x066,	0x001 },	/* 0x066 - 0x066 */
	{ 0x419,	0x001 },	/* 0x419 - 0x419 */
	{ 0x177,	0x001 },	/* 0x177 - 0x177 */
	{ 0x16b,	0x001 },	/* 0x16b - 0x16b */
	{ 0x3e0,	0x001 },	/* 0x3e0 - 0x3e0 */
	{ 0x16d,	0x001 },	/* 0x16d - 0x16d */
	{ 0x16c,	0x001 },	/* 0x16c - 0x16c */
	{ 0x169,	0x001 },	/* 0x169 - 0x169 */
	{ 0x259,	0x001 },	/* 0x259 - 0x259 */
	{ 0x690,	0x001 },	/* 0x690 - 0x690 */
	{ 0x890,	0x001 },	/* 0x890 - 0x890 */
	{ 0x29f,	0x001 },	/* 0x29f - 0x29f */
	{ 0x280,	0x009 },	/* 0x280 - 0x288 */
	{ 0x46b,	0x001 },	/* 0x46b - 0x46b */
	{ 0x2e0,	0x001 },	/* 0x2e0 - 0x2e0 */
	{ 0x2e5,	0x001 },	/* 0x2e5 - 0x2e5 */
	{ 0x2e3,	0x001 },	/* 0x2e3 - 0x2e3 */
	{ 0x2e6,	0x001 },	/* 0x2e6 - 0x2e6 */
	{ 0x2e4,	0x001 },	/* 0x2e4 - 0x2e4 */
	{ 0x2e2,	0x001 },	/* 0x2e2 - 0x2e2 */
	{ 0x2e1,	0x001 },	/* 0x2e1 - 0x2e1 */
	{ 0x793,	0x001 },	/* 0x793 - 0x793 */
	{ 0x993,	0x001 },	/* 0x993 - 0x993 */
	{ 0x792,	0x001 },	/* 0x792 - 0x792 */
	{ 0x992,	0x001 },	/* 0x992 - 0x992 */
	{ 0x3e3,	0x001 },	/* 0x3e3 - 0x3e3 */
	{ 0x5d1,	0x003 },	/* 0x5d1 - 0x5d3 */
	{ 0x5d7,	0x003 },	/* 0x5d7 - 0x5d9 */
	{ 0x5d0,	0x001 },	/* 0x5d0 - 0x5d0 */
	{ 0x5d4,	0x003 },	/* 0x5d4 - 0x5d6 */
	{ 0x473,	0x001 },	/* 0x473 - 0x473 */
	{ 0x472,	0x001 },	/* 0x472 - 0x472 */
	{ 0x395,	0x001 },	/* 0x395 - 0x395 */
	{ 0x013,	0x001 },	/* 0x013 - 0x013 */
	{ 0x393,	0x001 },	/* 0x393 - 0x393 */
	{ 0x012,	0x001 },	/* 0x012 - 0x012 */
	{ 0x392,	0x001 },	/* 0x392 - 0x392 */
	{ 0x394,	0x001 },	/* 0x394 - 0x394 */
	{ 0x39c,	0x001 },	/* 0x39c - 0x39c */
	{ 0x39b,	0x001 },	/* 0x39b - 0x39b */
	{ 0x292,	0x001 },	/* 0x292 - 0x292 */
	{ 0x195,	0x002 },	/* 0x195 - 0x196 */
	{ 0x1f6,	0x002 },	/* 0x1f6 - 0x1f7 */
	{ 0x1b0,	0x001 },	/* 0x1b0 - 0x1b0 */
	{ 0x64d,	0x001 },	/* 0x64d - 0x64d */
	{ 0x84d,	0x001 },	/* 0x84d - 0x84d */
	{ 0x64e,	0x001 },	/* 0x64e - 0x64e */
	{ 0x84e,	0x001 },	/* 0x84e - 0x84e */
	{ 0x494,	0x001 },	/* 0x494 - 0x494 */
	{ 0x1e1,	0x001 },	/* 0x1e1 - 0x1e1 */
	{ 0x1e7,	0x001 },	/* 0x1e7 - 0x1e7 */
	{ 0x270,	0x001 },	/* 0x270 - 0x270 */
	{ 0x6c3,	0x001 },	/* 0x6c3 - 0x6c3 */
	{ 0x8c3,	0x001 },	/* 0x8c3 - 0x8c3 */
	{ 0x6c2,	0x001 },	/* 0x6c2 - 0x6c2 */
	{ 0x8c2,	0x001 },	/* 0x8c2 - 0x8c2 */
	{ 0x6c1,	0x001 },	/* 0x6c1 - 0x6c1 */
	{ 0x8c1,	0x001 },	/* 0x8c1 - 0x8c1 */
	{ 0x6c0,	0x001 },	/* 0x6c0 - 0x6c0 */
	{ 0x8c0,	0x001 },	/* 0x8c0 - 0x8c0 */
	{ 0x6c5,	0x001 },	/* 0x6c5 - 0x6c5 */
	{ 0x8c5,	0x001 },	/* 0x8c5 - 0x8c5 */
	{ 0x6c4,	0x001 },	/* 0x6c4 - 0x6c4 */
	{ 0x8c4,	0x001 },	/* 0x8c4 - 0x8c4 */
	{ 0x272,	0x001 },	/* 0x272 - 0x272 */
	{ 0x271,	0x001 },	/* 0x271 - 0x271 */
	{ 0x380,	0x001 },	/* 0x380 - 0x380 */
	{ 0x382,	0x001 },	/* 0x382 - 0x382 */
	{ 0x381,	0x001 },	/* 0x381 - 0x381 */
	{ 0x383,	0x001 },	/* 0x383 - 0x383 */
	{ 0x3b0,	0x001 },	/* 0x3b0 - 0x3b0 */
	{ 0x3af,	0x001 },	/* 0x3af - 0x3af */
	{ 0x3b1,	0x002 },	/* 0x3b1 - 0x3b2 */
	{ 0x3b5,	0x001 },	/* 0x3b5 - 0x3b5 */
	{ 0x3e9,	0x001 },	/* 0x3e9 - 0x3e9 */
	{ 0x46c,	0x002 },	/* 0x46c - 0x46d */
	{ 0x3b9,	0x001 },	/* 0x3b9 - 0x3b9 */
	{ 0x1a0,	0x001 },	/* 0x1a0 - 0x1a0 */
	{ 0x1a2,	0x001 },	/* 0x1a2 - 0x1a2 */
	{ 0x1a1,	0x001 },	/* 0x1a1 - 0x1a1 */
	{ 0x1a3,	0x001 },	/* 0x1a3 - 0x1a3 */
	{ 0x2b3,	0x001 },	/* 0x2b3 - 0x2b3 */
	{ 0x2b1,	0x001 },	/* 0x2b1 - 0x2b1 */
	{ 0x2b0,	0x001 },	/* 0x2b0 - 0x2b0 */
	{ 0x2ba,	0x001 },	/* 0x2ba - 0x2ba */
	{ 0x2b9,	0x001 },	/* 0x2b9 - 0x2b9 */
	{ 0x2b8,	0x001 },	/* 0x2b8 - 0x2b8 */
	{ 0x2b5,	0x001 },	/* 0x2b5 - 0x2b5 */
	{ 0x2b4,	0x001 },	/* 0x2b4 - 0x2b4 */
	{ 0x2b7,	0x001 },	/* 0x2b7 - 0x2b7 */
	{ 0x2b6,	0x001 },	/* 0x2b6 - 0x2b6 */
	{ 0x2b2,	0x001 },	/* 0x2b2 - 0x2b2 */
	{ 0x3e2,	0x001 },	/* 0x3e2 - 0x3e2 */
	{ 0x3ea,	0x002 },	/* 0x3ea - 0x3eb */
	{ 0x3e1,	0x001 },	/* 0x3e1 - 0x3e1 */
	{ 0x3e5,	0x001 },	/* 0x3e5 - 0x3e5 */
	{ 0x1b7,	0x001 },	/* 0x1b7 - 0x1b7 */
	{ 0x3b4,	0x001 },	/* 0x3b4 - 0x3b4 */
	{ 0x3dc,	0x002 },	/* 0x3dc - 0x3dd */
	{ 0x3e7,	0x002 },	/* 0x3e7 - 0x3e8 */
	{ 0x40c,	0x002 },	/* 0x40c - 0x40d */
	{ 0x3bb,	0x001 },	/* 0x3bb - 0x3bb */
	{ 0x3ba,	0x001 },	/* 0x3ba - 0x3ba */
	{ 0x377,	0x001 },	/* 0x377 - 0x377 */
	{ 0x78f,	0x001 },	/* 0x78f - 0x78f */
	{ 0x98f,	0x001 },	/* 0x98f - 0x98f */
	{ 0x78e,	0x001 },	/* 0x78e - 0x78e */
	{ 0x98e,	0x001 },	/* 0x98e - 0x98e */
	{ 0x28d,	0x001 },	/* 0x28d - 0x28d */
	{ 0x28f,	0x001 },	/* 0x28f - 0x28f */
	{ 0x291,	0x001 },	/* 0x291 - 0x291 */
	{ 0x28c,	0x001 },	/* 0x28c - 0x28c */
	{ 0x28e,	0x001 },	/* 0x28e - 0x28e */
	{ 0x290,	0x001 },	/* 0x290 - 0x290 */
	{ 0x471,	0x001 },	/* 0x471 - 0x471 */
	{ 0x49d,	0x001 },	/* 0x49d - 0x49d */
	{ 0x4f5,	0x002 },	/* 0x4f5 - 0x4f6 */
	{ 0x49b,	0x001 },	/* 0x49b - 0x49b */
	{ 0x4f4,	0x001 },	/* 0x4f4 - 0x4f4 */
	{ 0x49c,	0x001 },	/* 0x49c - 0x49c */
	{ 0x1ce,	0x001 },	/* 0x1ce - 0x1ce */
	{ 0x1ef,	0x001 },	/* 0x1ef - 0x1ef */
	{ 0x1bb,	0x001 },	/* 0x1bb - 0x1bb */
	{ 0x1ba,	0x001 },	/* 0x1ba - 0x1ba */
	{ 0x1b9,	0x001 },	/* 0x1b9 - 0x1b9 */
	{ 0x2d1,	0x001 },	/* 0x2d1 - 0x2d1 */
	{ 0x609,	0x001 },	/* 0x609 - 0x609 */
	{ 0x809,	0x001 },	/* 0x809 - 0x809 */
	{ 0x2d6,	0x003 },	/* 0x2d6 - 0x2d8 */
	{ 0x583,	0x001 },	/* 0x583 - 0x583 */
	{ 0x586,	0x001 },	/* 0x586 - 0x586 */
	{ 0x588,	0x001 },	/* 0x588 - 0x588 */
	{ 0x58a,	0x001 },	/* 0x58a - 0x58a */
	{ 0x58c,	0x001 },	/* 0x58c - 0x58c */
	{ 0x58e,	0x001 },	/* 0x58e - 0x58e */
	{ 0x585,	0x001 },	/* 0x585 - 0x585 */
	{ 0x587,	0x001 },	/* 0x587 - 0x587 */
	{ 0x589,	0x001 },	/* 0x589 - 0x589 */
	{ 0x58b,	0x001 },	/* 0x58b - 0x58b */
	{ 0x58d,	0x001 },	/* 0x58d - 0x58d */
	{ 0x580,	0x001 },	/* 0x580 - 0x580 */
	{ 0x591,	0x001 },	/* 0x591 - 0x591 */
	{ 0x584,	0x001 },	/* 0x584 - 0x584 */
	{ 0x581,	0x002 },	/* 0x581 - 0x582 */
	{ 0x523,	0x001 },	/* 0x523 - 0x523 */
	{ 0x522,	0x001 },	/* 0x522 - 0x522 */
	{ 0x521,	0x001 },	/* 0x521 - 0x521 */
	{ 0x171,	0x001 },	/* 0x171 - 0x171 */
	{ 0x29d,	0x001 },	/* 0x29d - 0x29d */
	{ 0x29a,	0x001 },	/* 0x29a - 0x29a */
	{ 0x041,	0x002 },	/* 0x041 - 0x042 */
	{ 0x1b2,	0x004 },	/* 0x1b2 - 0x1b5 */
	{ 0x531,	0x001 },	/* 0x531 - 0x531 */
	{ 0x530,	0x001 },	/* 0x530 - 0x530 */
	{ 0x533,	0x001 },	/* 0x533 - 0x533 */
	{ 0x532,	0x001 },	/* 0x532 - 0x532 */
	{ 0x537,	0x001 },	/* 0x537 - 0x537 */
	{ 0x536,	0x001 },	/* 0x536 - 0x536 */
	{ 0x535,	0x001 },	/* 0x535 - 0x535 */
	{ 0x534,	0x001 },	/* 0x534 - 0x534 */
	{ 0x539,	0x001 },	/* 0x539 - 0x539 */
	{ 0x538,	0x001 },	/* 0x538 - 0x538 */
	{ 0x53b,	0x001 },	/* 0x53b - 0x53b */
	{ 0x53a,	0x001 },	/* 0x53a - 0x53a */
	{ 0x767,	0x001 },	/* 0x767 - 0x767 */
	{ 0x967,	0x001 },	/* 0x967 - 0x967 */
	{ 0x489,	0x001 },	/* 0x489 - 0x489 */
	{ 0x488,	0x001 },	/* 0x488 - 0x488 */
	{ 0x48a,	0x001 },	/* 0x48a - 0x48a */
	{ 0x768,	0x001 },	/* 0x768 - 0x768 */
	{ 0x968,	0x001 },	/* 0x968 - 0x968 */
	{ 0x4b7,	0x001 },	/* 0x4b7 - 0x4b7 */
	{ 0x48c,	0x002 },	/* 0x48c - 0x48d */
	{ 0x4e2,	0x001 },	/* 0x4e2 - 0x4e2 */
	{ 0x4e0,	0x002 },	/* 0x4e0 - 0x4e1 */
	{ 0x4df,	0x001 },	/* 0x4df - 0x4df */
	{ 0x4e6,	0x001 },	/* 0x4e6 - 0x4e6 */
	{ 0x4e4,	0x002 },	/* 0x4e4 - 0x4e5 */
	{ 0x4e3,	0x001 },	/* 0x4e3 - 0x4e3 */
	{ 0x4dd,	0x001 },	/* 0x4dd - 0x4dd */
	{ 0x4d9,	0x001 },	/* 0x4d9 - 0x4d9 */
	{ 0x4db,	0x001 },	/* 0x4db - 0x4db */
	{ 0x4d7,	0x001 },	/* 0x4d7 - 0x4d7 */
	{ 0x4de,	0x001 },	/* 0x4de - 0x4de */
	{ 0x4da,	0x001 },	/* 0x4da - 0x4da */
	{ 0x4dc,	0x001 },	/* 0x4dc - 0x4dc */
	{ 0x4d8,	0x001 },	/* 0x4d8 - 0x4d8 */
	{ 0x53d,	0x001 },	/* 0x53d - 0x53d */
	{ 0x53c,	0x001 },	/* 0x53c - 0x53c */
	{ 0x53f,	0x001 },	/* 0x53f - 0x53f */
	{ 0x53e,	0x001 },	/* 0x53e - 0x53e */
	{ 0x485,	0x001 },	/* 0x485 - 0x485 */
	{ 0x763,	0x001 },	/* 0x763 - 0x763 */
	{ 0x963,	0x001 },	/* 0x963 - 0x963 */
	{ 0x764,	0x001 },	/* 0x764 - 0x764 */
	{ 0x964,	0x001 },	/* 0x964 - 0x964 */
	{ 0x765,	0x001 },	/* 0x765 - 0x765 */
	{ 0x965,	0x001 },	/* 0x965 - 0x965 */
	{ 0x760,	0x001 },	/* 0x760 - 0x760 */
	{ 0x960,	0x001 },	/* 0x960 - 0x960 */
	{ 0x761,	0x001 },	/* 0x761 - 0x761 */
	{ 0x961,	0x001 },	/* 0x961 - 0x961 */
	{ 0x762,	0x001 },	/* 0x762 - 0x762 */
	{ 0x962,	0x001 },	/* 0x962 - 0x962 */
	{ 0x484,	0x001 },	/* 0x484 - 0x484 */
	{ 0x541,	0x001 },	/* 0x541 - 0x541 */
	{ 0x540,	0x001 },	/* 0x540 - 0x540 */
	{ 0x487,	0x001 },	/* 0x487 - 0x487 */
	{ 0x486,	0x001 },	/* 0x486 - 0x486 */
	{ 0x769,	0x001 },	/* 0x769 - 0x769 */
	{ 0x969,	0x001 },	/* 0x969 - 0x969 */
	{ 0x490,	0x001 },	/* 0x490 - 0x490 */
	{ 0x48f,	0x001 },	/* 0x48f - 0x48f */
	{ 0x4b8,	0x001 },	/* 0x4b8 - 0x4b8 */
	{ 0x48e,	0x001 },	/* 0x48e - 0x48e */
	{ 0x766,	0x001 },	/* 0x766 - 0x766 */
	{ 0x966,	0x001 },	/* 0x966 - 0x966 */
	{ 0x480,	0x004 },	/* 0x480 - 0x483 */
	{ 0x4f8,	0x001 },	/* 0x4f8 - 0x4f8 */
	{ 0x16f,	0x001 },	/* 0x16f - 0x16f */
	{ 0x3de,	0x001 },	/* 0x3de - 0x3de */
	{ 0x3d5,	0x001 },	/* 0x3d5 - 0x3d5 */
	{ 0x297,	0x002 },	/* 0x297 - 0x298 */
	{ 0x493,	0x001 },	/* 0x493 - 0x493 */
	{ 0x120,	0x001 },	/* 0x120 - 0x120 */
	{ 0x129,	0x001 },	/* 0x129 - 0x129 */
	{ 0x125,	0x001 },	/* 0x125 - 0x125 */
	{ 0x123,	0x001 },	/* 0x123 - 0x123 */
	{ 0x670,	0x001 },	/* 0x670 - 0x670 */
	{ 0x870,	0x001 },	/* 0x870 - 0x870 */
	{ 0x671,	0x001 },	/* 0x671 - 0x671 */
	{ 0x871,	0x001 },	/* 0x871 - 0x871 */
	{ 0x672,	0x001 },	/* 0x672 - 0x672 */
	{ 0x872,	0x001 },	/* 0x872 - 0x872 */
	{ 0x673,	0x001 },	/* 0x673 - 0x673 */
	{ 0x873,	0x001 },	/* 0x873 - 0x873 */
	{ 0x122,	0x001 },	/* 0x122 - 0x122 */
	{ 0x67c,	0x001 },	/* 0x67c - 0x67c */
	{ 0x87c,	0x001 },	/* 0x87c - 0x87c */
	{ 0x124,	0x001 },	/* 0x124 - 0x124 */
	{ 0x12a,	0x001 },	/* 0x12a - 0x12a */
	{ 0x674,	0x001 },	/* 0x674 - 0x674 */
	{ 0x874,	0x001 },	/* 0x874 - 0x874 */
	{ 0x675,	0x001 },	/* 0x675 - 0x675 */
	{ 0x875,	0x001 },	/* 0x875 - 0x875 */
	{ 0x121,	0x001 },	/* 0x121 - 0x121 */
	{ 0x676,	0x001 },	/* 0x676 - 0x676 */
	{ 0x876,	0x001 },	/* 0x876 - 0x876 */
	{ 0x677,	0x001 },	/* 0x677 - 0x677 */
	{ 0x877,	0x001 },	/* 0x877 - 0x877 */
	{ 0x678,	0x001 },	/* 0x678 - 0x678 */
	{ 0x878,	0x001 },	/* 0x878 - 0x878 */
	{ 0x126,	0x003 },	/* 0x126 - 0x128 */
	{ 0x080,	0x001 },	/* 0x080 - 0x080 */
	{ 0x660,	0x001 },	/* 0x660 - 0x660 */
	{ 0x860,	0x001 },	/* 0x860 - 0x860 */
	{ 0x662,	0x001 },	/* 0x662 - 0x662 */
	{ 0x862,	0x001 },	/* 0x862 - 0x862 */
	{ 0x661,	0x001 },	/* 0x661 - 0x661 */
	{ 0x861,	0x001 },	/* 0x861 - 0x861 */
	{ 0x085,	0x002 },	/* 0x085 - 0x086 */
	{ 0x08a,	0x002 },	/* 0x08a - 0x08b */
	{ 0x082,	0x003 },	/* 0x082 - 0x084 */
	{ 0x087,	0x003 },	/* 0x087 - 0x089 */
	{ 0x081,	0x001 },	/* 0x081 - 0x081 */
	{ 0x090,	0x002 },	/* 0x090 - 0x091 */
	{ 0x095,	0x002 },	/* 0x095 - 0x096 */
	{ 0x08d,	0x003 },	/* 0x08d - 0x08f */
	{ 0x092,	0x003 },	/* 0x092 - 0x094 */
	{ 0x08c,	0x001 },	/* 0x08c - 0x08c */
	{ 0x09b,	0x002 },	/* 0x09b - 0x09c */
	{ 0x0a0,	0x002 },	/* 0x0a0 - 0x0a1 */
	{ 0x098,	0x003 },	/* 0x098 - 0x09a */
	{ 0x09d,	0x003 },	/* 0x09d - 0x09f */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x0a3,	0x003 },	/* 0x0a3 - 0x0a5 */
	{ 0x0a7,	0x002 },	/* 0x0a7 - 0x0a8 */
	{ 0x0a6,	0x001 },	/* 0x0a6 - 0x0a6 */
	{ 0x0a2,	0x001 },	/* 0x0a2 - 0x0a2 */
	{ 0x3ac,	0x001 },	/* 0x3ac - 0x3ac */
	{ 0x3aa,	0x001 },	/* 0x3aa - 0x3aa */
	{ 0x1b1,	0x001 },	/* 0x1b1 - 0x1b1 */
	{ 0x1cf,	0x008 },	/* 0x1cf - 0x1d6 */
	{ 0x469,	0x001 },	/* 0x469 - 0x469 */
	{ 0x1ed,	0x001 },	/* 0x1ed - 0x1ed */
	{ 0x3e4,	0x001 },	/* 0x3e4 - 0x3e4 */
	{ 0x3c2,	0x001 },	/* 0x3c2 - 0x3c2 */
	{ 0x3c1,	0x001 },	/* 0x3c1 - 0x3c1 */
	{ 0x078,	0x001 },	/* 0x078 - 0x078 */
	{ 0x370,	0x001 },	/* 0x370 - 0x370 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x46e,	0x001 },	/* 0x46e - 0x46e */
	{ 0x15d,	0x001 },	/* 0x15d - 0x15d */
	{ 0x1c7,	0x001 },	/* 0x1c7 - 0x1c7 */
	{ 0x153,	0x001 },	/* 0x153 - 0x153 */
	{ 0x1c9,	0x001 },	/* 0x1c9 - 0x1c9 */
	{ 0x155,	0x001 },	/* 0x155 - 0x155 */
	{ 0x152,	0x001 },	/* 0x152 - 0x152 */
	{ 0x692,	0x001 },	/* 0x692 - 0x692 */
	{ 0x892,	0x001 },	/* 0x892 - 0x892 */
	{ 0x1c4,	0x003 },	/* 0x1c4 - 0x1c6 */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x1c8,	0x001 },	/* 0x1c8 - 0x1c8 */
	{ 0x156,	0x001 },	/* 0x156 - 0x156 */
	{ 0x405,	0x001 },	/* 0x405 - 0x405 */
	{ 0x168,	0x001 },	/* 0x168 - 0x168 */
	{ 0xc13,	0x001 },	/* 0xc13 - 0xc13 */
	{ 0xc10,	0x001 },	/* 0xc10 - 0xc10 */
	{ 0xc12,	0x001 },	/* 0xc12 - 0xc12 */
	{ 0xc11,	0x001 },	/* 0xc11 - 0xc11 */
	{ 0x1e6,	0x001 },	/* 0x1e6 - 0x1e6 */
	{ 0x1f0,	0x002 },	/* 0x1f0 - 0x1f1 */
	{ 0x1e0,	0x001 },	/* 0x1e0 - 0x1e0 */
	{ 0x799,	0x001 },	/* 0x799 - 0x799 */
	{ 0x999,	0x001 },	/* 0x999 - 0x999 */
	{ 0x798,	0x001 },	/* 0x798 - 0x798 */
	{ 0x998,	0x001 },	/* 0x998 - 0x998 */
	{ 0x3ed,	0x001 },	/* 0x3ed - 0x3ed */
	{ 0x415,	0x001 },	/* 0x415 - 0x415 */
	{ 0x3ee,	0x001 },	/* 0x3ee - 0x3ee */
	{ 0x3da,	0x002 },	/* 0x3da - 0x3db */
	{ 0x3ce,	0x001 },	/* 0x3ce - 0x3ce */
	{ 0x7d3,	0x001 },	/* 0x7d3 - 0x7d3 */
	{ 0x9d3,	0x001 },	/* 0x9d3 - 0x9d3 */
	{ 0x7d7,	0x001 },	/* 0x7d7 - 0x7d7 */
	{ 0x9d7,	0x001 },	/* 0x9d7 - 0x9d7 */
	{ 0x7d9,	0x001 },	/* 0x7d9 - 0x7d9 */
	{ 0x9d9,	0x001 },	/* 0x9d9 - 0x9d9 */
	{ 0x7db,	0x001 },	/* 0x7db - 0x7db */
	{ 0x9db,	0x001 },	/* 0x9db - 0x9db */
	{ 0x7d5,	0x001 },	/* 0x7d5 - 0x7d5 */
	{ 0x9d5,	0x001 },	/* 0x9d5 - 0x9d5 */
	{ 0x7d1,	0x001 },	/* 0x7d1 - 0x7d1 */
	{ 0x9d1,	0x001 },	/* 0x9d1 - 0x9d1 */
	{ 0x7d2,	0x001 },	/* 0x7d2 - 0x7d2 */
	{ 0x9d2,	0x001 },	/* 0x9d2 - 0x9d2 */
	{ 0x7d6,	0x001 },	/* 0x7d6 - 0x7d6 */
	{ 0x9d6,	0x001 },	/* 0x9d6 - 0x9d6 */
	{ 0x7d8,	0x001 },	/* 0x7d8 - 0x7d8 */
	{ 0x9d8,	0x001 },	/* 0x9d8 - 0x9d8 */
	{ 0x7da,	0x001 },	/* 0x7da - 0x7da */
	{ 0x9da,	0x001 },	/* 0x9da - 0x9da */
	{ 0x7d4,	0x001 },	/* 0x7d4 - 0x7d4 */
	{ 0x9d4,	0x001 },	/* 0x9d4 - 0x9d4 */
	{ 0x7d0,	0x001 },	/* 0x7d0 - 0x7d0 */
	{ 0x9d0,	0x001 },	/* 0x9d0 - 0x9d0 */
	{ 0x7dc,	0x001 },	/* 0x7dc - 0x7dc */
	{ 0x9dc,	0x001 },	/* 0x9dc - 0x9dc */
	{ 0x2c8,	0x003 },	/* 0x2c8 - 0x2ca */
	{ 0x2c6,	0x002 },	/* 0x2c6 - 0x2c7 */
	{ 0x3cd,	0x001 },	/* 0x3cd - 0x3cd */
	{ 0x78d,	0x001 },	/* 0x78d - 0x78d */
	{ 0x98d,	0x001 },	/* 0x98d - 0x98d */
	{ 0x78c,	0x001 },	/* 0x78c - 0x78c */
	{ 0x98c,	0x001 },	/* 0x98c - 0x98c */
	{ 0x789,	0x001 },	/* 0x789 - 0x789 */
	{ 0x989,	0x001 },	/* 0x989 - 0x989 */
	{ 0x788,	0x001 },	/* 0x788 - 0x788 */
	{ 0x988,	0x001 },	/* 0x988 - 0x988 */
	{ 0x78b,	0x001 },	/* 0x78b - 0x78b */
	{ 0x98b,	0x001 },	/* 0x98b - 0x98b */
	{ 0x78a,	0x001 },	/* 0x78a - 0x78a */
	{ 0x98a,	0x001 },	/* 0x98a - 0x98a */
	{ 0x3df,	0x001 },	/* 0x3df - 0x3df */
	{ 0x25e,	0x001 },	/* 0x25e - 0x25e */
	{ 0x25d,	0x001 },	/* 0x25d - 0x25d */
	{ 0x250,	0x001 },	/* 0x250 - 0x250 */
	{ 0x25f,	0x002 },	/* 0x25f - 0x260 */
	{ 0x264,	0x002 },	/* 0x264 - 0x265 */
	{ 0x25b,	0x001 },	/* 0x25b - 0x25b */
	{ 0x268,	0x001 },	/* 0x268 - 0x268 */
	{ 0x263,	0x001 },	/* 0x263 - 0x263 */
	{ 0x25c,	0x001 },	/* 0x25c - 0x25c */
	{ 0x261,	0x002 },	/* 0x261 - 0x262 */
	{ 0x255,	0x001 },	/* 0x255 - 0x255 */
	{ 0x266,	0x001 },	/* 0x266 - 0x266 */
	{ 0x257,	0x001 },	/* 0x257 - 0x257 */
	{ 0x256,	0x001 },	/* 0x256 - 0x256 */
	{ 0x267,	0x001 },	/* 0x267 - 0x267 */
	{ 0x258,	0x001 },	/* 0x258 - 0x258 */
	{ 0x850,	0x001 },	/* 0x850 - 0x850 */
	{ 0x830,	0x005 },	/* 0x830 - 0x834 */
	{ 0x83f,	0x001 },	/* 0x83f - 0x83f */
	{ 0x83c,	0x003 },	/* 0x83c - 0x83e */
	{ 0x83a,	0x002 },	/* 0x83a - 0x83b */
	{ 0x835,	0x005 },	/* 0x835 - 0x839 */
	{ 0x857,	0x001 },	/* 0x857 - 0x857 */
	{ 0x855,	0x002 },	/* 0x855 - 0x856 */
	{ 0x854,	0x001 },	/* 0x854 - 0x854 */
	{ 0x851,	0x003 },	/* 0x851 - 0x853 */
	{ 0x413,	0x001 },	/* 0x413 - 0x413 */
	{ 0x40b,	0x001 },	/* 0x40b - 0x40b */
	{ 0x409,	0x001 },	/* 0x409 - 0x409 */
	{ 0x748,	0x001 },	/* 0x748 - 0x748 */
	{ 0x948,	0x001 },	/* 0x948 - 0x948 */
	{ 0x408,	0x001 },	/* 0x408 - 0x408 */
	{ 0x741,	0x004 },	/* 0x741 - 0x744 */
	{ 0x73f,	0x002 },	/* 0x73f - 0x740 */
	{ 0x941,	0x004 },	/* 0x941 - 0x944 */
	{ 0x93f,	0x002 },	/* 0x93f - 0x940 */
	{ 0x739,	0x001 },	/* 0x739 - 0x739 */
	{ 0x939,	0x001 },	/* 0x939 - 0x939 */
	{ 0x73a,	0x001 },	/* 0x73a - 0x73a */
	{ 0x93a,	0x001 },	/* 0x93a - 0x93a */
	{ 0x73c,	0x001 },	/* 0x73c - 0x73c */
	{ 0x93c,	0x001 },	/* 0x93c - 0x93c */
	{ 0x73d,	0x001 },	/* 0x73d - 0x73d */
	{ 0x93d,	0x001 },	/* 0x93d - 0x93d */
	{ 0x417,	0x001 },	/* 0x417 - 0x417 */
	{ 0x745,	0x001 },	/* 0x745 - 0x745 */
	{ 0x945,	0x001 },	/* 0x945 - 0x945 */
	{ 0x73b,	0x001 },	/* 0x73b - 0x73b */
	{ 0x93b,	0x001 },	/* 0x93b - 0x93b */
	{ 0x735,	0x001 },	/* 0x735 - 0x735 */
	{ 0x935,	0x001 },	/* 0x935 - 0x935 */
	{ 0x734,	0x001 },	/* 0x734 - 0x734 */
	{ 0x934,	0x001 },	/* 0x934 - 0x934 */
	{ 0x737,	0x001 },	/* 0x737 - 0x737 */
	{ 0x937,	0x001 },	/* 0x937 - 0x937 */
	{ 0x736,	0x001 },	/* 0x736 - 0x736 */
	{ 0x936,	0x001 },	/* 0x936 - 0x936 */
	{ 0x746,	0x001 },	/* 0x746 - 0x746 */
	{ 0x946,	0x001 },	/* 0x946 - 0x946 */
	{ 0x738,	0x001 },	/* 0x738 - 0x738 */
	{ 0x938,	0x001 },	/* 0x938 - 0x938 */
	{ 0x730,	0x001 },	/* 0x730 - 0x730 */
	{ 0x930,	0x001 },	/* 0x930 - 0x930 */
	{ 0x731,	0x001 },	/* 0x731 - 0x731 */
	{ 0x931,	0x001 },	/* 0x931 - 0x931 */
	{ 0x729,	0x001 },	/* 0x729 - 0x729 */
	{ 0x929,	0x001 },	/* 0x929 - 0x929 */
	{ 0x732,	0x001 },	/* 0x732 - 0x732 */
	{ 0x932,	0x001 },	/* 0x932 - 0x932 */
	{ 0x733,	0x001 },	/* 0x733 - 0x733 */
	{ 0x933,	0x001 },	/* 0x933 - 0x933 */
	{ 0x728,	0x001 },	/* 0x728 - 0x728 */
	{ 0x928,	0x001 },	/* 0x928 - 0x928 */
	{ 0x73e,	0x001 },	/* 0x73e - 0x73e */
	{ 0x93e,	0x001 },	/* 0x93e - 0x93e */
	{ 0x725,	0x001 },	/* 0x725 - 0x725 */
	{ 0x925,	0x001 },	/* 0x925 - 0x925 */
	{ 0x727,	0x001 },	/* 0x727 - 0x727 */
	{ 0x927,	0x001 },	/* 0x927 - 0x927 */
	{ 0x722,	0x001 },	/* 0x722 - 0x722 */
	{ 0x922,	0x001 },	/* 0x922 - 0x922 */
	{ 0x416,	0x001 },	/* 0x416 - 0x416 */
	{ 0x726,	0x001 },	/* 0x726 - 0x726 */
	{ 0x926,	0x001 },	/* 0x926 - 0x926 */
	{ 0x723,	0x001 },	/* 0x723 - 0x723 */
	{ 0x923,	0x001 },	/* 0x923 - 0x923 */
	{ 0x724,	0x001 },	/* 0x724 - 0x724 */
	{ 0x924,	0x001 },	/* 0x924 - 0x924 */
	{ 0x721,	0x001 },	/* 0x721 - 0x721 */
	{ 0x921,	0x001 },	/* 0x921 - 0x921 */
	{ 0x720,	0x001 },	/* 0x720 - 0x720 */
	{ 0x920,	0x001 },	/* 0x920 - 0x920 */
	{ 0x40e,	0x001 },	/* 0x40e - 0x40e */
	{ 0x401,	0x001 },	/* 0x401 - 0x401 */
	{ 0x400,	0x001 },	/* 0x400 - 0x400 */
	{ 0x403,	0x002 },	/* 0x403 - 0x404 */
	{ 0x412,	0x001 },	/* 0x412 - 0x412 */
	{ 0x497,	0x002 },	/* 0x497 - 0x498 */
	{ 0x402,	0x001 },	/* 0x402 - 0x402 */
	{ 0x411,	0x001 },	/* 0x411 - 0x411 */
	{ 0x3ab,	0x001 },	/* 0x3ab - 0x3ab */
	{ 0x1f4,	0x001 },	/* 0x1f4 - 0x1f4 */
	{ 0x520,	0x001 },	/* 0x520 - 0x520 */
	{ 0x3ae,	0x001 },	/* 0x3ae - 0x3ae */
	{ 0x1cd,	0x001 },	/* 0x1cd - 0x1cd */
	{ 0x164,	0x001 },	/* 0x164 - 0x164 */
	{ 0x3ca,	0x002 },	/* 0x3ca - 0x3cb */
	{ 0x199,	0x001 },	/* 0x199 - 0x199 */
	{ 0x19b,	0x001 },	/* 0x19b - 0x19b */
	{ 0x19a,	0x001 },	/* 0x19a - 0x19a */
	{ 0x19c,	0x001 },	/* 0x19c - 0x19c */
	{ 0x6a4,	0x002 },	/* 0x6a4 - 0x6a5 */
	{ 0x6ae,	0x001 },	/* 0x6ae - 0x6ae */
	{ 0x6a6,	0x008 },	/* 0x6a6 - 0x6ad */
	{ 0x8a4,	0x002 },	/* 0x8a4 - 0x8a5 */
	{ 0x8ae,	0x001 },	/* 0x8ae - 0x8ae */
	{ 0x8a6,	0x008 },	/* 0x8a6 - 0x8ad */
	{ 0x211,	0x001 },	/* 0x211 - 0x211 */
	{ 0x210,	0x001 },	/* 0x210 - 0x210 */
	{ 0x695,	0x001 },	/* 0x695 - 0x695 */
	{ 0x895,	0x001 },	/* 0x895 - 0x895 */
	{ 0x696,	0x001 },	/* 0x696 - 0x696 */
	{ 0x896,	0x001 },	/* 0x896 - 0x896 */
	{ 0x693,	0x001 },	/* 0x693 - 0x693 */
	{ 0x893,	0x001 },	/* 0x893 - 0x893 */
	{ 0x694,	0x001 },	/* 0x694 - 0x694 */
	{ 0x894,	0x001 },	/* 0x894 - 0x894 */
	{ 0x19e,	0x001 },	/* 0x19e - 0x19e */
	{ 0x19d,	0x001 },	/* 0x19d - 0x19d */
	{ 0x19f,	0x001 },	/* 0x19f - 0x19f */
	{ 0x184,	0x002 },	/* 0x184 - 0x185 */
	{ 0x189,	0x002 },	/* 0x189 - 0x18a */
	{ 0x181,	0x003 },	/* 0x181 - 0x183 */
	{ 0x186,	0x003 },	/* 0x186 - 0x188 */
	{ 0x3ad,	0x001 },	/* 0x3ad - 0x3ad */
	{ 0x783,	0x001 },	/* 0x783 - 0x783 */
	{ 0x983,	0x001 },	/* 0x983 - 0x983 */
	{ 0x782,	0x001 },	/* 0x782 - 0x782 */
	{ 0x982,	0x001 },	/* 0x982 - 0x982 */
	{ 0x785,	0x001 },	/* 0x785 - 0x785 */
	{ 0x985,	0x001 },	/* 0x985 - 0x985 */
	{ 0x784,	0x001 },	/* 0x784 - 0x784 */
	{ 0x984,	0x001 },	/* 0x984 - 0x984 */
	{ 0x787,	0x001 },	/* 0x787 - 0x787 */
	{ 0x987,	0x001 },	/* 0x987 - 0x987 */
	{ 0x786,	0x001 },	/* 0x786 - 0x786 */
	{ 0x986,	0x001 },	/* 0x986 - 0x986 */
	{ 0x796,	0x001 },	/* 0x796 - 0x796 */
	{ 0x996,	0x001 },	/* 0x996 - 0x996 */
	{ 0x797,	0x001 },	/* 0x797 - 0x797 */
	{ 0x997,	0x001 },	/* 0x997 - 0x997 */
	{ 0x15b,	0x001 },	/* 0x15b - 0x15b */
	{ 0x15a,	0x001 },	/* 0x15a - 0x15a */
	{ 0x15c,	0x001 },	/* 0x15c - 0x15c */
	{ 0x141,	0x001 },	/* 0x141 - 0x141 */
	{ 0x6f7,	0x001 },	/* 0x6f7 - 0x6f7 */
	{ 0x8f7,	0x001 },	/* 0x8f7 - 0x8f7 */
	{ 0x143,	0x006 },	/* 0x143 - 0x148 */
	{ 0x142,	0x001 },	/* 0x142 - 0x142 */
	{ 0x149,	0x009 },	/* 0x149 - 0x151 */
	{ 0x18e,	0x002 },	/* 0x18e - 0x18f */
	{ 0x193,	0x002 },	/* 0x193 - 0x194 */
	{ 0x18b,	0x003 },	/* 0x18b - 0x18d */
	{ 0x190,	0x003 },	/* 0x190 - 0x192 */
	{ 0x468,	0x001 },	/* 0x468 - 0x468 */
	{ 0x460,	0x001 },	/* 0x460 - 0x460 */
	{ 0x463,	0x001 },	/* 0x463 - 0x463 */
	{ 0x462,	0x001 },	/* 0x462 - 0x462 */
	{ 0x461,	0x001 },	/* 0x461 - 0x461 */
	{ 0x465,	0x001 },	/* 0x465 - 0x465 */
	{ 0x464,	0x001 },	/* 0x464 - 0x464 */
	{ 0x466,	0x001 },	/* 0x466 - 0x466 */
	{ 0x49e,	0x002 },	/* 0x49e - 0x49f */
	{ 0x4f2,	0x002 },	/* 0x4f2 - 0x4f3 */
	{ 0x495,	0x001 },	/* 0x495 - 0x495 */
	{ 0x492,	0x001 },	/* 0x492 - 0x492 */
	{ 0x491,	0x001 },	/* 0x491 - 0x491 */
	{ 0x4f7,	0x001 },	/* 0x4f7 - 0x4f7 */
	{ 0x040,	0x001 },	/* 0x040 - 0x040 */
	{ 0x1c2,	0x002 },	/* 0x1c2 - 0x1c3 */
	{ 0x1bf,	0x003 },	/* 0x1bf - 0x1c1 */
	{ 0x1bc,	0x003 },	/* 0x1bc - 0x1be */
	{ 0x175,	0x001 },	/* 0x175 - 0x175 */
	{ 0x1a4,	0x001 },	/* 0x1a4 - 0x1a4 */
	{ 0x3c9,	0x001 },	/* 0x3c9 - 0x3c9 */
	{ 0x3c7,	0x002 },	/* 0x3c7 - 0x3c8 */
	{ 0x414,	0x001 },	/* 0x414 - 0x414 */
	{ 0x2c0,	0x001 },	/* 0x2c0 - 0x2c0 */
	{ 0x043,	0x001 },	/* 0x043 - 0x043 */
	{ 0x030,	0x001 },	/* 0x030 - 0x030 */
	{ 0x29c,	0x001 },	/* 0x29c - 0x29c */
	{ 0xc00,	0x001 },	/* 0xc00 - 0xc00 */
	{ 0xc05,	0x004 },	/* 0xc05 - 0xc08 */
	{ 0x4f9,	0x002 },	/* 0x4f9 - 0x4fa */
	{ 0x1e9,	0x001 },	/* 0x1e9 - 0x1e9 */
	{ 0x16a,	0x001 },	/* 0x16a - 0x16a */
	{ 0x1b8,	0x001 },	/* 0x1b8 - 0x1b8 */
	{ 0x470,	0x001 },	/* 0x470 - 0x470 */
	{ 0x46f,	0x001 },	/* 0x46f - 0x46f */
	{ 0x474,	0x001 },	/* 0x474 - 0x474 */
	{ 0x178,	0x001 },	/* 0x178 - 0x178 */
	{ 0x52b,	0x001 },	/* 0x52b - 0x52b */
	{ 0x4fb,	0x001 },	/* 0x4fb - 0x4fb */
	{ 0x315,	0x001 },	/* 0x315 - 0x315 */
	{ 0x317,	0x001 },	/* 0x317 - 0x317 */
	{ 0x314,	0x001 },	/* 0x314 - 0x314 */
	{ 0x316,	0x001 },	/* 0x316 - 0x316 */
	{ 0x319,	0x001 },	/* 0x319 - 0x319 */
	{ 0x31b,	0x001 },	/* 0x31b - 0x31b */
	{ 0x318,	0x001 },	/* 0x318 - 0x318 */
	{ 0x31a,	0x001 },	/* 0x31a - 0x31a */
	{ 0x30e,	0x001 },	/* 0x30e - 0x30e */
	{ 0x2ff,	0x001 },	/* 0x2ff - 0x2ff */
	{ 0x301,	0x001 },	/* 0x301 - 0x301 */
	{ 0x2fe,	0x001 },	/* 0x2fe - 0x2fe */
	{ 0x300,	0x001 },	/* 0x300 - 0x300 */
	{ 0x3c3,	0x001 },	/* 0x3c3 - 0x3c3 */
	{ 0x3c0,	0x001 },	/* 0x3c0 - 0x3c0 */
	{ 0x3bf,	0x001 },	/* 0x3bf - 0x3bf */
	{ 0x3be,	0x001 },	/* 0x3be - 0x3be */
	{ 0x014,	0x001 },	/* 0x014 - 0x014 */
	{ 0x010,	0x001 },	/* 0x010 - 0x010 */
	{ 0x00f,	0x001 },	/* 0x00f - 0x00f */
	{ 0x011,	0x001 },	/* 0x011 - 0x011 */
	{ 0x00e,	0x001 },	/* 0x00e - 0x00e */
	{ 0x16e,	0x001 },	/* 0x16e - 0x16e */
	{ 0x172,	0x001 },	/* 0x172 - 0x172 */
	{ 0x1eb,	0x001 },	/* 0x1eb - 0x1eb */
	{ 0x41a,	0x001 },	/* 0x41a - 0x41a */
	{ 0x3d3,	0x001 },	/* 0x3d3 - 0x3d3 */
	{ 0x3b8,	0x001 },	/* 0x3b8 - 0x3b8 */
	{ 0x289,	0x001 },	/* 0x289 - 0x289 */
	{ 0x3b7,	0x001 },	/* 0x3b7 - 0x3b7 */
	{ 0x077,	0x001 },	/* 0x077 - 0x077 */
	{ 0x3b6,	0x001 },	/* 0x3b6 - 0x3b6 */
	{ 0x076,	0x001 },	/* 0x076 - 0x076 */
	{ 0x072,	0x001 },	/* 0x072 - 0x072 */
	{ 0x648,	0x001 },	/* 0x648 - 0x648 */
	{ 0x848,	0x001 },	/* 0x848 - 0x848 */
	{ 0x060,	0x001 },	/* 0x060 - 0x060 */
	{ 0x063,	0x002 },	/* 0x063 - 0x064 */
	{ 0x061,	0x002 },	/* 0x061 - 0x062 */
	{ 0x43c,	0x003 },	/* 0x43c - 0x43e */
	{ 0x439,	0x003 },	/* 0x439 - 0x43b */
	{ 0x3ec,	0x001 },	/* 0x3ec - 0x3ec */
	{ 0x623,	0x001 },	/* 0x623 - 0x623 */
	{ 0x823,	0x001 },	/* 0x823 - 0x823 */
	{ 0x624,	0x001 },	/* 0x624 - 0x624 */
	{ 0x824,	0x001 },	/* 0x824 - 0x824 */
	{ 0x621,	0x001 },	/* 0x621 - 0x621 */
	{ 0x821,	0x001 },	/* 0x821 - 0x821 */
	{ 0x620,	0x001 },	/* 0x620 - 0x620 */
	{ 0x820,	0x001 },	/* 0x820 - 0x820 */
	{ 0x622,	0x001 },	/* 0x622 - 0x622 */
	{ 0x822,	0x001 },	/* 0x822 - 0x822 */
	{ 0x3bc,	0x002 },	/* 0x3bc - 0x3bd */
	{ 0x007,	0x001 },	/* 0x007 - 0x007 */
	{ 0x02b,	0x001 },	/* 0x02b - 0x02b */
	{ 0x625,	0x007 },	/* 0x625 - 0x62b */
	{ 0x825,	0x007 },	/* 0x825 - 0x82b */
	{ 0x065,	0x001 },	/* 0x065 - 0x065 */
	{ 0x605,	0x001 },	/* 0x605 - 0x605 */
	{ 0x805,	0x001 },	/* 0x805 - 0x805 */
	{ 0x60b,	0x001 },	/* 0x60b - 0x60b */
	{ 0x80b,	0x001 },	/* 0x80b - 0x80b */
	{ 0x60e,	0x001 },	/* 0x60e - 0x60e */
	{ 0x80e,	0x001 },	/* 0x80e - 0x80e */
	{ 0x60c,	0x001 },	/* 0x60c - 0x60c */
	{ 0x80c,	0x001 },	/* 0x80c - 0x80c */
	{ 0x604,	0x001 },	/* 0x604 - 0x604 */
	{ 0x804,	0x001 },	/* 0x804 - 0x804 */
	{ 0x60a,	0x001 },	/* 0x60a - 0x60a */
	{ 0x80a,	0x001 },	/* 0x80a - 0x80a */
	{ 0x60d,	0x001 },	/* 0x60d - 0x60d */
	{ 0x80d,	0x001 },	/* 0x80d - 0x80d */
	{ 0x60f,	0x001 },	/* 0x60f - 0x60f */
	{ 0x80f,	0x001 },	/* 0x80f - 0x80f */
	{ 0x0b9,	0x001 },	/* 0x0b9 - 0x0b9 */
	{ 0x0b0,	0x009 },	/* 0x0b0 - 0x0b8 */
	{ 0x0d7,	0x001 },	/* 0x0d7 - 0x0d7 */
	{ 0x0ce,	0x009 },	/* 0x0ce - 0x0d6 */
	{ 0x0e1,	0x001 },	/* 0x0e1 - 0x0e1 */
	{ 0x0d8,	0x009 },	/* 0x0d8 - 0x0e0 */
	{ 0x0c3,	0x001 },	/* 0x0c3 - 0x0c3 */
	{ 0x0ba,	0x009 },	/* 0x0ba - 0x0c2 */
	{ 0x0eb,	0x001 },	/* 0x0eb - 0x0eb */
	{ 0x0e2,	0x009 },	/* 0x0e2 - 0x0ea */
	{ 0x0cd,	0x001 },	/* 0x0cd - 0x0cd */
	{ 0x0c4,	0x009 },	/* 0x0c4 - 0x0cc */
	{ 0x10a,	0x001 },	/* 0x10a - 0x10a */
	{ 0x0f5,	0x001 },	/* 0x0f5 - 0x0f5 */
	{ 0x0ec,	0x009 },	/* 0x0ec - 0x0f4 */
	{ 0x0ff,	0x001 },	/* 0x0ff - 0x0ff */
	{ 0x0f6,	0x009 },	/* 0x0f6 - 0x0fe */
	{ 0x109,	0x001 },	/* 0x109 - 0x109 */
	{ 0x100,	0x009 },	/* 0x100 - 0x108 */
	{ 0x3ef,	0x001 },	/* 0x3ef - 0x3ef */
	{ 0x028,	0x001 },	/* 0x028 - 0x028 */
	{ 0x781,	0x001 },	/* 0x781 - 0x781 */
	{ 0x981,	0x001 },	/* 0x981 - 0x981 */
	{ 0x780,	0x001 },	/* 0x780 - 0x780 */
	{ 0x980,	0x001 },	/* 0x980 - 0x980 */
	{ 0x027,	0x001 },	/* 0x027 - 0x027 */
	{ 0x020,	0x001 },	/* 0x020 - 0x020 */
	{ 0x02a,	0x001 },	/* 0x02a - 0x02a */
	{ 0x029,	0x001 },	/* 0x029 - 0x029 */
	{ 0x643,	0x001 },	/* 0x643 - 0x643 */
	{ 0x843,	0x001 },	/* 0x843 - 0x843 */
	{ 0x647,	0x001 },	/* 0x647 - 0x647 */
	{ 0x847,	0x001 },	/* 0x847 - 0x847 */
	{ 0x073,	0x001 },	/* 0x073 - 0x073 */
	{ 0x070,	0x001 },	/* 0x070 - 0x070 */
	{ 0x641,	0x001 },	/* 0x641 - 0x641 */
	{ 0x841,	0x001 },	/* 0x841 - 0x841 */
	{ 0x074,	0x001 },	/* 0x074 - 0x074 */
	{ 0x64a,	0x001 },	/* 0x64a - 0x64a */
	{ 0x84a,	0x001 },	/* 0x84a - 0x84a */
	{ 0x645,	0x001 },	/* 0x645 - 0x645 */
	{ 0x845,	0x001 },	/* 0x845 - 0x845 */
	{ 0x64c,	0x001 },	/* 0x64c - 0x64c */
	{ 0x84c,	0x001 },	/* 0x84c - 0x84c */
	{ 0x644,	0x001 },	/* 0x644 - 0x644 */
	{ 0x844,	0x001 },	/* 0x844 - 0x844 */
	{ 0x071,	0x001 },	/* 0x071 - 0x071 */
	{ 0x64b,	0x001 },	/* 0x64b - 0x64b */
	{ 0x84b,	0x001 },	/* 0x84b - 0x84b */
	{ 0x649,	0x001 },	/* 0x649 - 0x649 */
	{ 0x849,	0x001 },	/* 0x849 - 0x849 */
	{ 0x075,	0x001 },	/* 0x075 - 0x075 */
	{ 0x640,	0x001 },	/* 0x640 - 0x640 */
	{ 0x840,	0x001 },	/* 0x840 - 0x840 */
	{ 0x646,	0x001 },	/* 0x646 - 0x646 */
	{ 0x846,	0x001 },	/* 0x846 - 0x846 */
	{ 0x026,	0x001 },	/* 0x026 - 0x026 */
	{ 0x601,	0x001 },	/* 0x601 - 0x601 */
	{ 0x801,	0x001 },	/* 0x801 - 0x801 */
	{ 0x603,	0x001 },	/* 0x603 - 0x603 */
	{ 0x602,	0x001 },	/* 0x602 - 0x602 */
	{ 0x803,	0x001 },	/* 0x803 - 0x803 */
	{ 0x802,	0x001 },	/* 0x802 - 0x802 */
	{ 0x607,	0x001 },	/* 0x607 - 0x607 */
	{ 0x606,	0x001 },	/* 0x606 - 0x606 */
	{ 0x807,	0x001 },	/* 0x807 - 0x807 */
	{ 0x806,	0x001 },	/* 0x806 - 0x806 */
	{ 0x608,	0x001 },	/* 0x608 - 0x608 */
	{ 0x808,	0x001 },	/* 0x808 - 0x808 */
	{ 0x025,	0x001 },	/* 0x025 - 0x025 */
	{ 0x022,	0x001 },	/* 0x022 - 0x022 */
	{ 0x049,	0x006 },	/* 0x049 - 0x04e */
	{ 0x045,	0x001 },	/* 0x045 - 0x045 */
	{ 0x791,	0x001 },	/* 0x791 - 0x791 */
	{ 0x991,	0x001 },	/* 0x991 - 0x991 */
	{ 0x790,	0x001 },	/* 0x790 - 0x790 */
	{ 0x990,	0x001 },	/* 0x990 - 0x990 */
	{ 0x000,	0x001 },	/* 0x000 - 0x000 */
	{ 0x158,	0x001 },	/* 0x158 - 0x158 */
	{ 0x157,	0x001 },	/* 0x157 - 0x157 */
	{ 0x024,	0x001 },	/* 0x024 - 0x024 */
	{ 0x1cc,	0x001 },	/* 0x1cc - 0x1cc */
	{ 0x1ca,	0x002 },	/* 0x1ca - 0x1cb */
	{ 0x1d8,	0x006 },	/* 0x1d8 - 0x1dd */
	{ 0x529,	0x001 },	/* 0x529 - 0x529 */
	{ 0x528,	0x001 },	/* 0x528 - 0x528 */
	{ 0x527,	0x001 },	/* 0x527 - 0x527 */
	{ 0x526,	0x001 },	/* 0x526 - 0x526 */
	{ 0x525,	0x001 },	/* 0x525 - 0x525 */
	{ 0x524,	0x001 },	/* 0x524 - 0x524 */
	{ 0x58f,	0x001 },	/* 0x58f - 0x58f */
	{ 0x2d2,	0x001 },	/* 0x2d2 - 0x2d2 */
	{ 0x2d5,	0x001 },	/* 0x2d5 - 0x2d5 */
	{ 0,	0 }
};
static phy_regs_t acphy2_regs[] = {
	{ 0xc18,	0x001 },	/* 0xc18 - 0xc18 */
	{ 0xc15,	0x001 },	/* 0xc15 - 0xc15 */
	{ 0xc14,	0x001 },	/* 0xc14 - 0xc14 */
	{ 0xc16,	0x001 },	/* 0xc16 - 0xc16 */
	{ 0x1f8,	0x001 },	/* 0x1f8 - 0x1f8 */
	{ 0x5b0,	0x001 },	/* 0x5b0 - 0x5b0 */
	{ 0x5af,	0x001 },	/* 0x5af - 0x5af */
	{ 0x5b1,	0x001 },	/* 0x5b1 - 0x5b1 */
	{ 0x7aa,	0x001 },	/* 0x7aa - 0x7aa */
	{ 0x7a9,	0x001 },	/* 0x7a9 - 0x7a9 */
	{ 0x7a8,	0x001 },	/* 0x7a8 - 0x7a8 */
	{ 0x5a1,	0x001 },	/* 0x5a1 - 0x5a1 */
	{ 0x5a0,	0x001 },	/* 0x5a0 - 0x5a0 */
	{ 0x5a6,	0x002 },	/* 0x5a6 - 0x5a7 */
	{ 0x5a4,	0x002 },	/* 0x5a4 - 0x5a5 */
	{ 0x5aa,	0x001 },	/* 0x5aa - 0x5aa */
	{ 0x5a9,	0x001 },	/* 0x5a9 - 0x5a9 */
	{ 0x5a8,	0x001 },	/* 0x5a8 - 0x5a8 */
	{ 0x5ae,	0x001 },	/* 0x5ae - 0x5ae */
	{ 0x7a3,	0x001 },	/* 0x7a3 - 0x7a3 */
	{ 0x7a1,	0x001 },	/* 0x7a1 - 0x7a1 */
	{ 0x7a7,	0x001 },	/* 0x7a7 - 0x7a7 */
	{ 0x7a6,	0x001 },	/* 0x7a6 - 0x7a6 */
	{ 0x7a2,	0x001 },	/* 0x7a2 - 0x7a2 */
	{ 0x7a0,	0x001 },	/* 0x7a0 - 0x7a0 */
	{ 0x7a5,	0x001 },	/* 0x7a5 - 0x7a5 */
	{ 0x7a4,	0x001 },	/* 0x7a4 - 0x7a4 */
	{ 0x7ac,	0x001 },	/* 0x7ac - 0x7ac */
	{ 0x7ab,	0x001 },	/* 0x7ab - 0x7ab */
	{ 0x5a2,	0x002 },	/* 0x5a2 - 0x5a3 */
	{ 0x5b3,	0x001 },	/* 0x5b3 - 0x5b3 */
	{ 0x1fa,	0x001 },	/* 0x1fa - 0x1fa */
	{ 0x1fe,	0x001 },	/* 0x1fe - 0x1fe */
	{ 0x5ab,	0x001 },	/* 0x5ab - 0x5ab */
	{ 0x1f9,	0x001 },	/* 0x1f9 - 0x1f9 */
	{ 0x1fd,	0x001 },	/* 0x1fd - 0x1fd */
	{ 0x5b2,	0x001 },	/* 0x5b2 - 0x5b2 */
	{ 0x5ad,	0x001 },	/* 0x5ad - 0x5ad */
	{ 0x5ac,	0x001 },	/* 0x5ac - 0x5ac */
	{ 0x165,	0x003 },	/* 0x165 - 0x167 */
	{ 0x52a,	0x001 },	/* 0x52a - 0x52a */
	{ 0x467,	0x001 },	/* 0x467 - 0x467 */
	{ 0x596,	0x001 },	/* 0x596 - 0x596 */
	{ 0x598,	0x001 },	/* 0x598 - 0x598 */
	{ 0x595,	0x001 },	/* 0x595 - 0x595 */
	{ 0x594,	0x001 },	/* 0x594 - 0x594 */
	{ 0x592,	0x002 },	/* 0x592 - 0x593 */
	{ 0x410,	0x001 },	/* 0x410 - 0x410 */
	{ 0x749,	0x001 },	/* 0x749 - 0x749 */
	{ 0x751,	0x003 },	/* 0x751 - 0x753 */
	{ 0x750,	0x001 },	/* 0x750 - 0x750 */
	{ 0x40f,	0x001 },	/* 0x40f - 0x40f */
	{ 0x42d,	0x001 },	/* 0x42d - 0x42d */
	{ 0x428,	0x001 },	/* 0x428 - 0x428 */
	{ 0x42c,	0x001 },	/* 0x42c - 0x42c */
	{ 0x42b,	0x001 },	/* 0x42b - 0x42b */
	{ 0x42a,	0x001 },	/* 0x42a - 0x42a */
	{ 0x429,	0x001 },	/* 0x429 - 0x429 */
	{ 0x424,	0x001 },	/* 0x424 - 0x424 */
	{ 0x422,	0x001 },	/* 0x422 - 0x422 */
	{ 0x420,	0x001 },	/* 0x420 - 0x420 */
	{ 0x426,	0x001 },	/* 0x426 - 0x426 */
	{ 0x425,	0x001 },	/* 0x425 - 0x425 */
	{ 0x423,	0x001 },	/* 0x423 - 0x423 */
	{ 0x421,	0x001 },	/* 0x421 - 0x421 */
	{ 0x427,	0x001 },	/* 0x427 - 0x427 */
	{ 0x3b3,	0x001 },	/* 0x3b3 - 0x3b3 */
	{ 0x3d4,	0x001 },	/* 0x3d4 - 0x3d4 */
	{ 0x407,	0x001 },	/* 0x407 - 0x407 */
	{ 0x251,	0x001 },	/* 0x251 - 0x251 */
	{ 0x253,	0x001 },	/* 0x253 - 0x253 */
	{ 0x252,	0x001 },	/* 0x252 - 0x252 */
	{ 0x254,	0x001 },	/* 0x254 - 0x254 */
	{ 0x162,	0x001 },	/* 0x162 - 0x162 */
	{ 0xc40,	0x001 },	/* 0xc40 - 0xc40 */
	{ 0x161,	0x001 },	/* 0x161 - 0x161 */
	{ 0xc41,	0x001 },	/* 0xc41 - 0xc41 */
	{ 0x406,	0x001 },	/* 0x406 - 0x406 */
	{ 0x691,	0x001 },	/* 0x691 - 0x691 */
	{ 0x001,	0x001 },	/* 0x001 - 0x001 */
	{ 0x454,	0x006 },	/* 0x454 - 0x459 */
	{ 0x442,	0x002 },	/* 0x442 - 0x443 */
	{ 0x44a,	0x00a },	/* 0x44a - 0x453 */
	{ 0x446,	0x001 },	/* 0x446 - 0x446 */
	{ 0x445,	0x001 },	/* 0x445 - 0x445 */
	{ 0x444,	0x001 },	/* 0x444 - 0x444 */
	{ 0x447,	0x003 },	/* 0x447 - 0x449 */
	{ 0x45a,	0x001 },	/* 0x45a - 0x45a */
	{ 0x430,	0x004 },	/* 0x430 - 0x433 */
	{ 0x023,	0x001 },	/* 0x023 - 0x023 */
	{ 0x434,	0x005 },	/* 0x434 - 0x438 */
	{ 0x441,	0x001 },	/* 0x441 - 0x441 */
	{ 0x43f,	0x002 },	/* 0x43f - 0x440 */
	{ 0x3e6,	0x001 },	/* 0x3e6 - 0x3e6 */
	{ 0x363,	0x001 },	/* 0x363 - 0x363 */
	{ 0x1fb,	0x001 },	/* 0x1fb - 0x1fb */
	{ 0x15e,	0x001 },	/* 0x15e - 0x15e */
	{ 0x351,	0x003 },	/* 0x351 - 0x353 */
	{ 0x34d,	0x004 },	/* 0x34d - 0x350 */
	{ 0x3a1,	0x001 },	/* 0x3a1 - 0x3a1 */
	{ 0x3a8,	0x001 },	/* 0x3a8 - 0x3a8 */
	{ 0x390,	0x002 },	/* 0x390 - 0x391 */
	{ 0x397,	0x002 },	/* 0x397 - 0x398 */
	{ 0x396,	0x001 },	/* 0x396 - 0x396 */
	{ 0x399,	0x002 },	/* 0x399 - 0x39a */
	{ 0x293,	0x003 },	/* 0x293 - 0x295 */
	{ 0x3a6,	0x001 },	/* 0x3a6 - 0x3a6 */
	{ 0x174,	0x001 },	/* 0x174 - 0x174 */
	{ 0x35b,	0x008 },	/* 0x35b - 0x362 */
	{ 0x3a2,	0x004 },	/* 0x3a2 - 0x3a5 */
	{ 0x3a9,	0x001 },	/* 0x3a9 - 0x3a9 */
	{ 0x46a,	0x001 },	/* 0x46a - 0x46a */
	{ 0x3a7,	0x001 },	/* 0x3a7 - 0x3a7 */
	{ 0x3f0,	0x001 },	/* 0x3f0 - 0x3f0 */
	{ 0x29b,	0x001 },	/* 0x29b - 0x29b */
	{ 0x418,	0x001 },	/* 0x418 - 0x418 */
	{ 0x40a,	0x001 },	/* 0x40a - 0x40a */
	{ 0xc01,	0x001 },	/* 0xc01 - 0xc01 */
	{ 0xc04,	0x001 },	/* 0xc04 - 0xc04 */
	{ 0xc02,	0x002 },	/* 0xc02 - 0xc03 */
	{ 0x371,	0x006 },	/* 0x371 - 0x376 */
	{ 0x04f,	0x001 },	/* 0x04f - 0x04f */
	{ 0x795,	0x001 },	/* 0x795 - 0x795 */
	{ 0x794,	0x001 },	/* 0x794 - 0x794 */
	{ 0x1ea,	0x001 },	/* 0x1ea - 0x1ea */
	{ 0x496,	0x001 },	/* 0x496 - 0x496 */
	{ 0x3d1,	0x002 },	/* 0x3d1 - 0x3d2 */
	{ 0x3d6,	0x001 },	/* 0x3d6 - 0x3d6 */
	{ 0x170,	0x001 },	/* 0x170 - 0x170 */
	{ 0x296,	0x001 },	/* 0x296 - 0x296 */
	{ 0x3d8,	0x002 },	/* 0x3d8 - 0x3d9 */
	{ 0x2d0,	0x001 },	/* 0x2d0 - 0x2d0 */
	{ 0x003,	0x002 },	/* 0x003 - 0x004 */
	{ 0x2d3,	0x002 },	/* 0x2d3 - 0x2d4 */
	{ 0xc30,	0x00c },	/* 0xc30 - 0xc3b */
	{ 0x140,	0x001 },	/* 0x140 - 0x140 */
	{ 0x30f,	0x005 },	/* 0x30f - 0x313 */
	{ 0x1e2,	0x001 },	/* 0x1e2 - 0x1e2 */
	{ 0x1e4,	0x001 },	/* 0x1e4 - 0x1e4 */
	{ 0x1e3,	0x001 },	/* 0x1e3 - 0x1e3 */
	{ 0x1e5,	0x001 },	/* 0x1e5 - 0x1e5 */
	{ 0x29e,	0x001 },	/* 0x29e - 0x29e */
	{ 0x48b,	0x001 },	/* 0x48b - 0x48b */
	{ 0x2e7,	0x002 },	/* 0x2e7 - 0x2e8 */
	{ 0x6e6,	0x001 },	/* 0x6e6 - 0x6e6 */
	{ 0x6ea,	0x001 },	/* 0x6ea - 0x6ea */
	{ 0x6f8,	0x001 },	/* 0x6f8 - 0x6f8 */
	{ 0x6fd,	0x001 },	/* 0x6fd - 0x6fd */
	{ 0x6fa,	0x003 },	/* 0x6fa - 0x6fc */
	{ 0x6e9,	0x001 },	/* 0x6e9 - 0x6e9 */
	{ 0x6f9,	0x001 },	/* 0x6f9 - 0x6f9 */
	{ 0x6ed,	0x001 },	/* 0x6ed - 0x6ed */
	{ 0x6d2,	0x002 },	/* 0x6d2 - 0x6d3 */
	{ 0x6d5,	0x001 },	/* 0x6d5 - 0x6d5 */
	{ 0x6d1,	0x001 },	/* 0x6d1 - 0x6d1 */
	{ 0x6d7,	0x001 },	/* 0x6d7 - 0x6d7 */
	{ 0x6da,	0x001 },	/* 0x6da - 0x6da */
	{ 0x6e4,	0x002 },	/* 0x6e4 - 0x6e5 */
	{ 0x6db,	0x001 },	/* 0x6db - 0x6db */
	{ 0x6de,	0x002 },	/* 0x6de - 0x6df */
	{ 0x6e2,	0x002 },	/* 0x6e2 - 0x6e3 */
	{ 0x6e0,	0x002 },	/* 0x6e0 - 0x6e1 */
	{ 0x6d4,	0x001 },	/* 0x6d4 - 0x6d4 */
	{ 0x6d0,	0x001 },	/* 0x6d0 - 0x6d0 */
	{ 0x6d8,	0x001 },	/* 0x6d8 - 0x6d8 */
	{ 0x6ef,	0x001 },	/* 0x6ef - 0x6ef */
	{ 0x6e8,	0x001 },	/* 0x6e8 - 0x6e8 */
	{ 0x6dc,	0x002 },	/* 0x6dc - 0x6dd */
	{ 0x6e7,	0x001 },	/* 0x6e7 - 0x6e7 */
	{ 0x6d6,	0x001 },	/* 0x6d6 - 0x6d6 */
	{ 0x6eb,	0x002 },	/* 0x6eb - 0x6ec */
	{ 0x6ee,	0x001 },	/* 0x6ee - 0x6ee */
	{ 0x6d9,	0x001 },	/* 0x6d9 - 0x6d9 */
	{ 0x6f2,	0x002 },	/* 0x6f2 - 0x6f3 */
	{ 0x6f0,	0x002 },	/* 0x6f0 - 0x6f1 */
	{ 0x6f4,	0x001 },	/* 0x6f4 - 0x6f4 */
	{ 0x6a2,	0x002 },	/* 0x6a2 - 0x6a3 */
	{ 0x6a0,	0x002 },	/* 0x6a0 - 0x6a1 */
	{ 0x600,	0x001 },	/* 0x600 - 0x600 */
	{ 0x28a,	0x002 },	/* 0x28a - 0x28b */
	{ 0x160,	0x001 },	/* 0x160 - 0x160 */
	{ 0x173,	0x001 },	/* 0x173 - 0x173 */
	{ 0x31c,	0x001 },	/* 0x31c - 0x31c */
	{ 0x31e,	0x001 },	/* 0x31e - 0x31e */
	{ 0x31d,	0x001 },	/* 0x31d - 0x31d */
	{ 0x31f,	0x001 },	/* 0x31f - 0x31f */
	{ 0x2f1,	0x001 },	/* 0x2f1 - 0x2f1 */
	{ 0x2f9,	0x001 },	/* 0x2f9 - 0x2f9 */
	{ 0x2ed,	0x001 },	/* 0x2ed - 0x2ed */
	{ 0x2f5,	0x001 },	/* 0x2f5 - 0x2f5 */
	{ 0x3cc,	0x001 },	/* 0x3cc - 0x3cc */
	{ 0x304,	0x001 },	/* 0x304 - 0x304 */
	{ 0x30a,	0x001 },	/* 0x30a - 0x30a */
	{ 0x307,	0x001 },	/* 0x307 - 0x307 */
	{ 0x30d,	0x001 },	/* 0x30d - 0x30d */
	{ 0x302,	0x001 },	/* 0x302 - 0x302 */
	{ 0x308,	0x001 },	/* 0x308 - 0x308 */
	{ 0x305,	0x001 },	/* 0x305 - 0x305 */
	{ 0x30b,	0x001 },	/* 0x30b - 0x30b */
	{ 0x303,	0x001 },	/* 0x303 - 0x303 */
	{ 0x309,	0x001 },	/* 0x309 - 0x309 */
	{ 0x306,	0x001 },	/* 0x306 - 0x306 */
	{ 0x30c,	0x001 },	/* 0x30c - 0x30c */
	{ 0x355,	0x001 },	/* 0x355 - 0x355 */
	{ 0x354,	0x001 },	/* 0x354 - 0x354 */
	{ 0x357,	0x001 },	/* 0x357 - 0x357 */
	{ 0x356,	0x001 },	/* 0x356 - 0x356 */
	{ 0x32d,	0x003 },	/* 0x32d - 0x32f */
	{ 0x333,	0x003 },	/* 0x333 - 0x335 */
	{ 0x712,	0x002 },	/* 0x712 - 0x713 */
	{ 0x330,	0x003 },	/* 0x330 - 0x332 */
	{ 0x336,	0x003 },	/* 0x336 - 0x338 */
	{ 0x321,	0x003 },	/* 0x321 - 0x323 */
	{ 0x327,	0x003 },	/* 0x327 - 0x329 */
	{ 0x710,	0x002 },	/* 0x710 - 0x711 */
	{ 0x324,	0x003 },	/* 0x324 - 0x326 */
	{ 0x32a,	0x003 },	/* 0x32a - 0x32c */
	{ 0x176,	0x001 },	/* 0x176 - 0x176 */
	{ 0x2ee,	0x001 },	/* 0x2ee - 0x2ee */
	{ 0x2f6,	0x001 },	/* 0x2f6 - 0x2f6 */
	{ 0x2ea,	0x001 },	/* 0x2ea - 0x2ea */
	{ 0x2f2,	0x001 },	/* 0x2f2 - 0x2f2 */
	{ 0x2ef,	0x001 },	/* 0x2ef - 0x2ef */
	{ 0x2f7,	0x001 },	/* 0x2f7 - 0x2f7 */
	{ 0x2eb,	0x001 },	/* 0x2eb - 0x2eb */
	{ 0x2f3,	0x001 },	/* 0x2f3 - 0x2f3 */
	{ 0x2f0,	0x001 },	/* 0x2f0 - 0x2f0 */
	{ 0x2f8,	0x001 },	/* 0x2f8 - 0x2f8 */
	{ 0x2ec,	0x001 },	/* 0x2ec - 0x2ec */
	{ 0x2f4,	0x001 },	/* 0x2f4 - 0x2f4 */
	{ 0x2c3,	0x003 },	/* 0x2c3 - 0x2c5 */
	{ 0x2c1,	0x002 },	/* 0x2c1 - 0x2c2 */
	{ 0x046,	0x003 },	/* 0x046 - 0x048 */
	{ 0x747,	0x001 },	/* 0x747 - 0x747 */
	{ 0x4b9,	0x001 },	/* 0x4b9 - 0x4b9 */
	{ 0x4c4,	0x00a },	/* 0x4c4 - 0x4cd */
	{ 0x4c0,	0x001 },	/* 0x4c0 - 0x4c0 */
	{ 0x4ce,	0x008 },	/* 0x4ce - 0x4d5 */
	{ 0x4c1,	0x003 },	/* 0x4c1 - 0x4c3 */
	{ 0x180,	0x001 },	/* 0x180 - 0x180 */
	{ 0x597,	0x001 },	/* 0x597 - 0x597 */
	{ 0x590,	0x001 },	/* 0x590 - 0x590 */
	{ 0x197,	0x002 },	/* 0x197 - 0x198 */
	{ 0x1de,	0x001 },	/* 0x1de - 0x1de */
	{ 0x1d7,	0x001 },	/* 0x1d7 - 0x1d7 */
	{ 0x3d7,	0x001 },	/* 0x3d7 - 0x3d7 */
	{ 0x299,	0x001 },	/* 0x299 - 0x299 */
	{ 0x3f1,	0x001 },	/* 0x3f1 - 0x3f1 */
	{ 0xc45,	0x001 },	/* 0xc45 - 0xc45 */
	{ 0xc42,	0x001 },	/* 0xc42 - 0xc42 */
	{ 0xc44,	0x001 },	/* 0xc44 - 0xc44 */
	{ 0xc43,	0x001 },	/* 0xc43 - 0xc43 */
	{ 0x1b6,	0x001 },	/* 0x1b6 - 0x1b6 */
	{ 0x1f5,	0x001 },	/* 0x1f5 - 0x1f5 */
	{ 0x1f2,	0x001 },	/* 0x1f2 - 0x1f2 */
	{ 0x358,	0x003 },	/* 0x358 - 0x35a */
	{ 0x1fc,	0x001 },	/* 0x1fc - 0x1fc */
	{ 0x5c0,	0x001 },	/* 0x5c0 - 0x5c0 */
	{ 0x7b0,	0x001 },	/* 0x7b0 - 0x7b0 */
	{ 0x7b5,	0x002 },	/* 0x7b5 - 0x7b6 */
	{ 0x7b1,	0x002 },	/* 0x7b1 - 0x7b2 */
	{ 0x7b9,	0x001 },	/* 0x7b9 - 0x7b9 */
	{ 0x7bc,	0x001 },	/* 0x7bc - 0x7bc */
	{ 0x7bf,	0x001 },	/* 0x7bf - 0x7bf */
	{ 0x7ba,	0x001 },	/* 0x7ba - 0x7ba */
	{ 0x7bd,	0x001 },	/* 0x7bd - 0x7bd */
	{ 0x7bb,	0x001 },	/* 0x7bb - 0x7bb */
	{ 0x7be,	0x001 },	/* 0x7be - 0x7be */
	{ 0x1f3,	0x001 },	/* 0x1f3 - 0x1f3 */
	{ 0x1e8,	0x001 },	/* 0x1e8 - 0x1e8 */
	{ 0x3cf,	0x002 },	/* 0x3cf - 0x3d0 */
	{ 0x3c6,	0x001 },	/* 0x3c6 - 0x3c6 */
	{ 0x3c4,	0x002 },	/* 0x3c4 - 0x3c5 */
	{ 0x044,	0x001 },	/* 0x044 - 0x044 */
	{ 0x4d6,	0x001 },	/* 0x4d6 - 0x4d6 */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x33a,	0x004 },	/* 0x33a - 0x33d */
	{ 0x342,	0x004 },	/* 0x342 - 0x345 */
	{ 0x33e,	0x004 },	/* 0x33e - 0x341 */
	{ 0x346,	0x004 },	/* 0x346 - 0x349 */
	{ 0x6f5,	0x002 },	/* 0x6f5 - 0x6f6 */
	{ 0x339,	0x001 },	/* 0x339 - 0x339 */
	{ 0x1ee,	0x001 },	/* 0x1ee - 0x1ee */
	{ 0x1ec,	0x001 },	/* 0x1ec - 0x1ec */
	{ 0x163,	0x001 },	/* 0x163 - 0x163 */
	{ 0x67a,	0x002 },	/* 0x67a - 0x67b */
	{ 0x679,	0x001 },	/* 0x679 - 0x679 */
	{ 0x642,	0x001 },	/* 0x642 - 0x642 */
	{ 0x500,	0x001 },	/* 0x500 - 0x500 */
	{ 0x510,	0x001 },	/* 0x510 - 0x510 */
	{ 0x501,	0x001 },	/* 0x501 - 0x501 */
	{ 0x240,	0x002 },	/* 0x240 - 0x241 */
	{ 0x24a,	0x001 },	/* 0x24a - 0x24a */
	{ 0x242,	0x008 },	/* 0x242 - 0x249 */
	{ 0x213,	0x001 },	/* 0x213 - 0x213 */
	{ 0x234,	0x004 },	/* 0x234 - 0x237 */
	{ 0x230,	0x004 },	/* 0x230 - 0x233 */
	{ 0x212,	0x001 },	/* 0x212 - 0x212 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x219,	0x001 },	/* 0x219 - 0x219 */
	{ 0x214,	0x001 },	/* 0x214 - 0x214 */
	{ 0x218,	0x001 },	/* 0x218 - 0x218 */
	{ 0x216,	0x001 },	/* 0x216 - 0x216 */
	{ 0x215,	0x001 },	/* 0x215 - 0x215 */
	{ 0x238,	0x002 },	/* 0x238 - 0x239 */
	{ 0x067,	0x001 },	/* 0x067 - 0x067 */
	{ 0x066,	0x001 },	/* 0x066 - 0x066 */
	{ 0x419,	0x001 },	/* 0x419 - 0x419 */
	{ 0x177,	0x001 },	/* 0x177 - 0x177 */
	{ 0x16b,	0x001 },	/* 0x16b - 0x16b */
	{ 0x3e0,	0x001 },	/* 0x3e0 - 0x3e0 */
	{ 0x16d,	0x001 },	/* 0x16d - 0x16d */
	{ 0x16c,	0x001 },	/* 0x16c - 0x16c */
	{ 0x169,	0x001 },	/* 0x169 - 0x169 */
	{ 0x259,	0x001 },	/* 0x259 - 0x259 */
	{ 0x690,	0x001 },	/* 0x690 - 0x690 */
	{ 0xc17,	0x001 },	/* 0xc17 - 0xc17 */
	{ 0x29f,	0x001 },	/* 0x29f - 0x29f */
	{ 0x280,	0x009 },	/* 0x280 - 0x288 */
	{ 0x46b,	0x001 },	/* 0x46b - 0x46b */
	{ 0x2e0,	0x001 },	/* 0x2e0 - 0x2e0 */
	{ 0x2e5,	0x001 },	/* 0x2e5 - 0x2e5 */
	{ 0x2e3,	0x001 },	/* 0x2e3 - 0x2e3 */
	{ 0x2e6,	0x001 },	/* 0x2e6 - 0x2e6 */
	{ 0x2e4,	0x001 },	/* 0x2e4 - 0x2e4 */
	{ 0x2e2,	0x001 },	/* 0x2e2 - 0x2e2 */
	{ 0x2e1,	0x001 },	/* 0x2e1 - 0x2e1 */
	{ 0x793,	0x001 },	/* 0x793 - 0x793 */
	{ 0x792,	0x001 },	/* 0x792 - 0x792 */
	{ 0x3e3,	0x001 },	/* 0x3e3 - 0x3e3 */
	{ 0x5d1,	0x003 },	/* 0x5d1 - 0x5d3 */
	{ 0x5d7,	0x003 },	/* 0x5d7 - 0x5d9 */
	{ 0x5d0,	0x001 },	/* 0x5d0 - 0x5d0 */
	{ 0x5d4,	0x003 },	/* 0x5d4 - 0x5d6 */
	{ 0x473,	0x001 },	/* 0x473 - 0x473 */
	{ 0x472,	0x001 },	/* 0x472 - 0x472 */
	{ 0x395,	0x001 },	/* 0x395 - 0x395 */
	{ 0x013,	0x001 },	/* 0x013 - 0x013 */
	{ 0x393,	0x001 },	/* 0x393 - 0x393 */
	{ 0x012,	0x001 },	/* 0x012 - 0x012 */
	{ 0x392,	0x001 },	/* 0x392 - 0x392 */
	{ 0x394,	0x001 },	/* 0x394 - 0x394 */
	{ 0x39c,	0x001 },	/* 0x39c - 0x39c */
	{ 0x39b,	0x001 },	/* 0x39b - 0x39b */
	{ 0x292,	0x001 },	/* 0x292 - 0x292 */
	{ 0x195,	0x002 },	/* 0x195 - 0x196 */
	{ 0x1f6,	0x002 },	/* 0x1f6 - 0x1f7 */
	{ 0x1b0,	0x001 },	/* 0x1b0 - 0x1b0 */
	{ 0x64d,	0x002 },	/* 0x64d - 0x64e */
	{ 0x494,	0x001 },	/* 0x494 - 0x494 */
	{ 0x1e1,	0x001 },	/* 0x1e1 - 0x1e1 */
	{ 0x1e7,	0x001 },	/* 0x1e7 - 0x1e7 */
	{ 0x270,	0x001 },	/* 0x270 - 0x270 */
	{ 0x6c3,	0x001 },	/* 0x6c3 - 0x6c3 */
	{ 0x6c2,	0x001 },	/* 0x6c2 - 0x6c2 */
	{ 0x6c1,	0x001 },	/* 0x6c1 - 0x6c1 */
	{ 0x6c0,	0x001 },	/* 0x6c0 - 0x6c0 */
	{ 0x6c5,	0x001 },	/* 0x6c5 - 0x6c5 */
	{ 0x6c4,	0x001 },	/* 0x6c4 - 0x6c4 */
	{ 0x272,	0x001 },	/* 0x272 - 0x272 */
	{ 0x271,	0x001 },	/* 0x271 - 0x271 */
	{ 0x380,	0x001 },	/* 0x380 - 0x380 */
	{ 0x382,	0x001 },	/* 0x382 - 0x382 */
	{ 0x381,	0x001 },	/* 0x381 - 0x381 */
	{ 0x383,	0x001 },	/* 0x383 - 0x383 */
	{ 0x3b0,	0x001 },	/* 0x3b0 - 0x3b0 */
	{ 0x3af,	0x001 },	/* 0x3af - 0x3af */
	{ 0x3b1,	0x002 },	/* 0x3b1 - 0x3b2 */
	{ 0x3b5,	0x001 },	/* 0x3b5 - 0x3b5 */
	{ 0x3e9,	0x001 },	/* 0x3e9 - 0x3e9 */
	{ 0x46c,	0x002 },	/* 0x46c - 0x46d */
	{ 0x3b9,	0x001 },	/* 0x3b9 - 0x3b9 */
	{ 0x1a0,	0x001 },	/* 0x1a0 - 0x1a0 */
	{ 0x1a2,	0x001 },	/* 0x1a2 - 0x1a2 */
	{ 0x1a1,	0x001 },	/* 0x1a1 - 0x1a1 */
	{ 0x1a3,	0x001 },	/* 0x1a3 - 0x1a3 */
	{ 0x2b3,	0x001 },	/* 0x2b3 - 0x2b3 */
	{ 0x2b1,	0x001 },	/* 0x2b1 - 0x2b1 */
	{ 0x2b0,	0x001 },	/* 0x2b0 - 0x2b0 */
	{ 0x15f,	0x001 },	/* 0x15f - 0x15f */
	{ 0x2ba,	0x001 },	/* 0x2ba - 0x2ba */
	{ 0x2b9,	0x001 },	/* 0x2b9 - 0x2b9 */
	{ 0x2b8,	0x001 },	/* 0x2b8 - 0x2b8 */
	{ 0x2b5,	0x001 },	/* 0x2b5 - 0x2b5 */
	{ 0x2b4,	0x001 },	/* 0x2b4 - 0x2b4 */
	{ 0x2b7,	0x001 },	/* 0x2b7 - 0x2b7 */
	{ 0x2b6,	0x001 },	/* 0x2b6 - 0x2b6 */
	{ 0x2b2,	0x001 },	/* 0x2b2 - 0x2b2 */
	{ 0x3e2,	0x001 },	/* 0x3e2 - 0x3e2 */
	{ 0x3ea,	0x002 },	/* 0x3ea - 0x3eb */
	{ 0x3e1,	0x001 },	/* 0x3e1 - 0x3e1 */
	{ 0x3e5,	0x001 },	/* 0x3e5 - 0x3e5 */
	{ 0x1b7,	0x001 },	/* 0x1b7 - 0x1b7 */
	{ 0x3b4,	0x001 },	/* 0x3b4 - 0x3b4 */
	{ 0x3dc,	0x002 },	/* 0x3dc - 0x3dd */
	{ 0x3e7,	0x002 },	/* 0x3e7 - 0x3e8 */
	{ 0x40c,	0x002 },	/* 0x40c - 0x40d */
	{ 0x3bb,	0x001 },	/* 0x3bb - 0x3bb */
	{ 0x3ba,	0x001 },	/* 0x3ba - 0x3ba */
	{ 0x17a,	0x004 },	/* 0x17a - 0x17d */
	{ 0x377,	0x001 },	/* 0x377 - 0x377 */
	{ 0x78f,	0x001 },	/* 0x78f - 0x78f */
	{ 0x78e,	0x001 },	/* 0x78e - 0x78e */
	{ 0x28d,	0x001 },	/* 0x28d - 0x28d */
	{ 0x28f,	0x001 },	/* 0x28f - 0x28f */
	{ 0x291,	0x001 },	/* 0x291 - 0x291 */
	{ 0x28c,	0x001 },	/* 0x28c - 0x28c */
	{ 0x28e,	0x001 },	/* 0x28e - 0x28e */
	{ 0x290,	0x001 },	/* 0x290 - 0x290 */
	{ 0x471,	0x001 },	/* 0x471 - 0x471 */
	{ 0x49d,	0x001 },	/* 0x49d - 0x49d */
	{ 0x4f5,	0x002 },	/* 0x4f5 - 0x4f6 */
	{ 0x49b,	0x001 },	/* 0x49b - 0x49b */
	{ 0x4f4,	0x001 },	/* 0x4f4 - 0x4f4 */
	{ 0x49c,	0x001 },	/* 0x49c - 0x49c */
	{ 0x1ce,	0x001 },	/* 0x1ce - 0x1ce */
	{ 0x1ef,	0x001 },	/* 0x1ef - 0x1ef */
	{ 0x1bb,	0x001 },	/* 0x1bb - 0x1bb */
	{ 0x1ba,	0x001 },	/* 0x1ba - 0x1ba */
	{ 0x1b9,	0x001 },	/* 0x1b9 - 0x1b9 */
	{ 0x2d1,	0x001 },	/* 0x2d1 - 0x2d1 */
	{ 0x609,	0x001 },	/* 0x609 - 0x609 */
	{ 0x2d6,	0x001 },	/* 0x2d6 - 0x2d6 */
	{ 0x2d9,	0x001 },	/* 0x2d9 - 0x2d9 */
	{ 0x2d7,	0x001 },	/* 0x2d7 - 0x2d7 */
	{ 0x2da,	0x001 },	/* 0x2da - 0x2da */
	{ 0x2d8,	0x001 },	/* 0x2d8 - 0x2d8 */
	{ 0x2db,	0x001 },	/* 0x2db - 0x2db */
	{ 0x583,	0x001 },	/* 0x583 - 0x583 */
	{ 0x586,	0x001 },	/* 0x586 - 0x586 */
	{ 0x588,	0x001 },	/* 0x588 - 0x588 */
	{ 0x58a,	0x001 },	/* 0x58a - 0x58a */
	{ 0x58c,	0x001 },	/* 0x58c - 0x58c */
	{ 0x58e,	0x001 },	/* 0x58e - 0x58e */
	{ 0x585,	0x001 },	/* 0x585 - 0x585 */
	{ 0x587,	0x001 },	/* 0x587 - 0x587 */
	{ 0x589,	0x001 },	/* 0x589 - 0x589 */
	{ 0x58b,	0x001 },	/* 0x58b - 0x58b */
	{ 0x58d,	0x001 },	/* 0x58d - 0x58d */
	{ 0x580,	0x001 },	/* 0x580 - 0x580 */
	{ 0x591,	0x001 },	/* 0x591 - 0x591 */
	{ 0x584,	0x001 },	/* 0x584 - 0x584 */
	{ 0x581,	0x002 },	/* 0x581 - 0x582 */
	{ 0x523,	0x001 },	/* 0x523 - 0x523 */
	{ 0x522,	0x001 },	/* 0x522 - 0x522 */
	{ 0x521,	0x001 },	/* 0x521 - 0x521 */
	{ 0x171,	0x001 },	/* 0x171 - 0x171 */
	{ 0x29d,	0x001 },	/* 0x29d - 0x29d */
	{ 0x29a,	0x001 },	/* 0x29a - 0x29a */
	{ 0x041,	0x002 },	/* 0x041 - 0x042 */
	{ 0x1b2,	0x004 },	/* 0x1b2 - 0x1b5 */
	{ 0x531,	0x001 },	/* 0x531 - 0x531 */
	{ 0x530,	0x001 },	/* 0x530 - 0x530 */
	{ 0x533,	0x001 },	/* 0x533 - 0x533 */
	{ 0x532,	0x001 },	/* 0x532 - 0x532 */
	{ 0x537,	0x001 },	/* 0x537 - 0x537 */
	{ 0x536,	0x001 },	/* 0x536 - 0x536 */
	{ 0x535,	0x001 },	/* 0x535 - 0x535 */
	{ 0x534,	0x001 },	/* 0x534 - 0x534 */
	{ 0x539,	0x001 },	/* 0x539 - 0x539 */
	{ 0x538,	0x001 },	/* 0x538 - 0x538 */
	{ 0x53b,	0x001 },	/* 0x53b - 0x53b */
	{ 0x53a,	0x001 },	/* 0x53a - 0x53a */
	{ 0x767,	0x001 },	/* 0x767 - 0x767 */
	{ 0x489,	0x001 },	/* 0x489 - 0x489 */
	{ 0x488,	0x001 },	/* 0x488 - 0x488 */
	{ 0x48a,	0x001 },	/* 0x48a - 0x48a */
	{ 0x768,	0x001 },	/* 0x768 - 0x768 */
	{ 0x499,	0x002 },	/* 0x499 - 0x49a */
	{ 0x4b7,	0x001 },	/* 0x4b7 - 0x4b7 */
	{ 0x48c,	0x002 },	/* 0x48c - 0x48d */
	{ 0x4e2,	0x001 },	/* 0x4e2 - 0x4e2 */
	{ 0x4e0,	0x002 },	/* 0x4e0 - 0x4e1 */
	{ 0x4df,	0x001 },	/* 0x4df - 0x4df */
	{ 0x4e6,	0x001 },	/* 0x4e6 - 0x4e6 */
	{ 0x4e4,	0x002 },	/* 0x4e4 - 0x4e5 */
	{ 0x4e3,	0x001 },	/* 0x4e3 - 0x4e3 */
	{ 0x4dd,	0x001 },	/* 0x4dd - 0x4dd */
	{ 0x4d9,	0x001 },	/* 0x4d9 - 0x4d9 */
	{ 0x4db,	0x001 },	/* 0x4db - 0x4db */
	{ 0x4d7,	0x001 },	/* 0x4d7 - 0x4d7 */
	{ 0x4de,	0x001 },	/* 0x4de - 0x4de */
	{ 0x4da,	0x001 },	/* 0x4da - 0x4da */
	{ 0x4dc,	0x001 },	/* 0x4dc - 0x4dc */
	{ 0x4d8,	0x001 },	/* 0x4d8 - 0x4d8 */
	{ 0x53d,	0x001 },	/* 0x53d - 0x53d */
	{ 0x53c,	0x001 },	/* 0x53c - 0x53c */
	{ 0x53f,	0x001 },	/* 0x53f - 0x53f */
	{ 0x53e,	0x001 },	/* 0x53e - 0x53e */
	{ 0x485,	0x001 },	/* 0x485 - 0x485 */
	{ 0x763,	0x003 },	/* 0x763 - 0x765 */
	{ 0x760,	0x003 },	/* 0x760 - 0x762 */
	{ 0x484,	0x001 },	/* 0x484 - 0x484 */
	{ 0x541,	0x001 },	/* 0x541 - 0x541 */
	{ 0x540,	0x001 },	/* 0x540 - 0x540 */
	{ 0x487,	0x001 },	/* 0x487 - 0x487 */
	{ 0x486,	0x001 },	/* 0x486 - 0x486 */
	{ 0x769,	0x001 },	/* 0x769 - 0x769 */
	{ 0x490,	0x001 },	/* 0x490 - 0x490 */
	{ 0x48f,	0x001 },	/* 0x48f - 0x48f */
	{ 0x4b8,	0x001 },	/* 0x4b8 - 0x4b8 */
	{ 0x48e,	0x001 },	/* 0x48e - 0x48e */
	{ 0x766,	0x001 },	/* 0x766 - 0x766 */
	{ 0x480,	0x004 },	/* 0x480 - 0x483 */
	{ 0x4f8,	0x001 },	/* 0x4f8 - 0x4f8 */
	{ 0x16f,	0x001 },	/* 0x16f - 0x16f */
	{ 0x3de,	0x001 },	/* 0x3de - 0x3de */
	{ 0x3d5,	0x001 },	/* 0x3d5 - 0x3d5 */
	{ 0x297,	0x002 },	/* 0x297 - 0x298 */
	{ 0x493,	0x001 },	/* 0x493 - 0x493 */
	{ 0x120,	0x001 },	/* 0x120 - 0x120 */
	{ 0x129,	0x001 },	/* 0x129 - 0x129 */
	{ 0x125,	0x001 },	/* 0x125 - 0x125 */
	{ 0x123,	0x001 },	/* 0x123 - 0x123 */
	{ 0x670,	0x004 },	/* 0x670 - 0x673 */
	{ 0x122,	0x001 },	/* 0x122 - 0x122 */
	{ 0x67c,	0x001 },	/* 0x67c - 0x67c */
	{ 0x124,	0x001 },	/* 0x124 - 0x124 */
	{ 0x12a,	0x001 },	/* 0x12a - 0x12a */
	{ 0x674,	0x002 },	/* 0x674 - 0x675 */
	{ 0x121,	0x001 },	/* 0x121 - 0x121 */
	{ 0x676,	0x003 },	/* 0x676 - 0x678 */
	{ 0x126,	0x003 },	/* 0x126 - 0x128 */
	{ 0x080,	0x001 },	/* 0x080 - 0x080 */
	{ 0x660,	0x001 },	/* 0x660 - 0x660 */
	{ 0x662,	0x001 },	/* 0x662 - 0x662 */
	{ 0x661,	0x001 },	/* 0x661 - 0x661 */
	{ 0x085,	0x002 },	/* 0x085 - 0x086 */
	{ 0x08a,	0x002 },	/* 0x08a - 0x08b */
	{ 0x082,	0x003 },	/* 0x082 - 0x084 */
	{ 0x087,	0x003 },	/* 0x087 - 0x089 */
	{ 0x081,	0x001 },	/* 0x081 - 0x081 */
	{ 0x090,	0x002 },	/* 0x090 - 0x091 */
	{ 0x095,	0x002 },	/* 0x095 - 0x096 */
	{ 0x08d,	0x003 },	/* 0x08d - 0x08f */
	{ 0x092,	0x003 },	/* 0x092 - 0x094 */
	{ 0x08c,	0x001 },	/* 0x08c - 0x08c */
	{ 0x09b,	0x002 },	/* 0x09b - 0x09c */
	{ 0x0a0,	0x002 },	/* 0x0a0 - 0x0a1 */
	{ 0x098,	0x003 },	/* 0x098 - 0x09a */
	{ 0x09d,	0x003 },	/* 0x09d - 0x09f */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x0a3,	0x003 },	/* 0x0a3 - 0x0a5 */
	{ 0x0a7,	0x002 },	/* 0x0a7 - 0x0a8 */
	{ 0x0a6,	0x001 },	/* 0x0a6 - 0x0a6 */
	{ 0x0a2,	0x001 },	/* 0x0a2 - 0x0a2 */
	{ 0x3ac,	0x001 },	/* 0x3ac - 0x3ac */
	{ 0x3aa,	0x001 },	/* 0x3aa - 0x3aa */
	{ 0x1b1,	0x001 },	/* 0x1b1 - 0x1b1 */
	{ 0x1cf,	0x008 },	/* 0x1cf - 0x1d6 */
	{ 0x469,	0x001 },	/* 0x469 - 0x469 */
	{ 0x1ed,	0x001 },	/* 0x1ed - 0x1ed */
	{ 0x3e4,	0x001 },	/* 0x3e4 - 0x3e4 */
	{ 0x3c2,	0x001 },	/* 0x3c2 - 0x3c2 */
	{ 0x3c1,	0x001 },	/* 0x3c1 - 0x3c1 */
	{ 0x078,	0x001 },	/* 0x078 - 0x078 */
	{ 0x370,	0x001 },	/* 0x370 - 0x370 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x46e,	0x001 },	/* 0x46e - 0x46e */
	{ 0x15d,	0x001 },	/* 0x15d - 0x15d */
	{ 0x1c7,	0x001 },	/* 0x1c7 - 0x1c7 */
	{ 0x153,	0x001 },	/* 0x153 - 0x153 */
	{ 0x1c9,	0x001 },	/* 0x1c9 - 0x1c9 */
	{ 0x155,	0x001 },	/* 0x155 - 0x155 */
	{ 0x152,	0x001 },	/* 0x152 - 0x152 */
	{ 0x692,	0x001 },	/* 0x692 - 0x692 */
	{ 0x1c4,	0x003 },	/* 0x1c4 - 0x1c6 */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x1c8,	0x001 },	/* 0x1c8 - 0x1c8 */
	{ 0x156,	0x001 },	/* 0x156 - 0x156 */
	{ 0x405,	0x001 },	/* 0x405 - 0x405 */
	{ 0x168,	0x001 },	/* 0x168 - 0x168 */
	{ 0xc13,	0x001 },	/* 0xc13 - 0xc13 */
	{ 0xc10,	0x001 },	/* 0xc10 - 0xc10 */
	{ 0xc12,	0x001 },	/* 0xc12 - 0xc12 */
	{ 0xc11,	0x001 },	/* 0xc11 - 0xc11 */
	{ 0x1e6,	0x001 },	/* 0x1e6 - 0x1e6 */
	{ 0x1f0,	0x002 },	/* 0x1f0 - 0x1f1 */
	{ 0x1e0,	0x001 },	/* 0x1e0 - 0x1e0 */
	{ 0x799,	0x001 },	/* 0x799 - 0x799 */
	{ 0x798,	0x001 },	/* 0x798 - 0x798 */
	{ 0x3ed,	0x001 },	/* 0x3ed - 0x3ed */
	{ 0x415,	0x001 },	/* 0x415 - 0x415 */
	{ 0x3ee,	0x001 },	/* 0x3ee - 0x3ee */
	{ 0x3da,	0x002 },	/* 0x3da - 0x3db */
	{ 0x3ce,	0x001 },	/* 0x3ce - 0x3ce */
	{ 0x7d3,	0x001 },	/* 0x7d3 - 0x7d3 */
	{ 0x7d7,	0x001 },	/* 0x7d7 - 0x7d7 */
	{ 0x7d9,	0x001 },	/* 0x7d9 - 0x7d9 */
	{ 0x7db,	0x001 },	/* 0x7db - 0x7db */
	{ 0x7d5,	0x001 },	/* 0x7d5 - 0x7d5 */
	{ 0x7d1,	0x002 },	/* 0x7d1 - 0x7d2 */
	{ 0x7d6,	0x001 },	/* 0x7d6 - 0x7d6 */
	{ 0x7d8,	0x001 },	/* 0x7d8 - 0x7d8 */
	{ 0x7da,	0x001 },	/* 0x7da - 0x7da */
	{ 0x7d4,	0x001 },	/* 0x7d4 - 0x7d4 */
	{ 0x7d0,	0x001 },	/* 0x7d0 - 0x7d0 */
	{ 0x7dc,	0x001 },	/* 0x7dc - 0x7dc */
	{ 0x2c8,	0x003 },	/* 0x2c8 - 0x2ca */
	{ 0x2c6,	0x002 },	/* 0x2c6 - 0x2c7 */
	{ 0x3cd,	0x001 },	/* 0x3cd - 0x3cd */
	{ 0x78d,	0x001 },	/* 0x78d - 0x78d */
	{ 0x78c,	0x001 },	/* 0x78c - 0x78c */
	{ 0x789,	0x001 },	/* 0x789 - 0x789 */
	{ 0x788,	0x001 },	/* 0x788 - 0x788 */
	{ 0x78b,	0x001 },	/* 0x78b - 0x78b */
	{ 0x78a,	0x001 },	/* 0x78a - 0x78a */
	{ 0x3df,	0x001 },	/* 0x3df - 0x3df */
	{ 0x25e,	0x001 },	/* 0x25e - 0x25e */
	{ 0x25d,	0x001 },	/* 0x25d - 0x25d */
	{ 0x250,	0x001 },	/* 0x250 - 0x250 */
	{ 0x25f,	0x002 },	/* 0x25f - 0x260 */
	{ 0x264,	0x002 },	/* 0x264 - 0x265 */
	{ 0x25b,	0x001 },	/* 0x25b - 0x25b */
	{ 0x268,	0x001 },	/* 0x268 - 0x268 */
	{ 0x263,	0x001 },	/* 0x263 - 0x263 */
	{ 0x25c,	0x001 },	/* 0x25c - 0x25c */
	{ 0x261,	0x002 },	/* 0x261 - 0x262 */
	{ 0x255,	0x001 },	/* 0x255 - 0x255 */
	{ 0x266,	0x001 },	/* 0x266 - 0x266 */
	{ 0x257,	0x001 },	/* 0x257 - 0x257 */
	{ 0x256,	0x001 },	/* 0x256 - 0x256 */
	{ 0x267,	0x001 },	/* 0x267 - 0x267 */
	{ 0x258,	0x001 },	/* 0x258 - 0x258 */
	{ 0x850,	0x001 },	/* 0x850 - 0x850 */
	{ 0x830,	0x005 },	/* 0x830 - 0x834 */
	{ 0x83f,	0x001 },	/* 0x83f - 0x83f */
	{ 0x83c,	0x003 },	/* 0x83c - 0x83e */
	{ 0x83a,	0x002 },	/* 0x83a - 0x83b */
	{ 0x835,	0x005 },	/* 0x835 - 0x839 */
	{ 0x857,	0x001 },	/* 0x857 - 0x857 */
	{ 0x855,	0x002 },	/* 0x855 - 0x856 */
	{ 0x854,	0x001 },	/* 0x854 - 0x854 */
	{ 0x851,	0x003 },	/* 0x851 - 0x853 */
	{ 0x413,	0x001 },	/* 0x413 - 0x413 */
	{ 0x40b,	0x001 },	/* 0x40b - 0x40b */
	{ 0x409,	0x001 },	/* 0x409 - 0x409 */
	{ 0x748,	0x001 },	/* 0x748 - 0x748 */
	{ 0x408,	0x001 },	/* 0x408 - 0x408 */
	{ 0x741,	0x004 },	/* 0x741 - 0x744 */
	{ 0x73f,	0x002 },	/* 0x73f - 0x740 */
	{ 0x739,	0x002 },	/* 0x739 - 0x73a */
	{ 0x73c,	0x002 },	/* 0x73c - 0x73d */
	{ 0x417,	0x001 },	/* 0x417 - 0x417 */
	{ 0x745,	0x001 },	/* 0x745 - 0x745 */
	{ 0x73b,	0x001 },	/* 0x73b - 0x73b */
	{ 0x735,	0x001 },	/* 0x735 - 0x735 */
	{ 0x734,	0x001 },	/* 0x734 - 0x734 */
	{ 0x737,	0x001 },	/* 0x737 - 0x737 */
	{ 0x736,	0x001 },	/* 0x736 - 0x736 */
	{ 0x746,	0x001 },	/* 0x746 - 0x746 */
	{ 0x738,	0x001 },	/* 0x738 - 0x738 */
	{ 0x730,	0x002 },	/* 0x730 - 0x731 */
	{ 0x729,	0x001 },	/* 0x729 - 0x729 */
	{ 0x732,	0x002 },	/* 0x732 - 0x733 */
	{ 0x728,	0x001 },	/* 0x728 - 0x728 */
	{ 0x73e,	0x001 },	/* 0x73e - 0x73e */
	{ 0x725,	0x001 },	/* 0x725 - 0x725 */
	{ 0x727,	0x001 },	/* 0x727 - 0x727 */
	{ 0x722,	0x001 },	/* 0x722 - 0x722 */
	{ 0x416,	0x001 },	/* 0x416 - 0x416 */
	{ 0x726,	0x001 },	/* 0x726 - 0x726 */
	{ 0x723,	0x002 },	/* 0x723 - 0x724 */
	{ 0x721,	0x001 },	/* 0x721 - 0x721 */
	{ 0x720,	0x001 },	/* 0x720 - 0x720 */
	{ 0x40e,	0x001 },	/* 0x40e - 0x40e */
	{ 0x401,	0x001 },	/* 0x401 - 0x401 */
	{ 0x400,	0x001 },	/* 0x400 - 0x400 */
	{ 0x403,	0x002 },	/* 0x403 - 0x404 */
	{ 0x412,	0x001 },	/* 0x412 - 0x412 */
	{ 0x497,	0x002 },	/* 0x497 - 0x498 */
	{ 0x402,	0x001 },	/* 0x402 - 0x402 */
	{ 0x411,	0x001 },	/* 0x411 - 0x411 */
	{ 0x3ab,	0x001 },	/* 0x3ab - 0x3ab */
	{ 0x1f4,	0x001 },	/* 0x1f4 - 0x1f4 */
	{ 0x520,	0x001 },	/* 0x520 - 0x520 */
	{ 0x3ae,	0x001 },	/* 0x3ae - 0x3ae */
	{ 0x1cd,	0x001 },	/* 0x1cd - 0x1cd */
	{ 0x179,	0x001 },	/* 0x179 - 0x179 */
	{ 0x164,	0x001 },	/* 0x164 - 0x164 */
	{ 0x3ca,	0x002 },	/* 0x3ca - 0x3cb */
	{ 0x199,	0x001 },	/* 0x199 - 0x199 */
	{ 0x19b,	0x001 },	/* 0x19b - 0x19b */
	{ 0x19a,	0x001 },	/* 0x19a - 0x19a */
	{ 0x19c,	0x001 },	/* 0x19c - 0x19c */
	{ 0x6a4,	0x002 },	/* 0x6a4 - 0x6a5 */
	{ 0x6ae,	0x001 },	/* 0x6ae - 0x6ae */
	{ 0x6a6,	0x008 },	/* 0x6a6 - 0x6ad */
	{ 0x211,	0x001 },	/* 0x211 - 0x211 */
	{ 0x210,	0x001 },	/* 0x210 - 0x210 */
	{ 0x695,	0x002 },	/* 0x695 - 0x696 */
	{ 0x693,	0x002 },	/* 0x693 - 0x694 */
	{ 0x19e,	0x001 },	/* 0x19e - 0x19e */
	{ 0x19d,	0x001 },	/* 0x19d - 0x19d */
	{ 0x19f,	0x001 },	/* 0x19f - 0x19f */
	{ 0x184,	0x002 },	/* 0x184 - 0x185 */
	{ 0x189,	0x002 },	/* 0x189 - 0x18a */
	{ 0x181,	0x003 },	/* 0x181 - 0x183 */
	{ 0x186,	0x003 },	/* 0x186 - 0x188 */
	{ 0x3ad,	0x001 },	/* 0x3ad - 0x3ad */
	{ 0x783,	0x001 },	/* 0x783 - 0x783 */
	{ 0x782,	0x001 },	/* 0x782 - 0x782 */
	{ 0x785,	0x001 },	/* 0x785 - 0x785 */
	{ 0x784,	0x001 },	/* 0x784 - 0x784 */
	{ 0x787,	0x001 },	/* 0x787 - 0x787 */
	{ 0x786,	0x001 },	/* 0x786 - 0x786 */
	{ 0x796,	0x002 },	/* 0x796 - 0x797 */
	{ 0x15b,	0x001 },	/* 0x15b - 0x15b */
	{ 0x15a,	0x001 },	/* 0x15a - 0x15a */
	{ 0x15c,	0x001 },	/* 0x15c - 0x15c */
	{ 0x141,	0x001 },	/* 0x141 - 0x141 */
	{ 0x6f7,	0x001 },	/* 0x6f7 - 0x6f7 */
	{ 0x143,	0x006 },	/* 0x143 - 0x148 */
	{ 0x142,	0x001 },	/* 0x142 - 0x142 */
	{ 0x149,	0x009 },	/* 0x149 - 0x151 */
	{ 0x18e,	0x002 },	/* 0x18e - 0x18f */
	{ 0x193,	0x002 },	/* 0x193 - 0x194 */
	{ 0x18b,	0x003 },	/* 0x18b - 0x18d */
	{ 0x190,	0x003 },	/* 0x190 - 0x192 */
	{ 0x468,	0x001 },	/* 0x468 - 0x468 */
	{ 0x460,	0x001 },	/* 0x460 - 0x460 */
	{ 0x463,	0x001 },	/* 0x463 - 0x463 */
	{ 0x462,	0x001 },	/* 0x462 - 0x462 */
	{ 0x461,	0x001 },	/* 0x461 - 0x461 */
	{ 0x465,	0x001 },	/* 0x465 - 0x465 */
	{ 0x464,	0x001 },	/* 0x464 - 0x464 */
	{ 0x466,	0x001 },	/* 0x466 - 0x466 */
	{ 0x49e,	0x003 },	/* 0x49e - 0x4a0 */
	{ 0x4a5,	0x00a },	/* 0x4a5 - 0x4ae */
	{ 0x4a1,	0x001 },	/* 0x4a1 - 0x4a1 */
	{ 0x4af,	0x008 },	/* 0x4af - 0x4b6 */
	{ 0x4a2,	0x003 },	/* 0x4a2 - 0x4a4 */
	{ 0x4f2,	0x002 },	/* 0x4f2 - 0x4f3 */
	{ 0x495,	0x001 },	/* 0x495 - 0x495 */
	{ 0x492,	0x001 },	/* 0x492 - 0x492 */
	{ 0x491,	0x001 },	/* 0x491 - 0x491 */
	{ 0x4f7,	0x001 },	/* 0x4f7 - 0x4f7 */
	{ 0x040,	0x001 },	/* 0x040 - 0x040 */
	{ 0x1c2,	0x002 },	/* 0x1c2 - 0x1c3 */
	{ 0x1bf,	0x003 },	/* 0x1bf - 0x1c1 */
	{ 0x1bc,	0x003 },	/* 0x1bc - 0x1be */
	{ 0x175,	0x001 },	/* 0x175 - 0x175 */
	{ 0x1a4,	0x001 },	/* 0x1a4 - 0x1a4 */
	{ 0x3c9,	0x001 },	/* 0x3c9 - 0x3c9 */
	{ 0x3c7,	0x002 },	/* 0x3c7 - 0x3c8 */
	{ 0x414,	0x001 },	/* 0x414 - 0x414 */
	{ 0x2c0,	0x001 },	/* 0x2c0 - 0x2c0 */
	{ 0x043,	0x001 },	/* 0x043 - 0x043 */
	{ 0x030,	0x001 },	/* 0x030 - 0x030 */
	{ 0x29c,	0x001 },	/* 0x29c - 0x29c */
	{ 0xc00,	0x001 },	/* 0xc00 - 0xc00 */
	{ 0xc05,	0x004 },	/* 0xc05 - 0xc08 */
	{ 0x4f9,	0x002 },	/* 0x4f9 - 0x4fa */
	{ 0x1e9,	0x001 },	/* 0x1e9 - 0x1e9 */
	{ 0x16a,	0x001 },	/* 0x16a - 0x16a */
	{ 0x1b8,	0x001 },	/* 0x1b8 - 0x1b8 */
	{ 0x470,	0x001 },	/* 0x470 - 0x470 */
	{ 0x46f,	0x001 },	/* 0x46f - 0x46f */
	{ 0x474,	0x001 },	/* 0x474 - 0x474 */
	{ 0x178,	0x001 },	/* 0x178 - 0x178 */
	{ 0x52b,	0x001 },	/* 0x52b - 0x52b */
	{ 0x4fb,	0x001 },	/* 0x4fb - 0x4fb */
	{ 0x315,	0x001 },	/* 0x315 - 0x315 */
	{ 0x317,	0x001 },	/* 0x317 - 0x317 */
	{ 0x314,	0x001 },	/* 0x314 - 0x314 */
	{ 0x316,	0x001 },	/* 0x316 - 0x316 */
	{ 0x319,	0x001 },	/* 0x319 - 0x319 */
	{ 0x31b,	0x001 },	/* 0x31b - 0x31b */
	{ 0x318,	0x001 },	/* 0x318 - 0x318 */
	{ 0x31a,	0x001 },	/* 0x31a - 0x31a */
	{ 0x30e,	0x001 },	/* 0x30e - 0x30e */
	{ 0x2ff,	0x001 },	/* 0x2ff - 0x2ff */
	{ 0x301,	0x001 },	/* 0x301 - 0x301 */
	{ 0x2fe,	0x001 },	/* 0x2fe - 0x2fe */
	{ 0x300,	0x001 },	/* 0x300 - 0x300 */
	{ 0x3c3,	0x001 },	/* 0x3c3 - 0x3c3 */
	{ 0x3c0,	0x001 },	/* 0x3c0 - 0x3c0 */
	{ 0x3bf,	0x001 },	/* 0x3bf - 0x3bf */
	{ 0x3be,	0x001 },	/* 0x3be - 0x3be */
	{ 0x014,	0x001 },	/* 0x014 - 0x014 */
	{ 0x010,	0x001 },	/* 0x010 - 0x010 */
	{ 0x00f,	0x001 },	/* 0x00f - 0x00f */
	{ 0x011,	0x001 },	/* 0x011 - 0x011 */
	{ 0x00d,	0x002 },	/* 0x00d - 0x00e */
	{ 0x16e,	0x001 },	/* 0x16e - 0x16e */
	{ 0x172,	0x001 },	/* 0x172 - 0x172 */
	{ 0x1eb,	0x001 },	/* 0x1eb - 0x1eb */
	{ 0x41a,	0x001 },	/* 0x41a - 0x41a */
	{ 0x3d3,	0x001 },	/* 0x3d3 - 0x3d3 */
	{ 0x3b8,	0x001 },	/* 0x3b8 - 0x3b8 */
	{ 0x289,	0x001 },	/* 0x289 - 0x289 */
	{ 0x3b7,	0x001 },	/* 0x3b7 - 0x3b7 */
	{ 0x077,	0x001 },	/* 0x077 - 0x077 */
	{ 0x3b6,	0x001 },	/* 0x3b6 - 0x3b6 */
	{ 0x076,	0x001 },	/* 0x076 - 0x076 */
	{ 0x072,	0x001 },	/* 0x072 - 0x072 */
	{ 0x648,	0x001 },	/* 0x648 - 0x648 */
	{ 0x060,	0x001 },	/* 0x060 - 0x060 */
	{ 0x063,	0x002 },	/* 0x063 - 0x064 */
	{ 0x061,	0x002 },	/* 0x061 - 0x062 */
	{ 0x43c,	0x003 },	/* 0x43c - 0x43e */
	{ 0x439,	0x003 },	/* 0x439 - 0x43b */
	{ 0x3ec,	0x001 },	/* 0x3ec - 0x3ec */
	{ 0x623,	0x002 },	/* 0x623 - 0x624 */
	{ 0x621,	0x001 },	/* 0x621 - 0x621 */
	{ 0x620,	0x001 },	/* 0x620 - 0x620 */
	{ 0x622,	0x001 },	/* 0x622 - 0x622 */
	{ 0x3bc,	0x002 },	/* 0x3bc - 0x3bd */
	{ 0x007,	0x001 },	/* 0x007 - 0x007 */
	{ 0x02b,	0x001 },	/* 0x02b - 0x02b */
	{ 0x625,	0x007 },	/* 0x625 - 0x62b */
	{ 0x065,	0x001 },	/* 0x065 - 0x065 */
	{ 0x605,	0x001 },	/* 0x605 - 0x605 */
	{ 0x60b,	0x001 },	/* 0x60b - 0x60b */
	{ 0x60e,	0x001 },	/* 0x60e - 0x60e */
	{ 0x60c,	0x001 },	/* 0x60c - 0x60c */
	{ 0x604,	0x001 },	/* 0x604 - 0x604 */
	{ 0x60a,	0x001 },	/* 0x60a - 0x60a */
	{ 0x60d,	0x001 },	/* 0x60d - 0x60d */
	{ 0x60f,	0x001 },	/* 0x60f - 0x60f */
	{ 0x0b9,	0x001 },	/* 0x0b9 - 0x0b9 */
	{ 0x0b0,	0x009 },	/* 0x0b0 - 0x0b8 */
	{ 0x0d7,	0x001 },	/* 0x0d7 - 0x0d7 */
	{ 0x0ce,	0x009 },	/* 0x0ce - 0x0d6 */
	{ 0x0e1,	0x001 },	/* 0x0e1 - 0x0e1 */
	{ 0x0d8,	0x009 },	/* 0x0d8 - 0x0e0 */
	{ 0x0c3,	0x001 },	/* 0x0c3 - 0x0c3 */
	{ 0x0ba,	0x009 },	/* 0x0ba - 0x0c2 */
	{ 0x0eb,	0x001 },	/* 0x0eb - 0x0eb */
	{ 0x0e2,	0x009 },	/* 0x0e2 - 0x0ea */
	{ 0x0cd,	0x001 },	/* 0x0cd - 0x0cd */
	{ 0x0c4,	0x009 },	/* 0x0c4 - 0x0cc */
	{ 0x10a,	0x001 },	/* 0x10a - 0x10a */
	{ 0x0f5,	0x001 },	/* 0x0f5 - 0x0f5 */
	{ 0x0ec,	0x009 },	/* 0x0ec - 0x0f4 */
	{ 0x0ff,	0x001 },	/* 0x0ff - 0x0ff */
	{ 0x0f6,	0x009 },	/* 0x0f6 - 0x0fe */
	{ 0x109,	0x001 },	/* 0x109 - 0x109 */
	{ 0x100,	0x009 },	/* 0x100 - 0x108 */
	{ 0x3ef,	0x001 },	/* 0x3ef - 0x3ef */
	{ 0x028,	0x001 },	/* 0x028 - 0x028 */
	{ 0x781,	0x001 },	/* 0x781 - 0x781 */
	{ 0x780,	0x001 },	/* 0x780 - 0x780 */
	{ 0x027,	0x001 },	/* 0x027 - 0x027 */
	{ 0x020,	0x001 },	/* 0x020 - 0x020 */
	{ 0x02a,	0x001 },	/* 0x02a - 0x02a */
	{ 0x029,	0x001 },	/* 0x029 - 0x029 */
	{ 0x643,	0x001 },	/* 0x643 - 0x643 */
	{ 0x647,	0x001 },	/* 0x647 - 0x647 */
	{ 0x073,	0x001 },	/* 0x073 - 0x073 */
	{ 0x070,	0x001 },	/* 0x070 - 0x070 */
	{ 0x641,	0x001 },	/* 0x641 - 0x641 */
	{ 0x074,	0x001 },	/* 0x074 - 0x074 */
	{ 0x64a,	0x001 },	/* 0x64a - 0x64a */
	{ 0x645,	0x001 },	/* 0x645 - 0x645 */
	{ 0x64c,	0x001 },	/* 0x64c - 0x64c */
	{ 0x644,	0x001 },	/* 0x644 - 0x644 */
	{ 0x071,	0x001 },	/* 0x071 - 0x071 */
	{ 0x64b,	0x001 },	/* 0x64b - 0x64b */
	{ 0x649,	0x001 },	/* 0x649 - 0x649 */
	{ 0x075,	0x001 },	/* 0x075 - 0x075 */
	{ 0x640,	0x001 },	/* 0x640 - 0x640 */
	{ 0x646,	0x001 },	/* 0x646 - 0x646 */
	{ 0x026,	0x001 },	/* 0x026 - 0x026 */
	{ 0x601,	0x001 },	/* 0x601 - 0x601 */
	{ 0x603,	0x001 },	/* 0x603 - 0x603 */
	{ 0x602,	0x001 },	/* 0x602 - 0x602 */
	{ 0x607,	0x001 },	/* 0x607 - 0x607 */
	{ 0x606,	0x001 },	/* 0x606 - 0x606 */
	{ 0x608,	0x001 },	/* 0x608 - 0x608 */
	{ 0x025,	0x001 },	/* 0x025 - 0x025 */
	{ 0x022,	0x001 },	/* 0x022 - 0x022 */
	{ 0x049,	0x006 },	/* 0x049 - 0x04e */
	{ 0x045,	0x001 },	/* 0x045 - 0x045 */
	{ 0x791,	0x001 },	/* 0x791 - 0x791 */
	{ 0x790,	0x001 },	/* 0x790 - 0x790 */
	{ 0x000,	0x001 },	/* 0x000 - 0x000 */
	{ 0x158,	0x001 },	/* 0x158 - 0x158 */
	{ 0x157,	0x001 },	/* 0x157 - 0x157 */
	{ 0x024,	0x001 },	/* 0x024 - 0x024 */
	{ 0x1cc,	0x001 },	/* 0x1cc - 0x1cc */
	{ 0x1ca,	0x002 },	/* 0x1ca - 0x1cb */
	{ 0x1d8,	0x006 },	/* 0x1d8 - 0x1dd */
	{ 0x529,	0x001 },	/* 0x529 - 0x529 */
	{ 0x528,	0x001 },	/* 0x528 - 0x528 */
	{ 0x527,	0x001 },	/* 0x527 - 0x527 */
	{ 0x526,	0x001 },	/* 0x526 - 0x526 */
	{ 0x525,	0x001 },	/* 0x525 - 0x525 */
	{ 0x524,	0x001 },	/* 0x524 - 0x524 */
	{ 0x58f,	0x001 },	/* 0x58f - 0x58f */
	{ 0x2d2,	0x001 },	/* 0x2d2 - 0x2d2 */
	{ 0x2d5,	0x001 },	/* 0x2d5 - 0x2d5 */
	{ 0,	0 }
};

static phy_regs_t acphy0_regs[] = {
	{ 0x165,	0x003 },	/* 0x165 - 0x167 */
	{ 0x52a,	0x001 },	/* 0x52a - 0x52a */
	{ 0x467,	0x001 },	/* 0x467 - 0x467 */
	{ 0x410,	0x001 },	/* 0x410 - 0x410 */
	{ 0x751,	0x001 },	/* 0x751 - 0x751 */
	{ 0x951,	0x001 },	/* 0x951 - 0x951 */
	{ 0xb51,	0x001 },	/* 0xb51 - 0xb51 */
	{ 0x752,	0x001 },	/* 0x752 - 0x752 */
	{ 0x952,	0x001 },	/* 0x952 - 0x952 */
	{ 0xb52,	0x001 },	/* 0xb52 - 0xb52 */
	{ 0x753,	0x001 },	/* 0x753 - 0x753 */
	{ 0x953,	0x001 },	/* 0x953 - 0x953 */
	{ 0xb53,	0x001 },	/* 0xb53 - 0xb53 */
	{ 0x750,	0x001 },	/* 0x750 - 0x750 */
	{ 0x950,	0x001 },	/* 0x950 - 0x950 */
	{ 0xb50,	0x001 },	/* 0xb50 - 0xb50 */
	{ 0x40f,	0x001 },	/* 0x40f - 0x40f */
	{ 0x42d,	0x001 },	/* 0x42d - 0x42d */
	{ 0x428,	0x001 },	/* 0x428 - 0x428 */
	{ 0x42c,	0x001 },	/* 0x42c - 0x42c */
	{ 0x42b,	0x001 },	/* 0x42b - 0x42b */
	{ 0x42a,	0x001 },	/* 0x42a - 0x42a */
	{ 0x429,	0x001 },	/* 0x429 - 0x429 */
	{ 0x424,	0x001 },	/* 0x424 - 0x424 */
	{ 0x422,	0x001 },	/* 0x422 - 0x422 */
	{ 0x420,	0x001 },	/* 0x420 - 0x420 */
	{ 0x426,	0x001 },	/* 0x426 - 0x426 */
	{ 0x425,	0x001 },	/* 0x425 - 0x425 */
	{ 0x423,	0x001 },	/* 0x423 - 0x423 */
	{ 0x421,	0x001 },	/* 0x421 - 0x421 */
	{ 0x427,	0x001 },	/* 0x427 - 0x427 */
	{ 0x3b3,	0x001 },	/* 0x3b3 - 0x3b3 */
	{ 0x3d4,	0x001 },	/* 0x3d4 - 0x3d4 */
	{ 0x407,	0x001 },	/* 0x407 - 0x407 */
	{ 0x251,	0x001 },	/* 0x251 - 0x251 */
	{ 0x253,	0x001 },	/* 0x253 - 0x253 */
	{ 0x252,	0x001 },	/* 0x252 - 0x252 */
	{ 0x254,	0x001 },	/* 0x254 - 0x254 */
	{ 0x162,	0x001 },	/* 0x162 - 0x162 */
	{ 0x161,	0x001 },	/* 0x161 - 0x161 */
	{ 0x406,	0x001 },	/* 0x406 - 0x406 */
	{ 0x691,	0x001 },	/* 0x691 - 0x691 */
	{ 0x891,	0x001 },	/* 0x891 - 0x891 */
	{ 0xa91,	0x001 },	/* 0xa91 - 0xa91 */
	{ 0x001,	0x001 },	/* 0x001 - 0x001 */
	{ 0x442,	0x002 },	/* 0x442 - 0x443 */
	{ 0x446,	0x001 },	/* 0x446 - 0x446 */
	{ 0x445,	0x001 },	/* 0x445 - 0x445 */
	{ 0x444,	0x001 },	/* 0x444 - 0x444 */
	{ 0x447,	0x002 },	/* 0x447 - 0x448 */
	{ 0x430,	0x004 },	/* 0x430 - 0x433 */
	{ 0x023,	0x001 },	/* 0x023 - 0x023 */
	{ 0x434,	0x005 },	/* 0x434 - 0x438 */
	{ 0x441,	0x001 },	/* 0x441 - 0x441 */
	{ 0x43f,	0x002 },	/* 0x43f - 0x440 */
	{ 0x3e6,	0x001 },	/* 0x3e6 - 0x3e6 */
	{ 0x351,	0x003 },	/* 0x351 - 0x353 */
	{ 0x34d,	0x004 },	/* 0x34d - 0x350 */
	{ 0x3a1,	0x001 },	/* 0x3a1 - 0x3a1 */
	{ 0x3a8,	0x001 },	/* 0x3a8 - 0x3a8 */
	{ 0x390,	0x002 },	/* 0x390 - 0x391 */
	{ 0x397,	0x002 },	/* 0x397 - 0x398 */
	{ 0x396,	0x001 },	/* 0x396 - 0x396 */
	{ 0x399,	0x002 },	/* 0x399 - 0x39a */
	{ 0x293,	0x003 },	/* 0x293 - 0x295 */
	{ 0x3a6,	0x001 },	/* 0x3a6 - 0x3a6 */
	{ 0x174,	0x001 },	/* 0x174 - 0x174 */
	{ 0x3a2,	0x004 },	/* 0x3a2 - 0x3a5 */
	{ 0x3a9,	0x001 },	/* 0x3a9 - 0x3a9 */
	{ 0x46a,	0x001 },	/* 0x46a - 0x46a */
	{ 0x3a7,	0x001 },	/* 0x3a7 - 0x3a7 */
	{ 0x29b,	0x001 },	/* 0x29b - 0x29b */
	{ 0x418,	0x001 },	/* 0x418 - 0x418 */
	{ 0x40a,	0x001 },	/* 0x40a - 0x40a */
	{ 0x371,	0x006 },	/* 0x371 - 0x376 */
	{ 0x04f,	0x001 },	/* 0x04f - 0x04f */
	{ 0x795,	0x001 },	/* 0x795 - 0x795 */
	{ 0x995,	0x001 },	/* 0x995 - 0x995 */
	{ 0xb95,	0x001 },	/* 0xb95 - 0xb95 */
	{ 0x794,	0x001 },	/* 0x794 - 0x794 */
	{ 0x994,	0x001 },	/* 0x994 - 0x994 */
	{ 0xb94,	0x001 },	/* 0xb94 - 0xb94 */
	{ 0x1ea,	0x001 },	/* 0x1ea - 0x1ea */
	{ 0x496,	0x001 },	/* 0x496 - 0x496 */
	{ 0x3d1,	0x002 },	/* 0x3d1 - 0x3d2 */
	{ 0x3d6,	0x001 },	/* 0x3d6 - 0x3d6 */
	{ 0x170,	0x001 },	/* 0x170 - 0x170 */
	{ 0x296,	0x001 },	/* 0x296 - 0x296 */
	{ 0x3d8,	0x002 },	/* 0x3d8 - 0x3d9 */
	{ 0x2d0,	0x001 },	/* 0x2d0 - 0x2d0 */
	{ 0x003,	0x002 },	/* 0x003 - 0x004 */
	{ 0x2d3,	0x002 },	/* 0x2d3 - 0x2d4 */
	{ 0x140,	0x001 },	/* 0x140 - 0x140 */
	{ 0x30f,	0x005 },	/* 0x30f - 0x313 */
	{ 0x1e2,	0x001 },	/* 0x1e2 - 0x1e2 */
	{ 0x1e4,	0x001 },	/* 0x1e4 - 0x1e4 */
	{ 0x1e3,	0x001 },	/* 0x1e3 - 0x1e3 */
	{ 0x1e5,	0x001 },	/* 0x1e5 - 0x1e5 */
	{ 0x48b,	0x001 },	/* 0x48b - 0x48b */
	{ 0x2e7,	0x002 },	/* 0x2e7 - 0x2e8 */
	{ 0x6e6,	0x001 },	/* 0x6e6 - 0x6e6 */
	{ 0x6ea,	0x001 },	/* 0x6ea - 0x6ea */
	{ 0x6e9,	0x001 },	/* 0x6e9 - 0x6e9 */
	{ 0x6ed,	0x001 },	/* 0x6ed - 0x6ed */
	{ 0x6d2,	0x002 },	/* 0x6d2 - 0x6d3 */
	{ 0x6d5,	0x001 },	/* 0x6d5 - 0x6d5 */
	{ 0x6d1,	0x001 },	/* 0x6d1 - 0x6d1 */
	{ 0x6d7,	0x001 },	/* 0x6d7 - 0x6d7 */
	{ 0x6da,	0x001 },	/* 0x6da - 0x6da */
	{ 0x6e4,	0x002 },	/* 0x6e4 - 0x6e5 */
	{ 0x6db,	0x001 },	/* 0x6db - 0x6db */
	{ 0x6de,	0x002 },	/* 0x6de - 0x6df */
	{ 0x6e2,	0x002 },	/* 0x6e2 - 0x6e3 */
	{ 0x6e0,	0x002 },	/* 0x6e0 - 0x6e1 */
	{ 0x6d4,	0x001 },	/* 0x6d4 - 0x6d4 */
	{ 0x6d0,	0x001 },	/* 0x6d0 - 0x6d0 */
	{ 0x6d8,	0x001 },	/* 0x6d8 - 0x6d8 */
	{ 0x6ef,	0x001 },	/* 0x6ef - 0x6ef */
	{ 0x6e8,	0x001 },	/* 0x6e8 - 0x6e8 */
	{ 0x6dc,	0x002 },	/* 0x6dc - 0x6dd */
	{ 0x6e7,	0x001 },	/* 0x6e7 - 0x6e7 */
	{ 0x6d6,	0x001 },	/* 0x6d6 - 0x6d6 */
	{ 0x6eb,	0x002 },	/* 0x6eb - 0x6ec */
	{ 0x6ee,	0x001 },	/* 0x6ee - 0x6ee */
	{ 0x6d9,	0x001 },	/* 0x6d9 - 0x6d9 */
	{ 0x6f2,	0x002 },	/* 0x6f2 - 0x6f3 */
	{ 0x6f0,	0x002 },	/* 0x6f0 - 0x6f1 */
	{ 0x6f4,	0x001 },	/* 0x6f4 - 0x6f4 */
	{ 0x8e6,	0x001 },	/* 0x8e6 - 0x8e6 */
	{ 0x8ea,	0x001 },	/* 0x8ea - 0x8ea */
	{ 0x8e9,	0x001 },	/* 0x8e9 - 0x8e9 */
	{ 0x8ed,	0x001 },	/* 0x8ed - 0x8ed */
	{ 0x8d2,	0x001 },	/* 0x8d2 - 0x8d2 */
	{ 0x6a2,	0x002 },	/* 0x6a2 - 0x6a3 */
	{ 0x8d3,	0x001 },	/* 0x8d3 - 0x8d3 */
	{ 0x8d5,	0x001 },	/* 0x8d5 - 0x8d5 */
	{ 0x8d1,	0x001 },	/* 0x8d1 - 0x8d1 */
	{ 0x8d7,	0x001 },	/* 0x8d7 - 0x8d7 */
	{ 0x8da,	0x001 },	/* 0x8da - 0x8da */
	{ 0x8e4,	0x002 },	/* 0x8e4 - 0x8e5 */
	{ 0x8db,	0x001 },	/* 0x8db - 0x8db */
	{ 0x8de,	0x002 },	/* 0x8de - 0x8df */
	{ 0x8e2,	0x002 },	/* 0x8e2 - 0x8e3 */
	{ 0x8e0,	0x002 },	/* 0x8e0 - 0x8e1 */
	{ 0x8d4,	0x001 },	/* 0x8d4 - 0x8d4 */
	{ 0x8d0,	0x001 },	/* 0x8d0 - 0x8d0 */
	{ 0x8d8,	0x001 },	/* 0x8d8 - 0x8d8 */
	{ 0x8ef,	0x001 },	/* 0x8ef - 0x8ef */
	{ 0x8e8,	0x001 },	/* 0x8e8 - 0x8e8 */
	{ 0x8dc,	0x002 },	/* 0x8dc - 0x8dd */
	{ 0x8e7,	0x001 },	/* 0x8e7 - 0x8e7 */
	{ 0x8d6,	0x001 },	/* 0x8d6 - 0x8d6 */
	{ 0x8eb,	0x002 },	/* 0x8eb - 0x8ec */
	{ 0x8ee,	0x001 },	/* 0x8ee - 0x8ee */
	{ 0x6a0,	0x002 },	/* 0x6a0 - 0x6a1 */
	{ 0x8d9,	0x001 },	/* 0x8d9 - 0x8d9 */
	{ 0x8f2,	0x002 },	/* 0x8f2 - 0x8f3 */
	{ 0x8f0,	0x002 },	/* 0x8f0 - 0x8f1 */
	{ 0x8f4,	0x001 },	/* 0x8f4 - 0x8f4 */
	{ 0x600,	0x001 },	/* 0x600 - 0x600 */
	{ 0xae6,	0x001 },	/* 0xae6 - 0xae6 */
	{ 0xaea,	0x001 },	/* 0xaea - 0xaea */
	{ 0xae9,	0x001 },	/* 0xae9 - 0xae9 */
	{ 0xaed,	0x001 },	/* 0xaed - 0xaed */
	{ 0xad2,	0x001 },	/* 0xad2 - 0xad2 */
	{ 0x8a2,	0x002 },	/* 0x8a2 - 0x8a3 */
	{ 0xad3,	0x001 },	/* 0xad3 - 0xad3 */
	{ 0xad5,	0x001 },	/* 0xad5 - 0xad5 */
	{ 0xad1,	0x001 },	/* 0xad1 - 0xad1 */
	{ 0xad7,	0x001 },	/* 0xad7 - 0xad7 */
	{ 0xada,	0x001 },	/* 0xada - 0xada */
	{ 0xae4,	0x002 },	/* 0xae4 - 0xae5 */
	{ 0xadb,	0x001 },	/* 0xadb - 0xadb */
	{ 0xade,	0x002 },	/* 0xade - 0xadf */
	{ 0xae2,	0x002 },	/* 0xae2 - 0xae3 */
	{ 0xae0,	0x002 },	/* 0xae0 - 0xae1 */
	{ 0xad4,	0x001 },	/* 0xad4 - 0xad4 */
	{ 0xad0,	0x001 },	/* 0xad0 - 0xad0 */
	{ 0xad8,	0x001 },	/* 0xad8 - 0xad8 */
	{ 0xaef,	0x001 },	/* 0xaef - 0xaef */
	{ 0xae8,	0x001 },	/* 0xae8 - 0xae8 */
	{ 0xadc,	0x002 },	/* 0xadc - 0xadd */
	{ 0xae7,	0x001 },	/* 0xae7 - 0xae7 */
	{ 0xad6,	0x001 },	/* 0xad6 - 0xad6 */
	{ 0xaeb,	0x002 },	/* 0xaeb - 0xaec */
	{ 0xaee,	0x001 },	/* 0xaee - 0xaee */
	{ 0x8a0,	0x002 },	/* 0x8a0 - 0x8a1 */
	{ 0xad9,	0x001 },	/* 0xad9 - 0xad9 */
	{ 0xaf2,	0x002 },	/* 0xaf2 - 0xaf3 */
	{ 0xaf0,	0x002 },	/* 0xaf0 - 0xaf1 */
	{ 0xaf4,	0x001 },	/* 0xaf4 - 0xaf4 */
	{ 0x800,	0x001 },	/* 0x800 - 0x800 */
	{ 0xaa2,	0x002 },	/* 0xaa2 - 0xaa3 */
	{ 0xaa0,	0x002 },	/* 0xaa0 - 0xaa1 */
	{ 0xa00,	0x001 },	/* 0xa00 - 0xa00 */
	{ 0x28a,	0x002 },	/* 0x28a - 0x28b */
	{ 0x160,	0x001 },	/* 0x160 - 0x160 */
	{ 0x173,	0x001 },	/* 0x173 - 0x173 */
	{ 0x31c,	0x001 },	/* 0x31c - 0x31c */
	{ 0x31e,	0x001 },	/* 0x31e - 0x31e */
	{ 0x31d,	0x001 },	/* 0x31d - 0x31d */
	{ 0x31f,	0x001 },	/* 0x31f - 0x31f */
	{ 0x2f1,	0x001 },	/* 0x2f1 - 0x2f1 */
	{ 0x2f9,	0x001 },	/* 0x2f9 - 0x2f9 */
	{ 0x2ed,	0x001 },	/* 0x2ed - 0x2ed */
	{ 0x2f5,	0x001 },	/* 0x2f5 - 0x2f5 */
	{ 0x3cc,	0x001 },	/* 0x3cc - 0x3cc */
	{ 0x304,	0x001 },	/* 0x304 - 0x304 */
	{ 0x30a,	0x001 },	/* 0x30a - 0x30a */
	{ 0x307,	0x001 },	/* 0x307 - 0x307 */
	{ 0x30d,	0x001 },	/* 0x30d - 0x30d */
	{ 0x302,	0x001 },	/* 0x302 - 0x302 */
	{ 0x308,	0x001 },	/* 0x308 - 0x308 */
	{ 0x305,	0x001 },	/* 0x305 - 0x305 */
	{ 0x30b,	0x001 },	/* 0x30b - 0x30b */
	{ 0x303,	0x001 },	/* 0x303 - 0x303 */
	{ 0x309,	0x001 },	/* 0x309 - 0x309 */
	{ 0x306,	0x001 },	/* 0x306 - 0x306 */
	{ 0x30c,	0x001 },	/* 0x30c - 0x30c */
	{ 0x355,	0x001 },	/* 0x355 - 0x355 */
	{ 0x354,	0x001 },	/* 0x354 - 0x354 */
	{ 0x357,	0x001 },	/* 0x357 - 0x357 */
	{ 0x356,	0x001 },	/* 0x356 - 0x356 */
	{ 0x32d,	0x003 },	/* 0x32d - 0x32f */
	{ 0x333,	0x003 },	/* 0x333 - 0x335 */
	{ 0x712,	0x001 },	/* 0x712 - 0x712 */
	{ 0x912,	0x001 },	/* 0x912 - 0x912 */
	{ 0xb12,	0x001 },	/* 0xb12 - 0xb12 */
	{ 0x713,	0x001 },	/* 0x713 - 0x713 */
	{ 0x913,	0x001 },	/* 0x913 - 0x913 */
	{ 0xb13,	0x001 },	/* 0xb13 - 0xb13 */
	{ 0x330,	0x003 },	/* 0x330 - 0x332 */
	{ 0x336,	0x003 },	/* 0x336 - 0x338 */
	{ 0x321,	0x003 },	/* 0x321 - 0x323 */
	{ 0x327,	0x003 },	/* 0x327 - 0x329 */
	{ 0x710,	0x001 },	/* 0x710 - 0x710 */
	{ 0x910,	0x001 },	/* 0x910 - 0x910 */
	{ 0xb10,	0x001 },	/* 0xb10 - 0xb10 */
	{ 0x711,	0x001 },	/* 0x711 - 0x711 */
	{ 0x911,	0x001 },	/* 0x911 - 0x911 */
	{ 0xb11,	0x001 },	/* 0xb11 - 0xb11 */
	{ 0x324,	0x003 },	/* 0x324 - 0x326 */
	{ 0x32a,	0x003 },	/* 0x32a - 0x32c */
	{ 0x2ee,	0x001 },	/* 0x2ee - 0x2ee */
	{ 0x2f6,	0x001 },	/* 0x2f6 - 0x2f6 */
	{ 0x2ea,	0x001 },	/* 0x2ea - 0x2ea */
	{ 0x2f2,	0x001 },	/* 0x2f2 - 0x2f2 */
	{ 0x2ef,	0x001 },	/* 0x2ef - 0x2ef */
	{ 0x2f7,	0x001 },	/* 0x2f7 - 0x2f7 */
	{ 0x2eb,	0x001 },	/* 0x2eb - 0x2eb */
	{ 0x2f3,	0x001 },	/* 0x2f3 - 0x2f3 */
	{ 0x2f0,	0x001 },	/* 0x2f0 - 0x2f0 */
	{ 0x2f8,	0x001 },	/* 0x2f8 - 0x2f8 */
	{ 0x2ec,	0x001 },	/* 0x2ec - 0x2ec */
	{ 0x2f4,	0x001 },	/* 0x2f4 - 0x2f4 */
	{ 0x046,	0x003 },	/* 0x046 - 0x048 */
	{ 0x747,	0x001 },	/* 0x747 - 0x747 */
	{ 0x947,	0x001 },	/* 0x947 - 0x947 */
	{ 0xb47,	0x001 },	/* 0xb47 - 0xb47 */
	{ 0x4b9,	0x001 },	/* 0x4b9 - 0x4b9 */
	{ 0x4c4,	0x00a },	/* 0x4c4 - 0x4cd */
	{ 0x4c0,	0x001 },	/* 0x4c0 - 0x4c0 */
	{ 0x4ce,	0x008 },	/* 0x4ce - 0x4d5 */
	{ 0x4c1,	0x003 },	/* 0x4c1 - 0x4c3 */
	{ 0x180,	0x001 },	/* 0x180 - 0x180 */
	{ 0x197,	0x002 },	/* 0x197 - 0x198 */
	{ 0x3d7,	0x001 },	/* 0x3d7 - 0x3d7 */
	{ 0x299,	0x001 },	/* 0x299 - 0x299 */
	{ 0x1b6,	0x001 },	/* 0x1b6 - 0x1b6 */
	{ 0x1f5,	0x001 },	/* 0x1f5 - 0x1f5 */
	{ 0x1f2,	0x001 },	/* 0x1f2 - 0x1f2 */
	{ 0x358,	0x003 },	/* 0x358 - 0x35a */
	{ 0x1f3,	0x001 },	/* 0x1f3 - 0x1f3 */
	{ 0x1e8,	0x001 },	/* 0x1e8 - 0x1e8 */
	{ 0x3cf,	0x002 },	/* 0x3cf - 0x3d0 */
	{ 0x3c6,	0x001 },	/* 0x3c6 - 0x3c6 */
	{ 0x3c4,	0x002 },	/* 0x3c4 - 0x3c5 */
	{ 0x044,	0x001 },	/* 0x044 - 0x044 */
	{ 0x4d6,	0x001 },	/* 0x4d6 - 0x4d6 */
	{ 0x34a,	0x001 },	/* 0x34a - 0x34a */
	{ 0x33a,	0x004 },	/* 0x33a - 0x33d */
	{ 0x342,	0x004 },	/* 0x342 - 0x345 */
	{ 0x33e,	0x004 },	/* 0x33e - 0x341 */
	{ 0x346,	0x004 },	/* 0x346 - 0x349 */
	{ 0x6f5,	0x001 },	/* 0x6f5 - 0x6f5 */
	{ 0x8f5,	0x001 },	/* 0x8f5 - 0x8f5 */
	{ 0xaf5,	0x001 },	/* 0xaf5 - 0xaf5 */
	{ 0x6f6,	0x001 },	/* 0x6f6 - 0x6f6 */
	{ 0x8f6,	0x001 },	/* 0x8f6 - 0x8f6 */
	{ 0xaf6,	0x001 },	/* 0xaf6 - 0xaf6 */
	{ 0x339,	0x001 },	/* 0x339 - 0x339 */
	{ 0x1ee,	0x001 },	/* 0x1ee - 0x1ee */
	{ 0x1ec,	0x001 },	/* 0x1ec - 0x1ec */
	{ 0x163,	0x001 },	/* 0x163 - 0x163 */
	{ 0x67a,	0x001 },	/* 0x67a - 0x67a */
	{ 0x87a,	0x001 },	/* 0x87a - 0x87a */
	{ 0xa7a,	0x001 },	/* 0xa7a - 0xa7a */
	{ 0x67b,	0x001 },	/* 0x67b - 0x67b */
	{ 0x87b,	0x001 },	/* 0x87b - 0x87b */
	{ 0xa7b,	0x001 },	/* 0xa7b - 0xa7b */
	{ 0x679,	0x001 },	/* 0x679 - 0x679 */
	{ 0x879,	0x001 },	/* 0x879 - 0x879 */
	{ 0xa79,	0x001 },	/* 0xa79 - 0xa79 */
	{ 0x642,	0x001 },	/* 0x642 - 0x642 */
	{ 0x842,	0x001 },	/* 0x842 - 0x842 */
	{ 0xa42,	0x001 },	/* 0xa42 - 0xa42 */
	{ 0x501,	0x001 },	/* 0x501 - 0x501 */
	{ 0x500,	0x001 },	/* 0x500 - 0x500 */
	{ 0x510,	0x001 },	/* 0x510 - 0x510 */
	{ 0x240,	0x002 },	/* 0x240 - 0x241 */
	{ 0x24a,	0x001 },	/* 0x24a - 0x24a */
	{ 0x242,	0x008 },	/* 0x242 - 0x249 */
	{ 0x213,	0x001 },	/* 0x213 - 0x213 */
	{ 0x234,	0x004 },	/* 0x234 - 0x237 */
	{ 0x230,	0x004 },	/* 0x230 - 0x233 */
	{ 0x212,	0x001 },	/* 0x212 - 0x212 */
	{ 0x217,	0x001 },	/* 0x217 - 0x217 */
	{ 0x219,	0x001 },	/* 0x219 - 0x219 */
	{ 0x214,	0x001 },	/* 0x214 - 0x214 */
	{ 0x218,	0x001 },	/* 0x218 - 0x218 */
	{ 0x216,	0x001 },	/* 0x216 - 0x216 */
	{ 0x215,	0x001 },	/* 0x215 - 0x215 */
	{ 0x238,	0x002 },	/* 0x238 - 0x239 */
	{ 0x067,	0x001 },	/* 0x067 - 0x067 */
	{ 0x066,	0x001 },	/* 0x066 - 0x066 */
	{ 0x16b,	0x001 },	/* 0x16b - 0x16b */
	{ 0x3e0,	0x001 },	/* 0x3e0 - 0x3e0 */
	{ 0x16d,	0x001 },	/* 0x16d - 0x16d */
	{ 0x16c,	0x001 },	/* 0x16c - 0x16c */
	{ 0x169,	0x001 },	/* 0x169 - 0x169 */
	{ 0x259,	0x001 },	/* 0x259 - 0x259 */
	{ 0x690,	0x001 },	/* 0x690 - 0x690 */
	{ 0x890,	0x001 },	/* 0x890 - 0x890 */
	{ 0xa90,	0x001 },	/* 0xa90 - 0xa90 */
	{ 0x280,	0x009 },	/* 0x280 - 0x288 */
	{ 0x46b,	0x001 },	/* 0x46b - 0x46b */
	{ 0x2e0,	0x001 },	/* 0x2e0 - 0x2e0 */
	{ 0x2e5,	0x001 },	/* 0x2e5 - 0x2e5 */
	{ 0x2e3,	0x001 },	/* 0x2e3 - 0x2e3 */
	{ 0x2e6,	0x001 },	/* 0x2e6 - 0x2e6 */
	{ 0x2e4,	0x001 },	/* 0x2e4 - 0x2e4 */
	{ 0x2e2,	0x001 },	/* 0x2e2 - 0x2e2 */
	{ 0x2e1,	0x001 },	/* 0x2e1 - 0x2e1 */
	{ 0x793,	0x001 },	/* 0x793 - 0x793 */
	{ 0x993,	0x001 },	/* 0x993 - 0x993 */
	{ 0xb93,	0x001 },	/* 0xb93 - 0xb93 */
	{ 0x792,	0x001 },	/* 0x792 - 0x792 */
	{ 0x992,	0x001 },	/* 0x992 - 0x992 */
	{ 0xb92,	0x001 },	/* 0xb92 - 0xb92 */
	{ 0x3e3,	0x001 },	/* 0x3e3 - 0x3e3 */
	{ 0x473,	0x001 },	/* 0x473 - 0x473 */
	{ 0x472,	0x001 },	/* 0x472 - 0x472 */
	{ 0x395,	0x001 },	/* 0x395 - 0x395 */
	{ 0x013,	0x001 },	/* 0x013 - 0x013 */
	{ 0x393,	0x001 },	/* 0x393 - 0x393 */
	{ 0x012,	0x001 },	/* 0x012 - 0x012 */
	{ 0x392,	0x001 },	/* 0x392 - 0x392 */
	{ 0x394,	0x001 },	/* 0x394 - 0x394 */
	{ 0x39c,	0x001 },	/* 0x39c - 0x39c */
	{ 0x39b,	0x001 },	/* 0x39b - 0x39b */
	{ 0x292,	0x001 },	/* 0x292 - 0x292 */
	{ 0x195,	0x002 },	/* 0x195 - 0x196 */
	{ 0x1f6,	0x002 },	/* 0x1f6 - 0x1f7 */
	{ 0x1b0,	0x001 },	/* 0x1b0 - 0x1b0 */
	{ 0x494,	0x001 },	/* 0x494 - 0x494 */
	{ 0x1e1,	0x001 },	/* 0x1e1 - 0x1e1 */
	{ 0x1e7,	0x001 },	/* 0x1e7 - 0x1e7 */
	{ 0x270,	0x001 },	/* 0x270 - 0x270 */
	{ 0x6c3,	0x001 },	/* 0x6c3 - 0x6c3 */
	{ 0x8c3,	0x001 },	/* 0x8c3 - 0x8c3 */
	{ 0xac3,	0x001 },	/* 0xac3 - 0xac3 */
	{ 0x6c2,	0x001 },	/* 0x6c2 - 0x6c2 */
	{ 0x8c2,	0x001 },	/* 0x8c2 - 0x8c2 */
	{ 0xac2,	0x001 },	/* 0xac2 - 0xac2 */
	{ 0x6c1,	0x001 },	/* 0x6c1 - 0x6c1 */
	{ 0x8c1,	0x001 },	/* 0x8c1 - 0x8c1 */
	{ 0xac1,	0x001 },	/* 0xac1 - 0xac1 */
	{ 0x6c0,	0x001 },	/* 0x6c0 - 0x6c0 */
	{ 0x8c0,	0x001 },	/* 0x8c0 - 0x8c0 */
	{ 0xac0,	0x001 },	/* 0xac0 - 0xac0 */
	{ 0x6c5,	0x001 },	/* 0x6c5 - 0x6c5 */
	{ 0x8c5,	0x001 },	/* 0x8c5 - 0x8c5 */
	{ 0xac5,	0x001 },	/* 0xac5 - 0xac5 */
	{ 0x6c4,	0x001 },	/* 0x6c4 - 0x6c4 */
	{ 0x8c4,	0x001 },	/* 0x8c4 - 0x8c4 */
	{ 0xac4,	0x001 },	/* 0xac4 - 0xac4 */
	{ 0x272,	0x001 },	/* 0x272 - 0x272 */
	{ 0x271,	0x001 },	/* 0x271 - 0x271 */
	{ 0x380,	0x001 },	/* 0x380 - 0x380 */
	{ 0x382,	0x001 },	/* 0x382 - 0x382 */
	{ 0x381,	0x001 },	/* 0x381 - 0x381 */
	{ 0x383,	0x001 },	/* 0x383 - 0x383 */
	{ 0x3b0,	0x001 },	/* 0x3b0 - 0x3b0 */
	{ 0x3af,	0x001 },	/* 0x3af - 0x3af */
	{ 0x3b1,	0x002 },	/* 0x3b1 - 0x3b2 */
	{ 0x3b5,	0x001 },	/* 0x3b5 - 0x3b5 */
	{ 0x3e9,	0x001 },	/* 0x3e9 - 0x3e9 */
	{ 0x46c,	0x002 },	/* 0x46c - 0x46d */
	{ 0x3b9,	0x001 },	/* 0x3b9 - 0x3b9 */
	{ 0x1a0,	0x001 },	/* 0x1a0 - 0x1a0 */
	{ 0x1a2,	0x001 },	/* 0x1a2 - 0x1a2 */
	{ 0x1a1,	0x001 },	/* 0x1a1 - 0x1a1 */
	{ 0x1a3,	0x001 },	/* 0x1a3 - 0x1a3 */
	{ 0x2b3,	0x001 },	/* 0x2b3 - 0x2b3 */
	{ 0x2b1,	0x001 },	/* 0x2b1 - 0x2b1 */
	{ 0x2b0,	0x001 },	/* 0x2b0 - 0x2b0 */
	{ 0x2ba,	0x001 },	/* 0x2ba - 0x2ba */
	{ 0x2b9,	0x001 },	/* 0x2b9 - 0x2b9 */
	{ 0x2b8,	0x001 },	/* 0x2b8 - 0x2b8 */
	{ 0x2b5,	0x001 },	/* 0x2b5 - 0x2b5 */
	{ 0x2b4,	0x001 },	/* 0x2b4 - 0x2b4 */
	{ 0x2b7,	0x001 },	/* 0x2b7 - 0x2b7 */
	{ 0x2b6,	0x001 },	/* 0x2b6 - 0x2b6 */
	{ 0x2b2,	0x001 },	/* 0x2b2 - 0x2b2 */
	{ 0x3e2,	0x001 },	/* 0x3e2 - 0x3e2 */
	{ 0x3ea,	0x002 },	/* 0x3ea - 0x3eb */
	{ 0x3e1,	0x001 },	/* 0x3e1 - 0x3e1 */
	{ 0x3e5,	0x001 },	/* 0x3e5 - 0x3e5 */
	{ 0x1b7,	0x001 },	/* 0x1b7 - 0x1b7 */
	{ 0x3b4,	0x001 },	/* 0x3b4 - 0x3b4 */
	{ 0x3dc,	0x002 },	/* 0x3dc - 0x3dd */
	{ 0x3e7,	0x002 },	/* 0x3e7 - 0x3e8 */
	{ 0x40c,	0x002 },	/* 0x40c - 0x40d */
	{ 0x3bb,	0x001 },	/* 0x3bb - 0x3bb */
	{ 0x3ba,	0x001 },	/* 0x3ba - 0x3ba */
	{ 0x78f,	0x001 },	/* 0x78f - 0x78f */
	{ 0x98f,	0x001 },	/* 0x98f - 0x98f */
	{ 0xb8f,	0x001 },	/* 0xb8f - 0xb8f */
	{ 0x78e,	0x001 },	/* 0x78e - 0x78e */
	{ 0x98e,	0x001 },	/* 0x98e - 0x98e */
	{ 0xb8e,	0x001 },	/* 0xb8e - 0xb8e */
	{ 0x28d,	0x001 },	/* 0x28d - 0x28d */
	{ 0x28f,	0x001 },	/* 0x28f - 0x28f */
	{ 0x291,	0x001 },	/* 0x291 - 0x291 */
	{ 0x28c,	0x001 },	/* 0x28c - 0x28c */
	{ 0x28e,	0x001 },	/* 0x28e - 0x28e */
	{ 0x290,	0x001 },	/* 0x290 - 0x290 */
	{ 0x471,	0x001 },	/* 0x471 - 0x471 */
	{ 0x49d,	0x001 },	/* 0x49d - 0x49d */
	{ 0x4f5,	0x002 },	/* 0x4f5 - 0x4f6 */
	{ 0x49b,	0x001 },	/* 0x49b - 0x49b */
	{ 0x4f4,	0x001 },	/* 0x4f4 - 0x4f4 */
	{ 0x49c,	0x001 },	/* 0x49c - 0x49c */
	{ 0x1ef,	0x001 },	/* 0x1ef - 0x1ef */
	{ 0x1bb,	0x001 },	/* 0x1bb - 0x1bb */
	{ 0x1ba,	0x001 },	/* 0x1ba - 0x1ba */
	{ 0x1b9,	0x001 },	/* 0x1b9 - 0x1b9 */
	{ 0x2d1,	0x001 },	/* 0x2d1 - 0x2d1 */
	{ 0x609,	0x001 },	/* 0x609 - 0x609 */
	{ 0x809,	0x001 },	/* 0x809 - 0x809 */
	{ 0xa09,	0x001 },	/* 0xa09 - 0xa09 */
	{ 0x1a7,	0x001 },	/* 0x1a7 - 0x1a7 */
	{ 0x1a5,	0x002 },	/* 0x1a5 - 0x1a6 */
	{ 0x523,	0x001 },	/* 0x523 - 0x523 */
	{ 0x522,	0x001 },	/* 0x522 - 0x522 */
	{ 0x521,	0x001 },	/* 0x521 - 0x521 */
	{ 0x171,	0x001 },	/* 0x171 - 0x171 */
	{ 0x29a,	0x001 },	/* 0x29a - 0x29a */
	{ 0x041,	0x002 },	/* 0x041 - 0x042 */
	{ 0x1b2,	0x004 },	/* 0x1b2 - 0x1b5 */
	{ 0x531,	0x001 },	/* 0x531 - 0x531 */
	{ 0x530,	0x001 },	/* 0x530 - 0x530 */
	{ 0x533,	0x001 },	/* 0x533 - 0x533 */
	{ 0x532,	0x001 },	/* 0x532 - 0x532 */
	{ 0x537,	0x001 },	/* 0x537 - 0x537 */
	{ 0x536,	0x001 },	/* 0x536 - 0x536 */
	{ 0x535,	0x001 },	/* 0x535 - 0x535 */
	{ 0x534,	0x001 },	/* 0x534 - 0x534 */
	{ 0x539,	0x001 },	/* 0x539 - 0x539 */
	{ 0x538,	0x001 },	/* 0x538 - 0x538 */
	{ 0x53b,	0x001 },	/* 0x53b - 0x53b */
	{ 0x53a,	0x001 },	/* 0x53a - 0x53a */
	{ 0x767,	0x001 },	/* 0x767 - 0x767 */
	{ 0x967,	0x001 },	/* 0x967 - 0x967 */
	{ 0xb67,	0x001 },	/* 0xb67 - 0xb67 */
	{ 0x489,	0x001 },	/* 0x489 - 0x489 */
	{ 0x488,	0x001 },	/* 0x488 - 0x488 */
	{ 0x48a,	0x001 },	/* 0x48a - 0x48a */
	{ 0x768,	0x001 },	/* 0x768 - 0x768 */
	{ 0x968,	0x001 },	/* 0x968 - 0x968 */
	{ 0xb68,	0x001 },	/* 0xb68 - 0xb68 */
	{ 0x499,	0x002 },	/* 0x499 - 0x49a */
	{ 0x4b7,	0x001 },	/* 0x4b7 - 0x4b7 */
	{ 0x48c,	0x002 },	/* 0x48c - 0x48d */
	{ 0x4e2,	0x001 },	/* 0x4e2 - 0x4e2 */
	{ 0x4e0,	0x002 },	/* 0x4e0 - 0x4e1 */
	{ 0x4df,	0x001 },	/* 0x4df - 0x4df */
	{ 0x4e6,	0x001 },	/* 0x4e6 - 0x4e6 */
	{ 0x4e4,	0x002 },	/* 0x4e4 - 0x4e5 */
	{ 0x4e3,	0x001 },	/* 0x4e3 - 0x4e3 */
	{ 0x4dd,	0x001 },	/* 0x4dd - 0x4dd */
	{ 0x4d9,	0x001 },	/* 0x4d9 - 0x4d9 */
	{ 0x4db,	0x001 },	/* 0x4db - 0x4db */
	{ 0x4d7,	0x001 },	/* 0x4d7 - 0x4d7 */
	{ 0x4de,	0x001 },	/* 0x4de - 0x4de */
	{ 0x4da,	0x001 },	/* 0x4da - 0x4da */
	{ 0x4dc,	0x001 },	/* 0x4dc - 0x4dc */
	{ 0x4d8,	0x001 },	/* 0x4d8 - 0x4d8 */
	{ 0x53d,	0x001 },	/* 0x53d - 0x53d */
	{ 0x53c,	0x001 },	/* 0x53c - 0x53c */
	{ 0x53f,	0x001 },	/* 0x53f - 0x53f */
	{ 0x53e,	0x001 },	/* 0x53e - 0x53e */
	{ 0x485,	0x001 },	/* 0x485 - 0x485 */
	{ 0x763,	0x001 },	/* 0x763 - 0x763 */
	{ 0x963,	0x001 },	/* 0x963 - 0x963 */
	{ 0xb63,	0x001 },	/* 0xb63 - 0xb63 */
	{ 0x764,	0x001 },	/* 0x764 - 0x764 */
	{ 0x964,	0x001 },	/* 0x964 - 0x964 */
	{ 0xb64,	0x001 },	/* 0xb64 - 0xb64 */
	{ 0x765,	0x001 },	/* 0x765 - 0x765 */
	{ 0x965,	0x001 },	/* 0x965 - 0x965 */
	{ 0xb65,	0x001 },	/* 0xb65 - 0xb65 */
	{ 0x760,	0x001 },	/* 0x760 - 0x760 */
	{ 0x960,	0x001 },	/* 0x960 - 0x960 */
	{ 0xb60,	0x001 },	/* 0xb60 - 0xb60 */
	{ 0x761,	0x001 },	/* 0x761 - 0x761 */
	{ 0x961,	0x001 },	/* 0x961 - 0x961 */
	{ 0xb61,	0x001 },	/* 0xb61 - 0xb61 */
	{ 0x762,	0x001 },	/* 0x762 - 0x762 */
	{ 0x962,	0x001 },	/* 0x962 - 0x962 */
	{ 0xb62,	0x001 },	/* 0xb62 - 0xb62 */
	{ 0x484,	0x001 },	/* 0x484 - 0x484 */
	{ 0x541,	0x001 },	/* 0x541 - 0x541 */
	{ 0x540,	0x001 },	/* 0x540 - 0x540 */
	{ 0x487,	0x001 },	/* 0x487 - 0x487 */
	{ 0x486,	0x001 },	/* 0x486 - 0x486 */
	{ 0x492,	0x001 },	/* 0x492 - 0x492 */
	{ 0x490,	0x001 },	/* 0x490 - 0x490 */
	{ 0x48f,	0x001 },	/* 0x48f - 0x48f */
	{ 0x4b8,	0x001 },	/* 0x4b8 - 0x4b8 */
	{ 0x48e,	0x001 },	/* 0x48e - 0x48e */
	{ 0x766,	0x001 },	/* 0x766 - 0x766 */
	{ 0x966,	0x001 },	/* 0x966 - 0x966 */
	{ 0xb66,	0x001 },	/* 0xb66 - 0xb66 */
	{ 0x480,	0x004 },	/* 0x480 - 0x483 */
	{ 0x16f,	0x001 },	/* 0x16f - 0x16f */
	{ 0x3de,	0x001 },	/* 0x3de - 0x3de */
	{ 0x3d5,	0x001 },	/* 0x3d5 - 0x3d5 */
	{ 0x297,	0x002 },	/* 0x297 - 0x298 */
	{ 0x493,	0x001 },	/* 0x493 - 0x493 */
	{ 0x120,	0x001 },	/* 0x120 - 0x120 */
	{ 0x129,	0x001 },	/* 0x129 - 0x129 */
	{ 0x125,	0x001 },	/* 0x125 - 0x125 */
	{ 0x123,	0x001 },	/* 0x123 - 0x123 */
	{ 0x670,	0x001 },	/* 0x670 - 0x670 */
	{ 0x870,	0x001 },	/* 0x870 - 0x870 */
	{ 0xa70,	0x001 },	/* 0xa70 - 0xa70 */
	{ 0x671,	0x001 },	/* 0x671 - 0x671 */
	{ 0x871,	0x001 },	/* 0x871 - 0x871 */
	{ 0xa71,	0x001 },	/* 0xa71 - 0xa71 */
	{ 0x672,	0x001 },	/* 0x672 - 0x672 */
	{ 0x872,	0x001 },	/* 0x872 - 0x872 */
	{ 0xa72,	0x001 },	/* 0xa72 - 0xa72 */
	{ 0x673,	0x001 },	/* 0x673 - 0x673 */
	{ 0x873,	0x001 },	/* 0x873 - 0x873 */
	{ 0xa73,	0x001 },	/* 0xa73 - 0xa73 */
	{ 0x122,	0x001 },	/* 0x122 - 0x122 */
	{ 0x67c,	0x001 },	/* 0x67c - 0x67c */
	{ 0x87c,	0x001 },	/* 0x87c - 0x87c */
	{ 0xa7c,	0x001 },	/* 0xa7c - 0xa7c */
	{ 0x124,	0x001 },	/* 0x124 - 0x124 */
	{ 0x674,	0x001 },	/* 0x674 - 0x674 */
	{ 0x874,	0x001 },	/* 0x874 - 0x874 */
	{ 0xa74,	0x001 },	/* 0xa74 - 0xa74 */
	{ 0x675,	0x001 },	/* 0x675 - 0x675 */
	{ 0x875,	0x001 },	/* 0x875 - 0x875 */
	{ 0xa75,	0x001 },	/* 0xa75 - 0xa75 */
	{ 0x121,	0x001 },	/* 0x121 - 0x121 */
	{ 0x676,	0x001 },	/* 0x676 - 0x676 */
	{ 0x876,	0x001 },	/* 0x876 - 0x876 */
	{ 0xa76,	0x001 },	/* 0xa76 - 0xa76 */
	{ 0x677,	0x001 },	/* 0x677 - 0x677 */
	{ 0x877,	0x001 },	/* 0x877 - 0x877 */
	{ 0xa77,	0x001 },	/* 0xa77 - 0xa77 */
	{ 0x678,	0x001 },	/* 0x678 - 0x678 */
	{ 0x878,	0x001 },	/* 0x878 - 0x878 */
	{ 0xa78,	0x001 },	/* 0xa78 - 0xa78 */
	{ 0x126,	0x003 },	/* 0x126 - 0x128 */
	{ 0x080,	0x001 },	/* 0x080 - 0x080 */
	{ 0x660,	0x001 },	/* 0x660 - 0x660 */
	{ 0x860,	0x001 },	/* 0x860 - 0x860 */
	{ 0xa60,	0x001 },	/* 0xa60 - 0xa60 */
	{ 0x662,	0x001 },	/* 0x662 - 0x662 */
	{ 0x862,	0x001 },	/* 0x862 - 0x862 */
	{ 0xa62,	0x001 },	/* 0xa62 - 0xa62 */
	{ 0x661,	0x001 },	/* 0x661 - 0x661 */
	{ 0x861,	0x001 },	/* 0x861 - 0x861 */
	{ 0xa61,	0x001 },	/* 0xa61 - 0xa61 */
	{ 0x085,	0x002 },	/* 0x085 - 0x086 */
	{ 0x08a,	0x002 },	/* 0x08a - 0x08b */
	{ 0x082,	0x003 },	/* 0x082 - 0x084 */
	{ 0x087,	0x003 },	/* 0x087 - 0x089 */
	{ 0x081,	0x001 },	/* 0x081 - 0x081 */
	{ 0x090,	0x002 },	/* 0x090 - 0x091 */
	{ 0x095,	0x002 },	/* 0x095 - 0x096 */
	{ 0x08d,	0x003 },	/* 0x08d - 0x08f */
	{ 0x092,	0x003 },	/* 0x092 - 0x094 */
	{ 0x08c,	0x001 },	/* 0x08c - 0x08c */
	{ 0x09b,	0x002 },	/* 0x09b - 0x09c */
	{ 0x0a0,	0x002 },	/* 0x0a0 - 0x0a1 */
	{ 0x098,	0x003 },	/* 0x098 - 0x09a */
	{ 0x09d,	0x003 },	/* 0x09d - 0x09f */
	{ 0x097,	0x001 },	/* 0x097 - 0x097 */
	{ 0x0a3,	0x003 },	/* 0x0a3 - 0x0a5 */
	{ 0x0a7,	0x002 },	/* 0x0a7 - 0x0a8 */
	{ 0x0a6,	0x001 },	/* 0x0a6 - 0x0a6 */
	{ 0x0a2,	0x001 },	/* 0x0a2 - 0x0a2 */
	{ 0x3ac,	0x001 },	/* 0x3ac - 0x3ac */
	{ 0x3aa,	0x001 },	/* 0x3aa - 0x3aa */
	{ 0x1b1,	0x001 },	/* 0x1b1 - 0x1b1 */
	{ 0x469,	0x001 },	/* 0x469 - 0x469 */
	{ 0x1ed,	0x001 },	/* 0x1ed - 0x1ed */
	{ 0x3e4,	0x001 },	/* 0x3e4 - 0x3e4 */
	{ 0x3c2,	0x001 },	/* 0x3c2 - 0x3c2 */
	{ 0x3c1,	0x001 },	/* 0x3c1 - 0x3c1 */
	{ 0x370,	0x001 },	/* 0x370 - 0x370 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x46e,	0x001 },	/* 0x46e - 0x46e */
	{ 0x1c7,	0x001 },	/* 0x1c7 - 0x1c7 */
	{ 0x153,	0x001 },	/* 0x153 - 0x153 */
	{ 0x1c9,	0x001 },	/* 0x1c9 - 0x1c9 */
	{ 0x155,	0x001 },	/* 0x155 - 0x155 */
	{ 0x152,	0x001 },	/* 0x152 - 0x152 */
	{ 0x692,	0x001 },	/* 0x692 - 0x692 */
	{ 0x892,	0x001 },	/* 0x892 - 0x892 */
	{ 0xa92,	0x001 },	/* 0xa92 - 0xa92 */
	{ 0x1c4,	0x003 },	/* 0x1c4 - 0x1c6 */
	{ 0x154,	0x001 },	/* 0x154 - 0x154 */
	{ 0x1c8,	0x001 },	/* 0x1c8 - 0x1c8 */
	{ 0x156,	0x001 },	/* 0x156 - 0x156 */
	{ 0x405,	0x001 },	/* 0x405 - 0x405 */
	{ 0x168,	0x001 },	/* 0x168 - 0x168 */
	{ 0x1e6,	0x001 },	/* 0x1e6 - 0x1e6 */
	{ 0x1f0,	0x002 },	/* 0x1f0 - 0x1f1 */
	{ 0x1e0,	0x001 },	/* 0x1e0 - 0x1e0 */
	{ 0x799,	0x001 },	/* 0x799 - 0x799 */
	{ 0x999,	0x001 },	/* 0x999 - 0x999 */
	{ 0xb99,	0x001 },	/* 0xb99 - 0xb99 */
	{ 0x798,	0x001 },	/* 0x798 - 0x798 */
	{ 0x998,	0x001 },	/* 0x998 - 0x998 */
	{ 0xb98,	0x001 },	/* 0xb98 - 0xb98 */
	{ 0x3ed,	0x001 },	/* 0x3ed - 0x3ed */
	{ 0x415,	0x001 },	/* 0x415 - 0x415 */
	{ 0x3ee,	0x001 },	/* 0x3ee - 0x3ee */
	{ 0x3da,	0x002 },	/* 0x3da - 0x3db */
	{ 0x3ce,	0x001 },	/* 0x3ce - 0x3ce */
	{ 0x3cd,	0x001 },	/* 0x3cd - 0x3cd */
	{ 0x78d,	0x001 },	/* 0x78d - 0x78d */
	{ 0x98d,	0x001 },	/* 0x98d - 0x98d */
	{ 0xb8d,	0x001 },	/* 0xb8d - 0xb8d */
	{ 0x78c,	0x001 },	/* 0x78c - 0x78c */
	{ 0x98c,	0x001 },	/* 0x98c - 0x98c */
	{ 0xb8c,	0x001 },	/* 0xb8c - 0xb8c */
	{ 0x789,	0x001 },	/* 0x789 - 0x789 */
	{ 0x989,	0x001 },	/* 0x989 - 0x989 */
	{ 0xb89,	0x001 },	/* 0xb89 - 0xb89 */
	{ 0x788,	0x001 },	/* 0x788 - 0x788 */
	{ 0x988,	0x001 },	/* 0x988 - 0x988 */
	{ 0xb88,	0x001 },	/* 0xb88 - 0xb88 */
	{ 0x78b,	0x001 },	/* 0x78b - 0x78b */
	{ 0x98b,	0x001 },	/* 0x98b - 0x98b */
	{ 0xb8b,	0x001 },	/* 0xb8b - 0xb8b */
	{ 0x78a,	0x001 },	/* 0x78a - 0x78a */
	{ 0x98a,	0x001 },	/* 0x98a - 0x98a */
	{ 0xb8a,	0x001 },	/* 0xb8a - 0xb8a */
	{ 0x3df,	0x001 },	/* 0x3df - 0x3df */
	{ 0x25e,	0x001 },	/* 0x25e - 0x25e */
	{ 0x25d,	0x001 },	/* 0x25d - 0x25d */
	{ 0x250,	0x001 },	/* 0x250 - 0x250 */
	{ 0x25f,	0x002 },	/* 0x25f - 0x260 */
	{ 0x264,	0x002 },	/* 0x264 - 0x265 */
	{ 0x25b,	0x001 },	/* 0x25b - 0x25b */
	{ 0x263,	0x001 },	/* 0x263 - 0x263 */
	{ 0x25c,	0x001 },	/* 0x25c - 0x25c */
	{ 0x261,	0x002 },	/* 0x261 - 0x262 */
	{ 0x255,	0x001 },	/* 0x255 - 0x255 */
	{ 0x257,	0x001 },	/* 0x257 - 0x257 */
	{ 0x256,	0x001 },	/* 0x256 - 0x256 */
	{ 0x258,	0x001 },	/* 0x258 - 0x258 */
	{ 0x413,	0x001 },	/* 0x413 - 0x413 */
	{ 0x40b,	0x001 },	/* 0x40b - 0x40b */
	{ 0x409,	0x001 },	/* 0x409 - 0x409 */
	{ 0x408,	0x001 },	/* 0x408 - 0x408 */
	{ 0x741,	0x004 },	/* 0x741 - 0x744 */
	{ 0x73f,	0x002 },	/* 0x73f - 0x740 */
	{ 0x941,	0x004 },	/* 0x941 - 0x944 */
	{ 0x93f,	0x002 },	/* 0x93f - 0x940 */
	{ 0xb41,	0x004 },	/* 0xb41 - 0xb44 */
	{ 0xb3f,	0x002 },	/* 0xb3f - 0xb40 */
	{ 0x739,	0x001 },	/* 0x739 - 0x739 */
	{ 0x939,	0x001 },	/* 0x939 - 0x939 */
	{ 0xb39,	0x001 },	/* 0xb39 - 0xb39 */
	{ 0x73a,	0x001 },	/* 0x73a - 0x73a */
	{ 0x93a,	0x001 },	/* 0x93a - 0x93a */
	{ 0xb3a,	0x001 },	/* 0xb3a - 0xb3a */
	{ 0x73c,	0x001 },	/* 0x73c - 0x73c */
	{ 0x93c,	0x001 },	/* 0x93c - 0x93c */
	{ 0xb3c,	0x001 },	/* 0xb3c - 0xb3c */
	{ 0x73d,	0x001 },	/* 0x73d - 0x73d */
	{ 0x93d,	0x001 },	/* 0x93d - 0x93d */
	{ 0xb3d,	0x001 },	/* 0xb3d - 0xb3d */
	{ 0x417,	0x001 },	/* 0x417 - 0x417 */
	{ 0x745,	0x001 },	/* 0x745 - 0x745 */
	{ 0x945,	0x001 },	/* 0x945 - 0x945 */
	{ 0xb45,	0x001 },	/* 0xb45 - 0xb45 */
	{ 0x73b,	0x001 },	/* 0x73b - 0x73b */
	{ 0x93b,	0x001 },	/* 0x93b - 0x93b */
	{ 0xb3b,	0x001 },	/* 0xb3b - 0xb3b */
	{ 0x735,	0x001 },	/* 0x735 - 0x735 */
	{ 0x935,	0x001 },	/* 0x935 - 0x935 */
	{ 0xb35,	0x001 },	/* 0xb35 - 0xb35 */
	{ 0x734,	0x001 },	/* 0x734 - 0x734 */
	{ 0x934,	0x001 },	/* 0x934 - 0x934 */
	{ 0xb34,	0x001 },	/* 0xb34 - 0xb34 */
	{ 0x737,	0x001 },	/* 0x737 - 0x737 */
	{ 0x937,	0x001 },	/* 0x937 - 0x937 */
	{ 0xb37,	0x001 },	/* 0xb37 - 0xb37 */
	{ 0x736,	0x001 },	/* 0x736 - 0x736 */
	{ 0x936,	0x001 },	/* 0x936 - 0x936 */
	{ 0xb36,	0x001 },	/* 0xb36 - 0xb36 */
	{ 0x746,	0x001 },	/* 0x746 - 0x746 */
	{ 0x946,	0x001 },	/* 0x946 - 0x946 */
	{ 0xb46,	0x001 },	/* 0xb46 - 0xb46 */
	{ 0x738,	0x001 },	/* 0x738 - 0x738 */
	{ 0x938,	0x001 },	/* 0x938 - 0x938 */
	{ 0xb38,	0x001 },	/* 0xb38 - 0xb38 */
	{ 0x730,	0x001 },	/* 0x730 - 0x730 */
	{ 0x930,	0x001 },	/* 0x930 - 0x930 */
	{ 0xb30,	0x001 },	/* 0xb30 - 0xb30 */
	{ 0x731,	0x001 },	/* 0x731 - 0x731 */
	{ 0x931,	0x001 },	/* 0x931 - 0x931 */
	{ 0xb31,	0x001 },	/* 0xb31 - 0xb31 */
	{ 0x729,	0x001 },	/* 0x729 - 0x729 */
	{ 0x929,	0x001 },	/* 0x929 - 0x929 */
	{ 0xb29,	0x001 },	/* 0xb29 - 0xb29 */
	{ 0x732,	0x001 },	/* 0x732 - 0x732 */
	{ 0x932,	0x001 },	/* 0x932 - 0x932 */
	{ 0xb32,	0x001 },	/* 0xb32 - 0xb32 */
	{ 0x733,	0x001 },	/* 0x733 - 0x733 */
	{ 0x933,	0x001 },	/* 0x933 - 0x933 */
	{ 0xb33,	0x001 },	/* 0xb33 - 0xb33 */
	{ 0x728,	0x001 },	/* 0x728 - 0x728 */
	{ 0x928,	0x001 },	/* 0x928 - 0x928 */
	{ 0xb28,	0x001 },	/* 0xb28 - 0xb28 */
	{ 0x73e,	0x001 },	/* 0x73e - 0x73e */
	{ 0x93e,	0x001 },	/* 0x93e - 0x93e */
	{ 0xb3e,	0x001 },	/* 0xb3e - 0xb3e */
	{ 0x725,	0x001 },	/* 0x725 - 0x725 */
	{ 0x925,	0x001 },	/* 0x925 - 0x925 */
	{ 0xb25,	0x001 },	/* 0xb25 - 0xb25 */
	{ 0x727,	0x001 },	/* 0x727 - 0x727 */
	{ 0x927,	0x001 },	/* 0x927 - 0x927 */
	{ 0xb27,	0x001 },	/* 0xb27 - 0xb27 */
	{ 0x722,	0x001 },	/* 0x722 - 0x722 */
	{ 0x922,	0x001 },	/* 0x922 - 0x922 */
	{ 0xb22,	0x001 },	/* 0xb22 - 0xb22 */
	{ 0x416,	0x001 },	/* 0x416 - 0x416 */
	{ 0x726,	0x001 },	/* 0x726 - 0x726 */
	{ 0x926,	0x001 },	/* 0x926 - 0x926 */
	{ 0xb26,	0x001 },	/* 0xb26 - 0xb26 */
	{ 0x723,	0x001 },	/* 0x723 - 0x723 */
	{ 0x923,	0x001 },	/* 0x923 - 0x923 */
	{ 0xb23,	0x001 },	/* 0xb23 - 0xb23 */
	{ 0x724,	0x001 },	/* 0x724 - 0x724 */
	{ 0x924,	0x001 },	/* 0x924 - 0x924 */
	{ 0xb24,	0x001 },	/* 0xb24 - 0xb24 */
	{ 0x721,	0x001 },	/* 0x721 - 0x721 */
	{ 0x921,	0x001 },	/* 0x921 - 0x921 */
	{ 0xb21,	0x001 },	/* 0xb21 - 0xb21 */
	{ 0x720,	0x001 },	/* 0x720 - 0x720 */
	{ 0x920,	0x001 },	/* 0x920 - 0x920 */
	{ 0xb20,	0x001 },	/* 0xb20 - 0xb20 */
	{ 0x40e,	0x001 },	/* 0x40e - 0x40e */
	{ 0x401,	0x001 },	/* 0x401 - 0x401 */
	{ 0x400,	0x001 },	/* 0x400 - 0x400 */
	{ 0x403,	0x002 },	/* 0x403 - 0x404 */
	{ 0x412,	0x001 },	/* 0x412 - 0x412 */
	{ 0x497,	0x002 },	/* 0x497 - 0x498 */
	{ 0x402,	0x001 },	/* 0x402 - 0x402 */
	{ 0x411,	0x001 },	/* 0x411 - 0x411 */
	{ 0x3ab,	0x001 },	/* 0x3ab - 0x3ab */
	{ 0x1f4,	0x001 },	/* 0x1f4 - 0x1f4 */
	{ 0x520,	0x001 },	/* 0x520 - 0x520 */
	{ 0x3ae,	0x001 },	/* 0x3ae - 0x3ae */
	{ 0x1cd,	0x001 },	/* 0x1cd - 0x1cd */
	{ 0x164,	0x001 },	/* 0x164 - 0x164 */
	{ 0x3ca,	0x002 },	/* 0x3ca - 0x3cb */
	{ 0x199,	0x001 },	/* 0x199 - 0x199 */
	{ 0x19b,	0x001 },	/* 0x19b - 0x19b */
	{ 0x19a,	0x001 },	/* 0x19a - 0x19a */
	{ 0x19c,	0x001 },	/* 0x19c - 0x19c */
	{ 0x6a4,	0x002 },	/* 0x6a4 - 0x6a5 */
	{ 0x6ae,	0x001 },	/* 0x6ae - 0x6ae */
	{ 0x6a6,	0x008 },	/* 0x6a6 - 0x6ad */
	{ 0x8a4,	0x002 },	/* 0x8a4 - 0x8a5 */
	{ 0x8ae,	0x001 },	/* 0x8ae - 0x8ae */
	{ 0x8a6,	0x008 },	/* 0x8a6 - 0x8ad */
	{ 0xaa4,	0x002 },	/* 0xaa4 - 0xaa5 */
	{ 0xaae,	0x001 },	/* 0xaae - 0xaae */
	{ 0xaa6,	0x008 },	/* 0xaa6 - 0xaad */
	{ 0x211,	0x001 },	/* 0x211 - 0x211 */
	{ 0x210,	0x001 },	/* 0x210 - 0x210 */
	{ 0x695,	0x001 },	/* 0x695 - 0x695 */
	{ 0x895,	0x001 },	/* 0x895 - 0x895 */
	{ 0xa95,	0x001 },	/* 0xa95 - 0xa95 */
	{ 0x696,	0x001 },	/* 0x696 - 0x696 */
	{ 0x896,	0x001 },	/* 0x896 - 0x896 */
	{ 0xa96,	0x001 },	/* 0xa96 - 0xa96 */
	{ 0x693,	0x001 },	/* 0x693 - 0x693 */
	{ 0x893,	0x001 },	/* 0x893 - 0x893 */
	{ 0xa93,	0x001 },	/* 0xa93 - 0xa93 */
	{ 0x694,	0x001 },	/* 0x694 - 0x694 */
	{ 0x894,	0x001 },	/* 0x894 - 0x894 */
	{ 0xa94,	0x001 },	/* 0xa94 - 0xa94 */
	{ 0x19e,	0x001 },	/* 0x19e - 0x19e */
	{ 0x19d,	0x001 },	/* 0x19d - 0x19d */
	{ 0x19f,	0x001 },	/* 0x19f - 0x19f */
	{ 0x184,	0x002 },	/* 0x184 - 0x185 */
	{ 0x189,	0x002 },	/* 0x189 - 0x18a */
	{ 0x181,	0x003 },	/* 0x181 - 0x183 */
	{ 0x186,	0x003 },	/* 0x186 - 0x188 */
	{ 0x3ad,	0x001 },	/* 0x3ad - 0x3ad */
	{ 0x783,	0x001 },	/* 0x783 - 0x783 */
	{ 0x983,	0x001 },	/* 0x983 - 0x983 */
	{ 0xb83,	0x001 },	/* 0xb83 - 0xb83 */
	{ 0x782,	0x001 },	/* 0x782 - 0x782 */
	{ 0x982,	0x001 },	/* 0x982 - 0x982 */
	{ 0xb82,	0x001 },	/* 0xb82 - 0xb82 */
	{ 0x785,	0x001 },	/* 0x785 - 0x785 */
	{ 0x985,	0x001 },	/* 0x985 - 0x985 */
	{ 0xb85,	0x001 },	/* 0xb85 - 0xb85 */
	{ 0x784,	0x001 },	/* 0x784 - 0x784 */
	{ 0x984,	0x001 },	/* 0x984 - 0x984 */
	{ 0xb84,	0x001 },	/* 0xb84 - 0xb84 */
	{ 0x787,	0x001 },	/* 0x787 - 0x787 */
	{ 0x987,	0x001 },	/* 0x987 - 0x987 */
	{ 0xb87,	0x001 },	/* 0xb87 - 0xb87 */
	{ 0x786,	0x001 },	/* 0x786 - 0x786 */
	{ 0x986,	0x001 },	/* 0x986 - 0x986 */
	{ 0xb86,	0x001 },	/* 0xb86 - 0xb86 */
	{ 0x796,	0x001 },	/* 0x796 - 0x796 */
	{ 0x996,	0x001 },	/* 0x996 - 0x996 */
	{ 0xb96,	0x001 },	/* 0xb96 - 0xb96 */
	{ 0x797,	0x001 },	/* 0x797 - 0x797 */
	{ 0x997,	0x001 },	/* 0x997 - 0x997 */
	{ 0xb97,	0x001 },	/* 0xb97 - 0xb97 */
	{ 0x141,	0x001 },	/* 0x141 - 0x141 */
	{ 0x6f7,	0x001 },	/* 0x6f7 - 0x6f7 */
	{ 0x8f7,	0x001 },	/* 0x8f7 - 0x8f7 */
	{ 0xaf7,	0x001 },	/* 0xaf7 - 0xaf7 */
	{ 0x143,	0x006 },	/* 0x143 - 0x148 */
	{ 0x142,	0x001 },	/* 0x142 - 0x142 */
	{ 0x149,	0x009 },	/* 0x149 - 0x151 */
	{ 0x18e,	0x002 },	/* 0x18e - 0x18f */
	{ 0x193,	0x002 },	/* 0x193 - 0x194 */
	{ 0x18b,	0x003 },	/* 0x18b - 0x18d */
	{ 0x190,	0x003 },	/* 0x190 - 0x192 */
	{ 0x468,	0x001 },	/* 0x468 - 0x468 */
	{ 0x460,	0x001 },	/* 0x460 - 0x460 */
	{ 0x463,	0x001 },	/* 0x463 - 0x463 */
	{ 0x462,	0x001 },	/* 0x462 - 0x462 */
	{ 0x461,	0x001 },	/* 0x461 - 0x461 */
	{ 0x465,	0x001 },	/* 0x465 - 0x465 */
	{ 0x464,	0x001 },	/* 0x464 - 0x464 */
	{ 0x466,	0x001 },	/* 0x466 - 0x466 */
	{ 0x49e,	0x003 },	/* 0x49e - 0x4a0 */
	{ 0x4a5,	0x00a },	/* 0x4a5 - 0x4ae */
	{ 0x4a1,	0x001 },	/* 0x4a1 - 0x4a1 */
	{ 0x4af,	0x008 },	/* 0x4af - 0x4b6 */
	{ 0x4a2,	0x003 },	/* 0x4a2 - 0x4a4 */
	{ 0x4f2,	0x002 },	/* 0x4f2 - 0x4f3 */
	{ 0x495,	0x001 },	/* 0x495 - 0x495 */
	{ 0x491,	0x001 },	/* 0x491 - 0x491 */
	{ 0x4f7,	0x001 },	/* 0x4f7 - 0x4f7 */
	{ 0x040,	0x001 },	/* 0x040 - 0x040 */
	{ 0x1c2,	0x002 },	/* 0x1c2 - 0x1c3 */
	{ 0x1bf,	0x003 },	/* 0x1bf - 0x1c1 */
	{ 0x1bc,	0x003 },	/* 0x1bc - 0x1be */
	{ 0x175,	0x001 },	/* 0x175 - 0x175 */
	{ 0x1a4,	0x001 },	/* 0x1a4 - 0x1a4 */
	{ 0x3c9,	0x001 },	/* 0x3c9 - 0x3c9 */
	{ 0x3c7,	0x002 },	/* 0x3c7 - 0x3c8 */
	{ 0x414,	0x001 },	/* 0x414 - 0x414 */
	{ 0x043,	0x001 },	/* 0x043 - 0x043 */
	{ 0x030,	0x001 },	/* 0x030 - 0x030 */
	{ 0x29c,	0x001 },	/* 0x29c - 0x29c */
	{ 0x1e9,	0x001 },	/* 0x1e9 - 0x1e9 */
	{ 0x16a,	0x001 },	/* 0x16a - 0x16a */
	{ 0x1b8,	0x001 },	/* 0x1b8 - 0x1b8 */
	{ 0x470,	0x001 },	/* 0x470 - 0x470 */
	{ 0x46f,	0x001 },	/* 0x46f - 0x46f */
	{ 0x52b,	0x001 },	/* 0x52b - 0x52b */
	{ 0x315,	0x001 },	/* 0x315 - 0x315 */
	{ 0x317,	0x001 },	/* 0x317 - 0x317 */
	{ 0x314,	0x001 },	/* 0x314 - 0x314 */
	{ 0x316,	0x001 },	/* 0x316 - 0x316 */
	{ 0x319,	0x001 },	/* 0x319 - 0x319 */
	{ 0x31b,	0x001 },	/* 0x31b - 0x31b */
	{ 0x318,	0x001 },	/* 0x318 - 0x318 */
	{ 0x31a,	0x001 },	/* 0x31a - 0x31a */
	{ 0x30e,	0x001 },	/* 0x30e - 0x30e */
	{ 0x2ff,	0x001 },	/* 0x2ff - 0x2ff */
	{ 0x301,	0x001 },	/* 0x301 - 0x301 */
	{ 0x2fe,	0x001 },	/* 0x2fe - 0x2fe */
	{ 0x300,	0x001 },	/* 0x300 - 0x300 */
	{ 0x3c3,	0x001 },	/* 0x3c3 - 0x3c3 */
	{ 0x3c0,	0x001 },	/* 0x3c0 - 0x3c0 */
	{ 0x3bf,	0x001 },	/* 0x3bf - 0x3bf */
	{ 0x3be,	0x001 },	/* 0x3be - 0x3be */
	{ 0x014,	0x001 },	/* 0x014 - 0x014 */
	{ 0x010,	0x001 },	/* 0x010 - 0x010 */
	{ 0x00f,	0x001 },	/* 0x00f - 0x00f */
	{ 0x011,	0x001 },	/* 0x011 - 0x011 */
	{ 0x00e,	0x001 },	/* 0x00e - 0x00e */
	{ 0x16e,	0x001 },	/* 0x16e - 0x16e */
	{ 0x172,	0x001 },	/* 0x172 - 0x172 */
	{ 0x1eb,	0x001 },	/* 0x1eb - 0x1eb */
	{ 0x3d3,	0x001 },	/* 0x3d3 - 0x3d3 */
	{ 0x3b8,	0x001 },	/* 0x3b8 - 0x3b8 */
	{ 0x289,	0x001 },	/* 0x289 - 0x289 */
	{ 0x3b7,	0x001 },	/* 0x3b7 - 0x3b7 */
	{ 0x3b6,	0x001 },	/* 0x3b6 - 0x3b6 */
	{ 0x076,	0x001 },	/* 0x076 - 0x076 */
	{ 0x072,	0x001 },	/* 0x072 - 0x072 */
	{ 0x648,	0x001 },	/* 0x648 - 0x648 */
	{ 0x848,	0x001 },	/* 0x848 - 0x848 */
	{ 0xa48,	0x001 },	/* 0xa48 - 0xa48 */
	{ 0x060,	0x001 },	/* 0x060 - 0x060 */
	{ 0x063,	0x002 },	/* 0x063 - 0x064 */
	{ 0x061,	0x002 },	/* 0x061 - 0x062 */
	{ 0x43c,	0x003 },	/* 0x43c - 0x43e */
	{ 0x439,	0x003 },	/* 0x439 - 0x43b */
	{ 0x3ec,	0x001 },	/* 0x3ec - 0x3ec */
	{ 0x623,	0x001 },	/* 0x623 - 0x623 */
	{ 0x823,	0x001 },	/* 0x823 - 0x823 */
	{ 0xa23,	0x001 },	/* 0xa23 - 0xa23 */
	{ 0x624,	0x001 },	/* 0x624 - 0x624 */
	{ 0x824,	0x001 },	/* 0x824 - 0x824 */
	{ 0xa24,	0x001 },	/* 0xa24 - 0xa24 */
	{ 0x621,	0x001 },	/* 0x621 - 0x621 */
	{ 0x821,	0x001 },	/* 0x821 - 0x821 */
	{ 0xa21,	0x001 },	/* 0xa21 - 0xa21 */
	{ 0x620,	0x001 },	/* 0x620 - 0x620 */
	{ 0x820,	0x001 },	/* 0x820 - 0x820 */
	{ 0xa20,	0x001 },	/* 0xa20 - 0xa20 */
	{ 0x622,	0x001 },	/* 0x622 - 0x622 */
	{ 0x822,	0x001 },	/* 0x822 - 0x822 */
	{ 0xa22,	0x001 },	/* 0xa22 - 0xa22 */
	{ 0x3bc,	0x002 },	/* 0x3bc - 0x3bd */
	{ 0x007,	0x001 },	/* 0x007 - 0x007 */
	{ 0x02b,	0x001 },	/* 0x02b - 0x02b */
	{ 0x625,	0x007 },	/* 0x625 - 0x62b */
	{ 0x825,	0x007 },	/* 0x825 - 0x82b */
	{ 0xa25,	0x007 },	/* 0xa25 - 0xa2b */
	{ 0x065,	0x001 },	/* 0x065 - 0x065 */
	{ 0x605,	0x001 },	/* 0x605 - 0x605 */
	{ 0x805,	0x001 },	/* 0x805 - 0x805 */
	{ 0xa05,	0x001 },	/* 0xa05 - 0xa05 */
	{ 0x60b,	0x001 },	/* 0x60b - 0x60b */
	{ 0x80b,	0x001 },	/* 0x80b - 0x80b */
	{ 0xa0b,	0x001 },	/* 0xa0b - 0xa0b */
	{ 0x60e,	0x001 },	/* 0x60e - 0x60e */
	{ 0x80e,	0x001 },	/* 0x80e - 0x80e */
	{ 0xa0e,	0x001 },	/* 0xa0e - 0xa0e */
	{ 0x60c,	0x001 },	/* 0x60c - 0x60c */
	{ 0x80c,	0x001 },	/* 0x80c - 0x80c */
	{ 0xa0c,	0x001 },	/* 0xa0c - 0xa0c */
	{ 0x604,	0x001 },	/* 0x604 - 0x604 */
	{ 0x804,	0x001 },	/* 0x804 - 0x804 */
	{ 0xa04,	0x001 },	/* 0xa04 - 0xa04 */
	{ 0x60a,	0x001 },	/* 0x60a - 0x60a */
	{ 0x80a,	0x001 },	/* 0x80a - 0x80a */
	{ 0xa0a,	0x001 },	/* 0xa0a - 0xa0a */
	{ 0x60d,	0x001 },	/* 0x60d - 0x60d */
	{ 0x80d,	0x001 },	/* 0x80d - 0x80d */
	{ 0xa0d,	0x001 },	/* 0xa0d - 0xa0d */
	{ 0x60f,	0x001 },	/* 0x60f - 0x60f */
	{ 0x80f,	0x001 },	/* 0x80f - 0x80f */
	{ 0xa0f,	0x001 },	/* 0xa0f - 0xa0f */
	{ 0x0b9,	0x001 },	/* 0x0b9 - 0x0b9 */
	{ 0x0b0,	0x009 },	/* 0x0b0 - 0x0b8 */
	{ 0x0d7,	0x001 },	/* 0x0d7 - 0x0d7 */
	{ 0x0ce,	0x009 },	/* 0x0ce - 0x0d6 */
	{ 0x0e1,	0x001 },	/* 0x0e1 - 0x0e1 */
	{ 0x0d8,	0x009 },	/* 0x0d8 - 0x0e0 */
	{ 0x0c3,	0x001 },	/* 0x0c3 - 0x0c3 */
	{ 0x0ba,	0x009 },	/* 0x0ba - 0x0c2 */
	{ 0x0eb,	0x001 },	/* 0x0eb - 0x0eb */
	{ 0x0e2,	0x009 },	/* 0x0e2 - 0x0ea */
	{ 0x0cd,	0x001 },	/* 0x0cd - 0x0cd */
	{ 0x0c4,	0x009 },	/* 0x0c4 - 0x0cc */
	{ 0x10a,	0x001 },	/* 0x10a - 0x10a */
	{ 0x0f5,	0x001 },	/* 0x0f5 - 0x0f5 */
	{ 0x0ec,	0x009 },	/* 0x0ec - 0x0f4 */
	{ 0x0ff,	0x001 },	/* 0x0ff - 0x0ff */
	{ 0x0f6,	0x009 },	/* 0x0f6 - 0x0fe */
	{ 0x109,	0x001 },	/* 0x109 - 0x109 */
	{ 0x100,	0x009 },	/* 0x100 - 0x108 */
	{ 0x3ef,	0x001 },	/* 0x3ef - 0x3ef */
	{ 0x028,	0x001 },	/* 0x028 - 0x028 */
	{ 0x781,	0x001 },	/* 0x781 - 0x781 */
	{ 0x981,	0x001 },	/* 0x981 - 0x981 */
	{ 0xb81,	0x001 },	/* 0xb81 - 0xb81 */
	{ 0x780,	0x001 },	/* 0x780 - 0x780 */
	{ 0x980,	0x001 },	/* 0x980 - 0x980 */
	{ 0xb80,	0x001 },	/* 0xb80 - 0xb80 */
	{ 0x027,	0x001 },	/* 0x027 - 0x027 */
	{ 0x020,	0x001 },	/* 0x020 - 0x020 */
	{ 0x02a,	0x001 },	/* 0x02a - 0x02a */
	{ 0x029,	0x001 },	/* 0x029 - 0x029 */
	{ 0x643,	0x001 },	/* 0x643 - 0x643 */
	{ 0x843,	0x001 },	/* 0x843 - 0x843 */
	{ 0xa43,	0x001 },	/* 0xa43 - 0xa43 */
	{ 0x647,	0x001 },	/* 0x647 - 0x647 */
	{ 0x847,	0x001 },	/* 0x847 - 0x847 */
	{ 0xa47,	0x001 },	/* 0xa47 - 0xa47 */
	{ 0x073,	0x001 },	/* 0x073 - 0x073 */
	{ 0x070,	0x001 },	/* 0x070 - 0x070 */
	{ 0x641,	0x001 },	/* 0x641 - 0x641 */
	{ 0x841,	0x001 },	/* 0x841 - 0x841 */
	{ 0xa41,	0x001 },	/* 0xa41 - 0xa41 */
	{ 0x074,	0x001 },	/* 0x074 - 0x074 */
	{ 0x64a,	0x001 },	/* 0x64a - 0x64a */
	{ 0x84a,	0x001 },	/* 0x84a - 0x84a */
	{ 0xa4a,	0x001 },	/* 0xa4a - 0xa4a */
	{ 0x645,	0x001 },	/* 0x645 - 0x645 */
	{ 0x845,	0x001 },	/* 0x845 - 0x845 */
	{ 0xa45,	0x001 },	/* 0xa45 - 0xa45 */
	{ 0x644,	0x001 },	/* 0x644 - 0x644 */
	{ 0x844,	0x001 },	/* 0x844 - 0x844 */
	{ 0xa44,	0x001 },	/* 0xa44 - 0xa44 */
	{ 0x071,	0x001 },	/* 0x071 - 0x071 */
	{ 0x649,	0x001 },	/* 0x649 - 0x649 */
	{ 0x849,	0x001 },	/* 0x849 - 0x849 */
	{ 0xa49,	0x001 },	/* 0xa49 - 0xa49 */
	{ 0x075,	0x001 },	/* 0x075 - 0x075 */
	{ 0x640,	0x001 },	/* 0x640 - 0x640 */
	{ 0x840,	0x001 },	/* 0x840 - 0x840 */
	{ 0xa40,	0x001 },	/* 0xa40 - 0xa40 */
	{ 0x646,	0x001 },	/* 0x646 - 0x646 */
	{ 0x846,	0x001 },	/* 0x846 - 0x846 */
	{ 0xa46,	0x001 },	/* 0xa46 - 0xa46 */
	{ 0x026,	0x001 },	/* 0x026 - 0x026 */
	{ 0x601,	0x001 },	/* 0x601 - 0x601 */
	{ 0x801,	0x001 },	/* 0x801 - 0x801 */
	{ 0xa01,	0x001 },	/* 0xa01 - 0xa01 */
	{ 0x603,	0x001 },	/* 0x603 - 0x603 */
	{ 0x602,	0x001 },	/* 0x602 - 0x602 */
	{ 0x803,	0x001 },	/* 0x803 - 0x803 */
	{ 0x802,	0x001 },	/* 0x802 - 0x802 */
	{ 0xa03,	0x001 },	/* 0xa03 - 0xa03 */
	{ 0xa02,	0x001 },	/* 0xa02 - 0xa02 */
	{ 0x607,	0x001 },	/* 0x607 - 0x607 */
	{ 0x606,	0x001 },	/* 0x606 - 0x606 */
	{ 0x807,	0x001 },	/* 0x807 - 0x807 */
	{ 0x806,	0x001 },	/* 0x806 - 0x806 */
	{ 0xa07,	0x001 },	/* 0xa07 - 0xa07 */
	{ 0xa06,	0x001 },	/* 0xa06 - 0xa06 */
	{ 0x608,	0x001 },	/* 0x608 - 0x608 */
	{ 0x808,	0x001 },	/* 0x808 - 0x808 */
	{ 0xa08,	0x001 },	/* 0xa08 - 0xa08 */
	{ 0x025,	0x001 },	/* 0x025 - 0x025 */
	{ 0x022,	0x001 },	/* 0x022 - 0x022 */
	{ 0x049,	0x006 },	/* 0x049 - 0x04e */
	{ 0x045,	0x001 },	/* 0x045 - 0x045 */
	{ 0x791,	0x001 },	/* 0x791 - 0x791 */
	{ 0x991,	0x001 },	/* 0x991 - 0x991 */
	{ 0xb91,	0x001 },	/* 0xb91 - 0xb91 */
	{ 0x790,	0x001 },	/* 0x790 - 0x790 */
	{ 0x990,	0x001 },	/* 0x990 - 0x990 */
	{ 0xb90,	0x001 },	/* 0xb90 - 0xb90 */
	{ 0x000,	0x001 },	/* 0x000 - 0x000 */
	{ 0x158,	0x001 },	/* 0x158 - 0x158 */
	{ 0x157,	0x001 },	/* 0x157 - 0x157 */
	{ 0x024,	0x001 },	/* 0x024 - 0x024 */
	{ 0x1cc,	0x001 },	/* 0x1cc - 0x1cc */
	{ 0x1ca,	0x002 },	/* 0x1ca - 0x1cb */
	{ 0x529,	0x001 },	/* 0x529 - 0x529 */
	{ 0x528,	0x001 },	/* 0x528 - 0x528 */
	{ 0x527,	0x001 },	/* 0x527 - 0x527 */
	{ 0x526,	0x001 },	/* 0x526 - 0x526 */
	{ 0x525,	0x001 },	/* 0x525 - 0x525 */
	{ 0x524,	0x001 },	/* 0x524 - 0x524 */
	{ 0x2d2,	0x001 },	/* 0x2d2 - 0x2d2 */
	{ 0,	0 }
};

static phy_regs_t acphy13_regs[] = {
	{ 0x003,	0x002 },	/* 0x003 - 0x004 */
	{ 0x007,	0x001 },	/* 0x007 - 0x007 */
	{ 0x00b,	0x002 },	/* 0x00b - 0x00c */
	{ 0x00e,	0x007 },	/* 0x00e - 0x014 */
	{ 0x020,	0x001 },	/* 0x020 - 0x020 */
	{ 0x022,	0x00a },	/* 0x022 - 0x02b */
	{ 0x030,	0x001 },	/* 0x030 - 0x030 */
	{ 0x040,	0x010 },	/* 0x040 - 0x04f */
	{ 0x060,	0x008 },	/* 0x060 - 0x067 */
	{ 0x070,	0x00b },	/* 0x070 - 0x07a */
	{ 0x080,	0x029 },	/* 0x080 - 0x0a8 */
	{ 0x0b0,	0x05d },	/* 0x0b0 - 0x10c */
	{ 0x120,	0x00b },	/* 0x120 - 0x12a */
	{ 0x140,	0x019 },	/* 0x140 - 0x158 */
	{ 0x15a,	0x019 },	/* 0x15a - 0x172 */
	{ 0x174,	0x006 },	/* 0x174 - 0x179 */
	{ 0x17c,	0x003 },	/* 0x17c - 0x17e */
	{ 0x180,	0x017 },	/* 0x180 - 0x196 */
	{ 0x198,	0x00d },	/* 0x198 - 0x1a4 */
	{ 0x1ae,	0x001 },	/* 0x1ae - 0x1ae */
	{ 0x1b0,	0x004 },	/* 0x1b0 - 0x1b3 */
	{ 0x1b5,	0x02a },	/* 0x1b5 - 0x1de */
	{ 0x1e0,	0x01f },	/* 0x1e0 - 0x1fe */
	{ 0x200,	0x003 },	/* 0x200 - 0x202 */
	{ 0x210,	0x003 },	/* 0x210 - 0x212 */
	{ 0x218,	0x002 },	/* 0x218 - 0x219 */
	{ 0x230,	0x00a },	/* 0x230 - 0x239 */
	{ 0x240,	0x00b },	/* 0x240 - 0x24a */
	{ 0x250,	0x00a },	/* 0x250 - 0x259 */
	{ 0x25b,	0x00e },	/* 0x25b - 0x268 */
	{ 0x270,	0x003 },	/* 0x270 - 0x272 */
	{ 0x280,	0x020 },	/* 0x280 - 0x29f */
	{ 0x2b0,	0x00b },	/* 0x2b0 - 0x2ba */
	{ 0x2c0,	0x00b },	/* 0x2c0 - 0x2ca */
	{ 0x2d0,	0x006 },	/* 0x2d0 - 0x2d5 */
	{ 0x2d8,	0x004 },	/* 0x2d8 - 0x2db */
	{ 0x2e0,	0x009 },	/* 0x2e0 - 0x2e8 */
	{ 0x2ea,	0x010 },	/* 0x2ea - 0x2f9 */
	{ 0x2fe,	0x022 },	/* 0x2fe - 0x31f */
	{ 0x321,	0x02a },	/* 0x321 - 0x34a */
	{ 0x34d,	0x017 },	/* 0x34d - 0x363 */
	{ 0x370,	0x008 },	/* 0x370 - 0x377 */
	{ 0x380,	0x004 },	/* 0x380 - 0x383 */
	{ 0x390,	0x00b },	/* 0x390 - 0x39a */
	{ 0x39c,	0x001 },	/* 0x39c - 0x39c */
	{ 0x3a1,	0x051 },	/* 0x3a1 - 0x3f1 */
	{ 0x401,	0x01a },	/* 0x401 - 0x41a */
	{ 0x41c,	0x002 },	/* 0x41c - 0x41d */
	{ 0x420,	0x007 },	/* 0x420 - 0x426 */
	{ 0x429,	0x005 },	/* 0x429 - 0x42d */
	{ 0x430,	0x009 },	/* 0x430 - 0x438 */
	{ 0x442,	0x019 },	/* 0x442 - 0x45a */
	{ 0x460,	0x016 },	/* 0x460 - 0x475 */
	{ 0x480,	0x004 },	/* 0x480 - 0x483 */
	{ 0x48e,	0x001 },	/* 0x48e - 0x48e */
	{ 0x490,	0x001 },	/* 0x490 - 0x490 */
	{ 0x496,	0x001 },	/* 0x496 - 0x496 */
	{ 0x49d,	0x001 },	/* 0x49d - 0x49d */
	{ 0x4b8,	0x001 },	/* 0x4b8 - 0x4b8 */
	{ 0x4d6,	0x001 },	/* 0x4d6 - 0x4d6 */
	{ 0x4f4,	0x003 },	/* 0x4f4 - 0x4f6 */
	{ 0x4f8,	0x003 },	/* 0x4f8 - 0x4fa */
	{ 0x500,	0x002 },	/* 0x500 - 0x501 */
	{ 0x510,	0x001 },	/* 0x510 - 0x510 */
	{ 0x520,	0x00c },	/* 0x520 - 0x52b */
	{ 0x580,	0x001 },	/* 0x580 - 0x580 */
	{ 0x582,	0x017 },	/* 0x582 - 0x598 */
	{ 0x5a0,	0x021 },	/* 0x5a0 - 0x5c0 */
	{ 0x5d0,	0x00a },	/* 0x5d0 - 0x5d9 */
	{ 0x600,	0x010 },	/* 0x600 - 0x60f */
	{ 0x620,	0x00c },	/* 0x620 - 0x62b */
	{ 0x640,	0x010 },	/* 0x640 - 0x64f */
	{ 0x660,	0x003 },	/* 0x660 - 0x662 */
	{ 0x670,	0x015 },	/* 0x670 - 0x684 */
	{ 0x690,	0x007 },	/* 0x690 - 0x696 */
	{ 0x698,	0x002 },	/* 0x698 - 0x699 */
	{ 0x6a0,	0x00f },	/* 0x6a0 - 0x6ae */
	{ 0x6c0,	0x006 },	/* 0x6c0 - 0x6c5 */
	{ 0x6d2,	0x001 },	/* 0x6d2 - 0x6d2 */
	{ 0x6d4,	0x001 },	/* 0x6d4 - 0x6d4 */
	{ 0x6d8,	0x004 },	/* 0x6d8 - 0x6db */
	{ 0x6e3,	0x001 },	/* 0x6e3 - 0x6e3 */
	{ 0x6e7,	0x001 },	/* 0x6e7 - 0x6e7 */
	{ 0x6e9,	0x001 },	/* 0x6e9 - 0x6e9 */
	{ 0x6eb,	0x003 },	/* 0x6eb - 0x6ed */
	{ 0x6ef,	0x004 },	/* 0x6ef - 0x6f2 */
	{ 0x6f4,	0x001 },	/* 0x6f4 - 0x6f4 */
	{ 0x6f8,	0x002 },	/* 0x6f8 - 0x6f9 */
	{ 0x6fb,	0x003 },	/* 0x6fb - 0x6fd */
	{ 0x710,	0x004 },	/* 0x710 - 0x713 */
	{ 0x720,	0x00a },	/* 0x720 - 0x729 */
	{ 0x730,	0x00f },	/* 0x730 - 0x73e */
	{ 0x741,	0x009 },	/* 0x741 - 0x749 */
	{ 0x750,	0x004 },	/* 0x750 - 0x753 */
	{ 0x767,	0x001 },	/* 0x767 - 0x767 */
	{ 0x769,	0x001 },	/* 0x769 - 0x769 */
	{ 0x780,	0x01a },	/* 0x780 - 0x799 */
	{ 0x7a0,	0x00e },	/* 0x7a0 - 0x7ad */
	{ 0x7b0,	0x003 },	/* 0x7b0 - 0x7b2 */
	{ 0x7b5,	0x002 },	/* 0x7b5 - 0x7b6 */
	{ 0x7b9,	0x007 },	/* 0x7b9 - 0x7bf */
	{ 0x7d0,	0x00d },	/* 0x7d0 - 0x7dc */
	{ 0x7f0,	0x005 },	/* 0x7f0 - 0x7f4 */
	{ 0x830,	0x010 },	/* 0x830 - 0x83f */
	{ 0x850,	0x008 },	/* 0x850 - 0x857 */
	{ 0xc00,	0x004 },	/* 0xc00 - 0xc03 */
	{ 0xc05,	0x004 },	/* 0xc05 - 0xc08 */
	{ 0xc10,	0x009 },	/* 0xc10 - 0xc18 */
	{ 0xc30,	0x00c },	/* 0xc30 - 0xc3b */
	{ 0xc40,	0x006 },	/* 0xc40 - 0xc45 */
	{ 0xd00,	0x003 },	/* 0xd00 - 0xd02 */
	{ 0xd20,	0x003 },	/* 0xd20 - 0xd22 */
	{ 0,	0 }
};

#endif /* ACCONF != 0 */

#if defined(DBG_PHY_IOV)
static phy_table_info_t aphy2_tables[] = {
	{ 0,	0,	0x20 },
	{ 1,	0,	0x20 },
	{ 2,	0,	0x10 },
	{ 3,	0,	0x10 },
	{ 4,	0,	0x10 },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 8,	1,	0x35 },
	{ 9,	1,	0x35 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	7 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xd },
	{ 0x10,	0,	0x10 },
	{ 0x11,	0,	8 },
	{ 0x12,	0,	8 },
	{ 0x16,	0,	0x100 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t aphy3_tables[] = {
	{ 0,	0,	0x20 },
	{ 1,	0,	0x20 },
	{ 2,	0,	0x10 },
	{ 4,	0,	0xc },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	4 },
	{ 0xd,	0,	0x40 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xe },
	{ 0x10,	0,	0x40 },
	{ 0x11,	0,	8 },
	{ 0x13,	0,	2 },
	{ 0x14,	0,	0x35 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t aphy4_tables[] = {
	{ 0,	0,	0x20 },
	{ 1,	0,	0x28 },
	{ 2,	0,	0x10 },
	{ 4,	0,	0x10 },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 7,	0,	4 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	5 },
	{ 0xd,	0,	0x40 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xe },
	{ 0x10,	0,	0x40 },
	{ 0x11,	0,	8 },
	{ 0x13,	0,	2 },
	{ 0x14,	0,	0x35 },
	{ 0x15,	0,	0x40 },
	{ 0x16,	0,	0x40 },
	{ 0x17,	0,	0x10 },
	{ 0x18,	0,	0x40 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t gphy1_tables[] = {
	{ 0,	0,	0x20 },
	{ 1,	0,	0x20 },
	{ 2,	0,	0x10 },
	{ 3,	0,	0x10 },
	{ 4,	0,	0x10 },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 8,	1,	0x35 },
	{ 9,	1,	0x35 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	7 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xd },
	{ 0x10,	0,	0x10 },
	{ 0x11,	0,	8 },
	{ 0x12,	0,	8 },
	{ 0x13,	0,	0x20 },
	{ 0x14,	0,	0x20 },
	{ 0x15,	0,	0x14 },
	{ 0x16,	0,	0x100 },
	{ 0x80,	0,	0x40 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t gphy2_tables[] = {
	{ 0,	0,	0x18 },
	{ 1,	0,	0x18 },
	{ 2,	0,	4 },
	{ 4,	0,	0xc },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	4 },
	{ 0xd,	0,	0x40 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xd },
	{ 0x10,	0,	0x10 },
	{ 0x11,	0,	8 },
	{ 0x14,	0,	0x35 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t gphy3_tables[] = {
	{ 0,	0,	0x18 },
	{ 1,	0,	0x18 },
	{ 2,	0,	4 },
	{ 4,	0,	0xc },
	{ 5,	0,	0x1b },
	{ 6,	0,	8 },
	{ 7,	0,	4 },
	{ 0xa,	1,	0x35 },
	{ 0xb,	1,	0x35 },
	{ 0xc,	0,	4 },
	{ 0xd,	0,	0x40 },
	{ 0xe,	0,	0x10 },
	{ 0xf,	0,	0xd },
	{ 0x10,	0,	0x40 },
	{ 0x11,	0,	8 },
	{ 0x13,	0,	0xa },
	{ 0x14,	0,	0x35 },
	{ 0x15,	0,	0x40 },
	{ 0x16,	0,	0x40 },
	{ 0x17,	0,	0x10 },
	{ 0x18,	0,	0x40 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t nphy2_tables[] = {
	{ 0x00, 0,	53 },
	{ 0x01, 0,	53 },
	{ 0x02, 0,	53 },
	{ 0x03, 0,	53 },
	{ 0x04, 0,	59 },
	{ 0x05, 0,	59 },
	{ 0x07, 0,	288 },
	{ 0x08, 0,	26 },
	{ 0x09, 0,	128 },
	{ 0x0a, 1,	768 },
	{ 0x0b, 0,	128 },
	{ 0x0c, 1,	448 },
	{ 0x0d, 1,	8 },
	{ 0x0e, 1,	768 },
	{ 0x0f, 0,	106 },
	{ 0x10, 1,	256 },
	/*	this table is not needed
	{ 0x11, 1,	1024 },
	*/
	{ 0x12, 0,	128 },
	{ 0x13, 1,	512 },
	{ 0x14, 1,	6 },
	{ 0x15, 0,	6 },
	{ 0x16, 1,	96 },
	{ 0x17, 0,	11 },
	{ 0x18, 0,	32 },
	{ 0x19, 0,	11 },
	{ 0x1a, 1,	576 },
	{ 0x1b, 1,	576 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t nphy3_tables_1[] = {
	{ 0x00, 0,	99 },
	{ 0x01, 0,	99 },
	{ 0x02, 0,	99 },
	{ 0x03, 0,	99 },
	{ 0x04, 0,	105 },
	{ 0x05, 0,	105 },
	{ 0x07, 0,	320 },
	{ 0x08, 0,	48 },
	{ 0x09, 0,	32 }, /* for REV7+, 32 is changed to 64 in phydump_dumptbl */
	{ 0x0a, 1,	768 },
	{ 0x0b, 0,	128 },
	{ 0x0c, 1,	448 },
	{ 0x0d, 1,	8 },
	{ 0x0e, 1,	768 },
	{ 0x0f, 0,	108 },
	{ 0x10, 1,	282 },
	/*	this table is not needed
	{ 0x11, 1,	1024 },
	*/
	{ 0x12, 0,	128 },
	{ 0x13, 1,	512 },
	{ 0x14, 1,	6 },
	{ 0x16, 1,	96 },
	{ 0x18, 0,	32 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t nphy3_tables_2[] = {
	{ 0x1a, 1,	704 },
	{ 0x1b, 1,	704 },
	{ 0x1e, 1,	5 },
	{ 0x1f, 1,	64 },
	{ 0x20, 1,	64 },
	{ 0x21, 1,	64 },
	{ 0x22, 1,	64 },
	{ 0xff,	0,	0 }
};

static phy_table_info_t htphy_tables[] = {
	{ 0x00, 0,	99 },
	{ 0x01, 0,	99 },
	{ 0x02, 0,	99 },
	{ 0x03, 0,	99 },
	{ 0x04, 0,	105 },
	{ 0x05, 0,	105 },
	{ 0x07, 0,	1024 },
	{ 0x08, 0,	48 },
	{ 0x09, 0,	48 },
	{ 0x0d, 0,	160 },
	/* sampleplay table not needed
	{ 0x11, 1,	1024 },
	*/
	{ 0x12, 0,	128 },
	{ 0x1a, 1,	704 },
	{ 0x1b, 1,	704 },
	{ 0x1c, 1,	704 },
	{ 0x1f, 1,	64 },
	{ 0x20, 1,	64 },
	{ 0x21, 1,	64 },
	{ 0x22, 1,	64 },
	{ 0x23, 1,	64 },
	{ 0x24, 1,	64 },
	{ 0x25, 1,	128 },
	{ 0x26, 0,	128 },
	{ 0x27, 0,	32 },
	{ 0x28, 0,	99 },
	{ 0x29, 0,	99 },
	{ 0x2a, 1,	32 },
	/* coreXchanest table not needed
	{ 0x2b, 1,	512 },
	{ 0x2c, 1,	512 },
	{ 0x2d, 1,	512 },
	*/
	{ 0x2f, 1,	22 },
	{ 0xff,	0,	0 }
};

#if ACCONF != 0
static phy_table_info_t acphy_tables_rev4[] = {
	{  1, 0,  128},
	{  2, 0,   40},
	{  3, 1,  256},
	{  4, 0,  256},
	{  5, 1,   22},
	{  6, 0,   72},
	{  7, 0, 1136},
	{  8, 3,    9},
	{  9, 0,   48},
	{ 10, 0,  768},
	{ 12, 0,  160},
	{ 13, 1,   68},
	{ 14, 1,  512},
	{ 15, 1,  128},
	{ 16, 1, 8784},
	{ 17, 2, 464},
	{ 18, 1, 1920},
	{ 19, 0,  800},
	{ 20, 2,  128},
	{ 21, 0,   72},
	{ 22, 0,   64},
	{ 23, 1,  520},
	{ 24, 1,  520},
	{ 25, 1,  64},
	{ 26, 1,  22},
	{ 27, 0,   46},
	{ 28, 0,   46},
	{ 29, 1,   35},
	{ 30, 1,   64},
	{ 31, 1,   35},
	{ 32, 2,  128},
	{ 33, 1,   24},
	{ 34, 2,   512},
	{ 35, 1,   77},
	{ 64, 0,  128},
	{ 65, 1,  128},
	{ 66, 0,  128},
	{ 67, 0,  128},
	{ 68, 0,  119},
	{ 69, 0,  119},
	{ 70, 1,   22},
	{ 71, 1,  512},
	{ 72, 1,  128},
	{ 73, 1, 1024},
	{ 80, 0,    8},
	{ 81, 0,  128},
	{ 82, 0,  128},
	{ 83, 0,  128},
	{ 84, 0,  128},
	{ 85, 0,  128},
	{ 86, 0,  128},
	{ 87, 0,  128},
	{ 88, 0,  72},
	{ 89, 0,  16},
	{ 90, 0,  64},
	{ 91, 0,  64},
	{ 92, 0,  64},
	{ 93, 0,  128},
	{ 94, 0,  105},
	{ 96, 0,  128},
	{ 97, 1,  128},
	{ 98, 0,  128},
	{ 99, 0,  128},
	{100, 0,  119},
	{101, 0,  119},
	{102, 1,   22},
	{103, 1,  512},
	{104, 1,  128},
	{105, 1, 1024},
	{112, 1,   64},
	{113, 1,   64},
	{117, 0,   128},
	{118, 0,   128},
	{119, 0,   128},
	{120, 0,  72},
	{121, 0,  16},
	{122, 0,  64},
	{123, 0,  64},
	{124, 0,  64},
	{125, 0,  128},
	{126, 0,  105},
	{128, 0,  128},
	{129, 1,  128},
	{130, 0,  128},
	{131, 0,  128},
	{132, 0,  119},
	{133, 0,  119},
	{134, 1,   22},
	{135, 1,  512},
	{136, 1,  128},
	{137, 1, 1024},
	{149, 0,   128},
	{150, 0,   128},
	{151, 0,   128},
	{152, 0,   72},
	{153, 0,   16},
	{154, 0,   64},
	{155, 0,   64},
	{156, 0,   64},
	{157, 0,   128},
	{158, 0,   105},
	{ 0xff,	0,	0 }
};

static phy_table_info_t acphy_tables_rev3[] = {
	{  1, 0,  128},
	{  2, 0,   40},
	{  3, 0,  256},
	{  4, 0,  256},
	{  5, 1,   22},
	{  6, 0,   72},
	{  7, 0, 1136},
	{  8, 3,    9},
	{  9, 0,   48},
	{ 10, 0,  320},
	{ 11, 0,  105},
	{ 12, 0,  160},
	{ 13, 1,   68},
	{ 14, 1,  512},
	{ 15, 1,  128},
	{ 16, 1, 8784},
	{ 18, 1, 1920},
	{ 19, 0,  512},
	{ 20, 2,  128},
	{ 21, 0,   72},
	{ 22, 0,   64},
	{ 23, 1,  520},
	{ 24, 1,  520},
	{ 27, 0,   46},
	{ 28, 0,   46},
	{ 29, 1,   35},
	{ 30, 1,   64},
	{ 32, 2,  128},
	{ 33, 1,   24},
	{ 64, 0,  128},
	{ 65, 1,  128},
	{ 66, 0,  128},
	{ 67, 0,  128},
	{ 68, 0,  119},
	{ 69, 0,  119},
	{ 70, 1,   22},
	{ 71, 1,  128},
	{ 72, 1,  128},
	{ 73, 1, 1024},
	{ 80, 0,    8},
	{ 81, 0,  128},
	{ 82, 0,  128},
	{ 83, 0,  128},
	{ 84, 0,  128},
	{ 96, 0,  128},
	{ 97, 1,  128},
	{ 98, 0,  128},
	{ 99, 0,  128},
	{100, 0,  119},
	{101, 0,  119},
	{102, 1,   22},
	{103, 1,  128},
	{104, 1,  128},
	{105, 1, 1024},
	{ 0xff,	0,	0 }
};
static phy_table_info_t acphy2_tables_1[] = {
	{ 2, 0,   40},
	{ 3, 1,  256},
	{ 4, 0,  256},
	{ 7, 0, 1136},
	{ 8, 3,    9},
	{ 9, 0,   16},
	{10, 0,  256},
	{11, 0,  105},
	{12, 0,  160},
	{13, 1,   68},
	{14, 1,  512},
	{19, 0,  512},
	{20, 2,  128},
	{21, 0,   24},
	{22, 0,   35},
	{25, 1,   64},
	{26, 1,   22},
	{29, 1,   35},
	{31, 1,   35},
	{32, 2,  128},
	{33, 0,   24},
	{34, 0,  512},

	{0xff, 0, 0}
};
static phy_table_info_t acphy2_tables_2[] = {
	{64, 0,  128},
	{65, 1,  128},
	{66, 0,  128},
	{67, 0,  128},
	{68, 0,  119},
	{69, 0,  119},
	{70, 1,   19},
	{71, 1,   64},
	{72, 1,   64},
	{73, 1, 1024},
	{80, 0,    8},
	{81, 0,  128},
	{82, 0,  128},
	{83, 0,  128},
	{84, 0,  128},

	{0xff, 0, 0}
};
static phy_table_info_t acphy_tables[] = {
	{  1, 0,  128},
	{  2, 0,   40},
	{  3, 1,  256},
	{  4, 0,  256},
	{  5, 1,   22},
	{  6, 0,   72},
	{  7, 0, 1136},
	{  8, 3,    9},
	{  9, 0,   48},
	{ 10, 0,   96},
	{ 11, 0,  105},
	{ 12, 0,  160},
	{ 13, 1,   68},
	{ 14, 1,  512},
	{ 15, 1,  128},
	{ 16, 1, 8784},
	{ 17, 2,  464},
	{ 18, 1, 1920},
	{ 19, 0,  512},
	{ 20, 2,  128},
	{ 21, 0,   72},
	{ 22, 0,   64},
	{ 23, 1,  520},
	{ 24, 1,  520},
	{ 32, 2,  128},
	{ 33, 1,   24},
	{ 64, 0,  128},
	{ 65, 1,  128},
	{ 66, 0,  128},
	{ 67, 0,  128},
	{ 68, 0,  119},
	{ 69, 0,  119},
	{ 70, 1,   19},
	{ 71, 1,   64},
	{ 72, 1,   64},
	{ 73, 1, 1024},
	{ 80, 0,    8},
	{ 81, 0,  128},
	{ 82, 0,  128},
	{ 83, 0,  128},
	{ 84, 0,  128},
	{ 96, 0,  128},
	{ 97, 1,  128},
	{ 98, 0,  128},
	{ 99, 0,  128},
	{100, 0,  119},
	{101, 0,  119},
	{102, 1,   19},
	{103, 1,   64},
	{104, 1,   64},
	{105, 1, 1024},
	{128, 0,  128},
	{129, 1,  128},
	{130, 0,  128},
	{131, 0,  128},
	{132, 0,  119},
	{133, 0,  119},
	{134, 1,   19},
	{135, 1,   64},
	{136, 1,   64},
	{137, 1, 1024},
	{ 0xff,	0,	0 }
};
#endif /* ACCONF != 0 */

static void
wlc_phy_table_read(phy_info_t *pi, phy_table_info_t *ti, uint16 addr, uint16 *val, uint16 *qval)
{
	if (ISABGPHY(pi)) {
		wlc_phytable_read_abgphy(pi, ti, addr, val, qval);

	} else if (ISNPHY(pi)) {

		phy_reg_write(pi, NPHY_TableAddress, (ti->table << 10) | addr);
		*qval = 0;
		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
			(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
			OSL_DELAY(1);
		}

		/* PR68864 WAR, 43224 B0 requires a dummy read
		 * 43421 suffers the same problem
		 */
		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
		     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
		    (pi->sh->chiprev == 1)) {
			(void)phy_reg_read(pi, NPHY_TableDataLo);
			/* roll back the address from the dummy read */
			phy_reg_write(pi, NPHY_TableAddress, (ti->table << 10) | addr);
		}

		if (ti->q) {
			*qval = phy_reg_read(pi, NPHY_TableDataLo);
			*val = phy_reg_read(pi, NPHY_TableDataHi);
		} else {
			*val = phy_reg_read(pi, NPHY_TableDataLo);
		}
		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);
	} else if (ISHTPHY(pi)) {

		phy_reg_write(pi, HTPHY_TableAddress, (ti->table << 10) | addr);
		*qval = 0;

		if (ti->q) {
			*qval = phy_reg_read(pi, HTPHY_TableDataLo);
			*val = phy_reg_read(pi, HTPHY_TableDataHi);
		} else {
			*val = phy_reg_read(pi, HTPHY_TableDataLo);
		}
	} else if (ISACPHY(pi)) {
		phy_reg_write(pi, ACPHY_TableID(pi->pubpi.phy_rev), (uint16)ti->table);
		phy_reg_write(pi, ACPHY_TableOffset(pi->pubpi.phy_rev), addr);

		if (ti->q == 3) {
			*qval++ = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
			*qval++ = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
			*qval = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
			*val = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
		} else if (ti->q == 2) {
			*qval++ = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
			*qval = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
			*val = phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
		} else if (ti->q == 1) {
			*qval = phy_reg_read(pi, ACPHY_TableDataLo(pi->pubpi.phy_rev));
			*val = phy_reg_read(pi, ACPHY_TableDataHi(pi->pubpi.phy_rev));
		} else {
			*val = phy_reg_read(pi, ACPHY_TableDataLo(pi->pubpi.phy_rev));
		}
	}
}
#endif // endif

#ifdef WLC_LOW_ONLY
extern void
wlc_phy_dump_phy_regs(wlc_phy_t *pih, struct bcmstrbuf *b, int *offset)
#else
extern void
wlc_phy_dump_phy_regs(wlc_phy_t *pih, struct bcmstrbuf *b)
#endif // endif
{
	phy_info_t *pi = (phy_info_t *)pih;
	phy_regs_t *rl = NULL;

	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* dump BPHY space, from within GPHY or NPHY+2G */
	if (ISGPHY(pi)) {
		if (GREV_GE(pi->pubpi.phy_rev, 6))
			rl = bphy8_regs;
		else if (GREV_IS(pi->pubpi.phy_rev, 2))
			rl = bphy6_regs;
		else
			rl = bphy5_regs;
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "bphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "bphy", rl, 0, b);
#endif // endif

	} else if (ISNPHY(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
			rl = nphy3_bphy_regs;
		} else {
			rl = bphy8_regs;
		}
		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
			(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
			OSL_DELAY(1);
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "bphy", rl, NPHY_TO_BPHY_OFF, b, offset);
#else
		dump_phyregs(pi, "bphy", rl, NPHY_TO_BPHY_OFF, b);
#endif // endif
		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);
	} else if (ISHTPHY(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
		rl = htphy0_bphy_regs;
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "bphy", rl, HTPHY_TO_BPHY_OFF, b, offset);
#else
		dump_phyregs(pi, "bphy", rl, HTPHY_TO_BPHY_OFF, b);
#endif // endif
	}

	if (ISGPHY(pi)) {
		if (GREV_GE(pi->pubpi.phy_rev, 7))
			rl = aphy6_regs;
		else if (GREV_GE(pi->pubpi.phy_rev, 3))
			rl = aphy4_regs;
		else if (GREV_IS(pi->pubpi.phy_rev, 2))
			rl = aphy3_regs;
		else
			rl = aphy2_regs;
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "aphy", rl, GPHY_TO_APHY_OFF, b, offset);
#else
		dump_phyregs(pi, "aphy", rl, GPHY_TO_APHY_OFF, b);
#endif // endif
		if (GREV_GE(pi->pubpi.phy_rev, 3)) {
			rl = gphy2_regs;
		} else if (GREV_IS(pi->pubpi.phy_rev, 2)) {
			rl = gphy2_regs;
		} else {
			rl = gphy1_regs;
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "gphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "gphy", rl, 0, b);
#endif // endif
	} else if (ISAPHY(pi)) {
		/* A phy */
		if (AREV_GE(pi->pubpi.phy_rev, 6)) {
			rl = aphy6_regs;
		} else if (AREV_GE(pi->pubpi.phy_rev, 4)) {
			rl = aphy4_regs;
		} else if (AREV_IS(pi->pubpi.phy_rev, 3)) {
			rl = aphy3_regs;
		} else {
			rl = aphy2_regs;
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "aphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "aphy", rl, 0, b);
#endif // endif
	} else if (ISNPHY(pi)) {
		if (NREV_IS(pi->pubpi.phy_rev, 17)) {
			rl = nphy17_regs;
		} else if (NREV_GE(pi->pubpi.phy_rev, 8)) {
			rl = nphy8_regs;
		} else if (NREV_IS(pi->pubpi.phy_rev, 7)) {
			rl = nphy7_regs;
		} else if (NREV_GE(pi->pubpi.phy_rev, 5)) {
			rl = nphy5_regs;
		} else if (NREV_GE(pi->pubpi.phy_rev, 3)) {
			rl = nphy3_regs;
		} else {
			rl = nphy2_regs;
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "nphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "nphy", rl, 0, b);
#endif // endif
	} else if (ISHTPHY(pi)) {
		if (HTREV_GE(pi->pubpi.phy_rev, 1)) {
			rl = htphy1_regs;
		} else {
			rl = htphy0_regs;
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "htphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "htphy", rl, 0, b);
#endif // endif
#if ACCONF != 0
	} else if (ISACPHY(pi)) {
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			rl = acphy9_regs;
		} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
			rl = acphy13_regs;
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			rl = acphy3_regs;
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			rl = acphy2_regs;
		} else if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
			rl = acphy0_regs;
		} else {
			ASSERT(0);
		}
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "acphy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "acphy", rl, 0, b);
#endif // endif
#endif /* ACCONF != 0 */
	} else if (ISLPPHY(pi)) {
		PHY_ERROR(("Take care of LP phy dumps\n"));
		return;
	} else if (ISSSLPNPHY(pi)) {
		return;
	} else if (ISLCNPHY(pi)) {
		PHY_TRACE(("%s:***CHECK***\n", __FUNCTION__));
		return;
	} else if (ISLCN40PHY(pi)) {
		rl = lcn40phy3_regs;
#ifdef WLC_LOW_ONLY
		dump_phyregs(pi, "lcn40phy", rl, 0, b, offset);
#else
		dump_phyregs(pi, "lcn40phy", rl, 0, b);
#endif // endif
		return;
	}

	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
}

static uint16 regs_2050[] = {
	0x41, 0x42, 0x43, 0x50, 0x51, 0x52, 0x58, 0x5a,
	0x5b, 0x5c, 0x5d, 0x73, 0x74, 0x75, 0x76, 0x77,
	0x78, 0x79, 0x7a, 0x84, 0x86, 0x87, 0xe0, 0xe1,
	0xe2, 0xffff};

static uint16 regs_2050r8[] = {
	0x41, 0x42, 0x43, 0x50, 0x51, 0x52, 0x53, 0x54,
	0x58, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x73, 0x74,
	0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c,
	0x7d, 0x83, 0x84, 0x85, 0x86, 0x87, 0xe0, 0xe1,
	0xe2, 0xe3, 0xe4, 0x7e, 0xffff};

static uint16 regs_2060ww[] = {
	0x02, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
	0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
	0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a,
	0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32,
	0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
	0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x80, 0x81, 0x82,
	0x83, 0x84, 0x85, 0xffff};

#ifdef WLC_LOW_ONLY
#define BUF_CHARS_LINE_RADIO 34
#define BUF_MAX_LINE_RADIO 30 /* (BUF_LIMIT/BUF_CHARS_LINE_RADIO)approax */
extern void
wlc_phy_dump_radio_regs(wlc_phy_t *pih, struct bcmstrbuf *b, bool name_on, int *offset)
#else
extern void
wlc_phy_dump_radio_regs(wlc_phy_t *pih, struct bcmstrbuf *b, bool name_on)
#endif // endif
{
	phy_info_t *pi = (phy_info_t *)pih;
	uint16 *regs = NULL;
	const char *name = NULL;
#ifdef WLC_LOW_ONLY
	int i, buf_length, core_cnt, jtag_core;
#else
	int i, core_cnt, jtag_core;
#endif // endif
	uint16 addr = 0;
	radio_regs_t *radioregs = NULL;
	radio_regs_t *radioregs_tx = NULL;
	radio_regs_t *radioregs_rx = NULL;
	radio_20xx_regs_t *radio20xxregs = NULL;
	radio_20xx_dumpregs_t *radio20xxdumpregs = NULL;
	radio_20671_regs_t *radio20671regs = NULL;
	lcnphy_radio_regs_t *lcnphyregs = NULL;
	sslpnphy_radio_regs_t *sslpnphyregs = NULL;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	if (RADIOID(pi->pubpi.radioid) == BCM2050_ID) {
		if (RADIOREV(pi->pubpi.radiorev) == 8) {
			regs = regs_2050r8;
			name = "2050r8";
		} else {
			regs = regs_2050;
			name = "2050";
		}
	} else if (RADIOID(pi->pubpi.radioid) == BCM2060_ID) {
		regs = regs_2060ww;
		name = "2060ww";
	} else if (NCONF && RADIOID(pi->pubpi.radioid) == BCM2055_ID) {
		radioregs = regs_2055;
		name = "2055";
	} else if (NCONF && RADIOID(pi->pubpi.radioid) == BCM2056_ID) {
		if (NREV_LE(pi->pubpi.phy_rev, 4)) {
			radioregs = regs_SYN_2056;
			radioregs_tx = regs_TX_2056;
			radioregs_rx = regs_RX_2056;
		} else {
			switch (RADIOREV(pi->pubpi.radiorev)) {
			case 5:
				radioregs = regs_SYN_2056_rev5;
				radioregs_tx = regs_TX_2056_rev5;
				radioregs_rx = regs_RX_2056_rev5;
				break;

			case 6:
				radioregs = regs_SYN_2056_rev6;
				radioregs_tx = regs_TX_2056_rev6;
				radioregs_rx = regs_RX_2056_rev6;
				break;

			case 7:
			case 9: /* Radio id rev7 and rev9 have the same register settings */
				radioregs = regs_SYN_2056_rev7;
				radioregs_tx = regs_TX_2056_rev7;
				radioregs_rx = regs_RX_2056_rev7;
				break;

			case 8:
			case 11:
				radioregs = regs_SYN_2056_rev8;
				radioregs_tx = regs_TX_2056_rev8;
				radioregs_rx = regs_RX_2056_rev8;
				break;

			default:
				PHY_ERROR(("Unsupported radio rev %d\n",
					RADIOREV(pi->pubpi.radiorev)));
				ASSERT(0);
				break;
			}
		}
		name = "2056";
	} else if (NCONF && RADIOID(pi->pubpi.radioid) == BCM2057_ID) {
		switch (RADIOREV(pi->pubpi.radiorev)) {
		case 3:
			radio20xxregs = regs_2057_rev4;
			break;
		case 4:
			radio20xxregs = regs_2057_rev4;
			break;
		case 5:
			if (RADIOVER(pi->pubpi.radiover) == 0x0) {
				/* A0 */
				radio20xxregs = regs_2057_rev5;
			} else if (RADIOVER(pi->pubpi.radiover) == 0x1) {
				/* B0 */
				radio20xxregs = regs_2057_rev5v1;
			}
			break;
		case 6:
			radio20xxregs = regs_2057_rev4;
			break;
		case 7:
			radio20xxregs = regs_2057_rev7;
			break;
		case 8:
			radio20xxregs = regs_2057_rev8;
			break;
		case 9:
			radio20xxregs = regs_2057_rev9;
			break;
		case 10:
			radio20xxregs = regs_2057_rev10;
			break;
		case 12:
			radio20xxregs = regs_2057_rev12;
			break;
		case 13:
			radio20xxregs = regs_2057_rev13;
			break;
		case 14:
			if (RADIOVER(pi->pubpi.radiover) == 1)
				radio20xxregs = regs_2057_rev14v1;
			else
				radio20xxregs = regs_2057_rev14;
			break;
		default:
			PHY_ERROR(("Unsupported radio rev %d\n", RADIOREV(pi->pubpi.radiorev)));
			ASSERT(0);
			break;
		}
		name = "2057";
	} else if (NCONF && RADIOID(pi->pubpi.radioid) == BCM20671_ID) {
		switch (RADIOREV(pi->pubpi.radiorev)) {
		case 0:
			radio20671regs = regs_20671_rev0;
			break;
		case 1:
			if (RADIOVER(pi->pubpi.radiover) == 0)
				radio20671regs = regs_20671_rev1;
			else if (RADIOVER(pi->pubpi.radiover) == 1)
				radio20671regs = regs_20671_rev1_ver1;
			break;
		default:
			PHY_ERROR(("Unsupported radio rev %d\n", RADIOREV(pi->pubpi.radiorev)));
			ASSERT(0);
			break;
		}
		BCM_REFERENCE(radio20671regs);
		name = "20671";
	} else if (ISHTPHY(pi)) {
		if (RADIOID(pi->pubpi.radioid) == BCM2059_ID) {
			radio20xxregs = regs_2059_rev0;
			name = "2059";
		}
#if ACCONF != 0
	} else if (ISACPHY(pi)) {
		if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
			name = "2069";
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
				radio20xxdumpregs = dumpregs_2069_rev32;
			} else if ((RADIOREV(pi->pubpi.radiorev) == 16) ||
				(RADIOREV(pi->pubpi.radiorev) == 18)) {
				radio20xxdumpregs = dumpregs_2069_rev16;
			} else if (RADIOREV(pi->pubpi.radiorev) == 17) {
				radio20xxdumpregs = dumpregs_2069_rev17;
			} else if (RADIOREV(pi->pubpi.radiorev) == 25) {
				radio20xxdumpregs = dumpregs_2069_rev25;
			} else {
				radio20xxdumpregs = dumpregs_2069_rev0;
			}
		} else if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
			name = "20691";
			switch (RADIOREV(pi->pubpi.radiorev)) {
			case 18:
				radio20xxdumpregs = dumpregs_20691_rev18;
				break;
			case 27:
				radio20xxdumpregs = dumpregs_20691_rev27;
				break;
			case 30:
				radio20xxdumpregs = dumpregs_20691_rev30;
				break;
			case 31:
				radio20xxdumpregs = dumpregs_20691_rev31;
				break;
			case 32:
				radio20xxdumpregs = dumpregs_20691_rev32;
				break;
			case 48:
				radio20xxdumpregs = dumpregs_20691_rev48;
				break;
			case 50:
				radio20xxdumpregs = dumpregs_20691_rev50;
				break;
			case 60:
			case 68:
				radio20xxdumpregs = dumpregs_20691_rev68;
				break;
			case 75:
				radio20xxdumpregs = dumpregs_20691_rev75;
				break;
			case 79:
				radio20xxdumpregs = dumpregs_20691_rev79;
				break;
			case 74:
			case 82:
				radio20xxdumpregs = dumpregs_20691_rev82;
				break;
			default:
				;
			}
		}
#endif /* ACCONF != 0 */
	} else if (ISLPPHY(pi)) {
		if (BCM2062_ID == LPPHY_RADIO_ID(pi)) {
			radioregs = regs_2062;
			name = "2062";
		} else {
			if (LPREV_IS(pi->pubpi.phy_rev, 2)) {
				/* for radio rev 0 */
				radioregs = regs_2063_rev0;
			} else if (LPREV_GT(pi->pubpi.phy_rev, 2)) {
				/* for radio rev 1 */
				radioregs = regs_2063_rev1;
			}
			name = "2063";
		}
	} else if (ISSSLPNPHY(pi)) {
		sslpnphyregs = sslpnphy_radio_regs_2063;
		name = "2063 Radio";
	} else if (ISLCNPHY(pi)) {
		if (LCNREV_IS(pi->pubpi.phy_rev, 2)) {
			lcnphyregs = lcnphy_radio_regs_2066;
			name = "2066 Radio";
		} else {
			lcnphyregs = lcnphy_radio_regs_2064;
			name = "2064 Radio";
		}
	} else if (ISSIM_ENAB(pi->sh->sih)) {
		bcm_bprintf(b, "No radio, nothing to dump\n");
		return;
	}

	if (name == NULL)
		return;

	if ((RADIOID(pi->pubpi.radioid) != BCM2059_ID) &&
	      (RADIOID(pi->pubpi.radioid) != BCM2069_ID)) {
		if (name_on)
			bcm_bprintf(b, "%s: 0x%03x 0x%04x\n", name, 1, wlc_phy_get_radio_ver(pi));
		else
			bcm_bprintf(b, "0x%03x 0x%04x\n", 1, wlc_phy_get_radio_ver(pi));
	}

#ifdef WLC_LOW_ONLY
	i = *offset;
	buf_length = 0;
#else
	i = 0;
#endif // endif
	while (TRUE) {
		if (radioregs) {
			/* omit spare and radio ID */
			addr = radioregs[i].address;
		} else if (radio20xxregs) {
			addr = radio20xxregs[i].address;
		} else if (radio20xxdumpregs) {
			addr = radio20xxdumpregs[i].address;
		} else if (lcnphyregs) {
			addr = lcnphyregs[i].address;
		} else if (sslpnphyregs) {
			addr = sslpnphyregs[i].address;
		} else {
			addr = (regs != NULL) ? regs[i] : 0xffff;
		}

		if (addr == 0xffff)
		{
#ifdef WLC_LOW_ONLY
		    *offset = 0;
#endif // endif
			break;
}

		if (RADIOID(pi->pubpi.radioid) == BCM2056_ID) {
			jtag_core = RADIO_2056_SYN;
			name = "2056 SYN";
		} else if (RADIOID(pi->pubpi.radioid) == BCM2059_ID) {
			jtag_core = (addr & JTAG_2059_MASK);
			addr &= (~JTAG_2059_MASK);
		} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
			jtag_core = (addr & JTAG_2069_MASK);
			addr &= (~JTAG_2069_MASK);
		} else {
			jtag_core = 0;
		}

		if (name_on) {
			if ((RADIOID(pi->pubpi.radioid) == BCM2059_ID) &&
				(jtag_core == JTAG_2059_ALL)) {
				bcm_bprintf(b, "%s: 0x%03x 0x%04x 0x%04x 0x%04x\n", name, addr,
				            read_radio_reg(pi, addr | JTAG_2059_CR0),
				            read_radio_reg(pi, addr | JTAG_2059_CR1),
				            read_radio_reg(pi, addr | JTAG_2059_CR2));
			} else if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) &&
				(jtag_core == JTAG_2069_ALL)) {
				switch (PHYCORENUM(pi->pubpi.phy_corenum)) {
					case 1:
						bcm_bprintf(b, "%s: 0x%03x 0x%04x\n", name, addr,
							read_radio_reg(pi, addr | JTAG_2069_CR0));
						break;
					case 2:
						bcm_bprintf(b, "%s: 0x%03x 0x%04x 0x%04x\n",
							name, addr,
							read_radio_reg(pi, addr | JTAG_2069_CR0),
							read_radio_reg(pi, addr | JTAG_2069_CR1));
						break;
					case 3:
						bcm_bprintf(b, "%s: 0x%03x 0x%04x 0x%04x 0x%04x\n",
							name, addr,
							read_radio_reg(pi, addr | JTAG_2069_CR0),
							read_radio_reg(pi, addr | JTAG_2069_CR1),
							read_radio_reg(pi, addr | JTAG_2069_CR2));
						break;
					default:break;
				}
			} else {
				bcm_bprintf(b, "%s: 0x%03x 0x%04x\n", name, addr,
				            read_radio_reg(pi, addr | jtag_core));
			}
		} else {
			if ((RADIOID(pi->pubpi.radioid) == BCM2059_ID) &&
				(jtag_core == JTAG_2059_ALL)) {
				bcm_bprintf(b, "0x%03x 0x%04x 0x%04x 0x%04x\n", addr,
				            read_radio_reg(pi, addr | JTAG_2059_CR0),
				            read_radio_reg(pi, addr | JTAG_2059_CR1),
				            read_radio_reg(pi, addr | JTAG_2059_CR2));
			} else if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) &&
				(jtag_core == JTAG_2069_ALL)) {
				bcm_bprintf(b, "0x%03x 0x%04x 0x%04x 0x%04x\n", addr,
				            read_radio_reg(pi, addr | JTAG_2069_CR0),
				            read_radio_reg(pi, addr | JTAG_2069_CR1),
				            read_radio_reg(pi, addr | JTAG_2069_CR2));
			} else {
				bcm_bprintf(b, "0x%03x 0x%04x\n", addr,
				            read_radio_reg(pi, addr | jtag_core));
			}
		}
#ifdef WLC_LOW_ONLY
		if (buf_length > BUF_MAX_LINE_RADIO)
		break;
		i++;
		buf_length++;
		(*offset)++;
#else
		i++;
#endif // endif
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2056_ID) {
		for (core_cnt = 0; core_cnt <= 1; core_cnt++) {
			if (core_cnt == 0) {
				jtag_core = RADIO_2056_TX0;
				name = "2056 TX0";
			} else {
				jtag_core = RADIO_2056_TX1;
				name = "2056 TX1";
			}

			i = 0;
			while (TRUE) {
				if (radioregs_tx) {
					/* omit spare and radio ID */
					addr = radioregs_tx[i].address;
				} else {
				    ASSERT(regs != NULL);
					addr = regs[i];
				}

				if (addr == 0xffff)
					break;

				if (name_on)
					bcm_bprintf(b, "%s: 0x%03x 0x%04x\n", name, addr,
					            read_radio_reg(pi, addr | jtag_core));
				else
					bcm_bprintf(b, "0x%03x 0x%04x\n", addr,
					            read_radio_reg(pi, addr | jtag_core));
				i++;
			}
		}
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2056_ID) {
		for (core_cnt = 0; core_cnt <= 1; core_cnt++) {
			if (core_cnt == 0) {
				jtag_core = RADIO_2056_RX0;
				name = "2056 RX0";
			} else {
				jtag_core = RADIO_2056_RX1;
				name = "2056 RX1";
			}

			i = 0;
			while (TRUE) {
				if (radioregs_rx) {
					/* omit spare and radio ID */
					addr = radioregs_rx[i].address;
				} else {
					addr = regs[i];
				}

				if (addr == 0xffff)
					break;

				if (name_on)
					bcm_bprintf(b, "%s: 0x%03x 0x%04x\n", name, addr,
					            read_radio_reg(pi, addr | jtag_core));
				else
					bcm_bprintf(b, "0x%03x 0x%04x\n", addr,
					            read_radio_reg(pi, addr | jtag_core));
				i++;
			}
		}
	}
}
#endif /* BCMDBG || BCMDBG_DUMP */
#endif // endif

/* Do the initial table address write given the phy specific table access register
 * locations, the table ID and offset to start read/write operations
 */
void
wlc_phy_table_addr(phy_info_t *pi, uint tbl_id, uint tbl_offset,
                   uint16 tblAddr, uint16 tblDataHi, uint16 tblDataLo)
{
	PHY_TRACE(("wl%d: %s ID %u offset %u\n", pi->sh->unit, __FUNCTION__, tbl_id, tbl_offset));

	phy_reg_write(pi, tblAddr, (tbl_id << 10) | tbl_offset);

	pi->tbl_data_hi = tblDataHi;
	pi->tbl_data_lo = tblDataLo;

	/* PR68864 WAR, 43224 B0 requires a dummy read.
	 * 43421 suffers the same problem
	 * Remember the addr and offset for subsequent data writes
	 */
	if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
	     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
	    (pi->sh->chiprev == 1)) {
		pi->tbl_addr = tblAddr;
		pi->tbl_save_id = tbl_id;
		pi->tbl_save_offset = tbl_offset;
	}
}

/* Write the given value to the phy table which has been set up with an earlier call
 * to wlc_phy_table_addr()
 */
void
wlc_phy_table_data_write(phy_info_t *pi, uint width, uint32 val)
{
	ASSERT((width == 8) || (width == 16) || (width == 32));

	PHY_TRACE(("wl%d: %s width %u val %u\n", pi->sh->unit, __FUNCTION__, width, val));

	if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
	     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
	    (pi->sh->chiprev == 1) &&
	    (pi->tbl_save_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {
		phy_reg_read(pi, pi->tbl_data_lo);
		/* roll back the address from the dummy read */
		phy_reg_write(pi, pi->tbl_addr, (pi->tbl_save_id << 10) | pi->tbl_save_offset);
		pi->tbl_save_offset++;
	}

	if (width == 32) {
		/* width is 32-bit */
		phy_reg_write(pi, pi->tbl_data_hi, (uint16)(val >> 16));
		phy_reg_write(pi, pi->tbl_data_lo, (uint16)val);
	} else {
		/* width is 16-bit or 8-bit */
		phy_reg_write(pi, pi->tbl_data_lo, (uint16)val);
	}
}

/* Takes the table name, list of entries, offset to load the table,
 * see xxxphyprocs.tcl, proc xxxphy_write_table
 */
void
wlc_phy_write_table(phy_info_t *pi, const phytbl_info_t *ptbl_info, uint16 tblAddr,
	uint16 tblDataHi, uint16 tblDataLo)
{
	uint    idx;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint	tbl_width = ptbl_info->tbl_width;
	const uint8  *ptbl_8b    = (const uint8  *)ptbl_info->tbl_ptr;
	const uint16 *ptbl_16b   = (const uint16 *)ptbl_info->tbl_ptr;
	const uint32 *ptbl_32b   = (const uint32 *)ptbl_info->tbl_ptr;

	ASSERT((tbl_width == 8) || (tbl_width == 16) ||
		(tbl_width == 32));

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	phy_reg_write(pi, tblAddr, (tbl_id << 10) | tbl_offset);

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {

		/* PR68864 WAR, 43224 B0 requires a dummy read
		 * 43421 suffers the same problem
		 */
		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
		     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
		    (pi->sh->chiprev == 1) &&
		    (tbl_id == NPHY_TBL_ID_ANTSWCTRLLUT)) {
			phy_reg_read(pi, tblDataLo);
			/* roll back the address from the dummy read */
			phy_reg_write(pi, tblAddr, (tbl_id << 10) | (tbl_offset + idx));
		}

		if (tbl_width == 32) {
			/* width is 32-bit */
			phy_reg_write(pi, tblDataHi, (uint16)(ptbl_32b[idx] >> 16));
			phy_reg_write(pi, tblDataLo, (uint16)ptbl_32b[idx]);
		} else if (tbl_width == 16) {
			/* width is 16-bit */
			phy_reg_write(pi, tblDataLo, ptbl_16b[idx]);
		} else {
			/* width is 8-bit */
			phy_reg_write(pi, tblDataLo, ptbl_8b[idx]);
		}
	}
}

void
wlc_phy_read_table(phy_info_t *pi, const phytbl_info_t *ptbl_info, uint16 tblAddr,
	uint16 tblDataHi, uint16 tblDataLo)
{
	uint    idx;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint	tbl_width = ptbl_info->tbl_width;
	uint8  *ptbl_8b    = (uint8  *)(uintptr)ptbl_info->tbl_ptr;
	uint16 *ptbl_16b   = (uint16 *)(uintptr)ptbl_info->tbl_ptr;
	uint32 *ptbl_32b   = (uint32 *)(uintptr)ptbl_info->tbl_ptr;

	ASSERT((tbl_width == 8) || (tbl_width == 16) ||
		(tbl_width == 32));

	phy_reg_write(pi, tblAddr, (tbl_id << 10) | tbl_offset);

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {

		/* PR68864 WAR, 43224 B0 requires a dummy read
		 * 43421 suffers the same problem
		 */
		if ((CHIPID(pi->sh->chip) == BCM43224_CHIP_ID ||
		     CHIPID(pi->sh->chip) == BCM43421_CHIP_ID) &&
		    (pi->sh->chiprev == 1)) {
			(void)phy_reg_read(pi, tblDataLo);
			/* roll back the address from the dummy read */
			phy_reg_write(pi, tblAddr, (tbl_id << 10) | (tbl_offset + idx));
		}

		if (tbl_width == 32) {
			/* width is 32-bit */
			ptbl_32b[idx]  =  phy_reg_read(pi, tblDataLo);
			ptbl_32b[idx] |= (phy_reg_read(pi, tblDataHi) << 16);
		} else if (tbl_width == 16) {
			/* width is 16-bit */
			ptbl_16b[idx]  =  phy_reg_read(pi, tblDataLo);
		} else {
			/* width is 8-bit */
			ptbl_8b[idx]   =  (uint8)phy_reg_read(pi, tblDataLo);
		}
	}
}

/* Extended table write feature introduced with ACPHY */
/* Takes the table name, list of entries, offset to load the table,
 * see xxxphyprocs.tcl, proc xxxphy_write_table
 */
void
wlc_phy_write_table_ext(phy_info_t *pi, const phytbl_info_t *ptbl_info, uint16 tblId,
    uint16 tblOffset, uint16 tblDataWide, uint16 tblDataHi, uint16 tblDataLo)
{
	uint    idx;
	uint 	idx48, idx60, word_idx;
	uint32  data32;
	uint16  data16;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint	tbl_width = ptbl_info->tbl_width;
	const uint8  *ptbl_8b    = (const uint8  *)ptbl_info->tbl_ptr;
	const uint16 *ptbl_16b   = (const uint16 *)ptbl_info->tbl_ptr;
	const uint32 *ptbl_32b   = (const uint32 *)ptbl_info->tbl_ptr;

	ASSERT((tbl_width == 8) || (tbl_width == 16) ||
		(tbl_width == 32) || (tbl_width == 48) || (tbl_width == 60));

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	phy_reg_write(pi, tblId, (uint16) tbl_id);
	phy_reg_write(pi, tblOffset, (uint16) tbl_offset);

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {
		switch (tbl_width) {
		case 60:
		case 64:
			/* width is 60/64 bits */

			/* Here the data is accessed with a 32-bit pointer. The lowest 32-bit word
			   is at the lowest memory address.

			   The assumption is that the data buffer passed in is (2 * tbl_len)
			   where tbl_len is the number of table entries to write
			*/
			idx60 = 2 * idx;
			for (word_idx = 0; word_idx < 2; word_idx++) {
				data32 = ptbl_32b[idx60+word_idx];

				data16 = (uint16) (data32 & 0xFFFF);
				if (word_idx == 0) {
					phy_reg_write(pi, tblDataWide, data16);
				} else {
					phy_reg_write_wide(pi, data16);
				}

				data16 = (uint16) ((data32 >> 16) & 0xFFFF);
				phy_reg_write_wide(pi, data16);
			}
			break;

		case 48:
			/* width is 48-bit */

			/* Here the data is accessed with a 16-bit pointer. The lowest 16-bit word
			   is at the lowest memory address.

			   The assumption is that the data buffer passed in is (3 * tbl_len)
			   where tbl_len is the number of table entries to write
			*/
			idx48 = 3 * idx;
			for (word_idx = 0; word_idx < 3; word_idx++) {
				if (word_idx == 0) {
					phy_reg_write(pi, tblDataWide,
					    (uint16)(ptbl_16b[idx48+word_idx]));
				} else {
					phy_reg_write_wide(pi,
					    (uint16)(ptbl_16b[idx48+word_idx]));
				}
			}
			break;

		case 32:
			/* width is 32-bit */
			phy_reg_write(pi, tblDataHi, (uint16)(ptbl_32b[idx] >> 16));
			phy_reg_write(pi, tblDataLo, (uint16)ptbl_32b[idx]);
			break;

		case 16:
			/* width is 16-bit */
			phy_reg_write(pi, tblDataLo, ptbl_16b[idx]);
			break;

		case 8:
			/* width is 8-bit */
			phy_reg_write(pi, tblDataLo, ptbl_8b[idx]);
		}
	}
}

/* Extended table read feature introduced with ACPHY */
void
wlc_phy_read_table_ext(phy_info_t *pi, const phytbl_info_t *ptbl_info, uint16 tblId,
    uint16 tblOffset, uint16 tblDataWide, uint16 tblDataHi, uint16 tblDataLo)
{
	uint    idx;
	uint 	idx48, idx60, word_idx;
	uint32  data32;
	uint16  data16, u16temp = 0;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint	tbl_width = ptbl_info->tbl_width;
	uint8  *ptbl_8b    = (uint8  *)(uintptr)ptbl_info->tbl_ptr;
	uint16 *ptbl_16b   = (uint16 *)(uintptr)ptbl_info->tbl_ptr;
	uint32 *ptbl_32b   = (uint32 *)(uintptr)ptbl_info->tbl_ptr;

	ASSERT((tbl_width == 8) || (tbl_width == 16) ||
		(tbl_width == 32) || (tbl_width == 48) || (tbl_width == 60));

	phy_reg_write(pi, tblId, (uint16) tbl_id);
	phy_reg_write(pi, tblOffset, (uint16) tbl_offset);

	if (tbl_id == 20) {
		if (ISACPHY(pi) &&
		    (ACREV_IS(pi->pubpi.phy_rev, 3) ||
		     (ACREV_GE(pi->pubpi.phy_rev, 6) && ACREV_LE(pi->pubpi.phy_rev, 11)) ||
		     (ACREV_GE(pi->pubpi.phy_rev, 13) && ACREV_LE(pi->pubpi.phy_rev, 15)) ||
		     ACREV_IS(pi->pubpi.phy_rev, 17) || ACREV_IS(pi->pubpi.phy_rev, 18))) {
			u16temp = phy_reg_read(pi, ACPHY_fineclockgatecontrol(pi->pubpi.phy_rev));
			phy_reg_mod(pi, ACPHY_fineclockgatecontrol(pi->pubpi.phy_rev),
				ACPHY_fineclockgatecontrol_forceRfSeqgatedClksOn_MASK
				(pi->pubpi.phy_rev),
				0x01 << ACPHY_fineclockgatecontrol_forceRfSeqgatedClksOn_SHIFT
				(pi->pubpi.phy_rev));
		}
	}

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {
		switch (tbl_width) {
		case 60:
		case 64:
			/* width is 60/64 bits */

			/* Here the data is accessed with a 32-bit pointer. The lowest 32-bit word
			   is at the lowest memory address.

			   The assumption is that the data buffer passed in is (2 * tbl_len)
			   where tbl_len is the number of table entries to write
			*/
			idx60 = 2 * idx;
			for (word_idx = 0; word_idx < 2; word_idx++) {
				if (word_idx == 0) {
					data16 = phy_reg_read(pi, tblDataWide);
				} else {
					data16 = phy_reg_read_wide(pi);
				}
				data32 = (uint32) phy_reg_read_wide(pi);

				data32 = (data32 << 16) | (uint32)data16;

				ptbl_32b[idx60+word_idx] = data32;
			}

			break;

		case 48:
			/* width is 48-bit */

			/* Here the data is accessed with a 16-bit pointer. The lowest 16-bit word
			   is at the lowest memory address.

			   The assumption is that the data buffer passed in is (3 * tbl_len)
			   where tbl_len is the number of table entries to read
			*/
			idx48 = 3 * idx;
			for (word_idx = 0; word_idx < 3; word_idx++) {
				if (word_idx == 0) {
					ptbl_16b[idx48+word_idx] = phy_reg_read(pi, tblDataWide);
				} else {
					ptbl_16b[idx48+word_idx] = phy_reg_read_wide(pi);
				}
			}
			break;

		case 32:
			/* width is 32-bit */
			ptbl_32b[idx]  =  phy_reg_read(pi, tblDataLo);
			ptbl_32b[idx] |= (phy_reg_read(pi, tblDataHi) << 16);
			break;

		case 16:
			/* width is 16-bit */
			ptbl_16b[idx]  =  phy_reg_read(pi, tblDataLo);
			break;

		case 8:
			/* width is 8-bit */
			ptbl_8b[idx]   =  (uint8)phy_reg_read(pi, tblDataLo);
		}
	}
	if (tbl_id == 20) {
		if (ISACPHY(pi) &&
		    (ACREV_IS(pi->pubpi.phy_rev, 3) ||
		     (ACREV_GE(pi->pubpi.phy_rev, 6) && ACREV_LE(pi->pubpi.phy_rev, 11)) ||
		     (ACREV_GE(pi->pubpi.phy_rev, 13) && ACREV_LE(pi->pubpi.phy_rev, 15)) ||
		     ACREV_IS(pi->pubpi.phy_rev, 17) || ACREV_IS(pi->pubpi.phy_rev, 18))) {
			phy_reg_write(pi, ACPHY_fineclockgatecontrol(pi->pubpi.phy_rev), u16temp);
		}
	}
}

void
wlc_phy_common_read_table(phy_info_t *pi, uint32 tbl_id,
	const void *tbl_ptr, uint32 tbl_len, uint32 tbl_width,
	uint32 tbl_offset,
	void (*tbl_rfunc)(phy_info_t *, phytbl_info_t *))
{
	phytbl_info_t tab;
	tab.tbl_id = tbl_id;
	tab.tbl_ptr = tbl_ptr;	/* ptr to buf */
	tab.tbl_len = tbl_len;			/* # values   */
	tab.tbl_width = tbl_width;			/* gain_val_tbl_rev3 */
	tab.tbl_offset = tbl_offset;		/* tbl offset */
	tbl_rfunc(pi, &tab);
}

void
wlc_phy_common_write_table(phy_info_t *pi, uint32 tbl_id, const void *tbl_ptr,
	uint32 tbl_len, uint32 tbl_width, uint32 tbl_offset,
	void (*tbl_wfunc)(phy_info_t *, const phytbl_info_t *))
{

	phytbl_info_t tab;
	tab.tbl_id = tbl_id;
	tab.tbl_ptr = tbl_ptr;	/* ptr to buf */
	tab.tbl_len = tbl_len;			/* # values   */
	tab.tbl_width = tbl_width;			/* gain_val_tbl_rev3 */
	tab.tbl_offset = tbl_offset;		/* tbl offset */
	tbl_wfunc(pi, &tab);
}
/* Takes the table name, list of entries, offset to load the table,
 * see xxxphyprocs.tcl, proc xxxphy_write_table
 */
void
wlc_phy_table_write_lpphy(phy_info_t *pi, const lpphytbl_info_t *ptbl_info)
{
	uint    idx;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint32	u32temp;

	const uint8  *ptbl_8b    = (const uint8  *)ptbl_info->tbl_ptr;
	const uint16 *ptbl_16b   = (const uint16 *)ptbl_info->tbl_ptr;
	const uint32 *ptbl_32b   = (const uint32 *)ptbl_info->tbl_ptr;

	uint16 tblAddr = LPPHY_TableAddress;
	uint16 tblDataHi = LPPHY_TabledataHi;
	uint16 tblDatalo = LPPHY_TabledataLo;

	ASSERT((ptbl_info->tbl_phywidth == 8) || (ptbl_info->tbl_phywidth == 16) ||
		(ptbl_info->tbl_phywidth == 32));
	ASSERT((ptbl_info->tbl_width == 8) || (ptbl_info->tbl_width == 16) ||
		(ptbl_info->tbl_width == 32));

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	wlc_phy_table_lock_lpphy(pi);

	phy_reg_write(pi, tblAddr, (tbl_id << 10) | tbl_offset);

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {

		/* get the element from the table according to the table width */
		if (ptbl_info->tbl_width == 32) {
			/* tbl width is 32 bit */
			u32temp = (uint32)ptbl_32b[idx];
		} else if (ptbl_info->tbl_width == 16) {
			/* tbl width is 16 bit */
			u32temp = (uint32)ptbl_16b[idx];
		} else {
			/* tbl width is 8 bit */
			u32temp = (uint32)ptbl_8b[idx];
		}

		/* write the element into the phy table according phy address space width */
		if (ptbl_info->tbl_phywidth == 32) {
			/* phy width is 32-bit */
			phy_reg_write(pi, tblDataHi, (u32temp >> 16) & 0xffff);
			phy_reg_write(pi, tblDatalo, u32temp & 0xffff);
		} else if (ptbl_info->tbl_phywidth == 16) {
			/* phy width is 16-bit */
			phy_reg_write(pi, tblDatalo, u32temp & 0xffff);
		} else {
			/* phy width is 8-bit */
			phy_reg_write(pi, tblDatalo, u32temp & 0xffff);
		}
	}
	wlc_phy_table_unlock_lpphy(pi);
}

void
wlc_phy_table_read_lpphy(phy_info_t *pi, const lpphytbl_info_t *ptbl_info)
{
	uint    idx;
	uint    tbl_id     = ptbl_info->tbl_id;
	uint    tbl_offset = ptbl_info->tbl_offset;
	uint32  u32temp;

	uint8  *ptbl_8b    = (uint8  *)(uintptr)ptbl_info->tbl_ptr;
	uint16 *ptbl_16b   = (uint16 *)(uintptr)ptbl_info->tbl_ptr;
	uint32 *ptbl_32b   = (uint32 *)(uintptr)ptbl_info->tbl_ptr;

	uint16 tblAddr = LPPHY_TableAddress;
	uint16 tblDataHi = LPPHY_TabledataHi;
	uint16 tblDatalo = LPPHY_TabledataLo;

	ASSERT((ptbl_info->tbl_phywidth == 8) || (ptbl_info->tbl_phywidth == 16) ||
		(ptbl_info->tbl_phywidth == 32));
	ASSERT((ptbl_info->tbl_width == 8) || (ptbl_info->tbl_width == 16) ||
		(ptbl_info->tbl_width == 32));

	wlc_phy_table_lock_lpphy(pi);

	phy_reg_write(pi, tblAddr, (tbl_id << 10) | tbl_offset);

	for (idx = 0; idx < ptbl_info->tbl_len; idx++) {

		/* get the element from phy according to the phy table element
		 * address space width
		 */
		if (ptbl_info->tbl_phywidth == 32) {
			/* phy width is 32-bit */
			u32temp  =  phy_reg_read(pi, tblDatalo);
			u32temp |= (phy_reg_read(pi, tblDataHi) << 16);
		} else if (ptbl_info->tbl_phywidth == 16) {
			/* phy width is 16-bit */
			u32temp  =  phy_reg_read(pi, tblDatalo);
		} else {
			/* phy width is 8-bit */
			u32temp   =  (uint8)phy_reg_read(pi, tblDatalo);
		}

		/* put the element into the table according to the table element width
		 * Note that phy table width is some times more than necessary while
		 * table width is always optimal.
		 */
		if (ptbl_info->tbl_width == 32) {
			/* tbl width is 32-bit */
			ptbl_32b[idx]  =  u32temp;
		} else if (ptbl_info->tbl_width == 16) {
			/* tbl width is 16-bit */
			ptbl_16b[idx]  =  (uint16)u32temp;
		} else {
			/* tbl width is 8-bit */
			ptbl_8b[idx]   =  (uint8)u32temp;
		}
	}
	wlc_phy_table_unlock_lpphy(pi);
}

/* prevent simultaneous phy table access by driver and ucode */
void
wlc_phy_table_lock_lpphy(phy_info_t *pi)
{
	uint32 mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);

	if (mc & MCTL_EN_MAC) {
		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
		OSL_DELAY(5);
	}
}

void
wlc_phy_table_unlock_lpphy(phy_info_t *pi)
{
	wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);
}

uint
wlc_phy_init_radio_regs_allbands(phy_info_t *pi, radio_20xx_regs_t *radioregs)
{
	uint i = 0;

	do {
		if (radioregs[i].do_init) {
			write_radio_reg(pi, radioregs[i].address,
			                (uint16)radioregs[i].init);
		}

		i++;
	} while (radioregs[i].address != 0xffff);

	return i;
}
uint
wlc_phy_init_radio_regs_allbands_20671(phy_info_t *pi, radio_20671_regs_t *radioregs)
{
	uint i = 0;

	do {
		if (radioregs[i].do_init) {
			write_radio_reg(pi, radioregs[i].address,
			                (uint16)radioregs[i].init);
		}

		i++;
	} while (radioregs[i].address != 0xffff);

	return i;
}
uint
wlc_phy_init_radio_prefregs_allbands(phy_info_t *pi, radio_20xx_prefregs_t *radioregs)
{
	uint i = 0;

	do {
		write_radio_reg(pi, radioregs[i].address,
		                (uint16)radioregs[i].init);

		i++;
	} while (radioregs[i].address != 0xffff);

	return i;
}

uint
wlc_phy_init_radio_regs(phy_info_t *pi, radio_regs_t *radioregs, uint16 core_offset)
{
	uint i = 0;
	uint count = 0;

	do {
#ifdef BAND5G
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (radioregs[i].do_init_a) {
				write_radio_reg(pi, radioregs[i].address | core_offset,
					(uint16)radioregs[i].init_a);
				if (ISNPHY(pi) && (++count % 4 == 0))
					WLC_PHY_WAR_PR51571(pi);
			}
		} else
#endif /* BAND5G */
		{
			if (radioregs[i].do_init_g) {
				write_radio_reg(pi, radioregs[i].address | core_offset,
					(uint16)radioregs[i].init_g);
				if (ISNPHY(pi) && (++count % 4 == 0))
					WLC_PHY_WAR_PR51571(pi);
			}
		}

		i++;
	} while (radioregs[i].address != 0xffff);

	return i;
}

void
wlc_phy_do_dummy_tx(phy_info_t *pi, bool ofdm, bool pa_on)
{
#define	DUMMY_PKT_LEN	20 /* Dummy packet's length */
	d11regs_t *regs = pi->regs;
	int	i, count;
	uint8	ofdmpkt[DUMMY_PKT_LEN] = {
		0xcc, 0x01, 0x02, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
	};
	uint8	cckpkt[DUMMY_PKT_LEN] = {
		0x6e, 0x84, 0x0b, 0x00, 0x00, 0x00, 0xd4, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
	};
	uint32 *dummypkt;

	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);

	dummypkt = (uint32 *)(ofdm ? ofdmpkt : cckpkt);
	wlapi_bmac_write_template_ram(pi->sh->physhim, 0, DUMMY_PKT_LEN, dummypkt);

	/* set up the TXE transfer */

	W_REG(pi->sh->osh, &regs->PHYREF_XMTSEL, 0);
	/* Assign the WEP to the transmit path */
	if (D11REV_GE(pi->sh->corerev, 11))
		W_REG(pi->sh->osh, &regs->PHYREF_WEPCTL, 0x100);
	else
		W_REG(pi->sh->osh, &regs->PHYREF_WEPCTL, 0);

	/* Set/clear OFDM bit in PHY control word */
	W_REG(pi->sh->osh, &regs->txe_phyctl, (ofdm ? 1 : 0) | PHY_TXC_ANT_0);
	if (ISNPHY(pi) || ISHTPHY(pi) || ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
		ASSERT(ofdm);
		W_REG(pi->sh->osh, &regs->txe_phyctl1, 0x1A02);
	}

	W_REG(pi->sh->osh, &regs->txe_wm_0, 0);		/* No substitutions */
	W_REG(pi->sh->osh, &regs->txe_wm_1, 0);

	/* Set transmission from the TEMPLATE where we loaded the frame */
	if (D11REV_IS(pi->sh->corerev, 35)) {
		/* XXX PR 103560: For 4334Bx only
		 * XXX    Template region not
		 * XXX    preserved during save/restore
		 */
		W_REG(pi->sh->osh, &regs->PHYREF_XMTTPLATETXPTR, PHY_TXFIFO_END_BLK_REV35);
	} else
		W_REG(pi->sh->osh, &regs->PHYREF_XMTTPLATETXPTR, 0);
	W_REG(pi->sh->osh, &regs->PHYREF_XMTTXCNT, DUMMY_PKT_LEN);

	/* Set Template as source, length specified as a count and destination
	 * as Serializer also set "gen_eof"
	 */
	W_REG(pi->sh->osh, &regs->PHYREF_XMTSEL, ((8 << 8) | (1 << 5) | (1 << 2) | 2));

	/* Instruct the MAC to not calculate FCS, we'll supply a bogus one */
	W_REG(pi->sh->osh, &regs->txe_ctl, 0);

	if (!pa_on) {
		if (ISNPHY(pi))
			wlc_phy_pa_override_nphy(pi, OFF);
		else if (ISHTPHY(pi)) {
			wlc_phy_pa_override_htphy(pi, OFF);
		}
	}

	/* Start transmission and wait until sendframe goes away */
	/* Set TX_NOW in AUX along with MK_CTLWRD */
	if (ISNPHY(pi) || ISHTPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi))
		W_REG(pi->sh->osh, &regs->txe_aux, 0xD0);
	else if (ISLPPHY(pi))
		W_REG(pi->sh->osh, &regs->txe_aux, ((1 << 6) | (1 << 4)));
	else
		W_REG(pi->sh->osh, &regs->txe_aux, ((1 << 5) | (1 << 4)));

	(void)R_REG(pi->sh->osh, &regs->txe_aux);

	/* Wait for 10 x ack time, enlarge it for vsim of QT */
	i = 0;
	count = ofdm ? 30 : 250;

#ifndef BCMQT_CPU
	if (ISSIM_ENAB(pi->sh->sih)) {
		count *= 100;
	}
#endif // endif
	/* wait for txframe to be zero */
	while ((i++ < count) && (R_REG(pi->sh->osh, &regs->txe_status) & (1 << 7))) {
		OSL_DELAY(10);
	}
	if (i >= count)
		PHY_ERROR(("wl%d: %s: Waited %d uS for %s txframe\n",
		          pi->sh->unit, __FUNCTION__, 10 * i, (ofdm ? "ofdm" : "cck")));

	/* Wait for the mac to finish (this is 10x what is supposed to take) */
	i = 0;
	/* wait for txemend */
	while ((i++ < 10) && ((R_REG(pi->sh->osh, &regs->txe_status) & (1 << 10)) == 0)) {
		OSL_DELAY(10);
	}
	if (i >= 10)
		PHY_ERROR(("wl%d: %s: Waited %d uS for txemend\n",
		          pi->sh->unit, __FUNCTION__, 10 * i));

	/* Wait for the phy to finish */
	i = 0;
	/* wait for txcrs */
	while ((i++ < 500) && ((R_REG(pi->sh->osh, &regs->PHYREF_IFSSTAT) & (1 << 8)))) {
		OSL_DELAY(10);
	}
	if (i >= 500)
		PHY_ERROR(("wl%d: %s: Waited %d uS for txcrs\n",
		          pi->sh->unit, __FUNCTION__, 10 * i));
	if (!pa_on) {
		if (ISNPHY(pi))
			wlc_phy_pa_override_nphy(pi, ON);
		else if (ISHTPHY(pi)) {
			wlc_phy_pa_override_htphy(pi, ON);
		}
	}
}

static void
wlc_phy_scanroam_cache_cal(phy_info_t *pi, bool set)
{
	if (ISHTPHY(pi)) {
		wlc_phy_scanroam_cache_cal_htphy(pi, set);
	}
#if !defined(PHYCAL_CACHING) && !defined(WLMCHAN)
	else if (ISACPHY(pi)) {
		wlc_phy_scanroam_cache_cal_acphy(pi, set);
	}
#endif /* !defined(PHYCAL_CACHING) && !defined(WLMCHAN) */
}

void
wlc_phy_hold_upd(wlc_phy_t *pih, mbool id, bool set)
{
	phy_info_t *pi = (phy_info_t *)pih;
	ASSERT(id);
#ifdef WLPHYACICACHE
	ch_acicache_t *aci_ctx;
#endif // endif

	PHY_TRACE(("%s: id %d val %d old pi->measure_hold 0%x\n", __FUNCTION__, id, set,
		pi->measure_hold));

	PHY_CAL(("wl%d: %s: %s %s flag\n", pi->sh->unit, __FUNCTION__,
		set ? "SET" : "CLR",
		(id == PHY_HOLD_FOR_ASSOC) ? "ASSOC" :
		((id == PHY_HOLD_FOR_SCAN) ? "SCAN" :
		((id == PHY_HOLD_FOR_SCAN) ? "SCAN" :
		((id == PHY_HOLD_FOR_RM) ? "RM" :
		((id == PHY_HOLD_FOR_PLT) ? "PLT" :
		((id == PHY_HOLD_FOR_MUTE) ? "MUTE" :
		((id == PHY_HOLD_FOR_PKT_ENG) ? "PKTENG" :
		((id == PHY_HOLD_FOR_TOF) ? "TOF" :
		((id == PHY_HOLD_FOR_NOT_ASSOC) ? "NOT-ASSOC" : ""))))))))));

	if (set) {
		mboolset(pi->measure_hold, id);
	} else {
		mboolclr(pi->measure_hold, id);
	}
	if (id & PHY_HOLD_FOR_SCAN) {
		if (ISACPHY(pi)) {
			/* If scanning dont cache values only cache during cals */
			if (!set)
				wlc_phy_scanroam_cache_cal(pi, set);
			/* Dont change behavior for other PHYs */
		} else {
			wlc_phy_scanroam_cache_cal(pi, set);
		}
	}

#ifdef WLPHYACICACHE
	/* Update this info in the aci_context as well */
	aci_ctx = wlc_phy_get_aci_chanctx(pi, pi->radio_chanspec);
	if (aci_ctx)
		aci_ctx->isassoc = !mboolisset(pi->measure_hold, PHY_HOLD_FOR_NOT_ASSOC);
#endif // endif
	return;
}

bool
wlc_phy_ismuted(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	return PHY_MUTED(pi);
}

void
wlc_phy_mute_upd(wlc_phy_t *pih, bool mute, mbool flags)
{
	phy_info_t *pi = (phy_info_t *)pih;

	PHY_TRACE(("wlc_phy_mute_upd: flags 0x%x mute %d\n", flags, mute));

	if (mute) {
		mboolset(pi->measure_hold, PHY_HOLD_FOR_MUTE);
	} else {
		mboolclr(pi->measure_hold, PHY_HOLD_FOR_MUTE);
	}

	/* check if need to schedule a phy cal */
	if (!mute && (flags & PHY_MUTE_FOR_PREISM)) {
		pi->cal_info->last_cal_time = (pi->sh->now > pi->sh->glacial_timer) ?
			(pi->sh->now - pi->sh->glacial_timer) : 0;
	}
	return;
}

void
wlc_phy_clear_tssi(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		/* NPHY/HTPHY doesn't use sw or ucode powercontrol */
		return;
	} else if (ISAPHY(pi)) {
		wlapi_bmac_write_shm(pi->sh->physhim, M_A_TSSI_0, NULL_TSSI_W);
		wlapi_bmac_write_shm(pi->sh->physhim, M_A_TSSI_1, NULL_TSSI_W);
	} else {
		wlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_0, NULL_TSSI_W);
		wlapi_bmac_write_shm(pi->sh->physhim, M_B_TSSI_1, NULL_TSSI_W);
		wlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_0, NULL_TSSI_W);
		wlapi_bmac_write_shm(pi->sh->physhim, M_G_TSSI_1, NULL_TSSI_W);
	}
}

static bool
wlc_phy_cal_txpower_recalc_sw(phy_info_t *pi)
{
	bool ret = TRUE;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* NPHY/HTPHY/ACPHY doesn't ever use SW power control */
	if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))
		return FALSE;

	if (ISSSLPNPHY(pi))
		return FALSE;
	if (ISLCNCOMMONPHY(pi))
		return FALSE;

	if (ISLPPHY(pi)) {
		/* Adjust number of packets for TSSI averaging */
		if (wlc_phy_tpc_isenabled_lpphy(pi)) {
			wlc_phy_tx_pwr_update_npt_lpphy(pi);
		}
		return ret;
	}

	/* No need to do anything if the hw is doing pwrctrl for us */
	if (pi->hwpwrctrl) {

		/* Do nothing if radio pwr is being overridden */
		if (pi->radiopwr_override != RADIOPWR_OVERRIDE_DEF)
			return (ret);

		pi->hwpwr_txcur = wlapi_bmac_read_shm(pi->sh->physhim, M_TXPWR_CUR);
		return (ret);
	} else {
		if (ISABGPHY(pi))
			ret = wlc_phy_cal_txpower_recalc_sw_abgphy(pi);
	}

	return (ret);
}

void
wlc_phy_switch_radio(wlc_phy_t *pih, bool on)
{
	phy_info_t *pi = (phy_info_t *)pih;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));
	{
		uint mc;

		mc = R_REG(pi->sh->osh, &pi->regs->maccontrol);
		if (mc & MCTL_EN_MAC) {
			PHY_ERROR(("wl%d: %s: maccontrol 0x%x has EN_MAC set\n",
			          pi->sh->unit, __FUNCTION__, mc));
		}
	}

	if (!on) {
		wlapi_update_bt_chanspec(pi->sh->physhim, 0,
			SCAN_INPROG_PHY(pi), RM_INPROG_PHY(pi));
	}
	else {
		wlapi_update_bt_chanspec(pi->sh->physhim, pi->radio_chanspec,
			SCAN_INPROG_PHY(pi), RM_INPROG_PHY(pi));
	}

	if (ISNPHY(pi)) {
		wlc_phy_switch_radio_nphy(pi, on);
	} else if (ISHTPHY(pi)) {
		wlc_phy_switch_radio_htphy(pi, on);
	} else if (ISACPHY(pi)) {
		wlc_phy_switch_radio_acphy(pi, on);
	} else if (ISLPPHY(pi)) {
		if (on) {
			if (LPREV_GE(pi->pubpi.phy_rev, 2)) {
				PHY_REG_LIST_START
					PHY_REG_AND_ENTRY(LPPHY_REV2, RFOverride0,
						~(LPPHY_REV2_RFOverride0_rfpll_pu_ovr_MASK 	|
						LPPHY_REV2_RFOverride0_wrssi_pu_ovr_MASK 	|
						LPPHY_REV2_RFOverride0_nrssi_pu_ovr_MASK 	|
						LPPHY_REV2_RFOverride0_internalrfrxpu_ovr_MASK 	|
						LPPHY_REV2_RFOverride0_internalrftxpu_ovr_MASK))
					PHY_REG_AND_ENTRY(LPPHY_REV2, rfoverride2,
						~(LPPHY_REV2_rfoverride2_lna_pu_ovr_MASK |
						LPPHY_REV2_rfoverride2_slna_pu_ovr_MASK))
					PHY_REG_AND_ENTRY(LPPHY_REV2, rfoverride3,
						~LPPHY_REV2_rfoverride3_rfactive_ovr_MASK)
				PHY_REG_LIST_EXECUTE(pi);
			} else {
				PHY_REG_LIST_START
					PHY_REG_AND_ENTRY(LPPHY, RFOverride0,
						~(LPPHY_RFOverride0_rfpll_pu_ovr_MASK 		|
						LPPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
						LPPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
						LPPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
						LPPHY_RFOverride0_internalrftxpu_ovr_MASK))
					PHY_REG_AND_ENTRY(LPPHY, rfoverride2,
						~(LPPHY_rfoverride2_lna1_pu_ovr_MASK |
						LPPHY_rfoverride2_lna2_pu_ovr_MASK))
				PHY_REG_LIST_EXECUTE(pi);
			}
			pi->radio_is_on = TRUE;
		} else {
			if (LPREV_GE(pi->pubpi.phy_rev, 2)) {
				PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(LPPHY_REV2, RFOverrideVal0,
					~(LPPHY_REV2_RFOverrideVal0_rfpll_pu_ovr_val_MASK |
					LPPHY_REV2_RFOverrideVal0_wrssi_pu_ovr_val_MASK 	|
					LPPHY_REV2_RFOverrideVal0_nrssi_pu_ovr_val_MASK 	|
					LPPHY_REV2_RFOverrideVal0_internalrfrxpu_ovr_val_MASK 	|
					LPPHY_REV2_RFOverrideVal0_internalrftxpu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LPPHY_REV2, RFOverride0,
					LPPHY_REV2_RFOverride0_rfpll_pu_ovr_MASK 		|
					LPPHY_REV2_RFOverride0_wrssi_pu_ovr_MASK 		|
					LPPHY_REV2_RFOverride0_nrssi_pu_ovr_MASK 		|
					LPPHY_REV2_RFOverride0_internalrfrxpu_ovr_MASK 	|
					LPPHY_REV2_RFOverride0_internalrftxpu_ovr_MASK)
				PHY_REG_AND_ENTRY(LPPHY_REV2, rxlnaandgainctrl1ovrval,
					~(LPPHY_REV2_rxlnaandgainctrl1ovrval_lnapuovr_Val_MASK))
				PHY_REG_AND_ENTRY(LPPHY_REV2, rfoverride2val,
					~(LPPHY_REV2_rfoverride2val_slna_pu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LPPHY_REV2, rfoverride2,
					LPPHY_REV2_rfoverride2_lna_pu_ovr_MASK |
					LPPHY_REV2_rfoverride2_slna_pu_ovr_MASK)
				PHY_REG_AND_ENTRY(LPPHY_REV2, rfoverride3_val,
					~(LPPHY_REV2_rfoverride3_val_rfactive_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LPPHY_REV2, rfoverride3,
					LPPHY_REV2_rfoverride3_rfactive_ovr_MASK)
				PHY_REG_LIST_EXECUTE(pi);
			} else {
				PHY_REG_LIST_START
					PHY_REG_AND_ENTRY(LPPHY, RFOverrideVal0,
						~(LPPHY_RFOverrideVal0_rfpll_pu_ovr_val_MASK	 |
						LPPHY_RFOverrideVal0_wrssi_pu_ovr_val_MASK	 |
						LPPHY_RFOverrideVal0_nrssi_pu_ovr_val_MASK	 |
						LPPHY_RFOverrideVal0_internalrfrxpu_ovr_val_MASK |
						LPPHY_RFOverrideVal0_internalrftxpu_ovr_val_MASK))
					PHY_REG_OR_ENTRY(LPPHY, RFOverride0,
						LPPHY_RFOverride0_rfpll_pu_ovr_MASK 		|
						LPPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
						LPPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
						LPPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
						LPPHY_RFOverride0_internalrftxpu_ovr_MASK)
					PHY_REG_AND_ENTRY(LPPHY, rfoverride2val,
						~(LPPHY_rfoverride2val_lna1_pu_ovr_val_MASK |
						LPPHY_rfoverride2val_lna2_pu_ovr_val_MASK))
					PHY_REG_OR_ENTRY(LPPHY, rfoverride2,
						LPPHY_rfoverride2_lna1_pu_ovr_MASK |
						LPPHY_rfoverride2_lna2_pu_ovr_MASK)
				PHY_REG_LIST_EXECUTE(pi);
			}
			pi->radio_is_on = FALSE;
		}
	} else if (ISSSLPNPHY(pi)) {
		if (on) {
			PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(SSLPNPHY, RFOverride0,
					~(SSLPNPHY_RFOverride0_rfpll_pu_ovr_MASK	|
					SSLPNPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
					SSLPNPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
					SSLPNPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
					SSLPNPHY_RFOverride0_internalrftxpu_ovr_MASK))
				PHY_REG_AND_ENTRY(SSLPNPHY, rfoverride2,
					~(SSLPNPHY_rfoverride2_lna_pu_ovr_MASK |
					SSLPNPHY_rfoverride2_slna_pu_ovr_MASK))
			PHY_REG_LIST_EXECUTE(pi);

			if (wlapi_is_eci_coex_enabled(pi->sh->physhim))
				phy_reg_and(pi, SSLPNPHY_rfoverride3,
					~SSLPNPHY_rfoverride3_rfactive_ovr_MASK);
		} else {
			PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(SSLPNPHY, RFOverrideVal0,
					~(SSLPNPHY_RFOverrideVal0_rfpll_pu_ovr_val_MASK |
					SSLPNPHY_RFOverrideVal0_wrssi_pu_ovr_val_MASK 	|
					SSLPNPHY_RFOverrideVal0_nrssi_pu_ovr_val_MASK 	|
					SSLPNPHY_RFOverrideVal0_internalrfrxpu_ovr_val_MASK |
					SSLPNPHY_RFOverrideVal0_internalrftxpu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(SSLPNPHY, RFOverride0,
					SSLPNPHY_RFOverride0_rfpll_pu_ovr_MASK 		|
					SSLPNPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
					SSLPNPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
					SSLPNPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
					SSLPNPHY_RFOverride0_internalrftxpu_ovr_MASK)

				PHY_REG_AND_ENTRY(SSLPNPHY, rxlnaandgainctrl1ovrval,
					~(SSLPNPHY_rxlnaandgainctrl1ovrval_lnapuovr_Val_MASK))
				PHY_REG_AND_ENTRY(SSLPNPHY, rfoverride2val,
					~(SSLPNPHY_rfoverride2val_slna_pu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(SSLPNPHY, rfoverride2,
					SSLPNPHY_rfoverride2_lna_pu_ovr_MASK |
					SSLPNPHY_rfoverride2_slna_pu_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);

			if (wlapi_is_eci_coex_enabled(pi->sh->physhim)) {
				phy_reg_and(pi, SSLPNPHY_rfoverride3_val,
					~(SSLPNPHY_rfoverride3_val_rfactive_ovr_val_MASK));
			} else {
				phy_reg_or(pi, SSLPNPHY_rfoverride3_val,
					SSLPNPHY_rfoverride3_val_rfactive_ovr_val_MASK);
			}
			phy_reg_or(pi, SSLPNPHY_rfoverride3,
				SSLPNPHY_rfoverride3_rfactive_ovr_MASK);
		}
	} else if (ISLCNPHY(pi)) {
		if (on) {
			PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(LCNPHY, RFOverride0,
					~(LCNPHY_RFOverride0_rfpll_pu_ovr_MASK	|
					LCNPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
					LCNPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
					LCNPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
					LCNPHY_RFOverride0_internalrftxpu_ovr_MASK))
				PHY_REG_AND_ENTRY(LCNPHY, rfoverride2,
					~(LCNPHY_rfoverride2_lna_pu_ovr_MASK |
					LCNPHY_rfoverride2_slna_pu_ovr_MASK))
				PHY_REG_AND_ENTRY(LCNPHY, rfoverride3,
					~LCNPHY_rfoverride3_rfactive_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);
			if (pi->u.pi_lcnphy->lcnphy_spurmod == 1) {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(LCNPHY,
						spur_canceller1, ((1 << 13) + 23))
					PHY_REG_WRITE_ENTRY(LCNPHY,
						spur_canceller2, ((1 << 13) + 1989))
				PHY_REG_LIST_EXECUTE(pi);
			}
		} else {
			PHY_REG_LIST_START
				PHY_REG_AND_ENTRY(LCNPHY, RFOverrideVal0,
					~(LCNPHY_RFOverrideVal0_rfpll_pu_ovr_val_MASK |
					LCNPHY_RFOverrideVal0_wrssi_pu_ovr_val_MASK 	|
					LCNPHY_RFOverrideVal0_nrssi_pu_ovr_val_MASK 	|
					LCNPHY_RFOverrideVal0_internalrfrxpu_ovr_val_MASK |
					LCNPHY_RFOverrideVal0_internalrftxpu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LCNPHY, RFOverride0,
					LCNPHY_RFOverride0_rfpll_pu_ovr_MASK 		|
					LCNPHY_RFOverride0_wrssi_pu_ovr_MASK 		|
					LCNPHY_RFOverride0_nrssi_pu_ovr_MASK 		|
					LCNPHY_RFOverride0_internalrfrxpu_ovr_MASK 	|
					LCNPHY_RFOverride0_internalrftxpu_ovr_MASK)
				PHY_REG_AND_ENTRY(LCNPHY, rxlnaandgainctrl1ovrval,
					~(LCNPHY_rxlnaandgainctrl1ovrval_lnapuovr_Val_MASK))
				PHY_REG_AND_ENTRY(LCNPHY, rfoverride2val,
					~(LCNPHY_rfoverride2val_slna_pu_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LCNPHY, rfoverride2,
					LCNPHY_rfoverride2_lna_pu_ovr_MASK |
					LCNPHY_rfoverride2_slna_pu_ovr_MASK)
				PHY_REG_AND_ENTRY(LCNPHY, rfoverride3_val,
					~(LCNPHY_rfoverride3_val_rfactive_ovr_val_MASK))
				PHY_REG_OR_ENTRY(LCNPHY, rfoverride3,
					LCNPHY_rfoverride3_rfactive_ovr_MASK)
			PHY_REG_LIST_EXECUTE(pi);
		}
	} else if (ISABGPHY(pi)) {
		wlc_phy_switch_radio_abgphy(pi, on);
	} else if (pi->pi_fptr.switchradio) {
		pi->pi_fptr.switchradio(pi, on);
	}
}

/* %%%%%% chanspec, reg/srom limit */
uint16
wlc_phy_bw_state_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	return pi->bw;
}

void
wlc_phy_bw_state_set(wlc_phy_t *ppi, uint16 bw)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	pi->bw = bw;
}

void
wlc_phy_chanspec_shm_set(phy_info_t *pi, chanspec_t chanspec)
{
	uint16 curchannel;

	/* Update ucode channel value */
	if (D11REV_LT(pi->sh->corerev, 40)) {
		/* d11 rev < 40: compose a channel info value */
		curchannel = CHSPEC_CHANNEL(chanspec);
#ifdef BAND5G
		if (CHSPEC_IS5G(chanspec))
			curchannel |= D11_CURCHANNEL_5G;
#endif /* BAND5G */
		if (CHSPEC_IS40(chanspec))
			curchannel |= D11_CURCHANNEL_40;
	} else {
		/* d11 rev >= 40: store the chanspec */
		curchannel = chanspec;
	}

	PHY_TRACE(("wl%d: %s: M_CURCHANNEL %x\n", pi->sh->unit, __FUNCTION__, curchannel));
	wlapi_bmac_write_shm(pi->sh->physhim, M_CURCHANNEL, curchannel);
}

void
wlc_phy_chanspec_radio_set(wlc_phy_t *ppi, chanspec_t newch)
{
	phy_info_t *pi = (phy_info_t*)ppi;
#ifdef PREASSOC_PWRCTRL
	/* XXX this block of code
	   should be called before radio channel
	   is changed to the new channel
	*/
	if ((pi->radio_chanspec != newch) && ISACPHY(pi) && pi->sh->up) {
		wlc_phy_store_tx_pwrctrl_setting(pi, pi->radio_chanspec);
		wlc_phy_pwrctrl_shortwindow_upd(pi, TRUE);
	} else {
		pi->channel_short_window = TRUE;
	}
#endif // endif

	pi->radio_chanspec = newch;
}

chanspec_t
wlc_phy_chanspec_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	return pi->radio_chanspec;
}

int32
wlc_phy_min_txpwr_limit_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return (int32)pi->min_txpower;
}

void
wlc_phy_set_filt_war(wlc_phy_t *ppi, bool filt_war)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISHTPHY(pi))
		wlc_phy_set_filt_war_htphy(pi, filt_war);
}

bool
wlc_phy_get_filt_war(wlc_phy_t *ppi)
{
	bool ret = FALSE;
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISHTPHY(pi))
		ret = wlc_phy_get_filt_war_htphy(pi);
	return ret;
}

#if defined(WLTXPWR_CACHE) && defined(WLC_LOW_ONLY)
/**
 * Reserves an entry for the caller supplied chanspec in the tx power (ppr) cache, if not already
 * reserved.
 */
static void
wlc_phy_pwr_cache_reserve(phy_info_t *pi, chanspec_t chanspec)
{
	static chanspec_t last_chanspec = 0;
	if (wlc_phy_txpwr_cache_is_cached(pi->txpwr_cache, chanspec) != TRUE) {
		int result;
		chanspec_t kill_chan = 0;

		if (last_chanspec != 0)
			kill_chan = wlc_phy_txpwr_cache_find_other_cached_chanspec(pi->txpwr_cache,
				last_chanspec);
		if (kill_chan != 0) {
			if (pi->tx_power_offset == wlc_phy_get_cached_pwr(pi->txpwr_cache,
				kill_chan, TXPWR_CACHE_POWER_OFFSETS)) {
				/* remove reference, as we're about to delete this */
				pi->tx_power_offset = NULL;
			}
			wlc_phy_txpwr_cache_clear(pi->sh->osh, pi->txpwr_cache, kill_chan);
		}
		result = wlc_phy_txpwr_setup_entry(pi->txpwr_cache, chanspec); /* in wlc_ppr.c */
		ASSERT(result == BCME_OK);
	}
	last_chanspec = chanspec;
}
#endif /* WLTXPWR_CACHE WLC_LOW_ONLY */
#if defined(AP) && defined(RADAR)
void
wlc_phy_first_radar_indicator(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	/* indicate first time radar detection */
	pi->ri->first_radar_indicator = 1;
}
#endif // endif
void
wlc_phy_chanspec_set(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	chansetfn_t chanspec_set = NULL;
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, chanspec);
#endif // endif

	PHY_TRACE(("wl%d: %s: chanspec %x\n", pi->sh->unit, __FUNCTION__, chanspec));
	ASSERT(!wf_chspec_malformed(chanspec));

#ifdef WLSRVSDB
	pi->srvsdb_state.prev_chanspec = chanspec;
#endif /* WLSRVSDB */

#if defined(WLTXPWR_CACHE) && defined(WLC_LOW_ONLY)
	/* For split MAC driver, for faster channel switching, reserve an entry for this channel */
	wlc_phy_pwr_cache_reserve(pi, chanspec);
#endif /* WLTXPWR_CACHE && WLC_LOW_ONLY */

	/* Update ucode channel value */
	wlc_phy_chanspec_shm_set(pi, chanspec);

	chanspec_set = pi->pi_fptr.chanset;

#if defined(AP) && defined(RADAR)
	/* indicate first time radar detection */
	pi->ri->first_radar_indicator = 1;
#endif // endif
	/* Update interference mode for ACPHY, as now init is not called on band/bw change */
	if ((!SCAN_RM_IN_PROGRESS(pi)) && (ISACPHY(pi) ||
		(ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 4)))) {
		if (pi->sh->interference_mode_override == TRUE) {
			pi->sh->interference_mode = CHSPEC_IS2G(chanspec) ?
			        pi->sh->interference_mode_2G_override :
			        pi->sh->interference_mode_5G_override;
		} else if (pi->sh->btcoex_interference_mode_override) {
			pi->sh->interference_mode = CHSPEC_IS2G(chanspec) ?
			        pi->sh->interference_mode_2G_btcoex :
			        pi->sh->interference_mode_5G;
		} else {
			pi->sh->interference_mode = CHSPEC_IS2G(chanspec) ?
			        pi->sh->interference_mode_2G :
			        pi->sh->interference_mode_5G;
		}
	}

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	/* If a channel context exists, retrieve the multi-phase info from there, else use
	 * the default one
	 */
	/* A context has to be explicitly created */
	if (ctx)
		pi->cal_info = &ctx->cal_info;
	else
		pi->cal_info = &pi->def_cal_info;
#endif // endif

	ASSERT(pi->cal_info);

#ifdef ENABLE_FCBS
	if (IS_FCBS(pi)) {
		if (chanspec_set) {
			int chanidx;
			fcbsinitprefn_t prefcbsinit;

			if (wlc_phy_is_fcbs_chan(pi, chanspec, &chanidx) &&
				!(SCAN_INPROG_PHY(pi) || RM_INPROG_PHY(pi) || PLT_INPROG_PHY(pi))) {
				wlc_phy_fcbs((wlc_phy_t*)pi, chanidx, 1);
				/* Need to set this to indicate that we have switched to new chan
				 * not needed for SW-based FCBS ???
				 */
				pi->phy_fcbs.FCBS_INPROG = 1;
				wlc_phy_chanspec_radio_set((wlc_phy_t *)pi, chanspec);
			} else {
				/* The conditioning here matches that below for FCBS init. Hence, if
				 * there is a pending FCBS init on this channel and if HW_FCBS, then
				 * we want to setup the channel-indicator bit, etc. appropriately
				 * before we call phy_specific chanspec_set
				 */
				if (wlc_phy_is_fcbs_pending(pi, chanspec, &chanidx) &&
				!(SCAN_INPROG_PHY(pi) || RM_INPROG_PHY(pi) || PLT_INPROG_PHY(pi))) {
					if ((prefcbsinit = pi->pi_fptr.prefcbsinit))
						(*prefcbsinit)(pi, chanidx);
				}

				(*chanspec_set)(pi, chanspec);

				/* Now that we are on new channel, check for a pending request */
				if (wlc_phy_is_fcbs_pending(pi, chanspec, &chanidx) &&
				!(SCAN_INPROG_PHY(pi) || RM_INPROG_PHY(pi) || PLT_INPROG_PHY(pi))) {
					wlc_phy_fcbs_init((wlc_phy_t*)pi, chanidx);
				} else {
					chanidx = wlc_phy_channelindicator_obtain_acphy(pi);
					pi->phy_fcbs.initialized[chanidx] = FALSE;
				}
			}
		}
	} else {
		if (chanspec_set)
			(*chanspec_set)(pi, chanspec);
	}
#else
	if (chanspec_set)
		(*chanspec_set)(pi, chanspec);
#endif /* ENABLE_FCBS */
	if (ISACPHY(pi)) {
		wlc_phy_preempt(pi, ((pi->sh->interference_mode & ACPHY_ACI_PREEMPTION) != 0));
	}

#if defined(WLMCHAN)
	/* Switched the context so restart a pending MPHASE cal, else clear the state */
	if (ctx) {
		if (wlc_phy_cal_cache_restore(pi) == BCME_ERROR) {
			PHY_CAL(("%s cal cache restore on chanspec 0x%x Failed\n",
				__FUNCTION__, pi->radio_chanspec));
		}

		if (CHIPID(pi->sh->chip) != BCM43237_CHIP_ID) {
			/* Calibrate if now > last_cal_time + glacial */
			if (PHY_PERICAL_MPHASE_PENDING(pi)) {
				PHY_CAL(("%s: Restarting calibration for 0x%x phase %d\n",
				__FUNCTION__, chanspec, pi->cal_info->cal_phase_id));
				/* Delete any existing timer just in case */
				wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
				wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, 0, 0);
			} else if ((pi->phy_cal_mode != PHY_PERICAL_DISABLE) &&
				(pi->phy_cal_mode != PHY_PERICAL_MANUAL) &&
			((pi->sh->now - pi->cal_info->last_cal_time) >= pi->sh->glacial_timer))
				wlc_phy_cal_perical((wlc_phy_t *)pi, PHY_PERICAL_WATCHDOG);

		} else {
			if (PHY_PERICAL_MPHASE_PENDING(pi))
				wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
		}
	}
#endif /* WLMCHAN */

	/* Set this flag to FALSE after doing noise mmt for the first time */
	pi->noise_mmt_first_time = TRUE;
#ifndef WLC_DISABLE_ACI
#ifdef WLPHYACICACHE
if ((CHSPEC_BAND(pi->radio_chanspec) == CHSPEC_BAND(pi->prev_chanspec)) &&
	(CHSPEC_BW(pi->radio_chanspec) == CHSPEC_BW(pi->prev_chanspec))) {
		wlc_phy_do_aci_update_cache((wlc_phy_t *)pi, chanspec, TRUE);
}
#endif // endif
#endif /* WLC_DISABLE_ACI */

	wlapi_update_bt_chanspec(pi->sh->physhim, chanspec,
		SCAN_INPROG_PHY(pi), RM_INPROG_PHY(pi));
}

/* don't use this directly. use wlc_get_band_range whenever possible */
int
wlc_phy_chanspec_freq2bandrange_lpssn(uint freq)
{
	int range = -1;
	if (freq < 2500)
		range = WL_CHAN_FREQ_RANGE_2G;
#ifdef BAND5G
	else if (freq <= 5320)
		range = WL_CHAN_FREQ_RANGE_5GL;
	else if (freq <= 5700)
		range = WL_CHAN_FREQ_RANGE_5GM;
	else
		range = WL_CHAN_FREQ_RANGE_5GH;
#endif /* BAND5G */

	return range;
}

int
wlc_phy_chanspec_bandrange_get(phy_info_t *pi, chanspec_t chanspec)
{
	int range = -1;
	uint channel = CHSPEC_CHANNEL(chanspec);
	uint freq = wlc_phy_channel2freq(channel);

	if (ISNPHY(pi)) {
		range = wlc_phy_get_chan_freq_range_nphy(pi, channel);
	} else if (ISHTPHY(pi)) {
		range = wlc_phy_get_chan_freq_range_htphy(pi, channel);
	} else if (ISACPHY(pi)) {
#ifdef SROM12
	  if (pi->sh->sromrev == 12) {
	    range = wlc_phy_get_chan_freq_range_srom12_acphy(pi, channel);
	  }
#endif /* SROM12 */
	  if (pi->sh->sromrev == 11) {
	    range = wlc_phy_get_chan_freq_range_acphy(pi, channel);
	  }
	} else if (ISSSLPNPHY(pi) || ISLPPHY(pi) || ISLCNCOMMONPHY(pi) || ISLCN20PHY(pi)) {
		range = wlc_phy_chanspec_freq2bandrange_lpssn(freq);
	} else if (ISGPHY(pi)) {
		range = WL_CHAN_FREQ_RANGE_2G;
	} else if (ISAPHY(pi)) {
		range = wlc_get_a_band_range(pi);

		switch (range) {
		case A_LOW_CHANS:
			range = WL_CHAN_FREQ_RANGE_5GL;
			break;

		case A_MID_CHANS:
			range = WL_CHAN_FREQ_RANGE_5GM;
			break;

		case A_HIGH_CHANS:
			range = WL_CHAN_FREQ_RANGE_5GH;
			break;

		default:
			break;
		}
	} else
		ASSERT(0);

	return range;
}

bool
wlc_phy_is_txbfcal(wlc_phy_t *ppi)
{

	uint8  subband_idx;
	uint16 rpcal_val;
	bool   is_caled;
	phy_info_t *pi = (phy_info_t*)ppi;

	if (!ISACPHY(pi))
		return FALSE;

#ifdef MACOSX
	/* XXX FIXME: SWWLAN-31395 causes long channel switch times for 4360
	 * So disable implicit TXBF for 4360 for Macos for now
	 */
	if (ACMAJORREV_0(pi->pubpi.phy_rev))
		return FALSE;
#endif /* MACOSX */

	subband_idx = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	switch (subband_idx) {
	case WL_CHAN_FREQ_RANGE_2G:
		rpcal_val = pi->sh->rpcal2g;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND0:
		rpcal_val = pi->sh->rpcal5gb0;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND1:
		rpcal_val = pi->sh->rpcal5gb1;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND2:
		rpcal_val = pi->sh->rpcal5gb2;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND3:
		rpcal_val = pi->sh->rpcal5gb3;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Invalid chan_freq_range %d\n",
		           pi->sh->unit, __FUNCTION__, subband_idx));
		rpcal_val = pi->sh->rpcal2g;
		break;
	}

	is_caled = (rpcal_val != 0);

	return is_caled;
}

void
wlc_phy_chanspec_ch14_widefilter_set(wlc_phy_t *ppi, bool wide_filter)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISABGPHY(pi))
		pi->u.pi_abgphy->channel_14_wide_filter = wide_filter;

	/* XXX REVISIT JOHNVB.  It might be desired/necessary to set the chanspec
	 * if we happen to be on channel 14 already.  After talking with Bill
	 * there appears to be other boundary cases that might occur as a result
	 * of changing the locale, which is when this function is called.  Instead of
	 * worrying about this case I am adding, I will wait for a deeper revisit.
	 */
}

/*
 * Converts channel number to channel frequency.
 * Returns 0 if the channel is out of range.
 * Also used by some code in wlc_iw.c
 */
int
wlc_phy_channel2freq(uint channel)
{
	uint i;

	for (i = 0; i < ARRAYSIZE(chan_info_all); i++)
		if (chan_info_all[i].chan == channel)
			return (chan_info_all[i].freq);
	return (0);
}
/* Converts channel number into the wlc_phy_chan_info index */
uint
wlc_phy_channel2idx(uint channel)
{
	uint i;

	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
		if (chan_info_all[i].chan == channel)
			return i;
	}

	ASSERT(FALSE);
	return (0);
}

/* fill out a chanvec_t with all the supported channels for the band. */
void
wlc_phy_chanspec_band_validch(wlc_phy_t *ppi, uint band, chanvec_t *channels)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint i;
	uint channel;

	ASSERT((band == WLC_BAND_2G) || (band == WLC_BAND_5G));

	bzero(channels, sizeof(chanvec_t));

	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
		channel = chan_info_all[i].chan;

		/* disable the high band channels [149-165] for srom ver 1 */
		if ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM) &&
		    (channel <= LAST_REF5_CHANNUM))
			continue;

		/* Disable channel 144 unless it's an ACPHY */
		if ((channel == 144) && (!ISACPHY(pi)))
			continue;

		if (CHIPID_4324X_MEDIA_FAMILY(pi) &&
			((channel == 34) || (channel == 38) || (channel == 42) || (channel == 46)))
			continue;

		if (((band == WLC_BAND_2G) && (channel <= CH_MAX_2G_CHANNEL)) ||
		    ((band == WLC_BAND_5G) && (channel > CH_MAX_2G_CHANNEL)))
			setbit(channels->vec, channel);
	}
}

/* returns the first hw supported channel in the band */
chanspec_t
wlc_phy_chanspec_band_firstch(wlc_phy_t *ppi, uint band)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint i;
	uint channel;
	chanspec_t chspec;

	ASSERT((band == WLC_BAND_2G) || (band == WLC_BAND_5G));

	for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
		channel = chan_info_all[i].chan;

		/* If 40MHX b/w then check if there is an upper 20Mhz adjacent channel */
		if ((ISNPHY(pi) || ISHTPHY(pi)|| ISSSLPNPHY(pi)) && IS40MHZ(pi)) {
			uint j;
			/* check if the upper 20Mhz channel exists */
			for (j = 0; j < ARRAYSIZE(chan_info_all); j++) {
				if (chan_info_all[j].chan == channel + CH_10MHZ_APART)
					break;
			}
			/* did we find an adjacent channel */
			if (j == ARRAYSIZE(chan_info_all))
				continue;
			/* Convert channel from 20Mhz num to 40 Mhz number */
			channel = UPPER_20_SB(channel);
			chspec = channel | WL_CHANSPEC_BW_40 | WL_CHANSPEC_CTL_SB_LOWER;
			if (band == WLC_BAND_2G)
				chspec |= WL_CHANSPEC_BAND_2G;
			else
				chspec |= WL_CHANSPEC_BAND_5G;
		}
		else
			chspec = CH20MHZ_CHSPEC(channel);

		/* disable the high band channels [149-165] for srom ver 1 */
		if ((pi->a_band_high_disable) && (channel >= FIRST_REF5_CHANNUM) &&
		    (channel <= LAST_REF5_CHANNUM))
			continue;

		if (((band == WLC_BAND_2G) && (channel <= CH_MAX_2G_CHANNEL)) ||
		    ((band == WLC_BAND_5G) && (channel > CH_MAX_2G_CHANNEL)))
			return chspec;
	}

	/* should never come here */
	ASSERT(0);

	/* to avoid warning */
	return (chanspec_t)INVCHANSPEC;
}

/* %%%%%% txpower */

/* user txpower limit: in qdbm units with override flag */
int
wlc_phy_txpower_get(wlc_phy_t *ppi, int8 *qdbm, bool *override)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint8	i, max = 0;
	int8	*openlp_pwr = NULL;
	int8	*user_target = NULL;

	ASSERT(qdbm != NULL);

#ifdef WLTXPWR_PER_CORE
		max = WL_TXPWR_CORE_MAX;
		user_target = pi->p_tx_user_target;
		openlp_pwr = pi->p_openlp_tx_power_min;
#else
	max = 1;
	user_target = &pi->tx_user_target;
	openlp_pwr = &pi->openlp_tx_power_min;
#endif /* WLTXPWR_PER_CORE */

	for (i = 0; i < max; i++) {
		/* User target, per core. */
		qdbm[i] = user_target[i];

		if (pi->openlp_tx_power_on) {
			if (pi->txpwrnegative) {
				qdbm[i] = (-1 * openlp_pwr[i]) | WL_TXPWR_NEG;
			} else {
				qdbm[i] = openlp_pwr[i];
			}
		}
	}

	if (override != NULL)
		*override = pi->txpwroverride;
	return (0);
}

int
wlc_phy_txpower_set_offset(wlc_phy_t *ppi, int8 *qdbm)
{
#ifdef POWPERCHANNL2G
		phy_info_t *pi = (phy_info_t *)ppi;
		srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
		int8	qdbm_chan_offset, i;
		uint8 chan = CHSPEC_CHANNEL(pi->radio_chanspec)-1;
		uint8 band = wlc_phy_get_chan_freq_range_acphy(pi, chan);
		if (band  == WL_CHAN_FREQ_RANGE_2G) {
			for (i = 0; i < WL_TXPWR_CORE_MAX; i++) {
				qdbm_chan_offset =
					pwrdet->PwrOffsets2GTemp[pwrdet->CurrentTempZone][i][chan];
				qdbm[i] = qdbm[i] + qdbm_chan_offset;

			}
		}
#endif /* POWPERCHANNL2G */
		return (0);
}

/* user txpower limit: in qdbm units with override flag */
/* Victor, add power control related to power per channel offset */
int
wlc_phy_txpower_get_a(wlc_phy_t *ppi, int8 *qdbm, bool *override)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint8 chan = CHSPEC_CHANNEL(pi->radio_chanspec)-1;
	uint8 band = wlc_phy_get_chan_freq_range_acphy(pi, chan);
	uint8	i, max = 0;
	int8	*openlp_pwr = NULL;
	int8	*user_target = NULL;
	int8	qdbm_chan_offset = 0;

	ASSERT(qdbm != NULL);

#ifdef WLTXPWR_PER_CORE
	max = WL_TXPWR_CORE_MAX;
	user_target = pi->p_tx_user_target;
	openlp_pwr = pi->p_openlp_tx_power_min;
#else
	max = 1;
	user_target = &pi->tx_user_target;
	openlp_pwr = &pi->openlp_tx_power_min;
#endif /* WLTXPWR_PER_CORE */

	for (i = 0; i < max; i++) {
		/* User target, per core. */
		qdbm[i] = user_target[i];
		if (band  == WL_CHAN_FREQ_RANGE_2G) {
		/* 2GHz with offset  */
#ifdef POWPERCHANNL2G
			srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
			qdbm_chan_offset =
			    pwrdet->PwrOffsets2GTemp[pwrdet->CurrentTempZone][i][chan];
#else
			qdbm_chan_offset = 0;
#endif 	/* 	POWPERCHANNL2G */
		}
		if (pi->openlp_tx_power_on) {
			if (pi->txpwrnegative) {
				qdbm[i] = (-1 * openlp_pwr[i]) | WL_TXPWR_NEG;
			} else {
				qdbm[i] = openlp_pwr[i];
			}
		}
		qdbm[i] -= qdbm_chan_offset;
	}

	if (override != NULL)
		*override = pi->txpwroverride;
	return (0);
}

/* user txpower limit: in qdbm units with override flag */
int
#ifdef WLTXPWR_PER_CORE
wlc_phy_txpower_set(wlc_phy_t *ppi, int8* qdbm, bool override, ppr_t *reg_pwr)
#else
wlc_phy_txpower_set(wlc_phy_t *ppi, int8 qdbm, bool override, ppr_t *reg_pwr)
#endif /* WLTXPWR_PER_CORE */
{
	uint8 tx_pwr_ctrl_state;
	phy_info_t *pi = (phy_info_t *)ppi;

#ifdef WLTXPWR_PER_CORE
	uint i = 0;
#endif /* WLTXPWR_PER_CORE */

	/* No way for user to set maxpower on individual rates yet.
	 * Same max power is used for all rates
	 */

#ifdef WLTXPWR_PER_CORE
	/* Per core. */
	for (i = 0; i < WL_TXPWR_CORE_MAX; i++) {
		pi->p_tx_user_target[i] = qdbm[i];
	}
#else
	pi->tx_user_target = qdbm;
#endif /* WLTXPWR_PER_CORE */

	/* Restrict external builds to 100% Tx Power */
#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WL_EXPORT_TXPOWER)
	pi->txpwroverride = override;
	pi->txpwroverrideset = override;
#else
	pi->txpwroverride = FALSE;
#endif // endif

	if (pi->sh->up) {
		if (SCAN_INPROG_PHY(pi)) {
			PHY_TXPWR(("wl%d: Scan in progress, skipping txpower control\n",
				pi->sh->unit));
		} else {
			if (ISSSLPNPHY(pi)) {
				wlc_phy_txpower_recalc_target(pi, reg_pwr, NULL);
				wlc_phy_cal_txpower_recalc_sw(pi);
			} else {
				bool suspend;

				suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) &
				            MCTL_EN_MAC);

				if (!suspend)
					wlapi_suspend_mac_and_wait(pi->sh->physhim);

				if (ISACPHY(pi))
					tx_pwr_ctrl_state = pi->txpwrctrl;
				else
					tx_pwr_ctrl_state = pi->nphy_txpwrctrl;

				if (ISNPHY(pi)) {
					/* Switch off power control to save previuos index */
					wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
				} else if (ISACPHY(pi)) {
					wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
					wlc_phy_set_tssisens_lim_acphy(pi, pi->txpwroverride);
				}

				wlc_phy_txpower_recalc_target(pi, reg_pwr, NULL);
				wlc_phy_cal_txpower_recalc_sw(pi);

				if (ISNPHY(pi)) {
					/* Restore power control back */
					wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
				} else if (ISACPHY(pi)) {
					wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
				}

				if (!suspend)
					wlapi_enable_mac(pi->sh->physhim);
			}
		}
	}
	return (0);
}

/* user txpower limit: in qdbm units with override flag */
int
#ifdef WLTXPWR_PER_CORE
wlc_phy_neg_txpower_set(wlc_phy_t *ppi, int8 *qdbm)
#else
wlc_phy_neg_txpower_set(wlc_phy_t *ppi, uint qdbm)
#endif /* WLTXPWR_PER_CORE */
{
	phy_info_t *pi = (phy_info_t *)ppi;
	initfn_t txpwr_recalc_fn = NULL;

	if (pi->sh->up) {
		if (SCAN_INPROG_PHY(pi)) {
			PHY_TXPWR(("wl%d: Scan in progress, skipping txpower control\n",
				pi->sh->unit));
		} else {
			bool suspend;
			suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);

			if (!suspend)
				wlapi_suspend_mac_and_wait(pi->sh->physhim);

#ifdef WLTXPWR_PER_CORE
			pi->p_openlp_tx_power_min[0] = -1*qdbm[0];
			pi->p_openlp_tx_power_min[1] = -1*qdbm[1];
			pi->p_openlp_tx_power_min[2] = -1*qdbm[2];
#else
			pi->openlp_tx_power_min = -1*qdbm;
#endif /* WLTXPWR_PER_CORE */
			pi->txpwrnegative = 1;
			pi->txpwroverride = 1;

			txpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;
			if (txpwr_recalc_fn)
				(*txpwr_recalc_fn)(pi);

			if (!suspend)
				wlapi_enable_mac(pi->sh->physhim);

		}
	}
	return (0);
}

/* get sromlimit per rate for given channel. Routine does not account for ant gain */
void
wlc_phy_txpower_sromlimit(wlc_phy_t *ppi, chanspec_t chanspec, uint8 *min_pwr,
    ppr_t *max_pwr, uint8 core)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint channel = CHSPEC_CHANNEL(chanspec);

	if (min_pwr)
		*min_pwr = pi->min_txpower * WLC_TXPWR_DB_FACTOR;
	if (max_pwr) {
		if (ISSSLPNPHY(pi)) {
			wlc_phy_txpower_sromlimit_get_ssnphy(pi, channel, max_pwr);
		} else if (ISLCNPHY(pi)) {
			wlc_phy_txpower_sromlimit_get_lcnphy(pi, channel, max_pwr, core);
		} else if (ISLCN40PHY(pi)) {
			wlc_phy_txpower_sromlimit_get_lcn40phy(pi, channel, max_pwr, core);
		} else if (ISACPHY(pi)) {
			wlc_phy_txpower_sromlimit_get_acphy(pi, chanspec, max_pwr, core);
		} else  if (ISHTPHY(pi)) {
			wlc_phy_txpower_sromlimit_get_htphy(pi, chanspec, max_pwr, core);
		} else if (ISNPHY(pi)) {
			wlc_phy_txpower_sromlimit_get_nphy(pi, channel, max_pwr, core);
		} else if (ISABGPHY(pi) || (ISLPPHY(pi))) {
			wlc_phy_txpower_sromlimit_get_abglpphy_ppr_new(pi, channel, max_pwr, core);
		} else {
			ppr_set_cmn_val(max_pwr, (int8)WLC_TXPWR_MAX);
		}
	}
}

void
wlc_phy_txpower_boardlimit_band(wlc_phy_t *ppi, uint bandunit, int32 *max_pwr,
	int32 *min_pwr, uint32 *step_pwr)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	int32 local_max;

	/* XXX: Looks kind of bogus one as on 5G band we have different
	 *  limits for different sets of channels
	 */
	if (ISLPPHY(pi)) {
		if (bandunit == 1)
			*max_pwr = pi->tx_srom_max_2g;
		else {
			local_max = pi->tx_srom_max_5g_low;
			if (local_max <  pi->tx_srom_max_5g_mid)
				local_max =  pi->tx_srom_max_5g_mid;
			if (local_max <  pi->tx_srom_max_5g_hi)
				local_max =  pi->tx_srom_max_5g_hi;
			*max_pwr = local_max;
		}
		*min_pwr = 8;
		*step_pwr = 1;
	}
}

uint8
wlc_phy_txpower_get_target_min(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	uint8 core;
	uint8 tx_pwr_min = WLC_TXPWR_MAX;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		tx_pwr_min = MIN(tx_pwr_min, pi->tx_power_min_per_core[core]);
	}

	return tx_pwr_min;
}

uint8
wlc_phy_txpower_get_target_max(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	uint8 core;
	uint8 tx_pwr_max = 0;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		tx_pwr_max = MAX(tx_pwr_max, pi->tx_power_max_per_core[core]);
	}

	return tx_pwr_max;
}

static int8
wlc_phy_channel_gain_adjust(phy_info_t *pi)
{
	int8 pwr_correction = 0;
	uint8 channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		pwr_correction = pi->phy_cga_2g[channel-1];
	}
#ifdef BAND5G
	else {
		uint freq = wlc_phy_channel2freq(channel);
		uint8 i;
		uint16 chan_info_phy_cga_5g[24] = {
			5180, 5200, 5220, 5240, 5260, 5280, 5300, 5320,
			5500, 5520, 5540, 5560, 5580, 5600, 5620, 5640,
			5660, 5680, 5700, 5745, 5765, 5785, 5805, 5825,
		};

		for (i = 0; i < ARRAYSIZE(chan_info_phy_cga_5g); i++)
			if (freq <= chan_info_phy_cga_5g[i]) {
				pwr_correction = pi->phy_cga_5g[i];
				break;
			}
	}
#endif /* BAND5G */
	return pwr_correction;
}

#ifdef WLTXPWR_CACHE
/* Retrieve the cached ppr targets and pass them to the hardware function. */
static void
wlc_phy_txpower_retrieve_cached_target(phy_info_t *pi)
{
	initfn_t txpwr_recalc_fn = NULL;
	uint8 core;

	FOREACH_CORE(pi, core) {
		pi->tx_power_max_per_core[core] =
			wlc_phy_get_cached_pwr_max(pi->txpwr_cache, pi->radio_chanspec, core);
		pi->tx_power_min_per_core[core] =
			wlc_phy_get_cached_pwr_min(pi->txpwr_cache, pi->radio_chanspec, core);
#if WLTXPWR_PER_CORE
		pi->p_openlp_tx_power_min[core] = pi->tx_power_min_per_core[core];
#else
		pi->openlp_tx_power_min = pi->tx_power_min_per_core[core];
#endif /* WLTXPWR_PER_CORE */
	}
	pi->txpwrnegative = 0;

	txpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;
	if (txpwr_recalc_fn)
		(*txpwr_recalc_fn)(pi);
}
#endif /* WLTXPWR_CACHE */

/* Recalc target power all phys.  This internal/static function needs to be called whenever
 * the chanspec or TX power values (user target, regulatory limits or SROM/HW limits) change.
 * This happens thorough calls to the PHY public API.
 */
static void
wlc_phy_txpower_recalc_target(phy_info_t *pi, ppr_t *txpwr_reg, ppr_t *txpwr_targets)
{
	int8 tx_pwr_max = 0;
	int8 tx_pwr_min = 255;
	chanspec_t chspec;
	initfn_t txpwr_recalc_fn = NULL;
	uint8 mintxpwr = 0;
	ppr_t *srom_max_txpwr;
	ppr_t *tx_pwr_target;
	uint target_chan;
	phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
	int8 cga;
	uint8 core;
#if ACCONF && defined(WLC_HIGH) && (defined(WLTEST) || defined(WLPKTENG))
	int16 openloop_pwrctrl_delta;
	bool mac_enabled = FALSE;
	int8 olpc_anchor = 0;
#endif // endif
	bool band5g_4319_flag = ((BOARDTYPE(pi->sh->boardtype) == BCM94319SDELNA6L_SSID) ||
	    (BOARDTYPE(pi->sh->boardtype) == BCM94319SDNA_SSID)) &&
		CHSPEC_IS5G(pi->radio_chanspec);

	ppr_t *reg_txpwr_limit;
	int8 maxpwr = 127;

#ifdef WLTXPWR_CACHE
	if ((pi->tx_power_offset != NULL) && (!wlc_phy_is_pwr_cached(pi->txpwr_cache,
		TXPWR_CACHE_POWER_OFFSETS, pi->tx_power_offset))) {
		ppr_delete(pi->sh->osh, pi->tx_power_offset);
	}

	if ((!pi->txpwroverride) && ((pi->tx_power_offset = wlc_phy_get_cached_pwr(pi->txpwr_cache,
		pi->radio_chanspec, TXPWR_CACHE_POWER_OFFSETS)) != NULL) &&
		(txpwr_targets == NULL)) {
		wlc_phy_txpower_retrieve_cached_target(pi);
		return;
	}
	pi->tx_power_offset = NULL;
#endif /* WLTXPWR_CACHE */

	if ((reg_txpwr_limit = ppr_create(pi->sh->osh, PPR_CHSPEC_BW(pi->radio_chanspec))) == NULL)
		return;

	if (txpwr_reg != NULL)
		wlc_phy_txpower_reg_limit_calc(pi, txpwr_reg, pi->radio_chanspec, reg_txpwr_limit);

	chspec = pi->radio_chanspec;
	target_chan = wf_chspec_ctlchan(chspec);

	if ((tx_pwr_target = ppr_create(pi->sh->osh, PPR_CHSPEC_BW(chspec))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		     __FUNCTION__, MALLOCED(pi->sh->osh)));
		ppr_delete(pi->sh->osh, reg_txpwr_limit);
		return;
	}
	if ((srom_max_txpwr = ppr_create(pi->sh->osh, PPR_CHSPEC_BW(chspec))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		     __FUNCTION__, MALLOCED(pi->sh->osh)));
		ppr_delete(pi->sh->osh, reg_txpwr_limit);
		ppr_delete(pi->sh->osh, tx_pwr_target);
		return;
	}

	if ((pi->tx_power_offset != NULL) &&
	    (ppr_get_ch_bw(pi->tx_power_offset) != PPR_CHSPEC_BW(chspec))) {
		ppr_delete(pi->sh->osh, pi->tx_power_offset);
		pi->tx_power_offset = NULL;
	}
	if (pi->tx_power_offset == NULL) {
		if ((pi->tx_power_offset = ppr_create(pi->sh->osh, PPR_CHSPEC_BW(chspec))) ==
			NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
				__FUNCTION__, MALLOCED(pi->sh->osh)));
			ppr_delete(pi->sh->osh, reg_txpwr_limit);
			ppr_delete(pi->sh->osh, tx_pwr_target);
			ppr_delete(pi->sh->osh, srom_max_txpwr);
			return;
		}
	}

	ppr_clear(pi->tx_power_offset);

	cga = wlc_phy_channel_gain_adjust(pi);

	/* Combine user target, regulatory limit, SROM/HW/board limit and power
	 * percentage to get a tx power target for each rate.
	 */
	FOREACH_CORE(pi, core) {
		/* The user target is the starting point for determining the transmit
		 * power.  If pi->txoverride is true, then use the user target as the
		 * tx power target.
		 */
#ifdef WLTXPWR_PER_CORE
		ppr_set_cmn_val(tx_pwr_target, pi->p_tx_user_target[core]);
#else
		ppr_set_cmn_val(tx_pwr_target, pi->tx_user_target);
#endif /* WLTXPWR_PER_CORE */

#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WL_EXPORT_TXPOWER)
		/* Only allow tx power override for internal or test builds. */
		if (!pi->txpwroverride)
#endif // endif
		{
			/* Get board/hw limit */
			wlc_phy_txpower_sromlimit((wlc_phy_t *)pi, chspec,
			    &mintxpwr, srom_max_txpwr, core);

			if (ISSSLPNPHY(pi) && SSLPNREV_IS(pi->pubpi.phy_rev, 3)) {
				if (CHSPEC_IS20(pi->radio_chanspec) &&
				    (target_chan == 14)) {
					ppr_set_cmn_val(tx_pwr_target, 44);
				}
			}

			/* Adjust board limits based on environmental conditions */
			if (ISLCN40PHY(pi)) {
					wlc_lcn40phy_apply_cond_chg(pi->u.pi_lcn40phy,
						srom_max_txpwr);
			}
			if (ISNPHY(pi) && CHIPID_4324X_EPA_FAMILY(pi)) {
					wlc_nphy_apply_cond_chg(pi, srom_max_txpwr);
			}

			/* Choose minimum of provided regulatory and board/hw limits */
			ppr_compare_min(srom_max_txpwr, reg_txpwr_limit);
			/* Subtract 4 (1.0db) for 4313(IPA) as we are doing PA trimming
			 * otherwise subtract 6 (1.5 db)
			 * to ensure we don't go over
			 * the limit given a noisy power detector.  The result
			 * is now a target, not a limit.
			 */
			if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
				wlc_lcnphy_modify_max_txpower(pi, srom_max_txpwr);
			}
			else if (!(ISSSLPNPHY(pi) && SSLPNREV_IS(pi->pubpi.phy_rev, 4))) {
				ppr_minus_cmn_val(srom_max_txpwr, pi->tx_pwr_backoff);
			}

			/* Choose least of user and now combined regulatory/hw targets */
			ppr_compare_min(tx_pwr_target, srom_max_txpwr);

			/* Board specific fix reduction */
			if (ISGPHY(pi) &&
				(BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_PACTRL))
				ppr_minus_cmn_val(tx_pwr_target, 3);
			if (ISSSLPNPHY(pi))
				wlc_sslpnphy_txpwr_target_adj(pi, tx_pwr_target);

			/* Apply power output percentage */
			if (pi->txpwr_percent < 100)
				ppr_multiply_percentage(tx_pwr_target, pi->txpwr_percent);

#ifdef WL_SARLIMIT
			if (ISHTPHY(pi)) {
				ppr_apply_max(tx_pwr_target, pi->sarlimit[core]);
				/* find each core TP of all rates */
				pi->txpwr_max_percore[core] = ppr_get_max(tx_pwr_target);
			}
#endif /* WL_SARLIMIT */

			/* Enforce min power and save result as power target.
			 * LCNPHY references off the minimum so this is not appropriate for it.
			 */
			if (!ISLCNPHY(pi)) {
				if (ISACPHY(pi)) {
					/* Finding the MIN of the different cores */
					maxpwr = MIN(maxpwr,
						wlc_phy_calc_ppr_pwr_cap_acphy(pi,
						core, ppr_get_max(tx_pwr_target)));
#if defined(PHYCAL_CACHING) || defined(WLMCHAN)|| defined(WL_MODESW)
					mintxpwr = (uint8)wlc_phy_txpwrctrl_update_minpwr_acphy(pi);
#endif	/* PHYCAL_CACHING || WLMCHAN || WL_MODESW */
					PHY_INFORM(("%s, core %d, maxpwr %d, mintxpwr %d\n",
						__FUNCTION__, core, maxpwr, (int8)mintxpwr));
					if ((maxpwr >= (int8)mintxpwr)) {
						/* maxpwr is the max power among all rates
						 * (min accross cores)
						 * mintxpwr is the visibility threshold
						 * Rates will be disabled ONLY if some rates
						 * are above visibility thresh and some below.
						 * If all rates are above visi thresh,
						 * no OLPC. If all rates are below visi thresh,
						 * disable OLPC, dont disable rates
						 */
						ppr_force_disabled(tx_pwr_target, mintxpwr);
					}
				} else {
					ppr_apply_min(tx_pwr_target, mintxpwr);
				}
			}
			/* Channel Gain Adjustment */
			if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
				ppr_minus_cmn_val(tx_pwr_target, cga);
			}
		}

		if (ISHTPHY(pi)) {
			ppr_apply_max(tx_pwr_target, wlc_phy_txpwr_max_est_pwr_get_htphy(pi));
		}

		tx_pwr_max = ppr_get_max(tx_pwr_target);

		if (tx_pwr_max < (pi->min_txpower * WLC_TXPWR_DB_FACTOR)) {
			tx_pwr_max = pi->min_txpower * WLC_TXPWR_DB_FACTOR;
		}

		if (ISGPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))
			tx_pwr_min = ppr_get_min(tx_pwr_target, mintxpwr);
		else
			tx_pwr_min = ppr_get_min(tx_pwr_target, WL_RATE_DISABLED);
#ifdef WL_SARLIMIT
		if (ISHTPHY(pi)) {
			tx_pwr_max = MIN(tx_pwr_max, pi->txpwr_max_percore[core]);
		}
#endif // endif
		/* Now calculate the tx_power_offset and update the hardware... */
		pi->tx_power_max_per_core[core] = tx_pwr_max;
		pi->tx_power_min_per_core[core] = tx_pwr_min;

#ifdef WLTXPWR_CACHE
		if (wlc_phy_txpwr_cache_is_cached(pi->txpwr_cache, pi->radio_chanspec) == TRUE) {
			wlc_phy_set_cached_pwr_min(pi->txpwr_cache, pi->radio_chanspec, core,
				tx_pwr_min);
			wlc_phy_set_cached_pwr_max(pi->txpwr_cache, pi->radio_chanspec, core,
				tx_pwr_max);
		}
#endif // endif
#ifdef WLTXPWR_PER_CORE
		pi->p_openlp_tx_power_min[core] = tx_pwr_min;
#else
		pi->openlp_tx_power_min = tx_pwr_min;
#endif /* WLTXPWR_PER_CORE */
		pi->txpwrnegative = 0;

		PHY_NONE(("wl%d: %s: channel %d min %d max %d\n", pi->sh->unit, __FUNCTION__,
		    target_chan, tx_pwr_min, tx_pwr_max));

		PHY_NONE(("wl%d: %s: channel %d rate - targets - offsets:\n", pi->sh->unit,
		          __FUNCTION__, target_chan));

		/* determinate the txpower offset by either of the following 2 methods:
		 * txpower_offset = txpower_max - txpower_target OR
		 * txpower_offset = txpower_target - txpower_min
		 */

		/* return curpower for last core loop since we are now checking
		 * MIN_cores(MAX_rates(power)) for rate disabling
		 * Only the last core loop info is valid
		 */
		if (core == PHYCORENUM((pi)->pubpi.phy_corenum) - 1) {
			pi->curpower_display_core = PHYCORENUM((pi)->pubpi.phy_corenum) - 1;

			if (txpwr_targets != NULL)
				ppr_copy_struct(tx_pwr_target, txpwr_targets);
		}

		if (!pi->hwpwrctrl || ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi) ||
		      band5g_4319_flag) {
			ppr_cmn_val_minus(tx_pwr_target, pi->tx_power_max_per_core[core]);
		} else {
			ppr_minus_cmn_val(tx_pwr_target, pi->tx_power_min_per_core[core]);
		}
		ppr_compare_max(pi->tx_power_offset, tx_pwr_target);

		if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID))
			wlc_lcnphy_modify_rate_power_offsets(pi);

		if (ISLCNPHY(pi) || ISLCN40PHY(pi) || (ISNPHY(pi) && CHIPID_4324X_EPA_FAMILY(pi)) ||
			(TINY_RADIO(pi) && !((phy_reg_read(pi,
			ACPHY_perPktIdleTssiCtrlcck(pi->pubpi.phy_rev)) >> 8) & 1))) {
		/* CCK Pwr Index Convergence Correction */
			ppr_dsss_rateset_t dsss;
			uint rate;
			int32 temp;
			ppr_get_dsss(pi->tx_power_offset, WL_TX_BW_20, WL_TX_CHAINS_1, &dsss);
			for (rate = 0; rate < WL_RATESET_SZ_DSSS; rate++) {
				if ((CHIPID_4324X_EPA_FAMILY(pi) &&
					(pi->sh->bphy_sm_fix_opt == 1)) || TINY_RADIO(pi)) {
					temp = (int32)(dsss.pwr[rate]);
					temp += pi->sh->cckPwrIdxCorr;
					dsss.pwr[rate] = (int8)((uint8)temp);
				} else {
					temp = (int32)(-dsss.pwr[rate]);
					temp -= pi_lcn->cckPwrIdxCorr;
					dsss.pwr[rate] = (int8)((uint8)(-temp));
				}
			}
			ppr_set_dsss(pi->tx_power_offset, WL_TX_BW_20, WL_TX_CHAINS_1, &dsss);
		}

	}	/* CORE loop */

#ifdef WLTXPWR_CACHE
	if (wlc_phy_txpwr_cache_is_cached(pi->txpwr_cache, pi->radio_chanspec) == TRUE) {
		wlc_phy_set_cached_pwr(pi->sh->osh, pi->txpwr_cache, pi->radio_chanspec,
			TXPWR_CACHE_POWER_OFFSETS, pi->tx_power_offset);
	}
#endif // endif
	/*
	 * PHY_ERROR(("#####The final power offset limit########\n"));
	 * ppr_mcs_printf(pi->tx_power_offset);
	 */
	ppr_delete(pi->sh->osh, reg_txpwr_limit);
	ppr_delete(pi->sh->osh, tx_pwr_target);
	ppr_delete(pi->sh->osh, srom_max_txpwr);
#if ACCONF && defined(WLC_HIGH) && (defined(WLTEST) || defined(WLPKTENG))
	/* for 4360A/B0, when targetPwr is out of the tssi visibility range,
	 * force the power offset to be the delta between the lower bound of visibility
	 * range and the targetPwr
	 */
	if (pi->txpwroverrideset) {
		if (ISACPHY(pi) && (ACMAJORREV_0(pi->pubpi.phy_rev) ||
		    ((ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) &&
		     pi->disable_olpc == 0))) {
#ifdef WLTXPWR_PER_CORE
			int16 core_delta[WL_TXPWR_CORE_MAX];
			int i;
#endif /* WLTXPWR_PER_CORE */
			int16 base_pwr;

			if (CHSPEC_IS2G(pi->radio_chanspec))
				olpc_anchor = pi->olpc_anchor2g;
			else
				olpc_anchor = pi->olpc_anchor5g;

			if ((olpc_anchor == 0) || (olpc_anchor < pi->olpc_thresh)) {
				base_pwr = wlc_phy_tssivisible_thresh_acphy(pi);
			} else {
				base_pwr = olpc_anchor;
			}
#ifdef WLTXPWR_PER_CORE
			/* XXX FIXME How to define openloop_pwrctrl_delta and tx_power_offset
			 * when tx_user_target is a core indexed array ?
			 * Can we offset the max per core of the eventual diff between
			 * the biggest delta (openloop_pwrctrl_delta) and the delta for that core,
			 * keeping thus one offset only and all core's power higher than
			 * wlc_phy_tssivisible_thresh_acphy ?
			 */
			core_delta[0] = openloop_pwrctrl_delta =
				base_pwr - pi->p_tx_user_target[0];

			for (i = 1; i < WL_TXPWR_CORE_MAX; i++) {
				core_delta[i] =
					base_pwr - pi->p_tx_user_target[i];
				if (core_delta[i] > openloop_pwrctrl_delta) {
					openloop_pwrctrl_delta = core_delta[i];
				}
			}

#else
			openloop_pwrctrl_delta = base_pwr - pi->tx_user_target;
#endif /* WLTXPWR_PER_CORE */

			if ((olpc_anchor == 0) || (olpc_anchor < pi->olpc_thresh)) {
				/* keep only lower byte of the tssi visibility threshold. */
				base_pwr &= 0xff;
			}

			if (openloop_pwrctrl_delta > 0) {
				if (R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC)
					mac_enabled = TRUE;
				ppr_set_cmn_val(pi->tx_power_offset, 0);
				if (CHSPEC_IS2G(pi->radio_chanspec))
					olpc_anchor = pi->olpc_anchor2g;
				else
					olpc_anchor = pi->olpc_anchor5g;
				txpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;
				if (txpwr_recalc_fn)
					(*txpwr_recalc_fn)(pi);

				/* Stop PKTENG if already running.. */
				if (!mac_enabled)
					wlapi_enable_mac(pi->sh->physhim);

				wlapi_bmac_pkteng(pi->sh->physhim, 0, 0);

				OSL_DELAY(100);
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
				/* Turn ON Power Control */
				wlc_phy_txpwrctrl_enable_acphy(pi, 1);

				FOREACH_CORE(pi, core) {
					pi->tx_power_max_per_core[core] =
#ifdef WLTXPWR_PER_CORE
					(uint8)(base_pwr +
						(openloop_pwrctrl_delta - core_delta[core]));
#else
					(uint8)(base_pwr);
#endif /* WLTXPWR_PER_CORE */

					/* Set TX Power here for PKTENG */
					wlc_phy_txpwrctrl_set_target_acphy
						(pi, pi->tx_power_max_per_core[core], core);
				}
#ifdef WLC_TXCAL
				if (!(pi->olpc_idx_valid && pi->olpc_idx_in_use)) {
				/* If table based txcal anchor txidx is used for OLPC, No need to
				 * send out training packets in txpwr ovr mode
				 * Init idx will be set based on cal info from pi->olpc_anchor_idx
				 */
#endif /* WLC_TXCAL */
					wlapi_enable_mac(pi->sh->physhim);

					/* Start PKTENG to settle TX power Control */
					wlapi_bmac_pkteng(pi->sh->physhim, 1, 100);
					OSL_DELAY(1000);
					if (!mac_enabled)
						wlapi_suspend_mac_and_wait(pi->sh->physhim);
					OSL_DELAY(100);
#ifdef WLC_TXCAL
				}
#endif /* WLC_TXCAL */
				/* Toggle Power Control to save off base index */
				wlc_phy_txpwrctrl_enable_acphy(pi, 0);
				if (openloop_pwrctrl_delta > 127) {
					openloop_pwrctrl_delta = 127;
				} else if (openloop_pwrctrl_delta < -128) {
					openloop_pwrctrl_delta = -128;
				}
				ppr_set_cmn_val(pi->tx_power_offset,
					(int8) openloop_pwrctrl_delta);
#ifdef WLTXPWR_CACHE
				wlc_phy_txpwr_cache_invalidate(pi->txpwr_cache);
#endif  /* WLTXPWR_CACHE */
#ifdef WLC_HIGH_ONLY
				wlc_bmac_phy_txpwr_cache_invalidate(wlc->hw);
#endif // endif

				PHY_NONE(("###offset: %d targetPwr %d###\n",
					openloop_pwrctrl_delta,
					pi->tx_power_max_per_core[0]));
			}
		}
		pi->txpwroverrideset = FALSE;
	}
#endif // endif

	/* Don't call the hardware specifics if we were just trying to retrieve the target powers */
	if (txpwr_targets == NULL) {
		txpwr_recalc_fn = pi->pi_fptr.txpwrrecalc;
		if (txpwr_recalc_fn)
			(*txpwr_recalc_fn)(pi);
	}
}

#ifdef BCMDBG
void
wlc_phy_txpower_limits_dump(ppr_t* txpwr, bool ishtphy)
{
	int i;
	char fraction[4][4] = {"   ", ".25", ".5 ", ".75"};
	ppr_dsss_rateset_t dsss_limits;
	ppr_ofdm_rateset_t ofdm_limits;
	ppr_ht_mcs_rateset_t mcs_limits;

	printf("CCK                  ");
	ppr_get_dsss(txpwr, WL_TX_BW_20, WL_TX_CHAINS_1, &dsss_limits);
	for (i = 0; i < WL_RATESET_SZ_DSSS; i++) {
		printf(" %2d%s", dsss_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[dsss_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20MHz OFDM SISO      ");
	ppr_get_ofdm(txpwr, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20MHz OFDM CDD       ");
	ppr_get_ofdm(txpwr, WL_TX_BW_20, WL_TX_MODE_CDD, WL_TX_CHAINS_2, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "20MHz 1 Nsts to 1 Tx " : "20MHz MCS 0-7 SISO   ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "20MHz 1 Nsts to 2 Tx " : "20MHz MCS 0-7 CDD    ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	if (ishtphy) {
		printf("20MHz 1 Nsts to 3 Tx ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_3,
			&mcs_limits);
	} else {
		printf("20MHz MCS 0-7 STBC   ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_2, WL_TX_MODE_STBC, WL_TX_CHAINS_2,
			&mcs_limits);
	}
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "20MHz 2 Nsts to 2 Tx " : "20MHz MCS 8-15 SDM   ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	if (ishtphy) {
		printf("20MHz 2 Nsts to 3 Tx ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_limits);
		for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
			printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
				fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
		}
		printf("\n");

		printf("20MHz 3 Nsts to 3 Tx ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_20, WL_TX_NSS_3, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_limits);
		for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
			printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
				fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
		}
		printf("\n");
	}

	printf("40MHz OFDM SISO      ");
	ppr_get_ofdm(txpwr, WL_TX_BW_40, WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("40MHz OFDM CDD       ");
	ppr_get_ofdm(txpwr, WL_TX_BW_40, WL_TX_MODE_CDD, WL_TX_CHAINS_2, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "40MHz 1 Nsts to 1 Tx " : "40MHz MCS 0-7 SISO   ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "40MHz 1 Nsts to 2 Tx " : "40MHz MCS 0-7 CDD    ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "40MHz 1 Nsts to 3 Tx " : "40MHz MCS 0-7 CDD    ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_3,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("%s", ishtphy ? "40MHz 2 Nsts to 2 Tx " : "40MHz MCS8-15 SDM    ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	if (ishtphy) {
		printf("40MHz 2 Nsts to 3 Tx ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_limits);
		for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
			printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
				fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
		}
		printf("\n");

		printf("40MHz 3 Nsts to 3 Tx ");
		ppr_get_ht_mcs(txpwr, WL_TX_BW_40, WL_TX_NSS_3, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_limits);
		for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
			printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
				fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
		}
		printf("\n");
	}

	if (!ishtphy)
		return;

	printf("20MHz UL CCK         ");
	ppr_get_dsss(txpwr, WL_TX_BW_20IN40, WL_TX_CHAINS_1, &dsss_limits);
	for (i = 0; i < WL_RATESET_SZ_DSSS; i++) {
		printf(" %2d%s", dsss_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[dsss_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20MHz UL OFDM SISO   ");
	ppr_get_ofdm(txpwr, WL_TX_BW_20IN40, WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20MHz UL OFDM CDD    ");
	ppr_get_ofdm(txpwr, WL_TX_BW_20IN40, WL_TX_MODE_CDD, WL_TX_CHAINS_2, &ofdm_limits);
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		printf(" %2d%s", ofdm_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[ofdm_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 1 Nsts to 1 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 1 Nsts to 2 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 1 Nsts to 3 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_3,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 2 Nsts to 2 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 2 Nsts to 3 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");

	printf("20UL 3 Nsts to 3 Tx  ");
	ppr_get_ht_mcs(txpwr, WL_TX_BW_20IN40, WL_TX_NSS_3, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
		&mcs_limits);
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		printf(" %2d%s", mcs_limits.pwr[i]/ WLC_TXPWR_DB_FACTOR,
			fraction[mcs_limits.pwr[i] % WLC_TXPWR_DB_FACTOR]);
	}
	printf("\n");
}

#endif /* BCMDBG */

/* Translates the regulatory power limit array into an array of length TXP_NUM_RATES,
 * which can match the board limit array obtained using the SROM. Moreover, since the NPHY chips
 * currently do not distinguish between Legacy OFDM and MCS0-7, the SISO and CDD regulatory power
 * limits of these rates need to be combined carefully.
 * This internal/static function needs to be called whenever the chanspec or regulatory TX power
 * limits change.
 */
static void
wlc_phy_txpower_reg_limit_calc(phy_info_t *pi, ppr_t *txpwr, chanspec_t chanspec,
	ppr_t *txpwr_limit)
{
	uint k, i;
	ppr_ofdm_rateset_t ofdm_limits;
	ppr_ht_mcs_rateset_t mcs_limits;

	ppr_copy_struct(txpwr, txpwr_limit);

	/* Obtain the regulatory limits for Legacy OFDM and HT-OFDM 11n rates in NPHY chips */
	if (ISNPHY(pi)) {
		wl_tx_bw_t bw = WL_TX_BW_20;
		wl_tx_mode_t mode = WL_TX_MODE_NONE;
		wl_tx_chains_t chains = WL_TX_CHAINS_1;
		/* If NPHY is enabled, then use min of OFDM and MCS_20_SISO values as the regulatory
		 * limit for SISO Legacy OFDM and MCS0-7 rates. Similarly, for 40 MHz SIS0 Legacy
		 * OFDM  and MCS0-7 rates as well as for 20 MHz and 40 MHz CDD Legacy OFDM and
		 * MCS0-7 rates. This is because the current hardware implementation uses common
		 * powers for the 8 Legacy ofdm and 8 mcs0-7 rates, i.e. they share the same power
		 * table. The power table is populated based on the constellation, coding rate, and
		 * transmission mode (SISO/CDD/STBC/SDM). Therefore, care must be taken to match the
		 * constellation and coding rates of the Legacy OFDM and MCS0-7 rates since the 8
		 * Legacy OFDM rates and the 8 MCS0-7 rates do not have a 1-1 correspondence in
		 * these parameters.
		 */

		/* Regulatory limits for Legacy OFDM rates 20 and 40 MHz, SISO and CDD. The
		 * regulatory limits for the corresponding MCS0-7 20 and 40 MHz, SISO and
		 * CDD rates should also be mapped into Legacy OFDM limits and the minimum
		 * of the two limits should be taken for each rate.
		 */
		/* Regulatory limits for MCS0-7 rates 20 and 40 MHz, SISO and CDD. The
		 * regulatory limits for the corresponding Legacy OFDM 20 and 40 MHz, SISO and
		 * CDD rates should also be mapped into MCS0-7 limits and the minimum
		 * of the two limits should be taken for each rate.
		 */
		for (k = 0; k < 6; k++) {
			ppr_ofdm_rateset_t ofdm_from_mcs_limits;
			ppr_ht_mcs_rateset_t mcs_from_ofdm_limits;

			switch (k) {
			case 0:
				/* 20 MHz Legacy OFDM SISO */
				bw = WL_TX_BW_20;
				mode = WL_TX_MODE_NONE;
				chains = WL_TX_CHAINS_1;
				break;
			case 1:
				/* 20 MHz Legacy OFDM CDD */
				bw = WL_TX_BW_20;
				mode = WL_TX_MODE_CDD;
				chains = WL_TX_CHAINS_2;
				break;
			case 2:
				/* 40 MHz Legacy OFDM SISO */
				bw = WL_TX_BW_40;
				mode = WL_TX_MODE_NONE;
				chains = WL_TX_CHAINS_1;
				break;
			case 3:
				/* 40 MHz Legacy OFDM CDD */
				bw = WL_TX_BW_40;
				mode = WL_TX_MODE_CDD;
				chains = WL_TX_CHAINS_2;
				break;
			case 4:
				/* case 4: 20in40 MHz Legacy OFDM SISO */
				bw = WL_TX_BW_20IN40;
				mode = WL_TX_MODE_NONE;
				chains = WL_TX_CHAINS_1;
				break;
			case 5:
				/* 20in40 legacy ofdm cdd */
				bw = WL_TX_BW_20IN40;
				mode = WL_TX_MODE_CDD;
				chains = WL_TX_CHAINS_2;
				break;
			}
			ppr_get_ht_mcs(txpwr, bw, WL_TX_NSS_1, mode, chains, &mcs_limits);
			ppr_get_ofdm(txpwr, bw, mode, chains, &ofdm_limits);

			wlc_phy_copy_mcs_to_ofdm_powers(&mcs_limits, &ofdm_from_mcs_limits);

			wlc_phy_copy_ofdm_to_mcs_powers(&ofdm_limits, &mcs_from_ofdm_limits);

			for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
				if (ofdm_from_mcs_limits.pwr[i] == WL_RATE_DISABLED)
					continue;
				ofdm_limits.pwr[i] = MIN(ofdm_limits.pwr[i],
					ofdm_from_mcs_limits.pwr[i]);
			}

			for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
				if (mcs_from_ofdm_limits.pwr[i] == WL_RATE_DISABLED)
					continue;
				mcs_limits.pwr[i] = MIN(mcs_limits.pwr[i],
					mcs_from_ofdm_limits.pwr[i]);
			}

			ppr_set_ofdm(txpwr_limit, bw, mode, chains, &ofdm_limits);

			ppr_set_ht_mcs(txpwr_limit, bw, WL_TX_NSS_1, mode, chains, &mcs_limits);

		}
	}
}

/* Map Legacy OFDM powers-per-rate to MCS 0-7 powers-per-rate by matching the
 * constellation and coding rate of the corresponding Legacy OFDM and MCS rates. The power
 * of 9 Mbps Legacy OFDM is used for MCS-0 (same as 6 Mbps power) since no equivalent
 * of 9 Mbps exists in the 11n standard in terms of constellation and coding rate.
 */

void
wlc_phy_copy_ofdm_to_mcs_powers(ppr_ofdm_rateset_t* ofdm_limits, ppr_ht_mcs_rateset_t* mcs_limits)
{
	uint rate1;
	uint rate2;

	for (rate1 = 0, rate2 = 1; rate1 < WL_RATESET_SZ_OFDM-1; rate1++, rate2++) {
		mcs_limits->pwr[rate1] = ofdm_limits->pwr[rate2];
	}
	mcs_limits->pwr[rate1] = mcs_limits->pwr[rate1 - 1];
}

/* Map MCS 0-7 powers-per-rate to Legacy OFDM powers-per-rate by matching the
 * constellation and coding rate of the corresponding Legacy OFDM and MCS rates. The power
 * of 9 Mbps Legacy OFDM is set to the power of MCS-0 (same as 6 Mbps power) since no equivalent
 * of 9 Mbps exists in the 11n standard in terms of constellation and coding rate.
 */

void
wlc_phy_copy_mcs_to_ofdm_powers(ppr_ht_mcs_rateset_t* mcs_limits, ppr_ofdm_rateset_t* ofdm_limits)
{
	uint rate1;
	uint rate2;

	ofdm_limits->pwr[0] = mcs_limits->pwr[0];
	for (rate1 = 1, rate2 = 0; rate1 < WL_RATESET_SZ_OFDM; rate1++, rate2++) {
		ofdm_limits->pwr[rate1] = mcs_limits->pwr[rate2];
	}
}

void
wlc_phy_txpwr_percent_set(wlc_phy_t *ppi, uint8 txpwr_percent)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	pi->txpwr_percent = txpwr_percent;
}

void
wlc_phy_machwcap_set(wlc_phy_t *ppi, uint32 machwcap)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	pi->sh->machwcap = machwcap;
}

void
wlc_phy_runbist_config(wlc_phy_t *ppi, bool start_end)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	uint16 rxc;
	rxc = 0;

	if (start_end == ON) {
		if (!ISNPHY(pi) || ISHTPHY(pi))
			return;

		/* Keep pktproc in reset during bist run */
		if (NREV_IS(pi->pubpi.phy_rev, 3) || NREV_IS(pi->pubpi.phy_rev, 4)) {
			rxc = phy_reg_read(pi, NPHY_RxControl);
			phy_reg_write(pi, NPHY_RxControl,
			      NPHY_RxControl_dbgpktprocReset_MASK | rxc);
		}
	} else {
		if (ISNPHY(pi) && (NREV_IS(pi->pubpi.phy_rev, 3) ||
			NREV_IS(pi->pubpi.phy_rev, 4))) {
			phy_reg_write(pi, NPHY_RxControl, rxc);
		}

		wlc_phy_por_inform(ppi);
	}
}

/* Set tx power limits */
/* BMAC_NOTE: this only needs a chanspec so that it can choose which 20/40 limits
 * to save in phy state. Would not need this if we ether saved all the limits and
 * applied them only when we were on the correct channel, or we restricted this fn
 * to be called only when on the correct channel.
 */
/* FTODO make sure driver functions are calling this version */
void
wlc_phy_txpower_limit_set(wlc_phy_t *ppi, ppr_t *txpwr, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t*)ppi;
#ifdef TXPWR_TIMING
	int time1, time2;
	time1 = hndrte_time_us();
#endif // endif
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phy_txpower_recalc_target(pi, txpwr, NULL);
	wlc_phy_cal_txpower_recalc_sw(pi);
	wlapi_enable_mac(pi->sh->physhim);

#ifdef TXPWR_TIMING
	time2 = hndrte_time_us();
	wlc_phy_txpower_limit_set_time = time2 - time1;
#endif // endif
}

void
wlc_phy_ofdm_rateset_war(wlc_phy_t *pih, bool war)
{
	phy_info_t *pi = (phy_info_t*)pih;

	pi->ofdm_rateset_war = war;
}

void
wlc_phy_bf_preempt_enable(wlc_phy_t *pih, bool bf_preempt)
{
	phy_info_t *pi = (phy_info_t*)pih;
	if (ISABGPHY(pi))
		pi->u.pi_abgphy->bf_preempt_4306 = bf_preempt;
}

/*
 * For SW based power control, target power represents CCK and ucode reduced OFDM by the opo.
 * For hw based power control, we lower the target power so it represents OFDM and
 * ucode boosts CCK by the opo.
 */
void
wlc_phy_txpower_update_shm(phy_info_t *pi)
{
	int j;
	if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi) || ISSSLPNPHY(pi)) {
		PHY_ERROR(("%s is for legacy phy\n", __FUNCTION__));
		ASSERT(0);
		return;
	}

	if (!pi->sh->clk)
		return;
	if (!pi->tx_power_offset)
		return;
	if (pi->hwpwrctrl) {
		uint16 offset;
		ppr_ofdm_rateset_t ofdm_offsets;
		ppr_get_ofdm(pi->tx_power_offset, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
			&ofdm_offsets);

		/* Rate based ucode power control */
		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_MAX, 63);
		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_N, 1 << NUM_TSSI_FRAMES);

		/* Need to lower the target power to OFDM level, then add boost for CCK. */
		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_TARGET,
			wlc_phy_txpower_get_target_min((wlc_phy_t*)pi) << NUM_TSSI_FRAMES);

		wlapi_bmac_write_shm(pi->sh->physhim, M_TXPWR_CUR, pi->hwpwr_txcur);

		/* CCK */
		if (ISGPHY(pi)) {
			const uint8 ucode_cck_rates[] =
			        { /*	   1,    2,  5.5,   11 Mbps */
					0x02, 0x04, 0x0b, 0x16
				};
			ppr_dsss_rateset_t dsss_offsets;

			ppr_get_dsss(pi->tx_power_offset,
				WL_TX_BW_20, WL_TX_CHAINS_1, &dsss_offsets);
			PHY_TXPWR(("M_RATE_TABLE_B:\n"));
			for (j = 0; j < WL_RATESET_SZ_DSSS; j++) {
				offset = wlapi_bmac_rate_shm_offset(pi->sh->physhim,
					ucode_cck_rates[j]);
				wlapi_bmac_write_shm(pi->sh->physhim, offset + 6,
				                   dsss_offsets.pwr[j]);
				PHY_TXPWR(("[0x%x] = 0x%x\n", offset + 6, dsss_offsets.pwr[j]));

				wlapi_bmac_write_shm(pi->sh->physhim, offset + 14,
				                   -(dsss_offsets.pwr[j] / 2));
				PHY_TXPWR(("[0x%x] = 0x%x\n", offset + 14,
				          -(dsss_offsets.pwr[j] / 2)));
			}

			if (pi->ofdm_rateset_war) {
				offset = wlapi_bmac_rate_shm_offset(pi->sh->physhim,
					ucode_cck_rates[0]);
				wlapi_bmac_write_shm(pi->sh->physhim, offset + 6, 0);
				PHY_TXPWR(("[0x%x] = 0x%x (ofdm rateset war)\n", offset + 6, 0));
				wlapi_bmac_write_shm(pi->sh->physhim, offset + 14, 0);
				PHY_TXPWR(("[0x%x] = 0x%x (ofdm rateset war)\n", offset + 14, 0));
			}
		}

		/* OFDM */
		PHY_TXPWR(("M_RATE_TABLE_A:\n"));
		for (j = 0; j < WL_RATESET_SZ_OFDM; j++) {
			const uint8 ucode_ofdm_rates[] =
			        { /*	   6,   9,    12,   18,   24,   36,   48,   54 Mbps */
					0x0c, 0x12, 0x18, 0x24, 0x30, 0x48, 0x60, 0x6c
				};
			offset = wlapi_bmac_rate_shm_offset(pi->sh->physhim,
				ucode_ofdm_rates[j]);
			wlapi_bmac_write_shm(pi->sh->physhim, offset + 6, ofdm_offsets.pwr[j]);
			PHY_TXPWR(("[0x%x] = 0x%x\n", offset + 6, ofdm_offsets.pwr[j]));
			wlapi_bmac_write_shm(pi->sh->physhim, offset + 14,
				-(ofdm_offsets.pwr[j] / 2));
			PHY_TXPWR(("[0x%x] = 0x%x\n", offset + 14, -(ofdm_offsets.pwr[j] / 2)));
		}
		wlapi_bmac_mhf(pi->sh->physhim, MHF2, MHF2_PPR_HWPWRCTL, MHF2_PPR_HWPWRCTL,
		               WLC_BAND_ALL);
	} else {
		int i;

		/* ucode has 2 db granularity when doing sw pwrctrl,
		 * so round up to next 8 .25 units = 2 db.
		 *   HW based power control has .25 db granularity
		 */
		/* Populate only OFDM power offsets, since ucode can only offset OFDM packets */
		ppr_ofdm_rateset_t ofdm_offsets;

		ppr_get_ofdm(pi->tx_power_offset, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
			&ofdm_offsets);
		for (i = 0; i < WL_RATESET_SZ_OFDM; i++)
			ofdm_offsets.pwr[i] = (uint8)ROUNDUP(ofdm_offsets.pwr[i], 8);
		ppr_set_ofdm(pi->tx_power_offset, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
			&ofdm_offsets);
		wlapi_bmac_write_shm(pi->sh->physhim, M_OFDM_OFFSET,
			(uint16)((ofdm_offsets.pwr[0] + 7) >> 3));
	}
}

bool
wlc_phy_txpower_hw_ctrl_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISNPHY(pi)) {
		return pi->nphy_txpwrctrl;
	} else if (ISHTPHY(pi) || ISACPHY(pi)) {
		return pi->txpwrctrl;
	} else {
		return pi->hwpwrctrl;
	}
}

/* XXX MUST REVIEW MUST REVIEW MUST REVIEW; why is old NPHY off different than
 * restore logic in the off case???? johnvb
 *
 * Old "off" code did NOTHING to turn power control off other then set a
 * structure variable (probably a bug) but looks like it might have been
 * trying to do this (dead) code to turn it off.
 *
 * OFF:
 *		phy_reg_and(pi, NPHY_TxPwrCtrlCmd,
 * 			(uint16) ~NPHY_TxPwrCtrlCmd_txPwrCtrl_en_MASK);
 * 		wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
 *
 * Old "restore" code had this logic to turn power control OFF or ON:
 *
 * OFF:
 *		-- FIXME, to restore previous pwrindex
 *		wlc_phy_txpwr_fixpower_nphy(pi);
 * ON:
 * 		-- turn on power control --
 *		wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_ON);
 *
 * What is the correct way to do this?
 *
 * Do we need to set power index's/save power index's?
 *
 * We are trying to implement a single set function (not a save and restore).
 * This might mean we need to internally keep some state information
 * including whether we have any information yet.  Of course this information
 * would need to be initialized at some appropriate place.
 *
 * When would that logically be?  (phy attach, init, etc)
 *
 */
void
wlc_phy_txpower_hw_ctrl_set(wlc_phy_t *ppi, bool hwpwrctrl)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	bool cur_hwpwrctrl = pi->hwpwrctrl;
	bool suspend;

	/* validate if hardware power control is capable */
	if (!pi->hwpwrctrl_capable) {
		PHY_ERROR(("wl%d: hwpwrctrl not capable\n", pi->sh->unit));
		return;
	}

	PHY_INFORM(("wl%d: setting the hwpwrctrl to %d\n", pi->sh->unit, hwpwrctrl));
	pi->hwpwrctrl = hwpwrctrl;
	pi->nphy_txpwrctrl = hwpwrctrl;
	pi->txpwrctrl = hwpwrctrl;

	/* if power control mode is changed, propagate it */
	if (ISNPHY(pi)) {
		suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
		if (!suspend)
			wlapi_suspend_mac_and_wait(pi->sh->physhim);

		/* turn on/off power control */
		wlc_phy_txpwrctrl_enable_nphy(pi, pi->nphy_txpwrctrl);
		if (pi->nphy_txpwrctrl == PHY_TPC_HW_OFF) {
			wlc_phy_txpwr_fixpower_nphy(pi);
		} else {
			/* restore the starting txpwr index */
			phy_reg_mod(pi, NPHY_TxPwrCtrlCmd, NPHY_TxPwrCtrlCmd_pwrIndex_init_MASK,
			            pi->saved_txpwr_idx);
		}

		if (!suspend)
			wlapi_enable_mac(pi->sh->physhim);
	} else if (ISHTPHY(pi)) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

		/* turn on/off power control */
		wlc_phy_txpwrctrl_enable_htphy(pi, pi->txpwrctrl);

		wlapi_enable_mac(pi->sh->physhim);
	} else if (hwpwrctrl != cur_hwpwrctrl) {
		/* save, change and restore tx power control */

		if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
			return;

		} else if (ISABGPHY(pi)) {
			wlc_phy_txpower_hw_ctrl_set_abgphy(pi);
		}
	}
}

#ifdef BCM_OL_DEV
void
wlc_phy_sarlimit_write(wlc_phy_t *pih, uint32 sar)
{
	phy_info_t *pi = (phy_info_t *)pih;
	uint core;

	if (ISACPHY(pi)) {
		FOREACH_CORE(pi, core) {
			pi->sarlimit[core] = sar & 0xff;
			sar >>= 8;
		}
		wlc_phy_set_sarlimit_acphy(pi);
	}
}

void
wlc_phy_curpwr_write(wlc_phy_t *pih, uint8 curpwr)
{
	phy_info_t *pi = (phy_info_t *)pih;
	uint core;

	if (ISACPHY(pi)) {
		FOREACH_CORE(pi, core) {
			pi->tx_power_max_per_core[core] = curpwr;
			wlc_phy_txpwrctrl_set_target_acphy(pi,
				pi->tx_power_max_per_core[core], core);
			curpwr >>= 8;
		}
	}
}
#endif /* BCM_OL_DEV */

#ifdef WL_SARLIMIT
static void
wlc_phy_sarlimit_set_int(phy_info_t *pi, int8 *sar)
{
	uint core;

	FOREACH_CORE(pi, core) {
		pi->sarlimit[core] =
			MAX((sar[core] - pi->tx_pwr_backoff), pi->min_txpower);
	}
	if (ISACPHY(pi) && pi->sh->clk) {
		wlc_phy_set_sarlimit_acphy(pi);
	}
}
#endif /* WL_SARLIMIT */

void
wlc_phy_txpower_ipa_upd(phy_info_t *pi)
{
	/* this should be expanded to work with all new PHY capable of iPA */
	if (ISACPHY(pi)) {
		pi->ipa2g_on = ((pi->sh->epagain2g == 2) || (pi->sh->extpagain2g == 2));
		pi->ipa5g_on = ((pi->sh->epagain5g == 2) || (pi->sh->extpagain5g == 2));
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
		pi->ipa2g_on = (pi->fem2g.extpagain == 2);
		pi->ipa5g_on = (pi->fem5g.extpagain == 2);
	} else {
		pi->ipa2g_on = FALSE;
		pi->ipa5g_on = FALSE;
	}
	PHY_INFORM(("wlc_phy_txpower_ipa_upd: ipa 2g %d, 5g %d\n", pi->ipa2g_on, pi->ipa5g_on));
}

void
wlc_phy_txpower_get_current(wlc_phy_t *ppi, ppr_t *reg_pwr, phy_tx_power_t *power)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint8 min_pwr, core;

	if (ISNPHY(pi)) {
		power->rf_cores = 2;
		power->flags |= (WL_TX_POWER_F_MIMO);
		if (pi->nphy_txpwrctrl == PHY_TPC_HW_ON)
			power->flags |= (WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);
	} else if (ISHTPHY(pi)) {
		power->rf_cores = PHYCORENUM(pi->pubpi.phy_corenum);
		power->flags |= (WL_TX_POWER_F_MIMO);
		if (pi->txpwrctrl == PHY_TPC_HW_ON)
			power->flags |= (WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);
	} else if (ISACPHY(pi)) {
		power->rf_cores = PHYCORENUM(pi->pubpi.phy_corenum);
		power->flags |= (WL_TX_POWER_F_MIMO);
		if (pi->txpwrctrl == PHY_TPC_HW_ON)
			power->flags |= (WL_TX_POWER_F_ENABLED | WL_TX_POWER_F_HW);
	} else if (ISSSLPNPHY(pi)) {
		power->rf_cores = 1;
		power->flags |= (WL_TX_POWER_F_SISO);
		if (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)
			power->flags |= WL_TX_POWER_F_ENABLED;
		if (pi->hwpwrctrl)
			power->flags |= WL_TX_POWER_F_HW;
	}
	else if (ISLCNCOMMONPHY(pi)) {
		power->rf_cores = 1;
		power->flags |= (WL_TX_POWER_F_SISO);
		if (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)
			power->flags |= WL_TX_POWER_F_ENABLED;
		if (pi->hwpwrctrl)
			power->flags |= WL_TX_POWER_F_HW;
	} else {
		power->rf_cores = 1;
		if (pi->radiopwr_override == RADIOPWR_OVERRIDE_DEF)
			power->flags |= WL_TX_POWER_F_ENABLED;
		if (pi->hwpwrctrl)
			power->flags |= WL_TX_POWER_F_HW;
	}

	{
		ppr_t *txpwr_srom;

		if ((txpwr_srom = ppr_create(pi->sh->osh, PPR_CHSPEC_BW(pi->radio_chanspec))) !=
			NULL) {
			wlc_phy_txpower_sromlimit(ppi, pi->radio_chanspec, &min_pwr, txpwr_srom, 0);

			ppr_copy_struct(txpwr_srom, power->ppr_board_limits);

			ppr_delete(pi->sh->osh, txpwr_srom);
		}
	}
	/* reuse txpwr for target */
	wlc_phy_txpower_recalc_target(pi, reg_pwr, power->ppr_target_powers);
	power->display_core = pi->curpower_display_core;

	/* fill the est_Pout, max target power, and rate index corresponding to the max
	 * target power fields
	 */

	wlc_phy_get_est_pout(ppi, power->est_Pout, power->est_Pout_act, &power->est_Pout_cck);

	if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		/* Store the maximum target power among all rates */
		FOREACH_CORE(pi, core) {
			power->tx_power_max[core] = pi->tx_power_max_per_core[core];
		}
	} else if (pi->hwpwrctrl && pi->sh->up) {
		/* If hw (ucode) based, read the hw based estimate in realtime */
		wlc_phyreg_enter(ppi);
		if (ISLPPHY(pi)) {
			if (wlc_phy_tpc_isenabled_lpphy(pi))
				power->flags |= (WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
			else
				power->flags &= ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
		} else if (ISSSLPNPHY(pi)) {
			/* Store the maximum target power among all rates */
			power->tx_power_max[0] = pi->tx_power_max_per_core[0];
			power->tx_power_max[1] = pi->tx_power_max_per_core[0];
			if (wlc_phy_tpc_isenabled_sslpnphy(pi))
				power->flags |= (WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
			else
				power->flags &= ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
		} else if (ISLCNPHY(pi)) {
			/* Store the maximum target power among all rates */
			power->tx_power_max[0] = pi->tx_power_max_per_core[0];
			power->tx_power_max[1] = pi->tx_power_max_per_core[0];

			if (wlc_phy_tpc_isenabled_lcnphy(pi))
				power->flags |= (WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
			else
				power->flags &= ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);

			wlc_lcnphy_get_tssi(pi, (int8*)&power->est_Pout[0],
				(int8*)&power->est_Pout_cck);
		} else if (ISLCN40PHY(pi)) {
			/* Store the maximum target power among all rates */
			power->tx_power_max[0] = pi->tx_power_max_per_core[0];
			power->tx_power_max[1] = pi->tx_power_max_per_core[0];
			if (pi->pi_fptr.ishwtxpwrctrl && pi->pi_fptr.ishwtxpwrctrl(pi))
				power->flags |= (WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
			else
				power->flags &= ~(WL_TX_POWER_F_HW | WL_TX_POWER_F_ENABLED);
		}
		wlc_phyreg_exit(ppi);
	}
#ifdef WL_SARLIMIT
	FOREACH_CORE(pi, core) {
		if (ISACPHY(pi))
			power->SARLIMIT[core] = pi->sarlimit[core];
		else
			power->SARLIMIT[core] = WLC_TXPWR_MAX;
	}
#endif // endif
}

void wlc_phy_get_tssi_sens_min(wlc_phy_t *ppi, int8 *tssiSensMinPwr)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISACPHY(pi)) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_get_tssisens_min_acphy(pi, tssiSensMinPwr);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
	}
}

void wlc_phy_get_est_pout(wlc_phy_t *ppi, uint8* est_Pout, uint8* est_Pout_adj, uint8* est_Pout_cck)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	*est_Pout_cck = 0;
	/* fill the est_Pout array */
	if (ISNPHY(pi)) {
		uint32 est_pout;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
			est_pout = wlc_phy_txpower_est_power_lcnxn_rev3(pi);
		else
			est_pout = wlc_phy_txpower_est_power_nphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);

		/* Store the adjusted  estimated powers */
		est_Pout_adj[0] = (est_pout >> 8) & 0xff;
		est_Pout_adj[1] = est_pout & 0xff;

		/* Store the actual estimated powers without adjustment */
		est_Pout[0] = est_pout >> 24;
		est_Pout[1] = (est_pout >> 16) & 0xff;

		/* if invalid, return 0 */
		if (est_Pout[0] == 0x80)
			est_Pout[0] = 0;
		if (est_Pout[1] == 0x80)
			est_Pout[1] = 0;

		/* if invalid, return 0 */
		if (est_Pout_adj[0] == 0x80)
			est_Pout_adj[0] = 0;
		if (est_Pout_adj[1] == 0x80)
			est_Pout_adj[1] = 0;

	} else if (ISHTPHY(pi)) {
		/* Get power estimates */
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_txpwr_est_pwr_htphy(pi, est_Pout, est_Pout_adj);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);

	} else if (ISACPHY(pi)) {
		/* Get power estimates */
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_txpwr_est_pwr_acphy(pi, est_Pout, est_Pout_adj);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);

	} else if (!pi->hwpwrctrl) {
		/* If sw power control, grab the stashed value */
		if (ISGPHY(pi)) {
			ppr_ofdm_rateset_t ofdm_offsets;

			ppr_get_ofdm(pi->tx_power_offset,
				WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm_offsets);
			est_Pout[0] = pi->txpwr_est_Pout - ofdm_offsets.pwr[0];
			*est_Pout_cck = pi->txpwr_est_Pout;
		}
		else if (ISAPHY(pi))
			est_Pout[0] = pi->txpwr_est_Pout;
	} else if (pi->sh->up) {
		/* If hw (ucode) based, read the hw based estimate in realtime */
		wlc_phyreg_enter(ppi);
		if (ISGPHY(pi)) {
			*est_Pout_cck = phy_reg_read(pi, BPHY_TX_EST_PWR) & 0xff;
			est_Pout[0] = phy_reg_read(pi, GPHY_TO_APHY_OFF + APHY_RSSI_FILT_A2) & 0xff;
		} else if (ISLPPHY(pi)) {
			wlc_phy_get_tssi_lpphy(pi, (int8*)&est_Pout[0], (int8*)est_Pout_cck);
		} else if (ISSSLPNPHY(pi)) {
			wlc_sslpnphy_get_tssi(pi, (int8*)&est_Pout[0], (int8*)est_Pout_cck);
		} else if (ISLCNPHY(pi)) {
			wlc_lcnphy_get_tssi(pi, (int8*)&est_Pout[0], (int8*)est_Pout_cck);
		} else if (ISLCN40PHY(pi)) {
			wlc_lcn40phy_get_tssi(pi, (int8*)&est_Pout[0], (int8*)est_Pout_cck);
			est_Pout_adj[0] = est_Pout[0];
		} else if (ISAPHY(pi))
			est_Pout[0] = phy_reg_read(pi, APHY_RSSI_FILT_A2) & 0xff;
		wlc_phyreg_exit(ppi);
	}
}

#if defined(BCMDBG) || defined(WLTEST) || defined(BCMCCX)
/* Return the current instantaneous est. power
 * For swpwr ctrl it's based on current TSSI value (as opposed to average)
 * Mainly used by mfg.
 */
static void
wlc_phy_txpower_get_instant(phy_info_t *pi, void *pwr)
{
	tx_inst_power_t *power = (tx_inst_power_t *)pwr;
	/* If sw power control, grab the instant value based on current TSSI Only
	 * If hw based, read the hw based estimate in realtime
	 */
	if (ISLPPHY(pi)) {
		if (!pi->hwpwrctrl)
			return;

		wlc_phy_get_tssi_lpphy(pi, (int8*)&power->txpwr_est_Pout_gofdm,
			(int8*)&power->txpwr_est_Pout[0]);
		power->txpwr_est_Pout[1] = power->txpwr_est_Pout_gofdm;

	} else if (ISSSLPNPHY(pi)) {
		if (!pi->hwpwrctrl)
			return;

		wlc_sslpnphy_get_tssi(pi, (int8*)&power->txpwr_est_Pout_gofdm,
			(int8*)&power->txpwr_est_Pout[0]);
		power->txpwr_est_Pout[1] = power->txpwr_est_Pout_gofdm;

	} else if (ISLCNPHY(pi)) {
		if (!pi->hwpwrctrl)
			return;

		wlc_lcnphy_get_tssi(pi, (int8*)&power->txpwr_est_Pout_gofdm,
			(int8*)&power->txpwr_est_Pout[0]);
		power->txpwr_est_Pout[1] = power->txpwr_est_Pout_gofdm;

	} else if (ISLCN40PHY(pi)) {
		if (!pi->hwpwrctrl)
			return;

		wlc_lcn40phy_get_tssi(pi, (int8*)&power->txpwr_est_Pout_gofdm,
			(int8*)&power->txpwr_est_Pout[0]);
		power->txpwr_est_Pout[1] = power->txpwr_est_Pout_gofdm;

	} else if (ISABGPHY(pi)) {
		wlc_phy_txpower_get_instant_abgphy(pi, pwr);
	}

}
#endif // endif

#if defined(BCMDBG) || defined(WLTEST)
int
wlc_phy_test_init(phy_info_t *pi, int channel, bool txpkt)
{
	if (channel > MAXCHANNEL)
		return BCME_OUTOFRANGECHAN;

	wlc_phy_chanspec_set((wlc_phy_t*)pi, CH20MHZ_CHSPEC(channel));

	/* stop any requests from the stack and prevent subsequent thread */
	pi->phytest_on = TRUE;

	if (ISLPPHY(pi)) {

		wlc_phy_init_test_lpphy(pi);

	} else if (ISSSLPNPHY(pi)) {

		wlc_phy_init_test_sslpnphy(pi);

	} else if (ISLCNPHY(pi)) {

		wlc_phy_init_test_lcnphy(pi);

	} else if (ISLCN40PHY(pi)) {

		wlc_phy_init_test_lcn40phy(pi);

	} else if (ISGPHY(pi)) {
		/* Disable rx */
		pi->tr_loss_ctl = phy_reg_read(pi, BPHY_TR_LOSS_CTL);
		pi->rf_override = phy_reg_read(pi, BPHY_RF_OVERRIDE);
		phy_reg_or(pi, BPHY_RF_OVERRIDE, (uint16)0x8000);
		wlc_synth_pu_war(pi, channel);
	} else if (ISACPHY(pi)) {
		wlc_phy_init_test_acphy(pi);
	}

	/* Force WLAN antenna */
	wlc_btcx_override_enable(pi);

	return 0;
}

int
wlc_phy_test_stop(phy_info_t *pi)
{
	if (pi->phytest_on == FALSE)
		return 0;

	/* stop phytest mode */
	pi->phytest_on = FALSE;

	/* For NPHY, phytest register needs to be accessed only via phy and not directly */
	if (ISNPHY(pi)) {
		/* XXX PR39573: clean up 2G regs. For 5G, bypass
		 *  cleanup, assuming active phytest doesn't come from bphy
		 */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			phy_reg_and(pi, (NPHY_TO_BPHY_OFF + BPHY_TEST), 0xfc00);
			if (NREV_GE(pi->pubpi.phy_rev, 3))
				/* BPHY_DDFS_ENABLE is removed in mimophy rev 3 */
				phy_reg_write(pi, NPHY_bphytestcontrol, 0x0);
			else
				phy_reg_write(pi, NPHY_TO_BPHY_OFF + BPHY_DDFS_ENABLE, 0);
		}
	} else if (ISHTPHY(pi)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_AND_RAW_ENTRY(HTPHY_TO_BPHY_OFF + BPHY_TEST, 0xfc00)
				PHY_REG_WRITE_RAW_ENTRY(HTPHY_bphytestcontrol, 0x0)
			PHY_REG_LIST_EXECUTE(pi);
		}
	} else if (ISACPHY(pi)) {
#define ACPHY_TO_BPHY_OFF       0x3A1
#define ACPHY_BPHY_TEST         0x08
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_AND_RAW_ENTRY(ACPHY_TO_BPHY_OFF + ACPHY_BPHY_TEST, 0xfc00)
				PHY_REG_WRITE_RAW_ENTRY(ACPHY_bphytestcontrol(pi->pubpi.phy_rev),
					0x0)
			PHY_REG_LIST_EXECUTE(pi);
		}
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	} else if (ISLPPHY(pi)) {
		/* Just ignore the phytest reg, it's not currently used for LPPHY */
	} else if (ISSSLPNPHY(pi)) {
		/* Do nothing */
	} else if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
		PHY_TRACE(("%s:***CHECK***\n", __FUNCTION__));
	} else {
		AND_REG(pi->sh->osh, &pi->regs->phytest, 0xfc00);
		phy_reg_write(pi, BPHY_DDFS_ENABLE, 0);
	}

	/* Restore these registers */
	if (ISGPHY(pi)) {
		phy_reg_write(pi, BPHY_TR_LOSS_CTL, pi->tr_loss_ctl);
		phy_reg_write(pi, BPHY_RF_OVERRIDE, pi->rf_override);
	}

	return 0;
}

/*
 * Rate is number of 500 Kb units.
 */
static int
wlc_phy_test_evm(phy_info_t *pi, int channel, uint rate, int txpwr)
{
	d11regs_t *regs = pi->regs;
	uint16 reg = 0;
	int bcmerror = 0;

	/* stop any test in progress */
	wlc_phy_test_stop(pi);

	/* channel 0 means restore original contents and end the test */
	if (channel == 0) {
		if (ISNPHY(pi))
			phy_reg_write(pi, (NPHY_TO_BPHY_OFF + BPHY_TEST),
			              pi->evm_phytest);
		else if (ISLPPHY(pi)) {
			phy_reg_write(pi, LPPHY_bphyTest, pi->evm_phytest);
			phy_reg_write(pi, LPPHY_ClkEnCtrl, 0);
			wlc_phy_tx_pu_lpphy(pi, 0);
		} else if (ISSSLPNPHY(pi)) {
			phy_reg_write(pi, SSLPNPHY_bphyTest, pi->evm_phytest);
			phy_reg_write(pi, SSLPNPHY_ClkEnCtrl, 0);
			wlc_sslpnphy_tx_pu(pi, 0);
		} else if (ISLCNPHY(pi)) {
			phy_reg_write(pi, LCNPHY_bphyTest, pi->evm_phytest);
			phy_reg_write(pi, LCNPHY_ClkEnCtrl, 0);
			wlc_lcnphy_tx_pu(pi, 0);
		} else if (ISLCN40PHY(pi)) {
			phy_reg_write(pi, LCN40PHY_bphyTest, pi->evm_phytest);
			phy_reg_write(pi, LCN40PHY_ClkEnCtrl, 0);
			wlc_lcn40phy_tx_pu(pi, 0);
		} else 	if (ISHTPHY(pi))
			wlc_phy_bphy_testpattern_htphy(pi, HTPHY_TESTPATTERN_BPHY_EVM, reg, FALSE);
		 else
			W_REG(pi->sh->osh, &regs->phytest, pi->evm_phytest);

		pi->evm_phytest = 0;

		/* Restore 15.6 Mhz nominal fc Tx LPF */
		if (ISABGPHY(pi)) {
			if (pi->u.pi_abgphy->sbtml_gm &&
			        (RADIOID(pi->pubpi.radioid) == BCM2050_ID)) {
				or_radio_reg(pi, RADIO_2050_TX_CTL0, 0x4);
			}
		}

		if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_PACTRL) {
			W_REG(pi->sh->osh, &pi->regs->psm_gpio_out, pi->evm_o);
			W_REG(pi->sh->osh, &pi->regs->psm_gpio_oe, pi->evm_oe);
			OSL_DELAY(1000);
		}
		return 0;
	}

	if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_PACTRL) {
		PHY_INFORM(("wl%d: %s: PACTRL boardflag set, clearing gpio 0x%04x\n",
			pi->sh->unit, __FUNCTION__, BOARD_GPIO_PACTRL));
		/* Store initial values */
		pi->evm_o = R_REG(pi->sh->osh, &pi->regs->psm_gpio_out);
		pi->evm_oe = R_REG(pi->sh->osh, &pi->regs->psm_gpio_oe);
		AND_REG(pi->sh->osh, &regs->psm_gpio_out, ~BOARD_GPIO_PACTRL);
		OR_REG(pi->sh->osh, &regs->psm_gpio_oe, BOARD_GPIO_PACTRL);
		OSL_DELAY(1000);
	}

	if ((bcmerror = wlc_phy_test_init(pi, channel, TRUE)))
		return bcmerror;

	if (ISABGPHY(pi)) {
		if (pi->u.pi_abgphy->sbtml_gm && (RADIOID(pi->pubpi.radioid) == BCM2050_ID)) {
			/* Disable 15.6 Mhz nominal fc Tx LPF */
			and_radio_reg(pi, RADIO_2050_TX_CTL0, ~4);
		}
	}

	reg = TST_TXTEST_RATE_2MBPS;
	switch (rate) {
	case 2:
		reg = TST_TXTEST_RATE_1MBPS;
		break;
	case 4:
		reg = TST_TXTEST_RATE_2MBPS;
		break;
	case 11:
		reg = TST_TXTEST_RATE_5_5MBPS;
		break;
	case 22:
		reg = TST_TXTEST_RATE_11MBPS;
		break;
	}
	reg = (reg << TST_TXTEST_RATE_SHIFT) & TST_TXTEST_RATE;

	PHY_INFORM(("wlc_evm: rate = %d, reg = 0x%x\n", rate, reg));

	/* Save original contents */
	if (pi->evm_phytest == 0 && !ISHTPHY(pi)) {
		if (ISNPHY(pi))
			pi->evm_phytest = phy_reg_read(pi,
			                               (NPHY_TO_BPHY_OFF + BPHY_TEST));
		else if (ISLPPHY(pi)) {
			pi->evm_phytest = phy_reg_read(pi, LPPHY_bphyTest);
			phy_reg_write(pi, LPPHY_ClkEnCtrl, 0xffff);
		} else if (ISSSLPNPHY(pi)) {
			pi->evm_phytest = phy_reg_read(pi, SSLPNPHY_bphyTest);
			phy_reg_write(pi, SSLPNPHY_ClkEnCtrl, 0xffff);
		} else if (ISLCNPHY(pi)) {
			pi->evm_phytest = phy_reg_read(pi, LCNPHY_bphyTest);
			phy_reg_write(pi, LCNPHY_ClkEnCtrl, 0xffff);
		} else if (ISLCN40PHY(pi)) {
			pi->evm_phytest = phy_reg_read(pi, LCN40PHY_bphyTest);
			phy_reg_write(pi, LCN40PHY_ClkEnCtrl, 0xffff);
		} else
			pi->evm_phytest = R_REG(pi->sh->osh, &regs->phytest);
	}

	/* Set EVM test mode */
	if (ISHTPHY(pi)) {
		wlc_phy_bphy_testpattern_htphy(pi, NPHY_TESTPATTERN_BPHY_EVM, reg, TRUE);
	} else if (ISNPHY(pi)) {
		phy_reg_and(pi, (NPHY_TO_BPHY_OFF + BPHY_TEST),
		            ~(TST_TXTEST_ENABLE|TST_TXTEST_RATE|TST_TXTEST_PHASE));
		phy_reg_or(pi, (NPHY_TO_BPHY_OFF + BPHY_TEST), TST_TXTEST_ENABLE | reg);
	} else if (ISLPPHY(pi)) {
		phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;
		if (LPREV_GE(pi->pubpi.phy_rev, 2))
			wlc_phy_tx_dig_filt_cck_setup_lpphy(pi, TRUE);
		if (pi_lp->lpphy_use_cck_dig_loft_coeffs) {
#if defined(PHYCAL_CACHING)
			ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
			ASSERT(ctx);
			wlc_phy_set_tx_locc_lpphy(pi, ctx->u.lpphy_cache.didq_cck);
#else
			wlc_phy_set_tx_locc_lpphy(pi, pi_lp->lpphy_cal_results.didq_cck);
#endif // endif
		}
		wlc_phy_tx_pu_lpphy(pi, 1);
		phy_reg_or(pi, LPPHY_bphyTest, 0x128);
	} else if (ISSSLPNPHY(pi)) {
		wlc_sslpnphy_tx_pu(pi, 1);
		phy_reg_or(pi, SSLPNPHY_bphyTest, 0x128);
	} else if (ISLCNPHY(pi)) {
		wlc_lcnphy_tx_pu(pi, 1);
		phy_reg_or(pi, LCNPHY_bphyTest, 0x128);
	} else if ISLCN40PHY(pi) {
		wlc_lcn40phy_tx_pu(pi, 1);
		phy_reg_or(pi, LCN40PHY_bphyTest, 0x128);
	} else {
		AND_REG(pi->sh->osh, &regs->phytest,
		        ~(TST_TXTEST_ENABLE|TST_TXTEST_RATE|TST_TXTEST_PHASE));
		OR_REG(pi->sh->osh, &regs->phytest, TST_TXTEST_ENABLE | reg);
	}
	return 0;
}

static int
wlc_phy_test_carrier_suppress(phy_info_t *pi, int channel)
{
	d11regs_t *regs = pi->regs;
	int bcmerror = 0;
	phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;
	phy_info_sslpnphy_t *pi_sslpn = pi->u.pi_sslpnphy;

	/* stop any test in progress */
	wlc_phy_test_stop(pi);

	/* channel 0 means restore original contents and end the test */
	if (channel == 0) {
		if (ISNPHY(pi)) {
			phy_reg_write(pi, (NPHY_TO_BPHY_OFF + BPHY_TEST),
			              pi->car_sup_phytest);
		} else if (ISLPPHY(pi)) {
			/* Disable carrier suppression */
			phy_reg_write(pi, LPPHY_ClkEnCtrl, 0);
			phy_reg_and(pi, LPPHY_bphyTest, pi->car_sup_phytest);

			wlc_phy_tx_pu_lpphy(pi, 0);
		} else if (ISSSLPNPHY(pi)) {
			/* Disable carrier suppression */
			phy_reg_write(pi, SSLPNPHY_ClkEnCtrl, 0);
			phy_reg_and(pi, SSLPNPHY_bphyTest, pi->car_sup_phytest);
			phy_reg_and(pi, SSLPNPHY_sslpnCalibClkEnCtrl, 0xff7f);
			phy_reg_write(pi, SSLPNPHY_BphyControl3, pi_sslpn->sslpnphy_bphyctrl);
			wlc_sslpnphy_tx_pu(pi, 0);
		} else if (ISLCNPHY(pi)) {
			/* release the gpio controls from cc */
			wlc_lcnphy_epa_switch(pi, 0);
			/* Disable carrier suppression */
			wlc_lcnphy_crsuprs(pi, channel);
		} else if (ISLCN40PHY(pi)) {
			/* Disable carrier suppression */
			wlc_lcn40phy_crsuprs(pi, channel);
		} else 	if (ISHTPHY(pi)) {
			wlc_phy_bphy_testpattern_htphy(pi, HTPHY_TESTPATTERN_BPHY_RFCS, 0, FALSE);
		} else
			W_REG(pi->sh->osh, &regs->phytest, pi->car_sup_phytest);

		pi->car_sup_phytest = 0;
		return 0;
	}

	if ((bcmerror = wlc_phy_test_init(pi, channel, TRUE)))
		return bcmerror;

	/* Save original contents */
	if (pi->car_sup_phytest == 0 && !ISHTPHY(pi)) {
	        if (ISNPHY(pi)) {
			pi->car_sup_phytest = phy_reg_read(pi,
			                                   (NPHY_TO_BPHY_OFF + BPHY_TEST));
		} else if (ISLPPHY(pi)) {
			pi->car_sup_phytest = phy_reg_read(pi, LPPHY_bphyTest);
		} else if (ISSSLPNPHY(pi)) {
			pi->car_sup_phytest = phy_reg_read(pi, SSLPNPHY_bphyTest);
			pi_sslpn->sslpnphy_bphyctrl = phy_reg_read(pi, SSLPNPHY_BphyControl3);
		} else if (ISLCNPHY(pi)) {
			pi->car_sup_phytest = phy_reg_read(pi, LCNPHY_bphyTest);
		} else
			pi->car_sup_phytest = R_REG(pi->sh->osh, &regs->phytest);
	}

	/* set carrier suppression test mode */
	if (ISHTPHY(pi)) {
		wlc_phy_bphy_testpattern_htphy(pi, HTPHY_TESTPATTERN_BPHY_RFCS, 0, TRUE);
	} else if (ISNPHY(pi)) {
		PHY_REG_LIST_START
			PHY_REG_AND_RAW_ENTRY(NPHY_TO_BPHY_OFF + BPHY_TEST, 0xfc00)
			PHY_REG_OR_RAW_ENTRY(NPHY_TO_BPHY_OFF + BPHY_TEST, 0x0228)
		PHY_REG_LIST_EXECUTE(pi);
	} else if (ISLPPHY(pi)) {
		if (LPREV_GE(pi->pubpi.phy_rev, 2))
			wlc_phy_tx_dig_filt_cck_setup_lpphy(pi, TRUE);
		if (pi_lp->lpphy_use_cck_dig_loft_coeffs) {
#if defined(PHYCAL_CACHING)
			ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
			ASSERT(ctx);
			wlc_phy_set_tx_locc_lpphy(pi, ctx->u.lpphy_cache.didq_cck);
#else
			wlc_phy_set_tx_locc_lpphy(pi, pi_lp->lpphy_cal_results.didq_cck);
#endif // endif
		}
		wlc_phy_tx_pu_lpphy(pi, 1);

		/* Enable carrier suppression */
		PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(LPPHY, ClkEnCtrl, 0xffff)
			PHY_REG_OR_ENTRY(LPPHY, bphyTest, 0x228)
		PHY_REG_LIST_EXECUTE(pi);

	} else if (ISSSLPNPHY(pi)) {
		wlc_sslpnphy_tx_pu(pi, 1);

		/* Enable carrier suppression */
		PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(SSLPNPHY, ClkEnCtrl, 0xffff)
			PHY_REG_OR_ENTRY(SSLPNPHY, bphyTest, 0x228)
		PHY_REG_LIST_EXECUTE(pi);

	} else if (ISLCNPHY(pi)) {
		/* get the gpio controls to cc */
		wlc_lcnphy_epa_switch(pi, 1);
		wlc_lcnphy_crsuprs(pi, channel);
	} else {
		AND_REG(pi->sh->osh, &regs->phytest, 0xfc00);
		OR_REG(pi->sh->osh, &regs->phytest, 0x0228);
	}

	return 0;
}

static int
wlc_phy_test_freq_accuracy(phy_info_t *pi, int channel)
{
	int bcmerror = 0;

	/* stop any test in progress */
	wlc_phy_test_stop(pi);

	/* channel 0 means this is a request to end the test */
	if (channel == 0) {
		/* Restore original values */
		if (ISNPHY(pi)) {
			if ((bcmerror = wlc_phy_freq_accuracy_nphy(pi, channel)) != BCME_OK)
				return bcmerror;
		} else if (ISHTPHY(pi)) {
			if ((bcmerror = wlc_phy_freq_accuracy_htphy(pi, channel)) != BCME_OK)
				return bcmerror;
		} else if (ISACPHY(pi)) {
			if ((bcmerror = wlc_phy_freq_accuracy_acphy(pi, channel)) != BCME_OK)
				return bcmerror;
		} else if (ISLPPHY(pi)) {
			wlc_phy_stop_tx_tone_lpphy(pi);
			wlc_phy_clear_deaf_lpphy(pi, (bool)1);
		} else if (ISSSLPNPHY(pi)) {
			wlc_sslpnphy_stop_tx_tone(pi);
			wlc_sslpnphy_set_tx_pwr_ctrl(pi, SSLPNPHY_TX_PWR_CTRL_HW);
		} else if (ISLCNPHY(pi)) {
			wlc_lcnphy_stop_tx_tone(pi);
			if (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)
				wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_TEMPBASED);
			else
				wlc_lcnphy_set_tx_pwr_ctrl(pi, LCNPHY_TX_PWR_CTRL_HW);
			wlc_lcnphy_epa_switch(pi, 0);
		} else if (ISLCN40PHY(pi)) {
			/* For lcn40, restore the 24dB scaler */
			PHY_REG_MOD(pi, LCN40PHY, bbmult0, bbmult0_enable, 1);
			PHY_REG_MOD(pi, LCN40PHY, bbmult0, bbmult0_coeff, 64);
			wlc_lcn40phy_set_bbmult(pi, 64);
			wlc_lcn40phy_stop_tx_tone(pi);
			pi->pi_fptr.settxpwrctrl(pi, LCN40PHY_TX_PWR_CTRL_HW);
		} else if (ISABGPHY(pi)) {
			wlc_phy_test_freq_accuracy_prep_abgphy(pi);
		}

		return 0;
	}

	if ((bcmerror = wlc_phy_test_init(pi, channel, FALSE)))
		return bcmerror;

	if (ISNPHY(pi)) {
		if ((bcmerror = wlc_phy_freq_accuracy_nphy(pi, channel)) != BCME_OK)
			return bcmerror;
	} else if (ISACPHY(pi)) {
		if ((bcmerror = wlc_phy_freq_accuracy_acphy(pi, channel)) != BCME_OK)
			return bcmerror;
	} else if (ISHTPHY(pi)) {
		if ((bcmerror = wlc_phy_freq_accuracy_htphy(pi, channel)) != BCME_OK)
			return bcmerror;
	} else if (ISLPPHY(pi)) {
		wlc_phy_set_deaf_lpphy(pi, (bool)1);
		wlc_phy_start_tx_tone_lpphy(pi, 0, LPREV_GE(pi->pubpi.phy_rev, 2) ? 28: 100);
	} else if (ISSSLPNPHY(pi)) {
		wlc_sslpnphy_start_tx_tone(pi, 0, 112, 0);
		wlc_sslpnphy_set_tx_pwr_by_index(pi, (int)20);
	} else if (ISLCNPHY(pi)) {
		/* get the gpio controls to cc */
		wlc_lcnphy_epa_switch(pi, 1);
		wlc_lcnphy_start_tx_tone(pi, 0, 112, 0);
		wlc_lcnphy_set_tx_pwr_by_index(pi, (int)94);
	} else if (ISLCN40PHY(pi)) {
		/* For lcn40, need to scale up tx tone by 24 dB */
		PHY_REG_MOD(pi, LCN40PHY, bbmult0, bbmult0_enable, 1);
		PHY_REG_MOD(pi, LCN40PHY, bbmult0, bbmult0_coeff, 255);
		wlc_lcn40phy_set_bbmult(pi, 255);
		wlc_lcn40phy_start_tx_tone(pi, 0, 112, 0);
		pi->pi_fptr.settxpwrbyindex(pi, (int)94);
	} else if (ISABGPHY(pi)) {
		wlc_phy_test_freq_accuracy_run_abgphy(pi);
	}

	return 0;
}

#endif // endif

void
wlc_phy_antsel_type_set(wlc_phy_t *ppi, uint8 antsel_type)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	pi->antsel_type = antsel_type;

	/* initialize flag to init HW Rx antsel if the board supports it */
	if ((pi->antsel_type == ANTSEL_2x3_HWRX) || (pi->antsel_type == ANTSEL_1x2_HWRX))
		pi->nphy_enable_hw_antsel = TRUE;
	else
		pi->nphy_enable_hw_antsel = FALSE;
}

bool
wlc_phy_test_ison(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	return (pi->phytest_on);
}

#ifdef WLC_SW_DIVERSITY
bool
wlc_phy_swdiv_ant_set(wlc_phy_t *ppi, uint8 new_ant)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (!pi->sh->clk)
		return FALSE;

	if (ISLCN40PHY(pi))
		return wlc_lcn40phy_swdiv_ant_set(pi, new_ant);
	else if (ISACPHY(pi))
		return wlc_phy_swdiv_ant_set_acphy(pi, new_ant);
	else
		return FALSE;
}

bool
wlc_phy_swdiv_ant_get(wlc_phy_t *ppi, uint8 *cur_ant)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (!pi->sh->clk)
		return FALSE;

	if (ISLCN40PHY(pi))
		return wlc_lcn40phy_swdiv_ant_get(pi, cur_ant);
	else if (ISACPHY(pi))
		return wlc_phy_swdiv_ant_get_acphy(pi, cur_ant);
	else
		return FALSE;
}
#endif /* WLC_SW_DIVERSITY */

/* Read the gci chip status register indexed by 'reg' */
uint32
si_gci_chipstatus_acphy(si_t *sih, uint reg)
{
	/* because NFLASH and GCI clashes in 0xC00 */
#ifndef NFLASH_SUPPORT
	si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gci_indirect_addr), ~0, reg);
	/* setting mask and value to '0' to use si_corereg for read only purpose */
	return si_corereg(sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gci_chipsts), 0, 0);
#else /* NFLASH_SUPPORT */
	ASSERT(0);
	return 0xFFFFFFFF;
#endif // endif
}

bool
wlc_phy_check_antdiv_enable_acphy(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev))) {
		return ((si_gci_chipstatus_acphy(pi->sh->sih, 8) >> 2) & 0x1);
	} else {
		return (ACMAJORREV_3(pi->pubpi.phy_rev));
	}
}

bool
wlc_phy_ant_rxdiv_get(wlc_phy_t *ppi, uint8 *pval)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	*pval = pi->sh->rx_antdiv;
	return TRUE;
}

void
wlc_phy_ant_rxdiv_set(wlc_phy_t *ppi, uint8 val)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	bool suspend;
	pi->sh->rx_antdiv = val;

	if (ISHTPHY(pi))
		return;	/* no need to set phy reg for htphy */

#ifdef WLC_SW_DIVERSITY
	if (ISLCN40PHY(pi) && pi->u.pi_lcn40phy->swdiv_enable)
		return;

	if (ISACPHY(pi) && pi->u.pi_acphy->swdiv_enable)
		return;
#endif // endif

	if (!(ISACPHY(pi) && wlc_phy_check_antdiv_enable_acphy(ppi))) {
		return;
	}

	/* update ucode flag for non-4322(phy has antdiv by default) */
	if (!(ISNPHY(pi) && D11REV_IS(pi->sh->corerev, 16))) {
		if (val > ANT_RX_DIV_FORCE_1) {
			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV, MHF1_ANTDIV,
				WLC_BAND_ALL);
			/* and M_PHY_ANTDIV_MASK to 0x200 */
			if (CHIPID(pi->sh->chip) == BCM4314_CHIP_ID ||
			    CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) {
				wlapi_bmac_write_shm(pi->sh->physhim,
					M_PHY_ANTDIV_REG_4314, 0x4b1);
				wlapi_bmac_write_shm(pi->sh->physhim,
					M_PHY_ANTDIV_MASK_4314, 0x200);
			}
		} else
			wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_ANTDIV, 0, WLC_BAND_ALL);
	}

	if (ISNPHY(pi))
		return;	/* no need to set phy reg for nphy */

	if (!pi->sh->clk)
		return;

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend)
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

	if (ISLPPHY(pi)) {
		if (val > ANT_RX_DIV_FORCE_1) {
			phy_reg_mod(pi, LPPHY_crsgainCtrl,
				LPPHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x01 << LPPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LPPHY_crsgainCtrl,
				LPPHY_crsgainCtrl_DefaultAntenna_MASK,
				((ANT_RX_DIV_START_1 == val) ? 1 : 0) <<
				LPPHY_crsgainCtrl_DefaultAntenna_SHIFT);
		} else {
			phy_reg_mod(pi, LPPHY_crsgainCtrl,
				LPPHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x00 << LPPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LPPHY_crsgainCtrl,
				LPPHY_crsgainCtrl_DefaultAntenna_MASK,
				(uint16)val << LPPHY_crsgainCtrl_DefaultAntenna_SHIFT);
		}
	} else if (ISSSLPNPHY(pi)) {
		if (val > ANT_RX_DIV_FORCE_1) {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				phy_reg_mod(pi, SSLPNPHY_Rev2_crsgainCtrl_40,
				SSLPNPHY_Rev2_crsgainCtrl_40_DiversityChkEnable_MASK,
				0x01 << SSLPNPHY_Rev2_crsgainCtrl_40_DiversityChkEnable_SHIFT);

				phy_reg_mod(pi, SSLPNPHY_Rev2_crsgainCtrl_40,
					SSLPNPHY_Rev2_crsgainCtrl_40_DefaultAntenna_MASK,
					((ANT_RX_DIV_START_1 == val) ? 1 : 0) <<
					SSLPNPHY_Rev2_crsgainCtrl_40_DefaultAntenna_SHIFT);
			} else {
				phy_reg_mod(pi, SSLPNPHY_crsgainCtrl,
					SSLPNPHY_crsgainCtrl_DiversityChkEnable_MASK,
					0x01 << SSLPNPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
				phy_reg_mod(pi, SSLPNPHY_crsgainCtrl,
					SSLPNPHY_crsgainCtrl_DefaultAntenna_MASK,
					((ANT_RX_DIV_START_1 == val) ? 1 : 0) <<
					SSLPNPHY_crsgainCtrl_DefaultAntenna_SHIFT);
			}
		} else {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				phy_reg_mod(pi, SSLPNPHY_Rev2_crsgainCtrl_40,
				SSLPNPHY_Rev2_crsgainCtrl_40_DiversityChkEnable_MASK,
				0x00 << SSLPNPHY_Rev2_crsgainCtrl_40_DiversityChkEnable_SHIFT);

				phy_reg_mod(pi, SSLPNPHY_Rev2_crsgainCtrl_40,
				SSLPNPHY_Rev2_crsgainCtrl_40_DefaultAntenna_MASK,
				(uint16)val << SSLPNPHY_Rev2_crsgainCtrl_40_DefaultAntenna_SHIFT);
			} else {
				phy_reg_mod(pi, SSLPNPHY_crsgainCtrl,
					SSLPNPHY_crsgainCtrl_DiversityChkEnable_MASK,
					0x00 << SSLPNPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
				phy_reg_mod(pi, SSLPNPHY_crsgainCtrl,
					SSLPNPHY_crsgainCtrl_DefaultAntenna_MASK,
					(uint16)val << SSLPNPHY_crsgainCtrl_DefaultAntenna_SHIFT);
			}
		}

		/* Reset radio ctrl and crs gain */
		PHY_REG_LIST_START
			PHY_REG_OR_ENTRY(SSLPNPHY, resetCtrl, 0x44)
			PHY_REG_WRITE_ENTRY(SSLPNPHY, resetCtrl, 0x80)
		PHY_REG_LIST_EXECUTE(pi);

		/* Get pointer to the BTCX shm block */
		if (pi->bt_shm_addr)
			wlapi_bmac_write_shm(pi->sh->physhim,
				pi->bt_shm_addr + M_BTCX_DIVERSITY_SAVE, 0);

	} else if (ISLCNPHY(pi)) {
		if (val > ANT_RX_DIV_FORCE_1) {
			phy_reg_mod(pi, LCNPHY_crsgainCtrl,
				LCNPHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x01 << LCNPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LCNPHY_crsgainCtrl,
				LCNPHY_crsgainCtrl_DefaultAntenna_MASK,
				((ANT_RX_DIV_START_1 == val) ? 1 : 0) <<
				LCNPHY_crsgainCtrl_DefaultAntenna_SHIFT);
		} else {
			phy_reg_mod(pi, LCNPHY_crsgainCtrl,
				LCNPHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x00 << LCNPHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LCNPHY_crsgainCtrl,
				LCNPHY_crsgainCtrl_DefaultAntenna_MASK,
				(uint16)val << LCNPHY_crsgainCtrl_DefaultAntenna_SHIFT);
		}
	} else if (ISABGPHY(pi)) {
		wlc_phy_ant_rxdiv_set_abgphy(pi, val);
	} else if (ISLCN40PHY(pi)) {
#ifdef WLC_SW_DIVERSITY
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
		if (pi_lcn40->swdiv_swctrl_en) {
			if (!suspend)
				wlapi_enable_mac(pi->sh->physhim);
			return;
		}
#endif // endif
		if (val > ANT_RX_DIV_FORCE_1) {
			phy_reg_mod(pi, LCN40PHY_crsgainCtrl,
				LCN40PHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x01 << LCN40PHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LCN40PHY_crsgainCtrl,
				LCN40PHY_crsgainCtrl_DefaultAntenna_MASK,
				((ANT_RX_DIV_START_1 == val) ? 1 : 0) <<
				LCN40PHY_crsgainCtrl_DefaultAntenna_SHIFT);

			if (CHIPID(pi->sh->chip) == BCM4314_CHIP_ID ||
			    CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) {
				if (CHSPEC_IS40(pi->radio_chanspec)) {
				    PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(LCN40PHY, agcControl8, 0x0741)
					PHY_REG_WRITE_ENTRY(LCN40PHY, diversityReg, 0x1f02)
					PHY_REG_MOD_ENTRY(LCN40PHY, GainStableThr_new,
						crsgainstablethr20, 0x3)
					PHY_REG_MOD_ENTRY(LCN40PHY, GainStableThr_new,
						crsgainstablethr40, 0x2)
					PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
						crssignalblock_tf_20L, 0)
					PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
						crssignalblock_tf_20U, 0)
					PHY_REG_MOD_ENTRY(LCN40PHY, PwrThresh1_new,
						SlowPwrLoThresh40, 0x03)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl11,
						gain_settle_dly_cnt, 0x2)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset0_new,
						OFDMPreambleSyncTimeOut20, 0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
						OFDMPreambleSyncTimeOut20L, 0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
						OFDMPreambleSyncTimeOut20U, 0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl6,
						c_agc_phase_2_5, 0x6)
					PHY_REG_MOD_ENTRY(LCN40PHY, ReducedDetectorDly_new,
						reducedDetectorDlyThresh, 0xfa)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl13,
						hg_ofdm_detect_cnt, 0x1)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl5, c_ng_ofdm_cfo_dly,
						0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, CFOblkConfig,
						c_crs_cfo_calc_en_40mhz, 0x0)
				    PHY_REG_LIST_EXECUTE(pi);
				} else {
				    PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(LCN40PHY, agcControl8, 0x0741)
					PHY_REG_WRITE_ENTRY(LCN40PHY, diversityReg, 0x0f02)
					PHY_REG_MOD_ENTRY(LCN40PHY, GainStableThr_new,
						crsgainstablethr20, 0x3)
					PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
						crssignalblock_tf_20U, 0x2)
					PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
						crssignalblock_tf_20L, 0x1)
					PHY_REG_MOD_ENTRY(LCN40PHY, PwrThresh1_new,
						SlowPwrLoThresh40, 0x07)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl11,
						gain_settle_dly_cnt, 0x2)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset0_new,
						OFDMPreambleSyncTimeOut20, 0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
						OFDMPreambleSyncTimeOut20L, 0x7)
					PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
						OFDMPreambleSyncTimeOut20U, 0x7)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl6, c_agc_phase_2_5,
						0x6)
					PHY_REG_MOD_ENTRY(LCN40PHY, ReducedDetectorDly_new,
						reducedDetectorDlyThresh, 0xfa)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl13,
						hg_ofdm_detect_cnt, 0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, agcControl5, c_ng_ofdm_cfo_dly,
						0x0)
					PHY_REG_MOD_ENTRY(LCN40PHY, CFOblkConfig,
						c_crs_cfo_calc_en_40mhz, 0x0)
				    PHY_REG_LIST_EXECUTE(pi);
				}
				if (LCN40REV_LT(pi->pubpi.phy_rev, 4)) {
					PHY_REG_MOD(pi, LCN40PHY, ReducedDetectorDly,
						reducedDetectorDlyThresh, 0xfa);
					PHY_REG_MOD(pi, LCN40PHY, DetectorDlyAdjust,
						ofdmfiltDlyAdjustment, -1);
				}
				/* Enable lcn40phy antdiv WAR in ucode */
				wlapi_bmac_mhf(pi->sh->physhim, MHF5, MHF5_LCN40PHY_ANTDIV_WAR,
					MHF5_LCN40PHY_ANTDIV_WAR, WLC_BAND_2G);
			}

		} else {
			phy_reg_mod(pi, LCN40PHY_crsgainCtrl,
				LCN40PHY_crsgainCtrl_DiversityChkEnable_MASK,
				0x00 << LCN40PHY_crsgainCtrl_DiversityChkEnable_SHIFT);
			phy_reg_mod(pi, LCN40PHY_crsgainCtrl,
				LCN40PHY_crsgainCtrl_DefaultAntenna_MASK,
				(uint16)val << LCN40PHY_crsgainCtrl_DefaultAntenna_SHIFT);

			if (CHIPID(pi->sh->chip) == BCM4314_CHIP_ID ||
			    CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) {
			    PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(LCN40PHY, agcControl8, 0x0750)
				PHY_REG_WRITE_ENTRY(LCN40PHY, diversityReg, 0x0802)
				PHY_REG_MOD_ENTRY(LCN40PHY, GainStableThr_new,
					crsgainstablethr20, 0x1)
				PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
					crssignalblock_tf_20U, 0x2)
				PHY_REG_MOD_ENTRY(LCN40PHY, SignalBlockConfigTable_new,
					crssignalblock_tf_20L, 0x2)
				PHY_REG_MOD_ENTRY(LCN40PHY, PwrThresh1_new, SlowPwrLoThresh40,
					0x07)
			    PHY_REG_LIST_EXECUTE(pi);
			    if (CHSPEC_IS40(pi->radio_chanspec)) {
				PHY_REG_MOD(pi, LCN40PHY, agcControl11, gain_settle_dly_cnt, 0x3);
			    } else {
				PHY_REG_MOD(pi, LCN40PHY, agcControl11, gain_settle_dly_cnt, 0x5);
			    }
			    PHY_REG_LIST_START
				PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset0_new,
					OFDMPreambleSyncTimeOut20, 0x7)
				PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
					OFDMPreambleSyncTimeOut20L, 0x7)
				PHY_REG_MOD_ENTRY(LCN40PHY, ofdmSyncTimerOffset1_new,
					OFDMPreambleSyncTimeOut20U, 0x7)
				PHY_REG_MOD_ENTRY(LCN40PHY, agcControl6, c_agc_phase_2_5, 0x4)
			    PHY_REG_LIST_EXECUTE(pi);
			    if (LCN40REV_LT(pi->pubpi.phy_rev, 4)) {
				PHY_REG_MOD(pi, LCN40PHY, ReducedDetectorDly,
					reducedDetectorDlyThresh, 0xfa);
			    }
			    PHY_REG_LIST_START
				PHY_REG_MOD_ENTRY(LCN40PHY, ReducedDetectorDly_new,
					reducedDetectorDlyThresh, 0xfa)
				PHY_REG_MOD_ENTRY(LCN40PHY, agcControl13, hg_ofdm_detect_cnt, 0x1)
				PHY_REG_MOD_ENTRY(LCN40PHY, agcControl5, c_ng_ofdm_cfo_dly, 0x1)
			    PHY_REG_LIST_EXECUTE(pi);
			    if (LCN40REV_LT(pi->pubpi.phy_rev, 4)) {
				PHY_REG_MOD(pi, LCN40PHY, DetectorDlyAdjust,
					ofdmfiltDlyAdjustment, 0);
			    }
			    PHY_REG_MOD(pi, LCN40PHY, CFOblkConfig, c_crs_cfo_calc_en_40mhz, 0x1);
			    /* Disable lcn40phy antdiv WAR in ucode */
			    wlapi_bmac_mhf(pi->sh->physhim, MHF5, MHF5_LCN40PHY_ANTDIV_WAR,
			        0, WLC_BAND_2G);
			}
		}

		if ((CHIPID(pi->sh->chip) == BCM4314_CHIP_ID) ||
		    (CHIPID(pi->sh->chip) == BCM43142_CHIP_ID)) {
			if ((ANT_RX_DIV_START_1 == val) || (ANT_RX_DIV_FORCE_1 == val)) {
				/* Ant1 is chosen */
				PHY_REG_MOD(pi, LCN40PHY, rfoverride2, ext_lna_gain_ovr, 0x1);
				PHY_REG_MOD(pi, LCN40PHY, rfoverride2val, ext_lna_gain_ovr_val,
					0x1);
			} else {
				/* Ant0 is chosen */
				PHY_REG_MOD(pi, LCN40PHY, rfoverride2, ext_lna_gain_ovr, 0x1);
				PHY_REG_MOD(pi, LCN40PHY, rfoverride2val, ext_lna_gain_ovr_val,
					0x0);
			}
		}

	} else if (ISACPHY(pi) && wlc_phy_check_antdiv_enable_acphy(ppi)) {
		wlc_phy_antdiv_acphy(pi, val);
	} else {
		PHY_ERROR(("wl%d: %s: PHY_TYPE= %d is Unsupported \n",
		          pi->sh->unit, __FUNCTION__, pi->pubpi.phy_type));
		ASSERT(0);
	}

	if (!suspend)
		wlapi_enable_mac(pi->sh->physhim);

	return;
}

void
wlc_phy_interference_set(wlc_phy_t *pih, bool init)
{
	int wanted_mode;
	phy_info_t *pi = (phy_info_t *)pih;

	if (!(ISNPHY(pi) || ISHTPHY(pi) || (CHIPID(pi->sh->chip) == BCM43142_CHIP_ID)))
		return;

	if (pi->sh->interference_mode_override == TRUE) {
		/* keep the same values */
#ifdef BAND5G
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (pi->sh->interference_mode_5G_override == 0 ||
				pi->sh->interference_mode_5G_override == 1) {
				wanted_mode = pi->sh->interference_mode_5G_override;
			} else {
				wanted_mode = 0;
			}
		} else
#endif /* BAND5G */
		{
			wanted_mode = pi->sh->interference_mode_2G_override;
		}
	} else {

#ifdef BAND5G
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			wanted_mode = pi->sh->interference_mode_5G;
		} else
#endif /* BAND5G */
		{
			wanted_mode = pi->sh->interference_mode_2G;
		}
	}

	if (CHSPEC_CHANNEL(pi->radio_chanspec) != pi->interf.curr_home_channel) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

#ifndef WLC_DISABLE_ACI
		wlc_phy_interference(pi, wanted_mode, init);
#endif // endif
		pi->sh->interference_mode = wanted_mode;

		wlapi_enable_mac(pi->sh->physhim);
	}
}

#ifndef WLC_DISABLE_ACI
/* %%%%%% interference */
static bool
wlc_phy_interference(phy_info_t *pi, int wanted_mode, bool init)
{
	if (init) {
		pi->interference_mode_crs_time = 0;
		pi->crsglitch_prev = 0;
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
			/* clear out all the state */
			wlc_phy_noisemode_reset_nphy(pi);
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				wlc_phy_acimode_reset_nphy(pi);
			}
		} else if (ISHTPHY(pi)) {
			/* clear out all the state */
			wlc_phy_noisemode_reset_htphy(pi);
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				wlc_phy_acimode_reset_htphy(pi);
			}
		} else if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
			wlc_lcnphy_aci_init(pi);
		} else if (ISLCN40PHY(pi) && (CHIPID(pi->sh->chip) == BCM43142_CHIP_ID)) {
			wlc_lcn40phy_aci_init(pi);
		}
	}

	/* NPHY 5G, supported for NON_WLAN and INTERFERE_NONE only */
	if (ISGPHY(pi) || ISLPPHY(pi) || ISSSLPNPHY(pi) ||
		(ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) ||
		((ISNPHY(pi) || ISHTPHY(pi)) &&
		(CHSPEC_IS2G(pi->radio_chanspec) ||
		(CHSPEC_IS5G(pi->radio_chanspec) &&
	        (wanted_mode == NON_WLAN || wanted_mode == INTERFERE_NONE))))) {
		if (wanted_mode == INTERFERE_NONE) {	/* disable */
			if (ISHTPHY(pi)) {
				/* XXX
				 * PR114196: Set MF thresholds back to default for mode 0
				 */
				wlc_phy_noise_raise_MFthresh_htphy(pi, FALSE);
			}

			switch (pi->cur_interference_mode) {
			case WLAN_AUTO:
			case WLAN_AUTO_W_NOISE:
			case WLAN_MANUAL:
				if (ISLPPHY(pi))
					wlc_phy_aci_enable_lpphy(pi, FALSE);
				else if (ISNPHY(pi) &&
					CHSPEC_IS2G(pi->radio_chanspec)) {
					wlc_phy_acimode_set_nphy(pi, FALSE,
						PHY_ACI_PWR_NOTPRESENT);
				} else if (ISHTPHY(pi) &&
					CHSPEC_IS2G(pi->radio_chanspec)) {
					wlc_phy_acimode_set_htphy(pi, FALSE,
						PHY_ACI_PWR_NOTPRESENT);
				} else if (ISGPHY(pi)) {
					wlc_phy_aci_ctl_gphy(pi, FALSE);
				} else if (ISSSLPNPHY(pi)) {
					wlc_sslpnphy_force_adj_gain(pi, FALSE, wanted_mode);
				} else if (ISLCNPHY(pi) &&
					(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
					wlc_lcnphy_force_adj_gain(pi, FALSE, wanted_mode);
				}
				pi->aci_state &= ~ACI_ACTIVE;
				break;
			case NON_WLAN:
				if (ISNPHY(pi)) {
					if (NREV_GE(pi->pubpi.phy_rev, 3) &&
						CHSPEC_IS2G(pi->radio_chanspec)) {
						wlc_phy_acimode_set_nphy(pi,
							FALSE,
							PHY_ACI_PWR_NOTPRESENT);
						pi->aci_state &= ~ACI_ACTIVE;
					}
				} else if (ISHTPHY(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
					wlc_phy_acimode_set_htphy(pi,
						FALSE,
						PHY_ACI_PWR_NOTPRESENT);
					pi->aci_state &= ~ACI_ACTIVE;
				} else if (ISSSLPNPHY(pi)) {
					wlc_sslpnphy_force_adj_gain(pi, FALSE, wanted_mode);
				} else if (ISLCNPHY(pi) &&
					(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
					pi->aci_state &= ~ACI_ACTIVE;
					wlc_lcnphy_force_adj_gain(pi, FALSE, wanted_mode);
				} else {
					pi->interference_mode_crs = 0;
					if (ISABGPHY(pi))
						wlc_phy_aci_interf_nwlan_set_gphy(pi, FALSE);

				}
				break;
			}
		} else {	/* Enable */
			if (ISHTPHY(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
				/* XXX
				 * PR114196: Set high MF threshold for all RSSIs in 2G if
				 * interference mode is not 0
				 */
				wlc_phy_noise_raise_MFthresh_htphy(pi, TRUE);
			}

			switch (wanted_mode) {
			case NON_WLAN:
				if (ISNPHY(pi)) {
					if (!NREV_GE(pi->pubpi.phy_rev, 3)) {
						PHY_ERROR(("NON_WLAN not supported for NPHY\n"));
					}
				} else if (ISSSLPNPHY(pi)) {
					wlc_sslpnphy_force_adj_gain(pi, FALSE, wanted_mode);
				} else if (ISLCNPHY(pi) &&
					(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
					wlc_lcnphy_force_adj_gain(pi, TRUE, wanted_mode);
				} else {
					pi->interference_mode_crs = 1;
					if (ISABGPHY(pi)) {
						wlc_phy_aci_interf_nwlan_set_gphy(pi, TRUE);
					}

				}
				break;
			case WLAN_AUTO:
			case WLAN_AUTO_W_NOISE:
				/* fall through */
				if (((pi->aci_state & ACI_ACTIVE) != 0) ||
					ISNPHY(pi) || ISHTPHY(pi))
					break;
				if (ISLPPHY(pi)) {
				  wlc_phy_aci_enable_lpphy(pi, FALSE);
				  break;
				}
				if (ISSSLPNPHY(pi)) {
					wlc_sslpnphy_aci(pi, FALSE);
					break;
				}
				if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
					wlc_lcnphy_aci(pi, FALSE);
					break;
				}
				/* FALLTHRU */
			case WLAN_MANUAL:
				if (ISLPPHY(pi))
					wlc_phy_aci_enable_lpphy(pi, TRUE);
				else if (ISNPHY(pi)) {
					int aci_pwr = CHIPID_4324X_MEDIA_FAMILY(pi) ?
					    PHY_ACI_PWR_MED : PHY_ACI_PWR_HIGH;
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						wlc_phy_acimode_set_nphy(pi, TRUE, aci_pwr);
					}
				} else if (ISHTPHY(pi)) {
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						wlc_phy_acimode_set_htphy(pi, TRUE,
							PHY_ACI_PWR_HIGH);
					}
				} else if (ISLCNPHY(pi) &&
					(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
					wlc_lcnphy_force_adj_gain(pi, TRUE, wanted_mode);
				} else if (ISGPHY(pi)) {
					wlc_phy_aci_ctl_gphy(pi, TRUE);
					break;
				} else if (ISSSLPNPHY(pi)) {
					wlc_sslpnphy_force_adj_gain(pi, TRUE, wanted_mode);
				}
			}
		}
	}

	/* Depending on interfernece modes, do whatever needs to be done */
	if (ISACPHY(pi)) {
		if (wanted_mode == INTERFERE_NONE) {
			if (ACPHY_ENABLE_FCBS_HWACI(pi)) {
				wlc_phy_hwaci_mitigation_enable_acphy_tiny(pi, 0, FALSE);
			} else {
				wlc_phy_desense_aci_reset_params_acphy(pi, TRUE, TRUE);
				wlc_phy_hwaci_setup_acphy(pi, FALSE, FALSE);
				wlc_phy_aci_w2nb_setup_acphy(pi, FALSE);
			}
			wlc_phy_preempt(pi, FALSE);
		}

		/* Nothing needs to be done for ACPHY_ACI_GLITCHBASED_DESENSE */

		/* Switch on( & init) the required rssi settings */
		if ((pi->sh->interference_mode & ACPHY_ACI_HWACI_PKTGAINLMT) != 0) {
			if (!ACPHY_ENABLE_FCBS_HWACI(pi))
				wlc_phy_hwaci_setup_acphy(pi, TRUE, TRUE);

		} else if ((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0) {
			if (!ACPHY_ENABLE_FCBS_HWACI(pi))
				wlc_phy_hwaci_setup_acphy(pi, TRUE, TRUE);
			else
				wlc_phy_hwaci_mitigation_enable_acphy_tiny(pi, 1, TRUE);
		}
		if (!ACPHY_ENABLE_FCBS_HWACI(pi) &&
			(pi->sh->interference_mode & ACPHY_ACI_W2NB_PKTGAINLMT) != 0) {
			wlc_phy_aci_w2nb_setup_acphy(pi, TRUE);
			}
		if ((pi->sh->interference_mode & ACPHY_ACI_PREEMPTION) != 0)
		        wlc_phy_preempt(pi, TRUE);
	}

	if (ISLCN40PHY(pi) && (CHIPID(pi->sh->chip) == BCM43143_CHIP_ID)) {
		wlc_lcn40phy_rev6_aci(pi, wanted_mode);
	}

	pi->cur_interference_mode = wanted_mode;
	return TRUE;
}

static void
wlc_phy_aci_enter(phy_info_t *pi)
{
	/* There are cases when the glitch count is continuously high
	 * but there is no ACI.  In this case we want to wait 'countdown' secs
	 * between scans
	 */
	ASSERT((pi->aci_state & ACI_ACTIVE) == 0);

	/* If we have glitches see if they are caused by ACI */
	if (pi->interf.aci.glitch_ma > pi->interf.aci.enter_thresh) {

		/* If we find ACI on our channel, go into ACI avoidance */
		if (pi->interf.aci.countdown == 0) {	/* Is it time to check? */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);

			if (ISGPHY(pi) && wlc_phy_aci_scan_gphy(pi)) {
				pi->aci_start_time = pi->sh->now;
				wlc_phy_aci_ctl_gphy(pi, TRUE);
				pi->interf.aci.countdown = 0;
			} else {
				/* Glitch count is high but no ACI, so wait
				 * hi_glitch_delay seconds before checking for ACI again.
				 */
				pi->interf.aci.countdown = pi->interf.aci.glitch_delay + 1;
			}
			wlapi_enable_mac(pi->sh->physhim);
		}
		if (pi->interf.aci.countdown)
			pi->interf.aci.countdown--;
	} else {
		pi->interf.aci.countdown = 0;	/* no glitches so cancel glitchdelay */
	}
}

static void
wlc_phy_aci_exit(phy_info_t *pi)
{
	if (pi->interf.aci.glitch_ma < pi->interf.aci.exit_thresh) {

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		if (ISGPHY(pi)) {
			if (!wlc_phy_aci_scan_gphy(pi)) {
			PHY_CAL(("%s: Absence of ACI, exiting ACI\n", __FUNCTION__));
			pi->aci_start_time = 0;
			wlc_phy_aci_ctl_gphy(pi, FALSE);
		} else {
				PHY_CAL(("%s: ACI is present - remain in ACI mode\n",
					__FUNCTION__));
			}
		}
		wlapi_enable_mac(pi->sh->physhim);
	}
}

/* update aci rx carrier sense glitch moving average */
static void
wlc_phy_aci_update_ma(phy_info_t *pi)
{

	int32 delta = 0;
	int32 bphy_delta = 0;
	int32 ofdm_delta = 0;
	int32 badplcp_delta = 0;
	int32 bphy_badplcp_delta = 0;
	int32 ofdm_badplcp_delta = 0;

	if ((pi->interf.cca_stats_func_called == FALSE) || pi->interf.cca_stats_mbsstime <= 0) {
	  uint16 cur_glitch_cnt;
	  uint offset;
	  uint16 bphy_cur_glitch_cnt = 0;
	  uint16 cur_badplcp_cnt = 0;
	  uint16 bphy_cur_badplcp_cnt = 0;
#ifdef WLPHYACICACHE
	ch_acicache_t *aci_ctx;
	aci_ctx = wlc_phy_get_aci_chanctx(pi, pi->radio_chanspec);
	if (aci_ctx) {
		delta = aci_ctx->aci_cache.sum_delta_crsglitch;
		bphy_delta = aci_ctx->aci_cache.sum_delta_bphy_crsglitch;
		badplcp_delta = aci_ctx->aci_cache.sum_delta_badplcp;
		bphy_badplcp_delta = aci_ctx->aci_cache.sum_delta_bphy_badplcp;
	} else
#endif // endif
	{
#ifdef WLSRVSDB
	  uint8 bank_offset = 0;
	  uint8 vsdb_switch_failed = 0;
	  uint8 vsdb_split_cntr = 0;

	  if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi->srvsdb_state.sr_vsdb_channels[0]) {
	    bank_offset = 0;
	  } else if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi->srvsdb_state.sr_vsdb_channels[1]) {
	    bank_offset = 1;
	  }
	  /* Assume vsdb switch failed, if no switches were recorded for both the channels */
	  vsdb_switch_failed = !(pi->srvsdb_state.num_chan_switch[0] &
	  pi->srvsdb_state.num_chan_switch[1]);

	  /* use split counter for each channel if vsdb is active and vsdb switch was successfull */
	  /* else use last 1 sec delta counter for current channel for calculations */
	  vsdb_split_cntr = (!vsdb_switch_failed) && (pi->srvsdb_state.srvsdb_active);

#endif /* WLSRVSDB */
	  /* determine delta number of rxcrs glitches */
	  offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxcrsglitch);
	  cur_glitch_cnt = wlapi_bmac_read_shm(pi->sh->physhim, offset);
	  delta = cur_glitch_cnt - pi->interf.aci.pre_glitch_cnt;
	  pi->interf.aci.pre_glitch_cnt = cur_glitch_cnt;

#ifdef WLSRVSDB
	  if (vsdb_split_cntr) {
	    delta =  pi->srvsdb_state.sum_delta_crsglitch[bank_offset];
	  }
#endif /* WLSRVSDB */
	  if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi) || ISACPHY(pi)) {

		  /* compute the rxbadplcp  */
		  offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxbadplcp);
		  cur_badplcp_cnt = wlapi_bmac_read_shm(pi->sh->physhim, offset);
		  badplcp_delta = cur_badplcp_cnt - pi->interf.pre_badplcp_cnt;
		  pi->interf.pre_badplcp_cnt = cur_badplcp_cnt;

#ifdef WLSRVSDB
		  if (vsdb_split_cntr) {
			  badplcp_delta = pi->srvsdb_state.sum_delta_prev_badplcp[bank_offset];
		  }
#endif /* WLSRVSDB */
		  /* determine delta number of bphy rx crs glitches */
		  offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_rxcrsglitch);
		  bphy_cur_glitch_cnt = wlapi_bmac_read_shm(pi->sh->physhim, offset);
		  bphy_delta = bphy_cur_glitch_cnt - pi->interf.noise.bphy_pre_glitch_cnt;
		  pi->interf.noise.bphy_pre_glitch_cnt = bphy_cur_glitch_cnt;

#ifdef WLSRVSDB
		  if (vsdb_split_cntr) {
			  bphy_delta = pi->srvsdb_state.sum_delta_bphy_crsglitch[bank_offset];
		  }
#endif /* WLSRVSDB */

		  /* compute bphy rxbadplcp */

		  offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_badplcp);
		  bphy_cur_badplcp_cnt = wlapi_bmac_read_shm(pi->sh->physhim, offset);

		  bphy_badplcp_delta = bphy_cur_badplcp_cnt -
		  pi->interf.bphy_pre_badplcp_cnt;
		  pi->interf.bphy_pre_badplcp_cnt = bphy_cur_badplcp_cnt;

#ifdef WLSRVSDB
		  if (vsdb_split_cntr) {
			  bphy_badplcp_delta =
			  pi->srvsdb_state.sum_delta_prev_bphy_badplcp[bank_offset];
		  }

#endif /* WLSRVSDB */
		}
	}

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		/* ofdm glitches is what we will be using */
		ofdm_delta = delta - bphy_delta;
	} else {
		ofdm_delta = delta;
	}

	/* ofdm bad plcps is what we will be using */
	if (CHSPEC_IS2G(pi->radio_chanspec))
		ofdm_badplcp_delta = badplcp_delta - bphy_badplcp_delta;
	else
		ofdm_badplcp_delta = badplcp_delta;

	if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi)) {
		/* if we aren't suppose to update yet, don't */
		if (pi->interf.scanroamtimer != 0)
			return;
	}
	} else {
		pi->interf.cca_stats_func_called = FALSE;
		/* Normalizing the statistics per second */
		delta = pi->interf.cca_stats_total_glitch * 1000 /
		        pi->interf.cca_stats_mbsstime;
		bphy_delta = pi->interf.cca_stats_bphy_glitch * 1000 /
		        pi->interf.cca_stats_mbsstime;
		ofdm_delta = delta - bphy_delta;
		badplcp_delta = pi->interf.cca_stats_total_badplcp * 1000 /
		        pi->interf.cca_stats_mbsstime;
		bphy_badplcp_delta = pi->interf.cca_stats_bphy_badplcp * 1000 /
		        pi->interf.cca_stats_mbsstime;
		ofdm_badplcp_delta = badplcp_delta - bphy_badplcp_delta;
	}

	if (delta >= 0) {
		/* evict old value */
		pi->interf.aci.ma_total -= pi->interf.aci.ma_list[pi->interf.aci.ma_index];

		/* admit new value */
		pi->interf.aci.ma_total += (uint16) delta;
		pi->interf.aci.glitch_ma_previous = pi->interf.aci.glitch_ma;
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
		     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
			pi->interf.aci.glitch_ma = pi->interf.aci.ma_total /
			        PHY_NOISE_MA_WINDOW_SZ;
		} else {
			pi->interf.aci.glitch_ma = pi->interf.aci.ma_total / MA_WINDOW_SZ;
		}

		pi->interf.aci.ma_list[pi->interf.aci.ma_index++] = (uint16) delta;
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
		     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
			if (pi->interf.aci.ma_index >= PHY_NOISE_MA_WINDOW_SZ)
				pi->interf.aci.ma_index = 0;
		} else {
			if (pi->interf.aci.ma_index >= MA_WINDOW_SZ)
				pi->interf.aci.ma_index = 0;
		}
	}

	if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi) || ISACPHY(pi)) {
		if (badplcp_delta >= 0) {
			pi->interf.badplcp_ma_total -=
				pi->interf.badplcp_ma_list[pi->interf.badplcp_ma_index];
			pi->interf.badplcp_ma_total += (uint16) badplcp_delta;
			pi->interf.badplcp_ma_previous = pi->interf.badplcp_ma;

			if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
			     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
				pi->interf.badplcp_ma =
				        pi->interf.badplcp_ma_total / PHY_NOISE_MA_WINDOW_SZ;
			} else {
				pi->interf.badplcp_ma = pi->interf.badplcp_ma_total / MA_WINDOW_SZ;
			}

			pi->interf.badplcp_ma_list[pi->interf.badplcp_ma_index++] =
				(uint16) badplcp_delta;
			if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3) &&
			     NREV_LE(pi->pubpi.phy_rev, 15)) || ISHTPHY(pi) || ISACPHY(pi)) {
				if (pi->interf.badplcp_ma_index >= PHY_NOISE_MA_WINDOW_SZ)
					pi->interf.badplcp_ma_index = 0;
			} else {
				if (pi->interf.badplcp_ma_index >= MA_WINDOW_SZ)
					pi->interf.badplcp_ma_index = 0;
			}
		}

		/* XXX
		 * OFDM GLITCHES
		 * evict old value, admit new value, compute new ma, readjust ma window
		 */
		if ((CHSPEC_IS5G(pi->radio_chanspec) && (ofdm_delta >= 0)) ||
			(CHSPEC_IS2G(pi->radio_chanspec) && (delta >= 0) && (bphy_delta >= 0))) {
			pi->interf.noise.ofdm_ma_total -= pi->interf.noise.
					ofdm_glitch_ma_list[pi->interf.noise.ofdm_ma_index];
			pi->interf.noise.ofdm_ma_total += (uint16) ofdm_delta;
			pi->interf.noise.ofdm_glitch_ma_previous = pi->interf.noise.ofdm_glitch_ma;
			pi->interf.noise.ofdm_glitch_ma =
				pi->interf.noise.ofdm_ma_total / PHY_NOISE_MA_WINDOW_SZ;
			pi->interf.noise.ofdm_glitch_ma_list[pi->interf.noise.ofdm_ma_index++] =
				(uint16) ofdm_delta;
			if (pi->interf.noise.ofdm_ma_index >= PHY_NOISE_MA_WINDOW_SZ)
				pi->interf.noise.ofdm_ma_index = 0;
		}

		/* XXX
		 * BPHY GLITCHES
		 * evict old value, admit new value, compute new ma, readjust ma window
		 */
		if (bphy_delta >= 0) {
			pi->interf.noise.bphy_ma_total -= pi->interf.noise.
					bphy_glitch_ma_list[pi->interf.noise.bphy_ma_index];
			pi->interf.noise.bphy_ma_total += (uint16) bphy_delta;
			pi->interf.noise.bphy_glitch_ma_previous = pi->interf.noise.bphy_glitch_ma;
			pi->interf.noise.bphy_glitch_ma =
				pi->interf.noise.bphy_ma_total / PHY_NOISE_MA_WINDOW_SZ;
			pi->interf.noise.bphy_glitch_ma_list[pi->interf.noise.bphy_ma_index++] =
				(uint16) bphy_delta;
			if (pi->interf.noise.bphy_ma_index >= PHY_NOISE_MA_WINDOW_SZ)
				pi->interf.noise.bphy_ma_index = 0;
		}

		/* XXX
		 * OFDM BADPLCP
		 * evict old value, admit new value, compute new ma, readjust ma window
		 */
		if ((CHSPEC_IS5G(pi->radio_chanspec) && (ofdm_badplcp_delta >= 0)) ||
			(CHSPEC_IS2G(pi->radio_chanspec) && (badplcp_delta >= 0) &&
			(bphy_badplcp_delta >= 0))) {
			pi->interf.noise.ofdm_badplcp_ma_total -= pi->interf.noise.
				ofdm_badplcp_ma_list[pi->interf.noise.ofdm_badplcp_ma_index];
			pi->interf.noise.ofdm_badplcp_ma_total += (uint16) ofdm_badplcp_delta;
			pi->interf.noise.ofdm_badplcp_ma_previous =
				pi->interf.noise.ofdm_badplcp_ma;
			pi->interf.noise.ofdm_badplcp_ma =
				pi->interf.noise.ofdm_badplcp_ma_total / PHY_NOISE_MA_WINDOW_SZ;
			pi->interf.noise.ofdm_badplcp_ma_list
				[pi->interf.noise.ofdm_badplcp_ma_index++] =
				(uint16) ofdm_badplcp_delta;
			if (pi->interf.noise.ofdm_badplcp_ma_index >= PHY_NOISE_MA_WINDOW_SZ)
				pi->interf.noise.ofdm_badplcp_ma_index = 0;
		}

		/* XXX
		 * BPHY BADPLCP
		 * evict old value, admit new value, compute new ma, readjust ma window
		 */
		if (bphy_badplcp_delta >= 0) {
			pi->interf.noise.bphy_badplcp_ma_total -= pi->interf.noise.
				bphy_badplcp_ma_list[pi->interf.noise.bphy_badplcp_ma_index];
			pi->interf.noise.bphy_badplcp_ma_total += (uint16) bphy_badplcp_delta;
			pi->interf.noise.bphy_badplcp_ma_previous = pi->interf.noise.
				bphy_badplcp_ma;
			pi->interf.noise.bphy_badplcp_ma =
				pi->interf.noise.bphy_badplcp_ma_total / PHY_NOISE_MA_WINDOW_SZ;
			pi->interf.noise.bphy_badplcp_ma_list
					[pi->interf.noise.bphy_badplcp_ma_index++] =
					(uint16) bphy_badplcp_delta;
			if (pi->interf.noise.bphy_badplcp_ma_index >= PHY_NOISE_MA_WINDOW_SZ)
				pi->interf.noise.bphy_badplcp_ma_index = 0;
		}
	}

	if (((ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 16) ||
	    (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 5)))) || ISHTPHY(pi)) &&
	    (pi->sh->interference_mode == WLAN_AUTO_W_NOISE ||
	     pi->sh->interference_mode == NON_WLAN)) {
		PHY_ACI(("wlc_phy_aci_update_ma: ACI= %s, rxglitch_ma= %d,"
			" badplcp_ma= %d, ofdm_glitch_ma= %d, bphy_glitch_ma=%d,"
			" ofdm_badplcp_ma= %d, bphy_badplcp_ma=%d, crsminpwr index= %d,"
			" init gain= 0x%x, channel= %d\n",
			(pi->aci_state & ACI_ACTIVE) ? "Active" : "Inactive",
			pi->interf.aci.glitch_ma,
			pi->interf.badplcp_ma,
			pi->interf.noise.ofdm_glitch_ma,
			pi->interf.noise.bphy_glitch_ma,
			pi->interf.noise.ofdm_badplcp_ma,
			pi->interf.noise.bphy_badplcp_ma,
			pi->interf.crsminpwr_index,
			pi->interf.init_gain_core1, CHSPEC_CHANNEL(pi->radio_chanspec)));
	} else {
		PHY_ACI(("wlc_phy_aci_update_ma: ave glitch %d, ACI is %s, delta is %d\n",
		pi->interf.aci.glitch_ma,
		(pi->aci_state & ACI_ACTIVE) ? "Active" : "Inactive", delta));
	}
#ifdef WLSRVSDB
	/* Clear out cumulatiove cntrs after 1 sec */
	/* reset both chan info becuase its a fresh start after every 1 sec */
	if (pi->srvsdb_state.srvsdb_active) {
		bzero(pi->srvsdb_state.num_chan_switch, 2 * sizeof(uint8));
		bzero(pi->srvsdb_state.sum_delta_crsglitch, 2 * sizeof(uint32));
		bzero(pi->srvsdb_state.sum_delta_bphy_crsglitch, 2 * sizeof(uint32));
		bzero(pi->srvsdb_state.sum_delta_prev_badplcp, 2 * sizeof(uint32));
		bzero(pi->srvsdb_state.sum_delta_prev_bphy_badplcp, 2 * sizeof(uint32));
	}
#endif /* WLSRVSDB */
}

static void
wlc_phy_aci_upd(phy_info_t *pi)
{
	bool desense_gt_4;
	int glit_plcp_sum;
#ifdef WLSRVSDB
	uint8 offset = 0;
	uint8 vsdb_switch_failed = 0;

	if (pi->srvsdb_state.srvsdb_active) {
		/* Assume vsdb switch failure, if no chan switches were recorded in last 1 sec */
		vsdb_switch_failed = !(pi->srvsdb_state.num_chan_switch[0] &
			pi->srvsdb_state.num_chan_switch[1]);
		if (CHSPEC_CHANNEL(pi->radio_chanspec) ==
			pi->srvsdb_state.sr_vsdb_channels[0]) {
			offset = 0;
		} else if (CHSPEC_CHANNEL(pi->radio_chanspec) ==
			pi->srvsdb_state.sr_vsdb_channels[1]) {
			offset = 1;
		}

		/* return if vsdb switching was active and time spent in current channel */
		/* is less than 1 sec */
		/* If vsdb switching had failed, it could be in a  deadlock */
		/* situation because of noise/aci */
		/* So continue with aci mitigation even though delta timers show less than 1 sec */

		if ((pi->srvsdb_state.sum_delta_timer[offset] < (1000 * 1000)) &&
			!vsdb_switch_failed) {

			bzero(pi->srvsdb_state.num_chan_switch, 2 * sizeof(uint8));
			return;
		}
		PHY_INFORM(("Enter ACI mitigation for chan %x  since %d ms of time has expired\n",
			pi->srvsdb_state.sr_vsdb_channels[offset],
			pi->srvsdb_state.sum_delta_timer[offset]/1000));

		/* reset the timers after an effective 1 sec duration in the channel */
		bzero(pi->srvsdb_state.sum_delta_timer, 2 * sizeof(uint32));

		/* If enetering aci mitigation scheme, we need a save of */
		/* previous pi structure while doing switch */
		pi->srvsdb_state.swbkp_snapshot_valid[offset] = 0;
	}
#endif /* WLSRVSDB */

#ifdef DYNAMIC_THRESH_UPD
		wlc_phy_update_glitch_thresholds(pi);
#endif /* DYNAMIC_THRESH_UPD */

	wlc_phy_aci_update_ma(pi);

	if (ISACPHY(pi)) {
		if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
			if ((pi->sh->interference_mode & ACPHY_ACI_GLITCHBASED_DESENSE) != 0) {
				wlc_phy_desense_aci_engine_acphy(pi, TRUE);
			}

			if ((pi->sh->interference_mode & (ACPHY_ACI_HWACI_PKTGAINLMT |
				ACPHY_ACI_W2NB_PKTGAINLMT)) != 0) {
				wlc_phy_hwaci_engine_acphy(pi);
			}
		}
	} else {
	switch (pi->sh->interference_mode) {
		case NON_WLAN:
			/* NON_WLAN NPHY */
			if (ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 16) ||
			    (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 5)))) {
				/* run noise mitigation only */
				wlc_phy_noisemode_upd_nphy(pi);
			} else if (ISHTPHY(pi)) {
				/* run noise mitigation only */
				wlc_phy_noisemode_upd_htphy(pi);
			} else if (ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 6) &&
				NREV_LE(pi->pubpi.phy_rev, 15))) {
				wlc_phy_noisemode_upd(pi);
			}
			break;
		case WLAN_AUTO:
			if (ISGPHY(pi)) {
				/* Attempt to enter ACI mode if not already active */
				if (!(pi->aci_state & ACI_ACTIVE)) {
					wlc_phy_aci_enter(pi);
				} else {
					if (((pi->sh->now - pi->aci_start_time) %
						pi->aci_exit_check_period) == 0) {
						wlc_phy_aci_exit(pi);
					}
				}
			}
			else if (ISLPPHY(pi)) {
				wlc_phy_aci_upd_lpphy(pi);
			} else if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
				wlc_lcnphy_aci_noise_measure(pi);
			} else if (ISLCN40PHY(pi) && ((CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) ||
				(CHIPID(pi->sh->chip) == BCM43340_CHIP_ID) ||
				(CHIPID(pi->sh->chip) == BCM43341_CHIP_ID))) {
				wlc_lcn40phy_aci_upd(pi);
			} else if (ISSSLPNPHY(pi) && (SSLPNREV_IS(pi->pubpi.phy_rev, 3))) {
				wlc_sslpnphy_noise_measure((wlc_phy_t *)pi);
			}
			else if (ISNPHY(pi) || ISHTPHY(pi)) {
				if (ASSOC_INPROG_PHY(pi))
					break;
#ifdef NOISE_CAL_LCNXNPHY
				if ((NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV) ||
					NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))) {
						wlc_phy_aci_noise_measure_nphy(pi, TRUE);
				}
				else
#endif // endif
				{
					/* 5G band not supported yet */
					if (CHSPEC_IS5G(pi->radio_chanspec))
						break;

					if (PUB_NOT_ASSOC(pi)) {
						/* not associated:  do not run aci routines */
						break;
					}
					PHY_ACI(("Interf Mode 3,"
						" pi->interf.aci.glitch_ma = %d\n",
						pi->interf.aci.glitch_ma));

					/* Attempt to enter ACI mode if not already active */
					/* only run this code if associated */
					if (!(pi->aci_state & ACI_ACTIVE)) {
						if ((pi->sh->now  % NPHY_ACI_CHECK_PERIOD) == 0) {

							if ((pi->interf.aci.glitch_ma +
								pi->interf.badplcp_ma) >=
								pi->interf.aci.enter_thresh) {
								if (ISNPHY(pi)) {
								wlc_phy_acimode_upd_nphy(pi);
								} else if (ISHTPHY(pi)) {
								wlc_phy_acimode_upd_htphy(pi);
								}
							}
						}
					} else {
						if (((pi->sh->now - pi->aci_start_time) %
							pi->aci_exit_check_period) == 0) {
							if (ISNPHY(pi)) {
								wlc_phy_acimode_upd_nphy(pi);
							} else if (ISHTPHY(pi)) {
								wlc_phy_acimode_upd_htphy(pi);
							}
						}
					}
				}
			}
			break;
		case WLAN_AUTO_W_NOISE:
			if (ISNPHY(pi) || ISHTPHY(pi)) {
#ifdef NOISE_CAL_LCNXNPHY
				if ((NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV) ||
					NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))) {
						wlc_phy_aci_noise_measure_nphy(pi, TRUE);
				}
				else
#endif // endif
				{
					/* 5G band not supported yet */
					if (CHSPEC_IS5G(pi->radio_chanspec))
						break;

					/* only do this for 4322 and future revs */
					if (ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 16) ||
					    (NREV_GE(pi->pubpi.phy_rev, 3) &&
					     NREV_LE(pi->pubpi.phy_rev, 5)))) {
						/* Attempt to enter ACI mode if
						 * not already active
						 */
						wlc_phy_aci_noise_upd_nphy(pi);
					} else if (ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 6) &&
						NREV_LE(pi->pubpi.phy_rev, 15))) {
					  PHY_ACI(("Interf Mode 4\n"));
					  desense_gt_4 = (pi->interf.noise.ofdm_desense >= 4 ||
					      pi->interf.noise.bphy_desense >= 4);
					  glit_plcp_sum = pi->interf.aci.glitch_ma +
					        pi->interf.badplcp_ma;
					  if (!(pi->aci_state & ACI_ACTIVE)) {
					    if ((pi->sh->now  % NPHY_ACI_CHECK_PERIOD) == 0) {
					      if ((glit_plcp_sum >=
					        pi->interf.aci.enter_thresh) || desense_gt_4) {
						if (ISNPHY(pi)) {
						  wlc_phy_acimode_upd_nphy(pi);
						}
					      }
					    }
					  } else {
					    if (((pi->sh->now - pi->aci_start_time) %
						 pi->aci_exit_check_period) == 0) {
					      if (ISNPHY(pi)) {
						wlc_phy_acimode_upd_nphy(pi);
					      }
					    }
					  }

					  wlc_phy_noisemode_upd(pi);

					} else if (ISHTPHY(pi)) {
						wlc_phy_aci_noise_upd_htphy(pi);
					}
				}
			}
			else if (ISSSLPNPHY(pi) && (SSLPNREV_IS(pi->pubpi.phy_rev, 3))) {
				wlc_sslpnphy_noise_measure((wlc_phy_t *)pi);
			} else if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) {
				wlc_lcnphy_aci_noise_measure(pi);
			} else if (ISLCN40PHY(pi) && ((CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) ||
				(CHIPID(pi->sh->chip) == BCM43340_CHIP_ID) ||
				(CHIPID(pi->sh->chip) == BCM43341_CHIP_ID))) {
				wlc_lcn40phy_aci_upd(pi);
			}
			break;

		default:
			break;
	}
	}
}

void
wlc_phy_noisemode_upd(phy_info_t *pi)
{

	int8 bphy_desense_delta = 0, ofdm_desense_delta = 0;
	uint16 glitch_badplcp_sum;

	if (CHSPEC_CHANNEL(pi->radio_chanspec) != pi->interf.curr_home_channel)
		return;

	if (pi->interf.scanroamtimer != 0) {
		/* have not updated moving averages */
		return;
	}

	/* BPHY desense. Sets  pi->interf.noise.bphy_desense in side the func */
	/* Should be run only if associated */
	if (!PUB_NOT_ASSOC(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {

		glitch_badplcp_sum = pi->interf.noise.bphy_glitch_ma +
			pi->interf.noise.bphy_badplcp_ma;

		bphy_desense_delta = wlc_phy_cmn_noisemode_glitch_chk_adj(pi, glitch_badplcp_sum,
			&pi->interf.noise.bphy_thres);

		pi->interf.noise.bphy_desense += bphy_desense_delta;
	} else {
		pi->interf.noise.bphy_desense = 0;
	}

	glitch_badplcp_sum = pi->interf.noise.ofdm_glitch_ma + pi->interf.noise.ofdm_badplcp_ma;
	/* OFDM desense. Sets  pi->interf.noise.ofdm_desense in side the func */
	ofdm_desense_delta = wlc_phy_cmn_noisemode_glitch_chk_adj(pi, glitch_badplcp_sum,
		&pi->interf.noise.ofdm_thres);
	pi->interf.noise.ofdm_desense += ofdm_desense_delta;

	wlc_phy_cmn_noise_limit_desense(pi);

	/* XXX This function utilizes bphy_desense, ofdm_desense
	  * and RSSI (if setting exact OFDM and BPHY settings is not possible).
	  * This function finds out the best settings for BPHY (0x2e6, 0xc33, IG)
	  * and OFDM(0x280 and IG), that can best set the desense.
	  * Also, call this function if some desense is required.
	  * if both OFDM, BPHY desense == 0, then never mind calling the function.
	  * call the lower function only if there is any new desense to be done.
	  */

	if (bphy_desense_delta || ofdm_desense_delta) {
		if (ISNPHY(pi)) {
			wlc_phy_bphy_ofdm_noise_hw_set_nphy(pi);
		}
	}

	PHY_ACI(("PHY_CMN:  {GL_MA, BP_MA} OFDM {%d, %d},"
	         " BPHY {%d, %d}, Desense - (OFDM, BPHY) = {%d, %d} MAX_Desense {%d, %d},"
	         "channel is %d rssi = %d\n",
	         pi->interf.noise.ofdm_glitch_ma, pi->interf.noise.ofdm_badplcp_ma,
	         pi->interf.noise.bphy_glitch_ma, pi->interf.noise.bphy_badplcp_ma,
	         pi->interf.noise.ofdm_desense, pi->interf.noise.bphy_desense,
	         pi->interf.noise.max_poss_ofdm_desense, pi->interf.noise.max_poss_bphy_desense,
	         CHSPEC_CHANNEL(pi->radio_chanspec), pi->interf.rssi));

}

static int8
wlc_phy_cmn_noisemode_glitch_chk_adj(phy_info_t *pi, uint16 total_glitch_badplcp,
	noise_thresholds_t *thresholds)
{
	int8 desense_delta = 0;

	if (total_glitch_badplcp > thresholds->glitch_badplcp_low_th) {
		/* glitch count is high, could be due to inband noise */
		thresholds->high_detect_total++;
		thresholds->low_detect_total = 0;
	} else {
		/* glitch count not high */
		thresholds->high_detect_total = 0;
		thresholds->low_detect_total++;
	}

	if (thresholds->high_detect_total >= thresholds->high_detect_thresh) {
		/* we have more than glitch_th_up bphy
		 * glitches in a row. so, let's try raising the
		 * inband noise immunity
		 */
		if (total_glitch_badplcp < thresholds->glitch_badplcp_high_th) {
			/* Desense by less */
			desense_delta = thresholds->desense_lo_step;
		} else {
			/* Desense by more */
			desense_delta = thresholds->desense_hi_step;
		}
		thresholds->high_detect_total = 0;
	} else if (thresholds->low_detect_total > 0) {
		/* check to see if we can lower noise immunity */
		uint16 low_detect_total, undesense_wait, undesense_window;

		low_detect_total = thresholds->low_detect_total;
		undesense_wait = thresholds->undesense_wait;
		undesense_window = thresholds->undesense_window;

		/* Reduce the wait time to undesense if glitch count has been low for longer */
		while (undesense_wait > 1) {
			if (low_detect_total <=  undesense_window) {
				break;
			}
			low_detect_total -= undesense_window;
			/* Halve the wait time */
			undesense_wait /= 2;
		}

		if ((low_detect_total % undesense_wait) == 0) {
			/* Undesense */
			desense_delta = -1;
		}
	}
	PHY_ACI(("In %s: recomended desense = %d glitch_ma + badplcp_ma = %d,"
		"th_lo = %d, th_hi = %d \n", __FUNCTION__, desense_delta,
		total_glitch_badplcp, thresholds->glitch_badplcp_low_th,
		thresholds->glitch_badplcp_high_th));
	return desense_delta;
}

void
wlc_phy_cmn_noise_limit_desense(phy_info_t *pi)
{
	if (pi->interf.rssi != 0) {
		int8 max_desense_rssi = PHY_NOISE_DESENSE_RSSI_MAX;
		int8 desense_margin = PHY_NOISE_DESENSE_RSSI_MARGIN;

		int8 max_desense_dBm, bphy_desense_dB, ofdm_desense_dB;

		pi->interf.noise.bphy_desense = MAX(pi->interf.noise.bphy_desense, 0);
		pi->interf.noise.ofdm_desense = MAX(pi->interf.noise.ofdm_desense, 0);

		max_desense_dBm = MIN(pi->interf.rssi, max_desense_rssi) - desense_margin;

		bphy_desense_dB = max_desense_dBm - pi->interf.bphy_min_sensitivity;
		ofdm_desense_dB = max_desense_dBm - pi->interf.ofdm_min_sensitivity;

		bphy_desense_dB = MAX(bphy_desense_dB, 0);
		ofdm_desense_dB = MAX(ofdm_desense_dB, 0);

		pi->interf.noise.max_poss_bphy_desense = bphy_desense_dB;
		pi->interf.noise.max_poss_ofdm_desense = ofdm_desense_dB;

		pi->interf.noise.bphy_desense = MIN(bphy_desense_dB, pi->interf.noise.bphy_desense);
		pi->interf.noise.ofdm_desense = MIN(ofdm_desense_dB, pi->interf.noise.ofdm_desense);
	} else {
		pi->interf.noise.max_poss_bphy_desense = 0;
		pi->interf.noise.max_poss_ofdm_desense = 0;

		pi->interf.noise.bphy_desense = 0;
		pi->interf.noise.ofdm_desense = 0;
	}
}

void
wlc_phy_interf_rssi_update(wlc_phy_t *pih, chanspec_t chanspec, int8 leastRSSI)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if ((NREV_GE(pi->pubpi.phy_rev, 6) && ISNPHY(pi)) || ISHTPHY(pi)) {
	    if ((CHSPEC_CHANNEL(chanspec) == pi->interf.curr_home_channel)) {
	        pi->u.pi_nphy->intf_rssi_avg = leastRSSI;
	        pi->interf.rssi = leastRSSI;
	    }
	}

	/* Doing interference update here */
	if (ISACPHY(pi))
		wlc_phy_desense_aci_upd_rssi_acphy(pi, chanspec, leastRSSI);
}

void
wlc_phy_interf_chan_stats_update(wlc_phy_t *ppi, chanspec_t chanspec, uint32 crsglitch,
        uint32 bphy_crsglitch, uint32 badplcp, uint32 bphy_badplcp, uint32 mbsstime)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	uint32 ofdm_glitch, ofdm_badplcp;

	/* Doing interference update of chan stats here  */
	if (pi->interf.curr_home_channel == (CHSPEC_CHANNEL(chanspec))) {
		pi->interf.cca_stats_func_called = TRUE;
		pi->interf.cca_stats_total_glitch = crsglitch;
		pi->interf.cca_stats_bphy_glitch = bphy_crsglitch;
		pi->interf.cca_stats_total_badplcp = badplcp;
		pi->interf.cca_stats_bphy_badplcp = bphy_badplcp;
		pi->interf.cca_stats_mbsstime = mbsstime;
	} else if ((mbsstime > 0) && ISACPHY(pi)) {
		ofdm_glitch = crsglitch - bphy_crsglitch;
		ofdm_badplcp = badplcp - bphy_badplcp;
		wlc_phy_desense_aci_upd_chan_stats_acphy(pi, chanspec,
		                                         bphy_crsglitch * 1000/mbsstime,
		                                         bphy_badplcp * 1000/mbsstime,
		                                         ofdm_glitch * 1000/mbsstime,
		                                         ofdm_badplcp * 1000/mbsstime);
	}
}

uint64
wlc_phy_get_time_usec(phy_info_t *pi)
{
	uint64 time_lo, time_hi;

	time_lo = R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->tsf_timerlow);
	time_hi = R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->tsf_timerhigh);

	return ((time_hi << 32) | time_lo);
}

#endif /* Compiling out ACI code for 4324 */

void
wlc_phy_acimode_noisemode_reset(wlc_phy_t *pih, uint channel,
	bool clear_aci_state, bool clear_noise_state, bool disassoc)
{
	phy_info_t *pi = (phy_info_t *)pih;

	pi->interf.cca_stats_func_called = FALSE;

	if (!((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi)))
		return;

	if (pi->sh->interference_mode_override == TRUE)
		return;

	PHY_TRACE(("%s: CurCh %d HomeCh %d disassoc %d\n",
		__FUNCTION__, channel,
		pi->interf.curr_home_channel, disassoc));

	if ((disassoc) ||
		((channel != pi->interf.curr_home_channel) &&
		(disassoc == FALSE))) {
		/* not home channel... reset */
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
#ifndef WLC_DISABLE_ACI
			wlc_phy_aci_noise_reset_nphy(pi, channel,
				clear_aci_state, clear_noise_state, disassoc);
#endif /* Compiling out ACI code for 4324 */
		} else if (ISHTPHY(pi)) {
			wlc_phy_aci_noise_reset_htphy(pi, channel,
				clear_aci_state, clear_noise_state, disassoc);
		}
	}
}

static void
wlc_phy_noise_calc(phy_info_t *pi, uint32 *cmplx_pwr, int8 *pwr_ant, uint8 extra_gain_1dB)
{
	int8 cmplx_pwr_dbm[PHY_CORE_MAX];
	uint8 i;
	uint16 gain;

	bzero((uint8 *)cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
	ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);

	gain = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_BLKS+0xC);
	PHY_INFORM(("--> RXGAIN: %d\n", gain));

	wlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm, PHYCORENUM(pi->pubpi.phy_corenum));

	FOREACH_CORE(pi, i) {
	  if (ISACPHY(pi)) {
		/* init gain is fixed to -65 for acphy,
		 *-37 = 10*log10((0.4/512)*(0.4/512)*(16)*(1/50.0))
		 */

		/* knoise support, read gain value from shm, by Peyush */
		int16 assumed_gain;

		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
		if (pi_ac->srom.femctrl == 2) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				assumed_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_2G);
			} else {
			  assumed_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_5G);
			}
		} else {
			assumed_gain = (int16)(ACPHY_NOISE_INITGAIN);
		}

		assumed_gain += extra_gain_1dB;
		cmplx_pwr_dbm[i] += (int16) ((ACPHY_NOISE_SAMPLEPWR_TO_DBM - assumed_gain));
		pi->u.pi_acphy->phy_noise_all_core[i] =  cmplx_pwr_dbm[i] + (assumed_gain);
	  }
	  else
	if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			gain = pi_nphy->iqestgain;
		 cmplx_pwr_dbm[i] += (int8) (NPHY_NOISE_SAMPLEPWR_TO_DBM - gain);
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
		 cmplx_pwr_dbm[i] += (int8) (PHY_NOISE_OFFSETFACT_4322 - gain);
	}  else if ((ISNPHY(pi) && NREV_LT(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi))
			/* assume init gain 70 dB, 128 maps to 1V so
			 * 10*log10(128^2*2/128/128/50)+30=16 dBm
			 * WARNING: if the nphy init gain is ever changed,
			 * this formula needs to be updated
			*/
			cmplx_pwr_dbm[i] += (int8)(16 - (15) * 3 - (70 + extra_gain_1dB));
#if defined(WLTEST)
		else if (ISLCNPHY(pi) && LCNREV_GE(pi->pubpi.phy_rev, 2)) {
			int16 noise_offset_fact;
			phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
			wlc_phy_get_noiseoffset_lcnphy(pi, &noise_offset_fact);
			cmplx_pwr_dbm[i] +=
				(int8)(noise_offset_fact - pi_lcn->rxpath_gain);
		} else if (ISLCN40PHY(pi)) {
			int16 noise_offset_fact;
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			wlc_phy_get_noiseoffset_lcn40phy(pi, &noise_offset_fact);
			cmplx_pwr_dbm[i] +=
				(int8) ((noise_offset_fact - (pi_lcn->rxpath_gain >> 2)));
		}
#endif // endif
		pwr_ant[i] = cmplx_pwr_dbm[i];
		PHY_INFORM(("wlc_phy_noise_calc_phy: pwr_ant[%d] = %d\n", i, pwr_ant[i]));
	}

	PHY_INFORM(("%s: samples %d ant %d\n", __FUNCTION__, pi->phy_rxiq_samps,
		pi->phy_rxiq_antsel));
}

/* Following function converts complex power (cmplx_pwr) into db power
	(10*log10(cmplx_pwr)) first and then applies appropriate corrections.
	It also returns crsminpwr without any offset correction: 8*log2(16*cmplx_pwr)
*/
void
wlc_phy_noise_calc_fine_resln(phy_info_t *pi, uint32 *cmplx_pwr, uint16 *crsmin_pwr,
	int16 *pwr_ant, uint8 extra_gain_1dB, int16 *tot_gain)
{
	int16 cmplx_pwr_dbm[PHY_CORE_MAX];
	uint8 i;
	uint16 gain;
	int8 offset[] = {0, 0};

	/* lookup table for computing the dB contribution from the first
	 * 4 bits after MSB (most significant NONZERO bit) in cmplx_pwr[core]
	 * (entries in multiples of 0.25dB):
	 */
	uint8 dB_LUT[] = {0, 1, 2, 3, 4, 5, 6, 6, 7, 8, 8, 9,
		10, 10, 11, 11};
	uint8 LUT_correction[] = {13, 12, 12, 13, 16, 20, 25,
		5, 12, 19, 2, 11, 20, 5, 15, 1};

	bzero((uint16 *)cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
	ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);

	/* Convert sample-power to dB scale: */
	FOREACH_CORE(pi, i) {
		uint8 shift_ct, lsb, msb_loc;
		uint8 msb2345 = 0x0;
		uint32 tmp;
		tmp = cmplx_pwr[i];
		shift_ct = msb_loc = 0;
		while (tmp != 0) {
			tmp = tmp >> 1;
			shift_ct++;
			lsb = (uint8)(tmp & 1);
			if (lsb == 1)
				msb_loc = shift_ct;
		}

		/* Store first 4 bits after MSB: */
		if (msb_loc <= 4) {
			msb2345 = (cmplx_pwr[i] << (4-msb_loc)) & 0xf;
		} else {
			/* Need to first round cmplx_pwr to 5 MSBs: */
			tmp = cmplx_pwr[i] + (1U << (msb_loc-5));
			/* Check if MSB has shifted in the process: */
			if (tmp & (1U << (msb_loc+1))) {
				msb_loc++;
			}
			msb2345 = (tmp >> (msb_loc-4)) & 0xf;
		}

		/* Power in 0.25 dB steps: */
		cmplx_pwr_dbm[i] = ((3*msb_loc) << 2) + dB_LUT[msb2345];

		/* Apply a possible +0.25dB (1 step) correction depending
		 * on MSB location in cmplx_pwr[core]:
		 */
		cmplx_pwr_dbm[i] += (int16)((msb_loc >= LUT_correction[msb2345]) ? 1 : 0);
		/* crsmin_pwr = 8*log2(16*cmplx_pwr)
		   = 32 + 8*(10*log10(cmplx_pwr))/(10*log10(2))
		   = 32 + (cmplx_pwr_db * round(8/(10*log10(2)) * 2^10)) >> (10+2),
		   where additional >>2 is to account for quarter dB resolution
		*/
		crsmin_pwr[i] = 32 + ((cmplx_pwr_dbm[i] * 2721) >> 12);
	}

	if (ISHTPHY(pi)) {
		int16 assumed_gain;
		wlc_phy_get_rxiqest_gain_htphy(pi, &assumed_gain);
		assumed_gain += extra_gain_1dB;

		FOREACH_CORE(pi, i) {
			/* Convert to analog input power at ADC and then
			 * backoff applied gain to get antenna input power:
			 */

			/* XXX
			 * FIXME:
			 * Need to have better way of arriving at assumed_gain
			 * than having #define's for different boards
			 */

			/* scale conversion factor by 4 as power is in 0.25dB steps */
			cmplx_pwr_dbm[i] += (int16) ((HTPHY_NOISE_SAMPLEPWR_TO_DBM -
			                              assumed_gain) << 2);
			pwr_ant[i] = cmplx_pwr_dbm[i];
			PHY_INFORM(("wlc_phy_noise_calc_fine_resln: pwr_ant[%d] = %d\n",
				i, pwr_ant[i]));
		}
	} else if (ISACPHY(pi)) {
		int16 assumed_gain;

		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

		FOREACH_CORE(pi, i) {
			assumed_gain = tot_gain[i];

			if (assumed_gain == ACPHY_RXGAIN_UNSPECIFIED) {
				if (pi_ac->srom.femctrl == 2) {
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						assumed_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_2G);
					} else {
						assumed_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_5G);
					}
				} else {
					assumed_gain = (int16)(ACPHY_NOISE_INITGAIN);
				}
			}

			assumed_gain += extra_gain_1dB;

			/* Convert to analog input power at ADC and then
			 * backoff applied gain to get antenna input power:
			 */

			/* XXX
			 * FIXME:
			 * Need to have better way of arriving at assumed_gain
			 * than having #define's for different boards
			 */

			/* scale conversion factor by 4 as power is in 0.25dB steps */
			cmplx_pwr_dbm[i] += (int16) ((ACPHY_NOISE_SAMPLEPWR_TO_DBM -
			                              assumed_gain) << 2);
			pwr_ant[i] = cmplx_pwr_dbm[i];
			PHY_RXIQ(("In %s: pwr_ant[%d] = %d\n", __FUNCTION__,
				i, pwr_ant[i]));
		}

#if defined(WLTEST)
	}
	else if (ISLCNPHY(pi) && LCNREV_GE(pi->pubpi.phy_rev, 2)) {
		int16 noise_offset_fact;
		int8 freq_offset_fact;
		phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
		wlc_phy_get_noiseoffset_lcnphy(pi, &noise_offset_fact);
		FOREACH_CORE(pi, i) {
			cmplx_pwr_dbm[i] +=
				(int16) ((noise_offset_fact - pi_lcn->rxpath_gain) << 2);
			pwr_ant[i] = cmplx_pwr_dbm[i];
			/* Frequency based variation correction */
			wlc_lcnphy_get_lna_freq_correction(pi, &freq_offset_fact);
			pwr_ant[i] = pwr_ant[i] - freq_offset_fact;
		}
	} else if (ISLCN40PHY(pi)) {
		int16 noise_offset_fact;
		int8 freq_offset_fact;
		phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
		wlc_phy_get_noiseoffset_lcn40phy(pi, &noise_offset_fact);
		FOREACH_CORE(pi, i) {
			cmplx_pwr_dbm[i] +=
				(int16) ((noise_offset_fact << 2) - pi_lcn->rxpath_gain);
			pwr_ant[i] = cmplx_pwr_dbm[i];
			/* Frequency based variation correction */
			wlc_lcn40phy_get_lna_freq_correction(pi, &freq_offset_fact);
			pwr_ant[i] = pwr_ant[i] - freq_offset_fact;
		}
#endif /* #if defined(WLTEST) */
	} else if (ISNPHY(pi) &&
		(NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 6))) {
		FOREACH_CORE(pi, i) {
			/* Convert to analog input power at ADC and then
			 * backoff applied gain to get antenna input power:
			 */
			cmplx_pwr_dbm[i] += (int16) ((NPHY_NOISE_SAMPLEPWR_TO_DBM -
				NPHY_NOISE_INITGAIN) << 2);
			/* scale conversion factor by 4 as power is in 0.25dB steps */
			pwr_ant[i] = cmplx_pwr_dbm[i];
			PHY_INFORM(("wlc_phy_noise_calc_fine_resln: pwr_ant[%d] = %d\n",
				i, pwr_ant[i]));
		}
	} else if (ISNPHY(pi) && CHIPID_4324X_EPA_FAMILY(pi)) {
			/* Adding fine resolution option for 4324B1,B3,B5 */
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			gain = pi_nphy->iqestgain;
			wlc_phy_rxgain_index_offset(pi, offset);
		FOREACH_CORE(pi, i) {
			cmplx_pwr_dbm[i] += (int16) ((NPHY_NOISE_SAMPLEPWR_TO_DBM - gain) << 2);
			cmplx_pwr_dbm[i] -= (offset[i]);
			pwr_ant[i] = cmplx_pwr_dbm[i];
			PHY_INFORM(("wlc_phy_noise_calc_fine_resln: pwr_ant[%d] = %d\n",
				i, pwr_ant[i]));
		}
			/* clearing the variables */
			pi_nphy->gainindex = 0;
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				pi_nphy->iqestgain = 74;
			} else {
				pi_nphy->iqestgain = 70;
			}

	} else {
		FOREACH_CORE(pi, i) {
			/* assume init gain 70 dB, 128 maps to 1V so
			 * 10*log10(128^2*2/128/128/50)+30=16 dBm
			 *  WARNING: if the nphy init gain is ever changed,
			 * this formula needs to be updated
			 */
			cmplx_pwr_dbm[i] += ((int16)(16 << 2) - (int16)((15 << 2)*3)
			                     - (int16)((70 + extra_gain_1dB) << 2));
			pwr_ant[i] = cmplx_pwr_dbm[i];
		}
	}

}

static void
wlc_phy_noise_save(phy_info_t *pi, int8 *noise_dbm_ant, int8 *max_noise_dbm)
{
	uint8 i;

	FOREACH_CORE(pi, i) {
		/* save noise per core */
		pi->phy_noise_win[i][pi->phy_noise_index] = noise_dbm_ant[i];

		/* save the MAX for all cores */
		if (noise_dbm_ant[i] > *max_noise_dbm)
			*max_noise_dbm = noise_dbm_ant[i];
	}
	pi->phy_noise_index = MODINC_POW2(pi->phy_noise_index, PHY_NOISE_WINDOW_SZ);

	pi->sh->phy_noise_window[pi->sh->phy_noise_index] = *max_noise_dbm;
	pi->sh->phy_noise_index = MODINC_POW2(pi->sh->phy_noise_index, MA_WINDOW_SZ);
}

static uint8 wlc_phy_calc_extra_init_gain(phy_info_t *pi, uint8 extra_gain_3dB,
                                         rxgain_t rxgain[])
{
	uint16 init_gain_code[4];
	uint8 core, MAX_DVGA, MAX_LPF, MAX_MIX;
	uint8 dvga, mix, lpf0, lpf1;
	uint8 dvga_inc, lpf0_inc, lpf1_inc;
	uint8 max_inc, gain_ticks = extra_gain_3dB;

	if (ISHTPHY(pi)) {
		MAX_DVGA = 4; MAX_LPF = 10; MAX_MIX = 4;
		wlc_phy_table_read_htphy(pi, HTPHY_TBL_ID_RFSEQ, 3, 0x106, 16, &init_gain_code);

		/* Find if the requested gain increase is possible */
		FOREACH_CORE(pi, core) {
			dvga = 0;
			mix = (init_gain_code[core] >> 4) & 0xf;
			lpf0 = (init_gain_code[core] >> 8) & 0xf;
			lpf1 = (init_gain_code[core] >> 12) & 0xf;
			max_inc = MAX(0, MAX_DVGA - dvga) + MAX(0, MAX_LPF - lpf0 - lpf1) +
			        MAX(0, MAX_MIX - mix);
			gain_ticks = MIN(gain_ticks, max_inc);
		}
		if (gain_ticks != extra_gain_3dB) {
			PHY_INFORM(("%s: Unable to find enough extra gain. Using extra_gain = %d\n",
			            __FUNCTION__, 3 * gain_ticks));
		}

		/* Do nothing if no gain increase is required/possible */
		if (gain_ticks == 0) {
			return gain_ticks;
		}

		/* Find the mix, lpf0, lpf1 gains required for extra INITgain */
		FOREACH_CORE(pi, core) {
			uint8 gain_inc = gain_ticks;

			dvga = 0;
			mix = (init_gain_code[core] >> 4) & 0xf;
			lpf0 = (init_gain_code[core] >> 8) & 0xf;
			lpf1 = (init_gain_code[core] >> 12) & 0xf;

			dvga_inc = MIN((uint8) MAX(0, MAX_DVGA - dvga), gain_inc);
			dvga += dvga_inc;
			gain_inc -= dvga_inc;

			lpf1_inc = MIN((uint8) MAX(0, MAX_LPF - lpf1 - lpf0), gain_inc);
			lpf1 += lpf1_inc;
			gain_inc -= lpf1_inc;

			lpf0_inc = MIN((uint8) MAX(0, MAX_LPF - lpf1 - lpf0), gain_inc);
			lpf0 += lpf0_inc;
			gain_inc -= lpf0_inc;

			mix += MIN((uint8) MAX(0, MAX_MIX - mix), gain_inc);

			rxgain[core].lna1 = init_gain_code[core] & 0x3;
			rxgain[core].lna2 = (init_gain_code[core] >> 2) & 0x3;
			rxgain[core].mix  = mix;
			rxgain[core].lpf0 = lpf0;
			rxgain[core].lpf1 = lpf1;
			rxgain[core].dvga = dvga;
		}
	}
	else if (ISACPHY(pi)) {
		gain_ticks = wlc_phy_calc_extra_init_gain_acphy(pi, extra_gain_3dB, rxgain);
	} else {
		PHY_ERROR(("%s: Extra INITgain not supported\n", __FUNCTION__));
		return 0;
	}

	return gain_ticks;
}

static void
wlc_phy_rx_iq_est_aphy(phy_info_t *pi, phy_iq_est_t *est, uint16 num_samps,
	uint8 wait_time, uint8 wait_for_crs)
{
	uint16 offset = (ISAPHY(pi)) ? 0 : GPHY_TO_APHY_OFF;

	/* Get Rx IQ Imbalance Estimate from modem */
	phy_reg_write(pi, (offset+APHY_IqestNumSamps), num_samps);
	phy_reg_mod(pi, (offset+APHY_IqestEnWaitTime), APHY_IqEnWaitTime_waitTime_MASK,
		(wait_time << APHY_IqEnWaitTime_waitTime_SHIFT));
	phy_reg_mod(pi, (offset+APHY_IqestEnWaitTime), APHY_IqMode,
		((wait_for_crs) ? APHY_IqMode : 0));
	phy_reg_mod(pi, (offset+APHY_IqestEnWaitTime), APHY_IqStart, APHY_IqStart);

	/* wait for estimate */
	SPINWAIT(((phy_reg_read(pi, offset+APHY_IqestEnWaitTime) & APHY_IqStart) != 0), 10000);
	ASSERT((phy_reg_read(pi, offset+APHY_IqestEnWaitTime) & APHY_IqStart) == 0);

	if ((phy_reg_read(pi, offset+APHY_IqestEnWaitTime) & APHY_IqStart) == 0) {
		est[0].i_pwr = (phy_reg_read(pi, offset+APHY_IqestIpwrAccHi) << 16) |
			phy_reg_read(pi, offset+APHY_IqestIpwrAccLo);
		est[0].q_pwr = (phy_reg_read(pi, offset+APHY_IqestQpwrAccHi) << 16) |
			phy_reg_read(pi, offset+APHY_IqestQpwrAccLo);
		est[0].iq_prod = (phy_reg_read(pi, offset+APHY_IqestIqAccHi) << 16) |
			phy_reg_read(pi, offset+APHY_IqestIqAccLo);
		PHY_CAL(("i_pwr = %u, q_pwr = %u, iq_prod = %d\n",
			est[0].i_pwr, est[0].q_pwr, est[0].iq_prod));
	} else {
		PHY_ERROR(("%s: IQ measurement timed out\n", __FUNCTION__));
	}
}

static uint32
wlc_phy_rx_iq_est(phy_info_t *pi, uint8 samples, uint8 antsel, uint8 resolution, uint8 lpf_hpc,
                  uint8 dig_lpf, uint8 gain_correct, uint8 extra_gain_3dB, uint8 wait_for_crs,
                  uint8 force_gain_type)
{
	phy_iq_est_t est[PHY_CORE_MAX];
	uint32 cmplx_pwr[PHY_CORE_MAX];
	int8 noise_dbm_ant[PHY_CORE_MAX];
	int16	tot_gain[PHY_CORE_MAX];
	int16	tot_gain_dummy[PHY_CORE_MAX];
	int16 noise_dBm_ant_fine[PHY_CORE_MAX];
	uint16 crsmin_pwr[PHY_CORE_MAX];
	uint16 log_num_samps, num_samps;
	uint16 org_antsel;
	uint8 wait_time = 32;
	bool sampling_in_progress = (pi->phynoise_state != 0);
	uint8 i, extra_gain_1dB = 0;
	uint32 result = 0;

	if ((sampling_in_progress) && (!ISLCNPHY(pi))) {
		PHY_ERROR(("%s: sampling_in_progress\n", __FUNCTION__));

		return 0;
	}

	/* Extra INITgain is supported only for HTPHY currently */
	if (extra_gain_3dB > 0) {
	  if (!ISHTPHY(pi)&&!ISACPHY(pi)) {
			extra_gain_3dB = 0;
			PHY_ERROR(("%s: Extra INITgain not supported for this phy.\n",
			           __FUNCTION__));
		}
	}

	pi->phynoise_state |= PHY_NOISE_STATE_MON;
	/* choose num_samps to be some power of 2 */
	log_num_samps = samples;
	num_samps = 1 << log_num_samps;

	bzero((uint8 *)est, sizeof(est));
	bzero((uint8 *)cmplx_pwr, sizeof(cmplx_pwr));
	bzero((uint8 *)noise_dbm_ant, sizeof(noise_dbm_ant));
	bzero((uint16 *)crsmin_pwr, sizeof(crsmin_pwr));
	bzero((uint16 *)noise_dBm_ant_fine, sizeof(noise_dBm_ant_fine));
	bzero((int16 *)tot_gain, sizeof(tot_gain));
	bzero((int16 *)tot_gain_dummy, sizeof(tot_gain_dummy));
	if (ISACPHY(pi)) {
		FOREACH_CORE(pi, i) {
			tot_gain[i] = ACPHY_RXGAIN_UNSPECIFIED;
		}
	}

	/* get IQ power measurements */
	if (ISNPHY(pi)) {
		uint16  phy_clip_state[2];
		uint16 clip_off[] = {0xffff, 0xffff};
		uint16 classif_state = 0;

		if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 6)) {
			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
			if (lpf_hpc) {
				/* Override the LPF high pass corners to their
				 * lowest values (0x1)
				 */
				wlc_phy_lpf_hpc_override_nphy(pi, TRUE);
			}
		} else {
			classif_state = wlc_phy_classifier_nphy(pi, 0, 0);
			wlc_phy_classifier_nphy(pi, 3, 0);
			wlc_phy_clip_det_nphy(pi, 0, &phy_clip_state[0]);
			wlc_phy_clip_det_nphy(pi, 1, clip_off);
		}

		/* get IQ power measurements */
		wlc_phy_rx_iq_est_nphy(pi, est, num_samps, wait_time, wait_for_crs);

		if (NREV_GE(pi->pubpi.phy_rev, 3) && NREV_LE(pi->pubpi.phy_rev, 6)) {
			if (lpf_hpc) {
				/* Restore LPF high pass corners to their original values */
				wlc_phy_lpf_hpc_override_nphy(pi, FALSE);
			}
			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
		} else {
			wlc_phy_clip_det_nphy(pi, 1, &phy_clip_state[0]);
			/* restore classifier settings and reenable MAC ASAP */
			wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_classifierSel_MASK,
				classif_state);
		}
	} else if (ISHTPHY(pi)) {
		rxgain_t rxgain[PHY_CORE_MAX];
		rxgain_ovrd_t rxgain_ovrd[PHY_CORE_MAX];

		wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
		if (lpf_hpc) {
			/* Override the LPF high pass corners to their lowest values (0x1) */
			wlc_phy_lpf_hpc_override_htphy(pi, TRUE);
		}

		/* Overide the digital LPF */
		if (dig_lpf) {
			wlc_phy_dig_lpf_override_htphy(pi, dig_lpf);
		}

		/* Increase INITgain if requested */
		if (extra_gain_3dB > 0) {
			extra_gain_3dB = wlc_phy_calc_extra_init_gain(pi, extra_gain_3dB, rxgain);

			/* Override higher INITgain if possible */
			if (extra_gain_3dB > 0) {
				wlc_phy_rfctrl_override_rxgain_htphy(pi, 0, rxgain, rxgain_ovrd);
			}
		}

		/* get IQ power measurements */
		wlc_phy_rx_iq_est_htphy(pi, est, num_samps, wait_time, wait_for_crs);

		/* Disable the overrides if they were set */
		if (extra_gain_3dB > 0) {
			wlc_phy_rfctrl_override_rxgain_htphy(pi, 1, NULL, rxgain_ovrd);
		}

		if (lpf_hpc) {
			/* Restore LPF high pass corners to their original values */
			wlc_phy_lpf_hpc_override_htphy(pi, FALSE);
		}

		/* Restore the digital LPF */
		if (dig_lpf) {
			wlc_phy_dig_lpf_override_htphy(pi, 0);
		}
		wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
	} else if (ISACPHY(pi)) {
		rxgain_t rxgain[PHY_CORE_MAX];
		rxgain_ovrd_t rxgain_ovrd[PHY_CORE_MAX];
		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

		if (force_gain_type != 0) {
			wlc_phy_get_rxgain_acphy(pi, rxgain, tot_gain, force_gain_type);
			wlc_phy_rfctrl_override_rxgain_acphy(pi, 0, rxgain, rxgain_ovrd);
			PHY_RXIQ(("In %s: For gain type = %d | Total gain being applied = %d \n",
				__FUNCTION__, force_gain_type, tot_gain[0]));
		} else {
			PHY_RXIQ(("In %s: For gain type = %d | Total gain being applied = %d \n",
				__FUNCTION__, force_gain_type, ACPHY_NOISE_INITGAIN));
		}

		if (lpf_hpc) {
			/* Override the LPF high pass corners to their lowest values (0x1) */
			wlc_phy_lpf_hpc_override_acphy(pi, TRUE);
		}
		/* Overide the digital LPF */
		if (!TINY_RADIO(pi) && dig_lpf) {
			wlc_phy_dig_lpf_override_acphy(pi, dig_lpf);
		}

		/* Increase INITgain if requested */
		if (extra_gain_3dB > 0) {
			extra_gain_3dB = wlc_phy_calc_extra_init_gain(pi, extra_gain_3dB, rxgain);

			/* Override higher INITgain if possible */
			if (extra_gain_3dB > 0) {
				wlc_phy_rfctrl_override_rxgain_acphy(pi, 0, rxgain, rxgain_ovrd);
			}
		}

		/* get IQ power measurements */
		wlc_phy_rx_iq_est_acphy(pi, est, num_samps, wait_time, wait_for_crs, FALSE);
		/* Disable the overrides if they were set */
		if (extra_gain_3dB > 0) {
			wlc_phy_rfctrl_override_rxgain_acphy(pi, 1, NULL, rxgain_ovrd);
		}
		if (lpf_hpc) {
			/* Restore LPF high pass corners to their original values */
			wlc_phy_lpf_hpc_override_acphy(pi, FALSE);
		}
		/* Restore the digital LPF */
		if (!TINY_RADIO(pi) && dig_lpf) {
			wlc_phy_dig_lpf_override_acphy(pi, 0);
		}

		if (force_gain_type != 0) {
			if ((force_gain_type == 4) ||
				((force_gain_type == 3) && (pi_ac->mdgain_trtx_allowed))) {
				wlc_phy_get_rxgain_acphy(pi, rxgain, tot_gain_dummy, 6);
			}
			wlc_phy_rfctrl_override_rxgain_acphy(pi, 1, NULL, rxgain_ovrd);
		}

		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	} else if (ISLPPHY(pi)) {
		wlc_phy_set_deaf_lpphy(pi, (bool)0);
		noise_dbm_ant[0] = (int8)wlc_phy_rx_signal_power_lpphy(pi, 20);
		wlc_phy_clear_deaf_lpphy(pi, (bool)0);
		PHY_CAL(("channel = %d noise pwr=%d\n",
			(int)CHSPEC_CHANNEL(pi->radio_chanspec), noise_dbm_ant[0]));

		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
		return (noise_dbm_ant[0] & 0xff);
	} else if (ISSSLPNPHY(pi)) {
		PHY_ERROR(("%s: SSLPNPHY not supported yet\n", __FUNCTION__));
		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
		return 0;
	} else if (ISLCNPHY(pi)) {
#if defined(WLTEST)
		uint8 save_antsel;
		(void)wlc_phy_ant_rxdiv_get((wlc_phy_t *)pi, &save_antsel);
		if (antsel <= 1)
			wlc_phy_ant_rxdiv_set((wlc_phy_t *)pi, antsel);
		wlc_lcnphy_rx_power(pi, num_samps, wait_time, wait_for_crs, est);
		wlc_phy_ant_rxdiv_set((wlc_phy_t *)pi, save_antsel);
#else
		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
		return 0;
#endif // endif
	} else if (ISLCN40PHY(pi)) {
#if defined(WLTEST)
		uint8 save_antsel;
		(void)wlc_phy_ant_rxdiv_get((wlc_phy_t *)pi, &save_antsel);
		if (antsel <= 1)
			wlc_phy_ant_rxdiv_set((wlc_phy_t *)pi, antsel);
		wlc_lcn40phy_rx_power(pi, num_samps, wait_time, wait_for_crs, est);
		wlc_phy_ant_rxdiv_set((wlc_phy_t *)pi, save_antsel);
#else
		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
		return 0;
#endif // endif
	} else {	/* APHY, GPHY */
		uint16 val;
		uint16 bbconfig_reg = APHY_BBCONFIG + ((ISAPHY(pi)) ? 0 : GPHY_TO_APHY_OFF);
		org_antsel = ((val = phy_reg_read(pi, bbconfig_reg)) & PHY_BBC_ANT_MASK);
		phy_reg_mod(pi, bbconfig_reg, PHY_BBC_ANT_MASK, antsel);
		phy_reg_write(pi, bbconfig_reg, val | BBCFG_RESETCCA);
		phy_reg_write(pi, bbconfig_reg, val & (~BBCFG_RESETCCA));
		wlc_phy_rx_iq_est_aphy(pi, est, num_samps, wait_time, wait_for_crs);
		phy_reg_mod(pi, bbconfig_reg, PHY_BBC_ANT_MASK, org_antsel);
		val = phy_reg_read(pi, bbconfig_reg);
		phy_reg_write(pi, bbconfig_reg, val | BBCFG_RESETCCA);
		phy_reg_write(pi, bbconfig_reg, val & (~BBCFG_RESETCCA));
	}

	/* sum I and Q powers for each core, average over num_samps with rounding */
	ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);
	FOREACH_CORE(pi, i) {
		cmplx_pwr[i] = ((est[i].i_pwr + est[i].q_pwr) +
			(1U << (log_num_samps-1))) >> log_num_samps;
	}

	/* convert in 1dB gain for gain adjustment */
	extra_gain_1dB = 3 * extra_gain_3dB;

	if (resolution == 0) {
		/* pi->phy_noise_win per antenna is updated inside */
		wlc_phy_noise_calc(pi, cmplx_pwr, noise_dbm_ant, extra_gain_1dB);

		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;

		for (i = PHYCORENUM(pi->pubpi.phy_corenum); i >= 1; i--)
			result = (result << 8) | (noise_dbm_ant[i-1] & 0xff);

		return result;
	}
	else if (resolution == 1) {
		/* Reports power in finer resolution than 1 dB (currently 0.25 dB) */

		if (((ISHTPHY(pi)) && (PHYCORENUM(pi->pubpi.phy_corenum) == 3)) ||
			(ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 3) &&
			NREV_LE(pi->pubpi.phy_rev, 6))) || CHIPID_4324X_EPA_FAMILY(pi) ||
			(ISLCNPHY(pi) && LCNREV_GE(pi->pubpi.phy_rev, 2)) ||
			(ISLCN40PHY(pi))||(ISACPHY(pi)))  {
			int16 noisefloor;

			wlc_phy_noise_calc_fine_resln(pi, cmplx_pwr, crsmin_pwr, noise_dBm_ant_fine,
				extra_gain_1dB, tot_gain);

			if ((gain_correct == 3) || (gain_correct == 4)) {
				int8 subband_idx, core, bw_idx, tmp_range;
				acphy_rssioffset_t *pi_ac_rssioffset =
				        &pi->u.pi_acphy->srom.rssioffset;
				/* If rssi_cal_rev is FALSE, then rssi_gain_delta is in 1 dB steps
				 * So, this has to be adj in the tot_gain which is in 1 dB steps.
				 * Can't apply 0.25 dB steps as we can't apply comp with tot_gain
				 * So, have to apply it with tempsense comp which is in 0.25dB steps
				 */
				if (ISACPHY(pi) && (pi->u.pi_acphy->rssi_cal_rev == FALSE)) {
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						bw_idx = (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
					} else {
						bw_idx = (CHSPEC_IS80(pi->radio_chanspec)) ? 2 :
						        (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
					}

					/* Apply nvram based offset: */
					FOREACH_CORE(pi, core) {
						if (CHSPEC_IS2G(pi->radio_chanspec)) {
						  noise_dBm_ant_fine[core] +=
						    pi_ac_rssioffset
						    ->rssi_corr_gain_delta_2g[core]
						    [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx] << 2;
						  PHY_RXIQ(("In %s: rssi_gain_delta_offset for"
							    " core %d = %d (in dB) \n",
							    __FUNCTION__, core, pi_ac_rssioffset
							    ->rssi_corr_gain_delta_2g[core]
							    [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx]));
						} else {
						  tmp_range =  wlc_phy_get_chan_freq_range_acphy(pi,
						    CHSPEC_CHANNEL(pi->radio_chanspec));
						  if ((tmp_range > 0) && (tmp_range < 5)) {
						    subband_idx = tmp_range -1;
						    noise_dBm_ant_fine[core]  +=
						      pi_ac_rssioffset
						      ->rssi_corr_gain_delta_5g[core][0][bw_idx]
						      [subband_idx] << 2;
						    PHY_RXIQ(("In %s: rssi_gain_delta_offset for"
							      " core %d = %d (in dB) \n",
							      __FUNCTION__, core, pi_ac_rssioffset
							      ->rssi_corr_gain_delta_5g[core]
							      [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx]
							      [subband_idx]));
						  }
						}
					}
				}
			}

#ifdef WL11AC
			/* This peice of code will be executed
			 *only if resolution is 1, => qdBm steps.
			 */
			if ((pi->u.pi_acphy->rssi_cal_rev == TRUE) &&
			     (pi->u.pi_acphy->rxgaincal_rssical == TRUE)) {
				int16	rssi_gain_delta_qdBm[PHY_CORE_MAX];
				int16 rssi_temp_delta_qdBm[PHY_CORE_MAX];
				int16 curr_temp, gain_temp_slope = 0;
				int16 tmp_temp_delta;
				FOREACH_CORE(pi, i) {
				  rssi_gain_delta_qdBm[i] = 0;
				}

				if ((gain_correct == 4 && ISACPHY(pi))) {
					/* This is absolute temp gain compensation
					 * This has to be applied only for Rudimentary AGC.
					 * For this, -g 4 option has to be given.
					 * For iqest cali and veri, we do not apply this
					 * absolute gain temp compensation.
					 */
					FOREACH_CORE(pi, i) {
					  if (CHSPEC_IS2G(pi->radio_chanspec)) {
					    int8 tmp_range;
					    tmp_range = wlc_phy_rssi_get_chan_freq_range_acphy(pi,
					      CHSPEC_CHANNEL(pi->radio_chanspec));
					    gain_temp_slope = pi->u.pi_acphy->srom.
					      rxgain_tempadj_2g_sub[i][tmp_range];
					    /* 57 = 5.7 dB change in gain
					     * for 100 degrees change
					     */
					  } else {
					    int8 tmp_range;
					    tmp_range =  wlc_phy_get_chan_freq_range_acphy(pi,
					      CHSPEC_CHANNEL(pi->radio_chanspec));
					    if (tmp_range == 1) {
					      gain_temp_slope =
					        pi->u.pi_acphy->srom.rxgain_tempadj_5gl[i];
					    } else if (tmp_range == 2) {
					      gain_temp_slope =
					        pi->u.pi_acphy->srom.rxgain_tempadj_5gml[i];
					    } else if (tmp_range == 3) {
					      gain_temp_slope =
					        pi->u.pi_acphy->srom.rxgain_tempadj_5gmu[i];
					    } else if (tmp_range == 4) {
					      gain_temp_slope =
					        pi->u.pi_acphy->srom.rxgain_tempadj_5gh[i];
					    }
					  }

					  curr_temp = wlc_phy_tempsense_acphy(pi);

					  if (curr_temp >= 0) {
					    rssi_temp_delta_qdBm[i] = (curr_temp *
					      gain_temp_slope * 2 + 250)/500;
					  } else {
					    rssi_temp_delta_qdBm[i] = (curr_temp *
					      gain_temp_slope * 2 - 250)/500;
					  }
					}
				} else {
					/* SO, if it is here, -g 4 option was not provided.
					 * And both rssi_cal_rev and rxgaincal_rssical were TRUE.
					 * So, apply gain_cal_temp based copensation for tone
					 * calibration and verification. Hopefully for calibration
					 * the coeff are 0's and thus no compensation is applied.
					*/
					FOREACH_CORE(pi, i) {
						wlc_phy_tempsense_acphy(pi);
						wlc_phy_upd_gain_wrt_gain_cal_temp_phy(pi,
						  &tmp_temp_delta, (int)i);
						rssi_temp_delta_qdBm[i] = tmp_temp_delta;
					}

				}

				if ((pi->u.pi_acphy->rssi_cal_rev == TRUE) &&
				    (pi->u.pi_acphy->rxgaincal_rssical == TRUE)) {
					int8 subband_idx, core, bw_idx;
					acphy_rssioffset_t *pi_ac_rssioffset =
					  &pi->u.pi_acphy->srom.rssioffset;
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						bw_idx = (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
					} else {
						bw_idx = (CHSPEC_IS80(pi->radio_chanspec)) ? 2 :
						  (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
					}

					/* Apply nvram based offset: */
					FOREACH_CORE(pi, core) {
						subband_idx =
						  wlc_phy_rssi_get_chan_freq_range_acphy(pi,
						  CHSPEC_CHANNEL(pi->radio_chanspec));
						if (CHSPEC_IS2G(pi->radio_chanspec)) {
						  rssi_gain_delta_qdBm[core] =
						    pi_ac_rssioffset
						    ->rssi_corr_gain_delta_2g_sub[core]
						    [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx][subband_idx];
						} else {
						  if ((subband_idx >= 0) && (subband_idx < 5)) {
						    rssi_gain_delta_qdBm[core] =
						      pi_ac_rssioffset
						      ->rssi_corr_gain_delta_5g_sub
						      [core][ACPHY_GAIN_DELTA_ELNA_ON][bw_idx]
						      [subband_idx];
						  }
						}
					}
				} else {
					/* False part i.e. gain delta in 1 dB step is being applied
					 *  in if (gain_correct == 3 && gain_correct == 4)
					 */
					FOREACH_CORE(pi, i) {
						rssi_gain_delta_qdBm[i] = 0;
					}
				}
				FOREACH_CORE(pi, i) {
				  noise_dBm_ant_fine[i] += rssi_temp_delta_qdBm[i] +
				    rssi_gain_delta_qdBm[i];
				  PHY_RXIQ(("In %s: | Core %d | temp_delta_qdBm = %d (qdB)"
					    "| gain_delta_qdBm = %d (qdB) |"
					    "RXIQEST = %d (qdB)\n", __FUNCTION__, i,
					    rssi_temp_delta_qdBm[i], rssi_gain_delta_qdBm[i],
					    noise_dBm_ant_fine[i]));
				}
			}
#endif /* WL11AC */
			if ((gain_correct == 1) || (gain_correct == 2) || gain_correct == 3) {
				int16 gainerr[PHY_CORE_MAX];
				int16 gain_err_temp_adj;
				wlc_phy_get_rxgainerr_phy(pi, gainerr);

				/* make and apply temperature correction */
				if (ISHTPHY(pi)) {
					/* Read and (implicitly) store current temperature */
					wlc_phy_tempsense_htphy(pi);
				} else if (ISACPHY(pi)) {
					/* Read and (implicitly) store current temperature */
					wlc_phy_tempsense_acphy(pi);
				}
				wlc_phy_upd_gain_wrt_temp_phy(pi, &gain_err_temp_adj);

				FOREACH_CORE(pi, i) {
					/* gainerr is in 0.5dB units;
					 * need to convert to 0.25dB units
					 */
				    if (gain_correct == 1) {
				    gainerr[i] = gainerr[i] << 1;
					/* Apply gain correction */
					noise_dBm_ant_fine[i] -= gainerr[i];
					}
					noise_dBm_ant_fine[i] += gain_err_temp_adj;
				}
			}

			if (ISLCNPHY(pi))
				noisefloor = 4*LCNPHY_NOISE_FLOOR_20M;
			if (ISLCN40PHY(pi))
				noisefloor = (CHSPEC_IS40(pi->radio_chanspec))?
					4*LCN40PHY_NOISE_FLOOR_40M : 4*LCN40PHY_NOISE_FLOOR_20M;
			else if (ISACPHY(pi)) {
				if (CHSPEC_IS40(pi->radio_chanspec))
					noisefloor = 4*ACPHY_NOISE_FLOOR_40M;
				else if (CHSPEC_IS20(pi->radio_chanspec))
					noisefloor = 4*ACPHY_NOISE_FLOOR_20M;
				else
					noisefloor = 4*ACPHY_NOISE_FLOOR_80M;
			} else
				noisefloor = (CHSPEC_IS40(pi->radio_chanspec))?
					4*HTPHY_NOISE_FLOOR_40M : 4*HTPHY_NOISE_FLOOR_20M;

			/* DO NOT do flooring of estimate if the Chip is 4350 AND gain correct is 0.
			 * In other words,
			 * DO flooring for ALL chips other than 4350 AND
			 * DO flooring for 4350 if gain correct is done - ie, -g is 1/2/3/4.
			 */
			if (!(ACMAJORREV_2(pi->pubpi.phy_rev) && (gain_correct == 0))) {
				FOREACH_CORE(pi, i) {
					if (noise_dBm_ant_fine[i] < noisefloor) {
					        noise_dBm_ant_fine[i] = noisefloor;
					}
				}
			}

			for (i = PHYCORENUM(pi->pubpi.phy_corenum); i >= 1; i--) {
				result = (result << 10) | (noise_dBm_ant_fine[i-1] & 0x3ff);
			}
			pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
			return result;
		}
		else {
			PHY_ERROR(("%s: Fine-resolution reporting not supported\n", __FUNCTION__));
			pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
			return 0;
		}
	}

	pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
	return 0;
}

bool
wlc_phy_get_rxgainerr_phy(phy_info_t *pi, int16 *gainerr)
{
	/*
	 * Retrieves rxgain error (read from srom) for current channel;
	 * Returns TRUE if no gainerror was written to SROM, FALSE otherwise
	 */
	uint8 core;
	bool srom_isempty;

	if (ISLCNPHY(pi)) {
#if defined(WLTEST)
		wlc_phy_get_rxgainerr_lcnphy(pi, gainerr);
#endif // endif
		return 1;
	} else if (ISLCN40PHY(pi)) {
#if defined(WLTEST)
		wlc_phy_get_rxgainerr_lcn40phy(pi, gainerr);
#endif // endif
		return 1;
	} else if (!((ISNPHY(pi) && (NREV_GE(pi->pubpi.phy_rev, 3) &&
		NREV_LE(pi->pubpi.phy_rev, 6))) || ISHTPHY(pi) || ISACPHY(pi))) {
		return 0;
	} else {
#ifdef BAND5G
		if (CHSPEC_CHANNEL(pi->radio_chanspec) > 14) {
			/* 5G */
			if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 48) {
				/* 5G-low: channels 36 through 48 */
				FOREACH_CORE(pi, core) {
					gainerr[core] = (int16) pi->rxgainerr_5gl[core];
				}
				srom_isempty = pi->rxgainerr5gl_isempty;
			} else if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 64) {
				/* 5G-mid: channels 52 through 64 */
				FOREACH_CORE(pi, core) {
					gainerr[core] = (int16) pi->rxgainerr_5gm[core];
				}
				srom_isempty = pi->rxgainerr5gm_isempty;
			} else if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 128) {
				/* 5G-high: channels 100 through 128 */
				FOREACH_CORE(pi, core) {
					gainerr[core] = (int16) pi->rxgainerr_5gh[core];
				}
				srom_isempty = pi->rxgainerr5gh_isempty;
			} else {
				/* 5G-upper: channels 132 and above */
				FOREACH_CORE(pi, core) {
					gainerr[core] = (int16) pi->rxgainerr_5gu[core];
				}
				srom_isempty = pi->rxgainerr5gu_isempty;
			}
		} else
#endif /* BAND5G */
		{
			/* 2G */
			FOREACH_CORE(pi, core) {
				gainerr[core] = (int16) pi->rxgainerr_2g[core];
			}
			srom_isempty = pi->rxgainerr2g_isempty;
		}
	}
	return srom_isempty;
}

#ifdef NOISE_CAL_LCNXNPHY
void wlc_phy_noise_trigger_ucode(phy_info_t *pi)
{
	/* ucode assumes these shm locations start with 0
	 * and ucode will not touch them in case of sampling expires
	 */
	wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);
	wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);
	wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);
	wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);
	if (ISHTPHY(pi)|ISACPHY(pi)) {
		wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP4, 0);
		wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP5, 0);
	}

	W_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);

}
#endif /* NOISE_CAL_LCNXNPHY */
void
wlc_phy_reset_iqest_blk(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint16 orig_forceclk, new_forceclk;
	bool suspend;

	if (!ISNPHY(pi))
		return;

	/* suspend mac if not suspended before */
	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend)
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

	orig_forceclk = phy_reg_read(pi, NPHY_forceClk);
	new_forceclk =  (orig_forceclk | 0x9);
	phy_reg_write(pi, NPHY_forceClk, new_forceclk);
	wlc_phy_resetcca_nphy(pi);
	phy_reg_write(pi, NPHY_forceClk, orig_forceclk);

	if (!suspend)
		wlapi_enable_mac(pi->sh->physhim);
}
/* This is the unified entry point for all phy noise sampling for all PHYs.
 *   It support both sw polling and ucode interrupt noise sampling.
 *	??? how to ensure coexistence
 *	XXX need to trace PHY_NOISE_SAMPLE_CQRM case, which may be recursive
 *
 *   Polling will finish atomically. For interrupt, wlc_phy_noise_sample_intr will collect results.
 *   Both methods can coexist and requests can be concurrent. But at any given time,
 *     only one can sampling can be in progress to avoid disturbing the PHY IQest engine.
 *   wlc_phy_noise_cb is called to propagate results to all consumers, where
 *   the phynoise_state flags and channel matching ensure sampling results are not misused.
 */
static void
wlc_phy_noise_sample_request(wlc_phy_t *pih, uint8 reason, uint8 ch)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
	bool sampling_in_progress = (pi->phynoise_state != 0);
	bool wait_for_intr = TRUE;

	PHY_NONE(("wlc_phy_noise_sample_request: state %d reason %d, channel %d\n",
		pi->phynoise_state, reason, ch));
	/* JIRA:SWWLAN-38643 When noise measurement times out, in the latest implementation,
	 * ucode doesn't give an interruptand hence pi->phynoise_state doesn't get to zero.
	 * Adding more approrpiate condition for checking if noise sampling is in progress
	 */
#ifdef EPA_CHIP_4324X
	sampling_in_progress =
		(R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->maccommand) & MCMD_BG_NOISE);
#endif // endif

	/* This is needed to make sure that the crsmin cal happens
	*   even if sampling is in progress
	*/
	if (ISACPHY(pi)) {
		pi->u.pi_acphy->trigger_crsmin_cal = FALSE;
		if (reason == PHY_NOISE_STATE_CRSMINCAL && sampling_in_progress) {
			pi->u.pi_acphy->trigger_crsmin_cal = TRUE;
		}
	}

	/* since polling is atomic, sampling_in_progress equals to interrupt sampling ongoing
	 *  In these collision cases, always yield and wait interrupt to finish, where the results
	 *  maybe be sharable if channel matches in common callback progressing.
	 */
	if (sampling_in_progress)
		return;

	switch (reason) {
	case PHY_NOISE_SAMPLE_MON:

		pi->phynoise_chan_watchdog = ch;
		pi->phynoise_state |= PHY_NOISE_STATE_MON;

		break;

	case PHY_NOISE_SAMPLE_EXTERNAL:

		pi->phynoise_state |= PHY_NOISE_STATE_EXTERNAL;
		break;

	case PHY_NOISE_SAMPLE_CRSMINCAL:

		if (ISACPHY(pi)) {
			pi->phynoise_state |= PHY_NOISE_STATE_CRSMINCAL;
			break;
		}

	default:
		ASSERT(0);
		break;
	}

	/* start test, save the timestamp to recover in case ucode gets stuck */
	pi->phynoise_now = pi->sh->now;

	/* Fixed noise, don't need to do the real measurement */
	if (pi->phy_fixed_noise) {
		if (ISNPHY(pi) || ISHTPHY(pi)) {
			uint8 i;
			FOREACH_CORE(pi, i) {
				pi->phy_noise_win[i][pi->phy_noise_index] =
					PHY_NOISE_FIXED_VAL_NPHY;
			}
			pi->phy_noise_index = MODINC_POW2(pi->phy_noise_index,
				PHY_NOISE_WINDOW_SZ);
			/* legacy noise is the max of antennas */
			noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
		} else {
			/* all other PHY */
			noise_dbm = PHY_NOISE_FIXED_VAL;
		}

		wait_for_intr = FALSE;
		goto done;
	}

	if (ISLPPHY(pi)) {
		/* CQRM always use interrupt since ccx can issue many requests and
		 * suspend_mac can't finish intime
		 */
		if (!pi->phynoise_polling || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {
			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_1, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);

			W_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);
		} else {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_set_deaf_lpphy(pi, (bool)0);
			noise_dbm = (int8)wlc_phy_rx_signal_power_lpphy(pi, 20);
			wlc_phy_clear_deaf_lpphy(pi, (bool)0);
			wlapi_enable_mac(pi->sh->physhim);
			PHY_CAL(("channel = %d noise pwr=%d\n",
				(int)CHSPEC_CHANNEL(pi->radio_chanspec), noise_dbm));
			wait_for_intr = FALSE;
		}
	} else if (ISSSLPNPHY(pi)) {
		noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
	} else if (ISLCN40PHY(pi)) {
		wlc_lcn40phy_noise_measure_start(pi, FALSE);
	} else if (ISLCNPHY(pi)) {
		/* Trigger noise cal but don't adjust anything */
		wlc_lcnphy_noise_measure_start(pi, FALSE);
	} else if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		if (!pi->phynoise_polling || (reason == PHY_NOISE_SAMPLE_EXTERNAL) ||
			(reason == PHY_NOISE_SAMPLE_CRSMINCAL)) {

			/* ucode assumes these shm locations start with 0
			 * and ucode will not touch them in case of sampling expires
			 */
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP0, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP1, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP2, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP3, 0);

			if (ISHTPHY(pi) || ISACPHY(pi)) {
				wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP4, 0);
				wlapi_bmac_write_shm(pi->sh->physhim, M_PWRIND_MAP5, 0);
			}

			W_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);

		} else {

			/* polling mode */
			phy_iq_est_t est[PHY_CORE_MAX];
			uint32 cmplx_pwr[PHY_CORE_MAX];
			int8 noise_dbm_ant[PHY_CORE_MAX];
			uint16 log_num_samps, num_samps, classif_state = 0;
			uint8 wait_time = 32;
			uint8 wait_crs = 0;
			uint8 i;

			bzero((uint8 *)est, sizeof(est));
			bzero((uint8 *)cmplx_pwr, sizeof(cmplx_pwr));
			bzero((uint8 *)noise_dbm_ant, sizeof(noise_dbm_ant));

			/* choose num_samps to be some power of 2 */
			log_num_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
			num_samps = 1 << log_num_samps;

			/* suspend MAC, get classifier settings, turn it off
			 * get IQ power measurements
			 * restore classifier settings and reenable MAC ASAP
			*/
			wlapi_suspend_mac_and_wait(pi->sh->physhim);

			if (ISNPHY(pi)) {
				classif_state = wlc_phy_classifier_nphy(pi, 0, 0);
				wlc_phy_classifier_nphy(pi, 3, 0);
				wlc_phy_rx_iq_est_nphy(pi, est, num_samps, wait_time, wait_crs);
				wlc_phy_classifier_nphy(pi, NPHY_ClassifierCtrl_classifierSel_MASK,
					classif_state);
			} else if (ISHTPHY(pi)) {
				classif_state = wlc_phy_classifier_htphy(pi, 0, 0);
				wlc_phy_classifier_htphy(pi, 3, 0);
				wlc_phy_rx_iq_est_htphy(pi, est, num_samps, wait_time, wait_crs);
				wlc_phy_classifier_htphy(pi,
					HTPHY_ClassifierCtrl_classifierSel_MASK, classif_state);
			} else if (ISACPHY(pi)) {
			  classif_state = wlc_phy_classifier_acphy(pi, 0, 0);
			  wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK, 0);
			  wlc_phy_rx_iq_est_acphy(pi, est, num_samps, wait_time, wait_crs, FALSE);
				wlc_phy_classifier_acphy(pi,
					ACPHY_ClassifierCtrl_classifierSel_MASK, classif_state);
			} else {
				ASSERT(0);
			}

			wlapi_enable_mac(pi->sh->physhim);

			/* sum I and Q powers for each core, average over num_samps */
			FOREACH_CORE(pi, i)
				cmplx_pwr[i] = (est[i].i_pwr + est[i].q_pwr) >> log_num_samps;

			/* pi->phy_noise_win per antenna is updated inside */
			wlc_phy_noise_calc(pi, cmplx_pwr, noise_dbm_ant, 0);
			wlc_phy_noise_save(pi, noise_dbm_ant, &noise_dbm);

			wait_for_intr = FALSE;
		}
	} else if (ISAPHY(pi)) {
		if (!pi->phynoise_polling || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {
			/* For A PHY we must set the radio to return RSSI data to RSSI ADC */
			uint16 reg;

			wlc_phyreg_enter(pih);
			wlc_radioreg_enter(pih);
			/* set temp reading delay to zero */
			reg = phy_reg_read(pi, APHY_RSSI_ADC_CTL);
			reg = (reg & 0xF0FF);
			phy_reg_write(pi, APHY_RSSI_ADC_CTL, reg);

			/* grab the default value for this radio */
			reg = read_radio_reg(pi, RADIO_2060WW_RX_SP_REG1);
			wlc_radioreg_exit(pih);
			wlc_phyreg_exit(pih);

			/* save the radio reg default value for ucode
			 * to restore after measurements
			 */
			wlapi_bmac_write_shm(pi->sh->physhim, M_RF_RX_SP_REG1, reg);

			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_1, 0);

			W_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);

		} else {
			noise_dbm = wlc_phy_noise_sample_aphy_meas(pi);
			wait_for_intr = FALSE;
		}
	} else if (ISGPHY(pi)) {
		/* B/GPHY */
		if (!pi->phynoise_polling || (reason == PHY_NOISE_SAMPLE_EXTERNAL)) {
			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_0, 0);
			wlapi_bmac_write_shm(pi->sh->physhim, M_JSSI_1, 0);
			W_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);

		} else {
			noise_dbm = wlc_phy_noise_sample_gphy(pi);
			wait_for_intr = FALSE;
		}
	} else {
		PHY_TRACE(("Fallthru nophy\n"));
		/* No phy ?? */
		return;
	}

done:
	/* if no interrupt scheduled, populate noise results now */
	if (!wait_for_intr)
		wlc_phy_noise_cb(pi, ch, noise_dbm);
}

void
wlc_phy_noise_sample_request_external(wlc_phy_t *pih)
{
	uint8  channel;

	channel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));

	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_EXTERNAL, channel);
}

void
wlc_phy_noise_sample_request_crsmincal(wlc_phy_t *pih)
{
	uint8  channel;

	channel = CHSPEC_CHANNEL(wlc_phy_chanspec_get(pih));

	wlc_phy_noise_sample_request(pih, PHY_NOISE_SAMPLE_CRSMINCAL, channel);
}

void
wlc_phy_noise_cb(phy_info_t *pi, uint8 channel, int8 noise_dbm)
{
	int8 i;
	if (!pi->phynoise_state)
		return;

	PHY_NONE(("wlc_phy_noise_cb: state %d noise %d channel %d\n",
	          pi->phynoise_state, noise_dbm, channel));
	if (pi->phynoise_state & PHY_NOISE_STATE_MON) {
		if (pi->phynoise_chan_watchdog == channel) {
			/* JIRA:SWWLAN-36824 For the first time, fill up all the entries in array
			   with measured value so that the noise value reported by wl noise makes
			   sense right from the beginning
			 */
			if (pi->noise_mmt_first_time) {
				for (i = 0; i < MA_WINDOW_SZ; i++)
					pi->sh->phy_noise_window[i] = noise_dbm;
				pi->noise_mmt_first_time = FALSE;
			}

			pi->sh->phy_noise_window[pi->sh->phy_noise_index] = noise_dbm;
			pi->sh->phy_noise_index = MODINC(pi->sh->phy_noise_index, MA_WINDOW_SZ);
		}
		pi->phynoise_state &= ~PHY_NOISE_STATE_MON;
	}

	if (pi->phynoise_state & PHY_NOISE_STATE_EXTERNAL) {
		pi->phynoise_state &= ~PHY_NOISE_STATE_EXTERNAL;

		wlapi_noise_cb(pi->sh->physhim, channel, noise_dbm);
	}

	if (ISACPHY(pi)) {
		if (pi->phynoise_state & PHY_NOISE_STATE_CRSMINCAL)
			pi->phynoise_state &= ~PHY_NOISE_STATE_CRSMINCAL;
	}
}

int8
wlc_phy_noise_read_shmem(phy_info_t *pi)
{
	uint32 cmplx_pwr[PHY_CORE_MAX];
	int8 noise_dbm_ant[PHY_CORE_MAX];
	uint16 lo, hi;
	uint32 cmplx_pwr_tot = 0;
	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
	uint8 core;
#ifdef EPA_CHIP_4324X
	noise_dbm = PHY_NOISE_FIXED_VAL_NPHY_4324x_EPA;
#endif // endif
	bool medium_busy = FALSE;

	ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);
	bzero((uint8 *)cmplx_pwr, sizeof(cmplx_pwr));
	bzero((uint8 *)noise_dbm_ant, sizeof(noise_dbm_ant));

	if (ISACPHY(pi)) {
		medium_busy = (wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(1)) & 0x8000) != 0;
	}
	/* read SHM, reuse old corerev PWRIND since we are tight on SHM pool */
	FOREACH_CORE(pi, core) {
		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(2*core));
		hi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(2*core+1));
		cmplx_pwr[core] = ((hi & 0x7fff) << 16) + lo;
		cmplx_pwr_tot += cmplx_pwr[core];
		if (cmplx_pwr[core] == 0 || medium_busy) {
#ifdef EPA_CHIP_4324X
			noise_dbm_ant[core] = PHY_NOISE_FIXED_VAL_NPHY_4324x_EPA;
#else
			noise_dbm_ant[core] = PHY_NOISE_FIXED_VAL_NPHY;
#endif // endif
		} else
			cmplx_pwr[core] >>= PHY_NOISE_SAMPLE_LOG_NUM_UCODE;
	}

	if (cmplx_pwr_tot == 0) {
		PHY_INFORM(("%s: timeout in ucode\n", __FUNCTION__));
	} else if (medium_busy) {
		PHY_INFORM(("%s: medium busy detected by ucode\n", __FUNCTION__));
	} else {
#ifdef NOISE_CAL_LCNXNPHY
		if ((NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV) ||
			NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 2)) &&
			ISNPHY(pi)) {
			wlc_phy_noisepwr_nphy(pi, cmplx_pwr);
		}
#endif // endif
		wlc_phy_noise_calc(pi, cmplx_pwr, noise_dbm_ant, 0);
		/* Putting check here to see if crsmin cal needs to be triggered */
		if (ISACPHY(pi)) {
			if ((pi->phynoise_state == PHY_NOISE_STATE_CRSMINCAL) ||
			pi->u.pi_acphy->trigger_crsmin_cal) {
				wlc_phy_crs_min_pwr_cal_acphy(pi, PHY_CRS_RUN_AUTO);
			}
		}
	}

	wlc_phy_noise_save(pi, noise_dbm_ant, &noise_dbm);

	/* legacy noise is the max of antennas */
	return noise_dbm;

}

/* ucode detected ACI, apply mitigation settings */
void
wlc_phy_hwaci_mitigate_intr(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;

	if (ISACPHY(pi) && !ACPHY_ENABLE_FCBS_HWACI(pi)) {
		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

		pi_ac->hw_aci_status = wlapi_bmac_read_shm(pi->sh->physhim, M_HWACI_ST) & 0x1;
		PHY_ACI(("HWACI Reading SHMEM 0x14*2 = %d \n", pi_ac->hw_aci_status));
	}
}

/* ucode finished phy noise measurement and raised interrupt */
void
wlc_phy_noise_sample_intr(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int jssi[4];
	uint8 crs_state;
	uint16 jssi_pair, jssi_aux;
	uint8 channel = 0;
	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
	if (ISLPPHY(pi)) {
		uint32 cmplx_pwr_tot, cmplx_pwr[PHY_CORE_MAX];
		int8 cmplx_pwr_dbm[PHY_CORE_MAX];
		uint16 lo, hi;
		int32 pwr_offset_dB, gain_dB;
		uint16 status_0, status_1;
		uint16 agc_state, gain_idx;
		uint8 core;

		/* copy of the M_CURCHANNEL, just channel number plus 2G/5G flag */
		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
		channel = jssi_aux & D11_CURCHANNEL_MAX;

		ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) < PHY_CORE_MAX);
		bzero((uint8 *)cmplx_pwr, sizeof(cmplx_pwr));
		bzero((uint8 *)cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));

		/* read SHM, reuse old corerev PWRIND since we are tight on SHM pool */
		FOREACH_CORE(pi, core) {
			lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(2*core));
			hi = wlapi_bmac_read_shm(pi->sh->physhim, M_PWRIND_MAP(2*core+1));
			cmplx_pwr[core] = (hi << 16) + lo;
		}

		cmplx_pwr_tot = (cmplx_pwr[0] + cmplx_pwr[1]) >> 6;

		status_0 = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_0);
		if (LPREV_GE(pi->pubpi.phy_rev, 2)) {
			status_0 = ((status_0 & 0xc000) | ((status_0 & 0x3fff)>>1));
		}
		status_1 = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_1);
		BCM_REFERENCE(status_1);

		agc_state = (status_0 >> 8) & 0xf;
		gain_idx  = (status_0 & 0xff);

		if ((cmplx_pwr_tot > 0) && ((status_0 & 0xc000) == 0x4000) &&
		    /* Filter out weird statuses -- probably hw bug in status reporting */
		    ((agc_state != 1) || (gain_idx >=  20)))
		    {
			/* Measurement finished o.k */
			wlc_phy_compute_dB(cmplx_pwr, cmplx_pwr_dbm,
				PHYCORENUM(pi->pubpi.phy_corenum));

			pwr_offset_dB = (phy_reg_read(pi, LPPHY_InputPowerDB) & 0xFF);

			if (pwr_offset_dB > 127)
				pwr_offset_dB -= 256;

			/* 20*log10(1)+30-20*log10(512/0.5) ~= -30 */
			noise_dbm += (int8)(pwr_offset_dB - 30);

			if (LPREV_GE(pi->pubpi.phy_rev, 2)) {
				if ((status_0 & 0x0f00) == 0x0100) {
					gain_dB = (phy_reg_read(pi, LPPHY_HiGainDB) & 0xFF);
					noise_dbm -= (int8)(gain_dB);
				} else {
					/* There's a bug in 4325 where the gainIdx is not
					 * output to debug gpio's so unless the AGC is in
					 * HIGH_GAIN_STATE the actual gain can't be
					 * derived from the debug gpio.
					 */
					noise_dbm = -60;
				}
			} else {
				gain_dB = (gain_idx *3) - 6;
				noise_dbm -= (int8)(gain_dB);
			}

			PHY_INFORM(("lpphy noise is %d dBm ch %d(DBG %04x %04x)\n",
				noise_dbm, channel, status_0, status_1));
		} else {
			/* Measurement finished abnormally */
			PHY_INFORM(("lpphy noise measurement error: %04x %04x ch %d\n",
				status_0, status_1, channel));

			noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;
		}
	} else if (ISSSLPNPHY(pi)) {
		noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;

	} else if (ISLCN40PHY(pi)) {
	  wlc_lcn40phy_noise_measure(pi);
	} else if (ISLCNPHY(pi)) {
	  wlc_lcnphy_noise_measure(pi);
	} else if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		/* copy of the M_CURCHANNEL, just channel number plus 2G/5G flag */
		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
		channel = jssi_aux & D11_CURCHANNEL_MAX;
		noise_dbm = wlc_phy_noise_read_shmem(pi);
	} else if (ISABGPHY(pi)) {

		jssi_pair = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_0);
		jssi[0] = (int)(jssi_pair & 0xff);
		jssi[1] = (int)((jssi_pair >> 8) & 0xff);
		if (ISGPHY(pi)) {
			/* ucode grabs 4 samples for GPhy */
			jssi_pair = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_1);
			jssi[2] = (int)(jssi_pair & 0xff);
			jssi[3] = (int)((jssi_pair >> 8) & 0xff);
		}

		jssi_aux = wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
		channel = jssi_aux & D11_CURCHANNEL_MAX;

		crs_state = (jssi_aux >> 8) & 0x1f;

		if (ISAPHY(pi)) {
			/* APhy jssi value is signed */
			if (jssi[0] > 127)
				jssi[0] -= 256;

			/* check for a bad reading, ucode puts valid bit in jssi[1] */
			if (!(jssi[1] & 1)) {	/* bad sample, try again */
				PHY_NONE(("wl%d: wlc_phy_noise_int: sample invalid\n",
				          pi->sh->unit));
				/* special failure case for APHY: rerun if hasn't started */
				if (pi->phynoise_state == 0)
					wlc_phy_noise_sample_request(pih, pi->phynoise_state,
						channel);

			} else {
				/* APHY 4306C0s RSSI ADC output needs to be scaled up
				 * to match 4306B0
				 */
				if (AREV_GT(pi->pubpi.phy_rev, 2))
					jssi[0] = jssi[0] * 4;
			}
		}

		PHY_NONE(("wl%d: wlc_phy_noise_int: chan %d crs %d JSSI sample %d\n",
		         pi->sh->unit, channel, crs_state, jssi[0]));

		noise_dbm = wlc_jssi_to_rssi_dbm_abgphy(pi, crs_state, jssi, 4);
	} else {
		PHY_ERROR(("%s, unsupported phy type\n", __FUNCTION__));
		ASSERT(0);
	}

	if (!ISLCNCOMMONPHY(pi))
	  {
	    /* rssi dbm computed, invoke all callbacks */
	    wlc_phy_noise_cb(pi, channel, noise_dbm);
	  }
}

int8
wlc_phy_noise_avg(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	int tot = 0;
	int i = 0;
	int j = 0;

#ifdef BCM_OL_DEV
	if (ISACPHY(pi)) {
		PHY_TRACE(("%s: Offload collecting noise sample\n", __FUNCTION__));
		wlc_phy_noise_sample_acphy(pih);
		for (i = 0; i < MA_WINDOW_SZ; i++) {
			if (pi->sh->phy_noise_window[i] != 0) {
				tot += pi->sh->phy_noise_window[i];
				++j;
			}
		}
		if (j) {
			tot /= j;
		}
		PHY_TRACE(("%s: Offload noise value %d\n", __FUNCTION__, tot));
		return (int8)tot;
	}
#endif /* BCM_OL_DEV */

#ifdef WLOFFLD
	void *wlc = wlapi_get_wlc_info(pi->sh->physhim);
	tot =  wlc_ol_noise_avg_offload(wlc); /* Read it from shared memory */
	if (tot != 0) {
		PHY_TRACE(("%s: Got noise value (%d) form offload engine\n",
			__FUNCTION__, tot));
		return (int8)tot;
	} else {
		/*
		* May be the offload ARM engine has not started yet. Get the actual sampled
		* value and fall thro' to perform average calculation as usual.
		* previously it was returning PHY_NOISE_FIXED_VAL_NPHY
		*/
		if (ISACPHY(pi)) {
			int8 current_noise_dbm;
			PHY_TRACE(("%s: No noise value found in shared memory, collecting sample\n",
			__FUNCTION__));
			/*
			* Since there is no noise average available in offload
			* there is a possibility that noise samples are filled
			* with garbage values, so fill up the entire array NOW
			*/
			current_noise_dbm = wlc_phy_noise_sample_acphy(pih);
			for (i = 0; i < MA_WINDOW_SZ; i++) {
				pi->sh->phy_noise_window[i] = current_noise_dbm;
			}
		} /* ISACPHY */
	} /* else */
#endif /* WLOFFLD */

	if (ISSSLPNPHY(pi)) {
		tot = (int)wlc_sslpnphy_noise_avg(pi);
	} else if (ISLCN40PHY(pi)) {
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
		int8 gain_adjust = 0;
		if (!pi->sh->clk)
			return 0;
		if (pi_lcn40->noise_iqest_en) {
			uint16 lcn40phyregs_shm_addr =
				2 * wlapi_bmac_read_shm(pi->sh->physhim, M_LCN40PHYREGS_PTR);
			int16 noise_dBm_ucode, noise_dBm;
			wlc_lcn40phy_trigger_noise_iqest(pi);
			noise_dBm_ucode = (int16)wlapi_bmac_read_shm(pi->sh->physhim,
				lcn40phyregs_shm_addr + M_NOISE_IQPWR_DB);
			if (noise_dBm_ucode)
				gain_adjust = wlc_lcn40phy_get_noise_iqest_gainadjust(pi);
			noise_dBm = noise_dBm_ucode + gain_adjust;
			tot = noise_dBm;
			PHY_INFORM(("noise_dBm=%d, noise_iq=%d, noise_dBm_ucode=%d\n",
				noise_dBm, (int16)wlapi_bmac_read_shm(pi->sh->physhim,
				lcn40phyregs_shm_addr + M_NOISE_IQPWR), noise_dBm_ucode));
		}
	} else {
		for (i = 0; i < MA_WINDOW_SZ; i++) {
			if (pi->sh->phy_noise_window[i] != 0) {
				tot += pi->sh->phy_noise_window[i];
				++j;
			}
		}
		if (j) {
			tot /= j;
		} else {
			tot = ACPHY_NOISE_FLOOR_20M; /* buffer empty */
		}
	}
	return (int8)tot;
}

int8
wlc_phy_noise_avg_per_antenna(wlc_phy_t *pih, int coreidx)
{
	phy_info_t *pi = (phy_info_t *)pih;
	uint8 i, idx;
	int32 tot = 0;
	int8 result = 0;

	if (!pi->sh->up)
		return 0;

	/* checking coreidx to prevent overrunning
	 * phy_noise_win array
	 */
	if (((uint)coreidx) >= PHY_CORE_MAX)
		return 0;

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, coreidx) {
		tot = 0;
		idx = pi->phy_noise_index;
		for (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {
			tot += pi->phy_noise_win[coreidx][idx];
			idx = MODINC_POW2(idx, PHY_NOISE_WINDOW_SZ);
		}

		result = (int8)(tot/PHY_NOISE_WINDOW_SZ);
	}

	return result;
}

int8
wlc_phy_noise_lte_avg(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	int tot = 0;

	if (ISLCN40PHY(pi)) {
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
		int8 gain_adjust = 0;
		if (!pi->sh->clk)
			return 0;
		if (pi_lcn40->noise_iqest_en) {
			uint16 lcn40phyregs_shm_addr =
				2 * wlapi_bmac_read_shm(pi->sh->physhim, M_LCN40PHYREGS_PTR);
			int16 noise_dBm_ucode, noise_dBm;
			wlc_lcn40phy_trigger_noise_iqest(pi);
			noise_dBm_ucode = (int16)wlapi_bmac_read_shm(pi->sh->physhim,
				lcn40phyregs_shm_addr + M_NOISE_LTE_IQPWR_DB);
			if (noise_dBm_ucode)
				gain_adjust = wlc_lcn40phy_get_noise_iqest_gainadjust(pi);
			noise_dBm = noise_dBm_ucode + gain_adjust;
			tot = noise_dBm;
			PHY_INFORM(("noise_dBm=%d, noise_iq=%d, noise_dBm_ucode=%d\n",
				noise_dBm, (int16)wlapi_bmac_read_shm(pi->sh->physhim,
				lcn40phyregs_shm_addr + M_NOISE_IQPWR), noise_dBm_ucode));
		}
	}
	return (int8)tot;
}

static uint8 nrssi_tbl_phy[PHY_RSSI_TABLE_SIZE] = {
	00,  1,  2,  3,  4,  5,  6,  7,
	8,  9, 10, 11, 12, 13, 14, 15,
	16, 17, 18, 19, 20, 21, 22, 23,
	24, 25, 26, 27, 28, 29, 30, 31,
	32, 33, 34, 35, 36, 37, 38, 39,
	40, 41, 42, 43, 44, 45, 46, 47,
	48, 49, 50, 51, 52, 53, 54, 55,
	56, 57, 58, 59, 60, 61, 62, 63
};

int8 lcnphy_gain_index_offset_for_pkt_rssi[] = {
	8,	/* 0 */
	8,	/* 1 */
	8,	/* 2 */
	8,	/* 3 */
	8,	/* 4 */
	8,	/* 5 */
	8,	/* 6 */
	9,	/* 7 */
	10,	/* 8 */
	8,	/* 9 */
	8,	/* 10 */
	7,	/* 11 */
	7,	/* 12 */
	1,	/* 13 */
	2,	/* 14 */
	2,	/* 15 */
	2,	/* 16 */
	2,	/* 17 */
	2,	/* 18 */
	2,	/* 19 */
	2,	/* 20 */
	2,	/* 21 */
	2,	/* 22 */
	2,	/* 23 */
	2,	/* 24 */
	2,	/* 25 */
	2,	/* 26 */
	2,	/* 27 */
	2,	/* 28 */
	2,	/* 29 */
	2,	/* 30 */
	2,	/* 31 */
	1,	/* 32 */
	1,	/* 33 */
	0,	/* 34 */
	0,	/* 35 */
	0,	/* 36 */
	0	/* 37 */
};

int8 lcn40phy_gain_index_offset_for_pkt_rssi_2g[] = {
	0,	/* 0 */
	0,	/* 1 */
	0,	/* 2 */
	0,	/* 3 */
	0,	/* 4 */
	0,	/* 5 */
	0,	/* 6 */
	0,	/* 7 */
	0,	/* 8 */
	0,	/* 9 */
	0,	/* 10 */
	0,	/* 11 */
	0,	/* 12 */
	0,	/* 13 */
	0,	/* 14 */
	0,	/* 15 */
	0,	/* 16 */
	0,	/* 17 */
	0,	/* 18 */
	0,	/* 19 */
	0,	/* 20 */
	0,	/* 21 */
	0,	/* 22 */
	0,	/* 23 */
	0,	/* 24 */
	1,	/* 25 */
	0,	/* 26 */
	1,	/* 27 */
	2,	/* 28 */
	2,	/* 29 */
	0,	/* 30 */
	0,	/* 31 */
	0,	/* 32 */
	0,	/* 33 */
	0,	/* 34 */
	0,	/* 35 */
	0,	/* 36 */
	0,	/* 37 */
};
#ifdef BAND5G
int8 lcn40phy_gain_index_offset_for_pkt_rssi_5g[] = {
	0,	/* 0 */
	0,	/* 1 */
	0,	/* 2 */
	0,	/* 3 */
	0,	/* 4 */
	0,	/* 5 */
	0,	/* 6 */
	0,	/* 7 */
	0,	/* 8 */
	0,	/* 9 */
	0,	/* 10 */
	0,	/* 11 */
	0,	/* 12 */
	0,	/* 13 */
	0,	/* 14 */
	0,	/* 15 */
	0,	/* 16 */
	0,	/* 17 */
	0,	/* 18 */
	0,	/* 19 */
	0,	/* 20 */
	0,	/* 21 */
	0,	/* 22 */
	0,	/* 23 */
	0,	/* 24 */
	0,	/* 25 */
	2,	/* 26 */
	2,	/* 27 */
	2,	/* 28 */
	2,	/* 29 */
	0,	/* 30 */
	0,	/* 31 */
	0,	/* 32 */
	0,	/* 33 */
	0,	/* 34 */
	0,	/* 35 */
	0,	/* 36 */
	0	/* 37 */
};
#endif /* BAND5G */

void
wlc_phy_compute_dB(uint32 *cmplx_pwr, int8 *p_cmplx_pwr_dB, uint8 core)
{
	uint8 shift_ct, lsb, msb, secondmsb, i;
	uint32 tmp;

	ASSERT(core <= PHY_CORE_MAX);

	PHY_INFORM(("wlc_phy_compute_dB: compute_dB for %d cores\n", core));
	for (i = 0; i < core; i++) {
		tmp = cmplx_pwr[i];
		shift_ct = msb = secondmsb = 0;
		while (tmp != 0) {
			tmp = tmp >> 1;
			shift_ct++;
			lsb = (uint8)(tmp & 1);
			if (lsb == 1)
				msb = shift_ct;
		}

		if (msb != 0)
		secondmsb = (uint8)((cmplx_pwr[i] >> (msb - 1)) & 1);

		p_cmplx_pwr_dB[i] = (int8)(3*msb + 2*secondmsb);
		PHY_INFORM(("wlc_phy_compute_dB: p_cmplx_pwr_dB[%d] %d\n", i, p_cmplx_pwr_dB[i]));
	}
}
#define LCN40_RXSTAT0_BRD_ATTN	12
#define LCN40_RXSTAT0_ACITBL_IDX_MSB	11
#define LCN40_RX_GAIN_INDEX_MASK	0x7F00
#define LCN40_RX_GAIN_INDEX_SHIFT	8
#define LCN40_QDB_MASK	0x3
#define LCN40_QDB_SHIFT	2
#define LCN40_BIT1_QDB_POS	10
#define LCN40_BIT0_QDB_POS	13

void BCMFASTPATH
wlc_phy_rssi_compute(wlc_phy_t *pih, void *ctx)
{
	wlc_d11rxhdr_t *wlc_rxhdr = (wlc_d11rxhdr_t *)ctx;
	d11rxhdr_t *rxh = &wlc_rxhdr->rxhdr;
	int rssi = ltoh16(rxh->PhyRxStatus_1) & PRXS1_JSSI_MASK;
	phy_info_t *pi = (phy_info_t *)pih;
	int8 rssi_qdb = 0;
	uint16 board_atten = (ltoh16(rxh->PhyRxStatus_0) >> 11) & 0x1;
	bool jssi_based_rssi = FALSE;

	if (ISSIM_ENAB(pi->sh->sih)) {
		rssi = WLC_RSSI_INVALID;
		rssi_qdb = 0;
		wlc_rxhdr->do_rssi_ma = 1;      /* skip calc rssi MA */
		goto end;
	}
	/* intermediate mpdus in a AMPDU do not have a valid phy status */
	if ((pi->sh->corerev >= 11) && !(ltoh16(rxh->RxStatus2) & RXS_PHYRXST_VALID)) {
		rssi = WLC_RSSI_INVALID;
		rssi_qdb = 0;
		wlc_rxhdr->do_rssi_ma = 1;		/* skip calc rssi MA */
		goto end;
	}

	/* For bcm4334 do not use packets that were received when prisel_clr flag is set */
	if ((pi->sh->corerev == 35) && (ltoh16(rxh->RxStatus2) & RXS_PHYRXST_PRISEL_CLR)) {
			if (ISLCN40PHY(pi)) {
				/* RXS_PHYRXST_PRISEL_CLR set, rssi_qdB = 0x0 => Use JSSI */
				/* RXS_PHYRXST_PRISEL_CLR set, rssi_qdB = 0x3 => WLC_RSSI_INVALID */
				phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
				if (pi_lcn40->rssi_iqest_en && pi_lcn40->rssi_iqest_jssi_en) {
					rssi_qdb = (ltoh16(rxh->PhyRxStatus_0)
						>> LCN40_BIT0_QDB_POS) & 0x1;
					rssi_qdb |= ((ltoh16(rxh->PhyRxStatus_0)
						& (1 << LCN40_BIT1_QDB_POS))
						>> (LCN40_BIT1_QDB_POS - 1));
					if (!rssi_qdb) {
						jssi_based_rssi = TRUE;
					}
				}
				else {
					rssi = WLC_RSSI_INVALID;
					wlc_rxhdr->do_rssi_ma = 1; /* skip calc rssi MA */
					goto end;
				}
			}
		else {
			rssi = WLC_RSSI_INVALID;
			wlc_rxhdr->do_rssi_ma = 1; /* skip calc rssi MA */
			goto end;
		}
	}

	if (ISSSLPNPHY(pi)) {
		rssi = wlc_sslpnphy_rssi_compute(pi, rssi, rxh);
	}

	if (ISLCNCOMMONPHY(pi)) {
		uint8 gidx = 0;
		int rssi_slope;
		gidx = (ltoh16(rxh->PhyRxStatus_2) & 0xFC00) >> 10;

		rssi_slope = wlc_phy_getlcnphy_common(pi)->lcnphy_pkteng_rssi_slope;
		if (rssi > 127)
			rssi -= 256;

		if (ISLCNPHY(pi)) {
			/* RSSI adjustment */
			rssi = rssi + lcnphy_gain_index_offset_for_pkt_rssi[gidx];
			if (board_atten)
				rssi = rssi + pi->rssi_corr_boardatten;
			else
				rssi = rssi + pi->rssi_corr_normal;

			rssi_qdb = 0;
		} else {
			int8 *corr2g;
#ifdef BAND5G
			int8 *corr5g;
#endif /* BAND5G */
			int8 *corrperrg;
			int8 po_reg;
			int16 po_nom;
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			int16 rxpath_gain;
			uint8 aci_tbl = 0;
			uint8 tr_iso = 0;

			board_atten = (ltoh16(rxh->PhyRxStatus_0) >> LCN40_RXSTAT0_BRD_ATTN) & 0x1;
			aci_tbl = (ltoh16(rxh->PhyRxStatus_0)
				>> LCN40_RXSTAT0_ACITBL_IDX_MSB) & 0x1;
			if (aci_tbl)
				gidx = gidx + (1 << 6);

			if (pi_lcn40->rssi_iqest_en) {
				if (CHSPEC_IS2G(pi->radio_chanspec))
					tr_iso = pi_lcn->lcnphy_tr_isolation_mid;
#ifdef BAND5G
				else
					tr_iso = pi_lcn->triso5g[0];
#endif // endif
				if (board_atten) {
					gidx = gidx + tr_iso;
				}
			}

			if (pi_lcn40->rssi_iqest_en && (!jssi_based_rssi)) {
				int rssi_in_qdb;
				rxpath_gain =
					wlc_lcn40phy_get_rxpath_gain_by_index(pi,
					gidx, board_atten);

				rssi_qdb = (ltoh16(rxh->PhyRxStatus_0) >> LCN40_BIT0_QDB_POS) & 0x1;
				rssi_qdb |= ((ltoh16(rxh->PhyRxStatus_0)
					& (1 << LCN40_BIT1_QDB_POS))
					>> (LCN40_BIT1_QDB_POS - 1));
				rssi_in_qdb = (rssi << LCN40_QDB_SHIFT)
					+ rssi_qdb - rxpath_gain
					+ (pi_lcn40->rssi_iqest_gain_adj << LCN40_QDB_SHIFT);
				rssi = (rssi_in_qdb >> LCN40_QDB_SHIFT);
				rssi_qdb = rssi_in_qdb & LCN40_QDB_MASK;
				PHY_INFORM(("rssidB= %d, rssi_qdB= %d, rssi_in_qdB= %d"
						"boardattn= %d, rxpath_gain= %d, "
						"gidx = %d, gain_adj = %d\n",
						rssi, rssi_qdb, rssi_in_qdb, board_atten,
						rxpath_gain, gidx,
						pi_lcn40->rssi_iqest_gain_adj));
			}

			if ((!pi_lcn40->rssi_iqest_en) || jssi_based_rssi) {
				/* JSSI adjustment wrt power offset */
				if (CHSPEC_IS20(pi->radio_chanspec))
					po_reg = PHY_REG_READ(pi, LCN40PHY,
					SignalBlockConfigTable6_new,
					crssignalblk_input_pwr_offset_db);
				else
					po_reg = PHY_REG_READ(pi, LCN40PHY,
					SignalBlockConfigTable5_new,
					crssignalblk_input_pwr_offset_db_40mhz);

				switch (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)) {
				case WL_CHAN_FREQ_RANGE_2G:
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_2g;
					else
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_40_2g;
					break;
			#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5GL:
					/* 5 GHz low */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[0];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[0];
					break;
				case WL_CHAN_FREQ_RANGE_5GM:
					/* 5 GHz middle */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[1];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[1];
					break;
				case WL_CHAN_FREQ_RANGE_5GH:
					/* 5 GHz high */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[2];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[2];
					break;
			#endif /* BAND5G */
				default:
					po_nom = po_reg;
					break;
				}

				rssi += (po_nom - po_reg);

				/* RSSI adjustment and Adding the JSSI range specific corrections */
#ifdef BAND5G
				if (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec) !=
					WL_CHAN_FREQ_RANGE_2G) {
					if ((rssi < -60) && ((gidx > 0) && (gidx <= 37)))
						rssi = rssi +
						lcn40phy_gain_index_offset_for_pkt_rssi_5g[gidx];
					corrperrg = pi->rssi_corr_perrg_5g;
				} else
#endif /* BAND5G */
				{
					if ((rssi < -60) && ((gidx > 0) && (gidx <= 37)))
						rssi = rssi +
						lcn40phy_gain_index_offset_for_pkt_rssi_2g[gidx];
					corrperrg = pi->rssi_corr_perrg_2g;
				}

				if (rssi <= corrperrg[0])
					rssi += corrperrg[2];
				else if (rssi <= corrperrg[1])
					rssi += corrperrg[3];
				else
					rssi += corrperrg[4];

				corr2g = &(pi->rssi_corr_normal);
#ifdef BAND5G
				corr5g = &(pi->rssi_corr_normal_5g[0]);
#endif /* BAND5G */

				switch (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)) {
					case WL_CHAN_FREQ_RANGE_2G:
						rssi += *corr2g;
						break;
				#ifdef BAND5G
					case WL_CHAN_FREQ_RANGE_5GL:
						/* 5 GHz low */
						rssi += corr5g[0];
						break;

					case WL_CHAN_FREQ_RANGE_5GM:
						/* 5 GHz middle */
						rssi += corr5g[1];
						break;

					case WL_CHAN_FREQ_RANGE_5GH:
						/* 5 GHz high */
						rssi += corr5g[2];
						break;
				#endif /* BAND5G */
					default:
						rssi += 0;
						break;
				}
			}

			/* Temp sense based correction */
			rssi = (rssi << LCN40_QDB_SHIFT) + rssi_qdb;
			rssi += wlc_lcn40phy_rssi_tempcorr(pi, 0);
			if (pi_lcn40->rssi_iqest_en && !jssi_based_rssi)
				rssi += wlc_lcn40phy_iqest_rssi_tempcorr(pi, 0, board_atten);

			rssi_qdb = rssi & LCN40_QDB_MASK;
			rssi = (rssi >> LCN40_QDB_SHIFT);
		}

		/* temperature compensation */
		rssi = rssi + rssi_slope;
	}

	if (RADIOID(pih->radioid) == BCM2050_ID) {
		if ((ltoh16(rxh->PhyRxStatus_0) & PRXS0_OFDM) == 0) {

			if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_ADCDIV) {
				/* Correct for the nrssi slope */
				if (rssi >= PHY_RSSI_TABLE_SIZE)
					rssi = PHY_RSSI_TABLE_SIZE - 1;

				rssi = nrssi_tbl_phy[rssi];
				rssi = (-131 * (31 - rssi) >> 7) - 67;
			} else {
				rssi = (-149 * (31 - rssi) >> 7) - 68;
			}

			if (ISGPHY(pi)) {
				uint16 val;
				/* Only 4306/B0 boards have T/R bit overloaded to also
				 * represent LNA for CCK
				 */
				if (ltoh16(rxh->PhyRxStatus_3) & PRXS3_TRSTATE) {
					rssi += 20;
				}
				val = (ltoh16(rxh->PhyRxStatus_2) & PRXS2_LNAGN_MASK) >>
				        PRXS2_LNAGN_SHIFT;
				switch (val) {
					case 0:	rssi -= -2;	break;
					case 1:	rssi -= 19;	break;
					case 2:	rssi -= 13;	break;
					case 3:	rssi -= 25;	break;
				}
				rssi += 25;
			}
		} else {
			/* Sign extend */
			if (rssi > 127)
				rssi -= 256;
			/* Check T-R/LNA bit */
			/* Adjust the calculated RSSI to match measured RX power
			 * as reported by DVT, to keep reported RSSI within +/-3dB of
			 * measured Rx power. This is needed for 2050 Radio only.
			 */
			if (ltoh16(rxh->PhyRxStatus_3) & PRXS3_TRSTATE)
				rssi += 17;
			else
				rssi -= 4;
		}
	} else if (RADIOID(pih->radioid) == BCM2060_ID) {
		/* Sign extend */
		if (rssi > 127)
			rssi -= 256;
	} else if (ISLPPHY(pi)) {
		/* Sign extend */
		if (rssi > 127)
			rssi -= 256;
	} else if (ISSSLPNPHY(pi)) {
		/* do nothing */
	} else if (ISLCNCOMMONPHY(pi)) {
		/* Sign extend */
		if (rssi > 127)
			rssi -= 256;
		wlc_rxhdr->rxpwr[0] = (int8)rssi;
		wlc_rxhdr->do_rssi_ma = 0;
	} else if (ISNPHY(pi) &&
	           (RADIOID(pih->radioid) == BCM2055_ID ||
	            RADIOID(pih->radioid) == BCM2056_ID ||
	            RADIOID(pih->radioid) == BCM2057_ID ||
	            RADIOID(pih->radioid) == BCM20671_ID)) {
		ASSERT(ISNPHY(pi));
		rssi = wlc_phy_rssi_compute_nphy(pi, wlc_rxhdr);
	} else if (ISHTPHY(pi)) {
		ASSERT(RADIOID(pih->radioid) == BCM2059_ID);
		rssi = wlc_phy_rssi_compute_htphy(pi, wlc_rxhdr);
	} else if (ISACPHY(pi)) {
		ASSERT(RADIOID(pih->radioid) == BCM2069_ID || RADIOID(pih->radioid) == BCM20691_ID);
		rssi = wlc_phy_rssi_compute_acphy(pi, wlc_rxhdr);
		pi->u.pi_acphy->last_rssi = rssi;
	} else {
		ASSERT((const char *)"Unknown radio" == NULL);
	}
#if defined(WLNOKIA_NVMEM)
	rssi = wlc_phy_upd_rssi_offset(pi, (int8)rssi, rxh->RxChan);
#endif // endif

	if (ISLCN40PHY(pi)) {
		if (rssi > MAX_VALID_RSSI)
			rssi = MAX_VALID_RSSI;
	}

end:
	wlc_rxhdr->rssi = (int8)rssi;
	wlc_rxhdr->rssi_qdb = (int8)rssi_qdb;

	if (ISLCNPHY(pi)) {
		wlc_phy_lcn_updatemac_rssi(pi, (int8)rssi,
			(int8)((ltoh16(rxh->PhyRxStatus_0) >> 14) & 0x1));
	}

	if (ISNPHY(pi) || ISHTPHY(pi)) {
		int16 rssi0_avg = 0, rssi1_avg = 0;
		int8  ctr;
		int8  rssi0, rssi1;

		/* Compute RSSI for 16 samples per core */
		/* getting moving average of rssi values */
		rssi0 = wlc_rxhdr->rxpwr[0];
		rssi1 = wlc_rxhdr->rxpwr[1];

		pi->rssi0_buffer[pi->rssi0_index] = (int8) rssi0;
		pi->rssi1_buffer[pi->rssi1_index] = (int8) rssi1;
		pi->rssi0_index++;
		pi->rssi1_index++;
		/* average over 16 values/packets */
		pi->rssi1_index %= 16;
		pi->rssi0_index %= 16;
		rssi0_avg = 0;
		rssi1_avg = 0;
		for (ctr = 0; ctr < 16; ctr++) {
			rssi0_avg += pi->rssi0_buffer[ctr];
			rssi1_avg += pi->rssi1_buffer[ctr];
		}
		rssi0_avg /= 16;
		rssi1_avg /= 16;
		pi->rssi0_avg = (int8) rssi0_avg;
		pi->rssi1_avg = (int8) rssi1_avg;
	}
}

/* %%%%%% radar */

void
wlc_phy_radar_detect_enable(wlc_phy_t *pih, bool on)
{
#if defined(AP) && defined(RADAR)
	phy_info_t *pi = (phy_info_t *)pih;

	pi->sh->radar = on;

	if (!pi->sh->up)
		return;

	/* apply radar inits to hardware if we are on the A/LP/N/HTPHY */
	if (ISAPHY(pi) || ISLPPHY(pi) || ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))
		wlc_phy_radar_detect_init(pi, on);

	return;
#endif /* defined(AP) && defined(RADAR) */
}

int
wlc_phy_radar_detect_run(wlc_phy_t *pih)
{
#if defined(AP) && defined(RADAR)
	phy_info_t *pi = (phy_info_t *)pih;

	if (ISAPHY(pi))
		return wlc_phy_radar_detect_run_aphy(pi);
	else if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))
		return wlc_phy_radar_detect_run_nphy(pi);

	ASSERT(0);
#endif /* defined(AP) && defined(RADAR) */
	return (RADAR_TYPE_NONE);
}

int
wlc_phy_radar_status(wlc_phy_t *pih)
{
#if defined(AP) && defined(RADAR)
	phy_info_t *pi = (phy_info_t *)pih;

	if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		pi->ri->radar_status.detected = TRUE;
		pi->ri->radar_status.pretended = TRUE;
		pi->ri->radar_status.ch = pi->radio_chanspec;
	}
#endif /* defined(AP) && defined(RADAR) */
	return (RADAR_TYPE_NONE);
}

void
wlc_phy_radar_detect_mode_set(wlc_phy_t *pih, phy_radar_detect_mode_t mode)
{
#if defined(AP) && defined(RADAR)
	phy_info_t *pi = (phy_info_t *)pih;

	PHY_TRACE(("wl%d: %s, Radar detect mode set done\n", pi->sh->unit, __FUNCTION__));

	if (pi->ri->rdm == mode)
		return;
	else if ((mode != RADAR_DETECT_MODE_FCC) && (mode != RADAR_DETECT_MODE_EU)) {
		PHY_TRACE(("wl%d: bogus radar detect mode: %d\n", pi->sh->unit, mode));
		return;
	} else
		pi->ri->rdm = mode;

	/* Change radar params based on radar detect mode for
	 * both 20Mhz (index 0) and 40Mhz (index 1) aptly
	 * feature_mask bit-11 is FCC-enable
	 * feature_mask bit-12 is EU-enable
	 */
	if (pi->ri->rdm == RADAR_DETECT_MODE_FCC) {
		pi->ri->rparams.radar_args.feature_mask =
			(pi->ri->rparams.radar_args.feature_mask & 0xefff) | 0x800;
		if (!ISACPHY(pi)) {
		  if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) || ISHTPHY(pi)) {
		    pi->ri->rparams.radar_args.st_level_time = 0x1591;
		  } else {
		    pi->ri->rparams.radar_args.st_level_time = 0x1901;
		  }
		}

	} else if (pi->ri->rdm == RADAR_DETECT_MODE_EU) {
		pi->ri->rparams.radar_args.feature_mask =
			(pi->ri->rparams.radar_args.feature_mask & 0xf7ff) | 0x1000;
		if (!ISACPHY(pi)) {
		  if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) || ISHTPHY(pi)) {
		    pi->ri->rparams.radar_args.st_level_time = 0x1591;
		  } else {
		    pi->ri->rparams.radar_args.st_level_time = 0x1901;
		  }
		}
	}
#endif /* defined(AP) && defined(RADAR) */
}
#if defined(AP) && defined(RADAR)
/* Sort vector (of length len) into ascending order */
static void
wlc_shell_sort(int len, int *vector)
{
	int i, j, incr;
	int v;

	incr = 4;

	while (incr < len) {
		incr *= 3;
		incr++;
	}

	while (incr > 1) {
		incr /= 3;
		for (i = incr; i < len; i++) {
			v = vector[i];
			j = i;
			while (vector[j-incr] > v) {
				vector[j] = vector[j-incr];
				j -= incr;
				if (j < incr)
					break;
			}
			vector[j] = v;
		}
	}
}

void
wlc_phy_radar_detect_init(phy_info_t *pi, bool on)
{
	PHY_TRACE(("wl%d: %s, RSSI LUT done\n", pi->sh->unit, __FUNCTION__));

	/* DFS_SW_VERSION, ... are defined in file wlc_phy_int.h */
	PHY_RADAR(("DFS_SW_VERSION=%03d.%03d. DDMMYYYY=%04d%04d\n",
		DFS_SW_VERSION, DFS_SW_SUB_VERSION, DFS_SW_DATE_MONTH, DFS_SW_YEAR));

	if (ISAPHY(pi)) {
		wlc_phy_radar_detect_init_aphy(pi, on);
		return;
	} else if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
#ifdef BAND5G
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (ISHTPHY(pi)) {
				wlc_phy_radar_detect_init_htphy(pi, on);
				wlc_phy_update_radar_detect_param_htphy(pi);
			} else if (ISACPHY(pi)) {
				wlc_phy_radar_detect_init_acphy(pi, on);
			} else if (ISNPHY(pi)) {
				wlc_phy_radar_detect_init_nphy(pi, on);
				wlc_phy_update_radar_detect_param_nphy(pi);
			}
		}
#endif /* BAND5G */
		return;
	}
	ASSERT(0);
}

/* read_radar_table */
static void
wlc_phy_radar_read_table_aphy(phy_info_t *pi, radar_work_t *rt, int min_pulses)
{
	uint16 i;
	uint16 w0, w1, w2;

	/* True? Maximum table size is 42 entries */
	bzero(rt->tstart_list, sizeof(rt->tstart_list));
	bzero(rt->width_list, sizeof(rt->width_list));

	rt->length = phy_reg_read(pi, APHY_RADAR_FIFO_CTL) & 0xff;
	if (rt->length < min_pulses)
		return;

	rt->length /= 3;	/* 3 words per pulse */

	for (i = 0; i < rt->length; i++) {	/* Read out the FIFO */
		w0 = phy_reg_read(pi, APHY_RADAR_FIFO);
		w1 = phy_reg_read(pi, APHY_RADAR_FIFO);
		w2 = phy_reg_read(pi, APHY_RADAR_FIFO);
		rt->tstart_list[i] = ((w0 << 8) + (w1 & 0xff)) << 4;
		rt->width_list[i] = w2 & 0xff;
	}
}

/* generate an n-th tier list (difference between nth pulses) */
static void
wlc_phy_radar_generate_tlist(uint32 *inlist, int *outlist, int length, int n)
{
	int i;

	for (i = 0; i < (length - n); i++) {
		outlist[i] = ABS((int32)(inlist[i + n] - inlist[i]));
	}
}

/* generate an n-th tier pw list */
static void
wlc_phy_radar_generate_tpw(uint16 *inlist, uint16 *outlist, int length, int n)
{
	int i;

	for (i = 0; i < (length - n); i++) {
		outlist[i] = inlist[i + n - 1];
	}
}

static void
wlc_phy_radar_generate_tfm(int16 *inlist, int16 *outlist, int length, int n)
{
	int i;

	for (i = 0; i < (length - n); i++) {
		outlist[i] = inlist[i + n - 1];
	}
}

/* remove outliers from a list */
static void
wlc_phy_radar_filter_list(int *inlist, int *length, int min_val, int max_val)
{
	int i, j;
	j = 0;
	for (i = 0; i < *length; i++) {
		if ((inlist[i] >= min_val) && (inlist[i] <= max_val)) {
			inlist[j] = inlist[i];
			j++;
		}
	}
	*length = j;
}

/*
 * select_nfrequent - crude for now
 * inlist - input array (tier list) that has been sorted into ascending order
 * length - length of input array
 * n - position of interval value/frequency to return
 * value - interval
 * frequency - number of occurrences of interval value
 * vlist - returned interval list
 * flist - returned frequency list
 */
static int
wlc_phy_radar_select_nfrequent(int *inlist, int length, int n, int *value,
	int *position, int *frequency, int *vlist, int *flist)
{
	/*
	 * needs declarations:
		int vlist[RDR_TIER_SIZE];
		int flist[RDR_TIER_SIZE];
	 * from calling routine
	 */
	int i, j, pointer, counter, newvalue, nlength;
	int plist[RDR_NTIER_SIZE];
	int f, v, p;

	vlist[0] = inlist[0];
	plist[0] = 0;
	flist[0] = 1;

	pointer = 0;
	counter = 0;

	for (i = 1; i < length; i++) {	/* find the frequencies */
		newvalue = inlist[i];
		if (newvalue != vlist[pointer]) {
			pointer++;
			vlist[pointer] = newvalue;
			plist[pointer] = i;
			flist[pointer] = 1;
			counter = 0;
		} else {
			counter++;
			flist[pointer] = counter;
		}
	}

	nlength = pointer + 1;

	for (i = 1; i < nlength; i++) {	/* insertion sort */
		f = flist[i];
		v = vlist[i];
		p = plist[i];
		j = i - 1;
		while ((j >= 0) && flist[j] > f) {
			flist[j + 1] = flist[j];
			vlist[j + 1] = vlist[j];
			plist[j + 1] = plist[j];
			j--;
		}
		flist[j + 1] = f;
		vlist[j + 1] = v;
		plist[j + 1] = p;
	}

	if (n < nlength) {
		*value = vlist[nlength - n - 1];
		*position = plist[nlength - n - 1];
		*frequency = flist[nlength - n - 1] + 1;
	} else {
		*value = 0;
		*position = 0;
		*frequency = 0;
	}
	return nlength;
}

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_acphy_2cores) = {
	WL_RADAR_THR_VERSION,
	0x6b8, 0x30, 0x6b8, 0x30, 0x6b8, 0x30, 0x6b0, 0x30, 0x6b0, 0x30, 0x6b0, 0x30
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_acphy_1core) = {
	WL_RADAR_THR_VERSION,
	0x6b8, 0x30, 0x6b8, 0x30, 0x6b8, 0x30, 0x6ac, 0x30, 0x6ac, 0x30, 0x6b0, 0x30
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_acphy_1core_4350) = {
	WL_RADAR_THR_VERSION,
	0x6a8, 0x30, 0x6a4, 0x30, 0x6a0, 0x30, 0x6ac, 0x30, 0x6a8, 0x30, 0x6a8, 0x30
	/* Assume 3dB antenna gain, targeting -64dBm at input of antenna port */
};

/* http://confluence.broadcom.com/x/B5gGEw */
static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_acphy_435x_43602) = {
	WL_RADAR_THR_VERSION,
	0x688, 0x18, 0x688, 0x18, 0x688, 0x18, 0x688, 0x18, 0x688, 0x18, 0x688, 0x18
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_acphy_43602) = {
	WL_RADAR_THR_VERSION,
	0x690, 0x18, 0x690, 0x18, 0x690, 0x18, 0x690, 0x18, 0x690, 0x18, 0x690, 0x18
	/* Assume 4dB antenna gain, targeting -64dBm at input of antenna port */
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_htphy) = {
	WL_RADAR_THR_VERSION,
	0x6b8, 0x30, 0x6b8, 0x30, 0, 0, 0x6b8, 0x30, 0x6b8, 0x30, 0, 0
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_nphy_ge7) = {
	WL_RADAR_THR_VERSION,
	0x64a, 0x30, 0x64a, 0x30, 0, 0, 0x64a, 0x30, 0x64a, 0x30, 0, 0
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_nphy_ge19) = {
	WL_RADAR_THR_VERSION,
	0x6aa, 0x28, 0x6aa, 0x28, 0, 0, 0x6aa, 0x28, 0x6aa, 0x28, 0, 0
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_nphy_ge3) = {
	WL_RADAR_THR_VERSION,
	0x6c0, 0x6f0, 0x6c0, 0x6f0, 0, 0, 0x6c0, 0x6f0, 0x6c0, 0x6f0, 0, 0
};

static const wl_radar_thr_t BCMATTACHDATA(wlc_phy_radar_thresh_nphy_lt3) = {
	WL_RADAR_THR_VERSION,
	0x6a8, 0x6d0, 0x6b8, 0x6e0, 0, 0, 0x69c, 0x6c6, 0x6b8, 0x6e0, 0, 0
};

/* radar detection */
static void
BCMATTACHFN(wlc_phy_radar_params_attach)(phy_info_t *pi)
{
	if (ISAPHY(pi)) {
		wlc_phy_radar_params_attach_aphy(pi);
		return;
	}

	/* 20Mhz channel radar thresholds */
	if (ISACPHY(pi)) {
		pi->ri->rparams.radar_thrs = (GET_RDR_NANTENNAS(pi) == 1)
							? wlc_phy_radar_thresh_acphy_1core
							: wlc_phy_radar_thresh_acphy_2cores;
		if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			/* Improve radar detect sensitivity */
			pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_acphy_435x_43602;
		}
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_acphy_43602;
		}
	} else if (ISHTPHY(pi)) {
		pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_htphy;
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) {
		if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
			pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_nphy_ge19;
		} else {
			pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_nphy_ge7;
		}
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
		pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_nphy_ge3;
	} else {
		pi->ri->rparams.radar_thrs = wlc_phy_radar_thresh_nphy_lt3;
	}

	/* 20Mhz channel radar params */
	pi->ri->rparams.min_tint = 3000;	/* 0.15ms (6.67 kHz)		*/
	pi->ri->rparams.max_tint = 120000;	/* 6ms (167 Hz) - for Finland	*/
	pi->ri->rparams.min_blen = 100000;
	pi->ri->rparams.max_blen = 1500000;	/* 75 ms			*/
	pi->ri->rparams.min_deltat_lp = 19000;	/* 1e-3*20e6 - small error	*/
	pi->ri->rparams.max_deltat_lp = 130000;	/* 2*2e-3*20e6 + small error	*/
	pi->ri->rparams.max_type1_pw = 50;	/* fcc type1 1*20 + 15		*/
	pi->ri->rparams.max_jp1_2_pw = 70;	/* jp-1-2 2.5*20+20		*/
	pi->ri->rparams.jp4_intv = 6660;	/* jp4 hopping radar 333*20	*/
	pi->ri->rparams.jp1_2_intv = 76923;	/* jp-1-2 3846.15*20		*/
	pi->ri->rparams.jp2_3_intv = 80000;	/* jp-2-3 4000*20		*/
	pi->ri->rparams.jp2_1_intv = 27780;	/* jp-2-1 1389*20		*/
	pi->ri->rparams.type1_intv = 28571;	/* fcc type 1 1428.57*20	*/
	pi->ri->rparams.max_type2_pw = 150;	/* fcc type 2, 5*20 + 50	*/
	pi->ri->rparams.min_type3_pw = 70;	/* fcc type 3, 6*20 - 50	*/
	pi->ri->rparams.max_type3_pw = 250;	/* fcc type 3, 10*20 + 50	*/
	pi->ri->rparams.min_type4_pw = 160;	/* fcc type 4, 11*20 - 60	*/
	pi->ri->rparams.max_type4_pw = 460;	/* fcc type 4, 20*20 + 60	*/
	pi->ri->rparams.min_type2_intv = 3000;
	pi->ri->rparams.max_type2_intv = 4600;
	pi->ri->rparams.min_type3_4_intv = 4000;
	pi->ri->rparams.max_type3_4_intv = 10000;
	pi->ri->rparams.sdepth_extra_pulses = 2;
	pi->ri->rparams.radar_args.nskip_rst_lp = 2;
	pi->ri->rparams.radar_args.min_burst_intv_lp = 20000000;
	pi->ri->rparams.radar_args.max_burst_intv_lp = 70000000;
#ifdef BIN5_RADAR_DETECT_WAR_J28
	pi->ri->rparams.radar_args.nskip_rst_lp = 3;
#endif // endif
	pi->ri->rparams.radar_args.quant = 128;
	pi->ri->rparams.radar_args.npulses = 5;

	if (ISACPHY(pi))
		pi->ri->rparams.radar_args.ncontig = 45616; /* 37424; 37411; */
	else
		pi->ri->rparams.radar_args.ncontig = 37411;

	/* [100 011 1000 100011]=[1000 1110 0010 0011]=0x8e23 = 36387
	 * bits 15-13: JP2_1, JP4 npulses = 4
	 * bits 12-10: JP1_2_JP2_3 npulses = 3
	 * bits 9-6: EU-t4 fm tol = 8, (8/16)
	 * bit 5-0: max detection index = 35
	 * [100 100 1000 100011]=[1001 0010 0010 0011]=0x9223 = 37411
	 * bits 15-13: JP2_1, JP4 npulses = 4
	 * bits 12-10: JP1_2_JP2_3 npulses = 4
	 * bits 9-6: EU-t4 fm tol = 8, (8/16)
	 * bit 5-0: max detection index = 35
	 * [101 100 1000 110000]=[1011 0010 0011 0000]=0xb230 = 45596
	 * bits 15-13: JP2_1, JP4 npulses = 5
	 * bits 12-10: FCC_1, JP1_2_JP2_3 npulses = 4
	 * bits 9-6: EU-t4 fm tol = 8, (8/16)
	 * bit 5-0: max detection index = 48
	 */

	pi->ri->rparams.radar_args.max_pw = 690;  /* 30us + 15% */
	pi->ri->rparams.radar_args.thresh0 = pi->ri->rparams.radar_thrs.thresh0_20_lo;
	pi->ri->rparams.radar_args.thresh1 = pi->ri->rparams.radar_thrs.thresh1_20_lo;
	pi->ri->rparams.radar_args.fmdemodcfg = 0x7f09;
	pi->ri->rparams.radar_args.autocorr = 0x1e;

	if (ISACPHY(pi)) {
		/* it is used to check pw for acphy. if pw >200, then check fm */
		pi->ri->rparams.radar_args.st_level_time = 0x8190;
		pi->ri->rparams.radar_args.min_pw = 6;
		pi->ri->rparams.radar_args.max_pw_tol = 12;
		pi->ri->rparams.radar_args.npulses_lp = 11;
		pi->ri->rparams.radar_args.t2_min = 30528;	/* 0x7740 */
	} else if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) || ISHTPHY(pi)) {
		pi->ri->rparams.radar_args.st_level_time = 0x1591;
		pi->ri->rparams.radar_args.min_pw = 6;
		pi->ri->rparams.radar_args.max_pw_tol = 12;
#ifdef NPHYREV7_HTPHY_DFS_WAR
		pi->ri->rparams.radar_args.npulses_lp = 9;
#else
		pi->ri->rparams.radar_args.npulses_lp = 11;
#endif // endif
		pi->ri->rparams.radar_args.t2_min = 31552;	/* 0x7b40 */
	} else {
		pi->ri->rparams.radar_args.st_level_time = 0x1901;
		pi->ri->rparams.radar_args.min_pw = 1;
		pi->ri->rparams.radar_args.max_pw_tol = 12;
		pi->ri->rparams.radar_args.npulses_lp = 8;
		pi->ri->rparams.radar_args.t2_min = 31552;	/* 0x7b40 */
	}
#ifdef BIN5_RADAR_DETECT_WAR
	pi->ri->rparams.radar_args.min_pw = 10;
	pi->ri->rparams.radar_args.max_pw = 650;
	pi->ri->rparams.radar_args.npulses = 13;
	pi->ri->rparams.radar_args.npulses_lp = 13;
	pi->ri->rparams.radar_args.max_pw_tol = 8;
#endif // endif
#ifdef BIN5_RADAR_DETECT_WAR_J28
	pi->ri->rparams.radar_args.npulses_lp = 8;
	pi->ri->rparams.radar_args..st_level_time = 0x0190;
#endif // endif
	/* t2_min[15:12] = x; if n_non_single >= x && lp_length >
	 * npulses_lp => bin5 detected
	 * t2_min[11:10] = # times combining adjacent pulses < min_pw_lp
	 * t2_min[9] = fm_tol enable
	 * t2_min[8] = skip_type 5 enable
	 * t2_min[7:4] = y; bin5 remove pw <= 10*y
	 * t2_min[3:0] = t; non-bin5 remove pw <= 5*y
	 * st_level_time[11:0] =  pw criterion for short pluse noise filter
	 * st_level_time[15:12] =  2^x-1 as FMOFFSET
	 */
	pi->ri->rparams.radar_args.min_pw_lp = 700;
#ifdef BIN5_RADAR_DETECT_WAR
	pi->ri->rparams.radar_args.min_pw_lp = 1000;
#endif // endif
	pi->ri->rparams.radar_args.max_pw_lp = 2000;

	if (ISACPHY(pi) && TONEDETECTION)
		pi->ri->rparams.radar_args.min_fm_lp = 500 - 256;
	else
#ifdef NPHYREV7_HTPHY_DFS_WAR
		pi->ri->rparams.radar_args.min_fm_lp = 25;
#else
		pi->ri->rparams.radar_args.min_fm_lp = 45;
#endif // endif
#ifdef BIN5_RADAR_DETECT_WAR
		pi->ri->rparams.radar_args.min_fm_lp = 60;
#endif // endif
#ifdef BIN5_RADAR_DETECT_WAR_J28
	 pi->ri->rparams.radar_args.min_fm_lp  = 20;
#endif // endif
	pi->ri->rparams.radar_args.max_span_lp = 63568;  /* 0xf850; 15, 8, 80 */
	/* max_span_lp[15:12] = skip_tot max */
	/* max_span_lp[11:8] = x, x/16 = % alowed fm tollerance bin5 */
	/* max_span_lp[7:0] = alowed pw tollerance bin5 */

	pi->ri->rparams.radar_args.min_deltat = 2000;
	pi->ri->rparams.radar_args.max_deltat = 3000000;
	pi->ri->rparams.radar_args.version = WL_RADAR_ARGS_VERSION;

	if (ISACPHY(pi) && TONEDETECTION) {
		pi->ri->rparams.radar_args.fra_pulse_err = 65282; /* 0x1002 */
		/* bits 15-8: EU-t4 min_fm = 255 */
		/* bits 7-0: time from last det = 2 minute */
	} else {
		pi->ri->rparams.radar_args.fra_pulse_err = 4098; /* 0x1002 */
		/* bits 15-8: EU-t4 min_fm = 16 */
		/* bits 7-0: time from last det = 2 minute */
	}

	/* 0x8444, bits 15:14 low_intv_eu_t2 */
	/* bits 13:12 low_intv_eu_t1; npulse -- bit 11:8 for EU type 4, */
	/* bits 7:4 = 4 for EU type 2, bits 3:0= 4 for EU type 1 */
	/* 11 11 0100 0100 0100 */
	if (ISACPHY(pi))
		pi->ri->rparams.radar_args.npulses_fra = 33860;
	else
		pi->ri->rparams.radar_args.npulses_fra = 33860;

	pi->ri->rparams.radar_args.npulses_stg2 = 5;
#ifdef BIN5_RADAR_DETECT_WAR
	pi->ri->rparams.radar_args.npulses_stg2 = 8;
#endif // endif
	pi->ri->rparams.radar_args.npulses_stg3 = 5;
	pi->ri->rparams.radar_args.percal_mask = 0x31;
	pi->ri->rparams.radar_args.feature_mask = 0xa800;
#ifdef NPHYREV7_HTPHY_DFS_WAR
	if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) || ISHTPHY(pi) || ISACPHY(pi)) {
		pi->ri->rparams.radar_args.blank = 0x2c19;
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3))
#else
	if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi) || ISACPHY(pi))
#endif // endif
	{
		pi->ri->rparams.radar_args.blank = 0x6419;
	} else {
		pi->ri->rparams.radar_args.blank = 0x2c19;
	}

	/* feature mask bit definitions:
	 * bit-0  : (off) : when feature_mask bit-3 is on, 0=>bin5 data, 1=>short pulse data
	 * bit-1  : (off) : output before-fitlered pulse data
	 * bit-2  : (off) : output # pulses at each antenna (if # pulse > 5)
	 * bit-3  : (off) : output radar pulses data at various points (tstart, intv, pw, fm)
	 * bit-4  : (off) : output wlc_phy_radar_detect_uniform_pw_check(..) debug messages
	 * bit-5  : (off) : output staggered reset
	 * bit-6  : (off) : output fifo output
	 * bit-7  : (off) : output intv and pruned pw even No detection
	 * bit-8  : (on)  : output "WARNING: number of epochs=xxx > epoch size=xxx"
	 * bit-9  : (off) : output EU type debug messages
	 * bit-10 : (off) : disable/enable the new staggered 2/3 detection
	 * bit-11 : (on)  : enable fcc radar detection
	 * bit-12 : (on)  : enable etsi radar detection
	 * bit-13 : (on)  : for combining pulse use max of pw(i) & pw(i-1) inlieu of pw(i-1)+pw(i)
	 * bit-14 : (off) : output the Skipped radar if delta2 is greated than 2 mins
	 * bit-15 : (off) : use 384 of 511 FIFO data
	 */
}

static void
wlc_phy_radar_detect_init_aphy(phy_info_t *pi, bool on)
{
	ASSERT(ISAPHY(pi) && AREV_GE(pi->pubpi.phy_rev, 3));

	if (on) {
		/* skip writing the adc power up delay since we use the ucode workaround
		 * PR 16559 for now
		 *  WRITE_APHY_TABLE_ENT(pi, 0xf, 0xd, 0xff);
		 */

		/* empirically refined Radar detect thresh1 */
		phy_reg_write(pi, APHY_RADAR_THRESH1, pi->ri->rparams.radar_args.thresh1);

		/* Requested by dboldy 8/17/04 */
		phy_reg_write(pi, APHY_RADAR_THRESH0, pi->ri->rparams.radar_args.thresh0);

		wlapi_bmac_write_shm(pi->sh->physhim, M_RADAR_REG,
			pi->ri->rparams.radar_args.thresh1);
	}

	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_RADARWAR, (on ? MHF1_RADARWAR : 0),
		WLC_BAND_5G);
}

static int
wlc_phy_radar_detect_run_aphy(phy_info_t *pi)
{
	uint16 i;
	uint16 j;
	int tiern_length[RDR_NTIERS_APHY];
	int value[RDR_NTIERS_APHY], freq[RDR_NTIERS_APHY], pos[RDR_NTIERS_APHY];
	uint32 *epoch_list;
	int epoch_length = 0;
	int pulse_interval;
	bool filter_pw = TRUE;
	radar_work_t *rt = &pi->ri->radar_work;
	radar_params_t *rparams = &pi->ri->rparams;
	int val_list[RDR_TIER_SIZE];
	int freq_list[RDR_TIER_SIZE];

	if (rparams->radar_args.npulses == 0) {
		PHY_ERROR(("%s: radar params not initialized\n", __FUNCTION__));
		return (RADAR_TYPE_NONE);
	}

	pulse_interval = 0;
	wlc_phy_radar_read_table_aphy(pi, rt, rparams->radar_args.npulses);

	/*
	 * Reject if too few pulses recorded
	 */
	if (rt->length < rparams->radar_args.npulses) {
		return (RADAR_TYPE_NONE);
	}

	/*
	 * filter based on pulse width
	 */
	if (filter_pw) {
		j = 0;
		for (i = 0; i < rt->length; i++) {
			if ((rt->width_list[i] >= rparams->radar_args.min_pw) &&
				(rt->width_list[i] <= rparams->radar_args.max_pw)) {
				rt->width_list[j] = rt->width_list[i];
				rt->tstart_list[j] = rt->tstart_list[i];
				j++;
			}
		}
		rt->length = j;
	}
	ASSERT(rt->length <= RDR_NANTENNAS * RDR_LIST_SIZE);

	/*
	 * Break pulses into epochs.
	 */
	rt->nepochs = 1;
	rt->epoch_start[0] = 0;
	for (i = 1; i < rt->length; i++) {
		if ((int32)(rt->tstart_list[i] - rt->tstart_list[i-1]) > (int32)rparams->max_blen) {
			rt->epoch_finish[rt->nepochs-1] = i - 1;
			rt->epoch_start[rt->nepochs] = i;
			rt->nepochs++;
		}
	}
	rt->epoch_finish[rt->nepochs - 1] = i;

	/*
	 * Run the detector for each epoch
	 */
	for (i = 0; i < rt->nepochs && !pulse_interval; i++) {
		/*
		 * Generate 0th order tier list (time delta between received pulses)
		 * Quantize and filter delta pulse times delta pulse times are
		 * returned in sorted order from smallest to largest.
		 */

		epoch_list = rt->tstart_list + rt->epoch_start[i];
		epoch_length = rt->epoch_finish[i] - rt->epoch_start[i] + 1;
		if (epoch_length >= RDR_TIER_SIZE) {
			PHY_RADAR(("WARNINIG: EPOCH LENGTH = %d EXCEEDED TIER_SIZE = %d !!\n",
				epoch_length, RDR_TIER_SIZE));
			return (RADAR_TYPE_NONE);
		}
		bzero(rt->tiern_list[0], sizeof(rt->tiern_list[0]));

		/*
		 * generate lists
		 */
		wlc_phy_radar_generate_tlist(epoch_list, rt->tiern_list[0], epoch_length, 1);
		for (j = 0; j < epoch_length; j++) {			/* quantize */
			rt->tiern_list[0][j] = rparams->radar_args.quant * ((rt->tiern_list[0][j] +
			(rparams->radar_args.quant >> 1)) / rparams->radar_args.quant);
		}
		tiern_length[0] = epoch_length;
		wlc_phy_radar_filter_list(rt->tiern_list[0], &(tiern_length[0]), rparams->min_tint,
		                rparams->max_tint);
		wlc_shell_sort(tiern_length[0], rt->tiern_list[0]);	/* sort */

		/*
		 * Detection
		 */

		/* Reject out of hand if the number of filtered pulses is too low */
		if (tiern_length[0] < rparams->radar_args.npulses) {
			continue;
		}

		/* measure most common pulse interval */
		wlc_phy_radar_select_nfrequent(rt->tiern_list[0], tiern_length[0], 0,
			&value[0], &pos[0], &freq[0], val_list, freq_list);

		if (freq[0] >= rparams->radar_args.npulses) {
			/* Paydirt: Equal spaced pulses, no gaps */
			pulse_interval = value[0];
			continue;
		}

		if (freq[0] < rparams->radar_args.ncontig) {
			continue;
		}

		/* Possible match - look for gaps */
		/* Check 2nd most frequent interval only on lowest tier */
		wlc_phy_radar_select_nfrequent(rt->tiern_list[0], tiern_length[0], 1,
			&value[1], &pos[1], &freq[1], val_list, freq_list);
		if ((value[1] == (2 * value[0])) && ((freq[0] + freq[1]) >=
			rparams->radar_args.npulses)) {
			/* twice the interval */
			pulse_interval = value[1];
			continue;
		}

		if ((value[0] == (2 * value[1])) && ((freq[0] + freq[1]) >=
			rparams->radar_args.npulses)) {
			/* half the interval */
			pulse_interval = value[1];
			continue;
		}

	}

	if (pulse_interval) {
#ifdef BCMDBG
		int epoch_detected = i;

		PHY_RADAR(("Radar: Pulse Interval %d\n", pulse_interval));

		PHY_RADAR(("Pulse Widths:  "));
		for (i = 0; i < rt->length; i++) {
			PHY_RADAR(("%d ", rt->width_list[i]));
		}
		PHY_RADAR(("\n"));

		PHY_RADAR(("Start Time:  "));
		for (i = 0; i < rt->length; i++) {
			PHY_RADAR(("%d ", rt->tstart_list[i]));
		}
		PHY_RADAR(("\n"));

		PHY_RADAR(("Epoch : nepochs %d, length %d detected %d",
		          rt->nepochs, epoch_length, epoch_detected));
#endif /* BCMDBG */

		return RADAR_TYPE_UNCLASSIFIED;
	}

	return (RADAR_TYPE_NONE);
}

static void
wlc_phy_radar_detect_init_nphy(phy_info_t *pi, bool on)
{
	ASSERT(ISNPHY(pi));

	if (on) {
		if (CHSPEC_CHANNEL(pi->radio_chanspec) <= WL_THRESHOLD_LO_BAND) {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_40_lo;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_40_lo;
			} else {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_20_lo;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_20_lo;
			}
		} else {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_40_hi;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_40_hi;
			} else {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_20_hi;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_20_hi;
			}
		}

		phy_reg_write(pi, NPHY_RadarBlankCtrl,
			pi->ri->rparams.radar_args.blank);

		if (ISNPHY(pi)) {
			if (NREV_LT(pi->pubpi.phy_rev, 3)) {
				phy_reg_write(pi, NPHY_RadarThresh0,
					pi->ri->rparams.radar_args.thresh0);
				phy_reg_write(pi, NPHY_RadarThresh1,
					pi->ri->rparams.radar_args.thresh1);
			} else {
				phy_reg_write(pi, NPHY_RadarThresh0,
					(uint16)((int16)pi->ri->rparams.radar_args.thresh0));
				phy_reg_write(pi, NPHY_RadarThresh1,
					(uint16)((int16)pi->ri->rparams.radar_args.thresh1));
				phy_reg_write(pi, NPHY_Radar_t2_min, 0);
			}
		}

		phy_reg_write(pi, NPHY_StrAddress2u,
			pi->ri->rparams.radar_args.st_level_time);
		phy_reg_write(pi, NPHY_StrAddress2l,
			pi->ri->rparams.radar_args.st_level_time);
		phy_reg_write(pi, NPHY_FMDemodConfig,
			pi->ri->rparams.radar_args.fmdemodcfg);

		wlapi_bmac_write_shm(pi->sh->physhim,
			M_RADAR_REG, pi->ri->rparams.radar_args.thresh1);

		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(NPHY, RadarThresh0R, 0x7a8)
				PHY_REG_WRITE_ENTRY(NPHY, RadarThresh1R, 0x7d0)
			PHY_REG_LIST_EXECUTE(pi);
		} else if (!(ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) && !(ISHTPHY(pi))) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(NPHY, RadarThresh0R, 0x7e8)
				PHY_REG_WRITE_ENTRY(NPHY, RadarThresh1R, 0x10)
			PHY_REG_LIST_EXECUTE(pi);
		}

#ifdef NPHYREV7_HTPHY_DFS_WAR
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(NPHY, RadarMaLength, 0x08)
				PHY_REG_WRITE_ENTRY(NPHY, RadarT3Timeout, 200)
				PHY_REG_WRITE_ENTRY(NPHY, RadarResetBlankingDelay, 25)
			PHY_REG_LIST_EXECUTE(pi);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(NPHY, RadarMaLength, 0x10)
				PHY_REG_WRITE_ENTRY(NPHY, RadarT3Timeout, 400)
				PHY_REG_WRITE_ENTRY(NPHY, RadarResetBlankingDelay, 50)
			PHY_REG_LIST_EXECUTE(pi);
		}
#endif // endif

		/* percal_mask to disable radar detection during selected period cals */
		pi->radar_percal_mask = pi->ri->rparams.radar_args.percal_mask;
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) || ISHTPHY(pi)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(NPHY, RadarSearchCtrl, 1)
#ifdef NPHYREV7_HTPHY_DFS_WAR
				/* turn on moving average with bit 1 */
				PHY_REG_WRITE_ENTRY(NPHY, RadarDetectConfig1, 0x3206)
#else
				PHY_REG_WRITE_ENTRY(NPHY, RadarDetectConfig1, 0x3204)
#endif // endif
				PHY_REG_WRITE_ENTRY(NPHY, RadarT3BelowMin, 0)
			PHY_REG_LIST_EXECUTE(pi);
			if (pi->pubpi.phy_rev == LCNXN_BASEREV)
				phy_reg_write(pi, NPHY_RadarDetectConfig1, 0x3206);
		} else {
			/* Set radar frame search modes */
			phy_reg_write(pi, NPHY_RadarSearchCtrl, 7);
		}
	}

	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_RADARWAR, (on ? MHF1_RADARWAR : 0), FALSE);
}

static void
wlc_phy_radar_detect_init_htphy(phy_info_t *pi, bool on)
{
	if (on) {
		if (CHSPEC_CHANNEL(pi->radio_chanspec) <= WL_THRESHOLD_LO_BAND) {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_40_lo;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_40_lo;
			} else {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_20_lo;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_20_lo;
			}
		} else {
			if (CHSPEC_IS40(pi->radio_chanspec)) {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_40_hi;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_40_hi;
			} else {
				pi->ri->rparams.radar_args.thresh0 =
					pi->ri->rparams.radar_thrs.thresh0_20_hi;
				pi->ri->rparams.radar_args.thresh1 =
					pi->ri->rparams.radar_thrs.thresh1_20_hi;
			}
		}
		phy_reg_write(pi, HTPHY_RadarBlankCtrl,
			(pi->ri->rparams.radar_args.blank));

		phy_reg_write(pi, HTPHY_RadarThresh0,
			(uint16)((int16)pi->ri->rparams.radar_args.thresh0));
		phy_reg_write(pi, HTPHY_RadarThresh1,
			(uint16)((int16)pi->ri->rparams.radar_args.thresh1));
		phy_reg_write(pi, HTPHY_Radar_t2_min, 0);

		phy_reg_write(pi, HTPHY_StrAddress2u,
			pi->ri->rparams.radar_args.st_level_time);
		phy_reg_write(pi, HTPHY_StrAddress2l,
			pi->ri->rparams.radar_args.st_level_time);
		phy_reg_write(pi, HTPHY_FMDemodConfig,
			pi->ri->rparams.radar_args.fmdemodcfg);

		wlapi_bmac_write_shm(pi->sh->physhim,
			M_RADAR_REG, pi->ri->rparams.radar_args.thresh1);

		PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(HTPHY, RadarThresh0R, 0x7a8)
			PHY_REG_WRITE_ENTRY(HTPHY, RadarThresh1R, 0x7d0)
		PHY_REG_LIST_EXECUTE(pi);

#ifdef NPHYREV7_HTPHY_DFS_WAR
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(HTPHY, RadarMaLength, 0x08)
				PHY_REG_WRITE_ENTRY(HTPHY, RadarT3Timeout, 200)
				PHY_REG_WRITE_ENTRY(HTPHY, RadarResetBlankingDelay, 25)
			PHY_REG_LIST_EXECUTE(pi);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			PHY_REG_LIST_START
				PHY_REG_WRITE_ENTRY(HTPHY, RadarMaLength, 0x10)
				PHY_REG_WRITE_ENTRY(HTPHY, RadarT3Timeout, 400)
				PHY_REG_WRITE_ENTRY(HTPHY, RadarResetBlankingDelay, 50)
			PHY_REG_LIST_EXECUTE(pi);
		}
#endif // endif

		/* percal_mask to disable radar detection during selected period cals */
		pi->radar_percal_mask = pi->ri->rparams.radar_args.percal_mask;

		PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(HTPHY, RadarSearchCtrl, 1)
#ifdef NPHYREV7_HTPHY_DFS_WAR
			PHY_REG_WRITE_ENTRY(HTPHY, RadarDetectConfig1, 0x3206)
#else
			PHY_REG_WRITE_ENTRY(HTPHY, RadarDetectConfig1, 0x3204)
#endif // endif
			PHY_REG_WRITE_ENTRY(HTPHY, RadarT3BelowMin, 0)
		PHY_REG_LIST_EXECUTE(pi);
	}

	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_RADARWAR, (on ? MHF1_RADARWAR : 0), FALSE);
}

static void
wlc_phy_radar_detect_init_acphy(phy_info_t *pi, bool on)
{
	/* Update radar_args according to the chanspec */
	if (CHSPEC_CHANNEL(pi->radio_chanspec) <= WL_THRESHOLD_LO_BAND) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_20_lo;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_20_lo;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_40_lo;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_40_lo;
		} else {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_80_lo;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_80_lo;
		}
	} else {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_20_hi;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_20_hi;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_40_hi;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_40_hi;
		} else {
			pi->ri->rparams.radar_args.thresh0 =
				pi->ri->rparams.radar_thrs.thresh0_80_hi;
			pi->ri->rparams.radar_args.thresh1 =
				pi->ri->rparams.radar_thrs.thresh1_80_hi;
		}
	}

	if (on) {
		if (CHSPEC_CHANNEL(pi->radio_chanspec) <= WL_THRESHOLD_LO_BAND) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x08)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 200)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 25)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac19)
					/* RadarBlankCtrl MSB = 1: */
					/* Enable radar fifo read/write stall fix */
					/* for chips after 4360b0 */
				PHY_REG_LIST_EXECUTE(pi);
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x10)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 400)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 50)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac32)
				PHY_REG_LIST_EXECUTE(pi);
			} else {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x1f)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 800)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 100)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac64)
				PHY_REG_LIST_EXECUTE(pi);
			}
		} else {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x08)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 200)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 25)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac19)
				PHY_REG_LIST_EXECUTE(pi);
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x10)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 400)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 50)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac32)
				PHY_REG_LIST_EXECUTE(pi);
			} else {
				PHY_REG_LIST_START
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarMaLength(pi->pubpi.phy_rev), 0x1f)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3BelowMin(pi->pubpi.phy_rev), 0)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarT3Timeout(pi->pubpi.phy_rev), 800)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarResetBlankingDelay(pi->pubpi.phy_rev), 100)
					PHY_REG_WRITE_ENTRY(ACPHY,
						RadarBlankCtrl(pi->pubpi.phy_rev), 0xac64)
				PHY_REG_LIST_EXECUTE(pi);
			}
		}
		/* phy_reg_write(pi, ACPHY_RadarBlankCtrl, */
		/*   (pi->ri->rparams.radar_args.blank | (0x0000))); */
		phy_reg_write(pi, ACPHY_RadarThresh0(pi->pubpi.phy_rev),
			(uint16)((int16)pi->ri->rparams.radar_args.thresh0));
		phy_reg_write(pi, ACPHY_RadarThresh1(pi->pubpi.phy_rev),
			(uint16)((int16)pi->ri->rparams.radar_args.thresh1));
		phy_reg_write(pi, ACPHY_Radar_t2_min(pi->pubpi.phy_rev), 0);
		phy_reg_write(pi, ACPHY_FMDemodConfig(pi->pubpi.phy_rev),
			pi->ri->rparams.radar_args.fmdemodcfg);
		phy_reg_write(pi, ACPHY_RadarBlankCtrl2(pi->pubpi.phy_rev), 0x5f88);

		wlapi_bmac_write_shm(pi->sh->physhim,
			M_RADAR_REG, pi->ri->rparams.radar_args.thresh1);

		/* percal_mask to disable radar detection during selected period cals */
		pi->radar_percal_mask = pi->ri->rparams.radar_args.percal_mask;

		if (ISACPHY(pi) && TONEDETECTION) {
		  PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(ACPHY, RadarSearchCtrl(pi->pubpi.phy_rev), 1)
			PHY_REG_WRITE_ENTRY(ACPHY, RadarDetectConfig1(pi->pubpi.phy_rev), 0x3206)
			/* enable new fm */
		        PHY_REG_WRITE_ENTRY(ACPHY, RadarDetectConfig2(pi->pubpi.phy_rev), 0x141)
		    /* PHY_REG_WRITE_ENTRY(ACPHY, RadarT3BelowMin, 0) */
		   PHY_REG_LIST_EXECUTE(pi);}
		else {
		  PHY_REG_LIST_START
			PHY_REG_WRITE_ENTRY(ACPHY, RadarSearchCtrl(pi->pubpi.phy_rev), 1)
			PHY_REG_WRITE_ENTRY(ACPHY, RadarDetectConfig1(pi->pubpi.phy_rev), 0x3206)
			/* enable new fm */
		        PHY_REG_WRITE_ENTRY(ACPHY, RadarDetectConfig2(pi->pubpi.phy_rev), 0x40)
		    /* PHY_REG_WRITE_ENTRY(ACPHY, RadarT3BelowMin(pi->pubpi.phy_rev), 0) */
		   PHY_REG_LIST_EXECUTE(pi);
		}
	}
	/* Set IIR filter on init */
	if (ISACPHY(pi))
		wlc_phy_radar_detect_iir_war_acphy(pi);

	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Improve radar detect sensitivity */
		phy_reg_write(pi, ACPHY_Radar_adc_to_dbm(pi->pubpi.phy_rev), 0x94);
	} else if (TINY_RADIO(pi)) {
		phy_reg_write(pi, ACPHY_Radar_adc_to_dbm(pi->pubpi.phy_rev), 0x4ac);
		phy_reg_write(pi, ACPHY_RadarDetectConfig1(pi->pubpi.phy_rev), 0x2c06);
	}

	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_RADARWAR, (on ? MHF1_RADARWAR : 0), FALSE);
}

static void
wlc_phy_radar_read_table_nphy_rev_lt7(phy_info_t *pi, radar_work_t *rt, int min_pulses)
{
	int i, core;
	uint16 w0, w1, w2;
	int max_fifo_size = 255;
	radar_params_t *rparams = &pi->ri->rparams;

	ASSERT(ISNPHY(pi) && NREV_LT(pi->pubpi.phy_rev, 7));
	if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3))
		max_fifo_size = 510;

	/* True? Maximum table size is 85 entries for .11n */
	/* Format is different from earlier .11a PHYs */
	bzero(rt->tstart_list_n, sizeof(rt->tstart_list_n));
	bzero(rt->width_list_n, sizeof(rt->width_list_n));
	bzero(rt->fm_list_n, sizeof(rt->fm_list_n));

	if (ISNPHY(pi)) {
		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
			rt->nphy_length[0] = phy_reg_read(pi, NPHY_Antenna0_radarFifoCtrl) & 0x3ff;
			if (GET_RDR_NANTENNAS(pi) > 1)
				rt->nphy_length[1] = phy_reg_read(pi, NPHY_Antenna1_radarFifoCtrl) &
					0x3ff;
		} else {
			rt->nphy_length[0] = phy_reg_read(pi, NPHY_Antenna0_radarFifoCtrl) & 0x1ff;
			if (GET_RDR_NANTENNAS(pi) > 1)
				rt->nphy_length[1] = phy_reg_read(pi, NPHY_Antenna1_radarFifoCtrl) &
					0x1ff;
		}
	}
	/* Rev 3: nphy_length is <=510 because words are read/written in multiples of 3 */

	if (rt->nphy_length[0]  > max_fifo_size) {
		PHY_RADAR(("FIFO LENGTH in ant 0 is greater than max_fifo_size\n"));
		rt->nphy_length[0]  = 0;
	}

	if (GET_RDR_NANTENNAS(pi) > 1 && rt->nphy_length[1] > max_fifo_size) {
		PHY_RADAR(("FIFO LENGTH in ant 1 is greater than max_fifo_size\n"));
		rt->nphy_length[1]  = 0;
	}

#ifdef BCMDBG
	/* enable pulses received at each antenna messages if feature_mask bit-2 is set */
	if (rparams->radar_args.feature_mask & 0x4) {
		if (rt->nphy_length[0] > 5)
			PHY_RADAR(("ant 0:%d\n", rt->nphy_length[0]));
		if (GET_RDR_NANTENNAS(pi) > 1 && rt->nphy_length[1] > 5)
			PHY_RADAR(("ant 1:%d\n", rt->nphy_length[1]));
	}
#endif /* BCMDBG */

	for (core = 0; core < GET_RDR_NANTENNAS(pi); core++) {
		rt->nphy_length[core] /= 3;	/* 3 words per pulse */

		/* use the last sample for bin5 */
		rt->tstart_list_bin5[core][0] = rt->tstart_list_tail[core];
		rt->width_list_bin5[core][0] = rt->width_list_tail[core];
		rt->fm_list_bin5[core][0] = rt->fm_list_tail[core];
		for (i = 0; i < rt->nphy_length[core]; i++) {
			if (core == 0) {
				/* Read out FIFO 0 */
				w0 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
				w1 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
				w2 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
			} else {
				/* Read out FIFO 0 */
				w0 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
				w1 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
				w2 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
			}
			/* USE ONLY 255 of 511 FIFO DATA if feature_mask bit-15 set */
			if ((i < 128 && (rparams->radar_args.feature_mask & 0x8000)) ||
				((rparams->radar_args.feature_mask & 0x8000) == 0)) {
				if (IS20MHZ(pi)) {
					rt->tstart_list_n[core][i] = (uint32) (((w0 << 12) +
						(w1 & 0x0fff)) << 4);
					rt->width_list_n[core][i] = ((w2 & 0x00ff) << 4) +
						((w1 >> 12) & 0x000f);
				} else if (IS40MHZ(pi)) {
					rt->tstart_list_n[core][i] = (uint32) ((((w0 << 12) +
						(w1 & 0x0fff)) << 4) >> 1);
					rt->width_list_n[core][i] = (((w2 & 0x00ff) << 4) +
						((w1 >> 12) & 0x000f)) >> 1;
				} else {
					rt->tstart_list_n[core][i] = (uint32) ((((w0 << 12) +
						(w1 & 0x0fff)) << 4) >> 2);
					rt->width_list_n[core][i] = (((w2 & 0x00ff) << 4) +
						((w1 >> 12) & 0x000f)) >> 2;
				}
				rt->tstart_list_bin5[core][i+1] = rt->tstart_list_n[core][i];
				rt->width_list_bin5[core][i+1] = rt->width_list_n[core][i];
				rt->fm_list_n[core][i] = (w2 >> 8) & 0x00ff;
				rt->fm_list_bin5[core][i+1] = rt->fm_list_n[core][i];
			}
		}
		/* save the last (tail) sample */
		rt->tstart_list_tail[core] = rt->tstart_list_bin5[core][i+1];
		rt->width_list_tail[core] = rt->width_list_bin5[core][i+1];
		rt->fm_list_tail[core] = rt->fm_list_bin5[core][i+1];

		if (rt->nphy_length[core] > 128 && (rparams->radar_args.feature_mask & 0x8000))
			rt->nphy_length[core] = 128;
		rt->nphy_length_bin5[core] = rt->nphy_length[core] + 1;
	}
}

static void
wlc_phy_radar_read_table(phy_info_t *pi, radar_work_t *rt, int min_pulses)
{
	int i;
	uint8 core;
	uint16 w0, w1, w2, w3;
	int max_fifo_size = 512;
#ifdef BCMDBG
	radar_params_t *rparams = &pi->ri->rparams;
#endif /* BCMDBG */
	int FMOFFSET;

	/* Maximum table size is 128 entries for .11n rev7 forward */
	bzero(rt->tstart_list_n, sizeof(rt->tstart_list_n));
	bzero(rt->width_list_n, sizeof(rt->width_list_n));
	bzero(rt->fm_list_n, sizeof(rt->fm_list_n));

	if (ISACPHY(pi)) {
		if (GET_RDR_NANTENNAS(pi) > 1) {
			rt->nphy_length[0] = phy_reg_read(pi,
				ACPHY_Antenna0_radarFifoCtrl(pi->pubpi.phy_rev)) & 0x3ff;
			rt->nphy_length[1] = phy_reg_read(pi,
				ACPHY_Antenna1_radarFifoCtrl(pi->pubpi.phy_rev)) & 0x3ff;
		} else {
			rt->nphy_length[0] = phy_reg_read(pi,
				ACPHY_Antenna0_radarFifoCtrl(pi->pubpi.phy_rev)) & 0x3ff;
		}
	} else if (ISHTPHY(pi)) {
		rt->nphy_length[0] = phy_reg_read(pi, HTPHY_Antenna0_radarFifoCtrl) & 0x3ff;
		if (GET_RDR_NANTENNAS(pi) > 1)
			rt->nphy_length[1] = phy_reg_read(pi, HTPHY_Antenna1_radarFifoCtrl) & 0x3ff;
	} else {
		rt->nphy_length[0] = phy_reg_read(pi, NPHY_Antenna0_radarFifoCtrl) & 0x3ff;
		if (GET_RDR_NANTENNAS(pi) > 1)
			rt->nphy_length[1] = phy_reg_read(pi, NPHY_Antenna1_radarFifoCtrl) & 0x3ff;
	}
	if (ISACPHY(pi) && TONEDETECTION)
	  FMOFFSET = 256;
	else
	  FMOFFSET = 0;

	for (core = 0; core < GET_RDR_NANTENNAS(pi); core++) {
	    if (rt->nphy_length[core] > max_fifo_size) {
		PHY_RADAR(("FIFO LENGTH in ant %d is greater than max_fifo_size of %d\n",
			core, max_fifo_size));
		rt->nphy_length[core]  = 0;
	    }
	}

#ifdef BCMDBG
	/* enable pulses received at each antenna messages if feature_mask bit-2 is set */
	if (rparams->radar_args.feature_mask & 0x4) {
		if (rt->nphy_length[0] > 5)
			PHY_RADAR(("ant 0:%d\n", rt->nphy_length[0]));
		if (GET_RDR_NANTENNAS(pi) > 1 && rt->nphy_length[1] > 5)
			PHY_RADAR(("ant 1:%d\n", rt->nphy_length[1]));
	}
#endif /* BCMDBG */

	for (core = 0; core < GET_RDR_NANTENNAS(pi); core++) {
		rt->nphy_length[core] /= 4;	/* 4 words per pulse */

		/* use the last sample for bin5 */
		rt->tstart_list_bin5[core][0] = rt->tstart_list_tail[core];
		rt->width_list_bin5[core][0] = rt->width_list_tail[core];
		rt->fm_list_bin5[core][0] = rt->fm_list_tail[core];
		for (i = 0; i < rt->nphy_length[core]; i++) {
			if (core == 0) {
				/* Read out FIFO 0 */
				if (ISACPHY(pi)) {
					w0 = phy_reg_read(pi,
						ACPHY_Antenna0_radarFifoData(pi->pubpi.phy_rev));
					w1 = phy_reg_read(pi,
						ACPHY_Antenna0_radarFifoData(pi->pubpi.phy_rev));
					w2 = phy_reg_read(pi,
						ACPHY_Antenna0_radarFifoData(pi->pubpi.phy_rev));
					w3 = phy_reg_read(pi,
						ACPHY_Antenna0_radarFifoData(pi->pubpi.phy_rev));
				} else if (ISHTPHY(pi)) {
					w0 = phy_reg_read(pi, HTPHY_Antenna0_radarFifoData);
					w1 = phy_reg_read(pi, HTPHY_Antenna0_radarFifoData);
					w2 = phy_reg_read(pi, HTPHY_Antenna0_radarFifoData);
					w3 = phy_reg_read(pi, HTPHY_Antenna0_radarFifoData);
				} else {
					w0 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
					w1 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
					w2 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
					w3 = phy_reg_read(pi, NPHY_Antenna0_radarFifoData);
				}
			} else {
				if (ISACPHY(pi)) {
					w0 = phy_reg_read(pi,
						ACPHY_Antenna1_radarFifoData(pi->pubpi.phy_rev));
					w1 = phy_reg_read(pi,
						ACPHY_Antenna1_radarFifoData(pi->pubpi.phy_rev));
					w2 = phy_reg_read(pi,
						ACPHY_Antenna1_radarFifoData(pi->pubpi.phy_rev));
					w3 = phy_reg_read(pi,
						ACPHY_Antenna1_radarFifoData(pi->pubpi.phy_rev));
				} else if (ISHTPHY(pi)) {
					w0 = phy_reg_read(pi, HTPHY_Antenna1_radarFifoData);
					w1 = phy_reg_read(pi, HTPHY_Antenna1_radarFifoData);
					w2 = phy_reg_read(pi, HTPHY_Antenna1_radarFifoData);
					w3 = phy_reg_read(pi, HTPHY_Antenna1_radarFifoData);
				} else {
					w0 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
					w1 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
					w2 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
					w3 = phy_reg_read(pi, NPHY_Antenna1_radarFifoData);
				}
			}

			if (IS20MHZ(pi)) {
				rt->tstart_list_n[core][i] = (uint32)((w0 << 16) +
					((w1 & 0x0fff) << 4) + (w3 & 0xf));
				rt->width_list_n[core][i] = ((w3 & 0x10) << 8) +
					((w2 & 0x00ff) << 4) + ((w1 >> 12) & 0x000f);
			} else if (IS40MHZ(pi)) {
				rt->tstart_list_n[core][i] = (uint32)(((w0 << 16) +
					((w1 & 0x0fff) << 4) + (w3 & 0xf)) >> 1);
				rt->width_list_n[core][i] = (((w3 & 0x10) << 8) +
					((w2 & 0x00ff) << 4) + ((w1 >> 12) & 0x000f)) >> 1;
			} else {
				rt->tstart_list_n[core][i] = (uint32)(((w0 << 16) +
					((w1 & 0x0fff) << 4) + (w3 & 0xf)) >> 2);
				rt->width_list_n[core][i] = (((w3 & 0x10) << 8) +
					((w2 & 0x00ff) << 4) + ((w1 >> 12) & 0x000f)) >> 2;
			}

			rt->tstart_list_bin5[core][i + 1] = rt->tstart_list_n[core][i];
			rt->width_list_bin5[core][i + 1] = rt->width_list_n[core][i];
			rt->fm_list_n[core][i] = ((w3 & 0x20) << 3) + ((w2 >> 8) & 0x00ff) -
			  FMOFFSET;
			rt->fm_list_bin5[core][i + 1] = rt->fm_list_n[core][i];
		}
		/* save the last (tail) sample */
		rt->tstart_list_tail[core] = rt->tstart_list_bin5[core][i+1];
		rt->width_list_tail[core] = rt->width_list_bin5[core][i+1];

		rt->fm_list_tail[core] = rt->fm_list_bin5[core][i+1];
		rt->nphy_length_bin5[core] = rt->nphy_length[core] + 1;
	}
}

static bool wlc_phy_radar_detect_uniform_pw_check(int num_pulses, radar_work_t *rt, uint16 j,
int init_min_detected_pw, int init_max_detected_pw, int *min_detected_pw_p,
int *max_detected_pw_p, int *pulse_interval_p,  int first_interval,
int *detected_pulse_index_p, int max_pw_tol, uint32 feature_mask)
{
	int k;

	*min_detected_pw_p = init_min_detected_pw;
	*max_detected_pw_p = init_max_detected_pw;
	for (k = 0; k < num_pulses; k++) {
		if (feature_mask & 0x10) {
		  PHY_RADAR(("RADAR: k=%d, j=%d, j-k=%d, *min_detected_pw_p=%d,"
				" *max_detected_pw_p=%d, *max_detected_pw_p -"
				" *min_detected_pw_p=%d, *pulse_interval_p=%d\n",
				k, j, j-k, *min_detected_pw_p, *max_detected_pw_p,
				*max_detected_pw_p -
				*min_detected_pw_p, *pulse_interval_p));
		}
		if (rt->tiern_pw[0][j-k] <= *min_detected_pw_p)
			*min_detected_pw_p = rt->tiern_pw[0][j-k];
		if (rt->tiern_pw[0][j-k] >= *max_detected_pw_p)
			*max_detected_pw_p = rt->tiern_pw[0][j-k];
	}
	if ((*max_detected_pw_p - *min_detected_pw_p <=
		max_pw_tol) ||
		(*max_detected_pw_p - 2 * *min_detected_pw_p <=
		2 * max_pw_tol)) {
		*pulse_interval_p = first_interval;
		*detected_pulse_index_p = j -
			num_pulses + 1;
		return TRUE;	/* radar detected */
	} else {
		return FALSE;	/* radar NOT detected */
	}
}

static bool
wlc_phy_radar_detect_pri_pw_filter(phy_info_t *pi,
	radar_work_t *rt, radar_params_t *rparams, uint16 j, int tol,
	int first_interval, int pw_2us, int pw5us, int pw15us, int pw20us, int pw30us,
	int i250us, int i500us, int i625us, int i5000us,
	int pw2us, int i833us, int i2500us, int i3333us,
	int i938us, int i3066us, int i3030us, int i1000us)
{
		if ((ABS(rt->tiern_list[0][j] - first_interval) < tol ||
			ABS(rt->tiern_list[0][j] - (first_interval >> 1)) < tol ||
			ABS(rt->tiern_list[0][j] - first_interval*2) < tol ||
			ABS(rt->tiern_list[0][j] - first_interval*3) < tol ||
			ABS(rt->tiern_list[0][j] - first_interval*4) < tol ||
			ABS(rt->tiern_list[0][j] - first_interval*5) < tol ||
			ABS(rt->tiern_list[0][j] - first_interval*6) < tol) &&

			/* fcc filters */
			(((pi->ri->rparams.radar_args.feature_mask & 0x800) &&
			(first_interval >= pi->ri->rparams.radar_args.min_deltat) &&

			/* type 2 filter */
			((rt->tiern_pw[0][j] <= pi->ri->rparams.max_type2_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_type2_pw &&
			first_interval >= pi->ri->rparams.min_type2_intv - tol &&
			first_interval <= pi->ri->rparams.max_type2_intv + tol) ||

			/* type 3,4 filter */
			(rt->tiern_pw[0][j] <= pi->ri->rparams.max_type4_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_type4_pw &&
			(!ISACPHY(pi) ||
			rt->tiern_pw[0][j] >= pi->ri->rparams.min_type3_pw) &&
			(!ISACPHY(pi) ||
			rt->tiern_pw[0][j+1] >= pi->ri->rparams.min_type3_pw) &&
			first_interval >= pi->ri->rparams.min_type3_4_intv - tol &&
			first_interval <= pi->ri->rparams.max_type3_4_intv + tol) ||

			/* fcc weather radar filter */
			(rt->tiern_pw[0][j] <= pw_2us &&
			rt->tiern_pw[0][j+1] <= pw_2us &&
			first_interval >= pi->ri->rparams.max_type3_4_intv - tol &&
			first_interval <= i3066us + pw20us) ||

			/* korean type 3 filter */
			(rt->tiern_pw[0][j] <= pw_2us &&
			rt->tiern_pw[0][j+1] <= pw_2us &&
			first_interval >= i3030us - tol &&
			first_interval <= i3030us + tol) ||

			/* type 1 filter */
			(rt->tiern_pw[0][j] <= pi->ri->rparams.max_type1_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_type1_pw &&
			first_interval >= pi->ri->rparams.type1_intv - tol &&
			first_interval <= pi->ri->rparams.type1_intv + tol) ||

			/* type 6, jp4 filter */
			(rt->tiern_pw[0][j] <= pi->ri->rparams.max_type1_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_type1_pw &&
			first_interval >= pi->ri->rparams.jp4_intv - tol &&
			first_interval <= pi->ri->rparams.jp4_intv + tol) ||

			/*  jp2+1 filter */
			(rt->tiern_pw[0][j] <= pi->ri->rparams.max_type1_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_type1_pw &&
			first_interval >= pi->ri->rparams.jp2_1_intv - tol &&
			first_interval <= pi->ri->rparams.jp2_1_intv + tol) ||

			/* type jp1-2, jp2-3 filter */
			(rt->tiern_pw[0][j] <= pi->ri->rparams.max_jp1_2_pw &&
			rt->tiern_pw[0][j+1] <= pi->ri->rparams.max_jp1_2_pw &&
			first_interval >= pi->ri->rparams.jp1_2_intv - tol &&
			first_interval <= pi->ri->rparams.jp2_3_intv + tol))) ||

			/* etsi filters */
			((pi->ri->rparams.radar_args.feature_mask & 0x1000) &&

			/* type 1, 2, 5, 6 filter */
			((rt->tiern_pw[0][j] <= pw15us &&
			rt->tiern_pw[0][j+1] <= pw15us &&
			first_interval >= i625us - tol*3 &&
			first_interval <= i5000us + tol) ||

			/* packet based staggered types 4, 5 */
			(rt->tiern_pw[0][j] <= pw2us &&
			rt->tiern_pw[0][j+1] <= pw2us &&
			first_interval >= i833us - tol &&
			first_interval <= i2500us + tol) ||

			/* type 3 filter */
			(rt->tiern_pw[0][j] <= pw15us &&
			rt->tiern_pw[0][j+1] <= pw15us &&
			first_interval >= i250us - tol &&
			first_interval <= i500us + tol) ||

			/* type 4 filter */
			(rt->tiern_pw[0][j] <= pw30us &&
			rt->tiern_pw[0][j+1] <= pw30us &&
			first_interval >= i250us - tol &&
			first_interval <= i500us + tol))))) {
				return TRUE;
			} else {
				return FALSE;
			}
}

#ifdef BCMDBG
static void
wlc_phy_radar_output_iv_pw(const char* type, const radar_work_t *rt, const radar_params_t *rparams,
                           int first_interval, int idx)
{
	if (rparams->radar_args.feature_mask & 0x80) {
		PHY_RADAR(("Check %s. IV:%d-%d ", type, first_interval, idx));
		PHY_RADAR(("PW:%d,%d-%d ", rt->tiern_pw[0][idx], rt->tiern_pw[0][idx+1], idx));
	}
}
#define PHY_RADAR_OUTPUT_IV_PW(type, rt, rparams, first_interval, idx) \
	wlc_phy_radar_output_iv_pw(type, rt, rparams, first_interval, idx)
#else /* !BCMDBG */
#define PHY_RADAR_OUTPUT_IV_PW(type, rt, rparams, first_interval, idx)
#endif /* BCMDBG */

static void
wlc_phy_radar_detect_run_epoch(phy_info_t *pi, uint i,
	radar_work_t *rt, radar_params_t *rparams,
	uint32 *epoch_list, int epoch_length,
	int pw_2us, int pw15us, int pw20us, int pw30us,
	int i250us, int i500us, int i625us, int i5000us,
	int pw2us, int i833us, int i2500us, int i3333us,
	int i938us, int i3066us,
	uint *det_type_p, int *pulse_interval_p, int *nconsecq_pulses_p,
	int *detected_pulse_index_p, int *min_detected_pw_p, int *max_detected_pw_p,
	int *fm_min_p, int *fm_max_p)
{
	uint16 j;
	int k;
	bool radar_detected = FALSE;

	/* int ndetected_staggered; */
	uint det_type = 0;
	char stag_det_seq[32];
	int tiern_length[RDR_NTIERS];
	int detected_pulse_index = 0;
	int nconsecq_pulses = 0;
	int nconsecq_eu_t1, nconsecq_eu_t2, nconsecq_eu_t4;
	int nconseq2even, nconseq2odd, nconseq2evenT5, nconseq2evenT6;
	int nconseq3a, nconseq3b, nconseq3c, nconseq3_EU5, nconseq3_EU6;
	int first_interval;
	int first_interval_eu_t1;
	int first_interval_eu_t2;
	int first_interval_eu_t4;
	int tol;
	int pulse_interval = 0;
	int pw5us, pw1us, i518us;
	int i3030us;
	bool fm_pass_eu_t4;
	int fm_dif, fm_tol;
	int eu_type1_cnt, eu_type2_cnt;
	int npulses_eu_t1, npulses_eu_t2, npulses_eu_t4;
	int i600us, i800us, i1000us, i1250us, i1500us, i2000us;
	int low_intv_eu_t1;
	int low_intv_eu_t2;
	int npulses_jp1_2_jp2_3, npulses_jp2_1, npulses_fcc_1, npulses_jp4;
	int nconsecq_jp1_2_jp2_3, nconsecq_jp2_1, nconsecq_fcc_1, nconsecq_jp4;
	int jp1_2_jp2_3_cnt, jp2_1_cnt, fcc_1_cnt, jp4_cnt;
	int first_interval_jp1_2_jp2_3, first_interval_jp2_1,
	  first_interval_fcc_1, first_interval_jp4;
	int pw0p5us;
	/* int pw2p5us; */
	int i333us, i1389us, i1428us;
	int staggered_T1_EU5, staggered_T2_EU5,	staggered_T3_EU5;
	int staggered_T1_EU6, staggered_T2_EU6,	staggered_T3_EU6;

	/* pri limits for fcc tdwr radars */
	pw0p5us = 12 + 12;
	pw1us = 38 + 12;
	/* pw2p5us = 60; */
	pw5us = 110 + 12;
	i333us = 6660;
	i1389us = 27780;
	i1428us = 28560;
	i518us = 10360;
	i3030us = 60606;  /* korean type 3 intv */
	i600us  = 12000;
	i800us  = 16000;
	i1000us = 20000;
	i1250us = 25000;
	i1500us = 30000;
	i2000us = 40000;

	npulses_eu_t1 = rparams->radar_args.npulses_fra & 0xf;
	npulses_eu_t2 = (rparams->radar_args.npulses_fra >> 4) & 0xf;
	npulses_eu_t4 = (rparams->radar_args.npulses_fra >> 8) & 0xf;

	npulses_jp1_2_jp2_3 = (rparams->radar_args.ncontig >> 10) & 0x7;
	npulses_jp2_1 = (rparams->radar_args.ncontig >> 13) & 0x7;
	npulses_jp4 = npulses_jp2_1;
	npulses_fcc_1 =	npulses_jp2_1;
	switch ((rparams->radar_args.npulses_fra >> 12) & 0x3) {
		case 0:
			low_intv_eu_t1 = i1000us;
			break;
		case 1:
			low_intv_eu_t1 = i1250us;
			break;
		case 2:
			low_intv_eu_t1 = i1500us;
			break;
		case 3:
			low_intv_eu_t1 = i2000us;
			break;
		default:
			low_intv_eu_t1 = i1250us;
			break;
	}

	switch ((rparams->radar_args.npulses_fra >> 14) & 0x3) {
		case 0:
			low_intv_eu_t2 = i600us;
			break;
		case 1:
			low_intv_eu_t2 = i800us;
			break;
		case 2:
			low_intv_eu_t2 = i1000us;
			break;
		case 3:
			low_intv_eu_t2 = i2000us;
			break;
		default:
			low_intv_eu_t2 = i1000us;
			break;
	}

	/* initialize staggered radar detection variables */
	snprintf(stag_det_seq, sizeof(stag_det_seq), "%s", "");

	bzero(rt->tiern_list[0], sizeof(rt->tiern_list[0]));
	bzero(rt->tiern_pw[0], sizeof(rt->tiern_pw[0]));
	bzero(rt->tiern_fm[0], sizeof(rt->tiern_fm[0]));

	/*
	 * generate lists
	 */
	wlc_phy_radar_generate_tlist(epoch_list, rt->tiern_list[0], epoch_length, 1);
	wlc_phy_radar_generate_tpw(rt->width_list + rt->epoch_start[i],
		rt->tiern_pw[0], epoch_length, 1);
	wlc_phy_radar_generate_tfm(rt->fm_list + rt->epoch_start[i],
		rt->tiern_fm[0], epoch_length, 1);
	/* ndetected_staggered = 0; */

	tiern_length[0] = epoch_length;
	wlc_phy_radar_filter_list(rt->tiern_list[0], &(tiern_length[0]), rparams->min_tint,
		rparams->max_tint);

	/* Detect contiguous only pulses */
	detected_pulse_index = 0;
	nconsecq_pulses = 0;
	nconsecq_eu_t1 = 0;
	nconsecq_eu_t2 = 0;
	nconsecq_eu_t4 = 0;
	nconseq2even = 0;
	nconseq2odd = 0;
	nconseq2evenT5 = 0;
	nconseq2evenT6 = 0;
	nconseq3a = 0;
	nconseq3b = 0;
	nconseq3c = 0;
	nconseq3_EU5 = 0;
	nconseq3_EU6 = 0;
	eu_type1_cnt = 0;
	eu_type2_cnt = 0;
	jp1_2_jp2_3_cnt = 0;
	jp2_1_cnt = 0;
	fcc_1_cnt = 0;
	jp4_cnt = 0;
	nconsecq_jp1_2_jp2_3 = 0;
	nconsecq_jp2_1 = 0;
	nconsecq_fcc_1 = 0;
	nconsecq_jp4 = 0;

	radar_detected = 0;
	det_type = RADAR_TYPE_NONE;

	tol = rparams->radar_args.quant;
	first_interval = rt->tiern_list[0][0];
	first_interval_eu_t1 = rt->tiern_list[0][0];
	first_interval_eu_t2 = rt->tiern_list[0][0];
	first_interval_eu_t4 = rt->tiern_list[0][0];
	first_interval_jp1_2_jp2_3 = rt->tiern_list[0][0];
	first_interval_jp2_1 = rt->tiern_list[0][0];
	first_interval_fcc_1 = rt->tiern_list[0][0];
	first_interval_jp4 = rt->tiern_list[0][0];

	staggered_T1_EU5 = i3333us;
	staggered_T2_EU5 = i3333us;
	staggered_T3_EU5 = i3333us;
	staggered_T1_EU6 = i2500us;
	staggered_T2_EU6 = i2500us;
	staggered_T3_EU6 = i2500us;

	if (rparams->radar_args.feature_mask & 0x400) {
	  for (j = 0; j < epoch_length-2; j++) {
	    if ((rt->tiern_list[0][j] < i3333us + tol) && (rt->tiern_list[0][j] > i2500us - tol)) {
	      if (staggered_T1_EU5 - rt->tiern_list[0][j] > 32) {
		staggered_T2_EU5 = staggered_T1_EU5;
		staggered_T1_EU5 = rt->tiern_list[0][j];
	      } else if ((rt->tiern_list[0][j] - staggered_T1_EU5) >
			 (20000000 / (20000000 / staggered_T1_EU5 - 20) -  staggered_T1_EU5 - 32) &&
			 (rt->tiern_list[0][j] - staggered_T1_EU5) <
			 (20000000 / (20000000 / staggered_T1_EU5  - 50) - staggered_T1_EU5 + 32) &&
			 (staggered_T2_EU5 - rt->tiern_list[0][j] > 32)) {
		staggered_T3_EU5 = staggered_T2_EU5;
		staggered_T2_EU5 = rt->tiern_list[0][j];
	      } else if ((rt->tiern_list[0][j] - staggered_T2_EU5)  >
			 (20000000 / (20000000 / staggered_T2_EU5 - 20) -  staggered_T2_EU5 - 32) &&
			 (rt->tiern_list[0][j] - staggered_T2_EU5) <
			 (20000000 / (20000000 / staggered_T2_EU5 - 50) - staggered_T2_EU5 + 32) &&
			 (staggered_T3_EU5 - rt->tiern_list[0][j] > 32)) {
		staggered_T3_EU5 = rt->tiern_list[0][j];
	      }
	    }
	  }
	for (j = 0; j < epoch_length - 2; j++) {
	  if ((rt->tiern_list[0][j] < i2500us + tol) && (rt->tiern_list[0][j] > i833us -tol)) {
	    if (staggered_T1_EU6 - rt->tiern_list[0][j] > 32) {
	      staggered_T2_EU6 = staggered_T1_EU6;
	      staggered_T1_EU6 = rt->tiern_list[0][j];
	    } else if ((rt->tiern_list[0][j] - staggered_T1_EU6) >
		       (20000000 / (20000000 / staggered_T1_EU6 - 80) - staggered_T1_EU6 -32) &&
		       (rt->tiern_list[0][j] - staggered_T1_EU6) <
		       (20000000 / MAX(1, (20000000 / staggered_T1_EU6 - 400)) -
		       staggered_T1_EU6 + 32) &&
		       (staggered_T2_EU6 - rt->tiern_list[0][j] > 32)) {
	      staggered_T3_EU6 = staggered_T2_EU6;
	      staggered_T2_EU6 = rt->tiern_list[0][j];
	    } else if ((rt->tiern_list[0][j] - staggered_T2_EU6) >
		       (20000000 / (20000000 / staggered_T2_EU6 - 80) - staggered_T2_EU6 - 32) &&
		       (rt->tiern_list[0][j] - staggered_T2_EU6) <
		       (20000000 / MAX(1, (20000000 / staggered_T2_EU6 - 400)) -
		       staggered_T2_EU6 + 32) &&
		       (staggered_T3_EU6 - rt->tiern_list[0][j] > 32)) {
	      staggered_T3_EU6 = rt->tiern_list[0][j];
	    }
	  }
	}

#ifdef BCMDBG
	if (rparams->radar_args.feature_mask & 0x600) {
	  PHY_RADAR(("Staggered Pulse Intervial EU5 T1=%d, T2=%d, T3 = %d\n",
	    staggered_T1_EU5, staggered_T2_EU5, staggered_T3_EU5));
	  PHY_RADAR(("Staggered Pulse Intervial EU6 T1=%d, T2=%d , T3 = %d\n",
	    staggered_T1_EU6, staggered_T2_EU6, staggered_T3_EU6));
	}
#endif /* BCMDBG */
}

	for (j = 0; j < epoch_length - 2; j++) {

		/* contiguous pulse detection */

		/* fcc, japan, korean, and EU type 3 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
			first_interval, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) &&
			!radar_detected) {
			nconsecq_pulses++;

			if (rparams->radar_args.feature_mask & 0x10) {
			  PHY_RADAR(("nconsecq_pulses=%d\n", nconsecq_pulses));
			}

			/* if number of detected pulses > threshold, */
			/* check detected pulse for pulse width tolerance */
			if (nconsecq_pulses >= rparams->radar_args.npulses-1) {
				if (wlc_phy_radar_detect_uniform_pw_check
					(rparams->radar_args.npulses-1,
					rt, j, rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					det_type = RADAR_TYPE_UNCLASSIFIED;
					radar_detected = 1;
					*nconsecq_pulses_p = nconsecq_pulses;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("Uclassified", rt, rparams,
					                       first_interval, j);
				}
			}
		} else {
			nconsecq_pulses = 0;
			first_interval = rt->tiern_list[0][j];
		}
		/* FCC Type 1 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_fcc_1, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_fcc_1++;

			/* jp2_1 counting */
			if (rt->tiern_pw[0][j] <= pw1us &&
				first_interval_fcc_1 >= i1428us - tol &&
				first_interval_fcc_1 <= i1428us + tol) {
				++fcc_1_cnt;
			}
			if (rparams->radar_args.feature_mask & 0x10) {
			  PHY_RADAR(("nconsecq_fcc_1=%d, fcc_1_cnt=%d\n",
			     nconsecq_fcc_1, fcc_1_cnt));
			}

			/* special case smaller number of npulses for fcc_1 */
			if ((nconsecq_fcc_1 >= npulses_fcc_1 - 1) &&
				(rparams->radar_args.feature_mask & 0x800) &&
				(fcc_1_cnt >= npulses_fcc_1 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check(npulses_fcc_1-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_fcc_1, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_FCC_5;
					*nconsecq_pulses_p = nconsecq_fcc_1;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("FCC-T1", rt, rparams,
					                       first_interval_fcc_1, j);
					npulses_fcc_1 = npulses_fcc_1 - 3;
				}
			}
		} else {
			nconsecq_fcc_1 = 0;
			fcc_1_cnt = 0;
			first_interval_fcc_1 = rt->tiern_list[0][j];
		}

		/* Japan jp1_2, jp2_3 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
			first_interval_jp1_2_jp2_3, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_jp1_2_jp2_3++;

			/* jp1_2, jp2_3 counting */
			if (rt->tiern_pw[0][j] <= rparams->max_jp1_2_pw &&
			first_interval_jp1_2_jp2_3 >= rparams->jp1_2_intv - tol &&
			first_interval_jp1_2_jp2_3 <= rparams->jp2_3_intv + tol) {
				++jp1_2_jp2_3_cnt;
			}
			if (rparams->radar_args.feature_mask & 0x10) {
			  PHY_RADAR(("nconsecq_jp1_2_jp2_3=%d, jp1_2_jp2_3_cnt=%d\n",
			     nconsecq_jp1_2_jp2_3, jp1_2_jp2_3_cnt));
			}

			/* special case smaller number of npulses for jp1_2, jp2_3 */
			if ((nconsecq_jp1_2_jp2_3 >= npulses_jp1_2_jp2_3 - 1) &&
				(rparams->radar_args.feature_mask & 0x800) &&
				(jp1_2_jp2_3_cnt >= npulses_jp1_2_jp2_3 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check
					(npulses_jp1_2_jp2_3-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_jp1_2_jp2_3, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_JP1_2_JP2_3;
					*nconsecq_pulses_p = nconsecq_jp1_2_jp2_3;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("JP-T1_2", rt, rparams,
						first_interval_jp1_2_jp2_3, j);
					npulses_jp1_2_jp2_3 = npulses_jp1_2_jp2_3 - 3;
				}
			}
		} else {
			nconsecq_jp1_2_jp2_3 = 0;
			jp1_2_jp2_3_cnt = 0;
			first_interval_jp1_2_jp2_3 = rt->tiern_list[0][j];
		}

		/* Japan jp2_1 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_jp2_1, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_jp2_1++;

			/* jp2_1 counting */
			if (rt->tiern_pw[0][j] <= pw0p5us &&
				first_interval_jp2_1 >= i1389us - tol &&
				first_interval_jp2_1 <= i1389us + tol) {
				++jp2_1_cnt;
			}
			if (rparams->radar_args.feature_mask & 0x10) {
				PHY_RADAR(("nconsecq_jp2_1=%d, jp2_1_cnt=%d\n",
				   nconsecq_jp2_1, jp2_1_cnt));
			}

			/* special case smaller number of npulses for jp2_1 */
			if ((nconsecq_jp2_1 >= npulses_jp2_1 - 1) &&
				(rparams->radar_args.feature_mask & 0x800) &&
				(jp2_1_cnt >= npulses_jp2_1 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check(npulses_jp2_1-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_jp2_1, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_JP2_1;
					*nconsecq_pulses_p = nconsecq_jp2_1;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("JP-T2_1", rt, rparams,
					                       first_interval_jp2_1, j);
					npulses_jp2_1 = npulses_jp2_1 - 3;
				}
			}
		} else {
			nconsecq_jp2_1 = 0;
			jp2_1_cnt = 0;
			first_interval_jp2_1 = rt->tiern_list[0][j];
		}

		/* Japan jp4 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_jp4, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_jp4++;
			/* jp4 counting */
			if (rt->tiern_pw[0][j] <= pw1us &&
				first_interval_jp4 >= i333us - tol &&
				first_interval_jp4 <= i333us + tol) {
				++jp4_cnt;
			}
			if (rparams->radar_args.feature_mask & 0x10) {
				PHY_RADAR(("nconsecq_jp4=%d, jp4_cnt=%d\n",
				   nconsecq_jp4, jp4_cnt));
			}

			/* special case smaller number of npulses for jp4 */
			if ((nconsecq_jp4 >= npulses_jp4 - 1) &&
				(rparams->radar_args.feature_mask & 0x800) &&
				(jp4_cnt >= npulses_jp4 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check(npulses_jp4-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_jp4, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_JP4;
					*nconsecq_pulses_p = nconsecq_jp4;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("JP-T4", rt, rparams,
					                       first_interval_jp4, j);
					npulses_jp4 = npulses_jp4 - 3;
				}
			}
		} else {
			nconsecq_jp4 = 0;
			jp4_cnt = 0;
			first_interval_jp4 = rt->tiern_list[0][j];
		}

		/* EU type 1 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_eu_t1, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_eu_t1++;

			/* esti type 1 counting */
			if ((rt->tiern_pw[0][j] <= pw5us &&
				rt->tiern_pw[0][j+1] <= pw5us &&
				first_interval_eu_t1 >= low_intv_eu_t1 &&
				first_interval_eu_t1 <= i5000us + tol)) {
				++eu_type1_cnt;
			}

			/* special case smaller number of npulses for EU types 1 */
			if ((nconsecq_eu_t1 >= npulses_eu_t1 - 1) &&
				(rparams->radar_args.feature_mask & 0x1000) &&
				(eu_type1_cnt >= npulses_eu_t1 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check(npulses_eu_t1-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_eu_t1, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_ETSI_1;
					*nconsecq_pulses_p = nconsecq_eu_t1;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("EU-T1", rt, rparams,
					                       first_interval_eu_t1, j);
					eu_type1_cnt = npulses_eu_t1 - 3;
				}
			}
		} else {
			nconsecq_eu_t1 = 0;
			eu_type1_cnt = 0;
			first_interval_eu_t1 = rt->tiern_list[0][j];
		}

		/* EU type 2 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_eu_t2, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_eu_t2++;

			/* esti type 2 counting */
			if ((rt->tiern_pw[0][j] <= pw15us &&
			rt->tiern_pw[0][j+1] <= pw15us &&
			first_interval_eu_t2 >= low_intv_eu_t2 &&
			first_interval_eu_t2 <= i5000us + tol)) {
				++eu_type2_cnt;
			}

			/* special case smaller number of npulses for EU types 2 */
			if ((nconsecq_eu_t2 >= npulses_eu_t2 - 1) &&
				(rparams->radar_args.feature_mask & 0x1000) &&
				(eu_type2_cnt >= npulses_eu_t2 - 2)) {
				if (wlc_phy_radar_detect_uniform_pw_check(npulses_eu_t2-1, rt, j,
					rparams->radar_args.max_pw,
					rparams->radar_args.min_pw,
					min_detected_pw_p, max_detected_pw_p, &pulse_interval,
					first_interval_eu_t2, &detected_pulse_index,
					rparams->radar_args.max_pw_tol,
					rparams->radar_args.feature_mask)) {
					radar_detected = 1;
					det_type = RADAR_TYPE_ETSI_2;
					*nconsecq_pulses_p = nconsecq_eu_t2;
					break;
				} else {
					PHY_RADAR_OUTPUT_IV_PW("EU-T2", rt, rparams,
					                       first_interval_eu_t2, j);
					eu_type2_cnt = npulses_eu_t2 - 3;
				}
			}
		} else {
			nconsecq_eu_t2 = 0;
			eu_type2_cnt = 0;
			first_interval_eu_t2 = rt->tiern_list[0][j];
		}

		/* EU type 4 detection */
		if (wlc_phy_radar_detect_pri_pw_filter(pi,
			rt, rparams, j, tol,
		        first_interval_eu_t4, pw_2us, pw5us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us, i3030us, i1000us) && !radar_detected) {
			nconsecq_eu_t4++;

			/* special cases for EU type 4: smaller npulses and checking fm */
			if ((nconsecq_eu_t4 >= npulses_eu_t4 - 1) &&
				(rparams->radar_args.feature_mask & 0x1000)) {
				*min_detected_pw_p = rparams->radar_args.max_pw;
				*max_detected_pw_p = rparams->radar_args.min_pw;
				fm_pass_eu_t4 = TRUE;
				*fm_min_p = 1030;
				*fm_max_p = 0;
				fm_tol = 0;
				fm_dif = 0;
				for (k = 0; k < npulses_eu_t4; k++) {
					if (rt->tiern_pw[0][j-k+1] <= *min_detected_pw_p)
						*min_detected_pw_p = rt->tiern_pw[0][j-k+1];
					if (rt->tiern_pw[0][j-k+1] >= *max_detected_pw_p)
						*max_detected_pw_p = rt->tiern_pw[0][j-k+1];
					/* check fm against absolute value threshold */
					if ((uint32) rt->tiern_fm[0][j-k+1] <
						((rparams->radar_args.fra_pulse_err >> 8) &
						 0xff) - tol) {
						fm_pass_eu_t4 = FALSE;
						if ((rparams->radar_args.feature_mask & 0x200) == 0)
						{
							break;
						}
					/* verify fm to be the same in a burst */
					} else if (255 - tol > rt->tiern_fm[0][j-k+1] &&
					      (ISACPHY(pi) && TONEDETECTION)) {
					  fm_pass_eu_t4 = FALSE;
							if ((rparams->radar_args.feature_mask &
								0x200) == 0)
							{
								break;
							}
					    }
					else {
					  if (!(ISACPHY(pi) && TONEDETECTION)) {
						if (rt->tiern_fm[0][j-k+1] < *fm_min_p)
							*fm_min_p = rt->tiern_fm[0][j-k+1];
						if (rt->tiern_fm[0][j-k+1] > *fm_max_p)
							*fm_max_p = rt->tiern_fm[0][j-k+1];
						fm_dif = ABS(*fm_max_p - *fm_min_p);
						fm_tol = ((*fm_min_p+*fm_max_p)/2*
							((rparams->radar_args.ncontig >> 6) &
							0xf))/16;
						if (fm_dif > fm_tol) {
							fm_pass_eu_t4 = FALSE;
							if ((rparams->radar_args.feature_mask &
								0x200) == 0)
							{
								break;
							}
						}
					  }
					}
					if (rparams->radar_args.feature_mask & 0x200) {
						PHY_RADAR(("EU-T4: k=%d,fm=%d,fm_th=%d,"
							"*fm_min_p=%d,*fm_max_p=%d,"
							"fm_dif=%d,fm_tol=%d,fm_pass=%d,pw=%d\n",
							k, rt->tiern_fm[0][j-k+1],
							(rparams->radar_args.fra_pulse_err >> 8) &
							0xff, *fm_min_p, *fm_max_p, fm_dif, fm_tol,
							fm_pass_eu_t4, rt->tiern_pw[0][j-k+1]));
					}
				}
				if (((*max_detected_pw_p - *min_detected_pw_p <=
					rparams->radar_args.max_pw_tol) ||
					(*max_detected_pw_p - 2 * *min_detected_pw_p <=
					2 * rparams->radar_args.max_pw_tol)) &&
					fm_pass_eu_t4) {
					pulse_interval = first_interval_eu_t4;
					detected_pulse_index = j -
						npulses_eu_t4 + 1;
					radar_detected = 1;
					det_type = RADAR_TYPE_ETSI_4;
					*nconsecq_pulses_p = nconsecq_eu_t4;
					break;	/* radar detected */
				} else {
					PHY_RADAR_OUTPUT_IV_PW("EU-T4", rt, rparams,
					                       first_interval_eu_t4, j);
				}
			}
		} else {
			nconsecq_eu_t4 = 0;
			first_interval_eu_t4 = rt->tiern_list[0][j];
		}

	if (rparams->radar_args.feature_mask & 0x400) {
	/* staggered 2/3 single filters */
		/* staggered 2 even */
		if (j >= 2 && !radar_detected) {
		  if ((ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-2]) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T1_EU5) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T2_EU5) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU5 + staggered_T2_EU5)) < 32 ||
		       ABS(rt->tiern_list[0][j] - (2*staggered_T1_EU5 + staggered_T2_EU5)) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU5 + 2*staggered_T2_EU5)) < 32) &&
		      ((rt->tiern_pw[0][j] <= pw1us &&
		      ((rt->tiern_list[0][j] >= i518us -
		      rparams->radar_args.quant &&
		      rt->tiern_list[0][j] <= i938us +
		      rparams->radar_args.quant) ||
		      (rt->tiern_list[0][j] >= i3066us -
		      rparams->radar_args.quant &&
		      rt->tiern_list[0][j] <= i3066us +
		      rparams->radar_args.quant)) &&
		      rparams->radar_args.feature_mask & 0x800) || /* fcc */
		      (rt->tiern_pw[0][j] <= pw2us &&
		      rt->tiern_list[0][j] >= i2500us - tol &&
		      rt->tiern_list[0][j] <= 3*i3333us + tol &&
		      rparams->radar_args.feature_mask &
		      0x1000))) { /* etsi */
		    nconseq2evenT5++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq2evenT5 >=
					rparams->radar_args.npulses_stg2) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq2evenT5; k++) {
						/*
						PHY_RADAR(("EVEN neven=%d, k=%d pw= %d\n",
						nconseq2even, k,rt->tiern_pw[0][j-2*k]));
						*/
						if (rt->tiern_pw[0][j-k+1] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
						if (rt->tiern_pw[0][j-k+1] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p - 2 *
						*min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol) {
						radar_detected = 1;
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG2;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						rparams->radar_args.npulses_stg2 + 1;
						*nconsecq_pulses_p = nconseq2evenT5;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("EVEN RESET neven=%d, j=%d "
					"intv=%d pw= %d\n",
					nconseq2evenT5, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq2evenT5 = 0;
			}
		}
		/* staggered 2/3 single filters */
		/* staggered 2 even */
		if (j >= 2 && !radar_detected) {
		  if ((ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-2]) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T1_EU6) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T2_EU6) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU6 + staggered_T2_EU6)) < 32 ||
		       ABS(rt->tiern_list[0][j] - (2 * staggered_T1_EU6 + staggered_T2_EU6)) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU6 + 2 * staggered_T2_EU6)) <
		       32) &&
		       ((rt->tiern_pw[0][j] <= pw1us &&
		       ((rt->tiern_list[0][j] >= i518us -
		       rparams->radar_args.quant &&
		       rt->tiern_list[0][j] <= i938us +
		       rparams->radar_args.quant) ||
		       (rt->tiern_list[0][j] >= i3066us -
		       rparams->radar_args.quant &&
		       rt->tiern_list[0][j] <= i3066us +
		       rparams->radar_args.quant)) &&
		       rparams->radar_args.feature_mask & 0x800) || /* fcc */
		       (rt->tiern_pw[0][j] <= pw2us &&
		       rt->tiern_list[0][j] >= i833us - tol &&
		       rt->tiern_list[0][j] <= 3*i2500us + tol &&
		       rparams->radar_args.feature_mask & 0x1000))) { /* etsi */
		    nconseq2evenT6++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq2evenT6 >=
					rparams->radar_args.npulses_stg2) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq2evenT6; k++) {
						/*
						PHY_RADAR(("EVEN neven=%d, k=%d pw= %d\n",
						nconseq2even, k,rt->tiern_pw[0][j-2*k]));
						*/
						if (rt->tiern_pw[0][j-k+1] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
						if (rt->tiern_pw[0][j-k+1] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p - 2 *
						*min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol) {
						radar_detected = 1;
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG2;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						rparams->radar_args.npulses_stg2 + 1;
						*nconsecq_pulses_p = nconseq2evenT6;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("EVEN RESET neven=%d, j=%d "
					"intv=%d pw= %d\n",
					nconseq2evenT6, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq2evenT6 = 0;
			}
		}
		/* staggered 3-a */
		if ((j >= 3 && !radar_detected) &&
			(rparams->radar_args.feature_mask & 0x1000)) {
		  if ((ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-3]) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T1_EU5) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T2_EU5) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T3_EU5) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU5 + staggered_T2_EU5)) <
		       tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T2_EU5 + staggered_T3_EU5)) <
		       tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU5 + staggered_T3_EU5)) <
		       tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU5 + staggered_T2_EU5 +
		       staggered_T3_EU5)) < tol) &&
		       rt->tiern_pw[0][j] <= pw2us &&
		       (rt->tiern_list[0][j] >= i2500us - tol &&
		       rt->tiern_list[0][j] <= 3*i3333us + tol)) {
				nconseq3_EU5++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq3_EU5 >=
					rparams->radar_args.npulses_stg3) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < rparams->radar_args.npulses_stg3; k++) {
						/*
						PHY_RADAR(("3A n3a=%d, k=%d pw= %d\n",
						nconseq3a, k,rt->tiern_pw[0][j-3*k]));
						*/
						if (rt->tiern_pw[0][j-k+1] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
						if (rt->tiern_pw[0][j-k+1] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol)
					{
						radar_detected = 1;
						*nconsecq_pulses_p = nconseq3_EU5;
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG3;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						rparams->radar_args.npulses_stg3 + 1;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("3A RESET n3a=%d, j=%d intv=%d "
					"pw= %d\n",
					nconseq3_EU5, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq3_EU5 = 0;
			}
		}

		/* staggered 3-a */
		if ((j >= 3 && !radar_detected) &&
			(rparams->radar_args.feature_mask & 0x1000)) {
		  if ((ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-3]) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T1_EU6) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T2_EU6) < 32 ||
		       ABS(rt->tiern_list[0][j] - staggered_T3_EU6) < 32 ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU6 + staggered_T2_EU6)) < tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T2_EU6 + staggered_T3_EU6)) < tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU6 + staggered_T3_EU6)) < tol ||
		       ABS(rt->tiern_list[0][j] - (staggered_T1_EU6 + staggered_T2_EU6 +
		       staggered_T3_EU6)) < tol) &&
		       rt->tiern_pw[0][j] <= pw2us &&
		       (rt->tiern_list[0][j] >= i833us - tol &&
		       rt->tiern_list[0][j] <= 3*i2500us + tol)) {
				nconseq3_EU6++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq3_EU6 >=
					rparams->radar_args.npulses_stg3) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq3_EU6; k++) {
						/*
						PHY_RADAR(("3A n3a=%d, k=%d pw= %d\n",
						nconseq3a, k,rt->tiern_pw[0][j-3*k]));
						*/
						if (rt->tiern_pw[0][j-k+1] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
						if (rt->tiern_pw[0][j-k+1] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-k+1];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol)
					{
						radar_detected = 1;
						*nconsecq_pulses_p = nconseq3_EU6;
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG3;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						rparams->radar_args.npulses_stg3 + 1;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("3A RESET n3a=%d, j=%d intv=%d, pw= %d\n",
					nconseq3_EU6, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq3_EU6 = 0;
			}
		}

	} else {
		/* staggered 2/3 single filters */
		/* staggered 2 even */
		if (j >= 2 && j % 2 == 0 && !radar_detected) {
			if (ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-2]) < tol &&
				((rt->tiern_pw[0][j] <= pw1us &&
				((rt->tiern_list[0][j] >= i518us -
				rparams->radar_args.quant &&
				rt->tiern_list[0][j] <= i938us +
				rparams->radar_args.quant) ||
				(rt->tiern_list[0][j] >= i3066us -
				rparams->radar_args.quant &&
				rt->tiern_list[0][j] <= i3066us +
				rparams->radar_args.quant)) &&
				/* fcc */
				rparams->radar_args.feature_mask & 0x800) ||
				(/* rt->tiern_pw[0][j] <= pw2us && */
				rt->tiern_list[0][j] >= i833us - tol &&
				rt->tiern_list[0][j] <= i3333us + tol &&
				rparams->radar_args.feature_mask & 0x1000))) {
				/* etsi */
				nconseq2even++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq2even + nconseq2odd >=
					rparams->radar_args.npulses_stg2-1) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq2even; k++) {
						/*
						PHY_RADAR(("EVEN neven=%d, k=%d pw= %d\n",
						nconseq2even, k,rt->tiern_pw[0][j-2*k]));
						*/
						if (rt->tiern_pw[0][j-2*k] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-2*k];
						if (rt->tiern_pw[0][j-2*k] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-2*k];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p - 2 *
						*min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol) {
						radar_detected = 1;
					}
					if (nconseq2odd > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq2odd; k++) {
							/*
							PHY_RADAR(("EVEN nodd=%d,"
								"k=%d pw= %d\n",
								nconseq2odd, k,
								rt->tiern_pw[0][j-2*k-1]));
							*/
							if (rt->tiern_pw[0][j-2*k-1] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-2*k-1];
							if (rt->tiern_pw[0][j-2*k-1] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-2*k-1];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
						}
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG2;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						2 * rparams->radar_args.npulses_stg2 + 1;
						*nconsecq_pulses_p = nconseq2odd;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("EVEN RESET neven=%d, j=%d "
					"intv=%d pw= %d\n",
					nconseq2even, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq2even = 0;
			}
		}

		/* staggered 2 odd */
		if (j >= 3 && j % 2 == 1 && !radar_detected) {
			if (ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-2]) < tol &&
				((rt->tiern_pw[0][j] <= pw1us &&
				((rt->tiern_list[0][j] >= i518us -
				rparams->radar_args.quant &&
				rt->tiern_list[0][j] <= i938us +
				rparams->radar_args.quant) ||
				(rt->tiern_list[0][j] >= i3066us -
				rparams->radar_args.quant &&
				rt->tiern_list[0][j] <= i3066us +
				rparams->radar_args.quant)) &&
				/* fcc */
				rparams->radar_args.feature_mask & 0x800) ||
				(/* rt->tiern_pw[0][j] <= pw2us && */
				rt->tiern_list[0][j] >= i833us - tol &&
				rt->tiern_list[0][j] <= i3333us + tol &&
				rparams->radar_args.feature_mask & 0x1000))) {
				/* etsi */
				nconseq2odd++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq2even + nconseq2odd >=
					rparams->radar_args.npulses_stg2-1) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq2odd; k++) {
						/*
						 * PHY_RADAR(("ODD nodd=%d, k=%d pw= %d\n",
						 * nconseq2odd, k,rt->tiern_pw[0][j-2*k]));
						 */
						if (rt->tiern_pw[0][j-2*k] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-2*k];
						if (rt->tiern_pw[0][j-2*k] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
								rt->tiern_pw[0][j-2*k];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol) {
						radar_detected = 1;
					}
					if (nconseq2even > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq2even; k++) {
							/*
							   PHY_RADAR(("ODD neven=%d,"
							   " k=%d pw= %d\n",
							   nconseq2even, k,
							   rt->tiern_pw[0][j-2*k-1]));
							 */
							if (rt->tiern_pw[0][j-2*k-1] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
									rt->tiern_pw[0][j-2*k-1];
							if (rt->tiern_pw[0][j-2*k-1] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
									rt->tiern_pw[0][j-2*k-1];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
							radar_detected = 1;
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG2;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
							2 * rparams->radar_args.npulses_stg2 + 1;
						*nconsecq_pulses_p = nconseq2even;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("ODD RESET nodd=%d, j=%d "
						"intv=%d pw= %d\n",
						nconseq2odd, j, rt->tiern_list[0][j],
						rt->tiern_pw[0][j]));
				nconseq2odd = 0;
			}
		}

		/* staggered 3-a */
		if ((j >= 3 && j % 3 == 0 && !radar_detected) &&
			(rparams->radar_args.feature_mask & 0x1000)) {
			if (ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-3]) < tol &&
				/* rt->tiern_pw[0][j] <= pw2us && */
				(rt->tiern_list[0][j] >= i833us - tol &&
				rt->tiern_list[0][j] <= i3333us + tol)) {
				nconseq3a++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq3a + nconseq3b + nconseq3c >=
					rparams->radar_args.npulses_stg3-1) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq3a; k++) {
						/*
						PHY_RADAR(("3A n3a=%d, k=%d pw= %d\n",
						nconseq3a, k,rt->tiern_pw[0][j-3*k]));
						*/
						if (rt->tiern_pw[0][j-3*k] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
						if (rt->tiern_pw[0][j-3*k] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol)
					{
						radar_detected = 1;
						*nconsecq_pulses_p = nconseq3a;
					}
					if (nconseq3c > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3c; k++) {
							/*
							PHY_RADAR(("3A n3c=%d, k=%d "
							"pw= %d\n",
							nconseq3c, k,
							rt->tiern_pw[0][j-3*k-1]));
							*/
							if (rt->tiern_pw[0][j-3*k-1] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
							if (rt->tiern_pw[0][j-3*k-1] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3c;
						}
					}
					if (nconseq3b > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3b; k++) {
							/*
							PHY_RADAR(("3A n3b=%d, k=%d "
							"pw= %d\n",
							nconseq3b, k,
							rt->tiern_pw[0][j-3*k-2]));
							*/
							if (rt->tiern_pw[0][j-3*k-2] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
							if (rt->tiern_pw[0][j-3*k-2] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3b;
						}
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG3;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						3 * rparams->radar_args.npulses_stg3 + 1;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("3A RESET n3a=%d, j=%d intv=%d "
					"pw= %d\n",
					nconseq3a, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq3a = 0;
			}
		}

		/* staggered 3-b */
		if ((j >= 4 && j % 3 == 1) && !radar_detected &&
			(rparams->radar_args.feature_mask & 0x1000)) {
			if (ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-3]) < tol &&
				/* rt->tiern_pw[0][j] <= pw2us && */
				(rt->tiern_list[0][j] >= i833us - tol &&
				rt->tiern_list[0][j] <= i3333us + tol)) {
				nconseq3b++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq3a + nconseq3b + nconseq3c >=
					rparams->radar_args.npulses_stg3-1) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq3b; k++) {
						/*
						PHY_RADAR(("3B n3b=%d, k=%d pw= %d\n",
						nconseq3b, k,rt->tiern_pw[0][j-3*k]));
						*/
						if (rt->tiern_pw[0][j-3*k] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
						if (rt->tiern_pw[0][j-3*k] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol)
					{
						radar_detected = 1;
						*nconsecq_pulses_p = nconseq3b;
					}
					if (nconseq3a > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3a; k++) {
							/*
							PHY_RADAR(("3B n3a=%d, k=%d "
							"pw= %d\n",
							nconseq3a, k,
							rt->tiern_pw[0][j-3*k-1]));
							*/
							if (rt->tiern_pw[0][j-3*k-1] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
							if (rt->tiern_pw[0][j-3*k-1] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3a;
						}
					}
					if (nconseq3c > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3c; k++) {
							/*
							PHY_RADAR(("3B n3c=%d, k=%d "
							"pw= %d\n",
							nconseq3c, k,
							rt->tiern_pw[0][j-3*k-2]));
							*/
							if (rt->tiern_pw[0][j-3*k-2] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
							if (rt->tiern_pw[0][j-3*k-2] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3c;
						}
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG3;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						3 * rparams->radar_args.npulses_stg3 + 1;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("3B RESET n3b=%d, j=%d intv=%d pw= %d\n",
					nconseq3b, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq3b = 0;
			}
		}

		/* staggered 3-c */
		if ((j >= 5 && j % 3 == 2) && !radar_detected &&
			(rparams->radar_args.feature_mask & 0x1000)) {
			if (ABS(rt->tiern_list[0][j] - rt->tiern_list[0][j-3]) < tol &&
				/* rt->tiern_pw[0][j] <= pw2us && */
				(rt->tiern_list[0][j] >= i833us - tol &&
				rt->tiern_list[0][j] <= i3333us + tol)) {
				nconseq3c++;
				/* check detected pulse for pulse width tolerance */
				if (nconseq3a + nconseq3b + nconseq3c >=
					rparams->radar_args.npulses_stg3-1) {
					*min_detected_pw_p = rparams->radar_args.max_pw;
					*max_detected_pw_p = rparams->radar_args.min_pw;
					for (k = 0; k < nconseq3c; k++) {
						/*
						PHY_RADAR(("3C n3c=%d, k=%d pw= %d\n",
						nconseq3c, k,rt->tiern_pw[0][j-3*k]));
						*/
						if (rt->tiern_pw[0][j-3*k] <=
							*min_detected_pw_p)
							*min_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
						if (rt->tiern_pw[0][j-3*k] >=
							*max_detected_pw_p)
							*max_detected_pw_p =
							rt->tiern_pw[0][j-3*k];
					}
					if (*max_detected_pw_p - *min_detected_pw_p <
						rparams->radar_args.max_pw_tol ||
						*max_detected_pw_p -
						2 * *min_detected_pw_p <
						2 * rparams->radar_args.max_pw_tol)
					{
						radar_detected = 1;
						*nconsecq_pulses_p = nconseq3c;
					}
					if (nconseq3b > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3b; k++) {
							/*
							PHY_RADAR(("3C n3b=%d, k=%d "
							"pw= %d\n",
							nconseq3b, k,
							rt->tiern_pw[0][j-3*k-1]));
							*/
							if (rt->tiern_pw[0][j-3*k-1] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
							if (rt->tiern_pw[0][j-3*k-1] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-1];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3b;
						}
					}
					if (nconseq3a > 0) {
						*min_detected_pw_p =
							rparams->radar_args.max_pw;
						*max_detected_pw_p =
							rparams->radar_args.min_pw;
						for (k = 0; k < nconseq3a; k++) {
							/*
							PHY_RADAR(("3C n3a=%d, k=%d "
							"pw= %d\n",
							nconseq3a, k,
							rt->tiern_pw[0][j-3*k-2]));
							*/
							if (rt->tiern_pw[0][j-3*k-2] <=
								*min_detected_pw_p)
								*min_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
							if (rt->tiern_pw[0][j-3*k-2] >=
								*max_detected_pw_p)
								*max_detected_pw_p =
								rt->tiern_pw[0][j-3*k-2];
						}
						if (*max_detected_pw_p -
							*min_detected_pw_p <
							rparams->radar_args.max_pw_tol ||
							*max_detected_pw_p -
							2 * *min_detected_pw_p <
							2 * rparams->radar_args.max_pw_tol)
						{
							radar_detected = 1;
							*nconsecq_pulses_p = nconseq3a;
						}
					}
					if (radar_detected) {
						det_type = RADAR_TYPE_STG3;
						pulse_interval = rt->tiern_list[0][j];
						detected_pulse_index = j -
						3 * rparams->radar_args.npulses_stg3 + 1;
						break;	/* radar detected */
					}
				}
			} else {
				if (rparams->radar_args.feature_mask & 0x20)
					PHY_RADAR(("3C RESET n3c=%d, j=%d intv=%d pw= %d\n",
					nconseq3c, j, rt->tiern_list[0][j],
					rt->tiern_pw[0][j]));
				nconseq3c = 0;
			}
		}
	}
	}  /* for (j = 0; j < epoch_length - 2; j++) */

	if (radar_detected) {
		*det_type_p = det_type;
		*pulse_interval_p = pulse_interval;
		*detected_pulse_index_p = detected_pulse_index;
	} else {
		*det_type_p = RADAR_TYPE_NONE;
		*pulse_interval_p = 0;
		*nconsecq_pulses_p = 0;
		*detected_pulse_index_p = 0;
	}
}

static int
wlc_phy_radar_detect_run_nphy(phy_info_t *pi)
{
/* NOTE: */
/* PLEASE UPDATE THE DFS_SW_VERSION #DEFINE'S IN FILE WLC_PHY_INT.H */
/* EACH TIME ANY DFS FUNCTION IS MODIFIED EXCEPT RADAR THRESHOLD CHANGES */
	uint16 i;
	uint16 j;
	int k;
	int wr_ptr;
	uint8 ant;
	uint16 mlength;
	uint32 *epoch_list;
	int epoch_length = 0;
	int epoch_detected;
	int pulse_interval;
	uint32 tstart;
	uint16 width;
	int16 fm;
	bool valid_lp;
	bool filter_pw = TRUE;
	bool filter_fm = TRUE;
	int32 deltat;
	radar_work_t *rt = &pi->ri->radar_work;
	radar_params_t *rparams = &pi->ri->rparams;
	uint det_type;
	int skip_type = 0;
	int min_detected_pw;
	int max_detected_pw;
	int pw_2us, pw15us, pw20us, pw30us;
	int i250us, i500us, i625us, i5000us;
	int pw2us, i833us, i2500us, i3333us;
	int i938us, i3066us;
	/* int i633us, i658us; */
	int nconsecq_pulses = 0;
	int detected_pulse_index = 0;
	uint32 max_lp_buffer_span;
	int32 deltat2 = 0;
	int32 salvate_intv = 0;
	uint32 tmp_uint32;
	int pw_dif, pw_tol, fm_dif, fm_tol;
	int fm_min = 0;
	int fm_max = 0;
	int FMCOMBINEOFFSET;
	pw_2us  = 40+16;
	pw15us = 300+45;
	pw20us = 400+60;
	pw30us = 600+90;
	i250us = 5000;    /* 4000 Hz */
	i500us = 10000;   /* 2000Hz */
	i625us = 12500;   /* 1600 Hz */
	/* i633us = 12658; */   /* 1580 Hz */
	/* i658us = 13158; */   /* 1520 Hz */
	i938us = 18760;   /* 1066.1 Hz */
	i3066us = 61312;  /* 326.2 Hz */
	i5000us = 100000; /* 200 Hz */
	/* staggered */
	pw2us  = 40+ 20;
	i833us = 16667;   /* 1200 Hz */
	i2500us = 50000;  /* 400 Hz */
	i3333us = 66667;  /* 300 Hz */
	max_lp_buffer_span = MAX_LP_BUFFER_SPAN_20MHZ;  /* 12sec */

	/* clear LP buffer if requested, and print LP buffer count history */
	if (pi->dfs_lp_buffer_nphy != 0) {
		pi->dfs_lp_buffer_nphy = 0;
		pi->ri->first_radar_indicator = 1;
		printf("DFS LP buffer =  ");
		for (i = 0; i < rt->lp_len_his_idx; i++) {
			printf("%d, ", rt->lp_len_his[i]);
		}
		printf("%d; now CLEARED\n", rt->lp_length);
		rt->lp_length = 0;
		rt->lp_pw_fm_matched = 0;
		rt->lp_n_non_single_pulses = 0;
		rt->lp_cnt = 0;
		rt->lp_skip_cnt = 0;
		rt->lp_skip_tot = 0;
		rt->lp_csect_single = 0;
		rt->lp_len_his_idx = 0;
		rt->last_detection_time = pi->sh->now;
		rt->last_detection_time_lp = pi->sh->now;
	}
	if (!rparams->radar_args.npulses) {
		PHY_ERROR(("%s: radar params not initialized\n", __FUNCTION__));
		return RADAR_TYPE_NONE;
	}

	/* initialize variable */
	pulse_interval = 0;

	min_detected_pw = rparams->radar_args.max_pw;
	max_detected_pw = rparams->radar_args.min_pw;

	/* suspend mac before reading phyregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
		OSL_DELAY(1);
	}

	if (ISNPHY(pi) && NREV_LT(pi->pubpi.phy_rev, 7))
		wlc_phy_radar_read_table_nphy_rev_lt7(pi, rt, 1);
	else
		wlc_phy_radar_read_table(pi, rt, 1);

	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);

	/* restart mac after reading phyregs */
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	/* skip radar detect if doing periodic cal
	 * (the test-tones utilized during cal can trigger
	 * radar detect)
	 * NEED TO BE HERE AFTER READING DATA FROM (CLEAR) THE FIFO
	 */
	if (ISNPHY(pi)) {
	  if (pi->u.pi_nphy->nphy_rxcal_active) {
	    pi->u.pi_nphy->nphy_rxcal_active = FALSE;
	    PHY_RADAR(("DOING RXCAL, SKIP RADARS\n"));
	    return RADAR_TYPE_NONE;
	  }
	}
	if (ISHTPHY(pi)) {
	  if (pi->u.pi_htphy->radar_cal_active) {
	    pi->u.pi_htphy->radar_cal_active = FALSE;
	    PHY_RADAR(("DOING CAL, SKIP RADARS\n"));
	    return RADAR_TYPE_NONE;
	  }
	}
	if (ISACPHY(pi)) {
	  if (pi->u.pi_acphy->radar_cal_active) {
	    pi->u.pi_acphy->radar_cal_active = FALSE;
	    PHY_RADAR(("DOING CAL, SKIP RADARS\n"));
	    return RADAR_TYPE_NONE;
	  }
	}
	if (ISACPHY(pi) && TONEDETECTION)
	  FMCOMBINEOFFSET =
	    MAX((2 << (((rparams->radar_args.st_level_time>> 12) & 0xf) -1)) -1, 0);
	else
	  FMCOMBINEOFFSET = 0;

	/*
	 * Reject if no pulses recorded
	 */
	if (GET_RDR_NANTENNAS(pi) == 2) {
	    if ((rt->nphy_length[0] < 1) && (rt->nphy_length[1] < 1)) {
			return RADAR_TYPE_NONE;
		}
	} else {
		if (rt->nphy_length[0] < 1) {
		return RADAR_TYPE_NONE;
	    }
	}

#ifdef BCMDBG
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
	    if ((rparams->radar_args.feature_mask & 0x8) ||
	        (rparams->radar_args.feature_mask & 0x40))  {
	      PHY_RADAR(("\nShort pulses entering radar_detect_run "));
	      PHY_RADAR(("\nAnt %d: %d pulses, ", ant, rt->nphy_length[ant]));

	      PHY_RADAR(("\ntstart0=[  "));
			for (i = 0; i < rt->nphy_length[ant]; i++)
			  PHY_RADAR(("%u ", rt->tstart_list_n[ant][i]));
					  PHY_RADAR(("];"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->nphy_length[ant]; i++)
				PHY_RADAR(("%u ", rt->tstart_list_n[ant][i] -
				   rt->tstart_list_n[ant][i - 1]));

			PHY_RADAR(("\nPulse Widths:  "));
			for (i = 0; i < rt->nphy_length[ant]; i++)
			  PHY_RADAR(("%d-%d ", rt->width_list_n[ant][i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->nphy_length[ant]; i++)
			  PHY_RADAR(("%d-%d ", rt->fm_list_n[ant][i], i));
			PHY_RADAR(("\n"));
	    }
	}
#endif /* BCMDBG */

	/* t2_min[15:12] = x; if n_non_single >= x && lp_length > npulses_lp => bin5 detected */
	/* t2_min[11:10] = # times combining adjacent pulses < min_pw_lp  */
	/* t2_min[9] = fm_tol enable */
	/* t2_min[8] = skip_type 5 enable */
	/* t2_min[7:4] = y; bin5 remove pw <= 10*y  */
	/* t2_min[3:0] = t; non-bin5 remove pw <= 5*y */

	/* remove "noise" pulses with small pw */
	if (!(rparams->radar_args.feature_mask & 0x600)) {
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
		wr_ptr = 0;
		mlength = rt->nphy_length_bin5[ant];
		for (i = 0; i < rt->nphy_length_bin5[ant]; i++) {
			if (rt->width_list_bin5[ant][i] >
			    10*((rparams->radar_args.t2_min >> 4) & 0xf) &&
			    rt->fm_list_bin5[ant][i] >
			    ((ISACPHY(pi) && TONEDETECTION) ?
			     rparams->radar_args.min_fm_lp : rparams->radar_args.min_fm_lp/2)) {
				rt->tstart_list_bin5[ant][wr_ptr] = rt->tstart_list_bin5[ant][i];
				rt->fm_list_bin5[ant][wr_ptr] = rt->fm_list_bin5[ant][i];
				rt->width_list_bin5[ant][wr_ptr] = rt->width_list_bin5[ant][i];
				++wr_ptr;
			} else {
				mlength--;
			}
		}	/* for mlength loop */
		rt->nphy_length_bin5[ant] = mlength;
	}	/* for ant loop */
	}

#ifdef BCMDBG
	/* output ant0/1 fifo data */
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
	    if (rparams->radar_args.feature_mask & 0x8) {
			if ((rparams->radar_args.feature_mask & 0x1) == 0) { /* bin5 */
				if (rt->nphy_length_bin5[ant] > 0) {
				  PHY_RADAR(("\nBin5 after removing noise pulses with pw <= %d",
				  ((rparams->radar_args.t2_min >> 4) & 0xf) * 10));
				  PHY_RADAR(("\nAnt %d: %d pulses, ", ant,
				  rt->nphy_length_bin5[ant]));

				  PHY_RADAR(("\ntstart0=[  "));
				  for (i = 0; i < rt->nphy_length_bin5[ant]; i++)
				    PHY_RADAR(("%u ", rt->tstart_list_bin5[ant][i]));
				  PHY_RADAR(("];"));

				  PHY_RADAR(("\nInterval:  "));
				  for (i = 1; i < rt->nphy_length_bin5[ant]; i++)
				    PHY_RADAR(("%d ", rt->tstart_list_bin5[ant][i] -
				    rt->tstart_list_bin5[ant][i - 1]));

				  PHY_RADAR(("\nPulse Widths:  "));
				  for (i = 0; i < rt->nphy_length_bin5[ant]; i++)
				    PHY_RADAR(("%d-%d ", rt->width_list_bin5[ant][i], i));

				  PHY_RADAR(("\nFM:  "));
				  for (i = 0; i < rt->nphy_length_bin5[ant]; i++)
				    PHY_RADAR(("%d-%d ", rt->fm_list_bin5[ant][i], i));
				  PHY_RADAR(("\n"));
				}
			} else { /* short pulse */
			if (rt->nphy_length[ant] > 0) {
				PHY_RADAR(("\nShort pulses entering radar_detect_run "));
				PHY_RADAR(("\nAnt %d: %d pulses, ", ant, rt->nphy_length[ant]));

				PHY_RADAR(("\ntstart0=[  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%u ", rt->tstart_list_n[ant][i]));
				PHY_RADAR(("];"));

				PHY_RADAR(("\nInterval:  "));
				for (i = 1; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d ", rt->tstart_list_n[ant][i] -
					rt->tstart_list_n[ant][i - 1]));

				PHY_RADAR(("\nPulse Widths:  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d-%d ", rt->width_list_n[ant][i], i));

				PHY_RADAR(("\nFM:  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d-%d ", rt->fm_list_n[ant][i], i));
				PHY_RADAR(("\n"));
			}
	      }
	    }
	}
#endif /* BCMDBG */

	if (rparams->radar_args.feature_mask & 0x800) {   /* if fcc */

	/* START LONG PULSES (BIN5) DETECTION */

	/* Combine pulses that are adjacent for ant 0 and ant 1 */
	  for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
	    rt->length =  rt->nphy_length_bin5[ant];
	    for (k = 0; k < ((rparams->radar_args.t2_min >> 10) & 0x3); k++) {
		mlength = rt->length;
		if (mlength > 1) {
			for (i = 1; i < mlength; i++) {
				deltat = ABS((int32)(rt->tstart_list_bin5[ant][i] -
					rt->tstart_list_bin5[ant][i-1]));

				if (deltat <= (int32)rparams->radar_args.max_pw_lp) {
					rt->width_list_bin5[ant][i-1] =
					  deltat + rt->width_list_bin5[ant][i];
					/* print pulse combining debug messages */
					if (0) {
						PHY_RADAR(("*%d,%d,%d ",
						rt->tstart_list_bin5[ant][i] -
						rt->tstart_list_bin5[ant][i-1],
						rt->width_list_bin5[ant][i],
						rt->width_list_bin5[ant][i-1]));
					}
					rt->fm_list_bin5[ant][i-1] =
					  (rt->fm_list_bin5[ant][i-1] + rt->fm_list_bin5[ant][i]) -
					  FMCOMBINEOFFSET;
					for (j = i; j < mlength - 1; j++) {
						rt->tstart_list_bin5[ant][j] =
							rt->tstart_list_bin5[ant][j+1];
						rt->width_list_bin5[ant][j] =
							rt->width_list_bin5[ant][j+1];
						rt->fm_list_bin5[ant][j] =
						  rt->fm_list_bin5[ant][j+1];
					}
					mlength--;
					rt->length--;
					/* i--; */
				     }	/* if deltat */
			}	/* for mlength loop */
		}	/* mlength > 1 */
	    }
	  } /* for ant loop */

	/* Now combine, sort, and remove duplicated pulses from the each antenna */
	rt->length = 0;
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
		for (i = 0; i < rt->nphy_length_bin5[ant]; i++) {
			rt->tstart_list[rt->length] = rt->tstart_list_bin5[ant][i];
			rt->width_list[rt->length] = rt->width_list_bin5[ant][i];
			rt->fm_list[rt->length] = rt->fm_list_bin5[ant][i];
			rt->length++;
		}
	}

	for (i = 1; i < rt->length; i++) {	/* insertion sort */
		tstart = rt->tstart_list[i];
		width = rt->width_list[i];
		fm = rt->fm_list[i];
		j = i;
		while ((j > 0) && rt->tstart_list[j - 1] > tstart) {
			rt->tstart_list[j] = rt->tstart_list[j - 1];
			rt->width_list[j] = rt->width_list[j - 1];
			rt->fm_list[j] = rt->fm_list[j - 1];
			j--;
		}
		rt->tstart_list[j] = tstart;
		rt->width_list[j] = width;
		rt->fm_list[j] = fm;
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 0) { /* bin5 */
			if ((rt->length > 0))  {
			PHY_RADAR(("\nBin5 after combining pulses from two antennas"));
			PHY_RADAR(("\n%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));

			PHY_RADAR(("\nPulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
			}
		}
	}
#endif /* BCMDBG */

	/* Should be done only for 2 chain cases */
	/* Combine pulses that are adjacent among 2 antennas */
	if (GET_RDR_NANTENNAS(pi) == 2) {
		for (k = 0; k < 1; k++) {
		mlength = rt->length;
		if (mlength > 1) {
			for (i = 1; i < mlength; i++) {
				deltat = ABS((int32)(rt->tstart_list[i] -
					rt->tstart_list[i-1]));

				if (deltat <= (int32)rparams->radar_args.max_pw_lp) {
					rt->width_list[i-1] = deltat + rt->width_list[i];
					/* print pulse combining debug messages */
					if (0) {
						PHY_RADAR(("*%d,%d,%d ",
						rt->tstart_list[i] -
						rt->tstart_list[i-1],
						rt->width_list[i],
						rt->width_list[i-1]));
					}

					rt->fm_list[i-1] = rt->fm_list[i-1] +
						rt->fm_list[i]-FMCOMBINEOFFSET;
					for (j = i; j < mlength - 1; j++) {
						rt->tstart_list[j] =
							rt->tstart_list[j+1];
						rt->width_list[j] =
							rt->width_list[j+1];
						rt->fm_list[j] = rt->fm_list[j+1];
					}
					mlength--;
					rt->length--;
				}	/* if deltat */
			}	/* for mlength loop */
		}	/* mlength > 1 */
	    }
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 0) { /* bin5 */
			if ((rt->length > 0))  {
			PHY_RADAR(("\nBin5 after combining pulses that are adjcent"));
			PHY_RADAR(("\n%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));

			PHY_RADAR(("\nPulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
			}
		}
	}
#endif /* BCMDBG */

	/* remove pulses that are spaced < quant (128/256) */
	for (i = 1; i < rt->length; i++) {
		deltat = ABS((int32)(rt->tstart_list[i] - rt->tstart_list[i-1]));
		if (deltat < 128) {
			for (j = i - 1; j < (rt->length); j++) {
				rt->tstart_list[j] = rt->tstart_list[j+1];
				rt->width_list[j] = rt->width_list[j+1];
				rt->fm_list[j] = rt->fm_list[j+1];
			}
			rt->length--;
		}
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 0) {
			if ((rt->length > 0))  { /* bin5 */
			PHY_RADAR(("\nBin5 after removing pulses that are spaced < %d\n",
				rparams->radar_args.quant));
			PHY_RADAR(("%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));
			PHY_RADAR(("\n"));

			PHY_RADAR(("Pulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));
			PHY_RADAR(("\n"));

			PHY_RADAR(("FM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
			}
		}
	}
#endif /* BCMDBG */

	/* prune lp buffer */
	/* remove any entry outside the time max delta_t_lp */
	if (rt->lp_length > 1) {
		deltat = ABS((int32)(rt->lp_buffer[rt->lp_length - 1] - rt->lp_buffer[0]));
		i = 0;
		while ((i < (rt->lp_length - 1)) &&
			(deltat > (int32)max_lp_buffer_span)) {
			i++;
			deltat = ABS((int32)(rt->lp_buffer[rt->lp_length - 1] - rt->lp_buffer[i]));
		}

		if (i > 0) {
			for (j = i; j < rt->lp_length; j++)
				rt->lp_buffer[j-i] = rt->lp_buffer[j];

			rt->lp_length -= i;
		}
	}
	/* First perform FCC-5 detection */
	/* add new pulses */

	/* process each new pulse */
	for (i = 0; i < rt->length; i++) {
		deltat = ABS((int32)(rt->tstart_list[i] - rt->last_tstart));
		salvate_intv = ABS((int32) (rt->tstart_list[i] - rt->last_skipped_time));
		valid_lp = (rt->width_list[i] >= rparams->radar_args.min_pw_lp) &&
			(rt->width_list[i] <= rparams->radar_args.max_pw_lp) &&
			(rt->fm_list[i] >= rparams->radar_args.min_fm_lp) &&
			(deltat >= rparams->radar_args.max_pw_lp);

		/* filter out: max_deltat_l < pburst_intv_lp < min_burst_intv_lp */
		/* this was skip-type = 2, now not skipping for this */
		valid_lp = valid_lp &&(deltat <= (int32) rparams->max_deltat_lp ||
			deltat >= (int32) rparams->radar_args.min_burst_intv_lp);
		if ((salvate_intv > (int32) rparams->max_deltat_lp &&
			salvate_intv < (int32) rparams->radar_args.min_burst_intv_lp)) {
			valid_lp = FALSE;
		}

		if (rt->lp_length > 0 && rt->lp_length < LP_BUFFER_SIZE) {
			valid_lp = valid_lp &&
				(rt->tstart_list[i] != rt->lp_buffer[rt->lp_length]);
		}

		skip_type = 0;
		if (valid_lp && deltat
			>= (int32) rparams->radar_args.min_burst_intv_lp &&
			deltat < (int32) rparams->radar_args.max_burst_intv_lp) {
			rt->lp_cnt = 0;
		}

		/* skip the pulse if outside of pulse interval range (1-2ms), */
		/* burst to burst interval not within range, more than 3 pulses in a */
		/* burst, and not skip salvated */

		if ((valid_lp && ((rt->lp_length != 0)) &&
			((deltat < (int32) rparams->min_deltat_lp) ||
			(deltat > (int32) rparams->max_deltat_lp &&
			deltat < (int32) rparams->radar_args.min_burst_intv_lp) ||
			(deltat > (int32) rparams->radar_args.max_burst_intv_lp) ||
			(rt->lp_cnt > 2)))) {	/* possible skip lp */

			/* get skip type */
			if (deltat < (int32) rparams->min_deltat_lp) {
				skip_type = 1;
			} else if (deltat > (int32) rparams->max_deltat_lp &&
				deltat < (int32) rparams->radar_args.min_burst_intv_lp) {
				skip_type = 2;
			} else if (deltat > (int32) rparams->radar_args.max_burst_intv_lp) {
				skip_type = 3;
				rt->lp_cnt = 0;
			} else if (rt->lp_cnt > 2) {
				skip_type = 4;
			} else {
				skip_type = 999;
			}

			/* skip_salvate */
			if (((salvate_intv > (int32) rparams->min_deltat_lp &&
				salvate_intv < (int32) rparams->max_deltat_lp)) ||
				((salvate_intv > (int32)rparams->radar_args.min_burst_intv_lp) &&
				(salvate_intv < (int32)rparams->radar_args.max_burst_intv_lp))) {
				/* note valid_lp is not reset in here */
				skip_type = -1;  /* salvated PASSED */
				if (salvate_intv >= (int32) rparams->radar_args.min_burst_intv_lp &&
					salvate_intv <
						(int32) rparams->radar_args.max_burst_intv_lp) {
					rt->lp_cnt = 0;
				}
			}
		} else {  /* valid lp not by skip salvate */
				skip_type = -2;
		}

		width = 0;
		fm = 0;
		pw_dif = 0;
		fm_dif = 0;
		pw_tol = rparams->radar_args.max_span_lp & 0xff;
		fm_tol = 0;
		/* monitor the number of pw and fm matching */
		/* max_span_lp[15:12] = skip_tot max */
		/* max_span_lp[11:8] = x, x/16 = % alowed fm tollerance */
		/* max_span_lp[7:0] = alowed pw tollerance */
		if (valid_lp && skip_type <= 0) {
			if (rt->lp_cnt == 0) {
				rt->lp_pw[0] = rt->width_list[i];
				rt->lp_fm[0] = rt->fm_list[i];
			} else if (rt->lp_cnt == 1) {
				width = rt->lp_pw[0];
				fm = rt->lp_fm[0];
				pw_dif = ABS(rt->width_list[i] - width);
				fm_dif = ABS(rt->fm_list[i] - fm);
				if (rparams->radar_args.t2_min & 0x200) {
					fm_tol = (fm*((rparams->radar_args.max_span_lp >> 8)
						& 0xf))/16;
				} else {
					fm_tol = 999;
				}
				if (pw_dif < pw_tol && fm_dif < fm_tol) {
					rt->lp_pw[1] = rt->width_list[i];
					rt->lp_fm[1] = rt->fm_list[i];
					++rt->lp_n_non_single_pulses;
					++rt->lp_pw_fm_matched;
				} else if (rt->lp_just_skipped) {
					width = rt->lp_skipped_pw;
					fm = rt->lp_skipped_fm;
					pw_dif = ABS(rt->width_list[i] - width);
					fm_dif = ABS(rt->fm_list[i] - fm);
					if (rparams->radar_args.t2_min & 0x200) {
						fm_tol = (fm*((rparams->radar_args.max_span_lp >> 8)
							& 0xf))/16;
					} else {
						fm_tol = 999;
					}
					if (pw_dif < pw_tol && fm_dif < fm_tol) {
						rt->lp_pw[1] = rt->width_list[i];
						rt->lp_fm[1] = rt->fm_list[i];
						++rt->lp_n_non_single_pulses;
						++rt->lp_pw_fm_matched;
						skip_type = -1;  /* salvated PASSED */
					} else {
						if (rparams->radar_args.t2_min & 0x100) {
							skip_type = 5;
						}
					}
				} else {
					if (rparams->radar_args.t2_min & 0x100) {
						skip_type = 5;
					}
				}
			} else if (rt->lp_cnt == 2) {
				width = rt->lp_pw[1];
				fm = rt->lp_fm[1];
				pw_dif = ABS(rt->width_list[i] - width);
				fm_dif = ABS(rt->fm_list[i] - fm);
				if (rparams->radar_args.t2_min & 0x200) {
					fm_tol = (fm*((rparams->radar_args.max_span_lp >> 8)
						& 0xf))/16;
				} else {
					fm_tol = 999;
				}
				if (pw_dif < pw_tol && fm_dif < fm_tol) {
					rt->lp_pw[2] = rt->width_list[i];
					rt->lp_fm[2] = rt->fm_list[i];
					++rt->lp_n_non_single_pulses;
					++rt->lp_pw_fm_matched;
				} else if (rt->lp_just_skipped) {
					width = rt->lp_skipped_pw;
					fm = rt->lp_skipped_fm;
					pw_dif = ABS(rt->width_list[i] - width);
					fm_dif = ABS(rt->fm_list[i] - fm);
					if (rparams->radar_args.t2_min & 0x200) {
						fm_tol = (fm*((rparams->radar_args.max_span_lp >> 8)
							& 0xf))/16;
					} else {
						fm_tol = 999;
					}
					if (pw_dif < pw_tol && fm_dif < fm_tol) {
						rt->lp_pw[2] = rt->width_list[i];
						rt->lp_fm[2] = rt->fm_list[i];
						++rt->lp_n_non_single_pulses;
						++rt->lp_pw_fm_matched;
						skip_type = -1;  /* salvated PASSED */
					} else {
						if (rparams->radar_args.t2_min & 0x100) {
							skip_type = 5;
						}
					}
				} else {
					if (rparams->radar_args.t2_min & 0x100) {
						skip_type = 5;
					}
				}
			}
		}

		if (valid_lp && skip_type != -1 && skip_type != -2) {	/* skipped lp */
			valid_lp = FALSE;
			rt->lp_skip_cnt++;
			rt->lp_skip_tot++;
			rt->lp_just_skipped = TRUE;
			rt->lp_skipped_pw = rt->width_list[i];
			rt->lp_skipped_fm = rt->fm_list[i];

			tmp_uint32 = rt->last_skipped_time;
			rt->last_skipped_time = rt->tstart_list[i];

#ifdef BCMDBG
			/* print "SKIPPED LP" debug messages */
			PHY_RADAR(("Skipped LP:"
/*
				" KTstart=%u Klast_ts=%u Klskip=%u"
*/
				" nLP=%d nSKIP=%d KIntv=%u"
				" Ksalintv=%d PW=%d FM=%d"
				" Type=%d pulse#=%d skip_tot=%d csect_single=%d\n",
/*
			(rt->tstart_list[i])/1000, rt->last_tstart/1000, tmp_uint32/1000,
*/
				rt->lp_length, rt->lp_skip_cnt, deltat/1000, salvate_intv/1000,
				rt->width_list[i], rt->fm_list[i],
				skip_type, rt->lp_cnt, rt->lp_skip_tot, rt->lp_csect_single));
			if (skip_type == 5) {
				PHY_RADAR(("           "
					" pw2=%d pw_dif=%d pw_tol=%d fm2=%d fm_dif=%d fm_tol=%d\n",
					width, pw_dif, pw_tol, fm, fm_dif, fm_tol));
			}
			if (skip_type == 999) {
				PHY_RADAR(("UNKOWN SKIP TYPE: %d\n", skip_type));
			}
#endif /* BCMDBG */

			/* if a) 2 consecutive skips, or */
			/*    b) too many consective singles, or */
			/*    c) too many total skip so far */
			/*  then reset lp buffer ... */
			if (rt->lp_skip_cnt >= rparams->radar_args.nskip_rst_lp) {
				if (rt->lp_len_his_idx < LP_LEN_HIS_SIZE) {
					rt->lp_len_his[rt->lp_len_his_idx] = rt->lp_length;
					rt->lp_len_his_idx++;
				}
				rt->lp_length = 0;
				rt->lp_skip_tot = 0;
				rt->lp_skip_cnt = 0;
				rt->lp_csect_single = 0;
				rt->lp_pw_fm_matched = 0;
				rt->lp_n_non_single_pulses = 0;
				rt->lp_cnt = 0;
			}
		} else if (valid_lp && (rt->lp_length < LP_BUFFER_SIZE)) {	/* valid lp */
			/* reset consecutive singles counter if pulse # > 0 */
			if (rt->lp_cnt > 0) {
				rt->lp_csect_single = 0;
			} else {
				++rt->lp_csect_single;
			}

			rt->lp_just_skipped = FALSE;
			/* print "VALID LP" debug messages */
			rt->lp_skip_cnt = 0;
			PHY_RADAR(("Valid LP:"
/*
				" KTstart=%u KTlast_ts=%u Klskip=%u"
*/
				" KIntv=%u"
				" Ksalintv=%d PW=%d FM=%d pulse#=%d"
				" pw2=%d pw_dif=%d pw_tol=%d fm2=%d fm_dif=%d fm_tol=%d\n",
/*
				(rt->tstart_list[i])/1000, rt->last_tstart/1000,
					rt->last_skipped_time/1000,
*/
				deltat/1000, salvate_intv/1000,
				rt->width_list[i], rt->fm_list[i], rt->lp_cnt,
				width, pw_dif, pw_tol,
				fm, fm_dif, fm_tol));
			PHY_RADAR(("         "
				" nLP=%d nSKIP=%d skipped_salvate=%d"
				" pw_fm_matched=%d #non-single=%d skip_tot=%d csect_single=%d\n",
				rt->lp_length + 1, rt->lp_skip_cnt, (skip_type == -1 ? 1 : 0),
				rt->lp_pw_fm_matched,
				rt->lp_n_non_single_pulses, rt->lp_skip_tot, rt->lp_csect_single));

				rt->lp_buffer[rt->lp_length] = rt->tstart_list[i];
				rt->lp_length++;
				rt->last_tstart = rt->tstart_list[i];
				rt->last_skipped_time = rt->tstart_list[i];

				rt->lp_cnt++;

			if (rt->lp_csect_single >= ((rparams->radar_args.t2_min >> 12) & 0xf)) {
				if (rt->lp_length > rparams->radar_args.npulses_lp / 2)
					rt->lp_length -= rparams->radar_args.npulses_lp / 2;
				else
					rt->lp_length = 0;
			}
		}
	}

	if (rt->lp_length > LP_BUFFER_SIZE)
		PHY_ERROR(("WARNING: LP buffer size is too long\n"));

#ifdef RADAR_DBG
	PHY_RADAR(("\n FCC-5 \n"));
	for (i = 0; i < rt->lp_length; i++) {
		PHY_RADAR(("%u  ", rt->lp_buffer[i]));
	}
	PHY_RADAR(("\n"));
#endif // endif
	if (rt->lp_length >= rparams->radar_args.npulses_lp) {
		/* reject detection spaced more than 3 minutes */
		deltat2 = (uint32) (pi->sh->now - rt->last_detection_time_lp);
		PHY_RADAR(("last_detection_time_lp=%u, watchdog_timer=%u, deltat2=%d,"
			" deltat2_min=%d, deltat2_sec=%d\n",
			rt->last_detection_time_lp, pi->sh->now, deltat2, deltat2/60, deltat2%60));
		rt->last_detection_time_lp = pi->sh->now;
		tmp_uint32 = RADAR_TYPE_NONE;
		if ((uint32) deltat2 < (rparams->radar_args.fra_pulse_err & 0xff)*60 ||
			(pi->ri->first_radar_indicator == 1 && (uint32) deltat2 < 30*60)) {
			if (rt->lp_csect_single <= rparams->radar_args.npulses_lp - 2 &&
				rt->lp_skip_tot < ((rparams->radar_args.max_span_lp >> 12) & 0xf)) {
				PHY_RADAR(("FCC-5 Radar Detection. Time from last detection"
					" = %u, = %dmin %dsec\n",
					deltat2, deltat2 / 60, deltat2 % 60));

				tmp_uint32 = RADAR_TYPE_FCC_5;
				pi->ri->radar_status.detected = TRUE;
				pi->ri->radar_status.count =
					pi->ri->radar_status.count + 1;
				pi->ri->radar_status.pretended = FALSE;
				pi->ri->radar_status.radartype = tmp_uint32;
				pi->ri->radar_status.timenow = (uint32) (pi->sh->now);
				pi->ri->radar_status.timefromL = deltat2;
				pi->ri->radar_status.ch = pi->radio_chanspec;
				pi->ri->radar_status.lp_csect_single = rt->lp_csect_single;
			}
		}
#ifdef BCMDBG
		else {
			if (rparams->radar_args.feature_mask & 0x4000) {
				PHY_RADAR(("SKIPPED false FCC-5 Radar Detection."
					" Time from last detection = %u, = %dmin %dsec,"
					" ncsect_single=%d\n",
					deltat2, deltat2 / 60, deltat2 % 60, rt->lp_csect_single));
			}
		}
#endif /* BCMDBG */
		if (rt->lp_len_his_idx < LP_LEN_HIS_SIZE) {
			rt->lp_len_his[rt->lp_len_his_idx] = rt->lp_length;
			rt->lp_len_his_idx++;
		}
		rt->lp_length = 0;
		rt->lp_pw_fm_matched = 0;
		rt->lp_n_non_single_pulses = 0;
		rt->lp_skip_tot = 0;
		rt->lp_csect_single = 0;
		pi->ri->first_radar_indicator = 0;
		return tmp_uint32;
	}
	}	/* end of if fcc */
	/*
	 * Reject if no pulses recorded
	 */
	if (GET_RDR_NANTENNAS(pi) == 2) {
	    if (rt->nphy_length[0] < (rparams->radar_args.npulses) &&
	    rt->nphy_length[1] < (rparams->radar_args.npulses)) {
		    return RADAR_TYPE_NONE;
	    }
	} else if (GET_RDR_NANTENNAS(pi) == 1) {
		if (rt->nphy_length[0] < (rparams->radar_args.npulses)) {
			return RADAR_TYPE_NONE;
	    }
	}

	/* START SHORT PULSES (NON-BIN5) DETECTION */
	/* remove "noise" pulses with  pw> 400 and fm<500 */
	if (ISACPHY(pi) && TONEDETECTION) {
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
		wr_ptr = 0;
		mlength = rt->nphy_length[ant];
		for (i = 0; i < rt->nphy_length[ant]; i++) {
		  if (rt->width_list_n[ant][i]  < (rparams->radar_args.st_level_time & 0x0fff) ||
		      rt->fm_list_n[ant][i] > rparams->radar_args.min_fm_lp) {
				rt->tstart_list_n[ant][wr_ptr] = rt->tstart_list_n[ant][i];
				rt->fm_list_n[ant][wr_ptr] = rt->fm_list_n[ant][i];
				rt->width_list_n[ant][wr_ptr] = rt->width_list_n[ant][i];
				++wr_ptr;
			} else {
				mlength--;
			}
		}	/* for mlength loop */
		rt->nphy_length[ant] = mlength;
	}	/* for ant loop */
	}
	/* Combine pulses that are adjacent */
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
		for (k = 0; k < 2; k++) {
			mlength = rt->nphy_length[ant];
			if (mlength > 1) {
			for (i = 1; i < mlength; i++) {
				deltat = ABS((int32)(rt->tstart_list_n[ant][i] -
					rt->tstart_list_n[ant][i-1]));
				if ((deltat < (int32)rparams->radar_args.min_deltat && FALSE) ||
				    (deltat <= (int32)rparams->radar_args.max_pw && TRUE))
				{
					if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) ||
						ISHTPHY(pi) || ISACPHY(pi)) {
						if (((uint32)(rt->tstart_list_n[ant][i] -
							rt->tstart_list_n[ant][i-1]))
							<= (uint32) rparams->radar_args.max_pw) {
							rt->width_list_n[ant][i-1] =
							ABS((int32)(rt->tstart_list_n[ant][i] -
							rt->tstart_list_n[ant][i-1])) +
							rt->width_list_n[ant][i];
						}
					} else {
#ifdef BCMDBG
						/* print pulse combining debug messages */
						PHY_RADAR(("*%d,%d,%d ",
							rt->tstart_list_n[ant][i] -
							rt->tstart_list_n[ant][i-1],
							rt->width_list_n[ant][i],
							rt->width_list_n[ant][i-1]));
#endif // endif
						if (rparams->radar_args.feature_mask & 0x2000) {
							rt->width_list_n[ant][i-1] =
								(rt->width_list_n[ant][i-1] >
								rt->width_list_n[ant][i] ?
								rt->width_list_n[ant][i-1] :
								rt->width_list_n[ant][i]);
						} else {
							rt->width_list_n[ant][i-1] =
								rt->width_list_n[ant][i-1] +
								rt->width_list_n[ant][i];
						}
					}

					/* Combine fm */
					if (ISACPHY(pi) && TONEDETECTION) {
						rt->fm_list_n[ant][i-1] = (rt->fm_list_n[ant][i-1] >
							rt->fm_list_n[ant][i] ?
							rt->fm_list_n[ant][i-1] :
							rt->fm_list_n[ant][i]);
					} else {
						rt->fm_list_n[ant][i-1] = rt->fm_list_n[ant][i-1] +
							rt->fm_list_n[ant][i];
					}

					for (j = i; j < mlength - 1; j++) {
						rt->tstart_list_n[ant][j] =
							rt->tstart_list_n[ant][j+1];
						rt->width_list_n[ant][j] =
							rt->width_list_n[ant][j+1];
						rt->fm_list_n[ant][j] =
							rt->fm_list_n[ant][j+1];
					}
					mlength--;
					rt->nphy_length[ant]--;
				}
			} /* for i < mlength */
			} /* mlength > 1 */
		}
	}
#ifdef BCMDBG
	/* output ant0/ant1 fifo data */
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
	    if (rparams->radar_args.feature_mask & 0x8)  {
			if ((rparams->radar_args.feature_mask & 0x1) == 1 &&
				(rt->nphy_length[ant] > 0)) {	/* short pulses */
				PHY_RADAR(("\nShort Pulse After combining adacent pulses"));
				PHY_RADAR(("\nAnt %d: %d pulses, ", ant, rt->nphy_length[ant]));

				PHY_RADAR(("\ntstart0=[  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%u ", rt->tstart_list_n[ant][i]));
				PHY_RADAR(("];"));

				PHY_RADAR(("\nInterval:  "));
				for (i = 1; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d ", rt->tstart_list_n[ant][i] -
						rt->tstart_list_n[ant][i - 1]));

				PHY_RADAR(("\nPulse Widths:  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d-%d ", rt->width_list_n[ant][i], i));

				PHY_RADAR(("\nFM:  "));
				for (i = 0; i < rt->nphy_length[ant]; i++)
					PHY_RADAR(("%d-%d ", rt->fm_list_n[ant][i], i));
				PHY_RADAR(("\n"));

			}
	    }
	}
#endif /* BCMDBG */

	/* Now combine, sort, and remove duplicated pulses from the 2 antennas */
	bzero(rt->tstart_list, sizeof(rt->tstart_list));
	bzero(rt->width_list, sizeof(rt->width_list));
	bzero(rt->fm_list, sizeof(rt->fm_list));
	rt->length = 0;
	for (ant = 0; ant < GET_RDR_NANTENNAS(pi); ant++) {
		for (i = 0; i < rt->nphy_length[ant]; i++) {
			rt->tstart_list[rt->length] = rt->tstart_list_n[ant][i];
			rt->width_list[rt->length] = rt->width_list_n[ant][i];
			rt->fm_list[rt->length] = rt->fm_list_n[ant][i];
			rt->length++;
		}
	}

	for (i = 1; i < rt->length; i++) {	/* insertion sort */
		tstart = rt->tstart_list[i];
		width = rt->width_list[i];
		fm = rt->fm_list[i];
		j = i;
		while ((j > 0) && rt->tstart_list[j - 1] > tstart) {
			rt->tstart_list[j] = rt->tstart_list[j - 1];
			rt->width_list[j] = rt->width_list[j - 1];
			rt->fm_list[j] = rt->fm_list[j - 1];
			j--;
		}
		rt->tstart_list[j] = tstart;
		rt->width_list[j] = width;
		rt->fm_list[j] = fm;
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 1 &&
			(rt->length > 0)) {	/* short pulses */
			PHY_RADAR(("\nShort pulses after combining pulses from two antennas"));
			PHY_RADAR(("\n%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart0=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));

			PHY_RADAR(("\nPulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
		}
	}
#endif /* BCMDBG */

	/* Should be done only for 2 chain cases */
	if (GET_RDR_NANTENNAS(pi) == 2) {
		for (k = 0; k < 1; k++) {
			mlength = rt->length;
			if (mlength > 1) {
				for (i = 1; i < mlength; i++) {
					deltat = ABS((int32)(rt->tstart_list[i] -
						rt->tstart_list[i-1]));
					if ((deltat < (int32)rparams->radar_args.min_deltat &&
					FALSE) ||
					(deltat <= (int32)rparams->radar_args.max_pw &&
					TRUE)) {
						if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) ||
							ISHTPHY(pi) || ISACPHY(pi)) {
							if (((uint32)(rt->tstart_list[i] -
							rt->tstart_list[i-1]))
							<= (uint32) rparams->radar_args.max_pw) {
								rt->width_list[i-1] =
								ABS((int32)(rt->tstart_list[i] -
								rt->tstart_list[i-1])) +
								rt->width_list[i];
							}
						} else {
							if (rparams->radar_args.feature_mask &
								0x2000) {
								rt->width_list[i-1] =
									(rt->width_list[i-1] >
									rt->width_list[i]) ?
									rt->width_list[i-1] :
									rt->width_list[i];
							} else {
								rt->width_list[i-1] =
									rt->width_list[i-1] +
									rt->width_list[i];
							}
						}
						/* Combine fm */
						if (ISACPHY(pi) && TONEDETECTION) {
							rt->fm_list[i-1] =
								(rt->fm_list[i-1] > rt->fm_list[i] ?
								rt->fm_list[i-1] : rt->fm_list[i]);
						} else {
							rt->fm_list[i-1] =
								rt->fm_list[i-1] + rt->fm_list[i];
						}

						for (j = i; j < mlength - 1; j++) {
							rt->tstart_list[j] =
								rt->tstart_list[j+1];
							rt->width_list[j] =
								rt->width_list[j+1];
							rt->fm_list[j] =
								rt->fm_list[j+1];
						}
						mlength--;
						rt->length--;
					}
				}
			}
		}
	}

	/* remove pulses spaced less than min_deltat */
	for (i = 1; i < rt->length; i++) {
		deltat = (int32)(rt->tstart_list[i] - rt->tstart_list[i-1]);
		if (deltat < (int32)rparams->radar_args.min_deltat) {
			for (j = i; j < (rt->length - 1); j++) {
				rt->tstart_list[j] = rt->tstart_list[j+1];
				rt->width_list[j] = rt->width_list[j+1];
				rt->fm_list[j] = rt->fm_list[j+1];
			}
			rt->length--;
		}
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 1 &&
			(rt->length > 0)) {	/* short pulses */
			PHY_RADAR(("\nShort pulses after removing pulses that are"
				" space > min_deltat (1ms)\n"));
			PHY_RADAR(("%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart0=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];\n"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));
			PHY_RADAR(("\n"));

			PHY_RADAR(("Pulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
		}
	}
#endif /* BCMDBG */

	/* remove entries spaced greater than max_deltat */
	if (rt->length > 1) {
		deltat = ABS((int32)(rt->tstart_list[rt->length - 1] - rt->tstart_list[0]));
		i = 0;
		while ((i < (rt->length - 1)) &&
		       (ABS(deltat) > (int32)rparams->radar_args.max_deltat)) {
			i++;
			deltat = ABS((int32)(rt->tstart_list[rt->length - 1] - rt->tstart_list[i]));
		}
		if (i > 0) {
			for (j = i; j < rt->length; j++) {
				rt->tstart_list[j-i] = rt->tstart_list[j];
				rt->width_list[j-i] = rt->width_list[j];
				rt->fm_list[j-1] = rt->fm_list[j];
			}
			rt->length -= i;
		}
	}

	/*
	 * filter based on pulse width
	 */
	if (filter_pw) {
		j = 0;
		for (i = 0; i < rt->length; i++) {
			if ((rt->width_list[i] >= rparams->radar_args.min_pw) &&
				(rt->width_list[i] <= rparams->radar_args.max_pw)) {
				rt->width_list[j] = rt->width_list[i];
				rt->tstart_list[j] = rt->tstart_list[i];
				rt->fm_list[j] = rt->fm_list[i];
				j++;
			}
		}
		rt->length = j;
	}
	if (ISACPHY(pi) && TONEDETECTION) {
	if (filter_fm) {
		j = 0;
		for (i = 0; i < rt->length; i++) {
			if (rt->fm_list[i] >=
				(ACMAJORREV_5(pi->pubpi.phy_rev) ? 0 : -50)) {
				rt->width_list[j] = rt->width_list[i];
				rt->tstart_list[j] = rt->tstart_list[i];
				rt->fm_list[j] = rt->fm_list[i];
				j++;
			}
		}
		rt->length = j;
	}
	}

#ifdef BCMDBG
	/* output fifo data */
	if (rparams->radar_args.feature_mask & 0x8)  {
		if ((rparams->radar_args.feature_mask & 0x1) == 1 &&
			(rt->length > 0)) {	/* short pulses */
			PHY_RADAR(("\nShort pulses after removing pulses that are"
				" space < max_deltat (150ms)\n"));
			PHY_RADAR(("%d pulses, ", rt->length));

			PHY_RADAR(("\ntstart0=[  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
			PHY_RADAR(("];\n"));

			PHY_RADAR(("\nInterval:  "));
			for (i = 1; i < rt->length; i++)
				PHY_RADAR(("%d ", rt->tstart_list[i] -
					rt->tstart_list[i - 1]));
			PHY_RADAR(("\n"));

			PHY_RADAR(("Pulse Widths:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->width_list[i], i));

			PHY_RADAR(("\nFM:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
			PHY_RADAR(("\n"));
		}
	}
#endif /* BCMDBG */

	if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi) ||
		ISACPHY(pi)) { /* nphy rev >= 3 */
/*
		ASSERT(rt->length <= RDR_NANTENNAS * RDR_LIST_SIZE);
*/
		if (rt->length > RDR_NANTENNAS * RDR_LIST_SIZE) {
			rt->length = RDR_NANTENNAS * RDR_LIST_SIZE;
			PHY_RADAR(("WARNING: radar rt->length=%d > list_size=%d\n",
				rt->length, RDR_NANTENNAS * RDR_LIST_SIZE));
		}
	} else {
/*
		ASSERT(rt->length <= RDR_LIST_SIZE);
*/
		if (rt->length > RDR_LIST_SIZE) {
			rt->length = RDR_LIST_SIZE;
			PHY_RADAR(("WARNING: radar rt->length = %d > RDR_LIST_SIZE = %d\n",
				rt->length, RDR_LIST_SIZE));
		}
	}

	/*
	 * Break pulses into epochs.
	 */
	rt->nepochs = 1;
	rt->epoch_start[0] = 0;
	for (i = 1; i < rt->length; i++) {
		if ((int32)(rt->tstart_list[i] - rt->tstart_list[i-1]) > rparams->max_blen) {
			rt->epoch_finish[rt->nepochs-1] = i - 1;
			rt->epoch_start[rt->nepochs] = i;
			rt->nepochs++;
		}
		if (rt->nepochs >= RDR_EPOCH_SIZE) {
			if (rparams->radar_args.feature_mask & 0x100) {
				PHY_RADAR(("WARNING: number of epochs %d > epoch size = %d\n",
					rt->nepochs, RDR_EPOCH_SIZE));
			}
			break;
		}
	}
	rt->epoch_finish[rt->nepochs - 1] = i;

	det_type = 0;

	/*
	 * Run the detector for each epoch
	 */
	for (i = 0; i < rt->nepochs && (pulse_interval == 0) && (det_type == 0); i++) {

		/*
		 * Generate 0th order tier list (time delta between received pulses)
		 * Quantize and filter delta pulse times delta pulse times are
		 * returned in sorted order from smallest to largest.
		 */
		epoch_list = rt->tstart_list + rt->epoch_start[i];
		epoch_length = (rt->epoch_finish[i] - rt->epoch_start[i] + 1);
		if (epoch_length > RDR_NTIER_SIZE) {
			if (rparams->radar_args.feature_mask & 0x100) {
				PHY_RADAR(("WARNING: DFS epoch_length=%d > TIER_SIZE=%d!!\n",
					epoch_length, RDR_NTIER_SIZE));
			}
			epoch_length = RDR_NTIER_SIZE;
		}

		wlc_phy_radar_detect_run_epoch(pi, i, rt, rparams, epoch_list, epoch_length,
			pw_2us, pw15us, pw20us, pw30us,
			i250us, i500us, i625us, i5000us,
			pw2us, i833us, i2500us, i3333us,
			i938us, i3066us,
			&det_type, &pulse_interval,
			&nconsecq_pulses, &detected_pulse_index,
			&min_detected_pw, &max_detected_pw,
			&fm_min, &fm_max);
	}

#ifdef BCMDBG
	if (rparams->radar_args.feature_mask & 0x2) {
		/*	Changed to display intervals instead of tstart
			PHY_RADAR(("Start Time:  "));
			for (i = 0; i < rt->length; i++)
				PHY_RADAR(("%u ", rt->tstart_list[i]));
		*/
		PHY_RADAR(("\nShort pulses before pruning (filtering)"));
		PHY_RADAR(("\nInterval:  "));
		for (i = 1; i < rt->length; i++)
			PHY_RADAR(("%d-%d ", rt->tstart_list[i] - rt->tstart_list[i - 1], i));
		PHY_RADAR(("\n"));

		PHY_RADAR(("Pulse Widths:  "));
		for (i = 0; i < rt->length; i++)
			PHY_RADAR(("%d-%d ", rt->width_list[i], i));
		PHY_RADAR(("\n"));

		PHY_RADAR(("FM:  "));
		for (i = 0; i < rt->length; i++)
			PHY_RADAR(("%d-%d ", rt->fm_list[i], i));
		PHY_RADAR(("\n"));
	}

	if (rparams->radar_args.feature_mask & 0x80) {
		PHY_RADAR(("\nShort pulses after pruning (filtering)"));
		PHY_RADAR(("\nPruned Intv: "));
		for (i = 0; i < epoch_length-2; i++)
			PHY_RADAR(("%d-%d ", rt->tiern_list[0][i], i));
		PHY_RADAR(("\n"));

		PHY_RADAR(("Pruned PW:  "));
		for (i = 0; i <  epoch_length-1; i++)
			PHY_RADAR(("%d-%d ", rt->tiern_pw[0][i], i));
		PHY_RADAR(("\n"));

		PHY_RADAR(("Pruned FM:  "));
		for (i = 0; i <  epoch_length-1; i++)
			PHY_RADAR(("%d-%d ", rt->tiern_fm[0][i], i));
		PHY_RADAR(("\n"));
		PHY_RADAR(("nconsecq_pulses=%d max_pw_delta=%d min_pw=%d max_pw=%d \n",
			nconsecq_pulses, max_detected_pw - min_detected_pw, min_detected_pw,
			max_detected_pw));
	}
#endif /* BCMDBG */

	epoch_detected = i;

	if (pulse_interval || det_type != 0) {
		bzero(pi->ri->radar_status.intv, sizeof(pi->ri->radar_status.intv));
		bzero(pi->ri->radar_status.pw, sizeof(pi->ri->radar_status.pw));
		bzero(pi->ri->radar_status.fm, sizeof(pi->ri->radar_status.fm));

		BCM_REFERENCE(epoch_detected);
		PHY_RADAR(("\nPruned Intv: "));
		for (i = 0; i < epoch_length-1; i++) {
			PHY_RADAR(("%d-%d ", rt->tiern_list[0][i], i));
			if (i >= detected_pulse_index && i < detected_pulse_index + 10) {
				pi->ri->radar_status.intv[i - detected_pulse_index] =
					rt->tiern_list[0][i];
			}
		}
		PHY_RADAR(("\n"));

		PHY_RADAR(("Pruned PW:  "));
		for (i = 0; i <  epoch_length-1; i++) {
			PHY_RADAR(("%i-%d ", rt->tiern_pw[0][i], i));
			if (i >= detected_pulse_index && i < detected_pulse_index + 10) {
				pi->ri->radar_status.pw[i - detected_pulse_index] =
					rt->tiern_pw[0][i];
			}
		}
		PHY_RADAR(("\n"));

		PHY_RADAR(("Pruned FM:  "));
		for (i = 0; i <  epoch_length-1; i++) {
			PHY_RADAR(("%i-%d ", rt->tiern_fm[0][i], i));
			if (i >= detected_pulse_index && i < detected_pulse_index + 10) {
				pi->ri->radar_status.fm[i - detected_pulse_index] =
					rt->tiern_fm[0][i];
			}
		}
		PHY_RADAR(("\n"));

		PHY_RADAR(("Nepochs=%d len=%d epoch_#=%d; det_idx=%d "
				"pw_delta=%d min_pw=%d max_pw=%d \n",
				rt->nepochs, epoch_length, epoch_detected, detected_pulse_index,
				max_detected_pw - min_detected_pw, min_detected_pw,
				max_detected_pw));

		deltat2 = (uint32) (pi->sh->now - rt->last_detection_time);
		/* detection not valid if detected pulse index too large */
		if (detected_pulse_index < ((rparams->radar_args.ncontig) & 0x3f) -
			rparams->radar_args.npulses) {
			rt->last_detection_time = pi->sh->now;
		}
		/* reject detection spaced more than 3 minutes and detected pulse index too larg */
		if (((uint32) deltat2 < (rparams->radar_args.fra_pulse_err & 0xff)*60 ||
			(pi->ri->first_radar_indicator == 1 && (uint32) deltat2 < 30*60)) &&
			(detected_pulse_index <
			((rparams->radar_args.ncontig) & 0x3f)
			- rparams->radar_args.npulses)) {
			PHY_RADAR(("Type %d Radar Detection. Detected pulse index=%d"
				" fm_min=%d fm_max=%d nconsecq_pulses=%d."
				" Time from last detection = %u, = %dmin %dsec \n",
				det_type, detected_pulse_index, fm_min, fm_max, nconsecq_pulses,
				deltat2, deltat2 / 60, deltat2 % 60));
			pi->ri->radar_status.detected = TRUE;
			pi->ri->radar_status.count = pi->ri->radar_status.count + 1;
			pi->ri->radar_status.pretended = FALSE;
			pi->ri->radar_status.radartype = det_type;
			pi->ri->radar_status.timenow = (uint32) pi->sh->now;
			pi->ri->radar_status.timefromL = (uint32) deltat2;
			pi->ri->radar_status.detected_pulse_index =  detected_pulse_index;
			pi->ri->radar_status.nconsecq_pulses = nconsecq_pulses;
			pi->ri->radar_status.ch = pi->radio_chanspec;
			pi->ri->first_radar_indicator = 0;
			return (det_type + (min_detected_pw << 4) +  (pulse_interval << 14));
		} else {
			if (rparams->radar_args.feature_mask & 0x4000) {
				PHY_RADAR(("SKIPPED false Type %d Radar Detection."
					" min_pw=%d pw_delta=%d pri=%d"
					" fm_min=%d fm_max=%d nconsecq_pulses=%d. Time from last"
					" detection = %u, = %dmin %dsec",
					det_type, min_detected_pw,
					max_detected_pw - max_detected_pw,
					pulse_interval, fm_min, fm_max, nconsecq_pulses, deltat2,
					deltat2 / 60, deltat2 % 60));
				if (detected_pulse_index < ((rparams->radar_args.ncontig) & 0x3f) -
					rparams->radar_args.npulses)
					PHY_RADAR((". Detected pulse index: %d\n",
						detected_pulse_index));
				else
					PHY_ERROR((". Detected pulse index too high: %d\n",
						detected_pulse_index));
			}
			return (RADAR_TYPE_NONE);
		}
	}
	return (RADAR_TYPE_NONE);
}
#endif /* #if defined(AP) && defined(RADAR) */

/* Increase the loop bandwidth of the PLL in the demodulator.
 * Note that although this allows the demodulator to track the
 * received carrier frequency over a wider bandwidth, it may
 * cause the Rx sensitivity to decrease
 */
void
wlc_phy_freqtrack_start(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (!ISGPHY(pi))
		return;

	wlc_phyreg_enter((wlc_phy_t*)pi);

	PHY_REG_LIST_START
		PHY_REG_WRITE_RAW_ENTRY(BPHY_COEFFS, 0xFFEA)
		PHY_REG_WRITE_RAW_ENTRY(BPHY_STEP, 0x0689)
	PHY_REG_LIST_EXECUTE(pi);

	wlc_phyreg_exit((wlc_phy_t*)pi);
}

/* Restore the loop bandwidth of the PLL in the demodulator to the original value */
void
wlc_phy_freqtrack_end(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (!ISGPHY(pi))
		return;

	wlc_phyreg_enter((wlc_phy_t*)pi);

	/* Restore the original values of the PHY registers */
	phy_reg_write(pi, BPHY_COEFFS, pi->freqtrack_saved_regs[0]);
	phy_reg_write(pi, BPHY_STEP, pi->freqtrack_saved_regs[1]);

	wlc_phyreg_exit((wlc_phy_t*)pi);
}

/* VCO calibration proc for 4318 */
static void
wlc_phy_vco_cal(phy_info_t *pi)
{
	/* check D11 is running on Fast Clock */
	if (D11REV_GE(pi->sh->corerev, 5))
		ASSERT(si_core_sflags(pi->sh->sih, 0, 0) & SISF_FCLKA);

	if ((RADIOID(pi->pubpi.radioid) == BCM2050_ID) &&
	    (RADIOREV(pi->pubpi.radiorev) == 8)) {
		chanspec_t old_chanspec = pi->radio_chanspec;
		wlc_phy_chanspec_set((wlc_phy_t*)pi, CHSPEC_CHANNEL(pi->radio_chanspec) > 7 ?
		CH20MHZ_CHSPEC(1) : CH20MHZ_CHSPEC(13));
		wlc_phy_chanspec_set((wlc_phy_t*)pi, old_chanspec);
	}
}

void
wlc_phy_set_deaf(wlc_phy_t *ppi, bool user_flag)
{
	phy_info_t *pi;
	pi = (phy_info_t*)ppi;

	if (ISLPPHY(pi))
		wlc_phy_set_deaf_lpphy(pi, (bool)1);
	else if (ISSSLPNPHY(pi))
		wlc_sslpnphy_deaf_mode(pi, TRUE);
	else if (ISLCNPHY(pi))
		wlc_lcnphy_deaf_mode(pi, TRUE);
	else if (ISLCN40PHY(pi)) {
		/* Before being deaf, Force digi_gain to 0dB */
		uint16 save_digi_gain_ovr_val;
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;

		save_digi_gain_ovr_val =
			PHY_REG_READ(pi, LCN40PHY, radioCtrl, digi_gain_ovr_val);
		pi_lcn40->save_digi_gain_ovr =
			PHY_REG_READ(pi, LCN40PHY, radioCtrl, digi_gain_ovr);
		/* Force digi_gain to 0dB */

		PHY_REG_LIST_START
			PHY_REG_MOD_ENTRY(LCN40PHY, radioCtrl, digi_gain_ovr_val, 0)
			PHY_REG_MOD_ENTRY(LCN40PHY, radioCtrl, digi_gain_ovr, 1)

			PHY_REG_MOD_ENTRY(LCN40PHY, agcControl4, c_agc_fsm_en, 0)
			PHY_REG_MOD_ENTRY(LCN40PHY, agcControl4, c_agc_fsm_en, 1)
		PHY_REG_LIST_EXECUTE(pi);
		OSL_DELAY(2);
		PHY_REG_MOD(pi, LCN40PHY, agcControl4, c_agc_fsm_en, 0);

		wlc_lcn40phy_deaf_mode(pi, TRUE);

		PHY_REG_MOD(pi, LCN40PHY, radioCtrl, digi_gain_ovr_val,
			save_digi_gain_ovr_val);
	} else if (ISNPHY(pi))
		wlc_nphy_deaf_mode(pi, TRUE);
	else if (ISHTPHY(pi))
		wlc_phy_deaf_htphy(pi, TRUE);
	else if (ISACPHY(pi))
		wlc_phy_deaf_acphy(pi, TRUE);
#if (defined(LCN20CONF) && (LCN20CONF != 0))
	else if (ISLCN20PHY(pi))
		wlc_lcn20phy_deaf_mode(pi, TRUE);
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
	else {
		PHY_ERROR(("%s: Not yet supported\n", __FUNCTION__));
		ASSERT(0);
	}
}

void
wlc_phy_clear_deaf(wlc_phy_t  *ppi, bool user_flag)
{
	phy_info_t *pi;
	pi = (phy_info_t*)ppi;

	if (ISLPPHY(pi))
		wlc_phy_clear_deaf_lpphy(pi, (bool)1);
	else if (ISSSLPNPHY(pi))
		wlc_sslpnphy_deaf_mode(pi, FALSE);
	else if (ISLCNPHY(pi))
		wlc_lcnphy_deaf_mode(pi, FALSE);
	else if (ISLCN40PHY(pi)) {
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;

		PHY_REG_MOD(pi, LCN40PHY, radioCtrl, digi_gain_ovr,
			pi_lcn40->save_digi_gain_ovr);
		wlc_lcn40phy_deaf_mode(pi, FALSE);
		/* Setting the saved value to default just to be safe */
		pi_lcn40->save_digi_gain_ovr = 0;
	}
	else if (ISNPHY(pi))
		wlc_nphy_deaf_mode(pi, FALSE);
	else if (ISHTPHY(pi))
		wlc_phy_deaf_htphy(pi, FALSE);
	else if (ISACPHY(pi))
		wlc_phy_deaf_acphy(pi, FALSE);
#if (defined(LCN20CONF) && (LCN20CONF != 0))
	else if (ISLCN20PHY(pi))
		wlc_lcn20phy_deaf_mode(pi, FALSE);
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
	else {
		PHY_ERROR(("%s: Not yet supported\n", __FUNCTION__));
		ASSERT(0);
	}
}

#if defined(WLTEST) || defined(AP) || defined(WLAWDL)
static int
wlc_phy_iovar_perical_config(phy_info_t *pi, int32 int_val, int32 *ret_int_ptr,	bool set)
{
	int err = BCME_OK;

	if (!set) {
		if (!ISNPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi) && !ISLCNPHY(pi))
			/* supported for n, ht, ac and lcn phy only */
			return BCME_UNSUPPORTED;

		*ret_int_ptr =  pi->phy_cal_mode;
	} else {
		if (!ISNPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi) && !ISLCNPHY(pi))
			/* supported for n, ht, ac and lcn phy only */
			return BCME_UNSUPPORTED;

		if (int_val == 0) {
			pi->phy_cal_mode = PHY_PERICAL_DISABLE;
		} else if (int_val == 1) {
			pi->phy_cal_mode = PHY_PERICAL_SPHASE;
		} else if (int_val == 2) {
			if (ISACPHY(pi) && ACREV_IS(pi->pubpi.phy_rev, 1)) {
				pi->phy_cal_mode = PHY_PERICAL_MPHASE;
				/* enabling MPHASE only for 4360 B0 */
			} else {
				pi->phy_cal_mode = PHY_PERICAL_SPHASE;
			}
			if (ISNPHY(pi))
				pi->phy_cal_mode = PHY_PERICAL_MPHASE;
		} else if (int_val == 3) {
			/* this mode is to disable normal periodic cal paths
			 *  only manual trigger(nphy_forcecal) can run it
			 */
			pi->phy_cal_mode = PHY_PERICAL_MANUAL;
		} else {
			err = BCME_RANGE;
			goto end;
		}
		wlc_phy_cal_perical_mphase_reset(pi);
	}
end:
	return err;
}
#endif // endif

#if defined(BCMDBG) || defined(WLTEST) || defined(MACOSX) || defined(ATE_BUILD) || \
	defined(BCMDBG_TEMPSENSE)
static int
wlc_phy_iovar_tempsense(phy_info_t *pi, int32 *ret_int_ptr)
{
	int err = BCME_OK;
	int32 int_val;

	*ret_int_ptr = 0;
	if (ISNPHY(pi)) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		*ret_int_ptr = (int32)wlc_phy_tempsense_nphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
	} else if (ISHTPHY(pi)) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		*ret_int_ptr = (int32)wlc_phy_tempsense_htphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
	} else if (ISACPHY(pi)) {
		/* No need to call suspend_mac and phyreg_enter since it
		* is done inside wlc_phy_tempsense_acphy
		*/
	  if (pi->radio_is_on)
	    *ret_int_ptr = (int32)wlc_phy_tempsense_acphy(pi);
	  else
	    err = BCME_RADIOOFF;
	} else if (ISLPPHY(pi)) {
		int_val = wlc_phy_tempsense_lpphy(pi);
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else if (ISLCNPHY(pi)) {
		if (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) {
			int_val = (int32)wlc_lcnphy_tempsense(pi, 1);
		} else {
			int_val = wlc_lcnphy_tempsense_degree(pi, 1);
		}
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else if (ISLCN40PHY(pi)) {
		int_val = wlc_lcn40phy_tempsense(pi, TEMPER_VBAT_TRIGGER_NEW_MEAS);
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else
		err = BCME_UNSUPPORTED;

	return err;
}

#endif	/* BCMDBG || WLTEST || MACOSX || ATE_BUILD || BCMDBG_TEMPSENSE */

#if defined(WLTEST)
static int
wlc_phy_iovar_idletssi_reg(phy_info_t *pi, int32 *ret_int_ptr, int32 int_val, bool set)
{
	int err = BCME_OK;
	uint32 tmp;
	uint16 idle_tssi[NPHY_CORE_NUM];
	phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;

	if (ISLCN40PHY(pi))
		*ret_int_ptr = wlc_lcn40phy_idle_tssi_reg_iovar(pi, int_val, set, &err);
	else if (ISHTPHY(pi))
		*ret_int_ptr = wlc_phy_idletssi_get_htphy(pi);
	else if (ISNPHY(pi)) {
		if (!(CHIP_4324_B0(pi) || CHIP_4324_B4(pi))) {
			wlc_phy_lcnxn_rx2tx_stallwindow_nphy(pi, 1);
			wlc_phy_txpwrctrl_idle_tssi_nphy(pi);
			wlc_phy_lcnxn_rx2tx_stallwindow_nphy(pi, 0);
		}
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			idle_tssi[0] = (uint16)pi_nphy->nphy_pwrctrl_info[0].idle_tssi_2g;
			idle_tssi[1] = (uint16)pi_nphy->nphy_pwrctrl_info[1].idle_tssi_2g;
		} else {
			idle_tssi[0] = (uint16)pi_nphy->nphy_pwrctrl_info[0].idle_tssi_5g;
			idle_tssi[1] = (uint16)pi_nphy->nphy_pwrctrl_info[1].idle_tssi_5g;
		}
		tmp = (idle_tssi[1] << 16) | idle_tssi[0];
		*ret_int_ptr = tmp;
	}

	return err;
}

static int
wlc_phy_iovar_avgtssi_reg(phy_info_t *pi, int32 *ret_int_ptr)
{
	int err = BCME_OK;
	if (ISLCN40PHY(pi))
		*ret_int_ptr = wlc_lcn40phy_avg_tssi_reg_iovar(pi);
	else if (ISNPHY(pi)) {
		*ret_int_ptr = wlc_nphy_tssi_read_iovar(pi);
	}
	return err;
}

static int
wlc_phy_set_rx_gainindex(phy_info_t *pi, int32 gain_idx)
{
	int err = BCME_OK;

	if (!pi->sh->up) {
		return BCME_NOTUP;
	}

	PHY_INFORM(("wlc_phy_set_rx_gainindex Called\n"));

	if (ISACPHY(pi)) {
		err = acphy_set_rxgain_index(pi, gain_idx);
		return err;
	}
	else
		return BCME_UNSUPPORTED;
}

static int
wlc_phy_get_rx_gainindex(phy_info_t *pi, int32 *gain_idx)
{
	int err = BCME_OK;

	if (!pi->sh->up) {
		return BCME_NOTUP;
	}

	PHY_INFORM(("wlc_phy_get_rx_gainindex Called\n"));

	if (ISACPHY(pi)) {
		uint8 gidx[PHY_CORE_MAX];
		err = acphy_get_rxgain_index(pi, gidx);
		*gain_idx = (int32)gidx[0];
		return err;
	}
	else
		return BCME_UNSUPPORTED;
}

static int
wlc_phy_pkteng_get_gainindex(phy_info_t *pi, int32 *gain_idx)
{
	int i;
	int err = BCME_OK;

	if (D11REV_LT(pi->sh->corerev, 11))
		return BCME_UNSUPPORTED;

	if (!pi->sh->up) {
		return BCME_NOTUP;
	}

	PHY_INFORM(("wlc_phy_pkteng_get_gainindex Called\n"));

	if (ISLCNCOMMONPHY(pi)) {
		uint8 gidx[4];
		uint16 rssi_addr[4];

		uint16 lcnphyregs_shm_addr =
			2 * wlapi_bmac_read_shm(pi->sh->physhim, M_LCN40PHYREGS_PTR);

		rssi_addr[0] = lcnphyregs_shm_addr + M_LCN_RSSI_0;
		rssi_addr[1] = lcnphyregs_shm_addr + M_LCN_RSSI_1;
		rssi_addr[2] = lcnphyregs_shm_addr + M_LCN_RSSI_2;
		rssi_addr[3] = lcnphyregs_shm_addr + M_LCN_RSSI_3;

		for (i = 0; i < 4; i++) {
			gidx[i] =
				(wlapi_bmac_read_shm(pi->sh->physhim, rssi_addr[i])
				& LCN40_RX_GAIN_INDEX_MASK) >> LCN40_RX_GAIN_INDEX_SHIFT;

		}
		*gain_idx = (int32)gidx[0];
		return BCME_OK;
	} else if (ISACPHY(pi)) {
		uint8 gidx[PHY_CORE_MAX];
		err = acphy_get_rxgain_index(pi, gidx);
		*gain_idx = (int32)gidx[0];
		return err;
	}
	else
		return BCME_UNSUPPORTED;
}

void
wlc_phy_pkteng_rxstats_update(wlc_phy_t *ppi, uint8 statidx)
{
	phy_info_t *pi;
	pi = (phy_info_t*)ppi;

	if (ISACPHY(pi) && ((pi->measure_hold & PHY_HOLD_FOR_PKT_ENG)))
		pi->u.pi_acphy->rxstats[statidx] += 1;
}

static int
wlc_phy_pkteng_stats_get(phy_info_t *pi, void *a, int alen)
{
	wl_pkteng_stats_t stats;
	uint16 rxstats_base;
	uint16 hi, lo;
	int i;

	if (D11REV_LT(pi->sh->corerev, 11))
		return BCME_UNSUPPORTED;

	if (!pi->sh->up) {
		return BCME_NOTUP;
	}

	PHY_INFORM(("Pkteng Stats Called\n"));

	/* Read with guard against carry */
	do {
		hi = wlapi_bmac_read_shm(pi->sh->physhim, M_PKTENG_FRMCNT_HI);
		lo = wlapi_bmac_read_shm(pi->sh->physhim, M_PKTENG_FRMCNT_LO);
	} while (hi != wlapi_bmac_read_shm(pi->sh->physhim, M_PKTENG_FRMCNT_HI));

	stats.lostfrmcnt = (hi << 16) | lo;
	stats.rssi_qdb = 0;

	if (ISLPPHY(pi) || ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
		if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 4)) &&
			(!CHIPID_4324X_MEDIA_FAMILY(pi))) {
			int16 rxpwr0, rxpwr1;
			rxpwr0 = R_REG(pi->sh->osh, &pi->regs->rssi) & 0xff;
			rxpwr1 = (R_REG(pi->sh->osh, &pi->regs->rssi) >> 8) & 0xff;
			/* Sign extend */
			if (rxpwr0 > 127)
				rxpwr0 -= 256;
			if (rxpwr1 > 127)
				rxpwr1 -= 256;
			stats.rssi = wlc_phy_swrssi_compute_nphy(pi, &rxpwr0, &rxpwr1);
		} else if (ISACPHY(pi)) {
			if (pi->u.pi_acphy->rssi_cal_rev == FALSE) {
#ifdef WL11AC
				int8 core;
				int8 temp = -128;
				stats.rssi = -128;
				FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
					if (core == 0) {
						temp = (R_REG(pi->sh->osh,
						 &pi->regs->u_rcv.d11regs.rxe_phyrs_2) >> 8) & 0xff;
					} else if (core == 1) {
						temp = R_REG(pi->sh->osh,
						 &pi->regs->u_rcv.d11regs.rxe_phyrs_3) & 0xff;
					} else if (core == 2) {
						temp = (R_REG(pi->sh->osh,
						 &pi->regs->u_rcv.d11regs.rxe_phyrs_3) >> 8) & 0xff;
					}
					stats.rssi = MAX(stats.rssi, temp);
				}

				if (stats.rssi > 127)
					stats.rssi -= 256;
#endif /* WL11AC */
			} else if (D11REV_IS(pi->sh->corerev, 48) ||
				D11REV_IS(pi->sh->corerev, 47) ||
				D11REV_IS(pi->sh->corerev, 51)) {
				int core;
				int16 rxpwr_core[PHY_CORE_MAX], rssi_comp;

				FOREACH_CORE(pi, core) {
					/* Supports only two cores */
					if (core < 2)
						rxpwr_core[core] =
						wlapi_bmac_read_shm(pi->sh->physhim,
						M_PKTENG_RXAVGPWR_ANT(core));
				}
				/* Sign extend */
				FOREACH_CORE(pi, core) {
					if (rxpwr_core[core] > (127 * 4))
						rxpwr_core[core] -= (256 * 4);
				}
				rssi_comp = wlc_phy_rssi_compute_compensation_acphy(pi,
					rxpwr_core, 1);

				if (pi->u.pi_acphy->rssi_qdB_en == TRUE) {
					stats.rssi = rssi_comp >> 2;
					stats.rssi_qdb = rssi_comp & 0x3;
				} else {
					stats.rssi =
					((rssi_comp >= 0) ?
					((rssi_comp + 2) >> 2) : -1 * ((-1 * rssi_comp + 2) >> 2));
					stats.rssi_qdb = 0;
				}

			} else {
				stats.rssi = pi->u.pi_acphy->last_rssi;
			}
		} else {
			stats.rssi = R_REG(pi->sh->osh, &pi->regs->rssi) & 0xff;
			if (stats.rssi > 127)
				stats.rssi -= 256;
		}
		stats.snr = stats.rssi - (ISLPPHY(pi) ? PHY_NOISE_FIXED_VAL :
			PHY_NOISE_FIXED_VAL_NPHY);
	} else if (ISSSLPNPHY(pi)) {
		wlc_sslpnphy_pkteng_stats_get(pi, &stats);
	} else if (ISLCNCOMMONPHY(pi)) {
		int16 rssi_lcn[4];
		int16 snr_a_lcn[4];
		int16 snr_b_lcn[4];
		uint8 gidx[4];
		int8 snr[4];
		int8 snr_lcn[4];
		phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
		phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
		uint16 rssi_addr[4], snr_a_addr[4], snr_b_addr[4];
		uint16 lcnphyregs_shm_addr =
			2 * wlapi_bmac_read_shm(pi->sh->physhim, M_LCN40PHYREGS_PTR);
		int16 rxpath_gain;
		uint16 board_atten = 0;
		int16 rssi_lcn40_qdb[4];
		uint16 rssi_qdb_addr[4];
		uint8 gain_resp[4];
		uint8 gidx_calc[4];

#if RSSI_IQEST_DEBUG
		uint16 rssi_iqpwr;
		int16 rssi_iqpwr_dB;
		int wait_count = 0;
		uint16 board_atten_dbg;

		while (wlapi_bmac_read_shm(pi->sh->physhim, lcnphyregs_shm_addr + M_RSSI_LOCK)) {
			/* Check for timeout */
			if (wait_count > 100) { /* 1 ms */
				PHY_ERROR(("wl%d: %s: Unable to get RSSI_LOCK\n",
					pi->sh->unit, __FUNCTION__));
				goto iqest_rssi_skip;
			}
			OSL_DELAY(10);
			wait_count++;
		}
		wlapi_bmac_write_shm(pi->sh->physhim, lcnphyregs_shm_addr + M_RSSI_LOCK, 1);
		rssi_iqpwr = wlapi_bmac_read_shm(pi->sh->physhim,
			lcnphyregs_shm_addr + M_RSSI_IQPWR_DBG);
		rssi_iqpwr_dB = wlapi_bmac_read_shm(pi->sh->physhim,
			lcnphyregs_shm_addr + M_RSSI_IQPWR_DB_DBG);
		board_atten_dbg = wlapi_bmac_read_shm(pi->sh->physhim,
			lcnphyregs_shm_addr + M_RSSI_BOARDATTEN_DBG);
		wlapi_bmac_write_shm(pi->sh->physhim, lcnphyregs_shm_addr + M_RSSI_LOCK, 0);
		printf("iqpwr = %d, iqpwr_dB = %d, board_atten = %d\n",
			rssi_iqpwr, rssi_iqpwr_dB, board_atten_dbg);
iqest_rssi_skip:
#endif /* RSSI_IQEST_DEBUG */

		rssi_addr[0] = lcnphyregs_shm_addr + M_LCN_RSSI_0;
		rssi_addr[1] = lcnphyregs_shm_addr + M_LCN_RSSI_1;
		rssi_addr[2] = lcnphyregs_shm_addr + M_LCN_RSSI_2;
		rssi_addr[3] = lcnphyregs_shm_addr + M_LCN_RSSI_3;

		rssi_qdb_addr[0] = lcnphyregs_shm_addr + M_LCN40_RSSI_QDB_0;
		rssi_qdb_addr[1] = lcnphyregs_shm_addr + M_LCN40_RSSI_QDB_1;
		rssi_qdb_addr[2] = lcnphyregs_shm_addr + M_LCN40_RSSI_QDB_2;
		rssi_qdb_addr[3] = lcnphyregs_shm_addr + M_LCN40_RSSI_QDB_3;

		stats.rssi = 0;

		for (i = 0; i < 4; i++) {
			rssi_lcn[i] = (int8)(wlapi_bmac_read_shm(pi->sh->physhim,
				rssi_addr[i]) & 0xFF);
			snr_lcn[i] = (int8)((wlapi_bmac_read_shm(pi->sh->physhim,
				rssi_addr[i]) >> 8) & 0xFF);
			BCM_REFERENCE(snr_lcn[i]);
			gidx[i] =
				(wlapi_bmac_read_shm(pi->sh->physhim, rssi_addr[i])
				& LCN40_RX_GAIN_INDEX_MASK) >> LCN40_RX_GAIN_INDEX_SHIFT;

			if (ISLCNPHY(pi)) {
				rssi_lcn[i] = rssi_lcn[i] +
					lcnphy_gain_index_offset_for_pkt_rssi[gidx[i]];
				if ((wlapi_bmac_read_shm(pi->sh->physhim, rssi_addr[i])) & 0x8000) {
					rssi_lcn[i] = rssi_lcn[i] +
						pi->rssi_corr_boardatten;
				} else
					rssi_lcn[i] = rssi_lcn[i] + pi->rssi_corr_normal;

				rssi_lcn[i] = rssi_lcn[i] << 2;
			} else {
				int8 *corr2g;
#ifdef BAND5G
				int8 *corr5g;
#endif /* BAND5G */
				int8 *corrperrg;
				int8 po_reg;
				int16 po_nom;
				uint8 tr_iso = 0;

				if (pi_lcn40->rssi_iqest_en) {
					board_atten = wlapi_bmac_read_shm(pi->sh->physhim,
					rssi_addr[i]) >> 15;

					gain_resp[i] =
						wlapi_bmac_read_shm(pi->sh->physhim,
						rssi_qdb_addr[i]) >> 2;
					gidx_calc[i] = ((gain_resp[i] + 18)* 85) >> 8;
					if (gidx[i] > 37)
						gidx_calc[i] = gidx_calc[i] + 38;
					if (CHSPEC_IS2G(pi->radio_chanspec))
						tr_iso = pi_lcn->lcnphy_tr_isolation_mid;
#ifdef BAND5G
					else
						tr_iso = pi_lcn->triso5g[0];
#endif // endif
					if (board_atten) {
						gidx_calc[i] = gidx_calc[i] + tr_iso;
					}
					gidx[i] = gidx_calc[i];

					rxpath_gain =
						wlc_lcn40phy_get_rxpath_gain_by_index(pi,
						gidx[i], board_atten);
					PHY_INFORM(("iqdB= %d, boardattn= %d, rxpath_gain= %d, "
						"gidx = %d, rssi_iqest_gain_adj = %d\n",
						rssi_lcn[i], board_atten, rxpath_gain, gidx[i],
						pi_lcn40->rssi_iqest_gain_adj));
					rssi_lcn40_qdb[i] =
						wlapi_bmac_read_shm(pi->sh->physhim,
						rssi_qdb_addr[i]) & 0x3;
					rssi_lcn[i] = (rssi_lcn[i] << LCN40_QDB_SHIFT)
						+ rssi_lcn40_qdb[i] - rxpath_gain +
						(pi_lcn40->rssi_iqest_gain_adj
						<< LCN40_QDB_SHIFT);
				}

#if RSSI_CORR_EN
			if (!pi_lcn40->rssi_iqest_en) {
				/* JSSI adjustment wrt power offset */
				if (CHSPEC_IS20(pi->radio_chanspec))
					po_reg =
					PHY_REG_READ(pi, LCN40PHY,
					SignalBlockConfigTable6_new,
					crssignalblk_input_pwr_offset_db);
				else
					po_reg =
					PHY_REG_READ(pi, LCN40PHY,
					SignalBlockConfigTable5_new,
					crssignalblk_input_pwr_offset_db_40mhz);

				switch (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)) {
				case WL_CHAN_FREQ_RANGE_2G:
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_2g;
					else
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_40_2g;
					break;
			#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5GL:
					/* 5 GHz low */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[0];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[0];
					break;
				case WL_CHAN_FREQ_RANGE_5GM:
					/* 5 GHz middle */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[1];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[1];
					break;
				case WL_CHAN_FREQ_RANGE_5GH:
					/* 5 GHz high */
					if (CHSPEC_IS20(pi->radio_chanspec))
						po_nom = pi_lcn->noise.nvram_input_pwr_offset_5g[2];
					else
						po_nom =
						pi_lcn->noise.nvram_input_pwr_offset_40_5g[2];
					break;
			#endif /* BAND5G */
				default:
					po_nom = po_reg;
					break;
				}

				rssi_lcn[i] += ((po_nom - po_reg) << LCN40_QDB_SHIFT);

				/* RSSI adjustment and Adding the JSSI range specific corrections */
				#ifdef BAND5G
				if (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec) !=
					WL_CHAN_FREQ_RANGE_2G) {
						if (((rssi_lcn[i] >> LCN40_QDB_SHIFT) < -60) &&
							((gidx[i] > 0) && (gidx[i] < 38)))
					rssi_lcn[i] = rssi_lcn[i] +
					(lcn40phy_gain_index_offset_for_pkt_rssi_5g[gidx[i]]
					<< LCN40_QDB_SHIFT);
						corrperrg = pi->rssi_corr_perrg_5g;
					} else
				#endif /* BAND5G */
					{
						if (((rssi_lcn[i] >> LCN40_QDB_SHIFT) < -60) &&
							((gidx[i] > 0) && (gidx[i] < 38)))
					rssi_lcn[i] = rssi_lcn[i] +
					(lcn40phy_gain_index_offset_for_pkt_rssi_2g[gidx[i]]
					<< LCN40_QDB_SHIFT);
						corrperrg = pi->rssi_corr_perrg_2g;
					}

					if ((rssi_lcn[i] << LCN40_QDB_SHIFT) <= corrperrg[0])
						rssi_lcn[i] += (corrperrg[2] << LCN40_QDB_SHIFT);
					else if ((rssi_lcn[i] << LCN40_QDB_SHIFT) <= corrperrg[1])
						rssi_lcn[i] += (corrperrg[3] << LCN40_QDB_SHIFT);
					else
						rssi_lcn[i] += (corrperrg[4] << LCN40_QDB_SHIFT);

					corr2g = &(pi->rssi_corr_normal);
#ifdef BAND5G
					corr5g = &(pi->rssi_corr_normal_5g[0]);
#endif /* BAND5G */

				switch (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)) {
						case WL_CHAN_FREQ_RANGE_2G:
							rssi_lcn[i] = rssi_lcn[i] +
								(*corr2g  << LCN40_QDB_SHIFT);
							break;
					#ifdef BAND5G
						case WL_CHAN_FREQ_RANGE_5GL:
							/* 5 GHz low */
							rssi_lcn[i] = rssi_lcn[i] +
							(corr5g[0] << LCN40_QDB_SHIFT);
							break;

						case WL_CHAN_FREQ_RANGE_5GM:
							/* 5 GHz middle */
							rssi_lcn[i] = rssi_lcn[i] +
							(corr5g[1] << LCN40_QDB_SHIFT);
							break;

						case WL_CHAN_FREQ_RANGE_5GH:
							/* 5 GHz high */
							rssi_lcn[i] = rssi_lcn[i] +
							(corr5g[2] << LCN40_QDB_SHIFT);
							break;
					#endif /* BAND5G */
						default:
							rssi_lcn[i] = rssi_lcn[i] + 0;
							break;
					}
				}

				/* Temp sense based correction */
				rssi_lcn[i] += wlc_lcn40phy_rssi_tempcorr(pi, 0);
				if (pi_lcn40->rssi_iqest_en)
					rssi_lcn[i] +=
					wlc_lcn40phy_iqest_rssi_tempcorr(pi, 0, board_atten);

#endif /* RSSI_CORR_EN */
			}
			stats.rssi += rssi_lcn[i];
		}

		stats.rssi = stats.rssi >> 2;

		/* temperature compensation */
		stats.rssi = stats.rssi + (pi_lcn->lcnphy_pkteng_rssi_slope << LCN40_QDB_SHIFT);

		/* convert into dB and save qdB portion */
		stats.rssi_qdb = stats.rssi & LCN40_QDB_MASK;
		stats.rssi = stats.rssi >> LCN40_QDB_SHIFT;

		/* SNR */
		snr_a_addr[0] = lcnphyregs_shm_addr + M_LCN_SNR_A_0;
		snr_a_addr[1] = lcnphyregs_shm_addr + M_LCN_SNR_A_1;
		snr_a_addr[2] = lcnphyregs_shm_addr + M_LCN_SNR_A_2;
		snr_a_addr[3] = lcnphyregs_shm_addr + M_LCN_SNR_A_3;

		snr_b_addr[0] = lcnphyregs_shm_addr + M_LCN_SNR_B_0;
		snr_b_addr[1] = lcnphyregs_shm_addr + M_LCN_SNR_B_1;
		snr_b_addr[2] = lcnphyregs_shm_addr + M_LCN_SNR_B_2;
		snr_b_addr[3] = lcnphyregs_shm_addr + M_LCN_SNR_B_3;

		stats.snr = 0;
		for (i = 0; i < 4; i++) {
			snr_a_lcn[i] = wlapi_bmac_read_shm(pi->sh->physhim, snr_a_addr[i]);
			snr_b_lcn[i] = wlapi_bmac_read_shm(pi->sh->physhim, snr_b_addr[i]);
			snr[i] = ((snr_a_lcn[i] - snr_b_lcn[i])* 3) >> 5;
			if (snr[i] > 31)
				snr[i] = 31;
			stats.snr += snr[i];
			PHY_INFORM(("i = %d, gidx = %d, snr = %d, snr_lcn = %d\n",
				i, lcnphy_gain_index_offset_for_pkt_rssi[gidx[i]],
				snr[i], snr_lcn[i]));
		}
		stats.snr = stats.snr >> 2;

#if RSSI_IQEST_DEBUG
	stats.rssi = rssi_iqpwr_dB;
	stats.lostfrmcnt = rssi_iqpwr;
	stats.snr = board_atten_dbg;
#endif // endif
	} else {
		/* Not available */
		stats.rssi = stats.snr = 0;
	}

#if defined(WLNOKIA_NVMEM)
	/* Nokia NVMEM spec specifies the rssi offsets */
	stats.rssi = wlc_phy_upd_rssi_offset(pi, (int8)stats.rssi, pi->radio_chanspec);
#endif // endif

	/* rx pkt stats */
	if (ISACPHY(pi)) {
		for (i = 0; i <= NUM_80211_RATES; i++)
			stats.rxpktcnt[i] = pi->u.pi_acphy->rxstats[i];
	} else {
		rxstats_base = wlapi_bmac_read_shm(pi->sh->physhim, M_RXSTATS_BLK_PTR);
		for (i = 0; i <= NUM_80211_RATES; i++) {
			stats.rxpktcnt[i] =
				wlapi_bmac_read_shm(pi->sh->physhim, 2*(rxstats_base+i));
		}
	}
	bcopy(&stats, a,
		(sizeof(wl_pkteng_stats_t) < (uint)alen) ? sizeof(wl_pkteng_stats_t) : (uint)alen);

	return BCME_OK;
}

static int
wlc_phy_iovar_idletssi(phy_info_t *pi, int32 *ret_int_ptr, bool type)
{
	/* no argument or type = 1 will do full tx_pwr_ctrl_init */
	/* type = 0 will do just idle_tssi_est */
	int err = BCME_OK;
	if (ISLCNPHY(pi))
		*ret_int_ptr = wlc_lcnphy_idle_tssi_est_iovar(pi, type);
	else if (ISLCN40PHY(pi))
		*ret_int_ptr = wlc_lcn40phy_idle_tssi_est_iovar(pi, type);
	else
		*ret_int_ptr = 0;

	return err;
}

static int
wlc_phy_iovar_bbmult_get(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr)
{
	int err = BCME_OK;

	if (ISNPHY(pi))
		wlc_phy_get_bbmult_nphy(pi, ret_int_ptr);
	else
		err = BCME_UNSUPPORTED;

	return err;
}

static int
wlc_phy_iovar_bbmult_set(phy_info_t *pi, void *p)
{
	int err = BCME_OK;
	uint16 bbmult[PHY_CORE_NUM_2] = { 0 };
	uint8 m0, m1;

	bcopy(p, bbmult, PHY_CORE_NUM_2 * sizeof(uint16));

	if (ISNPHY(pi)) {
		m0 = (uint8)(bbmult[0] & 0xff);
		m1 = (uint8)(bbmult[1] & 0xff);
		wlc_phy_set_bbmult_nphy(pi, m0, m1);
	} else
		err = BCME_UNSUPPORTED;

	return err;
}

static int
wlc_phy_iovar_vbatsense(phy_info_t *pi, int32 *ret_int_ptr)
{
	int err = BCME_OK;
	int32 int_val;

	if (ISLCNPHY(pi)) {
		int_val = wlc_lcnphy_vbatsense(pi, 1);
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else if (ISLCN40PHY(pi)) {
		int_val = wlc_lcn40phy_vbatsense(pi, TEMPER_VBAT_TRIGGER_NEW_MEAS);
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else if (ISNPHY(pi)) {
		int_val = (int32)(wlc_phy_vbat_from_statusbyte_nphy_rev19(pi));
		bcopy(&int_val, ret_int_ptr, sizeof(int_val));
	} else
		err = BCME_UNSUPPORTED;

	return err;
}

#endif // endif

#if defined(WLTEST) || defined(DBG_PHY_IOV)
static int
wlc_phy_table_get(phy_info_t *pi, int32 int_val, void *p, void *a)
{
	int32 tblInfo[4];
	lpphytbl_info_t tab;
	phytbl_info_t tab2;

	if (ISAPHY(pi) || ISGPHY(pi))
		return BCME_UNSUPPORTED;

	/* other PHY */
	bcopy(p, tblInfo, 3*sizeof(int32));

	if (ISLPPHY(pi)) {
		tab.tbl_ptr = &int_val;
		tab.tbl_len = 1;
		tab.tbl_id = (uint32)tblInfo[0];
		tab.tbl_offset = (uint32)tblInfo[1];
		tab.tbl_width = (uint32)tblInfo[2];
		tab.tbl_phywidth = (uint32)tblInfo[2];
		wlc_phy_table_read_lpphy(pi, &tab);
	} else {
		tab2.tbl_ptr = &int_val;
		tab2.tbl_len = 1;
		tab2.tbl_id = (uint32)tblInfo[0];
		tab2.tbl_offset = (uint32)tblInfo[1];
		tab2.tbl_width = (uint32)tblInfo[2];

		if (ISSSLPNPHY(pi)) {
			wlc_sslpnphy_read_table(pi, &tab2);
		} else if (ISNPHY(pi)) {
			if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
				wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, MCTL_PHYLOCK);
			}
			wlc_phy_read_table_nphy(pi, &tab2);
			if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
				wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);
			}
		} else if (ISHTPHY(pi)) {
			wlc_phy_read_table_htphy(pi, &tab2);
		} else if (ISACPHY(pi)) {
			wlc_phy_table_read_acphy(pi, tab2.tbl_id, tab2.tbl_len, tab2.tbl_offset,
			                         tab2.tbl_width, &int_val);
		} else if (pi->pi_fptr.phyreadtable) {
			pi->pi_fptr.phyreadtable(pi, &tab2);
		}
	}
	bcopy(&int_val, a, sizeof(int_val));
	return BCME_OK;
}

static int
wlc_phy_table_set(phy_info_t *pi, int32 int_val, void *a)
{
	int32 tblInfo[4];
	lpphytbl_info_t tab;
	phytbl_info_t tab2;

	if (ISAPHY(pi) || ISGPHY(pi))
		return BCME_UNSUPPORTED;

	bcopy(a, tblInfo, 4*sizeof(int32));

	if (ISLPPHY(pi)) {
		int_val = tblInfo[3];
		tab.tbl_ptr = &int_val;
		tab.tbl_len = 1;
		tab.tbl_id = (uint32)tblInfo[0];
		tab.tbl_offset = (uint32)tblInfo[1];
		tab.tbl_width = (uint32)tblInfo[2];
		tab.tbl_phywidth = (uint32)tblInfo[2];
		wlc_phy_table_write_lpphy(pi, &tab);
	} else {
	    int_val = tblInfo[3];
		tab2.tbl_ptr = &int_val;
		tab2.tbl_len = 1;
		tab2.tbl_id = (uint32)tblInfo[0];
		tab2.tbl_offset = (uint32)tblInfo[1];
		tab2.tbl_width = (uint32)tblInfo[2];

		if (ISSSLPNPHY(pi)) {
			wlc_sslpnphy_write_table(pi, &tab2);
		} else if (ISNPHY(pi)) {
			wlc_phy_write_table_nphy(pi, (&tab2));
		} else if (ISHTPHY(pi)) {
			wlc_phy_write_table_htphy(pi, (&tab2));
		} else if (ISACPHY(pi)) {
			wlc_phy_table_write_acphy(pi, tab2.tbl_id, tab2.tbl_len, tab2.tbl_offset,
			                         tab2.tbl_width, &int_val);
		} else if (pi->pi_fptr.phywritetable) {
			pi->pi_fptr.phywritetable(pi, &tab2);
		}
	}
	return BCME_OK;
}
#endif // endif

#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WLMEDIA_N2DEV) || \
	defined(DBG_PHY_IOV) || defined(WFD_PHY_LL_DEBUG) || defined(ATE_BUILD)
static int
wlc_phy_iovar_forcecal(phy_info_t *pi, int32 int_val, int32 *ret_int_ptr, int vsize, bool set)
{
	int err = BCME_OK;
	void *a;
#if defined(PHYCAL_CACHING)
	ch_calcache_t *ctx;
#endif /* PHYCAL_CACHING */

	a = (int32*)ret_int_ptr;

	if (!pi->sh->up)
		return BCME_NOTUP;

	if (ISHTPHY(pi)) {
		uint8 mphase = 0, searchmode = 0;

		/* for get with no argument, assume 0x00 */
		if (!set)
			int_val = 0x00;

		/* upper nibble: 0 = sphase,  1 = mphase */
		mphase = (((uint8) int_val) & 0xf0) >> 4;

		/* 0 = RESTART, 1 = REFINE, for Tx-iq/lo-cal */
		searchmode = ((uint8) int_val) & 0xf;

		PHY_CAL(("wlc_phy_iovar_forcecal (mphase = %d, refine = %d)\n",
			mphase, searchmode));

		/* call sphase or schedule mphase cal */
		wlc_phy_cal_perical_mphase_reset(pi);
		if (mphase) {
			pi->cal_info->cal_searchmode = searchmode;
			wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_NODELAY);
		} else {
			wlc_phy_cals_htphy(pi, searchmode);
		}
	} else if (ISACPHY(pi)) {
		uint8 mphase = FALSE;
		uint8 searchmode = PHY_CAL_SEARCHMODE_RESTART;

		/* for get with no argument, assume 0x00 */
		if (!set)
			int_val = 0x00;

		/* only values in range [0-3] are valids */
		if (int_val > 3)
			return BCME_BADARG;

		/* 3 is mphase, anything else is single phase */
		if (int_val == 3) {
			mphase = TRUE;
		}
		else {
			/* Single phase, using 2 means sphase partial */
			if (int_val == 2)
				searchmode = PHY_CAL_SEARCHMODE_REFINE;
		}

		PHY_CAL(("wlc_phy_iovar_forcecal (mphase = %d, refine = %d)\n",
			mphase, searchmode));

		/* call sphase or schedule mphase cal */
		wlc_phy_cal_perical_mphase_reset(pi);
		if (mphase) {
			pi->cal_info->cal_searchmode = searchmode;
			wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_NODELAY);
		} else {
			wlc_phy_cals_acphy(pi, searchmode);
		}
	} else if (ISNPHY(pi)) {
		/* for get with no argument, assume 0x00 */
		if (!set)
			int_val = PHY_PERICAL_AUTO;

		if ((int_val == PHY_PERICAL_PARTIAL) ||
		    (int_val == PHY_PERICAL_AUTO) ||
		    (int_val == PHY_PERICAL_FULL)) {
			wlc_phy_cal_perical_mphase_reset(pi);
			pi->u.pi_nphy->cal_type_override = (uint8)int_val;
			wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_NODELAY);
#ifdef WLOTA_EN
		} else if (int_val == PHY_FULLCAL_SPHASE) {
			wlc_phy_cal_perical((wlc_phy_t *)pi, PHY_FULLCAL_SPHASE);
#endif /* WLOTA_EN */
		} else
			err = BCME_RANGE;

		/* phy_forcecal will trigger noisecal */
		pi->trigger_noisecal = TRUE;

	} else if (ISLPPHY(pi)) {
		/* don't care get or set with argument */
#if defined(PHYCAL_CACHING)
		ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);

		ASSERT(ctx);
		ctx->valid = FALSE;
#else
		pi->u.pi_lpphy->lpphy_full_cal_channel = 0;
#endif // endif
		wlc_phy_periodic_cal_lpphy(pi);
		int_val = 0;
		bcopy(&int_val, a, vsize);

	} else if (ISSSLPNPHY(pi)) {
		phy_info_sslpnphy_t *pi_ssn = pi->u.pi_sslpnphy;

		if (int_val != 0)
			pi->phy_forcecal = TRUE;
		pi_ssn->sslpnphy_full_cal_channel[CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0] = 0;
		wlc_sslpnphy_noise_measure((wlc_phy_t *)pi);

	} else if (ISLCNCOMMONPHY(pi) && pi->pi_fptr.calibmodes) {
#if defined(PHYCAL_CACHING)
		ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
		if (ctx) {
			ctx->valid = FALSE;
		}
		/* null ctx is invalid by definition */
#else
		phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
		pi_lcn->lcnphy_full_cal_channel = 0;
#endif /* PHYCAL_CACHING */
		if (!set)
			*ret_int_ptr = 0;

		pi->pi_fptr.calibmodes(pi, PHY_FULLCAL);
		int_val = 0;
		bcopy(&int_val, a, vsize);
	}

	return err;
}

#ifndef ATE_BUILD
static int
wlc_phy_iovar_forcecal_obt(phy_info_t *pi, int32 int_val, int32 *ret_int_ptr, int vsize, bool set)
{
	int err = BCME_OK;
	uint8 wait_ctr = 0;
	int val = 1;
	if (ISNPHY(pi)) {
			wlc_phy_cal_perical_mphase_reset(pi);

			pi->cal_info->cal_phase_id = MPHASE_CAL_STATE_INIT;
			pi->trigger_noisecal = TRUE;

			while (wait_ctr < 50) {
				val = ((pi->cal_info->cal_phase_id !=
					MPHASE_CAL_STATE_IDLE)? 1 : 0);
				if (val == 0) {
					err = BCME_OK;
					break;
				}
				else {
					wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);
					wait_ctr++;
				}
			}
			if (wait_ctr >= 50) {
				return BCME_ERROR;
			}

		}

	return err;
}

/* JIRA: SWWLAN-32606, RB: 12975: function to do only Noise cal & read crsmin power of
 * core 0 & core 1
*/
static int
wlc_phy_iovar_forcecal_noise(phy_info_t *pi, int32 int_val, void *a, int vsize, bool set)
{
	int err = BCME_OK;
	uint8 wait_ctr = 0;
	int val = 1;
	uint16 crsmin[4];

	if (ISNPHY(pi)) {
		if (!set) {
			crsmin[0] = phy_reg_read(pi, NPHY_crsminpowerl0);
			crsmin[1] = phy_reg_read(pi, NPHY_crsminpoweru0);
			crsmin[2] = phy_reg_read(pi, NPHY_crsminpowerl0_core1);
			crsmin[3] = phy_reg_read(pi, NPHY_crsminpoweru0_core1);
			bcopy(crsmin, a, sizeof(uint16)*4);
		}
		else {
			wlc_phy_cal_perical_mphase_reset(pi);

			pi->cal_info->cal_phase_id = MPHASE_CAL_STATE_NOISECAL;
			pi->trigger_noisecal = TRUE;

			while (wait_ctr < 50) {
				val = ((pi->cal_info->cal_phase_id !=
				MPHASE_CAL_STATE_IDLE)? 1 : 0);

				if (val == 0) {
					err = BCME_OK;
					break;
				}
				else {
					wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_PARTIAL);
					wait_ctr++;
				}
			}

			if (wait_ctr >= 50) {
				return BCME_ERROR;
			}
		}
	} else if (ISACPHY(pi)) {
		/* Run a forced Noise cal for AC PHY */
		wlc_phy_noisecal_run_acphy(pi);
	}
	return err;
}
#endif /* !ATE_BUILD */
#endif // endif

#if defined(WLTEST) || defined(DBG_PHY_IOV)
static int
wlc_phy_dynamic_ml(phy_info_t *pi, int32 int_val, int32 *ret_int_ptr, int vsize, bool set)
{
	int err = BCME_OK;

	if (!pi->sh->clk)
		return BCME_NOCLK;

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;
	else if (NREV_LT(pi->pubpi.phy_rev, LCNXN_BASEREV + 2))
		return BCME_UNSUPPORTED;

	if (!set) {
		if (ISNPHY(pi)) {
			wlc_phy_dynamic_ml_get(pi);
			*ret_int_ptr = pi->nphy_ml_type;
		}

	} else {
		if ((int_val > 4) || (int_val < 0))
			return BCME_RANGE;
		wlc_phy_dynamic_ml_set(pi, int_val);
	}
	return err;
}

static int
wlc_phy_rf_swctrl_toggle(phy_info_t *pi, int32 int_val, void *tinfo, int32 *ret_int_ptr, bool set)
{
	int err = BCME_OK;
	int32 info[4];
	uint32 offset, value;

	if (!pi->sh->clk)
		return BCME_NOCLK;

	bcopy(tinfo, info, 3*sizeof(int32));
	offset = (uint32)info[0];

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;
	else if (!CHIPID_4324X_EPA_FAMILY(pi))
		return BCME_UNSUPPORTED;

	if (!set) {
		wlc_phy_rf_swctrl_reset(pi);

	} else {

		value = (uint32)info[1];
		if (value > 1)
			return BCME_RANGE;
		if (offset > 11)
			return BCME_RANGE;
		wlc_phy_rf_swctrl_set(pi, offset, value);
	}
	return err;
}

/* aci_nams : ACI Non Assoc Mode Sanity */
static int
wlc_phy_aci_nams(phy_info_t *pi, int32 int_val,	int32 *ret_int_ptr, int vsize, bool set)
{
	int err = BCME_OK;

	if (!pi->sh->clk)
		return BCME_NOCLK;

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;
	else if NREV_LT(pi->pubpi.phy_rev, LCNXN_BASEREV + 2)
		return BCME_UNSUPPORTED;

	if (!set) {
		if (ISNPHY(pi)) {
			*ret_int_ptr = pi->aci_nams;
		}

	} else {
		if ((int_val > 1) || (int_val < 0))
			return BCME_RANGE;
		pi->aci_nams = (uint8)int_val;
	}
	return err;
}
#endif // endif

static int
wlc_phy_iovar_oclscd(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr,
	bool set)
{
	int err = BCME_OK;
	uint8 coremask;

	if (!pi->sh->clk)
		return BCME_NOCLK;

	coremask = ((phy_reg_read(pi, NPHY_CoreConfig) & NPHY_CoreConfig_CoreMask_MASK)
		>> NPHY_CoreConfig_CoreMask_SHIFT);

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;
	else if (NREV_LT(pi->pubpi.phy_rev, LCNXN_BASEREV + 2))
		return BCME_UNSUPPORTED;

	if (!set) {
		if (ISNPHY(pi)) {
			*ret_int_ptr = pi->nphy_oclscd;
		}

	} else {
		if (ISNPHY(pi)) {

			if ((int_val > 3) || (int_val < 0))
				return BCME_RANGE;

			if (int_val == 2)
				return BCME_BADARG;

			if ((coremask < 3) && (int_val != 0))
				return BCME_NORESOURCE;

			pi->nphy_oclscd = (uint8)int_val;
			/* suspend mac */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);

			wlc_phy_set_oclscd_nphy(pi);

			/* resume mac */
			wlapi_enable_mac(pi->sh->physhim);
		}
	}
	return err;
}
static int wlc_phy_iovar_ocl_force_core0(phy_info_t *pi, int32 int_val,
	int32 *ret_int_ptr, bool set)
{
	if (!pi->sh->clk)
		return BCME_NOCLK;

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;

	if (!set) {
		if (ISNPHY(pi)) {
			*ret_int_ptr = pi->phy_ocl_force_core0;
		}
	} else {
		if (ISNPHY(pi)) {
			wlc_phy_ocl_force_core0(pi, (uint8)int_val);
		}
	}
	return BCME_OK;
}
/* Debug functionality. Is called via an iovar. */
static int
wlc_phy_iovar_prog_lnldo2(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr,
	bool set)
{
	int err = BCME_OK;
	uint8 lnldo2_val = 0;
	uint32 reg_value = 0;

	if (!ISNPHY(pi))
		return BCME_UNSUPPORTED;
	else if (!CHIPID_4324X_IPA_FAMILY(pi))
		return BCME_UNSUPPORTED;

	if (!set) {
		/* READ */
		wlc_si_pmu_regcontrol_access(pi, 5, &reg_value, 0);
		*ret_int_ptr = (int32)((reg_value & 0xff) >> 1);
	} else {
		/* WRITE */
		lnldo2_val = (uint8)(int_val & 0xff);
		*ret_int_ptr = wlc_phy_lnldo2_war_nphy(pi, 1, lnldo2_val);
	}
	return err;
}

#if defined(WLTEST) || defined(MACOSX)
static void
wlc_phy_iovar_set_deaf(phy_info_t *pi, int32 int_val)
{
	if (int_val) {
		wlc_phy_set_deaf((wlc_phy_t *) pi, TRUE);
	} else {
		wlc_phy_clear_deaf((wlc_phy_t *) pi, TRUE);
	}
}

static int
wlc_phy_iovar_get_deaf(phy_info_t *pi, int32 *ret_int_ptr)
{
	if (ISHTPHY(pi)) {
		*ret_int_ptr = (int32)wlc_phy_get_deaf_htphy(pi);
		return BCME_OK;
	} else if (ISNPHY(pi)) {
		*ret_int_ptr = (int32)wlc_phy_get_deaf_nphy(pi);
		return BCME_OK;
	} else if (ISACPHY(pi)) {
	        *ret_int_ptr = (int32)wlc_phy_get_deaf_acphy(pi);
		return BCME_OK;
	} else {
		return BCME_UNSUPPORTED;
	}
}
#endif // endif
#if defined(WLTEST) || defined(ATE_BUILD)
static int
wlc_phy_iovar_txpwrctrl(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr,
	bool set)
{
	int err = BCME_OK;

	if (!set) {
		if (ISACPHY(pi) || ISHTPHY(pi)) {
			*ret_int_ptr = pi->txpwrctrl;
		} else if (ISNPHY(pi)) {
			*ret_int_ptr = pi->nphy_txpwrctrl;
		} else if (ISLPPHY(pi)) {
			*ret_int_ptr = wlc_phy_tpc_isenabled_lpphy(pi);
		} else if (ISSSLPNPHY(pi)) {
			*ret_int_ptr = wlc_phy_tpc_isenabled_sslpnphy(pi);
		} else if (ISLCNPHY(pi)) {
			*ret_int_ptr = wlc_phy_tpc_iovar_isenabled_lcnphy(pi);
		} else if (pi->pi_fptr.ishwtxpwrctrl) {
			*ret_int_ptr = pi->pi_fptr.ishwtxpwrctrl(pi);
		}

	} else {
		if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			if ((int_val != PHY_TPC_HW_OFF) && (int_val != PHY_TPC_HW_ON)) {
				err = BCME_RANGE;
				goto end;
			}

			pi->nphy_txpwrctrl = (uint8)int_val;
			pi->txpwrctrl = (uint8)int_val;

			/* if not up, we are done */
			if (!pi->sh->up)
				goto end;

			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
			if (ISNPHY(pi))
				wlc_phy_txpwrctrl_enable_nphy(pi, (uint8) int_val);
			else if (ISHTPHY(pi))
				wlc_phy_txpwrctrl_enable_htphy(pi, (uint8) int_val);
			else if (ISACPHY(pi))
				wlc_phy_txpwrctrl_enable_acphy(pi, (uint8) int_val);
			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);

		} else if (ISLPPHY(pi)) {
#if defined(PHYCAL_CACHING)
			ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#else
			phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;
#endif // endif

			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);

			wlc_phy_set_tx_pwr_ctrl_lpphy(pi,
				int_val ? LPPHY_TX_PWR_CTRL_HW : LPPHY_TX_PWR_CTRL_SW);
			/* Reset calibration */
#if defined(PHYCAL_CACHING)
			ASSERT(ctx);
			ctx->valid = FALSE;
#else
			pi_lp->lpphy_full_cal_channel = 0;
#endif // endif
			pi->phy_forcecal = TRUE;

			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);
		} else if (ISSSLPNPHY(pi)) {
			wlc_sslpnphy_iovar_txpwrctrl(pi, int_val);

		} else if (ISLCNPHY(pi)) {
			wlc_lcnphy_iovar_txpwrctrl(pi, int_val, ret_int_ptr);
		} else if (ISLCN40PHY(pi)) {
			wlc_lcn40phy_iovar_txpwrctrl(pi, int_val, ret_int_ptr);
		}
	}

end:
	return err;
}

static int
wlc_phy_iovar_txpwrindex_get(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr)
{
	int err = BCME_OK;

	if (ISNPHY(pi)) {

		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
			(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
			OSL_DELAY(1);
		}

		*ret_int_ptr = wlc_phy_txpwr_idx_get_nphy(pi);

		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);

	} else if (ISHTPHY(pi)) {
		*ret_int_ptr = wlc_phy_txpwr_idx_get_htphy(pi);
	} else if (ISACPHY(pi)) {
		*ret_int_ptr = wlc_phy_txpwr_idx_get_acphy(pi);
	} else if (ISLPPHY(pi)) {
		phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;

		if (wlc_phy_tpc_isenabled_lpphy(pi)) {
			/* Update current power index */
			wlc_phy_tx_pwr_update_npt_lpphy(pi);
			*ret_int_ptr = pi_lp->lpphy_tssi_idx;
		} else
			*ret_int_ptr = pi_lp->lpphy_tx_power_idx_override;
	} else if (ISSSLPNPHY(pi)) {
		*ret_int_ptr = wlc_sslpnphy_txpwr_idx_get(pi);

	} else if (ISLCNPHY(pi))
		*ret_int_ptr = wlc_lcnphy_get_current_tx_pwr_idx(pi);
	else if (ISLCN40PHY(pi))
		*ret_int_ptr = wlc_lcn40phy_get_current_tx_pwr_idx(pi);
#if (defined(LCN20CONF) && (LCN20CONF != 0))
	else if (ISLCN20PHY(pi))
		*ret_int_ptr = wlc_lcn20phy_get_current_tx_pwr_idx(pi);
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
	return err;
}

static int
wlc_phy_iovar_txpwrindex_set(phy_info_t *pi, void *p)
{
	int err = BCME_OK;
	uint32 txpwridx[PHY_CORE_MAX] = { 0x30 };
	int8 idx, core;
	int8 siso_int_val;
	phy_info_nphy_t *pi_nphy = NULL;
#if defined(PHYCAL_CACHING)
	ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif

	if (ISNPHY(pi))
		pi_nphy = pi->u.pi_nphy;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	bcopy(p, txpwridx, PHY_CORE_MAX * sizeof(uint32));
	siso_int_val = (int8)(txpwridx[0] & 0xff);

	if (ISNPHY(pi)) {
		FOREACH_CORE(pi, core) {
			idx = (int8)(txpwridx[core] & 0xff);
			pi_nphy->nphy_txpwrindex[core].index_internal = idx;
			wlc_phy_store_txindex_nphy(pi);
			wlc_phy_txpwr_index_nphy(pi, (1 << core), idx, TRUE);
		}
	} else if (ISHTPHY(pi)) {
		FOREACH_CORE(pi, core) {
			idx = (int8)(txpwridx[core] & 0xff);
			wlc_phy_txpwr_by_index_htphy(pi, (1 << core), idx);
		}
	} else if (ISACPHY(pi)) {
		FOREACH_CORE(pi, core) {
			idx = (int8)(txpwridx[core] & 0xff);
			/* XXX: wlc_phy_txpwrctrl_enable_acphy can be moved into
			 * wlc_phy_txpwr_by_index_acphy
			 */
			wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
			wlc_phy_txpwr_by_index_acphy(pi, (1 << core), idx);
		}
	} else if (ISLPPHY(pi)) {
		if (siso_int_val == -1) {
#if defined(PHYCAL_CACHING)
			ASSERT(ctx);
			wlc_phy_set_tx_pwr_ctrl_lpphy(pi, LPPHY_TX_PWR_CTRL_HW);
			/* Reset calibration */
			ctx->valid = FALSE;
#else
			phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;
			wlc_phy_set_tx_pwr_ctrl_lpphy(pi, LPPHY_TX_PWR_CTRL_HW);
			/* Reset calibration */
			pi_lp->lpphy_full_cal_channel = 0;
#endif // endif
			pi->phy_forcecal = TRUE;
		} else if (siso_int_val >= 0) {
			wlc_phy_set_tx_pwr_by_index_lpphy(pi, siso_int_val);
		} else {
			err = BCME_RANGE;
		}
	} else if (ISSSLPNPHY(pi)) {
		phy_info_sslpnphy_t *ph = pi->u.pi_sslpnphy;
		if (siso_int_val == -1) {
			wlc_sslpnphy_set_tx_pwr_ctrl(pi, SSLPNPHY_TX_PWR_CTRL_HW);
			/* Reset calibration */
			ph->sslpnphy_full_cal_channel[CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0] = 0;
			pi->phy_forcecal = TRUE;
		} else if (siso_int_val >= 0) {
			wlc_sslpnphy_set_tx_pwr_by_index(pi, siso_int_val);
		} else {
			err = BCME_RANGE;
		}
	} else if (ISLCNCOMMONPHY(pi)) {
#if defined(PHYCAL_CACHING)
		err = wlc_iovar_txpwrindex_set_lcncommon(pi, siso_int_val, ctx);
#else
		err = wlc_iovar_txpwrindex_set_lcncommon(pi, siso_int_val);
#endif // endif
	}

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	return err;
}

static void
wlc_phy_iovar_tx_tone(phy_info_t *pi, int32 int_val)
{
	pi->phy_tx_tone_freq = (int32) int_val;

	if (pi->phy_tx_tone_freq == 0) {
		if (ISNPHY(pi)) {
			/* Restore back PAPD settings after stopping the tone */
			if (NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV))
				wlc_phy_papd_enable_nphy(pi, TRUE);
			/* FIXME4324. Dont know why only 4324 hangs if mac is not suspended */
			if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_stopplayback_nphy(pi);
			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
			if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
				wlapi_enable_mac(pi->sh->physhim);
		} else if (ISACPHY(pi)) {
			wlc_phy_stopplayback_acphy(pi);
			wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
			wlapi_enable_mac(pi->sh->physhim);
		} else if (ISHTPHY(pi)) {
			wlc_phy_stopplayback_htphy(pi);
			wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
		} else if (ISLCNPHY(pi)) {
			wlc_lcnphy_stop_tx_tone(pi);
		} else if (ISLCN40PHY(pi)) {
			wlc_lcn40phy_stop_tx_tone(pi);
			wlapi_enable_mac(pi->sh->physhim);
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		} else if (ISLCN20PHY(pi)) {
			wlc_lcn20phy_stop_tx_tone(pi);
			wlapi_enable_mac(pi->sh->physhim);
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
		}
	} else {
		if (ISNPHY(pi)) {
			/* use 151 since that should correspond to nominal tx output power */
			/* Can not play tone with papd bit enabled */
			if (NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV))
				wlc_phy_papd_enable_nphy(pi, FALSE);
			if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
			wlc_phy_tx_tone_nphy(pi, (uint32)int_val, 151, 0, 0, TRUE); /* play tone */
			if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
				wlapi_enable_mac(pi->sh->physhim);
		} else if (ISACPHY(pi)) {
			pi->phy_tx_tone_freq = pi->phy_tx_tone_freq * 1000; /* Covert to Hz */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
			wlc_phy_tx_tone_acphy(pi, (int32)int_val, 151, 0, 0, TRUE);
		} else if (ISHTPHY(pi)) {
			wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
			wlc_phy_tx_tone_htphy(pi, (uint32)int_val, 151, 0, 0, TRUE); /* play tone */
		} else if (ISLCNPHY(pi)) {
			pi->phy_tx_tone_freq = pi->phy_tx_tone_freq * 1000; /* Covert to Hz */
			wlc_lcnphy_set_tx_tone_and_gain_idx(pi);
		} else if (ISLCN40PHY(pi)) {
			pi->phy_tx_tone_freq = pi->phy_tx_tone_freq * 1000; /* Covert to Hz */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_lcn40phy_set_tx_tone_and_gain_idx(pi);
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		} else if (ISLCN20PHY(pi)) {
			pi->phy_tx_tone_freq = pi->phy_tx_tone_freq * 1000; /* Covert to Hz */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_lcn20phy_set_tx_tone_and_gain_idx(pi);
#endif /* #if (defined(LCN20CONF) && (LCN20CONF != 0)) */
		}
	}
}

static void
wlc_phy_iovar_tx_tone_hz(phy_info_t *pi, int32 int_val)
{
	pi->phy_tx_tone_freq = (int32) int_val;

	if (ISLCNPHY(pi)) {
		wlc_lcnphy_set_tx_tone_and_gain_idx(pi);
	} else if (ISLCN40PHY(pi)) {
		wlc_lcn40phy_set_tx_tone_and_gain_idx(pi);
	}
}

static void
wlc_phy_iovar_tx_tone_stop(phy_info_t *pi)
{
	if (ISLCNPHY(pi)) {
		wlc_lcnphy_stop_tx_tone(pi);
	} else if (ISLCN40PHY(pi)) {
		wlc_lcn40phy_stop_tx_tone(pi);
	}
}

#endif // endif

#if defined(WLTEST)
static int
wlc_phy_iovar_txrx_chain(phy_info_t *pi, int32 int_val, int32 *ret_int_ptr, bool set)
{
	int err = BCME_OK;

	if (ISHTPHY(pi))
		return BCME_UNSUPPORTED;

	if (!set) {
		if (ISNPHY(pi)) {
			*ret_int_ptr = (int)pi->nphy_txrx_chain;
		}
	} else {
		if (ISNPHY(pi)) {
			if ((int_val != AUTO) && (int_val != WLC_N_TXRX_CHAIN0) &&
				(int_val != WLC_N_TXRX_CHAIN1)) {
				err = BCME_RANGE;
				goto end;
			}

			if (pi->nphy_txrx_chain != (int8)int_val) {
				pi->nphy_txrx_chain = (int8)int_val;
				if (pi->sh->up) {
					wlapi_suspend_mac_and_wait(pi->sh->physhim);
					wlc_phyreg_enter((wlc_phy_t *)pi);
					wlc_phy_stf_chain_upd_nphy(pi);
					wlc_phy_force_rfseq_nphy(pi, NPHY_RFSEQ_RESET2RX);
					wlc_phyreg_exit((wlc_phy_t *)pi);
					wlapi_enable_mac(pi->sh->physhim);
				}
			}
		}
	}
end:
	return err;
}

static void
wlc_phy_iovar_bphy_testpattern(phy_info_t *pi, uint8 testpattern, bool enable)
{
	bool existing_enable = FALSE;

	/* WL out check */
	if (pi->sh->up) {
		PHY_ERROR(("wl%d: %s: This function needs to be called after 'wl out'\n",
		          pi->sh->unit, __FUNCTION__));
		return;
	}

	/* confirm band is locked to 2G */
	if (!CHSPEC_IS2G(pi->radio_chanspec)) {
		PHY_ERROR(("wl%d: %s: Band needs to be locked to 2G (b)\n",
		          pi->sh->unit, __FUNCTION__));
		return;
	}

	if ((ISNPHY(pi) && NREV_LT(pi->pubpi.phy_rev, 2)) || ISHTPHY(pi)) {
		PHY_ERROR(("wl%d: %s: This function is supported only for NPHY PHY_REV > 1\n",
		          pi->sh->unit, __FUNCTION__));
		return;
	}

	if (testpattern == NPHY_TESTPATTERN_BPHY_EVM) {    /* CW CCK for EVM testing */
		existing_enable = (bool) pi->phy_bphy_evm;
	} else if (testpattern == NPHY_TESTPATTERN_BPHY_RFCS) { /* RFCS testpattern */
		existing_enable = (bool) pi->phy_bphy_rfcs;
	} else {
		PHY_ERROR(("Testpattern needs to be between [0 (BPHY_EVM), 1 (BPHY_RFCS)]\n"));
		ASSERT(0);
	}

	if (ISNPHY(pi)) {
		wlc_phy_bphy_testpattern_nphy(pi, testpattern, enable, existing_enable);
	} else {
		PHY_ERROR(("support yet to be added\n"));
		ASSERT(0);
	}

	/* Return state of testpattern enables */
	if (testpattern == NPHY_TESTPATTERN_BPHY_EVM) {    /* CW CCK for EVM testing */
		pi->phy_bphy_evm = enable;
	} else if (testpattern == NPHY_TESTPATTERN_BPHY_RFCS) { /* RFCS testpattern */
		pi->phy_bphy_rfcs = enable;
	}
}

static void
wlc_phy_iovar_scraminit(phy_info_t *pi, int8 scraminit)
{
	pi->phy_scraminit = (int8)scraminit;
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if (ISNPHY(pi)) {
		wlc_phy_test_scraminit_nphy(pi, scraminit);
	} else if (ISHTPHY(pi)) {
		wlc_phy_test_scraminit_htphy(pi, scraminit);
	} else if (ISACPHY(pi)) {
		wlc_phy_test_scraminit_acphy(pi, scraminit);
	} else {
		PHY_ERROR(("support yet to be added\n"));
		ASSERT(0);
	}

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}

static void
wlc_phy_iovar_force_rfseq(phy_info_t *pi, uint8 int_val)
{
	wlc_phyreg_enter((wlc_phy_t *)pi);
	if (ISNPHY(pi)) {
		wlc_phy_force_rfseq_nphy(pi, int_val);
	} else if (ISHTPHY(pi)) {
		wlc_phy_force_rfseq_htphy(pi, int_val);
	}
	wlc_phyreg_exit((wlc_phy_t *)pi);
}

static int16
wlc_phy_iovar_test_tssi(phy_info_t *pi, uint8 val, uint8 pwroffset)
{
	int16 tssi = 0;
	if (ISNPHY(pi)) {
		tssi = (int16) wlc_phy_test_tssi_nphy(pi, val, pwroffset);
	} else if (ISHTPHY(pi)) {
		tssi = (int16) wlc_phy_test_tssi_htphy(pi, val, pwroffset);
	} else if (ISACPHY(pi)) {
		tssi = (int16) wlc_phy_test_tssi_acphy(pi, val, pwroffset);
	}
	return tssi;
}

static int16
wlc_phy_iovar_test_idletssi(phy_info_t *pi, uint8 val)
{
	int16 idletssi = INVALID_IDLETSSI_VAL;
	if (ISACPHY(pi)) {
		idletssi = (int16) wlc_phy_test_idletssi_acphy(pi, val);
	}
	return idletssi;
}

static int16
wlc_phy_iovar_setrptbl(phy_info_t *pi)
{
	if (ISACPHY(pi) && (!ACMAJORREV_1(pi->pubpi.phy_rev))) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_populate_recipcoeffs_acphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		return 0;
	}

	return BCME_UNSUPPORTED;
}

static int16
wlc_phy_iovar_forceimpbf(phy_info_t *pi)
{
	if (ISACPHY(pi) && (!ACMAJORREV_1(pi->pubpi.phy_rev))) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		phy_reg_write(pi, ACPHY_BfeConfigReg0(pi->pubpi.phy_rev), BFECONFIGREF_FORCEVAL);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		return 0;
	}

	return BCME_UNSUPPORTED;
}

static int16
wlc_phy_iovar_forcesteer(phy_info_t *pi, uint8 enable)
{
#if ACCONF != 0
	uint16 bfmcon_val      = 0;
	uint16 bfridx_pos_val  = 0;
	uint16 refresh_thr_val = 0;
	uint16 shm_base, addr1, addr2;

	if (ISACPHY(pi) && (!ACMAJORREV_1(pi->pubpi.phy_rev))) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);

		bfmcon_val      = enable ? BFMCON_FORCEVAL      : BFMCON_RELEASEVAL;
		bfridx_pos_val  = enable ? BFRIDX_POS_FORCEVAL  : BFRIDX_POS_RELEASEVAL;
		refresh_thr_val = enable ? REFRESH_THR_FORCEVAL : REFRESH_THR_RELEASEVAL;

		shm_base = wlapi_bmac_read_shm(pi->sh->physhim, M_BFI_BLK_PTR);
		addr1 = (shm_base + M_BFI_REFRESH_THR_OFFSET) * 2;
		addr2 = (shm_base + C_BFI_BFRIDX_POS)* 2;

		phy_reg_write(pi, ACPHY_BfmCon(pi->pubpi.phy_rev), bfmcon_val);
		wlapi_bmac_write_shm(pi->sh->physhim, addr1, refresh_thr_val);
		wlapi_bmac_write_shm(pi->sh->physhim, addr2, bfridx_pos_val);

		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		return 0;
	}
#endif /* ACCONF != 0 && WL_BEAMFORMING */

	return BCME_UNSUPPORTED;
}

static void
wlc_phy_iovar_rxcore_enable(phy_info_t *pi, int32 int_val, bool bool_val, int32 *ret_int_ptr,
	bool set)
{
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if (set) {
		if (ISNPHY(pi)) {
			wlc_phy_rxcore_setstate_nphy((wlc_phy_t *)pi, (uint8) int_val, 0);
		} else if (ISHTPHY(pi)) {
			wlc_phy_rxcore_setstate_htphy((wlc_phy_t *)pi, (uint8) int_val);
		} else if (ISACPHY(pi)) {
			wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, (uint8) int_val);
		}
	} else {
		if (ISNPHY(pi)) {
			*ret_int_ptr =  (uint32)wlc_phy_rxcore_getstate_nphy((wlc_phy_t *)pi);
		} else if (ISHTPHY(pi)) {
			*ret_int_ptr =  (uint32)wlc_phy_rxcore_getstate_htphy((wlc_phy_t *)pi);
		} else if (ISACPHY(pi)) {
			*ret_int_ptr =  (uint32)wlc_phy_rxcore_getstate_acphy((wlc_phy_t *)pi);
		}
	}

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}

#endif // endif

static int
wlc_phy_iovar_set_btc_restage_rxgain(phy_info_t *pi, int32 set_val)
{
	int err = BCME_OK;

	if (ISHTPHY(pi) && (IS_X29B_BOARDTYPE(pi) ||
	                    IS_X29D_BOARDTYPE(pi) || IS_X33_BOARDTYPE(pi))) {
		phy_info_htphy_t *pi_ht = (phy_info_htphy_t *)pi->u.pi_htphy;

		if ((set_val < 0) || (set_val > 1)) {
			return BCME_RANGE;
		}
		if (SCAN_RM_IN_PROGRESS(pi)) {
			return BCME_NOTREADY;
		}
		if (IS_X29B_BOARDTYPE(pi)) {
			/* XXX
			 * Ensure no other code is tampering with init gain
			 */
			if ((pi->sh->interference_mode != INTERFERE_NONE) &&
			     (pi->sh->interference_mode != NON_WLAN)) {
				return BCME_UNSUPPORTED;
			}
		}
		if ((IS_X29D_BOARDTYPE(pi) || IS_X33_BOARDTYPE(pi)) &&
		    !CHSPEC_IS2G(pi->radio_chanspec)) {
			return BCME_BADBAND;
		}

		if (((set_val == 0) && pi_ht->btc_restage_rxgain) ||
		    ((set_val == 1) && !pi_ht->btc_restage_rxgain)) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_btc_restage_rxgain_htphy(pi, (bool)set_val);
			wlapi_enable_mac(pi->sh->physhim);
		}
	} else if (ISACPHY(pi)) {
#ifndef WLC_DISABLE_ACI
		phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
#endif /* !WLC_DISABLE_ACI */
		if ((set_val < 0) || ((set_val > 6) && (set_val < 12)) ||
		    ((set_val > 12) && (set_val < 21)) || (set_val > 23)) {
			return BCME_RANGE;
		}
		if (SCAN_RM_IN_PROGRESS(pi)) {
			return BCME_NOTREADY;
		}
#ifndef WLC_DISABLE_ACI
		if (((set_val == 0) && (pi_ac->btc_mode != 0)) ||
		    ((set_val != 0) && (pi_ac->btc_mode != set_val))) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_desense_btcoex_acphy(pi, set_val);
			wlapi_enable_mac(pi->sh->physhim);
		}
#endif /* !WLC_DISABLE_ACI */
	} else if (CHIPID_4324X_MEDIA_FAMILY(pi)) {

		const uint8 num_dev_thres = 2;	/* Make configurable later */
		uint16 num_bt_devices;

		/* pi->bt_shm_addr is set by phy_init */
		if (pi->bt_shm_addr == 0) {
			return BCME_NOTUP;
		}

		/* Read number of BT task and desense configuration for SHM */
		num_bt_devices  = wlapi_bmac_read_shm(pi->sh->physhim,
			pi->bt_shm_addr + M_BTCX_NUM_TASKS);

		/* If more than num_dev_thres (two) tasks, no interference override
		 * and not already in manual ACI override mode
		 */
		if ((num_dev_thres > 0) && (num_bt_devices >= num_dev_thres) &&
			(!pi->sh->interference_mode_override) &&
			(pi->sh->interference_mode != WLAN_MANUAL)) {

			wlc_phy_set_interference_override_mode(pi, WLAN_MANUAL);

		} else if ((num_bt_devices < num_dev_thres) &&
			(pi->sh->interference_mode_override)) {

			wlc_phy_set_interference_override_mode(pi, INTERFERE_OVRRIDE_OFF);
		}
		/* Return "not BCME_OK" so that this function will be called every time
		 * wlc_btcx_watchdog is called
		 */
		err = BCME_BUSY;

	} else {
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovar_get_btc_restage_rxgain(phy_info_t *pi, int32 *ret_val)
{
	if (ISHTPHY(pi) && (IS_X29B_BOARDTYPE(pi) || IS_X29D_BOARDTYPE(pi) ||
	                    IS_X33_BOARDTYPE(pi))) {
		if ((IS_X29D_BOARDTYPE(pi) || IS_X33_BOARDTYPE(pi)) &&
		    !CHSPEC_IS2G(pi->radio_chanspec)) {
			return BCME_BADBAND;
		}
		*ret_val = (int32)pi->u.pi_htphy->btc_restage_rxgain;
		return BCME_OK;
	} else if (ISACPHY(pi)) {
	  *ret_val = (int32)pi->u.pi_acphy->btc_mode;
		return BCME_OK;
	} else
		return BCME_UNSUPPORTED;
}

static int
wlc_phy_iovar_set_dssf(phy_info_t *pi, int32 set_val)
{
	if (ISACPHY(pi) && PHY_ILNA(pi)) {
		phy_reg_write(pi, ACPHY_DSSF_C_CTRL(pi->pubpi.phy_rev), (uint16) set_val);

		return BCME_OK;
	}

	return BCME_UNSUPPORTED;
}

static int
wlc_phy_iovar_get_dssf(phy_info_t *pi, int32 *ret_val)
{
	if (ISACPHY(pi) && PHY_ILNA(pi)) {
		*ret_val = (int32) phy_reg_read(pi, ACPHY_DSSF_C_CTRL(pi->pubpi.phy_rev));

		return BCME_OK;
	}

	return BCME_UNSUPPORTED;
}

/* handler for iovar modules */
typedef int (*iovar_module_t)(phy_info_t *pi, uint32 actionid, uint16 type, void *p,
	uint plen, void *a, int alen, int vsize);

/* Dispatch phy iovars */
int
#ifndef PHYMOD3_TRUNK_MERGE
wlc_phy_iovar_dispatch(wlc_phy_t *pih, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
#else
wlc_phy_iovar_dispatch(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
#endif // endif
{
#ifndef PHYMOD3_TRUNK_MERGE
	phy_info_t *pi = (phy_info_t*)pih;
#endif // endif
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;

	iovar_module_t iovar_module_list[] = {
		wlc_phy_iovars_generic,
		wlc_phy_iovars_aci,
		wlc_phy_iovars_rssi,
		wlc_phy_iovars_calib,
#ifndef PHYMOD3_TRUNK_MERGE
		wlc_phy_iovars_radar,
#endif // endif
		wlc_phy_iovars_txpwrctl,
		wlc_phy_iovars_phy_specific,
#ifdef SAMPLE_COLLECT
		wlc_phy_iovars_sample_collect,
#endif // endif
		NULL
	};

	iovar_module_t *module;
	module = iovar_module_list;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(bool_val);

	do {
		err = (*module)(pi, actionid, type, p, plen, a, alen, vsize);
		++module;
	} while ((*module != NULL) && (err == BCME_UNSUPPORTED));

	if (err == BCME_UNSUPPORTED)
		err = wlc_phy_iovar_dispatch_old(pi, actionid, p, a, vsize, int_val, bool_val);

	return err;
}

/* OLD PHYTYPE specific iovars, to be phased out gradually,
 * do NOT add more. Instead, share, expand or create unified ones in wlc_phy_iovar_dispatch
 * XXX to reorganize and consolidate
 */
static int
wlc_phy_iovar_dispatch_old(phy_info_t *pi, uint32 actionid, void *p, void *a, int vsize,
	int32 int_val, bool bool_val)
{
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	phy_info_lpphy_t *pi_lp;
	phy_info_nphy_t *pi_nphy;

	pi_lp = pi->u.pi_lpphy;
	pi_nphy = pi->u.pi_nphy;
	BCM_REFERENCE(pi_lp);
	BCM_REFERENCE(pi_nphy);
	BCM_REFERENCE(ret_int_ptr);

	switch (actionid) {
#if NCONF
#if defined(BCMDBG)
	case IOV_SVAL(IOV_NPHY_INITGAIN):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_setinitgain_nphy(pi, (uint16) int_val);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;

	case IOV_SVAL(IOV_NPHY_HPVGA1GAIN):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_sethpf1gaintbl_nphy(pi, (int8) int_val);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;

	case IOV_SVAL(IOV_NPHY_TX_TEMP_TONE): {
		uint16 orig_BBConfig;
		uint16 m0m1;
		nphy_txgains_t target_gain;

		if ((uint32)int_val > 0) {
			pi->phy_tx_tone_freq = (uint32) int_val;
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);

			/* Save the bbmult values,since it gets overwritten by mimophy_tx_tone() */
			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);

			/* Disable the re-sampler (in case we are in spur avoidance mode) */
			orig_BBConfig = phy_reg_read(pi, NPHY_BBConfig);
			phy_reg_mod(pi, NPHY_BBConfig, NPHY_BBConfig_resample_clk160_MASK, 0);

			/* read current tx gain and use as target_gain */
			wlc_phy_get_tx_gain_nphy(pi, &target_gain);

			PHY_ERROR(("Tx gain core 0: target gain: ipa = %d,"
			         " pad = %d, pga = %d, txgm = %d, txlpf = %d\n",
			         target_gain.ipa[0], target_gain.pad[0], target_gain.pga[0],
			         target_gain.txgm[0], target_gain.txlpf[0]));

			PHY_ERROR(("Tx gain core 1: target gain: ipa = %d,"
			         " pad = %d, pga = %d, txgm = %d, txlpf = %d\n",
			         target_gain.ipa[0], target_gain.pad[1], target_gain.pga[1],
			         target_gain.txgm[1], target_gain.txlpf[1]));

			/* play a tone for 10 secs and then stop it and return */
			wlc_phy_tx_tone_nphy(pi, (uint32)int_val, 250, 0, 0, FALSE);

			/* Now restore the original bbmult values */
			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m0m1);
			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);

			OSL_DELAY(10000000);
			wlc_phy_stopplayback_nphy(pi);

			/* Restore the state of the re-sampler
			   (in case we are in spur avoidance mode)
			*/
			phy_reg_write(pi, NPHY_BBConfig, orig_BBConfig);

			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);
		}
		break;
	}
	case IOV_SVAL(IOV_NPHY_CAL_RESET):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		wlc_phy_cal_reset_nphy(pi, (uint32) int_val);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;

	case IOV_GVAL(IOV_NPHY_EST_TONEPWR):
	case IOV_GVAL(IOV_PHY_EST_TONEPWR): {
		int32 dBm_power[2];
		uint16 orig_BBConfig;
		uint16 m0m1;

		if (ISNPHY(pi)) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);

			/* Save the bbmult values, since it gets overwritten
			   by mimophy_tx_tone()
			*/
			wlc_phy_table_read_nphy(pi, 15, 1, 87, 16, &m0m1);

			/* Disable the re-sampler (in case we are in spur avoidance mode) */
			orig_BBConfig = phy_reg_read(pi, NPHY_BBConfig);
			phy_reg_mod(pi, NPHY_BBConfig, NPHY_BBConfig_resample_clk160_MASK, 0);
			pi->phy_tx_tone_freq = (uint32) 4000;

			/* play a tone for 10 secs */
			wlc_phy_tx_tone_nphy(pi, (uint32)4000, 250, 0, 0, FALSE);

			/* Now restore the original bbmult values */
			wlc_phy_table_write_nphy(pi, 15, 1, 87, 16, &m0m1);
			wlc_phy_table_write_nphy(pi, 15, 1, 95, 16, &m0m1);

			OSL_DELAY(10000000);
			wlc_phy_est_tonepwr_nphy(pi, dBm_power, 128);
			wlc_phy_stopplayback_nphy(pi);

			/* Restore the state of the re-sampler
			   (in case we are in spur avoidance mode)
			*/
			phy_reg_write(pi, NPHY_BBConfig, orig_BBConfig);

			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);

			int_val = dBm_power[0]/4;
			bcopy(&int_val, a, vsize);
			break;
		} else {
			err = BCME_UNSUPPORTED;
			break;
		}
	}

	case IOV_GVAL(IOV_NPHY_RFSEQ_TXGAIN): {
		uint16 rfseq_tx_gain[2];
		wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_RFSEQ, 2, 0x110, 16, rfseq_tx_gain);
		int_val = (((uint32) rfseq_tx_gain[1] << 16) | ((uint32) rfseq_tx_gain[0]));
		bcopy(&int_val, a, vsize);
		break;
	}

	case IOV_SVAL(IOV_PHY_SPURAVOID):
		if ((int_val != SPURAVOID_DISABLE) && (int_val != SPURAVOID_AUTO) &&
		    (int_val != SPURAVOID_FORCEON) && (int_val != SPURAVOID_FORCEON2)) {
			err = BCME_RANGE;
			break;
		}

		pi->phy_spuravoid = (int8)int_val;
		break;

	case IOV_GVAL(IOV_PHY_SPURAVOID):
		int_val = pi->phy_spuravoid;
		bcopy(&int_val, a, vsize);
		break;
#endif /* defined(BCMDBG) */

#if defined(WLTEST)
	case IOV_GVAL(IOV_NPHY_CCK_PWR_OFFSET):
		if (ISNPHY(pi)) {
			int_val =  pi_nphy->nphy_cck_pwr_err_adjust;
			bcopy(&int_val, a, vsize);
		}
		break;
	case IOV_GVAL(IOV_NPHY_CAL_SANITY):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		*ret_int_ptr = (uint32)wlc_phy_cal_sanity_nphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;

	case IOV_GVAL(IOV_NPHY_BPHY_EVM):
	case IOV_GVAL(IOV_PHY_BPHY_EVM):

		*ret_int_ptr = pi->phy_bphy_evm;
		break;

	case IOV_SVAL(IOV_NPHY_BPHY_EVM):
		wlc_phy_iovar_bphy_testpattern(pi, NPHY_TESTPATTERN_BPHY_EVM, (bool) int_val);
		break;

	case IOV_GVAL(IOV_NPHY_BPHY_RFCS):
		*ret_int_ptr = pi->phy_bphy_rfcs;
		break;

	case IOV_SVAL(IOV_NPHY_BPHY_RFCS):
		wlc_phy_iovar_bphy_testpattern(pi, NPHY_TESTPATTERN_BPHY_RFCS, (bool) int_val);
		break;

	case IOV_GVAL(IOV_NPHY_SCRAMINIT):
		*ret_int_ptr = pi->phy_scraminit;
		break;

	case IOV_SVAL(IOV_NPHY_SCRAMINIT):
		wlc_phy_iovar_scraminit(pi, pi->phy_scraminit);
		break;

	case IOV_SVAL(IOV_NPHY_RFSEQ):
		wlc_phy_iovar_force_rfseq(pi, (uint8)int_val);
		break;

	case IOV_GVAL(IOV_NPHY_TXIQLOCAL): {
		nphy_txgains_t target_gain;
		uint8 tx_pwr_ctrl_state;
		if (ISNPHY(pi)) {

			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);

			/* read current tx gain and use as target_gain */
			wlc_phy_get_tx_gain_nphy(pi, &target_gain);
			tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
			wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);

			/* want outer (0,1) ants so T/R works properly for CB2 2x3 switch, */
			if (pi->antsel_type == ANTSEL_2x3) {
				wlc_phy_antsel_init_nphy((wlc_phy_t *)pi, TRUE);
			}

			err = wlc_phy_cal_txiqlo_nphy(pi, target_gain, TRUE, FALSE);
			if (err)
				break;
			wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);
		}
		*ret_int_ptr = 0;
		break;
	}
	case IOV_SVAL(IOV_NPHY_RXIQCAL): {
		nphy_txgains_t target_gain;
		uint8 tx_pwr_ctrl_state;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);

		/* read current tx gain and use as target_gain */
		wlc_phy_get_tx_gain_nphy(pi, &target_gain);
		tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
		wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);
#ifdef RXIQCAL_FW_WAR
		if (wlc_phy_cal_rxiq_nphy_fw_war(pi, target_gain, 0, (bool)int_val, 0x3) != BCME_OK)
#else
		if (wlc_phy_cal_rxiq_nphy(pi, target_gain, 0, (bool)int_val, 0x3) != BCME_OK)
#endif // endif
		{
			break;
		}
		wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		int_val = 0;
		bcopy(&int_val, a, vsize);
		break;
	}
	case IOV_GVAL(IOV_NPHY_RXCALPARAMS):
		if (ISNPHY(pi)) {
			*ret_int_ptr = pi_nphy->nphy_rxcalparams;
		}
		break;

	case IOV_SVAL(IOV_NPHY_RXCALPARAMS):
		if (ISNPHY(pi)) {
			pi_nphy->nphy_rxcalparams = (uint32)int_val;
		}
		break;

	case IOV_GVAL(IOV_NPHY_TXPWRCTRL):
		wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_NPHY_TXPWRCTRL):
		err = wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_NPHY_RSSISEL):
		*ret_int_ptr = pi->nphy_rssisel;
		break;

	case IOV_SVAL(IOV_NPHY_RSSISEL):
		pi->nphy_rssisel = (uint8)int_val;

		if (!pi->sh->up)
			break;

		if (pi->nphy_rssisel < 0) {
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_phy_rssisel_nphy(pi, RADIO_MIMO_CORESEL_OFF, 0);
			wlc_phyreg_exit((wlc_phy_t *)pi);
		} else {
			int32 rssi_buf[4];
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_phy_poll_rssi_nphy(pi, (uint8)int_val, rssi_buf, 1);
			wlc_phyreg_exit((wlc_phy_t *)pi);
		}
		break;

	case IOV_GVAL(IOV_NPHY_RSSICAL): {
		/* if down, return the value, if up, run the cal */
		if (!pi->sh->up) {
			int_val = pi->nphy_rssical;
			bcopy(&int_val, a, vsize);
			break;
		}

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		/* run rssi cal */
		wlc_phy_rssi_cal_nphy(pi);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		int_val = pi->nphy_rssical;
		bcopy(&int_val, a, vsize);
		break;
	}

	case IOV_SVAL(IOV_NPHY_RSSICAL): {
		pi->nphy_rssical = bool_val;
		break;
	}

	case IOV_GVAL(IOV_NPHY_GPIOSEL):
	case IOV_GVAL(IOV_PHY_GPIOSEL):
		*ret_int_ptr = pi->phy_gpiosel;
		break;

	case IOV_SVAL(IOV_NPHY_GPIOSEL):
	case IOV_SVAL(IOV_PHY_GPIOSEL):
		pi->phy_gpiosel = (uint16) int_val;

		if (!pi->sh->up)
			break;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
		if (ISNPHY(pi))
			wlc_phy_gpiosel_nphy(pi, (uint16)int_val);
		else if (ISHTPHY(pi))
			wlc_phy_gpiosel_htphy(pi, (uint16)int_val);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;

	case IOV_GVAL(IOV_NPHY_TX_TONE):
		*ret_int_ptr = pi->phy_tx_tone_freq;
		break;

	case IOV_SVAL(IOV_NPHY_TX_TONE):
		wlc_phy_iovar_tx_tone(pi, (uint32)int_val);
		break;

	case IOV_SVAL(IOV_NPHY_GAIN_BOOST):
		pi->nphy_gain_boost = bool_val;
		break;

	case IOV_GVAL(IOV_NPHY_GAIN_BOOST):
		*ret_int_ptr = (int32)pi->nphy_gain_boost;
		break;

	case IOV_SVAL(IOV_NPHY_ELNA_GAIN_CONFIG):
		pi->nphy_elna_gain_config = (int_val != 0) ? TRUE : FALSE;
		break;

	case IOV_GVAL(IOV_NPHY_ELNA_GAIN_CONFIG):
		*ret_int_ptr = (int32)pi->nphy_elna_gain_config;
		break;

	case IOV_GVAL(IOV_NPHY_TEST_TSSI):
		*((uint*)a) = wlc_phy_iovar_test_tssi(pi, (uint8)int_val, 0);
		break;

	case IOV_GVAL(IOV_NPHY_TEST_TSSI_OFFS):
		*((uint*)a) = wlc_phy_iovar_test_tssi(pi, (uint8)int_val, 12);
		break;

#ifdef BAND5G
	case IOV_SVAL(IOV_NPHY_5G_PWRGAIN):
		pi->phy_5g_pwrgain = bool_val;
		break;

	case IOV_GVAL(IOV_NPHY_5G_PWRGAIN):
		*ret_int_ptr = (int32)pi->phy_5g_pwrgain;
		break;
#endif /* BAND5G */

	case IOV_GVAL(IOV_NPHY_PERICAL):
		wlc_phy_iovar_perical_config(pi, int_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_NPHY_PERICAL):
		wlc_phy_iovar_perical_config(pi, int_val, ret_int_ptr, TRUE);
		break;

	case IOV_SVAL(IOV_NPHY_FORCECAL):
		err = wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, TRUE);
		break;

#ifndef WLC_DISABLE_ACI
	case IOV_GVAL(IOV_NPHY_ACI_SCAN):
		if (SCAN_INPROG_PHY(pi)) {
			PHY_ERROR(("Scan in Progress, can execute %s\n", __FUNCTION__));
			*ret_int_ptr = -1;
		} else {
			if (pi->cur_interference_mode == INTERFERE_NONE) {
				PHY_ERROR(("interference mode is off\n"));
				*ret_int_ptr = -1;
				break;
			}

			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			*ret_int_ptr = wlc_phy_aci_scan_nphy(pi);
			wlapi_enable_mac(pi->sh->physhim);
		}
		break;
#endif /* Compiling out ACI code for 4324 */
	case IOV_SVAL(IOV_NPHY_ENABLERXCORE):
		wlc_phy_iovar_rxcore_enable(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_NPHY_ENABLERXCORE):
		wlc_phy_iovar_rxcore_enable(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_NPHY_PAPDCALTYPE):
		if (ISNPHY(pi))
			pi_nphy->nphy_papd_cal_type = (int8) int_val;
		break;

	case IOV_GVAL(IOV_NPHY_PAPDCAL):
		if (ISNPHY(pi))
			pi_nphy->nphy_force_papd_cal = TRUE;
		int_val = 0;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_NPHY_SKIPPAPD):
		if ((int_val != 0) && (int_val != 1)) {
			err = BCME_RANGE;
			break;
		}
		if (ISNPHY(pi))
			pi_nphy->nphy_papd_skip = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_NPHY_PAPDCALINDEX):
		if (ISNPHY(pi)) {
			*ret_int_ptr = (pi_nphy->nphy_papd_cal_gain_index[0] << 8) |
				pi_nphy->nphy_papd_cal_gain_index[1];
		}
		break;

	case IOV_SVAL(IOV_NPHY_CALTXGAIN): {
		uint8 tx_pwr_ctrl_state;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);

		if (ISNPHY(pi)) {
			pi_nphy->nphy_cal_orig_pwr_idx[0] =
				(uint8) ((phy_reg_read(pi, NPHY_Core0TxPwrCtrlStatus) >> 8) & 0x7f);
			pi_nphy->nphy_cal_orig_pwr_idx[1] =
				(uint8) ((phy_reg_read(pi, NPHY_Core1TxPwrCtrlStatus) >> 8) & 0x7f);
		}

		tx_pwr_ctrl_state = pi->nphy_txpwrctrl;
		wlc_phy_txpwrctrl_enable_nphy(pi, PHY_TPC_HW_OFF);

		wlc_phy_cal_txgainctrl_nphy(pi, int_val, TRUE);

		wlc_phy_txpwrctrl_enable_nphy(pi, tx_pwr_ctrl_state);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);

		break;
	}
#endif // endif
	case IOV_GVAL(IOV_PHY_TEMPTHRESH):
		*ret_int_ptr = (int32) pi->txcore_temp.disable_temp;
		break;

	case IOV_SVAL(IOV_PHY_TEMPTHRESH):
		pi->txcore_temp.disable_temp = MIN((uint8) int_val,
			pi->txcore_temp.disable_temp_max_cap);
		pi->txcore_temp.enable_temp =
		    pi->txcore_temp.disable_temp - pi->txcore_temp.hysteresis;
		break;

	case IOV_GVAL(IOV_CAL_PERIOD):
	        *ret_int_ptr = (int32)pi->cal_period;
	        break;

	case IOV_SVAL(IOV_CAL_PERIOD):
	        pi->cal_period = (uint32)int_val;
	        break;
#if defined(WLTEST)
	case IOV_GVAL(IOV_PHY_TEMPOFFSET):
		*ret_int_ptr = (int32) pi->phy_tempsense_offset;
		break;

	case IOV_SVAL(IOV_PHY_TEMPOFFSET):
		pi->phy_tempsense_offset = (int8) int_val;
		break;

	case IOV_GVAL(IOV_NPHY_VCOCAL):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phy_radio205x_vcocal_nphy(pi);
		wlapi_enable_mac(pi->sh->physhim);
		*ret_int_ptr = 0;
		break;

	case IOV_GVAL(IOV_NPHY_TBLDUMP_MINIDX):
		*ret_int_ptr = (int32)pi->nphy_tbldump_minidx;
		break;

	case IOV_SVAL(IOV_NPHY_TBLDUMP_MINIDX):
		pi->nphy_tbldump_minidx = (int8) int_val;
		break;

	case IOV_GVAL(IOV_NPHY_TBLDUMP_MAXIDX):
		*ret_int_ptr = (int32)pi->nphy_tbldump_maxidx;
		break;

	case IOV_SVAL(IOV_NPHY_TBLDUMP_MAXIDX):
		pi->nphy_tbldump_maxidx = (int8) int_val;
		break;

	case IOV_SVAL(IOV_NPHY_PHYREG_SKIPDUMP):
		if (pi->nphy_phyreg_skipcnt < 127) {
			pi->nphy_phyreg_skipaddr[pi->nphy_phyreg_skipcnt++] = (uint) int_val;
		}
		break;

	case IOV_GVAL(IOV_NPHY_PHYREG_SKIPDUMP):
		*ret_int_ptr = (pi->nphy_phyreg_skipcnt > 0) ?
			(int32) pi->nphy_phyreg_skipaddr[pi->nphy_phyreg_skipcnt-1] : 0;
		break;

	case IOV_SVAL(IOV_NPHY_PHYREG_SKIPCNT):
		pi->nphy_phyreg_skipcnt = (int8) int_val;
		break;

	case IOV_GVAL(IOV_NPHY_PHYREG_SKIPCNT):
		*ret_int_ptr = (int32)pi->nphy_phyreg_skipcnt;
		break;
#endif // endif
#endif /* NCONF */

#if defined(WLTEST)

#if LPCONF
	case IOV_SVAL(IOV_LPPHY_TX_TONE):
		pi->phy_tx_tone_freq = int_val;
		if (pi->phy_tx_tone_freq == 0) {
			wlc_phy_stop_tx_tone_lpphy(pi);
			wlc_phy_clear_deaf_lpphy(pi, (bool)1);
			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);
			pi->phywatchdog_override = TRUE;
		} else {
			pi->phywatchdog_override = FALSE;
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_phy_set_deaf_lpphy(pi, (bool)1);
			wlc_phy_start_tx_tone_lpphy(pi, int_val,
				LPREV_GE(pi->pubpi.phy_rev, 2) ? 28: 100); /* play tone */
		}
		break;

	case IOV_SVAL(IOV_LPPHY_PAPDCALTYPE):
		pi_lp->lpphy_papd_cal_type = (int16) int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_PAPDCAL):
		pi_lp->lpphy_force_papd_cal = TRUE;
		int_val = 0;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_GVAL(IOV_LPPHY_TXIQLOCAL):
	case IOV_GVAL(IOV_LPPHY_RXIQCAL):
		pi->phy_forcecal = TRUE;

		*ret_int_ptr = 0;
		break;

	case IOV_GVAL(IOV_LPPHY_FULLCAL):	/* conver to SVAL with parameters like NPHY ? */
		wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_GVAL(IOV_LPPHY_TXPWRCTRL):
		wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_LPPHY_TXPWRCTRL):
		err = wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_LPPHY_PAPD_SLOW_CAL):
		*ret_int_ptr = (uint32)pi_lp->lpphy_papd_slow_cal;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_SLOW_CAL): {
		pi_lp->lpphy_papd_slow_cal = bool_val;
		break;
	}

	case IOV_GVAL(IOV_LPPHY_PAPD_RECAL_MIN_INTERVAL):
		*ret_int_ptr = (int32)pi_lp->lpphy_papd_recal_min_interval;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_RECAL_MIN_INTERVAL):
		pi_lp->lpphy_papd_recal_min_interval = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_PAPD_RECAL_MAX_INTERVAL):
		*ret_int_ptr = (int32)pi_lp->lpphy_papd_recal_max_interval;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_RECAL_MAX_INTERVAL):
		pi_lp->lpphy_papd_recal_max_interval = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_PAPD_RECAL_GAIN_DELTA):
		*ret_int_ptr = (int32)pi_lp->lpphy_papd_recal_gain_delta;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_RECAL_GAIN_DELTA):
		pi_lp->lpphy_papd_recal_gain_delta = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_PAPD_RECAL_ENABLE):
		*ret_int_ptr = (uint32)pi_lp->lpphy_papd_recal_enable;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_RECAL_ENABLE):
		pi_lp->lpphy_papd_recal_enable = bool_val;
		break;

	case IOV_GVAL(IOV_LPPHY_PAPD_RECAL_COUNTER):
		*ret_int_ptr = (int32)pi_lp->lpphy_papd_recal_counter;
		break;

	case IOV_SVAL(IOV_LPPHY_PAPD_RECAL_COUNTER):
		pi_lp->lpphy_papd_recal_counter = (uint32)int_val;
		break;

	case IOV_SVAL(IOV_LPPHY_CCK_DIG_FILT_TYPE):
		pi_lp->lpphy_cck_dig_filt_type = (int16)int_val;
		if (LPREV_GE(pi->pubpi.phy_rev, 2))
			wlc_phy_tx_dig_filt_cck_setup_lpphy(pi, TRUE);
		break;

	case IOV_GVAL(IOV_LPPHY_CCK_DIG_FILT_TYPE):
		int_val = (uint32)pi_lp->lpphy_cck_dig_filt_type;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_OFDM_DIG_FILT_TYPE):
		pi_lp->lpphy_ofdm_dig_filt_type = (int16)int_val;
		if (LPREV_GE(pi->pubpi.phy_rev, 2))
			wlc_phy_tx_dig_filt_ofdm_setup_lpphy(pi, TRUE);
		break;

	case IOV_GVAL(IOV_LPPHY_OFDM_DIG_FILT_TYPE):
		int_val = (uint32)pi_lp->lpphy_ofdm_dig_filt_type;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_TXRF_SP_9_OVR):
		pi_lp->lpphy_txrf_sp_9_override = int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_TXRF_SP_9_OVR):
		int_val = pi_lp->lpphy_txrf_sp_9_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_OFDM_ANALOG_FILT_BW_OVERRIDE):
		pi->ofdm_analog_filt_bw_override = (int16)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_OFDM_ANALOG_FILT_BW_OVERRIDE):
		int_val = pi->ofdm_analog_filt_bw_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_CCK_ANALOG_FILT_BW_OVERRIDE):
		pi->cck_analog_filt_bw_override = (int16)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_CCK_ANALOG_FILT_BW_OVERRIDE):
		int_val = pi->cck_analog_filt_bw_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_OFDM_RCCAL_OVERRIDE):
		pi->ofdm_rccal_override = (int16)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_OFDM_RCCAL_OVERRIDE):
		int_val = pi->ofdm_rccal_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_CCK_RCCAL_OVERRIDE):
		pi->cck_rccal_override = (int16)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_CCK_RCCAL_OVERRIDE):
		int_val = pi->cck_rccal_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_GVAL(IOV_LPPHY_TXPWRINDEX):	/* depreciated by PHY_TXPWRINDEX */
		wlc_phy_iovar_txpwrindex_get(pi, int_val, bool_val, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_LPPHY_TXPWRINDEX):	/* depreciated by PHY_TXPWRINDEX */
		err = wlc_phy_iovar_txpwrindex_set(pi, p);
		break;

	case IOV_GVAL(IOV_LPPHY_CRS):
	        *ret_int_ptr = ((phy_reg_read(pi, LPPHY_crsgainCtrl) &
	                         LPPHY_crsgainCtrl_crseddisable_MASK) == 0);
		break;

	case IOV_SVAL(IOV_LPPHY_CRS):
		if (int_val)
			wlc_phy_clear_deaf_lpphy(pi, (bool)1);
		else
			wlc_phy_set_deaf_lpphy(pi, (bool)1);
		break;

	case IOV_SVAL(IOV_LPPHY_ACI_ON_THRESH):
	        pi_lp->lpphy_aci.on_thresh = (int)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_ON_THRESH):
		int_val = pi_lp->lpphy_aci.on_thresh;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_OFF_THRESH):
		pi_lp->lpphy_aci.off_thresh = (int)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_OFF_THRESH):
		int_val = pi_lp->lpphy_aci.off_thresh;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_ON_TIMEOUT):
		pi_lp->lpphy_aci.on_timeout = (int)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_ON_TIMEOUT):
		int_val = pi_lp->lpphy_aci.on_timeout;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_OFF_TIMEOUT):
		pi_lp->lpphy_aci.off_timeout = (int)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_OFF_TIMEOUT):
		int_val = pi_lp->lpphy_aci.off_timeout;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_GLITCH_TIMEOUT):
		pi_lp->lpphy_aci.glitch_timeout = (int)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_GLITCH_TIMEOUT):
		int_val = pi_lp->lpphy_aci.glitch_timeout;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_CHAN_SCAN_CNT):
		pi_lp->lpphy_aci.chan_scan_cnt = (int32)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_CHAN_SCAN_CNT):
		int_val = pi_lp->lpphy_aci.chan_scan_cnt;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_CHAN_SCAN_PWR_THRESH):
		pi_lp->lpphy_aci.chan_scan_pwr_thresh = (int32)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_CHAN_SCAN_PWR_THRESH):
		int_val = pi_lp->lpphy_aci.chan_scan_pwr_thresh;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_CHAN_SCAN_CNT_THRESH):
		pi_lp->lpphy_aci.chan_scan_cnt_thresh = (int32)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_CHAN_SCAN_CNT_THRESH):
		int_val = pi_lp->lpphy_aci.chan_scan_cnt_thresh;
		bcopy(&int_val, a, vsize);
		break;
	case IOV_SVAL(IOV_LPPHY_ACI_CHAN_SCAN_TIMEOUT):
		pi_lp->lpphy_aci.chan_scan_timeout = (int32)int_val;
		wlc_phy_aci_init_lpphy(pi, FALSE);
		break;
	case IOV_GVAL(IOV_LPPHY_ACI_CHAN_SCAN_TIMEOUT):
		int_val = pi_lp->lpphy_aci.chan_scan_timeout;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_LPPHY_NOISE_SAMPLES):
		pi_lp->lpphy_noise_samples = (uint16)int_val;
		break;
	case IOV_GVAL(IOV_LPPHY_NOISE_SAMPLES):
		int_val = pi_lp->lpphy_noise_samples;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_GVAL(IOV_LPPHY_PAPDEPSTBL):
	{
		lpphytbl_info_t tab;
		uint32 papdepstbl[PHY_PAPD_EPS_TBL_SIZE_LPPHY];

		/* Preset PAPD eps table */
		tab.tbl_len = PHY_PAPD_EPS_TBL_SIZE_LPPHY;
		tab.tbl_id = LPPHY_TBL_ID_PAPD_EPS;
		tab.tbl_offset = 0;
		tab.tbl_width = 32;
		tab.tbl_phywidth = 32;
		tab.tbl_ptr = &papdepstbl[0];

		/* read the table */
		wlc_phy_table_read_lpphy(pi, &tab);
		bcopy(&papdepstbl[0], a, PHY_PAPD_EPS_TBL_SIZE_LPPHY*sizeof(uint32));
	}
	break;

	case IOV_GVAL(IOV_LPPHY_IDLE_TSSI_UPDATE_DELTA_TEMP):
		int_val = (int)pi_lp->lpphy_idle_tssi_update_delta_temp;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_LPPHY_IDLE_TSSI_UPDATE_DELTA_TEMP):
		pi_lp->lpphy_idle_tssi_update_delta_temp = (int16)int_val;
		break;
#endif /* LPCONF */

#if SSLPNCONF
	case IOV_SVAL(IOV_SSLPNPHY_TX_TONE):
		pi->phy_tx_tone_freq = int_val;
		if (pi->phy_tx_tone_freq == 0) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_sslpnphy_stop_tx_tone(pi);
			wlc_phyreg_exit((wlc_phy_t *)pi);

			wlapi_bmac_macphyclk_set(pi->sh->physhim, ON);

			wlapi_enable_mac(pi->sh->physhim);
			pi->phywatchdog_override = TRUE;
		} else {
			pi->phywatchdog_override = FALSE;
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
			wlc_sslpnphy_start_tx_tone(pi, int_val, 112, 0); /* play tone */
			wlc_sslpnphy_set_tx_pwr_by_index(pi, (int)60);
			wlc_phyreg_exit((wlc_phy_t *)pi);

			wlapi_bmac_macphyclk_set(pi->sh->physhim, OFF);

			wlapi_enable_mac(pi->sh->physhim);
		}
		break;

	case IOV_GVAL(IOV_SSLPNPHY_PAPDCAL):
		pi->u.pi_sslpnphy->
			sslpnphy_full_cal_channel[CHSPEC_IS5G(pi->radio_chanspec) ? 1 : 0] = 0;
		/* fall through */
	case IOV_GVAL(IOV_SSLPNPHY_TXIQLOCAL):
	case IOV_GVAL(IOV_SSLPNPHY_RXIQCAL):
		pi->phy_forcecal = TRUE;

		*ret_int_ptr = 0;
		break;

	case IOV_GVAL(IOV_SSLPNPHY_TXPWRCTRL):
		wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_SSLPNPHY_TXPWRCTRL):
		err = wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_SSLPNPHY_TXPWRINDEX):
		wlc_phy_iovar_txpwrindex_get(pi, int_val, bool_val, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_SSLPNPHY_TXPWRINDEX):
		err = wlc_phy_iovar_txpwrindex_set(pi, p);
		break;

	case IOV_GVAL(IOV_SSLPNPHY_CRS):
	        *ret_int_ptr = ((phy_reg_read(pi, SSLPNPHY_crsgainCtrl) &
	                         SSLPNPHY_crsgainCtrl_crseddisable_MASK) == 0);
		break;

	case IOV_SVAL(IOV_SSLPNPHY_CRS):
		if (int_val)
			wlc_sslpnphy_deaf_mode(pi, FALSE);
		else
			wlc_sslpnphy_deaf_mode(pi, TRUE);
		break;

	case IOV_GVAL(IOV_SSLPNPHY_CARRIER_SUPPRESS):
		*ret_int_ptr = (pi->carrier_suppr_disable == 0);
		break;

	case IOV_GVAL(IOV_SSLPNPHY_UNMOD_RSSI):
	{
		int32 input_power_db = 0;

		if (!pi->sh->up) {
			err = BCME_NOTUP;
			break;
		}
		input_power_db = wlc_sslpnphy_rx_signal_power(pi, -1);
#if defined(WLNOKIA_NVMEM)
		input_power_db = wlc_phy_upd_rssi_offset(pi,
			(int8)input_power_db, pi->radio_chanspec);
#endif // endif
		*ret_int_ptr = input_power_db;
		break;
	}

	case IOV_SVAL(IOV_SSLPNPHY_CARRIER_SUPPRESS):
	{
		pi->carrier_suppr_disable = bool_val;
		if (pi->carrier_suppr_disable) {
			wlc_phy_carrier_suppress_sslpnphy(pi);
		}
		break;
	}

	case IOV_SVAL(IOV_SSLPNPHY_NOISE_SAMPLES):
		pi->u.pi_sslpnphy->sslpnphy_noise_samples = (uint16)int_val;
		break;
	case IOV_GVAL(IOV_SSLPNPHY_NOISE_SAMPLES):
		int_val = pi->u.pi_sslpnphy->sslpnphy_noise_samples;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_GVAL(IOV_SSLPNPHY_PAPARAMS):
		{
			int32 paparams[3];
			uint freq;
			freq = wlc_phy_channel2freq(CHSPEC_CHANNEL(pi->radio_chanspec));
			switch (wlc_phy_chanspec_freq2bandrange_lpssn(freq)) {
			case WL_CHAN_FREQ_RANGE_2G:
				/* 2.4 GHz */
				paparams[0] = (int32)pi->txpa_2g[0];		/* b0 */
				paparams[1] = (int32)pi->txpa_2g[1];		/* b1 */
				paparams[2] = (int32)pi->txpa_2g[2];		/* a1 */
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5GL:
				/* 5 GHz low */
				paparams[0] = (int32)pi->txpa_5g_low[0];	/* b0 */
				paparams[1] = (int32)pi->txpa_5g_low[1];	/* b1 */
				paparams[2] = (int32)pi->txpa_5g_low[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GM:
				/* 5 GHz middle */
				paparams[0] = (int32)pi->txpa_5g_mid[0];	/* b0 */
				paparams[1] = (int32)pi->txpa_5g_mid[1];	/* b1 */
				paparams[2] = (int32)pi->txpa_5g_mid[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GH:
#endif /* BAND5G */
			default:
				/* 5 GHz high */
				paparams[0] = (int32)pi->txpa_5g_hi[0];		/* b0 */
				paparams[1] = (int32)pi->txpa_5g_hi[1];		/* b1 */
				paparams[2] = (int32)pi->txpa_5g_hi[2];		/* a1 */
				break;
			}
			bcopy(&paparams, a, 3*sizeof(int32));
		}
		break;

	case IOV_SVAL(IOV_SSLPNPHY_PAPARAMS):
		{
			int32 paparams[3];
			int32 a1, b0, b1;
			int32 tssi, pwr;
			phytbl_info_t tab;
			uint freq;

			bcopy(p, paparams, 3*sizeof(int32));
			b0 = paparams[0];
			b1 = paparams[1];
			a1 = paparams[2];

			tab.tbl_id = SSLPNPHY_TBL_ID_TXPWRCTL;
			tab.tbl_width = 32;	/* 32 bit wide	*/
			/* Convert tssi to power LUT */
			tab.tbl_ptr = &pwr; /* ptr to buf */
			tab.tbl_len = 1;        /* # values   */
			tab.tbl_offset = 0; /* estPwrLuts */
			for (tssi = 0; tssi < 64; tssi++) {
				pwr = wlc_sslpnphy_tssi2dbm(tssi, a1, b0, b1);
				wlc_sslpnphy_write_table(pi,  &tab);
				tab.tbl_offset++;
			}

			freq = wlc_phy_channel2freq(CHSPEC_CHANNEL(pi->radio_chanspec));
			switch (wlc_phy_chanspec_freq2bandrange_lpssn(freq)) {
			case WL_CHAN_FREQ_RANGE_2G:
				/* 2.4 GHz */
				pi->txpa_2g[0] = (int16)paparams[0];		/* b0 */
				pi->txpa_2g[1] = (int16)paparams[1];		/* b1 */
				pi->txpa_2g[2] = (int16)paparams[2];		/* a1 */
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5GL:
				/* 5 GHz low */
				pi->txpa_5g_low[0] = (int16)paparams[0];	/* b0 */
				pi->txpa_5g_low[1] = (int16)paparams[1];	/* b1 */
				pi->txpa_5g_low[2] = (int16)paparams[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GM:
				/* 5 GHz middle */
				pi->txpa_5g_mid[0] = (int16)paparams[0];	/* b0 */
				pi->txpa_5g_mid[1] = (int16)paparams[1];	/* b1 */
				pi->txpa_5g_mid[2] = (int16)paparams[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GH:
			default:
				/* 5 GHz high */
				pi->txpa_5g_hi[0] = (int16)paparams[0];		/* b0 */
				pi->txpa_5g_hi[1] = (int16)paparams[1];		/* b1 */
				pi->txpa_5g_hi[2] = (int16)paparams[2];		/* a1 */
				break;
#endif /* BAND5G */
			}
		}
		break;

	case IOV_GVAL(IOV_SSLPNPHY_FULLCAL):	/* conver to SVAL with parameters like NPHY ? */
		wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_SSLPNPHY_FULLCAL):
		err = wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, TRUE);
		break;
#endif /* SSLPNCONF */

#if LCNCONF
	case IOV_GVAL(IOV_LCNPHY_PAPDEPSTBL):
	{
		lpphytbl_info_t tab;
		uint32 papdepstbl[PHY_PAPD_EPS_TBL_SIZE_LCNPHY];

		/* Preset PAPD eps table */
		tab.tbl_len = PHY_PAPD_EPS_TBL_SIZE_LCNPHY;
		tab.tbl_id = LCNPHY_TBL_ID_PAPDCOMPDELTATBL;
		tab.tbl_offset = 0;
		tab.tbl_width = 32;
		tab.tbl_phywidth = 32;
		tab.tbl_ptr = &papdepstbl[0];

		/* read the table */
		wlc_phy_table_read_lpphy(pi, &tab);
		bcopy(&papdepstbl[0], a, PHY_PAPD_EPS_TBL_SIZE_LCNPHY*sizeof(uint32));
	}
	break;
#endif /* LCNCONF */
#endif // endif

#if LPCONF
	case IOV_GVAL(IOV_LPPHY_TEMPSENSE):
		int_val = wlc_phy_tempsense_lpphy(pi);
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_GVAL(IOV_LPPHY_CAL_DELTA_TEMP):
		int_val = pi_lp->lpphy_cal_delta_temp;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_CAL_DELTA_TEMP):
		pi_lp->lpphy_cal_delta_temp = (int8)int_val;
		break;
	case IOV_GVAL(IOV_LPPHY_VBATSENSE):
		int_val = wlc_phy_vbatsense_lpphy(pi);
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_TEMPSENSE):
		pi_lp->lpphy_rx_gain_temp_adj_tempsense = (int8)int_val;
		break;

	case IOV_GVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_TEMPSENSE):
		int_val = (int32)pi_lp->lpphy_rx_gain_temp_adj_tempsense;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_THRESH):
	  {
	    uint32 thresh = (uint32)int_val;
	    pi_lp->lpphy_rx_gain_temp_adj_thresh[0] = (thresh & 0xff);
	    pi_lp->lpphy_rx_gain_temp_adj_thresh[1] = ((thresh >> 8) & 0xff);
	    pi_lp->lpphy_rx_gain_temp_adj_thresh[2] = ((thresh >> 16) & 0xff);
	    wlc_phy_rx_gain_temp_adj_lpphy(pi);
	  }
	  break;

	case IOV_GVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_THRESH):
	  {
	    uint32 thresh;
	    thresh = (uint32)pi_lp->lpphy_rx_gain_temp_adj_thresh[0];
	    thresh |= ((uint32)pi_lp->lpphy_rx_gain_temp_adj_thresh[1])<<8;
	    thresh |= ((uint32)pi_lp->lpphy_rx_gain_temp_adj_thresh[2])<<16;
	    bcopy(&thresh, a, sizeof(thresh));
	  }
	  break;

	case IOV_SVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_METRIC):
		pi_lp->lpphy_rx_gain_temp_adj_metric = (int8)(int_val & 0xff);
		pi_lp->lpphy_rx_gain_temp_adj_tempsense_metric = (int8)((int_val >> 8) & 1);
		wlc_phy_rx_gain_temp_adj_lpphy(pi);
		break;

	case IOV_GVAL(IOV_LPPHY_RX_GAIN_TEMP_ADJ_METRIC):
		int_val = (int32)pi_lp->lpphy_rx_gain_temp_adj_metric;
		int_val |= (int32)((pi_lp->lpphy_rx_gain_temp_adj_tempsense_metric << 8) & 0x100);
		bcopy(&int_val, a, sizeof(int_val));
		break;
#endif /* LPCONF */
	default:
		err = BCME_UNSUPPORTED;
	}

	return err;
}

uint32
wlc_phy_cap_get(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	uint32	cap = 0;

	switch (pi->pubpi.phy_type) {
	case PHY_TYPE_N:
		cap |= PHY_CAP_40MHZ;
		if (NREV_GE(pi->pubpi.phy_rev, 3))
			cap |= (PHY_CAP_SGI | PHY_CAP_STBC);
		break;

	case PHY_TYPE_HT:
		cap |= (PHY_CAP_40MHZ | PHY_CAP_SGI | PHY_CAP_STBC | PHY_CAP_LDPC);
		break;

#if ACCONF != 0
	case PHY_TYPE_AC:
		cap |= wlc_phy_ac_caps(pi);
		break;
#endif /* ACCONF != 0 */

	case PHY_TYPE_SSN:
		if (SSLPNREV_GT(pi->pubpi.phy_rev, 2))
			cap |= PHY_CAP_40MHZ;
		cap |= PHY_CAP_SGI;
		break;

	case PHY_TYPE_LCN:
		cap |= PHY_CAP_SGI;
		break;
	case PHY_TYPE_LCN40:
		cap |= (PHY_CAP_SGI | PHY_CAP_40MHZ | PHY_CAP_STBC);
		break;
#ifdef UNRELEASEDCHIP
	case PHY_TYPE_LCN20:
		cap |= (PHY_CAP_HT_PROP_RATES | PHY_CAP_SGI | PHY_CAP_STBC | PHY_CAP_LDPC);
		break;
#endif /* UNRELEASEDCHIP */

	default:
		break;
	}
	return cap;
}

/* %%%%%% IOCTL */
int
#ifndef PHYMOD3_TRUNK_MERGE
wlc_phy_ioctl(wlc_phy_t *pih, int cmd, int len, void *arg, bool *ta_ok)
#else
wlc_phy_ioctl_dispatch(phy_info_t *pi, int cmd, int len, void *arg, bool *ta_ok)
#endif // endif
{
#ifndef PHYMOD3_TRUNK_MERGE
	phy_info_t *pi = (phy_info_t *)pih;
#else
	wlc_phy_t *pih = (wlc_phy_t *)pi;
#endif // endif
	int bcmerror = 0;
	int val, *pval;
	bool bool_val;
	uint8 max_aci_mode;

	/* default argument is generic integer */
	pval = (int*)arg;

	/* This will prevent the misaligned access */
	if (pval && (uint32)len >= sizeof(val))
		bcopy(pval, &val, sizeof(val));
	else
		val = 0;

	/* bool conversion to avoid duplication below */
	bool_val = (val != 0);
	BCM_REFERENCE(bool_val);

	switch (cmd) {
	case WLC_RESTART:
		break;
	default:
		if ((arg == NULL) || (len <= 0)) {
			PHY_ERROR(("wl%d: %s: Command %d needs arguments\n",
			          pi->sh->unit, __FUNCTION__, cmd));
			return BCME_BADARG;
		}
		break;
	}

	switch (cmd) {

	case WLC_GET_PHY_NOISE:
		ASSERT(pval != NULL);
		*pval = wlc_phy_noise_avg(pih);
		break;

	case WLC_RESTART:
		/* Reset calibration results to uninitialized state in order to
		 * trigger recalibration next time wlc_init() is called.
		 */
		if (pi->sh->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}
		wlc_set_phy_uninitted(pi);
		break;

#if defined(BCMDBG)|| defined(WLTEST) || defined(DBG_PHY_IOV)
	case WLC_GET_RADIOREG:
		*ta_ok = TRUE;

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}
		ASSERT(pval != NULL);

		wlc_phyreg_enter(pih);
		wlc_radioreg_enter(pih);
		if ((val == RADIO_IDCODE) && (!ISHTPHY(pi)) && (!ISACPHY(pi)))
			*pval = read_radio_id(pi);
		else
			*pval = read_radio_reg(pi, (uint16)val);
		wlc_radioreg_exit(pih);
		wlc_phyreg_exit(pih);
		break;

	case WLC_SET_RADIOREG:
		*ta_ok = TRUE;

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		wlc_phyreg_enter(pih);
		wlc_radioreg_enter(pih);
		write_radio_reg(pi, (uint16)val, (uint16)(val >> NBITS(uint16)));
		wlc_radioreg_exit(pih);
		wlc_phyreg_exit(pih);
		break;
#endif // endif

#if defined(BCMDBG)
	case WLC_GET_TX_PATH_PWR:

		*pval = (read_radio_reg(pi, RADIO_2050_PU_OVR) & 0x84) ? 1 : 0;
		break;

	case WLC_SET_TX_PATH_PWR:

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		wlc_phyreg_enter(pih);
		wlc_radioreg_enter(pih);
		if (bool_val) {
			/* Enable overrides */
			write_radio_reg(pi, RADIO_2050_PU_OVR,
				0x84 | (read_radio_reg(pi, RADIO_2050_PU_OVR) &
				0xf7));
		} else {
			/* Disable overrides */
			write_radio_reg(pi, RADIO_2050_PU_OVR,
				read_radio_reg(pi, RADIO_2050_PU_OVR) & ~0x84);
		}
		wlc_radioreg_exit(pih);
		wlc_phyreg_exit(pih);
		break;
#endif /* BCMDBG */

#if defined(BCMDBG) || defined(WLTEST) || defined(WLMEDIA_N2DBG) || \
	defined(DBG_PHY_IOV)
	case WLC_GET_PHYREG:
		*ta_ok = TRUE;

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		wlc_phyreg_enter(pih);

		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
			(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
			OSL_DELAY(1);
		}

		ASSERT(pval != NULL);
		*pval = phy_reg_read(pi, (uint16)val);

		if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
			wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  0);

		wlc_phyreg_exit(pih);
		break;

	case WLC_SET_PHYREG:
		*ta_ok = TRUE;

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		wlc_phyreg_enter(pih);
		phy_reg_write(pi, (uint16)val, (uint16)(val >> NBITS(uint16)));
		wlc_phyreg_exit(pih);
		break;
#endif // endif

#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_TSSI: {

		if (!pi->sh->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter(pih);
		ASSERT(pval != NULL);
		*pval = 0;
		switch (pi->pubpi.phy_type) {
		case PHY_TYPE_LP:
			CASECHECK(PHYTYPE, PHY_TYPE_LP);
			{
			int8 ofdm_pwr = 0, cck_pwr = 0;

			wlc_phy_get_tssi_lpphy(pi, &ofdm_pwr, &cck_pwr);
			*pval =  ((uint16)ofdm_pwr << 8) | (uint16)cck_pwr;
			break;

			}
		case PHY_TYPE_SSN:
			CASECHECK(PHYTYPE, PHY_TYPE_SSN);
			{
				int8 ofdm_pwr = 0, cck_pwr = 0;

				wlc_sslpnphy_get_tssi(pi, &ofdm_pwr, &cck_pwr);
				*pval =  ((uint16)ofdm_pwr << 8) | (uint16)cck_pwr;
				break;
			}
		case PHY_TYPE_LCN:
			PHY_TRACE(("%s:***CHECK***\n", __FUNCTION__));
			CASECHECK(PHYTYPE, PHY_TYPE_LCN);
			{
				int8 ofdm_pwr = 0, cck_pwr = 0;

				wlc_lcnphy_get_tssi(pi, &ofdm_pwr, &cck_pwr);
				*pval =  ((uint16)ofdm_pwr << 8) | (uint16)cck_pwr;
				break;
			}
		case PHY_TYPE_LCN40:
			PHY_TRACE(("%s:***CHECK***\n", __FUNCTION__));
			CASECHECK(PHYTYPE, PHY_TYPE_LCN40);
			{
				int8 ofdm_pwr = 0, cck_pwr = 0;

				wlc_lcn40phy_get_tssi(pi, &ofdm_pwr, &cck_pwr);
				*pval =  ((uint16)ofdm_pwr << 8) | (uint16)cck_pwr;
				break;
			}
		case PHY_TYPE_N:
			CASECHECK(PHYTYPE, PHY_TYPE_N);
			{
			*pval = (phy_reg_read(pi, NPHY_TSSIBiasVal1) & 0xff) << 8;
			*pval |= (phy_reg_read(pi, NPHY_TSSIBiasVal2) & 0xff);
			break;
			}
		case PHY_TYPE_A:
			CASECHECK(PHYTYPE, PHY_TYPE_A);
			*pval = (phy_reg_read(pi, APHY_TSSI_STAT) & 0xff) << 8;
			break;
		case PHY_TYPE_G:
			CASECHECK(PHYTYPE, PHY_TYPE_G);
			*pval = (phy_reg_read(pi,
				(GPHY_TO_APHY_OFF + APHY_TSSI_STAT)) & 0xff) << 8;
			*pval |= (phy_reg_read(pi, BPHY_TSSI) & 0xff);
			break;
		}

		wlc_phyreg_exit(pih);
		wlapi_enable_mac(pi->sh->physhim);
		break;
	}

	case WLC_GET_ATTEN: {
		atten_t *atten = (atten_t *)pval;
		ASSERT(pval != NULL);

		if (!ISGPHY(pi)) {
			bcmerror = BCME_BADBAND;
			break;
		}
		wlc_get_11b_txpower(pi, atten);
		break;
	}

	case WLC_SET_ATTEN: {
		atten_t *atten = (atten_t *)pval;
		ASSERT(pval != NULL);

		if (!pi->sh->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		if ((atten->auto_ctrl != WL_ATTEN_APP_INPUT_PCL_OFF) &&
			(atten->auto_ctrl != WL_ATTEN_PCL_ON) &&
			(atten->auto_ctrl != WL_ATTEN_PCL_OFF)) {
			bcmerror = BCME_BADARG;
			break;
		}

		if (!ISGPHY(pi)) {
			bcmerror = BCME_BADBAND;
			break;
		}

		wlc_phyreg_enter(pih);
		wlc_radioreg_enter(pih);
		wlc_phy_set_11b_txpower(pi, atten);
		wlc_radioreg_exit(pih);
		wlc_phyreg_exit(pih);
		break;
	}

	case WLC_GET_PWRIDX:
		if (!ISAPHY(pi)) {
			bcmerror = BCME_BADBAND;
			break;
		}

		ASSERT(pval != NULL);
		*pval = pi->txpwridx;
		break;

	case WLC_SET_PWRIDX:	/* set A band radio/baseband power index */
		if (!pi->sh->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		if (!ISAPHY(pi)) {
			bcmerror = BCME_BADBAND;
			break;
		}

		if ((val < WL_PWRIDX_LOWER_LIMIT) || (val > WL_PWRIDX_UPPER_LIMIT)) {
			bcmerror = BCME_RANGE;
			break;
		}

		{
		bool override;
		override = (val == WL_PWRIDX_PCL_ON) ? FALSE : TRUE;
		wlc_set_11a_txpower(pi, (int8)val, override);
		}
		break;

	case WLC_LONGTRAIN:
		{
		longtrnfn_t long_train_fn = NULL;

		if (pi->sh->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}

		long_train_fn = pi->pi_fptr.longtrn;
		if (long_train_fn)
			bcmerror = (*long_train_fn)(pi, val);
		else
			PHY_ERROR(("WLC_LONGTRAIN: unsupported phy type\n"));

			break;
		}

	case WLC_EVM:
		ASSERT(arg != NULL);
		if (pi->sh->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}

		bcmerror = wlc_phy_test_evm(pi, val, *(((uint *)arg) + 1), *(((int *)arg) + 2));
		break;

	case WLC_FREQ_ACCURACY:
#if !SSLPNCONF
		/* SSLPNCONF transmits a few frames before running PAPD Calibration
		 * it does papd calibration each time it enters a new channel
		 * We cannot be down for this reason
		 */
		if (pi->sh->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}
#endif // endif

		bcmerror = wlc_phy_test_freq_accuracy(pi, val);
		break;

	case WLC_CARRIER_SUPPRESS:
#if !SSLPNCONF
		if (pi->sh->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}
#endif // endif
		bcmerror = wlc_phy_test_carrier_suppress(pi, val);
		break;
#endif // endif

#ifndef WLC_DISABLE_ACI
#if defined(WLTEST) || defined(WL_PHYACIARGS)
	case WLC_GET_ACI_ARGS:
		ASSERT(arg != NULL);
		bcmerror = wlc_phy_aci_args(pi, arg, TRUE, len);
		break;

	case WLC_SET_ACI_ARGS:
		ASSERT(arg != NULL);
		bcmerror = wlc_phy_aci_args(pi, arg, FALSE, len);
		break;

#endif // endif
#endif /* Compiling out ACI code for 4324 */

	case WLC_GET_INTERFERENCE_MODE:
		ASSERT(pval != NULL);
		*pval = pi->sh->interference_mode;
		if (pi->aci_state & ACI_ACTIVE) {
			*pval |= AUTO_ACTIVE;
			*pval |= (pi->aci_active_pwr_level << 4);
		}
		break;

	case WLC_SET_INTERFERENCE_MODE:
		max_aci_mode = ISACPHY(pi) ? ACPHY_ACI_MAX_MODE : WLAN_AUTO_W_NOISE;
		if (val < INTERFERE_NONE || val > max_aci_mode) {
			bcmerror = BCME_RANGE;
			break;
		}

		if (pi->sh->interference_mode == val)
			break;

		if (!pi->sh->up) {
			/*
			 * XXX: JIRA: SW4345-402 Short term fix to run the Litepoint sequence
			 * To be reverted back once we get the LP sequence fixed
			 */
			/* bcmerror = BCME_NOTUP; */
			break;
		}

		/* push to sw state */
		pi->sh->interference_mode = val;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);

#ifndef WLC_DISABLE_ACI
		/* turn interference mode to off before entering another mode */
		if (val != INTERFERE_NONE)
			wlc_phy_interference(pi, INTERFERE_NONE, TRUE);

#if defined(RXDESENS_EN)
		if (ISNPHY(pi))
			wlc_nphy_set_rxdesens((wlc_phy_t *)pi, 0);
#endif // endif
		if (!wlc_phy_interference(pi, pi->sh->interference_mode, TRUE))
			bcmerror = BCME_BADOPTION;
#endif /* !defined(WLC_DISABLE_ACI) */

		wlapi_enable_mac(pi->sh->physhim);
		break;

	case WLC_GET_INTERFERENCE_OVERRIDE_MODE:
		if (!(ISACPHY(pi) || ISNPHY(pi) || ISHTPHY(pi) || (ISLCNPHY(pi) &&
			(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)))) {
			break;
		}

		if (ISNPHY(pi) && !NREV_GE(pi->pubpi.phy_rev, 3)) {
			break;
		}

		ASSERT(pval != NULL);
		if (pi->sh->interference_mode_override == FALSE) {
			*pval = INTERFERE_OVRRIDE_OFF;
		} else {
			*pval = pi->sh->interference_mode;
		}
		break;

	case WLC_SET_INTERFERENCE_OVERRIDE_MODE:
		max_aci_mode = ISACPHY(pi) ? ACPHY_ACI_MAX_MODE : WLAN_AUTO_W_NOISE;
		if (!(ISACPHY(pi) || ISNPHY(pi) || ISHTPHY(pi)	|| (ISLCNPHY(pi) &&
			(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)))) {
			break;
		}

		if (ISNPHY(pi) && !NREV_GE(pi->pubpi.phy_rev, 3)) {
			break;
		}

		if (val < INTERFERE_OVRRIDE_OFF || val > max_aci_mode) {
			bcmerror = BCME_RANGE;
			break;
		}

		bcmerror = wlc_phy_set_interference_override_mode(pi, val);

		break;

	default:
		bcmerror = BCME_UNSUPPORTED;
	}

	return bcmerror;
}

/* Implements core functionality of WLC_SET_INTERFERENCE_OVERRIDE_MODE */
static int
wlc_phy_set_interference_override_mode(phy_info_t* pi, int val)
{
	int bcmerror = 0;

	if (val == INTERFERE_OVRRIDE_OFF) {
		/* this is a reset */
		pi->sh->interference_mode_override = FALSE;
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			pi->sh->interference_mode =
				pi->sh->interference_mode_2G;
		} else {
			pi->sh->interference_mode =
				pi->sh->interference_mode_5G;
		}
	} else {

		pi->sh->interference_mode_override = TRUE;

		/* push to sw state */
		if (ISACPHY(pi)) {
			pi->sh->interference_mode_2G_override = val;
			pi->sh->interference_mode_5G_override = val;
			pi->sh->interference_mode = CHSPEC_IS2G(pi->radio_chanspec) ?
				pi->sh->interference_mode_2G_override :
				pi->sh->interference_mode_5G_override;
		} else if (ISHTPHY(pi) ||
		          (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) ||
		          (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID))) {
			pi->sh->interference_mode_2G_override = val;
			pi->sh->interference_mode_5G_override = val;
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				/* for 2G, all values 0 thru 4 are valid */
				pi->sh->interference_mode =
					pi->sh->interference_mode_2G_override;
			} else {
				/* for 5G, only values 0 and 1 are valid options */
				if (val == 0 || val == 1) {
					pi->sh->interference_mode =
						pi->sh->interference_mode_5G_override;
				} else {
					/* default 5G interference value to 0 */
					pi->sh->interference_mode = 0;
				}
			}
		} else {
			pi->sh->interference_mode = val;
		}
	}

	if (!pi->sh->up)
		return BCME_NOTUP;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);

#ifndef WLC_DISABLE_ACI
	/* turn interference mode to off before entering another mode */
	if (val != INTERFERE_NONE)
		wlc_phy_interference(pi, INTERFERE_NONE, TRUE);

	if (!wlc_phy_interference(pi, pi->sh->interference_mode, TRUE))
		bcmerror = BCME_BADOPTION;
#endif // endif

	wlapi_enable_mac(pi->sh->physhim);

	return bcmerror;
}

static void
wlc_phy_txgainindex_cap_adjust(phy_info_t* pi)
{
	if (ISLCN40PHY(pi)) {
		wlc_lcn40phy_txgainindex_cap_adjust(pi);
	} else if (ISNPHY(pi) && CHIPID_4324X_EPA_FAMILY(pi)) {
		wlc_nphy_txgainindex_cap_adjust(pi);
	}
}

static void
wlc_phy_update_cond_backoff_boost(phy_info_t* pi)
{
	if (ISLCN40PHY(pi)) {
		wlc_lcn40phy_update_cond_backoff_boost(pi);
	}
	if (ISNPHY(pi) && CHIPID_4324X_EPA_FAMILY(pi)) {
		wlc_nphy_update_cond_backoff_boost(pi);
	}
}

/* WARNING: check ISSIM_ENAB() before doing any radio related calibrations */
int32
wlc_phy_watchdog(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	bool delay_phy_cal = FALSE;
	phy_info_abgphy_t *pi_abg = NULL;
#ifndef WLC_DISABLE_ACI
#ifdef WLPHYACICACHE
	ch_acicache_t *aci_ctx;
	aci_ctx = wlc_phy_get_aci_chanctx(pi, pi->radio_chanspec);
#endif // endif
#endif /* WLC_DISABLE_ACI */

	if (ISABGPHY(pi))
		pi_abg = pi->u.pi_abgphy;

	pi->sh->now++;

	if (!pi->phywatchdog_override)
		return BCME_OK;

	if (ISACPHY(pi) && !pi->radio_is_on) /* return if radio is off */
		return BCME_OK;
#if defined(PREASSOC_PWRCTRL) && !defined(WLC_LOW_ONLY)
	wlc_phy_pwrctrl_shortwindow_upd(pi, FALSE);
#endif // endif
	/* for QT, abort if no radio */
	if (ISSIM_ENAB(pi->sh->sih))
		return BCME_OK;
#ifndef WLC_DISABLE_ACI
#ifdef BCMLTECOEX
#if (ACCONF != 0)
	if (ISACPHY(pi)) {
		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
		if (wlapi_ltecx_get_lte_map(pi->sh->physhim)) {
			pi_ac->ltecx_ed_thresh = LTECX_ED_THRESH;
			wlc_phy_update_ed_thres_acphy(pi, pi->radio_chanspec);
			if (wlapi_ltecx_chk_elna_bypass_mode(pi->sh->physhim) &&
				!pi->u.pi_acphy->ltecx_elna_bypass_status) {
				wlc_phy_desense_ltecx_acphy(pi, 1);
			} else if (!wlapi_ltecx_chk_elna_bypass_mode(pi->sh->physhim) &&
				pi->u.pi_acphy->ltecx_elna_bypass_status) {
				wlc_phy_desense_ltecx_acphy(pi, 0);
			}
		} else {
			pi_ac->ltecx_ed_thresh = 0;
			wlc_phy_update_ed_thres_acphy(pi, pi->radio_chanspec);
			if (pi->u.pi_acphy->ltecx_elna_bypass_status) {
				wlc_phy_desense_ltecx_acphy(pi, 0);
			}
		}
	}
#endif /* acphy */
#endif /* BCMLTECOEX */
#endif /* WLC_DISABLE_ACI */
	if (ISLCNPHY(pi))
		wlc_lcnphy_noise_measure_stop(pi);

#ifndef WLC_DISABLE_ACI
	if (pi->tunings[0]) {
			pi->interf.noise.nphy_noise_assoc_enter_th = pi->tunings[0];
			pi->interf.noise.nphy_noise_noassoc_enter_th = pi->tunings[0];
	}

	if (pi->tunings[2]) {
			pi->interf.noise.nphy_noise_assoc_glitch_th_dn = pi->tunings[2];
			pi->interf.noise.nphy_noise_noassoc_glitch_th_dn = pi->tunings[2];
	}

	if (pi->tunings[1]) {
			pi->interf.noise.nphy_noise_noassoc_glitch_th_up = pi->tunings[1];
			pi->interf.noise.nphy_noise_assoc_glitch_th_up = pi->tunings[1];
	}

#ifdef WLPHYACICACHE
	if (aci_ctx) {
		wlc_phy_aci_update_counters_multilink(pi, aci_ctx);
		/* Dwell time updated, so, start measuring time from this instance */
		aci_ctx->link_entry_time =
			R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->tsf_timerlow)/1000;

		if (aci_ctx->dwell_time_since_update >= 1000)
			wlc_phy_aci_upd_multilink(pi, aci_ctx);

	} else /* if context doesn't exist, then carry out usual process */
#endif // endif
	{
		/* defer interference checking, scan and update if RM is progress */
		if (!SCAN_RM_IN_PROGRESS(pi) && (ISACPHY(pi) || ISNPHY(pi) ||
			ISHTPHY(pi) || ISGPHY(pi) || ISSSLPNPHY(pi) || (ISLCNPHY(pi) &&
			(CHIPID(pi->sh->chip) == BCM4313_CHIP_ID)) || ISLPPHY(pi) ||
			(ISLCN40PHY(pi) && ((CHIPID(pi->sh->chip) == BCM43142_CHIP_ID) ||
			(CHIPID(pi->sh->chip) == BCM43340_CHIP_ID) ||
			(CHIPID(pi->sh->chip) == BCM43341_CHIP_ID))))) {
			/* interf.scanroamtimer counts transient time coming out of scan */
			if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi)) {
				if (pi->interf.scanroamtimer != 0)
					pi->interf.scanroamtimer -= 1;
			}
			if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
				wlc_phy_aci_upd(pi);
			}

		} else {
			if ((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) || ISHTPHY(pi)) {
				/* in a scan/radio meas, don't update moving average when we
				 * first come out of scan or roam
				 */
				pi->interf.scanroamtimer = 2;
			}
		}
	}
#endif /* WLC_DISABLE_ACI */

	if ((pi->sh->now % pi->sh->fast_timer) == 0) {
		wlc_phyreg_enter(pih);
		wlapi_update_bt_chanspec(pi->sh->physhim, pi->radio_chanspec,
			SCAN_INPROG_PHY(pi), RM_INPROG_PHY(pi));
		wlc_phyreg_exit(pih);

		if (ISLPPHY(pi) && (BCM2062_ID == LPPHY_RADIO_ID(pi))) {
			wlc_phy_radio_2062_check_vco_cal(pi);
		}
	}

	/* update phy noise moving average only if no scan or rm in progress */
	/* For 43239 with OCL */
	if (!(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi))) {
		if ((pi->sh->now - pi->cal_info->last_noise_meas_time) >=
			pi->sh->noise_meas_timer) {
			if (ISACPHY(pi)) {
				/* Enabling crsmin_cal from watchdog */
				/* crsmin phyregs are only updated if the  */
				/* (current noise power - prev value from cache) */
				/* is above a threshold */
				if (pi->u.pi_acphy->crsmincal_enable) {
					wlc_phy_noise_sample_request_crsmincal((wlc_phy_t*)pi);
				} else {
					wlc_phy_noise_sample_request((wlc_phy_t*)pi,
					PHY_NOISE_SAMPLE_MON, CHSPEC_CHANNEL(pi->radio_chanspec));
				}
			} else {
				wlc_phy_noise_sample_request((wlc_phy_t*)pi, PHY_NOISE_SAMPLE_MON,
					CHSPEC_CHANNEL(pi->radio_chanspec));
			}
			pi->cal_info->last_noise_meas_time = pi->sh->now;
		}
	}

	/* reset phynoise state if ucode interrupt doesn't arrive for so long */
	if (pi->phynoise_state && (pi->sh->now - pi->phynoise_now) > 5) {
		PHY_TMP(("wlc_phy_watchdog: ucode phy noise sampling overdue\n"));
		pi->phynoise_state = 0;
	}

	/* fast_timer driven event */
	if ((!pi->phycal_txpower) ||
	    ((pi->sh->now - pi->phycal_txpower) >= pi->sh->fast_timer)) {
		/* SW power control: Keep attempting txpowr recalc until successfully */
		if (!SCAN_INPROG_PHY(pi) && wlc_phy_cal_txpower_recalc_sw(pi)) {
			pi->phycal_txpower = pi->sh->now;
		}
	}

	/* abort if cal should be blocked(e.g. not in home channel) */
	if ((SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || ASSOC_INPROG_PHY(pi)))
		return BCME_OK;

	/* ***CALIBRATION should start from here*** */

#if defined(WFD_PHY_LL)
	/* Be sure there is no cal in progress to enable/disable optimization */
	if (!PHY_PERICAL_MPHASE_PENDING(pi) && (ISNPHY(pi) || ISACPHY(pi))) {
		if (pi->wfd_ll_enable != pi->wfd_ll_enable_pending) {
			pi->wfd_ll_enable = pi->wfd_ll_enable_pending;
			if (!pi->wfd_ll_enable) {
				/* Force a watchdog CAL when disabling WFD optimization
				 * As PADP CAL has not been executed since a long time
				 * a PADP CAL is executed at the next watchdog timeout
				 */
				pi->cal_info->last_cal_time = 0;
			}
		}
	}
#endif /* WFD_PHY_LL */

	wlc_phy_update_cond_backoff_boost(pi);
	wlc_phy_txgainindex_cap_adjust(pi);

	/* Bypass elna if hirssi is detected to protect lna1 */
	if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi) &&
		!ACPHY_ENABLE_FCBS_HWACI(pi)) {
		/* 4360 a0/b0 */
		wlc_phy_hirssi_elnabypass_engine(pi);
	}

	if (ISGPHY(pi)) {
		/* glacial_timer driven event */
		if (!pi->disable_percal &&
		    (pi->sh->now - pi_abg->abgphy_cal.abgphy_cal_mlo) >= pi->sh->glacial_timer) {
			if ((GREV_GT(pi->pubpi.phy_rev, 1))) {
				wlc_phy_cal_measurelo_gphy(pi);
				delay_phy_cal = TRUE;
			}
		}

		/* slow_timer driven event */
		if ((pi->sh->now % pi->sh->slow_timer) == 0) {
			/* NOTE: wlc_phy_cal_txpower_stats_clr_gphy is to be called *after*
			 * wlc_gphy_measurelo in the case where both are called in
			 * the same pi->sh->now instant, otherwise the periodic
			 * calibration will skip all attenuator settings.
			 */
			if (!pi->hwpwrctrl)
				wlc_phy_cal_txpower_stats_clr_gphy(pi);
		}

		if (((pi->sh->now - pi_abg->abgphy_cal.abgphy_cal_noffset) >=
			pi->sh->slow_timer) &&
			(BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_ADCDIV) &&
			(RADIOREV(pi->pubpi.radiorev) == 8) && !delay_phy_cal)
		    {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_cal_radio2050_nrssioffset_gmode1(pi);
			wlapi_enable_mac(pi->sh->physhim);
			delay_phy_cal = TRUE;
		}

		if (((pi->sh->now - pi_abg->abgphy_cal.abgphy_cal_nslope) >= pi->sh->slow_timer) &&
		    (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_ADCDIV) && !delay_phy_cal) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phy_cal_radio2050_nrssislope(pi);
			wlc_phy_vco_cal(pi);
			wlapi_enable_mac(pi->sh->physhim);
			delay_phy_cal = TRUE;
		}
	}

	if (ISACPHY(pi) && pi->u.pi_acphy->temp_comp_tr_loss &&
		((pi->sh->now - pi->u.pi_acphy->srom.last_cal_time) >=
		pi->u.pi_acphy->srom.trloss_adj_time_dur)) {

		pi->u.pi_acphy->srom.last_cal_time = pi->sh->now;

		if (pi->srom_gain_cal_temp != 255) {
			int16 curr_temp;
			bool change_trloss = FALSE;
			curr_temp = wlc_phy_tempsense_acphy(pi);
			if (ABS(curr_temp - pi->srom_gain_cal_temp) <
				pi->u.pi_acphy->srom.trloss_adj_temp_thresh) {
				/* So this new gain cal temp compensation is not  applied */
				pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp = FALSE;
			} else {
				pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp = TRUE;
			}
			if ((pi->u.pi_acphy->srom.trloss_comp_wrt_temp_applied == TRUE) &&
				(ABS(pi->u.pi_acphy->srom.last_trloss_adj_temp - curr_temp) >
				pi->u.pi_acphy->srom.trloss_adj_temp_thresh))
				change_trloss = TRUE;

			if (change_trloss ||
				((pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp == TRUE) &&
				(pi->u.pi_acphy->srom.trloss_comp_wrt_temp_applied == FALSE))) {
				uint8 core;
				FOREACH_CORE(pi, core) {
					wlc_phy_set_trloss_reg_acphy(pi, core);
				}
			}
		}

	}

	if ((ISNPHY(pi)) && !pi->disable_percal && !delay_phy_cal) {
		if (!(((CHIPID(pi->sh->chip) == BCM43237_CHIP_ID) || (IS_WFD_PHY_LL_ENABLE(pi))) &&
			DCS_INPROG_PHY(pi))) {

			/* FIXME: Why are we conditioned on delay_phy_cal?
			 * it's always false
			 */

			/* 1) check to see if new cal needs to be activated */
			if ((pi->phy_cal_mode != PHY_PERICAL_DISABLE) &&
				(pi->phy_cal_mode != PHY_PERICAL_MANUAL) &&
			((pi->sh->now - pi->cal_info->last_cal_time) >= pi->sh->glacial_timer)) {
					wlc_phy_cal_perical((wlc_phy_t *)pi, PHY_PERICAL_WATCHDOG);
					if ((CHIPID(pi->sh->chip) == BCM43237_CHIP_ID) ||
					    IS_WFD_PHY_LL_ENABLE(pi))
						pi->cal_info->last_cal_time = pi->sh->now;
			}

			if (!IS_WFD_PHY_LL_ENABLE(pi)) {
				/* 2) if cal is pending, run it as well
				 * FIXME: move to 0-length timer to finish quickly and
				 * be more accurate
				 */
				wlc_phy_txpwr_papd_cal_nphy(pi);
			}

			/* PR84133: Check VCO-CAL status and refresh if needed
			 * - similar to PR76212 for LPPHY
			 *   FIXME: Pending Radio Verification of the "refresh" bit.
			 *   Upon reliability determination, we can
			 *   consolidate vco-cal from wlc_phy_cal_perical
			 */
			wlc_phy_radio205x_check_vco_cal_nphy(pi);
		}
	}

	if ((ISHTPHY(pi) || ISACPHY(pi)) && !pi->disable_percal && !delay_phy_cal)	{

		/* do we really want to look at disable_percal? we have an enable flag,
		 * so isn't this redundant? (nphy does this, but seems weird)
		 */

		if (!(IS_WFD_PHY_LL_ENABLE(pi) && DCS_INPROG_PHY(pi))) {

			/* check to see if a cal needs to be run */
			if ((pi->phy_cal_mode != PHY_PERICAL_DISABLE) &&
				(pi->phy_cal_mode != PHY_PERICAL_MANUAL) &&
				(pi->cal_info->cal_suppress_count == 0) &&
				((pi->sh->now - pi->cal_info->last_cal_time) >=
				pi->sh->glacial_timer)) {
					PHY_CAL(("wlc_phy_watchdog: watchdog fired (en=%d, now=%d,"
					"prev_time=%d, glac=%d)\n",
					pi->phy_cal_mode, pi->sh->now,
					pi->cal_info->last_cal_time,  pi->sh->glacial_timer));

					wlc_phy_cal_perical((wlc_phy_t *)pi, PHY_PERICAL_WATCHDOG);
			}
		}
	}

	if (ISLPPHY(pi)) {
		phy_info_lpphy_t *pi_lp = pi->u.pi_lpphy;
		if (pi->phy_forcecal || wlc_lpphy_txrxiq_cal_reqd(pi)) {
			if (!(pi->carrier_suppr_disable || pi->disable_percal)) {
				/* Perform Tx IQ and Rx IQ Calibrations */
				wlc_phy_periodic_cal_lpphy(pi);
			}
		}

		if (LPREV_GE(pi->pubpi.phy_rev, 2) &&
			((pi_lp->lpphy_force_papd_cal == TRUE) ||
			wlc_lpphy_papd_cal_reqd(pi))) {
			if (!(pi->carrier_suppr_disable || pi->disable_percal)) {
				/* Perform PAPD Calibration */
				wlc_phy_papd_cal_txpwr_lpphy(pi,
					pi_lp->lpphy_force_papd_cal);
			}
		}
	}

	/* PHY calibration is suppressed until this counter becomes 0 */
	if (pi->cal_info->cal_suppress_count > 0) {
		pi->cal_info->cal_suppress_count--;
	}

	/* PHY specific watchdog callbacks */
	if (pi->pi_fptr.phywatchdog)
		(*pi->pi_fptr.phywatchdog)(pi);

	/* SWWLAN-27483 */
	if (ISNPHY(pi) && (CHIP_4324_B1(pi) || CHIP_4324_B3(pi) || CHIP_4324_B5(pi))) {
		if (!(SCAN_RM_IN_PROGRESS(pi) ||
			PLT_INPROG_PHY(pi))) {
			wlc_phy_txpwr_update_baseidx_nphy(pi);
		}
	}

	if (wlapi_bmac_btc_mode_get(pi->sh->physhim))
	{
		uint16 btperiod;
		bool btactive;
		wlapi_bmac_btc_period_get(pi->sh->physhim, &btperiod, &btactive);
		wlc_phy_btc_adjust(pi, btactive, btperiod);
	}

	if (ISACPHY(pi) && (CHIPID(pi->sh->chip) == BCM4360_CHIP_ID))
		wlc_phy_stop_bt_toggle_acphy(pi);

	if (ISLCNPHY(pi) &&
	     !(SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || ASSOC_INPROG_PHY(pi)))
		if (CHIPID(pi->sh->chip) != BCM4313_CHIP_ID)
		wlc_lcnphy_noise_measure(pi);

#ifdef MULTICHAN_4313
	/* Reset papd tx power index and tx power control for all the channels */
	if (ISLCNPHY(pi) && (CHIPID(pi->sh->chip) == BCM4313_CHIP_ID))
	{
		if ((pi->sh->now - pi->cal_info->last_cal_time) >= pi->sh->glacial_timer)
		{
			wlc_lcnphy_tx_pwr_idx_reset(pi);
			pi->cal_info->last_cal_time = pi->sh->now;
		}
	}
#endif // endif

	if (ISHTPHY(pi) && (pi->sh->now % HTPHY_TEMPSENSE_TIMER == 0)) {
		/* Read and (implicitly) store current temperature */
		wlc_phy_tempsense_htphy(pi);
	}

	return BCME_OK;
}

void
wlc_phy_tx_pwr_limit_check(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;

	if (!pi->ucode_tssi_limit_en)
		return;

	if (ISLCNPHY(pi))
	  wlc_lcnphy_tx_pwr_limit_check(pi);
}

/* adjust phy setting based on bt states */
void
wlc_phy_btc_adjust(phy_info_t *pi, bool btactive, uint16 btperiod)
{
	if (btactive != pi->bt_active) {
		if (pi->pi_fptr.phybtcadjust) {
			(*pi->pi_fptr.phybtcadjust)(pi, btactive);
		}
	}

	pi->bt_period = btperiod;
	pi->bt_active = btactive;
}

#ifdef STA

#ifdef PR43338WAR
void
wlc_phy_11bap_reset(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;

	if (pi->war_b_ap) {
		pi->war_b_ap = FALSE;

		if (ISGPHY(pi))
			phy_reg_mod(pi, (GPHY_TO_APHY_OFF + APHY_CTHR_STHR_SHDIN),
				APHY_CTHR_CRS1_ENABLE, pi->war_b_ap_cthr_save);
		else if (ISNPHY(pi)) {

		}
	}
}

void
wlc_phy_11bap_restrict(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;

	if (!pi->war_b_ap) {
		/* PR43338 WAR, we have generic CCK reception problem with ACI of OFDM.
		 * should narrow RC filter and turn off OFDM classification if we are
		 * associate to B ONLY AP
		 */
		pi->war_b_ap = TRUE;

		if (ISGPHY(pi)) {
			pi->war_b_ap_cthr_save = APHY_CTHR_CRS1_ENABLE;
			phy_reg_mod(pi, (GPHY_TO_APHY_OFF + APHY_CTHR_STHR_SHDIN),
				APHY_CTHR_CRS1_ENABLE, 0);
			/* TODO, block change to APHY_CTHR_STHR_SHDIN for the bit */
		}
	}
}
#endif	/* PR43338WAR */
#endif /* STA */

void
wlc_phy_BSSinit(wlc_phy_t *pih, bool bonlyap, int noise)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint i;
	uint core;

	if (bonlyap) {
		/* PR43338 WAR, we have generic CCK reception problem with ACI of OFDM.
		 * should narrow RC filter and turn off OFDM classification if we are
		 * associate to B ONLY AP
		 */
	}

	/* watchdog idle phy noise */
	for (i = 0; i < MA_WINDOW_SZ; i++) {
		pi->sh->phy_noise_window[i] = (int8)(noise & 0xff);
	}
	pi->sh->phy_noise_index = 0;

	if ((pi->sh->interference_mode == WLAN_AUTO) &&
	     (pi->aci_state & ACI_ACTIVE)) {
		/* Reset the clock to check again after the moving average buffer has filled
		 */
		pi->aci_start_time = pi->sh->now + MA_WINDOW_SZ;
	}

	for (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {
		FOREACH_CORE(pi, core)
			pi->phy_noise_win[core][i] = PHY_NOISE_FIXED_VAL_NPHY;
	}
	pi->phy_noise_index = 0;
}

/* Convert epsilon table value to complex number */
void
wlc_phy_papd_decode_epsilon(uint32 epsilon, int32 *eps_real, int32 *eps_imag)
{
	if ((*eps_imag = (epsilon>>13)) > 0xfff)
		*eps_imag -= 0x2000; /* Sign extend */
	if ((*eps_real = (epsilon & 0x1fff)) > 0xfff)
		*eps_real -= 0x2000; /* Sign extend */
}

/* Atan table for cordic >> num2str(atan(1./(2.^[0:17]))/pi*180,8) */
static const fixed AtanTbl[] = {
	2949120,
	1740967,
	919879,
	466945,
	234379,
	117304,
	58666,
	29335,
	14668,
	7334,
	3667,
	1833,
	917,
	458,
	229,
	115,
	57,
	29
};

void
wlc_phy_cordic(fixed theta, cint32 *val)
{
	fixed angle, valtmp;
	unsigned iter;
	int signx = 1;
	int signtheta;

	val[0].i = CORDIC_AG;
	val[0].q = 0;
	angle    = 0;

	/* limit angle to -180 .. 180 */
	signtheta = (theta < 0) ? -1 : 1;
	theta = ((theta+FIXED(180)*signtheta)% FIXED(360))-FIXED(180)*signtheta;

	/* rotate if not in quadrant one or four */
	if (FLOAT(theta) > 90) {
		theta -= FIXED(180);
		signx = -1;
	} else if (FLOAT(theta) < -90) {
		theta += FIXED(180);
		signx = -1;
	}

	/* run cordic iterations */
	for (iter = 0; iter < CORDIC_NI; iter++) {
		if (theta > angle) {
			valtmp = val[0].i - (val[0].q >> iter);
			val[0].q = (val[0].i >> iter) + val[0].q;
			val[0].i = valtmp;
			angle += AtanTbl[iter];
		} else {
			valtmp = val[0].i + (val[0].q >> iter);
			val[0].q = -(val[0].i >> iter) + val[0].q;
			val[0].i = valtmp;
			angle -= AtanTbl[iter];
		}
	}

	/* re-rotate quadrant two and three points */
	val[0].i = val[0].i*signx;
	val[0].q = val[0].q*signx;
}

void
wlc_phy_inv_cordic(cint32 val, int32 *angle)
{
	int valtmp;
	unsigned iter;

	*angle = 0;
	val.i = val.i << 4;
	val.q = val.q << 4;

	/* run cordic iterations */
	for (iter = 0; iter < CORDIC_NI; iter++) {
		if (val.q < 0) {
			valtmp = val.i - (val.q >> iter);
			val.q = (val.i >> iter) + val.q;
			val.i = valtmp;
			*angle -= AtanTbl[iter];
		} else {
			valtmp = val.i + (val.q >> iter);
			val.q = -(val.i >> iter) + val.q;
			val.i = valtmp;
			*angle += AtanTbl[iter];
		}
	}

}

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
int
wlc_phy_cal_cache_init(wlc_phy_t *ppi)
{
	return 0;
}

void
wlc_phy_cal_cache_deinit(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx = pi->phy_calcache;

	while (ctx) {
		pi->phy_calcache = ctx->next;
		MFREE(pi->sh->osh, ctx,
		      sizeof(ch_calcache_t));
		ctx = pi->phy_calcache;
	}

	pi->phy_calcache = NULL;

	/* No more per-channel contexts, switch in the default one */
	pi->cal_info = &pi->def_cal_info;
	/* Reset the parameters */
	pi->cal_info->last_cal_temp = -50;
	pi->cal_info->last_cal_time = 0;
	pi->cal_info->last_temp_cal_time = 0;
}
#endif /* defined(PHYCAL_CACHING) || defined(WLMCHAN) */

#if defined(PHYCAL_CACHING) || defined(PHYCAL_CACHE_SMALL)
void
wlc_phy_cal_cache_set(wlc_phy_t *ppi, bool state)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	pi->phy_calcache_on = state;
	if (!state)
		wlc_phy_cal_cache_deinit(ppi);
}

bool
wlc_phy_cal_cache_get(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return pi->phy_calcache_on;
}
#endif /* defined(PHYCAL_CACHING) || defined(PHYCALCACHE_SMALL) */

void
wlc_phy_cal_mode(wlc_phy_t *ppi, uint mode)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (pi->pi_fptr.calibmodes)
		pi->pi_fptr.calibmodes(pi, mode);
}

void
wlc_phy_set_glacial_timer(wlc_phy_t *ppi, uint period)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	pi->sh->glacial_timer = period;
}

void
wlc_phy_cal_perical_mphase_reset(phy_info_t *pi)
{
	phy_cal_info_t *cal_info = pi->cal_info;

#if defined(WLMCHAN)
	PHY_CAL(("wlc_phy_cal_perical_mphase_reset chanspec 0x%x ctx: %p\n",
		pi->radio_chanspec, wlc_phy_get_chanctx(pi, pi->radio_chanspec)));
#else
	PHY_CAL(("wlc_phy_cal_perical_mphase_reset\n"));
#endif // endif

	if (pi->phycal_timer)
		wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);

	if (ISNPHY(pi))
		pi->u.pi_nphy->cal_type_override = PHY_PERICAL_AUTO;
	cal_info->cal_phase_id = MPHASE_CAL_STATE_IDLE;
	cal_info->txcal_cmdidx = 0; /* needed in nphy only */
}

/* wrapper function for multi phase perical schedule */
void
wlc_phy_mphase_cal_schedule(wlc_phy_t *pih, uint delay_val)
{
	phy_info_t *pi = (phy_info_t*)pih;

	if (!ISNPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi))
		return;

	if (PHY_PERICAL_MPHASE_PENDING(pi)) {
		wlc_phy_cal_perical_mphase_reset(pi);
	}

	pi->cal_info->cal_searchmode = PHY_CAL_SEARCHMODE_RESTART;
	/* schedule mphase cal */
	wlc_phy_cal_perical_mphase_schedule(pi, delay_val);
}

static void
wlc_phy_cal_perical_mphase_schedule(phy_info_t *pi, uint delay_val)
{
	/* for manual mode, let it run */
	if ((pi->phy_cal_mode != PHY_PERICAL_MPHASE) &&
	    (pi->phy_cal_mode != PHY_PERICAL_MANUAL))
		return;

	PHY_CAL(("wlc_phy_cal_perical_mphase_schedule\n"));

	/* use timer to wait for clean context since this
	 * may be called in the middle of nphy_init
	 */
	wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);

	pi->cal_info->cal_phase_id = MPHASE_CAL_STATE_INIT;
	wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, delay_val, 0);
}

/* policy entry */
void
wlc_phy_cal_perical(wlc_phy_t *pih, uint8 reason)
{
	int16 nphy_currtemp = 0;
	int16 delta_temp = 0;
	uint delta_time = 0;
	bool  suppress_cal = FALSE;
	phy_info_t *pi = (phy_info_t*)pih;
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif

	/* reset to default */
	pi->cal_info->cal_suppress_count = 0;

	/* do only init noisecal or trigger noisecal when STA
	 * joins to an AP (also trigger noisecal if AP roams)
	 */
	pi->trigger_noisecal = TRUE;

	/* reset periodic noise poll flag to avoid
	 * race-around condition with cal triggers
	 * between watchdog and others which could
	 * potentially cause sw corruption.
	 */
	pi->capture_periodic_noisestats = FALSE;

	if (!ISNPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi))
		return;

	if ((pi->phy_cal_mode == PHY_PERICAL_DISABLE) ||
	    (pi->phy_cal_mode == PHY_PERICAL_MANUAL))
		return;

	/* NPHY_IPA : disable PAPD cal for following calibration at least 4322A1? */

	PHY_CAL(("wlc_phy_cal_perical: reason %d chanspec 0x%x\n", reason,
	         pi->radio_chanspec));

	/* Update the Tx power per channel on ACPHY for 2GHz channels */
#ifdef POWPERCHANNL2G
	if (ISACPHY(pi))
		wlc_phy_tx_target_pwr_per_channel_decide_run_acphy(pi);
#endif // endif

	/* perical is enable: either single phase only, or mphase is allowed
	 *  dispatch to s-phase or m-phase based on reasons
	 */
	switch (reason) {
	case PHY_PERICAL_DRIVERUP:	/* always single phase ? */
		break;

	case PHY_PERICAL_PHYINIT:
		if (pi->phy_cal_mode == PHY_PERICAL_MPHASE) {
#if defined(WLMCHAN)
			if (ctx) {
				/* Switched the context so restart a pending MPHASE cal or
				 * restore stored calibration
				 */
				ASSERT(ctx->chanspec == pi->radio_chanspec);

				/* If it was pending last time, just restart it */
				if (PHY_PERICAL_MPHASE_PENDING(pi)) {
					/* Delete any existing timer just in case */
					PHY_CAL(("%s: Restarting calibration for 0x%x phase %d\n",
					         __FUNCTION__, ctx->chanspec,
					         pi->cal_info->cal_phase_id));
					wlapi_del_timer(pi->sh->physhim, pi->phycal_timer);
					wlapi_add_timer(pi->sh->physhim, pi->phycal_timer, 0, 0);
				} else if (wlc_phy_cal_cache_restore(pi) != BCME_ERROR) {
					break;
				}
			} else
#endif /* WLMCHAN */
			if (PHY_PERICAL_MPHASE_PENDING(pi)) {
				wlc_phy_cal_perical_mphase_reset(pi);
			}

			pi->cal_info->cal_searchmode = PHY_CAL_SEARCHMODE_RESTART;
			/* schedule mphase cal */
			wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_INIT_DELAY);
		}
		break;

	case PHY_PERICAL_JOIN_BSS:
	case PHY_PERICAL_START_IBSS:
	case PHY_PERICAL_UP_BSS:

		/* for these, want single phase cal to ensure immediately
		 *  clean Tx/Rx so auto-rate fast-start is promising
		 */
	  if ((pi->phy_cal_mode == PHY_PERICAL_MPHASE) &&
	    PHY_PERICAL_MPHASE_PENDING(pi)) {
	      wlc_phy_cal_perical_mphase_reset(pi);
	    }

		/* Always do idle TSSI measurement at the end of NPHY cal
		   while starting/joining a BSS/IBSS
		*/
		pi->first_cal_after_assoc = TRUE;
		if (ISNPHY(pi))
			pi->u.pi_nphy->cal_type_override = PHY_PERICAL_FULL; /* not used in htphy */

		/* force in-line rx/tx cal before join.  Multiphase cal
		 * could cause lost of packets while mac is suspended
		 * XXX PR63371
		 * wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_ASSOC_DELAY);
		 */

		if (pi->phycal_tempdelta) {
			if (ISNPHY(pi))
				pi->cal_info->last_cal_temp = wlc_phy_tempsense_nphy(pi);
			else if (ISHTPHY(pi))
				pi->cal_info->last_cal_temp = wlc_phy_tempsense_htphy(pi);
			else if (ISACPHY(pi)) {
				pi->cal_info->last_cal_temp = wlc_phy_tempsense_acphy(pi);
			}
		}
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
		if (ctx) {
			PHY_CAL(("wl%d: %s: Attempting to restore cals on JOIN...\n",
				pi->sh->unit, __FUNCTION__));
			if (wlc_phy_cal_cache_restore(pi) == BCME_ERROR) {
				if (ISNPHY(pi)) {
					wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);
				} else if (ISHTPHY(pi)) {
					wlc_phy_cals_htphy(pi, PHY_CAL_SEARCHMODE_RESTART);
				} else if (ISACPHY(pi)) {
					wlc_phy_cals_acphy(pi, PHY_CAL_SEARCHMODE_RESTART);
				}
			}
		}
		else
#endif /* PHYCAL_CACHING */
			if (ISNPHY(pi)) {
				wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_FULL);
			} else if (ISHTPHY(pi)) {
				wlc_phy_cals_htphy(pi, PHY_CAL_SEARCHMODE_RESTART);
			} else if (ISACPHY(pi)) {
				wlc_phy_cals_acphy(pi, PHY_CAL_SEARCHMODE_RESTART);
			}
		break;

	case PHY_PERICAL_WATCHDOG:

		if (PUB_NOT_ASSOC(pi) && ISACPHY(pi))
			return;

		/* Disable periodic noisecal trigger */
		pi->trigger_noisecal = FALSE;

		/* XXX Caputre noise stats at the expiry of watchdog
		 * glacial timer and update the reference crsminpwrs
		 * (which will be relative to the glacial timer).
		 * This will be used in the ACI scheme for comparision
		 * in lieu of baseline crsminpwr values
		 * For more info refer PR110454
		 */
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
			pi->capture_periodic_noisestats = TRUE;
		} else {
			pi->capture_periodic_noisestats = FALSE;
		}

		PHY_CAL(("%s: %sPHY phycal_tempdelta=%d\n", __FUNCTION__,
			(ISNPHY(pi)) ? "N": (ISHTPHY(pi) ? "HT" : (ISACPHY(pi) ? "AC" : "some")),
			pi->phycal_tempdelta));

		if (pi->phycal_tempdelta && (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))) {

			int cal_chanspec = 0;

			if (ISNPHY(pi)) {
				nphy_currtemp = wlc_phy_tempsense_nphy(pi);
				cal_chanspec = pi->cal_info->u.ncal.txiqlocal_chanspec;
			} else if (ISHTPHY(pi)) {
				nphy_currtemp = wlc_phy_tempsense_htphy(pi);
				cal_chanspec = pi->cal_info->u.htcal.chanspec;
			} else if (ISACPHY(pi)) {
			  if (pi->sh->now - pi->cal_info->last_temp_cal_time >=
			      pi->sh->glacial_timer) {
			        pi->cal_info->last_temp_cal_time = pi->sh->now;
				nphy_currtemp = wlc_phy_tempsense_acphy(pi);
			  } else {
			    nphy_currtemp =  pi->cal_info->last_cal_temp;
			  }
			  cal_chanspec = pi->cal_info->u.accal.chanspec;
			}
			delta_temp =
				(nphy_currtemp > pi->cal_info->last_cal_temp)?
				nphy_currtemp - pi->cal_info->last_cal_temp :
				pi->cal_info->last_cal_temp - nphy_currtemp;

			/* Only do WATCHDOG triggered (periodic) calibration if
			 the channel hasn't changed and if the temperature delta
			 is above the specified threshold
			 */
			PHY_CAL(("%sPHY temp is %d, delta %d, cal_delta %d, chanspec %04x/%04x\n",
			    (ISNPHY(pi)) ? "N": (ISHTPHY(pi) ? "HT" :
			    (ISACPHY(pi) ? "AC" : "some")),
				nphy_currtemp, delta_temp, pi->phycal_tempdelta,
				cal_chanspec, pi->radio_chanspec));

			delta_time = pi->sh->now - pi->cal_info->last_cal_time;

		/* cal_period = 0 implies only temperature based cals */
			if ((delta_temp < pi->phycal_tempdelta) &&
			    (((delta_time < pi->cal_period) && (pi->cal_period > 0)) ||
			     (pi->cal_period == PHY_PERICAL_TEMP_ONLY)) &&
			    (cal_chanspec == pi->radio_chanspec)) {
				suppress_cal = TRUE;
				pi->cal_info->cal_suppress_count = pi->sh->glacial_timer;
				PHY_CAL(("Suppressing calibration.\n"));
				/* PAPD temperature compensation */
				if (ISACPHY(pi))
					wlc_phy_papd_tempcomp_trigger_acphy(pi, nphy_currtemp);
			} else {
				pi->cal_info->last_cal_temp = nphy_currtemp;
			}
		}

		if (!suppress_cal) {

			/* if mphase is allowed, do it, otherwise, fall back to single phase */
			if (pi->phy_cal_mode == PHY_PERICAL_MPHASE) {
				/* only schedule if it's not in progress */
				if (!PHY_PERICAL_MPHASE_PENDING(pi)) {
					pi->cal_info->cal_searchmode = PHY_CAL_SEARCHMODE_REFINE;
					wlc_phy_cal_perical_mphase_schedule(pi,
						PHY_PERICAL_WDOG_DELAY);
				}
			} else if (pi->phy_cal_mode == PHY_PERICAL_SPHASE) {
				if (ISNPHY(pi)) {
					wlc_phy_cal_perical_nphy_run(pi, PHY_PERICAL_AUTO);
				} else if (ISHTPHY(pi)) {
					wlc_phy_cals_htphy(pi, PHY_CAL_SEARCHMODE_RESTART);
				} else if (ISACPHY(pi)) {
					wlc_phy_cals_acphy(pi, PHY_CAL_SEARCHMODE_RESTART);
				}
			} else {
				ASSERT(0);
			}
		}
		break;

	case PHY_PERICAL_DCS:
		ASSERT(ISNPHY(pi));
		if (ISNPHY(pi)) {
			if (PHY_PERICAL_MPHASE_PENDING(pi)) {
				wlc_phy_cal_perical_mphase_reset(pi);
				if (pi->phycal_tempdelta) {
					nphy_currtemp = wlc_phy_tempsense_nphy(pi);
					pi->cal_info->last_cal_temp = nphy_currtemp;
				}
			} else if (pi->phycal_tempdelta) {
				nphy_currtemp = wlc_phy_tempsense_nphy(pi);
				delta_temp =
				    (nphy_currtemp > pi->cal_info->last_cal_temp)?
				    nphy_currtemp - pi->cal_info->last_cal_temp :
				    pi->cal_info->last_cal_temp - nphy_currtemp;

				if ((delta_temp < (int16)pi->phycal_tempdelta)) {
					suppress_cal = TRUE;
				} else {
					pi->cal_info->last_cal_temp = nphy_currtemp;
				}
			}

			if (suppress_cal) {
				wlc_phy_txpwr_papd_cal_nphy_dcs(pi);
			} else {
				/* only mphase is allowed */
				if (pi->phy_cal_mode == PHY_PERICAL_MPHASE) {
					pi->cal_info->cal_searchmode = PHY_CAL_SEARCHMODE_REFINE;
					wlc_phy_cal_perical_mphase_schedule(pi,
						PHY_PERICAL_WDOG_DELAY);
				} else {
					ASSERT(0);
				}
			}
		}
		break;

	default:
		ASSERT(0);
		break;
	}
}

void
wlc_phy_cal_perical_mphase_restart(phy_info_t *pi)
{
	PHY_CAL(("wlc_phy_cal_perical_mphase_restart\n"));
	pi->cal_info->cal_phase_id = MPHASE_CAL_STATE_INIT;
	pi->cal_info->txcal_cmdidx = 0;
}

uint8
wlc_phy_nbits(int32 value)
{
	int32 abs_val;
	uint8 nbits = 0;

	abs_val = ABS(value);
	while ((abs_val >> nbits) > 0) nbits++;

	return nbits;
}

uint32
wlc_phy_sqrt_int(uint32 value)
{
	uint32 root = 0, shift = 0;

	/* Compute integer nearest to square root of input integer value */
	for (shift = 0; shift < 32; shift += 2) {
		if (((0x40000000 >> shift) + root) <= value) {
			value -= ((0x40000000 >> shift) + root);
			root = (root >> 1) | (0x40000000 >> shift);
		} else {
			root = root >> 1;
		}
	}

	/* round to the nearest integer */
	if (root < value) ++root;

	return root;
}

#ifdef WL_SARLIMIT
void
wlc_phy_sar_limit_set(wlc_phy_t *pih, uint32 int_val)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint core;
	int8 sar[PHY_MAX_CORES];

	FOREACH_CORE(pi, core) {
		sar[core] = (int8)(((int_val) >> (core * 8)) & 0xff);
	}
	/* internal */
	wlc_phy_sarlimit_set_int(pi, sar);
}
#endif /* WL_SARLIMIT */

#ifdef WL_SAR_SIMPLE_CONTROL
void
wlc_phy_sar_limit_set_percore(wlc_phy_t *pih, uint32 uint_val)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint core;

	FOREACH_CORE(pi, core) {
		if (((uint_val) >> (core * SAR_VAL_LENG)) & SAR_ACTIVEFLAG_MASK) {
			pi->sarlimit[core] =
				(int8)(((uint_val) >> (core * SAR_VAL_LENG)) & SAR_VAL_MASK);
		} else {
			pi->sarlimit[core] = WLC_TXPWR_MAX;
		}
	}

	if (ISACPHY(pi) && pi->sh->clk) {
		wlc_phy_set_sarlimit_acphy(pi);
	}
}
#endif /* WL_SAR_SIMPLE_CONTROL */

void
wlc_phy_stf_chain_init(wlc_phy_t *pih, uint8 txchain, uint8 rxchain)
{
	phy_info_t *pi = (phy_info_t*)pih;

	pi->sh->hw_phytxchain = txchain;
	pi->sh->hw_phyrxchain = rxchain;
	pi->sh->phytxchain = txchain;
	pi->sh->phyrxchain = rxchain;
	wlapi_update_wl_ant_info_to_bt(pi->sh->physhim, txchain, rxchain);
}

void
wlc_phy_stf_chain_set(wlc_phy_t *pih, uint8 txchain, uint8 rxchain)
{
	phy_info_t *pi = (phy_info_t*)pih;

	PHY_TRACE(("wlc_phy_stf_chain_set, new phy chain tx %d, rx %d", txchain, rxchain));

	pi->sh->phytxchain = txchain;

	if (ISNPHY(pi)) {
		if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV))
			wlc_phy_rxcore_setstate_nphy(pih, rxchain, 1);
		else
			wlc_phy_rxcore_setstate_nphy(pih, rxchain, 0);

	} else if (ISHTPHY(pi)) {
		wlc_phy_rxcore_setstate_htphy(pih, rxchain);
	} else if (ISACPHY(pi)) {
		wlc_phy_rxcore_setstate_acphy(pih, rxchain);
	}
	wlapi_update_wl_ant_info_to_bt(pi->sh->physhim, txchain, rxchain);
}

void
wlc_phy_stf_chain_get(wlc_phy_t *pih, uint8 *txchain, uint8 *rxchain)
{
	phy_info_t *pi = (phy_info_t*)pih;

	*txchain = pi->sh->phytxchain;
	*rxchain = pi->sh->phyrxchain;
}

uint8
wlc_phy_rssi_ant_compare(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int8 rssi1, rssi0;
	uint8 chainmap;

	rssi1 = pi->rssi1_avg;
	rssi0 = pi->rssi0_avg;

	if (rssi1 >= rssi0) {
		chainmap = 2;
	} else {
		chainmap = 1;
	}
	return chainmap;
}

uint8
wlc_phy_stf_chain_active_get(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint8 chainmap;

	/* XXX Watchdog override is a master switch to kill all PHY related
	 *  periodic activities in the driver
	 */
	if (!pi->phywatchdog_override)
		return pi->txcore_temp.bitmap;

	if (ISHTPHY(pi)) {
		wlc_phy_stf_chain_temp_throttle_htphy(pi);
	} else if (ISACPHY(pi)) {
		wlc_phy_stf_chain_temp_throttle_acphy(pi);
	} else if (ISNPHY(pi) && (NREV_IS(pi->pubpi.phy_rev, 6) ||
		NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV) ||
		NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV+1) ||
		NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV+2) ||
		(NREV_GE(pi->pubpi.phy_rev, 7) && (((RADIOREV(pi->pubpi.radiorev) == 5) &&
		((RADIOVER(pi->pubpi.radiover) == 0x1) ||
		(RADIOVER(pi->pubpi.radiover) == 0x2))) || (((pi->sh->chip == BCM43235_CHIP_ID) ||
		(pi->sh->chip == BCM43236_CHIP_ID) || (pi->sh->chip == BCM43238_CHIP_ID)) &&
		(pi->sh->chiprev >= 2)) || (pi->sh->chip == BCM43237_CHIP_ID))))) {

		/* Degrade-to-single-txchain is enabled for:
		 *     - NPHY rev 6:  all chips
		 *     - NPHY rev 7+: 5357B0 (radio 5v1), 5357B1 (radio5v2), 4323XB0+
		 */

		int16 nphy_currtemp;
		uint8 active_bitmap = pi->txcore_temp.bitmap;

		PHY_CAL(("Backoff tempthreshold %d | Restore tempthreshold %d\n",
		pi->txcore_temp.disable_temp, pi->txcore_temp.enable_temp));

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		nphy_currtemp = wlc_phy_tempsense_nphy(pi);
		wlapi_enable_mac(pi->sh->physhim);

		PHY_CAL(("currtemp %d active_bitmap %x\n",
		nphy_currtemp, active_bitmap));

		if (!pi->txcore_temp.heatedup) {
			if (nphy_currtemp >= pi->txcore_temp.disable_temp) {
				/* conditioning the RSSI compare chainmap to only Sulley board */
				if (NREV_GE(pi->pubpi.phy_rev, 8) &&
				    (pi->sh->boardtype == BCM943236OLYMPICSULLEY_SSID)) {
					chainmap = wlc_phy_rssi_ant_compare(pih);
					active_bitmap = (active_bitmap & 0xf0) | chainmap;
				} else if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
					PHY_CAL(("HEADTED UP! : backing off C0\n"));
					active_bitmap &= 0xFE; /* shutoff core 0 */
				} else {
					active_bitmap &= 0xFD; /* shutoff core 1 */
				}
				pi->txcore_temp.heatedup = TRUE;
				pi->txcore_temp.bitmap = active_bitmap;
			}
		} else {
			if (nphy_currtemp <= pi->txcore_temp.enable_temp) {
				if (NREV_GE(pi->pubpi.phy_rev, 8) &&
				(pi->sh->boardtype == BCM943236OLYMPICSULLEY_SSID)) {
					active_bitmap |= 0x33;
					pi->txcore_temp.degrade1RXen = FALSE;
				} else if (NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
					PHY_CAL(("COOL DOWN! : enabling C0\n"));
					active_bitmap |= 0x1;
				} else {
					active_bitmap |= 0x2;
				}
				pi->txcore_temp.heatedup = FALSE;
				pi->txcore_temp.bitmap = active_bitmap;
			} else {
				/* Sulley: degrade to 1-RX feature pending on MAC support */
				if (0) {
					if (!pi->txcore_temp.degrade1RXen) {
						/* if temperature is still greater  */
						/* than disable temp_thres then degrade 1RX */
						if (nphy_currtemp >= pi->txcore_temp.disable_temp) {
							chainmap = wlc_phy_rssi_ant_compare(pih);
							active_bitmap = (chainmap << 4) | chainmap;
							pi->txcore_temp.degrade1RXen = TRUE;
							pi->txcore_temp.bitmap = active_bitmap;
						}
					}
				}
			}
		}
	}
	return pi->txcore_temp.bitmap;
}

int8
wlc_phy_stf_ssmode_get(wlc_phy_t *pih, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int8* mcs_limits_1;
	int8* mcs_limits_2;

	PHY_TRACE(("wl%d: %s: chanspec %x\n", pi->sh->unit, __FUNCTION__, chanspec));

	/* criteria to choose stf mode */

	/* the "+3dbm (12 0.25db units)" is to account for the fact that with CDD, tx occurs
	 * on both chains
	 */
	if (CHSPEC_IS40(chanspec)) {
		mcs_limits_1 = &pi->b40_1x1mcs0;
		mcs_limits_2 = &pi->b40_1x2cdd_mcs0;
	} else {
		mcs_limits_1 = &pi->b20_1x1mcs0;
		mcs_limits_2 = &pi->b20_1x2cdd_mcs0;
	}
	if (*mcs_limits_1 > *mcs_limits_2 + 12)
		return PHY_TXC1_MODE_SISO;
	else
		return PHY_TXC1_MODE_CDD;
}

#ifdef SAMPLE_COLLECT

/* XXX A function to do sample collect
	Parameters for NPHY (with NREV < 7) are ----
	coll_us: collection time (in us).
	cores: 0, 1 or -1 for using core 0, 1 or both in 40MHz (ignored in 20MHz).
	Parameters for NPHY (with NREV >= 7) are ----
	mode: sample collect type.
	trigger: sample collect trigger bitmap.
	post_dur: post-trigger collection time (in us).
	For NPHY with (NREV < 7), we have the following
		If BW=20MHz, both cores are sampled simultaneously and the returned buffer
		has the structure [(uint16)num_bytes, rxpower(core0), rxpower(core1),
		I0(core0), Q0(core0), I0(core1), Q0(core1),...].
		If BW=40MHz, cores are sampled sequentially and the returned buffer has the
		structure [(uint16)num_bytes(core0), rxpower(core0), rxpower(core1),
		I0(core0), Q0(core0),...,(uint16)num_bytes(core1), rxpower(core0), rxpower(core1),
		I0(core1), Q0(core1),...].
		In 20MHz the sample frequency is 20MHz and in 40MHz the sample frequency is 40MHz.
	For HTPHY, ???
*/
static int
wlc_phy_sample_collect(phy_info_t *pi, wl_samplecollect_args_t *collect, void *buff)
{
	int ret;

	/* driver must be "out" (not up but chip is alive) */
	/* if (pi->sh->up)
		return BCME_NOTDOWN;
	 if (!pi->sh->clk)
		return BCME_NOCLK;
	*/
	if (ISHTPHY(pi)) {
		ret = wlc_phy_sample_collect_htphy(pi, collect, (uint32 *)buff);
		return ret;
	} else if (ISNPHY(pi)) {
		if (NREV_LT(pi->pubpi.phy_rev, 7)) {
			ret = wlc_phy_sample_collect_old(pi, collect, buff);
		} else {
			ret = wlc_phy_sample_collect_nphy(pi, collect, (uint32 *)buff);
		}
		return ret;
	}
	else if (ISLCN40PHY(pi)) {
		ret = wlc_phy_sample_collect_lcn40phy(pi, collect, (uint32 *)buff);
		return ret;
	} else 	if (ISACPHY(pi)) {
		ret = wlc_phy_sample_collect_acphy(pi, collect, (uint32 *)buff);
		return ret;
	}

	return BCME_UNSUPPORTED;
}
static int
wlc_phy_mac_triggered_sample_collect(phy_info_t *pi, wl_samplecollect_args_t *collect, void *buff)
{
	int ret;

	if (ISNPHY(pi) && (NREV_GT(pi->pubpi.phy_rev, 7))) {
		ret = wlc_phy_mac_triggered_sample_collect_nphy(pi, collect, (uint32 *)buff);
		return ret;
	}
	else
		return BCME_UNSUPPORTED;
}
static int
wlc_phy_sample_data(phy_info_t *pi, wl_sampledata_t *sample_data, void *b)
{
	int ret;

	/* driver must be "out" (not up but chip is alive) */
/*	if (pi->sh->up)
		return BCME_NOTDOWN;
	if (!pi->sh->clk)
		return BCME_NOCLK;
*/
	if (ISHTPHY(pi)) {
		ret = wlc_phy_sample_data_htphy(pi, sample_data, b);
		return ret;
	} else if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) {
		ret = wlc_phy_sample_data_nphy(pi, sample_data, b);
		return ret;
	} else 	if (ISACPHY(pi)) {
		ret = wlc_phy_sample_data_acphy(pi, sample_data, b);
		return ret;
	}

	return BCME_UNSUPPORTED;
}
static int
wlc_phy_mac_triggered_sample_data(phy_info_t *pi, wl_sampledata_t *sample_data, void *b)
{
	int ret;
	if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) {
		ret = wlc_phy_mac_triggered_sample_data_nphy(pi, sample_data, b);
		return ret;
	}
	return BCME_UNSUPPORTED;
}
static int
wlc_phy_sample_collect_old(phy_info_t *pi, wl_samplecollect_args_t *collect, void *buff)
{
	int cores;
	uint8 coll_us;
	uint16 *ptr = (uint16 *) buff;
	uint samp_freq_MHz, byte_per_samp, samp_count, byte_count;
	int start_core, end_core, core;
	uint16 mask, val, coll_type = 1;
	uint16 crsctl, crsctlu, crsctll;

	osl_t *osh;
	osh = pi->sh->osh;

	cores = collect->cores;
	coll_us = (uint8)collect->coll_us;

	if (cores > 1)
		return BCME_RANGE;

	if (IS40MHZ(pi)) {
		samp_freq_MHz = 40;
		byte_per_samp = 2;
		if (cores < 0) {
			start_core = 0;
			end_core = 1;
		} else {
			start_core = end_core = cores;
		}
	} else {
		samp_freq_MHz = 20;
		byte_per_samp = 4;
		start_core = end_core = 0;
	}
	samp_count = coll_us * samp_freq_MHz;
	byte_count = samp_count * byte_per_samp;

	if (byte_count > WLC_SAMPLECOLLECT_MAXLEN) {
		PHY_ERROR(("wl%d: %s: Not sufficient memory for this collect, byte_count: %d\n",
			pi->sh->unit, __FUNCTION__, byte_count));
		return BCME_ERROR;
	}

	wlapi_ucode_sample_init(pi->sh->physhim);

	wlc_phy_sample_collect_start_nphy(pi, coll_us, &crsctl, &crsctlu, &crsctll);

	/* RUN it */

	/* The RxMacifMode phyreg is passed to ucode to start the collect */
	mask = NPHY_RxMacifMode_SampleCore_MASK	| NPHY_RxMacifMode_PassThrough_MASK;

	/* Clear the macintstatus bit that indicates ucode timeout */
	W_REG(osh, &pi->regs->macintstatus, (1 << 24));

	for (core = start_core; core <= end_core; ptr += 1 + (ltoh16(ptr[0]) >> 1), core++) {
		val = (core << NPHY_RxMacifMode_SampleCore_SHIFT) |
			(coll_type << NPHY_RxMacifMode_PassThrough_SHIFT);
		val |= (phy_reg_read(pi, NPHY_RxMacifMode) & ~mask);

		/* Use SHM 0 for phyreg value (will be overwritten by the samples */
		wlapi_bmac_write_shm(pi->sh->physhim, 0, val);

		/* Give the command and wait */
		W_REG(osh, &pi->regs->maccommand, MCMD_SAMPLECOLL);
		SPINWAIT(((R_REG(osh, &pi->regs->maccommand) & MCMD_SAMPLECOLL) != 0), 50000);

		if ((R_REG(osh, &pi->regs->maccommand) & MCMD_SAMPLECOLL) != 0) {
			PHY_ERROR(("wl%d: %s: Failed to finish sample collect\n",
				pi->sh->unit, __FUNCTION__));
			return BCME_ERROR;
		}

		/* Verify that the sample collect didn't timeout in the ucode */
		if (R_REG(osh, &pi->regs->macintstatus) & (1 << 24)) {
			PHY_ERROR(("wl%d: %s: Sample Collect failed after 10 attempts\n",
				pi->sh->unit, __FUNCTION__));
			return BCME_ERROR;
		}

		/* RXE_RXCNT is stored in S_RSV1 */
		W_REG(osh, &pi->regs->objaddr, OBJADDR_SCR_SEL + S_RSV1);
		ptr[0] = R_REG(osh, &pi->regs->objdata) & ~0x1;
		/* Hardcode the peak-rxpower for the specific rx-gain */
		ptr[1] = htol16(0xB8B8);	/* 2's complement -72dBm */
		wlapi_copyfrom_objmem(pi->sh->physhim, 0, &ptr[2], ptr[0], OBJADDR_SHM_SEL);

		ptr[0] += 2;
		ptr[0] = htol16(ptr[0]);
	}

	wlc_phy_sample_collect_end_nphy(pi, crsctl, crsctlu, crsctll);

	return BCME_OK;
}
#endif	/* SAMPLE_COLLECT */

#ifdef WLTEST
void
wlc_phy_boardflag_upd(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if ((ISNPHY(pi)) && NREV_GE(pi->pubpi.phy_rev, 3)) {
		/* PR 64616 fix: Move nphy_aband_spurwar_en from nphy_init to phy_attach.
		   wlc_phy_chanspec_nphy_setup uses this flag and is called before nphy_init,
		   and thus we need to initialize this flag before
		   calling wlc_phy_chanspec_nphy_setup
		*/
		/* Check if A-band spur WAR should be enabled for this board */
		if (BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) & BFL2_SPUR_WAR) {
			PHY_ERROR(("%s: aband_spurwar on\n", __FUNCTION__));
			pi->u.pi_nphy->nphy_aband_spurwar_en = TRUE;
		} else {
			PHY_ERROR(("%s: aband_spurwar off\n", __FUNCTION__));
			pi->u.pi_nphy->nphy_aband_spurwar_en = FALSE;
		}
	}

	if ((ISNPHY(pi)) && NREV_GE(pi->pubpi.phy_rev, 6)) {
		/* Check if extra G-band spur WAR for 40 MHz channels 3 through 10
		 * should be enabled for this board
		 */
		if (BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) & BFL2_2G_SPUR_WAR) {
			PHY_ERROR(("%s: gband_spurwar2 on\n", __FUNCTION__));
			pi->u.pi_nphy->nphy_gband_spurwar2_en = TRUE;
		} else {
			PHY_ERROR(("%s: gband_spurwar2 off\n", __FUNCTION__));
			pi->u.pi_nphy->nphy_gband_spurwar2_en = FALSE;
		}
	}

	pi->nphy_txpwrctrl = PHY_TPC_HW_OFF;
	pi->txpwrctrl = PHY_TPC_HW_OFF;
	pi->phy_5g_pwrgain = FALSE;

	if (pi->sh->boardvendor == VENDOR_APPLE &&
	    (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))) {

		pi->nphy_txpwrctrl =  PHY_TPC_HW_ON;
		pi->phy_5g_pwrgain = TRUE;

	} else if ((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) & BFL2_TXPWRCTRL_EN) &&
		ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 2) && (pi->sh->sromrev >= 4)) {

		pi->nphy_txpwrctrl = PHY_TPC_HW_ON;

	} else if ((pi->sh->sromrev >= 4) &&
		(BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) & BFL2_5G_PWRGAIN)) {
		pi->phy_5g_pwrgain = TRUE;
	}
}
#endif /* WLTEST */
#if defined(WLTEST)
/*  FA009736 - PD Test Failure WAR */
void
wlc_phy_resetcntrl_regwrite(wlc_phy_t *pih)
{
#if LCNCONF
	phy_info_t *pi = (phy_info_t *)pih;
	/* enable rfseqSoftReset bit */
	phy_reg_write(pi, LCNPHY_resetCtrl, 0x088);
	OSL_DELAY(5);
	/* disable rfseqSoftReset bit and write default value 0x80  */
	phy_reg_write(pi, LCNPHY_resetCtrl, 0x080);
	OSL_DELAY(5);
	wlc_lcnphy_4313war(pi);
#endif /* LCNCONF */
}

int
wlc_phy_set_po_htphy(phy_info_t *pi, wl_po_t *inpo)
{
	int err = BCME_OK;

	if ((inpo->band > WL_CHAN_FREQ_RANGE_5G_BAND3))
		err  = BCME_BADARG;
	else
	{
		if (inpo->band == WL_CHAN_FREQ_RANGE_2G)
		{
			pi->ppr.sr9.cckbw202gpo = inpo->cckpo;
			pi->ppr.sr9.cckbw20ul2gpo = inpo->cckpo;
		}
		pi->ppr.sr9.ofdm[inpo->band].bw20 = inpo->ofdmpo;
		pi->ppr.sr9.ofdm[inpo->band].bw20ul = inpo->ofdmpo;
		pi->ppr.sr9.ofdm[inpo->band].bw40 = 0;
		pi->ppr.sr9.mcs[inpo->band].bw20 =
			(inpo->mcspo[1] << 16) | inpo->mcspo[0];
		pi->ppr.sr9.mcs[inpo->band].bw20ul =
			(inpo->mcspo[3] << 16) | inpo->mcspo[2];
		pi->ppr.sr9.mcs[inpo->band].bw40 =
			(inpo->mcspo[5] << 16) | inpo->mcspo[4];
	}
	return err;
}

int
wlc_phy_get_po_htphy(phy_info_t *pi, wl_po_t *outpo)
{
	int err = BCME_OK;

	if ((outpo->band > WL_CHAN_FREQ_RANGE_5G_BAND3))
		err  = BCME_BADARG;
	else
	{
		if (outpo->band == WL_CHAN_FREQ_RANGE_2G)
			outpo->cckpo = pi->ppr.sr9.cckbw202gpo;

		outpo->ofdmpo = pi->ppr.sr9.ofdm[outpo->band].bw20;
		outpo->mcspo[0] = (uint16)pi->ppr.sr9.mcs[outpo->band].bw20;
		outpo->mcspo[1] = (uint16)(pi->ppr.sr9.mcs[outpo->band].bw20 >>16);
		outpo->mcspo[2] = (uint16)pi->ppr.sr9.mcs[outpo->band].bw20ul;
		outpo->mcspo[3] = (uint16)(pi->ppr.sr9.mcs[outpo->band].bw20ul >>16);
		outpo->mcspo[4] = (uint16)pi->ppr.sr9.mcs[outpo->band].bw40;
		outpo->mcspo[5] = (uint16)(pi->ppr.sr9.mcs[outpo->band].bw40 >>16);
	}

	return err;
}

#endif // endif
/* %%%%%% dump */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP) || \
	defined(WLTEST)
void
wlc_phydump_phycal(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (!pi->sh->up)
		return;

	if (!(ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)))
		return;

	/* for HTPHY, branch out to htphy phycal dump routine */
	if (ISACPHY(pi)) {
		wlc_phy_cal_dump_acphy(pi, b);
	} else if (ISHTPHY(pi)) {
		wlc_phy_cal_dump_htphy(pi, b);
	} else if (ISNPHY(pi)) {
		wlc_phy_cal_dump_nphy(pi, b);
	}

#if defined(WLMCHAN) && defined(BCMDBG)
	{
	  if (!ISNPHY(pi) && !ISHTPHY(pi) && !ISACPHY(pi))
			return;
	  wlc_phydump_chanctx(pi, b);
	}
#endif // endif

}

/* Dump rssi values from aci scans */
void
wlc_phydump_aci(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	int channel, indx;
	int val;
	char *ptr;
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISACPHY(pi)) {
		wlc_phydump_aci_acphy(pi, b);
	} else {
		val = pi->sh->interference_mode;
		if (pi->aci_state & ACI_ACTIVE)
			val |= AUTO_ACTIVE;

		if (val & AUTO_ACTIVE)
			bcm_bprintf(b, "ACI is Active\n");
		else {
			bcm_bprintf(b, "ACI is Inactive\n");
			return;
		}

		for (channel = 0; channel < ACI_LAST_CHAN; channel++) {
			bcm_bprintf(b, "Channel %d : ", channel + 1);
			for (indx = 0; indx < 50; indx++) {
				ptr = &(pi->interf.aci.rssi_buf[channel][indx]);
				if (*ptr == (char)-1)
					break;
				bcm_bprintf(b, "%d ", *ptr);
			}
			bcm_bprintf(b, "\n");
		}
	}
}
#endif /* BCMDBG || BCMDBG_DUMP || BCMDBG_PHYDUMP || WLTEST */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP)
#if defined(DBG_PHY_IOV) || defined(BCMDBG_PHYDUMP)
#ifdef WLC_LOW_ONLY
int
wlc_phydump_radioreg(wlc_phy_t *pih, struct bcmstrbuf *b, int *offset)
#else
int
wlc_phydump_radioreg(wlc_phy_t *pih, struct bcmstrbuf *b)
#endif // endif
{
	phy_info_t *pi = (phy_info_t *)pih;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter(pih);
	wlc_radioreg_enter(pih);
#ifdef WLC_LOW_ONLY
		wlc_phy_dump_radio_regs(pih, b, TRUE, offset);
#else
	wlc_phy_dump_radio_regs(pih, b, TRUE);
#endif // endif
	wlc_radioreg_exit(pih);
	wlc_phyreg_exit(pih);
	wlapi_enable_mac(pi->sh->physhim);
	return 0;
}

#ifdef WLC_LOW_ONLY
int
wlc_phydump_reg(wlc_phy_t *pih, struct bcmstrbuf *b, int *offset)
#else
int
wlc_phydump_reg(wlc_phy_t *pih, struct bcmstrbuf *b)
#endif // endif
{
	/* This function now dumps ONLY register, not tables */
	phy_info_t *pi = (phy_info_t *)pih;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter(pih);
#ifdef WLC_LOW_ONLY
	wlc_phy_dump_phy_regs(pih, b, offset);
#else
	wlc_phy_dump_phy_regs(pih, b);
#endif // endif
	wlc_phyreg_exit(pih);
	wlapi_enable_mac(pi->sh->physhim);

	return 0;
}

#if defined(DBG_PHY_IOV)
static void
wlc_phydump_dumptbl(wlc_phy_t *pih, struct bcmstrbuf *b, uint8 tbl)
{
	uint16 qval[3];
	phy_info_t *pi = (phy_info_t *)pih;
	phy_table_info_t *ti = NULL;
	uint16 addr, val = 0;

	qval[0] = 0;
	qval[1] = 0;
	qval[2] = 0;

	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* dump BPHY space, from within GPHY or NPHY+2G */
	if (ISGPHY(pi)) {
		if (tbl != 1) {
			PHY_ERROR(("There is only one table\n"));
			return;
		}
		if (GREV_GE(pi->pubpi.phy_rev, 3)) {
			ti = gphy3_tables;
		} else if (GREV_IS(pi->pubpi.phy_rev, 2)) {
			ti = gphy2_tables;
		} else {
			ti = gphy1_tables;
		}
	} else if (ISAPHY(pi)) {
		/* A phy */
		if (tbl != 1) {
			PHY_ERROR(("There is only one table\n"));
			return;
		}
		if (AREV_GE(pi->pubpi.phy_rev, 6)) {
			ti = aphy4_tables;
		} else if (AREV_GE(pi->pubpi.phy_rev, 4)) {
			ti = aphy4_tables;
		} else if (AREV_IS(pi->pubpi.phy_rev, 3)) {
			ti = aphy3_tables;
		} else {
			ti = aphy2_tables;
		}
	} else if (ISNPHY(pi)) {
		if (NREV_GE(pi->pubpi.phy_rev, 3)) {
			if (tbl == 1) {
				ti = nphy3_tables_1;
			}
			else if (tbl == 2) {
				ti = nphy3_tables_2;
			}

		} else {
			if (tbl == 1) {
				ti = nphy2_tables;
			}
			else if (tbl == 2) {
				PHY_ERROR(("There is only one table\n"));
				return;
			}
		}
	} else if (ISHTPHY(pi)) {
		if (tbl != 1) {
			PHY_ERROR(("There is only one table\n"));
			return;
		}
		ti = htphy_tables;
#if ACCONF != 0
	} else if (ISACPHY(pi)) {
		if (!(ACMAJORREV_1(pi->pubpi.phy_rev)) && tbl != 1) {
			PHY_ERROR(("There is only one table\n"));
			return;
		}
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			ti = acphy_tables_rev4;
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			ti = acphy_tables_rev3;
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			if (tbl == 1) {
				ti = acphy2_tables_1;
			} else if (tbl == 2) {
				ti = acphy2_tables_2;
			}
		} else {
			ti = acphy_tables;
		}
#endif /* ACCONF != 0 */
	} else if (ISLPPHY(pi)) {
		PHY_ERROR(("Take care of LP phy dumps\n"));
		return;
	} else if (ISLCNPHY(pi)) {
		PHY_ERROR(("Take care of LCN phy dumps\n"));
		return;
	} else if (ISLCN40PHY(pi)) {
		PHY_ERROR(("Take care of LCN40 phy dumps\n"));
		return;
	} else {
		ASSERT(0);
		PHY_ERROR(("Unknown or Unhandled Phy\n"));
		return;
	}

	ASSERT(ti != NULL);
	while (ti->table != 0xff) {
#if defined(WLTEST)
		if (pi->nphy_tbldump_minidx >= 0) {
			if (ti->table < (uint) pi->nphy_tbldump_minidx) {
				ti++;
				continue;
			}
		}

		if (pi->nphy_tbldump_maxidx >= 0) {
			if (ti->table > (uint) pi->nphy_tbldump_maxidx) {
				break;
			}
		}
#endif // endif

		/* For NREV >= 5, there are holes in Table 0x7 and 0x13 which causes
		   the table dump to crash
		*/
		if (ISNPHY(pi)) {
			if (NREV_GE(pi->pubpi.phy_rev, 5)) {
				if ((ti->table == 0x7) || (ti->table == 0x13)) {
					ti++;
					continue;
				}
			}

			/* For NREV >= 7, AntSwCtrlLUT has 64 entries, not 32 anymore */
			if (NREV_GE(pi->pubpi.phy_rev, 7)) {
				if (ti->table == 0x9) {
					ti->max = 64;
				}
			}
		}
		if (ISACPHY(pi) && (CHSPEC_IS5G(pi->radio_chanspec))) {
			if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
				if (!ACMINORREV_0(pi->pubpi.phy_rev)) {
					/* bphy tables need to be skipped if table dump is in 5G */
					if (ti->table >= 80 && ti->table <= 84) {
						ti++;
						continue;
					}
				}
			}
		}

		for (addr = 0; addr < ti->max; addr++) {
			if (ISHTPHY(pi)) {
				if (ti->table == HTPHY_TBL_ID_RFSEQ) {
					/* avoid dumping out holes in the RFSEQ Table */
					if (!wlc_phy_rfseqtbl_valid_addr_htphy(pi, addr)) {
						continue;
					}
				}
			} else if (ISNPHY(pi)) {
				/* For NREV >=7, the holes in Table 0x8 should not be dumped */
				if (NREV_GE(pi->pubpi.phy_rev, 7)) {
					if ((ti->table == 0x8) && (addr >= 0x20)) {
						continue;
					}
				}
			}

			wlc_phy_table_read(pi, ti, addr, &val, &qval[0]);

			if (PHY_INFORM_ON() && si_taclear(pi->sh->sih, FALSE)) {
				PHY_INFORM(("%s: TA reading aphy table 0x%x:0x%x\n", __FUNCTION__,
				            ti->table, addr));
				bcm_bprintf(b, "0x%x: 0x%03x tabort\n", ti->table, addr);
			} else if (!si_taclear(pi->sh->sih, FALSE)) {
				if (ti->q == 1) {
					bcm_bprintf(b, "0x%x: 0x%03x 0x%04x 0x%04x\n", ti->table,
					            addr, val, qval[0]);
			    } else if (ti->q == 2) {
					bcm_bprintf(b, "0x%x: 0x%03x 0x%04x 0x%04x 0x%04x\n",
					    ti->table, addr, val, qval[1], qval[0]);
			    } else if (ti->q == 3) {
					bcm_bprintf(b, "0x%x: 0x%03x 0x%04x 0x%04x 0x%04x 0x%04x\n",
					     ti->table, addr, val, qval[2], qval[1], qval[0]);
				} else {
					bcm_bprintf(b, "0x%x: 0x%03x 0x%04x\n", ti->table, addr,
					            val);
				}
			}
		}
		ti++;
	}
	if (((ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3)) ||
		(ISACPHY(pi) && ACMAJORREV_1(pi->pubpi.phy_rev)))&& (tbl == 1)) {
		bcm_bprintf(b, "Please run \"wl dump phytbl2\" to get the remaining tables\n");
	}

	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
}

int
wlc_phydump_tbl1(wlc_phy_t *pih, struct bcmstrbuf *b)
{
	phy_info_t *pi = (phy_info_t *)pih;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter(pih);
	wlc_phydump_dumptbl(pih, b, 1);
	wlc_phyreg_exit(pih);
	wlapi_enable_mac(pi->sh->physhim);
	return 0;
}

int
wlc_phydump_tbl2(wlc_phy_t *pih, struct bcmstrbuf *b)
{
	phy_info_t *pi = (phy_info_t *)pih;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter(pih);
	wlc_phydump_dumptbl(pih, b, 2);
	wlc_phyreg_exit(pih);
	wlapi_enable_mac(pi->sh->physhim);
	return 0;
}
#endif // endif

#endif // endif

/* Below wlc_phydump_xx should be generic, applicable to all PHYs.
 * each PHY section should have ISXPHY macro checking
 */
void
wlc_phydump_measlo(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	int padmix_en = 0;
	int j, z, bb_attn, rf_attn;
	phy_info_t *pi = (phy_info_t *)ppi;
	phy_info_abgphy_t *pi_abg = NULL;
	if (ISABGPHY(pi))
		pi_abg = pi->u.pi_abgphy;

	if (!ISGPHY(pi))
		return;

	if (ISABGPHY(pi)) {
		bcm_bprintf(b, "bb_list_size= %d, rf_list_size= %d\n *RF* ", pi_abg->bb_list_size,
			pi_abg->rf_list_size);

		for (j = 0; j < pi_abg->bb_list_size; j++)
			bcm_bprintf(b, "  %d:i,q  ", pi_abg->bb_attn_list[j]);

	bcm_bprintf(b, "\n");

		for (z = 0; z < pi_abg->rf_list_size; z++) {
			rf_attn   = (int)((char)PHY_GET_RFATTN(pi_abg->rf_attn_list[z]));
			padmix_en = (int)((char)PHY_GET_PADMIX(pi_abg->rf_attn_list[z]));
			bcm_bprintf(b, "%2d %1d", rf_attn, padmix_en);

			for (j = 0; j < pi_abg->bb_list_size; j++) {
				int i, q;
				bb_attn = pi_abg->bb_attn_list[j];
				i = (int)((char)pi_abg->gphy_locomp_iq[PHY_GET_RFGAINID(rf_attn,
					padmix_en, pi_abg->rf_max)][bb_attn].i);
				q = (int)((char)pi_abg->gphy_locomp_iq[PHY_GET_RFGAINID(rf_attn,
					padmix_en, pi_abg->rf_max)][bb_attn].q);
				bcm_bprintf(b, " : %3d %2d", i, q);
			}
			bcm_bprintf(b, "\n");
		}
		bcm_bprintf(b, "\n");
	}
}

void
wlc_phydump_papd(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint32 val, i, j;
	int32 eps_real, eps_imag;
	phy_info_t *pi = (phy_info_t *)ppi;

	eps_real = eps_imag = 0;

	if (!pi->sh->up)
		return;

	if (!(ISNPHY(pi) || ISLCNCOMMONPHY(pi)))
		return;

	/*
	* XXX PR41476 WAR: Prevent MAC from accessing PHY registers while the host is
	* For Corerev 11 and 12, make sure that
	*       * either the MAC is disabled, or
	*       * MCTL_PHYLOCK is set that ucode checks before reading phyreg
	* This prevents collision for phy read access between Host and Ucode
	*/

	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12)) {
		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK,  MCTL_PHYLOCK);
		(void)R_REG(pi->sh->osh, &pi->regs->maccontrol);
		OSL_DELAY(1);
	}

	if (ISNPHY(pi))
	{
		bcm_bprintf(b, "papd eps table:\n [core 0]\t\t[core 1] \n");
		for (j = 0; j < 64; j++) {
			for (i = 0; i < 2; i++) {
				wlc_phy_table_read_nphy(pi, ((i == 0) ? NPHY_TBL_ID_EPSILONTBL0 :
					NPHY_TBL_ID_EPSILONTBL1), 1, j, 32, &val);
				wlc_phy_papd_decode_epsilon(val, &eps_real, &eps_imag);
				bcm_bprintf(b, "{%d\t%d}\t\t", eps_real, eps_imag);
			}
		bcm_bprintf(b, "\n");
		}
		bcm_bprintf(b, "\n\n");
	}
	else if (ISLCNPHY(pi))
	{
		wlc_lcnphy_read_papdepstbl(pi, b);

	} else if (ISLCN40PHY(pi))
		wlc_lcn40phy_read_papdepstbl(pi, b);

	if (D11REV_IS(pi->sh->corerev, 11) || D11REV_IS(pi->sh->corerev, 12))
		wlapi_bmac_mctrl(pi->sh->physhim, MCTL_PHYLOCK, 0);
}

void
wlc_phydump_noise(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint32 i, idx, antidx;
	int32 tot;
	phy_info_t *pi = (phy_info_t *)ppi;

	if (!pi->sh->up)
		return;

	bcm_bprintf(b, "History and average of latest %d noise values:\n",
		PHY_NOISE_WINDOW_SZ);

	FOREACH_CORE(pi, antidx) {
		tot = 0;
		bcm_bprintf(b, "Ant%d: [", antidx);

		idx = pi->phy_noise_index;
		for (i = 0; i < PHY_NOISE_WINDOW_SZ; i++) {
			bcm_bprintf(b, "%4d", pi->phy_noise_win[antidx][idx]);
			tot += pi->phy_noise_win[antidx][idx];
			idx = MODINC_POW2(idx, PHY_NOISE_WINDOW_SZ);
		}
		bcm_bprintf(b, "]");

		tot /= PHY_NOISE_WINDOW_SZ;
		bcm_bprintf(b, " [%4d]\n", tot);
	}
}

void
wlc_phydump_state(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
#ifndef PPR_API
	char fraction[4][4] = {"  ", ".25", ".5", ".75"};
	int i;
	phy_info_t *pi = (phy_info_t *)ppi;
	bool isphyhtcap = ISPHY_HT_CAP(pi);
	uint offset;

#define QDB_FRAC(x)	(x) / WLC_TXPWR_DB_FACTOR, fraction[(x) % WLC_TXPWR_DB_FACTOR]

	bcm_bprintf(b, "phy_type %d phy_rev %d ana_rev %d radioid 0x%x radiorev 0x%x\n",
	               pi->pubpi.phy_type, pi->pubpi.phy_rev, pi->pubpi.ana_rev,
	               pi->pubpi.radioid, pi->pubpi.radiorev);

	bcm_bprintf(b, "hw_power_control %d encore %d\n",
	               pi->hwpwrctrl, pi->pubpi.abgphy_encore);

	bcm_bprintf(b, "Power targets: ");
	/* CCK Power/Rate */
	bcm_bprintf(b, "\n\tCCK: ");
	for (i = 0; i < WL_NUM_RATES_CCK; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_CCK]));
	/* OFDM Power/Rate */
	bcm_bprintf(b, "\n\tOFDM 20MHz SISO: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_OFDM]));
	bcm_bprintf(b, "\n\tOFDM 20MHz CDD: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_OFDM_20_CDD]));
	/* 20MHz MCS Power/Rate */
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 20MHz 1 Tx: " : "\n\tMCS0-7 20MHz SISO: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_20_S1x1 : TXP_FIRST_MCS_20_SISO;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 20MHz 2 Tx: " : "\n\tMCS0-7 20MHz CDD: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_20_S1x2 : TXP_FIRST_MCS_20_CDD;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 20MHz 3 Tx: " : "\n\tMCS0-7 20MHz STBC: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_20_S1x3 : TXP_FIRST_MCS_20_STBC;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS8-15 20MHz 2 Tx: " : "\n\tMCS0-7 20MHz SDM: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_20_S2x2 : TXP_FIRST_MCS_20_SDM;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS8-15 20MHz 3 Tx: " : "");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_MCS_20_S2x3]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS16-23 20MHz 3 Tx: " : "");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_MCS_20_S3x3]));

	/* 40MHz OFDM Power/Rate */
	bcm_bprintf(b, "\n\tOFDM 40MHz SISO: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_OFDM_40_SISO]));
	bcm_bprintf(b, "\n\tOFDM 40MHz CDD: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_OFDM_40_CDD]));
	/* 40MHz MCS Power/Rate */
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 40MHz 1 Tx: " : "\n\tMCS0-7 40MHz SISO: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_40_S1x1 : TXP_FIRST_MCS_40_SISO;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 40MHz 2 Tx: " : "\n\tMCS0-7 40MHz CDD: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_40_S1x2 : TXP_FIRST_MCS_40_CDD;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS0-7 40MHz 3 Tx: " : "\n\tMCS0-7 40MHz STBC: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_40_S1x3 : TXP_FIRST_MCS_40_STBC;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+offset]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS8-15 40MHz 2 Tx: " : "\n\tMCS0-7 40MHz SDM: ");
	offset = isphyhtcap ? TXP_FIRST_MCS_40_S2x2 : TXP_FIRST_MCS_40_SDM;
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS8-15 40MHz 3 Tx: " : "");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_MCS_40_S2x3]));
	bcm_bprintf(b, isphyhtcap ? "\n\tMCS16-23 40MHz 3 Tx: " : "");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_MCS_40_S3x3]));

	/* MCS 32 Power */
	bcm_bprintf(b, "\n\tMCS32: %2d%s\n\n", QDB_FRAC(pi->tx_power_target[i]));

	if (isphyhtcap)
		goto next;

	/* CCK Power/Rate */
#if HTCONF
	bcm_bprintf(b, "\n\tCCK 20UL: ");
	for (i = 0; i < WL_NUM_RATES_CCK; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_CCK]));

	/* 20 in 40MHz OFDM Power/Rate */
	bcm_bprintf(b, "\n\tOFDM 20UL SISO: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_OFDM]));
	bcm_bprintf(b, "\n\tOFDM 40MHz CDD: ");
	for (i = 0; i < WL_NUM_RATES_OFDM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_OFDM_CDD]));

	/* 20 in 40MHz MCS Power/Rate */
	bcm_bprintf(b, "\n\tMCS0-7 20UL 1 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_S1x1]));
	bcm_bprintf(b, "\n\tMCS0-7 20UL 2 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_S1x2]));
	bcm_bprintf(b, "\n\tMCS0-7 20UL 3 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_FIRST_20UL_S1x3]));
	bcm_bprintf(b, "\n\tMCS8-15 20UL 2 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_LAST_20UL_S2x2]));
	bcm_bprintf(b, "\n\tMCS8-15 20UL 3 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_LAST_20UL_S2x3]));
	bcm_bprintf(b, "\n\tMCS16-23 20UL 3 Tx: ");
	for (i = 0; i < WL_NUM_RATES_MCS_1STREAM && isphyhtcap; i++)
		bcm_bprintf(b, "%2d%s ", QDB_FRAC(pi->tx_power_target[i+TXP_LAST_20UL_S3x3]));
#endif /* HTCONF */

next:
	if (ISNPHY(pi)) {
		bcm_bprintf(b, "antsel_type %d\n", pi->antsel_type);
		bcm_bprintf(b, "ipa2g %d ipa5g %d\n", pi->ipa2g_on, pi->ipa5g_on);

	} else if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNPHY(pi) || ISLCN40PHY(pi) || ISHTPHY(pi)) {
		return;
	} else if (ISAPHY(pi)) {
		bcm_bprintf(b, "itssi low 0x%x, itssi mid 0x%x, itssi high 0x%x\n",
			pi->u.pi_abgphy->idle_tssi[A_LOW_CHANS],
			pi->u.pi_abgphy->idle_tssi[A_MID_CHANS],
			pi->u.pi_abgphy->idle_tssi[A_HIGH_CHANS]);

		bcm_bprintf(b, "Power limits low: ");
		for (i = 0; i <= TXP_LAST_OFDM; i++)
			bcm_bprintf(b, "%d ", pi->tx_srom_max_rate_5g_low[i]);

		bcm_bprintf(b, "\nPower limits mid: ");
		for (i = 0; i <= TXP_LAST_OFDM; i++)
			bcm_bprintf(b, "%d ", pi->tx_srom_max_rate_5g_mid[i]);

		bcm_bprintf(b, "\nPower limits hi: ");
		for (i = 0; i <= TXP_LAST_OFDM; i++)
			bcm_bprintf(b, "%d ", pi->tx_srom_max_rate_5g_hi[i]);
	} else { /* G PHY */
		bcm_bprintf(b, "itssi 0x%x\n", pi->u.pi_abgphy->idle_tssi[G_ALL_CHANS]);
		bcm_bprintf(b, "Power limits: ");
		for (i = 0; i <= TXP_LAST_OFDM; i++)
			bcm_bprintf(b, "%d ", pi->tx_srom_max_rate_2g[i]);
	}

	bcm_bprintf(b, "\ninterference_mode %d intf_crs %d\n",
		pi->sh->interference_mode, pi->interference_mode_crs);
#endif /* !PPR_API */
}

void
wlc_phydump_lnagain(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	int core;
	uint16 lnagains[2][4];
	uint16 mingain[2];
	phy_info_t *pi = (phy_info_t *)ppi;
	phy_info_nphy_t *pi_nphy = NULL;

	if (pi->u.pi_nphy)
		pi_nphy = pi->u.pi_nphy;

	if (!ISNPHY(pi))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);

	/* Now, read the gain table */
	for (core = 0; core < 2; core++) {
		wlc_phy_table_read_nphy(pi, core, 4, 8, 16, &lnagains[core][0]);
	}

	mingain[0] =
		(phy_reg_read(pi, NPHY_Core1MinMaxGain) &
		NPHY_CoreMinMaxGain_minGainValue_MASK) >>
		NPHY_CoreMinMaxGain_minGainValue_SHIFT;
	mingain[1] =
		(phy_reg_read(pi, NPHY_Core2MinMaxGain) &
		NPHY_CoreMinMaxGain_minGainValue_MASK) >>
		NPHY_CoreMinMaxGain_minGainValue_SHIFT;

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	bcm_bprintf(b, "Core 0: 0x%02x, 0x%02x, 0x%02x, 0x%02x\n",
		lnagains[0][0], lnagains[0][1], lnagains[0][2], lnagains[0][3]);
	bcm_bprintf(b, "Core 1: 0x%02x, 0x%02x, 0x%02x, 0x%02x\n\n",
		lnagains[1][0], lnagains[1][1], lnagains[1][2], lnagains[1][3]);
	bcm_bprintf(b, "Min Gain: Core 0=0x%02x,   Core 1=0x%02x\n\n",
		mingain[0], mingain[1]);
}

void
wlc_phydump_initgain(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint8 ctr;
	uint16 regval[2], tblregval[4];
	uint16 lna_gain[2], hpvga1_gain[2], hpvga2_gain[2];
	uint16 tbl_lna_gain[4], tbl_hpvga1_gain[4], tbl_hpvga2_gain[4];
	phy_info_t *pi = (phy_info_t *)ppi;
	phy_info_nphy_t *pi_nphy = NULL;

	if (pi->u.pi_nphy)
		pi_nphy = pi->u.pi_nphy;

	if (!ISNPHY(pi))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);

	regval[0] = phy_reg_read(pi, NPHY_Core1InitGainCode);
	regval[1] = phy_reg_read(pi, NPHY_Core2InitGainCode);

	wlc_phy_table_read_nphy(pi, 7, PHYCORENUM(pi->pubpi.phy_corenum), 0x106, 16, tblregval);

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	lna_gain[0] = (regval[0] & NPHY_CoreInitGainCode_initLnaIndex_MASK) >>
		NPHY_CoreInitGainCode_initLnaIndex_SHIFT;
	hpvga1_gain[0] = (regval[0] & NPHY_CoreInitGainCode_initHpvga1Index_MASK) >>
		NPHY_CoreInitGainCode_initHpvga1Index_SHIFT;
	hpvga2_gain[0] = (regval[0] & NPHY_CoreInitGainCode_initHpvga2Index_MASK) >>
		NPHY_CoreInitGainCode_initHpvga2Index_SHIFT;

	lna_gain[1] = (regval[1] & NPHY_CoreInitGainCode_initLnaIndex_MASK) >>
		NPHY_CoreInitGainCode_initLnaIndex_SHIFT;
	hpvga1_gain[1] = (regval[1] & NPHY_CoreInitGainCode_initHpvga1Index_MASK) >>
		NPHY_CoreInitGainCode_initHpvga1Index_SHIFT;
	hpvga2_gain[1] = (regval[1] & NPHY_CoreInitGainCode_initHpvga2Index_MASK) >>
		NPHY_CoreInitGainCode_initHpvga2Index_SHIFT;

	for (ctr = 0; ctr < 4; ctr++) {
		tbl_lna_gain[ctr] = (tblregval[ctr] >> 2) & 0x3;
	}

	for (ctr = 0; ctr < 4; ctr++) {
		tbl_hpvga1_gain[ctr] = (tblregval[ctr] >> 4) & 0xf;
	}

	for (ctr = 0; ctr < 4; ctr++) {
		tbl_hpvga2_gain[ctr] = (tblregval[ctr] >> 8) & 0x1f;
	}

	bcm_bprintf(b, "Core 0 INIT gain: HPVGA2=%d, HPVGA1=%d, LNA=%d\n",
		hpvga2_gain[0], hpvga1_gain[0], lna_gain[0]);
	bcm_bprintf(b, "Core 1 INIT gain: HPVGA2=%d, HPVGA1=%d, LNA=%d\n",
		hpvga2_gain[1], hpvga1_gain[1], lna_gain[1]);
	bcm_bprintf(b, "\n");
	bcm_bprintf(b, "INIT gain table:\n");
	bcm_bprintf(b, "----------------\n");
	for (ctr = 0; ctr < 4; ctr++) {
		bcm_bprintf(b, "Core %d: HPVGA2=%d, HPVGA1=%d, LNA=%d\n",
			ctr, tbl_hpvga2_gain[ctr], tbl_hpvga1_gain[ctr], tbl_lna_gain[ctr]);
	}

}

void
wlc_phydump_hpf1tbl(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint8 ctr, core;
	uint16 gain[2][NPHY_MAX_HPVGA1_INDEX+1];
	uint16 gainbits[2][NPHY_MAX_HPVGA1_INDEX+1];
	phy_info_t *pi = (phy_info_t *)ppi;
	phy_info_nphy_t *pi_nphy = NULL;

	if (pi->u.pi_nphy)
		pi_nphy = pi->u.pi_nphy;

	if (!ISNPHY(pi))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);

	/* Read from the HPVGA1 gaintable */
	wlc_phy_table_read_nphy(pi, 0, NPHY_MAX_HPVGA1_INDEX, 16, 16, &gain[0][0]);
	wlc_phy_table_read_nphy(pi, 1, NPHY_MAX_HPVGA1_INDEX, 16, 16, &gain[1][0]);
	wlc_phy_table_read_nphy(pi, 2, NPHY_MAX_HPVGA1_INDEX, 16, 16, &gainbits[0][0]);
	wlc_phy_table_read_nphy(pi, 3, NPHY_MAX_HPVGA1_INDEX, 16, 16, &gainbits[1][0]);

	if ((pi_nphy) && (pi_nphy->phyhang_avoid))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	for (core = 0; core < 2; core++) {
		bcm_bprintf(b, "Core %d gain: ", core);
		for (ctr = 0; ctr <= NPHY_MAX_HPVGA1_INDEX; ctr++)  {
			bcm_bprintf(b, "%2d ", gain[core][ctr]);
		}
		bcm_bprintf(b, "\n");
	}

	bcm_bprintf(b, "\n");
	for (core = 0; core < 2; core++) {
		bcm_bprintf(b, "Core %d gainbits: ", core);
		for (ctr = 0; ctr <= NPHY_MAX_HPVGA1_INDEX; ctr++)  {
			bcm_bprintf(b, "%2d ", gainbits[core][ctr]);
		}
		bcm_bprintf(b, "\n");
	}
}

void
wlc_phydump_lpphytbl0(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint16 val16;
	lpphytbl_info_t tab;
	int i;
	phy_info_t *pi = (phy_info_t *)ppi;

	if (!ISLPPHY(pi))
		return;

	for (i = 0; i < 108; i ++) {
		tab.tbl_ptr = &val16;	/* ptr to buf */
		tab.tbl_len = 1;	/* # values */
		tab.tbl_id = 0;		/* iqloCaltbl */
		tab.tbl_offset = i;	/* tbl offset */
		tab.tbl_width = 16;	/* 16 bit wide */
		tab.tbl_phywidth = 16; /* width of table element in phy address space */
		wlc_phy_table_read_lpphy(pi, &tab);
		bcm_bprintf(b, "%i:\t%04x\n", i, val16);
	}
}

void
wlc_phydump_chanest(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint16 num_rx, num_sts, num_tones;
	uint16 k, r, t;
	uint32 ch;
	uint16 ch_re_ma, ch_im_ma;
	uint8  ch_re_si, ch_im_si;
	int16  ch_re, ch_im;
	int8   ch_exp;

	phy_info_t *pi = (phy_info_t *)ppi;

	if (!(ISHTPHY(pi) || ISACPHY(pi) || ISNPHY(pi)))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Go deaf to prevent PHY channel writes while doing reads */
	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	num_rx = (uint8)PHYCORENUM(pi->pubpi.phy_corenum);
	num_sts = 4;

	if (CHSPEC_IS40(pi->radio_chanspec)) {
		num_tones = 128;
#ifdef CHSPEC_IS80
	} else if (CHSPEC_IS80(pi->radio_chanspec)) {
		num_tones = 256;
#endif /* CHSPEC_IS80 */
	} else {
		num_tones = 64;
	}

	bcm_bprintf(b, "num_tones=%d\n", num_tones);
	bcm_bprintf(b, "re,im,exp\n");
	for (r = 0; r < num_rx; r++) {
		bcm_bprintf(b, "rx=%d\n", r);
		for (t = 0; t < num_sts; t++) {
			bcm_bprintf(b, "sts=%d\n", t);
			for (k = 0; k < num_tones; k++) {
				if (ISNPHY(pi)) {
					wlc_phy_table_read_nphy(pi, NPHY_TBL_ID_CHANEST, 1,
					                         t*128 + k, 32, &ch);

					/* Q11 FLP (12,12,6) */
					ch_re_ma  = ((ch >> 18) & 0x7ff);
					ch_re_si  = ((ch >> 29) & 0x001);
					ch_im_ma  = ((ch >>  6) & 0x7ff);
					ch_im_si  = ((ch >> 17) & 0x001);
					ch_exp    = ((int8)((ch << 2) & 0xfc)) >> 2;
					ch_re = (ch_re_si > 0) ? -ch_re_ma : ch_re_ma;
					ch_im = (ch_im_si > 0) ? -ch_im_ma : ch_im_ma;

				} else if (ISHTPHY(pi)) {
					wlc_phy_table_read_htphy(pi, HTPHY_TBL_ID_CHANEST(r), 1,
					                         t*128 + k, 32, &ch);

					/* Q11 FLP (12,12,6) */
					ch_re_ma  = ((ch >> 18) & 0x7ff);
					ch_re_si  = ((ch >> 29) & 0x001);
					ch_im_ma  = ((ch >>  6) & 0x7ff);
					ch_im_si  = ((ch >> 17) & 0x001);
					ch_exp    = ((int8)((ch << 2) & 0xfc)) >> 2;
					ch_re = (ch_re_si > 0) ? -ch_re_ma : ch_re_ma;
					ch_im = (ch_im_si > 0) ? -ch_im_ma : ch_im_ma;

				} else {
					ASSERT(ISACPHY(pi));
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_CHANEST(r), 1,
					                         t*256 + k, 32, &ch);

					if (ACMAJORREV_1(pi->pubpi.phy_rev) ||
					    (ACMAJORREV_2(pi->pubpi.phy_rev) &&
					    ACMINORREV_2(pi->pubpi.phy_rev))) {
						/* Q11 FLP (12,12,6) */
						ch_re_ma  = ((ch >> 18) & 0x7ff);
						ch_re_si  = ((ch >> 29) & 0x001);
						ch_im_ma  = ((ch >>  6) & 0x7ff);
						ch_im_si  = ((ch >> 17) & 0x001);
						ch_exp    = ((int8)((ch << 2) & 0xfc)) >> 2;
						ch_re = (ch_re_si > 0) ? -ch_re_ma : ch_re_ma;
						ch_im = (ch_im_si > 0) ? -ch_im_ma : ch_im_ma;
					} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
						/* Q8 FLP (9,9,5) */
						ch_re_ma  = ((ch >> 14) & 0xff);
						ch_re_si  = ((ch >> 22) & 0x01);
						ch_im_ma  = ((ch >>  5) & 0xff);
						ch_im_si  = ((ch >> 13) & 0x01);
						ch_exp    = ((int8)((ch << 3) & 0xf8)) >> 3;
						ch_re = (ch_re_si > 0) ? -ch_re_ma : ch_re_ma;
						ch_im = (ch_im_si > 0) ? -ch_im_ma : ch_im_ma;
					} else {
						/* Q13 FXP (14,14) */
						ch_re_ma  = ((ch >> 14) & 0x3fff);
						ch_im_ma  = ((ch >>  0) & 0x3fff);
						ch_exp = 0;
						ch_re = ((int16)((ch_re_ma << 2) & 0xfffc)) >> 2;
						ch_im = ((int16)((ch_im_ma << 2) & 0xfffc)) >> 2;
					}
				}

				bcm_bprintf(b, "%d,%d,%d\n", ch_re, ch_im, ch_exp);
			}
		}
	}

	/* Return from deaf */
	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}

#ifdef ENABLE_FCBS
void
wlc_phydump_fcbs(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint shmem_radioreg, shmem_phytbl16, shmem_phytbl32;
	uint shmem_phyreg, shmem_bphyctrl, shmem_cache_ptr;
	int bwidx[2];
	int len, cache_consumed;
	char *bwstr [ ] = {"", "20MHz", "40MHz"};
	phy_info_t *pi = (phy_info_t *)ppi;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	shmem_radioreg = (pi->phy_fcbs.shmem_radioreg != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_radioreg) : 0;

	shmem_phytbl16 = (pi->phy_fcbs.shmem_phytbl16 != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_phytbl16) : 0;

	shmem_phytbl32 = (pi->phy_fcbs.shmem_phytbl32 != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_phytbl32) : 0;

	shmem_phyreg = (pi->phy_fcbs.shmem_phyreg != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_phyreg) : 0;

	shmem_bphyctrl = (pi->phy_fcbs.shmem_bphyctrl != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_bphyctrl) : 0;

	shmem_cache_ptr = (pi->phy_fcbs.shmem_cache_ptr != 0) ?
	    wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr) : 0;

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	bcm_bprintf(b, "FCBS h/w addresses:\n");
	bcm_bprintf(b, "-------------------\n");
	bcm_bprintf(b, "RAM start address      = 0x%04x\n", pi->phy_fcbs.cache_startaddr);
	bcm_bprintf(b, "SHMEM radio address    = 0x%04x\n", pi->phy_fcbs.shmem_radioreg);
	bcm_bprintf(b, "SHMEM phytbl16 address = 0x%04x\n", pi->phy_fcbs.shmem_phytbl16);
	bcm_bprintf(b, "SHMEM phytbl32 address = 0x%04x\n", pi->phy_fcbs.shmem_phytbl32);
	bcm_bprintf(b, "SHMEM phyreg address   = 0x%04x\n", pi->phy_fcbs.shmem_phyreg);
	bcm_bprintf(b, "SHMEM bphyctrl address = 0x%04x\n", pi->phy_fcbs.shmem_bphyctrl);
	bcm_bprintf(b, "SHMEM cacheptr address = 0x%04x\n\n", pi->phy_fcbs.shmem_cache_ptr);

	bcm_bprintf(b, "FCBS shmem values:\n");
	bcm_bprintf(b, "------------------\n");
	bcm_bprintf(b, "radioreg  = %d\n", shmem_radioreg);
	bcm_bprintf(b, "phytbl16  = %d\n", shmem_phytbl16);
	bcm_bprintf(b, "phytbl32  = %d\n", shmem_phytbl32);
	bcm_bprintf(b, "phyreg    = %d\n", shmem_phyreg);
	bcm_bprintf(b, "bphyctrl  = 0x%04x\n", shmem_bphyctrl);
	bcm_bprintf(b, "cacheptr  = 0x%04x\n\n", shmem_cache_ptr);

	cache_consumed = 0;
	bcm_bprintf(b, "FCBS cache consumption:\n");
	bcm_bprintf(b, "-----------------------\n");
	len = pi->phy_fcbs.num_radio_regs * 2 * sizeof(uint16);
	bcm_bprintf(b, "Radio reg cache:\n");
	bcm_bprintf(b, "   CHAN_A = %d bytes\n", len);
	cache_consumed += len;
	bcm_bprintf(b, "   CHAN_B = %d bytes\n", len);
	cache_consumed += len;

	len = pi->phy_fcbs.phytbl16_buflen;
	if (((len/4) * 4) != len) {
		len += 2;
	}
	bcm_bprintf(b, "PHYTBL16 cache:\n");
	bcm_bprintf(b, "   CHAN_A = %d bytes\n", len);
	cache_consumed += len;
	bcm_bprintf(b, "   CHAN_B = %d bytes\n", len);
	cache_consumed += len;

	len = pi->phy_fcbs.phytbl32_buflen;
	bcm_bprintf(b, "PHYTBL32 cache:\n");
	bcm_bprintf(b, "   CHAN_A = %d bytes\n", len);
	cache_consumed += len;
	bcm_bprintf(b, "   CHAN_B = %d bytes\n", len);
	cache_consumed += len;

	len = pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_A];
	bcm_bprintf(b, "PHY reg cache:\n");
	bcm_bprintf(b, "   CHAN_A = %d bytes\n", len);
	cache_consumed += len;
	len = pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_B];
	bcm_bprintf(b, "   CHAN_B = %d bytes\n\n", len);
	cache_consumed += len;
	bcm_bprintf(b, "Total cache used by FCBS = %d bytes\n\n", cache_consumed);

	bcm_bprintf(b, "FCBS reg and table entry count:\n");
	bcm_bprintf(b, "-------------------------------\n");
	bcm_bprintf(b, "Radio regs       = %d\n", pi->phy_fcbs.num_radio_regs);
	bcm_bprintf(b, "PHYTBL16 entries = %d\n", pi->phy_fcbs.phytbl16_entries);
	bcm_bprintf(b, "PHYTBL32 entries = %d\n", pi->phy_fcbs.phytbl32_entries);
	bcm_bprintf(b, "PHY regs         = %d\n", pi->phy_fcbs.num_phy_regs);
	bcm_bprintf(b, "BPHY regs:\n");
	bcm_bprintf(b, "   CHAN_A = %d\n", pi->phy_fcbs.num_bphy_regs[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = %d\n\n", pi->phy_fcbs.num_bphy_regs[FCBS_CHAN_B]);

	bcm_bprintf(b, "FCBS cache offsets:\n");
	bcm_bprintf(b, "-------------------\n");
	bcm_bprintf(b, "Channel cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.chan_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n", pi->phy_fcbs.chan_cache_offset[FCBS_CHAN_B]);
	bcm_bprintf(b, "Radio reg cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.radioreg_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n", pi->phy_fcbs.radioreg_cache_offset[FCBS_CHAN_B]);
	bcm_bprintf(b, "PHYTBL16 cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.phytbl16_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n", pi->phy_fcbs.phytbl16_cache_offset[FCBS_CHAN_B]);
	bcm_bprintf(b, "PHYTBL32 cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.phytbl32_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n", pi->phy_fcbs.phytbl32_cache_offset[FCBS_CHAN_B]);
	bcm_bprintf(b, "PHY reg cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.phyreg_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n", pi->phy_fcbs.phyreg_cache_offset[FCBS_CHAN_B]);
	bcm_bprintf(b, "BPHY reg cache offset:\n");
	bcm_bprintf(b, "   CHAN_A = 0x%04x\n", pi->phy_fcbs.bphyreg_cache_offset[FCBS_CHAN_A]);
	bcm_bprintf(b, "   CHAN_B = 0x%04x\n\n", pi->phy_fcbs.bphyreg_cache_offset[FCBS_CHAN_B]);

	if (pi->phy_fcbs.initialized[FCBS_CHAN_A]) {
		if (CHSPEC_IS40(pi->phy_fcbs.chanspec[FCBS_CHAN_A])) {
			bwidx[0] = 2;
		} else {
			bwidx[0] = 1;
		}
	} else {
		bwidx[0] = 0;
	}

	if (pi->phy_fcbs.initialized[FCBS_CHAN_B]) {
		if (CHSPEC_IS40(pi->phy_fcbs.chanspec[FCBS_CHAN_B])) {
			bwidx[1] = 2;
		} else {
			bwidx[1] = 1;
		}
	} else {
		bwidx[1] = 0;
	}
	bcm_bprintf(b, "FCBS driver internal:\n");
	bcm_bprintf(b, "---------------------\n");
	bcm_bprintf(b, "Initialized   : CHAN_A=%3d, CHAN_B=%3d\n",
	    pi->phy_fcbs.initialized[FCBS_CHAN_A], pi->phy_fcbs.initialized[FCBS_CHAN_B]);
	bcm_bprintf(b, "Channels      : CHAN_A=%3d, CHAN_B=%3d\n",
	    CHSPEC_CHANNEL(pi->phy_fcbs.chanspec[FCBS_CHAN_A]),
	    CHSPEC_CHANNEL(pi->phy_fcbs.chanspec[FCBS_CHAN_B]));
	bcm_bprintf(b, "Bandwidth     : CHAN_A=%s, CHAN_B=%s\n", bwstr[bwidx[0]], bwstr[bwidx[1]]);
	bcm_bprintf(b, "Channel index : %d\n", pi->phy_fcbs.curr_fcbs_chan);
	bcm_bprintf(b, "Switch count  : %d\n", pi->phy_fcbs.switch_count);
	bcm_bprintf(b, "Load regs/tbls: %d\n", pi->phy_fcbs.load_regs_tbls);
}
#endif /* ENABLE_FCBS */

void
wlc_phydump_txv0(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint16 k;
	uint32 tbl_val;
	uint8 stall_val;

	phy_info_t *pi = (phy_info_t *)ppi;

	if (!ISACPHY(pi))
		return;

	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* disable stall */
	stall_val = (phy_reg_read(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev)) &
	             ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev))
	        >> ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev);
	phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
	            ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
	            1 << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));

	/* id=16, depth=1952 words for usr 0, width=32 */
	for (k = 0; k < 1952; k++) {
		wlc_phy_table_read_acphy(pi, 16, 1, k, 32, &tbl_val);
		bcm_bprintf(b, "0x%08x\n", tbl_val);
	}

	/* restore stall value */
	phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
	            ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
	            stall_val << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));

	wlc_phyreg_exit((wlc_phy_t *)pi);
}
#endif /* BCMDBG || BCMDBG_DUMP || BCMDBG_PHYDUMP */

#ifdef WLTEST
void
wlc_phydump_ch4rpcal(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	uint16 num_tones;
	uint16 k, r, fftk, fft_size;
	uint32 ch, tbl_id;
	uint16 ch_re_ma, ch_im_ma;
	uint8  ch_re_si, ch_im_si;
	int16  ch_re, ch_im;
	uint16 *tone_idx_tbl;
	uint16 tone_idx_20[52]  = {
		4,  5,  6,  7,  8,  9, 10, 12, 13, 14, 15, 16, 17,
		18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31,
		33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46,
		47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60};

	uint16 tone_idx_40[108] = {
		6,  7,  8,  9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
		25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43,
		44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62,
		66, 67, 68, 69, 70, 71, 72, 73, 74, 76, 77, 78, 79, 80, 81, 82, 83, 84,
		85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,
		103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
		118, 119, 120, 121, 122};

#ifdef CHSPEC_IS80
	uint16 tone_idx_80[234] = {
		6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
		24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
		43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61,
		62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
		80, 81, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98,
		99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
		114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 126, 130, 131, 132,
		133, 134, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 148,
		149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163,
		164, 165, 166, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
		180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
		195, 196, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210,
		211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225,
		226, 227, 228, 229, 230, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241,
		242, 243, 244, 245, 246, 247, 248, 249, 250};
#endif /* CHSPEC_IS80 */

	phy_info_t *pi = (phy_info_t *)ppi;

	if (!(ISHTPHY(pi) || ISACPHY(pi) || ISNPHY(pi)))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Go deaf to prevent PHY channel writes while doing reads */
	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, TRUE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	if (CHSPEC_IS40(pi->radio_chanspec)) {
		num_tones = 108;
		fft_size = 128;
		tone_idx_tbl = tone_idx_40;
#ifdef CHSPEC_IS80
	} else if (CHSPEC_IS80(pi->radio_chanspec)) {
		num_tones = 234;
		fft_size = 256;
		tone_idx_tbl = tone_idx_80;
#endif /* CHSPEC_IS80 */
	} else {
		num_tones = 52;
		fft_size = 64;
		tone_idx_tbl = tone_idx_20;
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, r) {
		for (k = 0; k < num_tones; k++) {
			fftk = tone_idx_tbl[k];
			fftk = (fftk < fft_size/2) ? (fftk + fft_size/2) : (fftk - fft_size/2);

			if (ISNPHY(pi)) {
				tbl_id = NPHY_TBL_ID_CHANEST;
				wlc_phy_table_read_nphy(pi, tbl_id, 1, fftk, 32, &ch);
			} else if (ISHTPHY(pi)) {
				tbl_id = HTPHY_TBL_ID_CHANEST(r);
				wlc_phy_table_read_htphy(pi, tbl_id, 1, fftk, 32, &ch);
			} else if (ISACPHY(pi)) {
				tbl_id = ACPHY_TBL_ID_CHANEST(r);
				wlc_phy_table_read_acphy(pi, tbl_id, 1, fftk, 32, &ch);
			}
			if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				ch_re_ma  = ((ch >> 18) & 0x7ff);
				ch_re_si  = ((ch >> 29) & 0x001);
				ch_im_ma  = ((ch >>  6) & 0x7ff);
				ch_im_si  = ((ch >> 17) & 0x001);
			} else {
				ch_re_ma  = ((ch >> 14) & 0xff);
				ch_re_si  = ((ch >> 22) & 0x01);
				ch_im_ma  = ((ch >>  5) & 0xff);
				ch_im_si  = ((ch >> 13) & 0x01);
			}
			ch_re = (ch_re_si > 0) ? -ch_re_ma : ch_re_ma;
			ch_im = (ch_im_si > 0) ? -ch_im_ma : ch_im_ma;

			bcm_bprintf(b, "%d\n%d\n", ch_re, ch_im);
		}
	}

	/* Return from deaf */
	if (ISNPHY(pi))
		wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);
	else if (ISHTPHY(pi))
		wlc_phy_stay_in_carriersearch_htphy(pi, FALSE);
	else if (ISACPHY(pi))
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}
#endif /* WLTEST */

#if defined(DBG_BCN_LOSS)
void
wlc_phydump_phycal_rx_min(wlc_phy_t *ppi, struct bcmstrbuf *b)
{
	nphy_iq_comp_t rxcal_coeffs;
	int time_elapsed;
	phy_info_nphy_t *pi_nphy = NULL;
	phy_info_t *pi = (phy_info_t *)ppi;

	if (!pi->sh->up) {
		PHY_ERROR(("wl%d: %s: Not up, cannot dump \n", pi->sh->unit, __FUNCTION__));
		return;
	}

	if (ISACPHY(pi)) {
		PHY_ERROR(("wl%d: %s: AC Phy not yet supported\n", pi->sh->unit, __FUNCTION__));
		return;
	}
	else if (ISHTPHY(pi)) {
		wlc_phy_cal_dump_htphy_rx_min(pi, b);
	}
	else if (ISNPHY(pi)) {
		pi_nphy = pi->u.pi_nphy;
		if (!pi_nphy) {
			PHY_ERROR(("wl%d: %s: NPhy null, cannot dump \n",
				pi->sh->unit, __FUNCTION__));
			return;
		}

		time_elapsed = pi->sh->now - pi->cal_info->last_cal_time;
		if (time_elapsed < 0)
			time_elapsed = 0;

		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);

		if (pi_nphy->phyhang_avoid)
			wlc_phy_stay_in_carriersearch_nphy(pi, TRUE);

		/* Read Rx calibration co-efficients */
		wlc_phy_rx_iq_coeffs_nphy(pi, 0, &rxcal_coeffs);

		if (pi_nphy->phyhang_avoid)
			wlc_phy_stay_in_carriersearch_nphy(pi, FALSE);

		/* reg access is done, enable the mac */
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);

		bcm_bprintf(b, "time since last cal: %d (sec), mphase_cal_id: %d\n\n",
			time_elapsed, pi->cal_info->cal_phase_id);

		bcm_bprintf(b, "rx cal  a0=%d, b0=%d, a1=%d, b1=%d\n\n",
			rxcal_coeffs.a0, rxcal_coeffs.b0, rxcal_coeffs.a1, rxcal_coeffs.b1);
	}
}
#endif /* DBG_BCN_LOSS */

void
wlc_beacon_loss_war_lcnxn(wlc_phy_t *ppi, uint8 enable)
{
	 phy_info_t *pi = (phy_info_t*)ppi;
		phy_reg_mod(pi, NPHY_reset_cca_frame_cond_ctrl_1,
		NPHY_reset_cca_frame_cond_ctrl_1_resetCCA_frame_cond_en_MASK,
		enable << NPHY_reset_cca_frame_cond_ctrl_1_resetCCA_frame_cond_en_SHIFT);
		phy_reg_mod(pi, NPHY_EngCtrl1,
		NPHY_EngCtrl1_resetBphyEn_MASK,
		enable << NPHY_EngCtrl1_resetBphyEn_SHIFT);
}

const uint8 *
wlc_phy_get_ofdm_rate_lookup(void)
{
	return ofdm_rate_lookup;
}

/* LPCONF || SSLPNCONF */
void
wlc_phy_radio_2063_vco_cal(phy_info_t *pi)
{
	uint8 calnrst;

	/* Power up VCO cal clock */
	mod_radio_reg(pi, RADIO_2063_PLL_SP_1, 1 << 6, 0);

	calnrst = read_radio_reg(pi, RADIO_2063_PLL_JTAG_CALNRST) & 0xf8;
	write_radio_reg(pi, RADIO_2063_PLL_JTAG_CALNRST, calnrst);
	OSL_DELAY(1);
	write_radio_reg(pi, RADIO_2063_PLL_JTAG_CALNRST, calnrst | 0x04);
	OSL_DELAY(1);
	write_radio_reg(pi, RADIO_2063_PLL_JTAG_CALNRST, calnrst | 0x06);
	OSL_DELAY(1);
	write_radio_reg(pi, RADIO_2063_PLL_JTAG_CALNRST, calnrst | 0x07);
	OSL_DELAY(300);

	/* Power down VCO cal clock */
	mod_radio_reg(pi, RADIO_2063_PLL_SP_1, 1 << 6, 1 << 6);
}
void
wlc_lcnphy_epa_switch(phy_info_t *pi, bool mode)
{
	if ((CHIPID(pi->sh->chip) == BCM4313_CHIP_ID) &&
		(BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_FEM)) {
		if (mode) {
			uint16 txant = 0;
			txant = wlapi_bmac_get_txant(pi->sh->physhim);
			if (txant == 1) {
				PHY_REG_MOD(pi, LCNPHY, RFOverrideVal0, ant_selp_ovr_val, 1);
				PHY_REG_MOD(pi, LCNPHY, RFOverride0, ant_selp_ovr, 1);
			}
			si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpiocontrol),
				~0x0, 0x0);
			si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpioout),
				0x40, 0x40);
			si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpioouten),
				0x40, 0x40);
		} else {
			PHY_REG_MOD(pi, LCNPHY, RFOverride0, ant_selp_ovr, 0);
			PHY_REG_MOD(pi, LCNPHY, RFOverrideVal0, ant_selp_ovr_val, 0);
			si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpioout),
				0x40, 0x00);
			si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, gpioouten),
				0x40, 0x0);
			si_corereg(pi->sh->sih, SI_CC_IDX,
				OFFSETOF(chipcregs_t, gpiocontrol), ~0x0, 0x40);
		}
	}
}

bool
wlc_phy_get_tempsense_degree(wlc_phy_t *ppi, int8 *pval)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISLCNPHY(pi))
		*pval = wlc_lcnphy_tempsense_degree(pi, 0);
	else
		return FALSE;
	return TRUE;
}

void
wlc_phy_ldpc_override_set(wlc_phy_t *ppi, bool ldpc)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISHTPHY(pi))
		wlc_phy_update_rxldpc_htphy(pi, ldpc);
	if (ISACPHY(pi))
		wlc_phy_update_rxldpc_acphy(pi, ldpc);
	return;
}

void
wlc_phy_tkip_rifs_war(wlc_phy_t *ppi, uint8 rifs)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISNPHY(pi))
		wlc_phy_nphy_tkip_rifs_war(pi, rifs);
}

void
wlc_phy_get_pwrdet_offsets(phy_info_t *pi, int8 *cckoffset, int8 *ofdmoffset)
{
	*cckoffset = 0;
	*ofdmoffset = 0;
#ifdef WLNOKIA_NVMEM
	if (ISLCNPHY(pi))
		wlc_phy_noknvmem_get_pwrdet_offsets(pi, cckoffset, ofdmoffset);
#endif /* WLNOKIA_NVMEM */
}

uint32
wlc_phy_qdiv(uint32 dividend, uint32 divisor, uint8 precision, bool round)
{
	uint32 quotient, remainder, roundup, rbit;

	ASSERT(divisor);

	quotient = dividend / divisor;
	remainder = dividend % divisor;
	rbit = divisor & 1;
	roundup = (divisor >> 1) + rbit;

	while (precision--) {
		quotient <<= 1;
		if (remainder >= roundup) {
			quotient++;
			remainder = ((remainder - roundup) << 1) + rbit;
		} else {
			remainder <<= 1;
		}
	}

	/* Final rounding */
	if (round && (remainder >= roundup))
		quotient++;

	return quotient;
}

/* update the cck power detector offset */
int8
wlc_phy_upd_rssi_offset(phy_info_t *pi, int8 rssi, chanspec_t chanspec)
{

#ifdef WLNOKIA_NVMEM
	if (rssi != WLC_RSSI_INVALID)
		rssi = wlc_phy_noknvmem_modify_rssi(pi, rssi, chanspec);
#endif // endif
	return rssi;
}

bool
wlc_phy_txpower_ipa_ison(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISNPHY(pi))
		return (wlc_phy_n_txpower_ipa_ison(pi));
	else
		return 0;
}

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
int
wlc_phy_reinit_chanctx(phy_info_t *pi, ch_calcache_t *ctx, chanspec_t chanspec)
{
	ASSERT(ctx);
	ctx->valid = FALSE;
	ctx->chanspec = chanspec;
	ctx->creation_time = pi->sh->now;
#ifndef PHYCAL_CACHE_SMALL
	if (ISLPPHY(pi))
		ctx->u.lpphy_cache.txiqlocal_bestcoeffs_valid = FALSE;
#endif /* PHYCAL_CACHE_SMALL */
	ctx->cal_info.last_cal_time = 0;
	ctx->cal_info.last_papd_cal_time = 0;
	ctx->cal_info.last_cal_temp = -50;
	ctx->in_use = TRUE;
	return 0;
}

int
wlc_phy_invalidate_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx = pi->phy_calcache;

	while (ctx) {
		if (ctx->chanspec == chanspec) {
			ctx->valid = FALSE;
#ifndef PHYCAL_CACHE_SMALL
			if (ISLPPHY(pi))
				ctx->u.lpphy_cache.txiqlocal_bestcoeffs_valid = FALSE;
#endif /* PHYCAL_CACHE_SMALL */
			ctx->cal_info.last_cal_time = 0;
			ctx->cal_info.last_papd_cal_time = 0;
			ctx->cal_info.last_cal_temp = -50;
			return 0;
		}
		ctx = ctx->next;
	}

	return 0;
}
/*   This function will try and reuse the existing ctx:
	return 0 --> couldn't find any ctx
	return 1 --> channel ctx exist
	return 2 --> grabbed an invalid ctx
*/
int
wlc_phy_reuse_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx = pi->phy_calcache;

	/* Check for existing */
	if (wlc_phy_get_chanctx(pi, chanspec))
		return 1;

	/* Check if there are any invalid entries and use them */
	while (ctx) {
		if (ctx->valid == FALSE && ctx->in_use == FALSE) {
			wlc_phy_reinit_chanctx(pi, ctx, chanspec);
			return 2;
		}
		ctx = ctx->next;
	}
	return 0;
}
int
wlc_phy_create_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	ch_calcache_t *ctx;
	phy_info_t *pi = (phy_info_t *)ppi;

	/* Check for existing */
	if (wlc_phy_reuse_chanctx(ppi, chanspec) != 0)
		return 0;

	if (!(ctx = (ch_calcache_t *)MALLOC(pi->sh->osh, sizeof(ch_calcache_t)))) {
		PHY_ERROR(("%s: out of memory %d\n", __FUNCTION__, MALLOCED(pi->sh->osh)));
		return BCME_NOMEM;
	}
	bzero(ctx, sizeof(ch_calcache_t));

	ctx->chanspec = chanspec;
	ctx->creation_time = pi->sh->now;
	ctx->cal_info.last_cal_temp = -50;
	ctx->cal_info.txcal_numcmds = pi->def_cal_info.txcal_numcmds;
	ctx->in_use = TRUE;

	/* Add it to the list */
	ctx->next = pi->phy_calcache;

	/* For the first context, switch out the default context */
	if (pi->phy_calcache == NULL &&
	    (pi->radio_chanspec == chanspec))
		pi->cal_info = &ctx->cal_info;
	pi->phy_calcache = ctx;
	pi->phy_calcache_num++;

	return 0;
}

void
wlc_phy_destroy_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx;

	/* Remove Memory for 4324B1/B3/B5 and the ac chips, for other chips, Do not      *
	* remove memory but just invalidate the context                 *
	*/
	ctx = wlc_phy_get_chanctx(pi, chanspec);

	if (ctx && (CHIPID_4324X_EPA_FAMILY(pi) || ISACPHY(pi))) {
		ch_calcache_t *rem;

		ctx = pi->phy_calcache;
		rem = pi->phy_calcache;

		while (rem) {
			if (rem->chanspec == chanspec) {
				if (rem == pi->phy_calcache)
					pi->phy_calcache = rem->next;
				else
					ctx->next = rem->next;

				/* If the current cal_info points to the one being removed
				*  then switch NULL it
				*/
				if (pi->cal_info == &rem->cal_info)
					pi->cal_info = NULL;

				MFREE(pi->sh->osh, rem,
					sizeof(ch_calcache_t));
				rem = NULL;
				pi->phy_calcache_num--;
				break;
			}
			ctx = rem;
			rem = rem->next;
		}
		/* Set the correct context if one exists, otherwise,
		 * switch in the default one
		 */
		if (pi->cal_info == NULL) {
			ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
			if (!ctx) {
				pi->cal_info = &pi->def_cal_info;
				/* Reset the parameters */
				pi->cal_info->last_cal_temp = -50;
				pi->cal_info->last_cal_time = 0;
				pi->cal_info->last_temp_cal_time = 0;
				pi->cal_info->last_papd_cal_time = 0;
			} else
			pi->cal_info = &ctx->cal_info;
		}
	} /* end if CHIPID_4324X_EPA_FAMILY */
	else if (ctx) {
		ctx->valid = FALSE;
		ctx->in_use = FALSE;
	}
}

void
wlc_phy_update_chctx_glacial_time(wlc_phy_t *ppi, chanspec_t chanspec)
{
	ch_calcache_t *ctx;
	phy_info_t *pi = (phy_info_t *)ppi;
	if ((ctx = wlc_phy_get_chanctx((phy_info_t *)ppi, chanspec)))
		ctx->cal_info.last_cal_time = pi->sh->now - pi->sh->glacial_timer;
}

/* this function can be used to display the remaining chanctx */
void
wlc_phy_display_chanctx(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx;

	ctx = pi->phy_calcache;
	while (ctx) {
		printf("wl: %s, ctx = 0X%p, channel=%d\n", __FUNCTION__, ctx,
			CHSPEC_CHANNEL(ctx->chanspec));
		ctx = ctx->next;
	}
}

ch_calcache_t *
wlc_phy_get_chanctx_oldest(phy_info_t *phi)
{
	ch_calcache_t *ctx = phi->phy_calcache;
	ch_calcache_t *ctx_lo_ctime = ctx;
	while (ctx->next) {
		ctx = ctx->next;
		if (ctx_lo_ctime->creation_time > ctx->creation_time)
			ctx_lo_ctime = ctx;
	}
	return ctx_lo_ctime;
}

ch_calcache_t *
wlc_phy_get_chanctx(phy_info_t *phi, chanspec_t chanspec)
{
	ch_calcache_t *ctx = phi->phy_calcache;
	while (ctx) {
		if (ctx->chanspec == chanspec)
			return ctx;
		ctx = ctx->next;
	}
	return NULL;
}

bool
wlc_phy_chan_iscached(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx;
	bool ret = 0;

	ctx = wlc_phy_get_chanctx(pi, chanspec);

	if (ctx != NULL)
		if (ctx->valid)
			ret = 1;

	return ret;
}

void wlc_phy_get_all_cached_ctx(wlc_phy_t *ppi, chanspec_t *chanlist)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx = pi->phy_calcache;
	int i = 0;

	while (ctx) {
		*(chanlist+i) = ctx->chanspec;
		i++;
		ctx = ctx->next;
	}
}

void
wlc_phy_get_cachedchans(wlc_phy_t *ppi, chanspec_t *chanlist)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx = pi->phy_calcache;
	chanlist[0] = 0;

	while (ctx) {
		if (ctx->valid) {
			chanlist[0] += 1;
			chanlist[chanlist[0]] = ctx->chanspec;
		}
		ctx = ctx->next;
	}
}

int32
wlc_phy_get_est_chanset_time(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_calcache_t *ctx;
	uint8 index, is5g = 0;

	ctx = wlc_phy_get_chanctx(pi, chanspec);
	index = (CHSPEC_BAND(chanspec) == CHSPEC_BAND(pi->radio_chanspec));
	if (CHSPEC_IS5G(chanspec))
		is5g = 1;

	if (ctx != NULL)
		if (ctx->valid)
			index += 2;

	return (pi->chan_set_est_time[is5g][index]);
}

void
wlc_phy_set_est_chanset_time(wlc_phy_t *ppi, chanspec_t from_chanspec,
bool iscached, bool inband, int32 rectime)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	uint8 index, is5g = 0;

	index = inband + (iscached << 1);

#ifdef BAND5G
	if (CHSPEC_IS5G(from_chanspec))
		is5g = 1;
#endif /* BAND5G */
	pi->chan_set_est_time[is5g][index] = rectime;
}

int8
wlc_phy_get_max_cachedchans(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISLCN40PHY(pi))
		return (wlc_lcn40phy_max_cachedchans(pi));

	return (-1);
}

uint32
wlc_phy_get_current_cachedchans(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi) {
#if defined(WLMCHAN) || defined(PHYCAL_CACHING)|| defined(WL_MODESW)
		return pi->phy_calcache_num;
#endif // endif
	}
	return 0;
}

#if defined(WLMCHAN) && defined(BCMDBG)
static void
wlc_phydump_chanctx(phy_info_t *phi, struct bcmstrbuf *b)
{
	ch_calcache_t *ctx = phi->phy_calcache;

	if (phi->HW_FCBS) {
		return;
	}

	bcm_bprintf(b, "Current chanspec: 0x%x\n", phi->radio_chanspec);
	while (ctx) {
			bcm_bprintf(b, "%sContext found for chanspec: 0x%x\n",
			            (ctx->valid)? "Valid ":"",
			            ctx->chanspec);
		if (ISNPHY(phi)) {
			wlc_phydump_cal_cache_nphy(phi, ctx, b);
		} else if (ISHTPHY(phi)) {
			wlc_phydump_cal_cache_htphy(phi, ctx, b);
		} else if (ISACPHY(phi)) {
			wlc_phydump_cal_cache_acphy(phi, ctx, b);
		}

		ctx = ctx->next;
	}
}
#endif /* WLMCHAN && BCMDBG  */

void
wlc_phy_cal_cache(wlc_phy_t *ppi)
{
	if (ISACPHY((phy_info_t*)ppi)) {
		wlc_phy_cal_cache_acphy(ppi);
	}
}

int
wlc_phy_cal_cache_restore(phy_info_t *pi)
{
	if (ISNPHY(pi)) {
		return (wlc_phy_cal_cache_restore_nphy(pi));
	} else if (ISHTPHY(pi)) {
		return (wlc_phy_cal_cache_restore_htphy(pi));
	} else if (ISACPHY(pi)) {
		return (wlc_phy_cal_cache_restore_acphy(pi));
	} else {
		return 0;
	}
}

int
wlc_phy_cal_cache_return(wlc_phy_t *ppi)
{
	return wlc_phy_cal_cache_restore((phy_info_t *)ppi);
}
#endif /* #if defined(PHYCAL_CACHING) || defined(WLMCHAN) */

#ifndef WLC_DISABLE_ACI
#ifdef WLPHYACICACHE
/* Following function returns pointer to the context  (if exists) for given chanspec */
ch_acicache_t *
wlc_phy_get_aci_chanctx(phy_info_t *phi, chanspec_t chanspec)
{
	ch_acicache_t *ctx = phi->phy_acicache;
	while (ctx) {
		if (ctx->chanspec == chanspec)
			return ctx;
		ctx = ctx->next;
	}
	return NULL;
}

int
wlc_phy_create_aci_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	ch_acicache_t *ctx;
	phy_info_t *pi = (phy_info_t *)ppi;

	/* Check for existing */
	if (wlc_phy_get_aci_chanctx(pi, chanspec))
		return BCME_OK;

	if (!(ctx = (ch_acicache_t *)MALLOC(pi->sh->osh, sizeof(ch_acicache_t)))) {
		PHY_ERROR(("%s: out of memory %d\n", __FUNCTION__, MALLOCED(pi->sh->osh)));
		return BCME_NOMEM;
	}
	bzero(ctx, sizeof(ch_acicache_t));

	ctx->chanspec = chanspec;

	/* Initialize the values of variables in here */
	wlc_phy_init_aci_chanctx(pi, ctx);

	/* Add it to the list */
	ctx->next = pi->phy_acicache;
	pi->phy_acicache = ctx;
	pi->phy_acicache_num++;

	return BCME_OK;
}

int
wlc_phy_destroy_aci_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_acicache_t *ctx, *rem;

	ctx = pi->phy_acicache;
	rem = pi->phy_acicache;

	while (rem) {
		/* Check if the context pointed by rem is to be deleted */
		if (rem->chanspec == chanspec) {
			if (rem == pi->phy_acicache)
				pi->phy_acicache = rem->next;
			else
				ctx->next = rem->next;

			MFREE(pi->sh->osh, rem,	sizeof(ch_acicache_t));
			rem = NULL;
			pi->phy_acicache_num--;
			return BCME_OK;
		}
		ctx = rem;
		rem = rem->next;
	}
	return BCME_BADADDR;
}

int
wlc_phy_invalidate_aci_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	ch_acicache_t *ctx;
	phy_info_t *pi = (phy_info_t *)ppi;

	ctx = wlc_phy_get_aci_chanctx(pi, chanspec);
	if (ctx) {
		ctx->valid = FALSE;
		return BCME_OK;
	} else
		return BCME_ERROR;
}

/*   This function will try and reuse the existing ctx:
	 return -1 --> couldn't find any ctx
	 return 1 --> A valid channel ctx exists
	 return 2 --> Got an invalid ctx. Reinitialize and validate it
*/
int
wlc_phy_reuse_aci_chanctx(wlc_phy_t *ppi, chanspec_t chanspec)
{
	ch_acicache_t *ctx;
	phy_info_t *pi = (phy_info_t *)ppi;

	ctx = wlc_phy_get_aci_chanctx(pi, chanspec);
	if (ctx) {
		if (ctx->valid)
			return 1;
		else {
			wlc_phy_init_aci_chanctx(pi, ctx);
			return 2;
		}
	} else
		return BCME_ERROR;
}

/* this function can be used to display the remaining chanctx */
void
wlc_phy_display_aci_chanctx(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_acicache_t *aci_ctx;

	aci_ctx = pi->phy_acicache;
	while (aci_ctx) {
		/*
		PHY_TRACE(("wl: %s, ctx = 0X%x, channel=%d\n", __FUNCTION__, ctx,
			CHSPEC_CHANNEL(ctx->chanspec)));
		 */
		printf("wl: %s, ctx = 0X%x, channel=%d\n", __FUNCTION__, aci_ctx,
			CHSPEC_CHANNEL(aci_ctx->chanspec));
		aci_ctx = aci_ctx->next;
	}
}
void
wlc_phy_init_aci_chanctx(phy_info_t *pi, ch_acicache_t *ctx)
{
	/* Copy all the init values from pi */
	wlc_phy_aci_cache_save(pi, ctx);
	/* Initialize remaining variables */
	ctx->now = 0;
	ctx->dwell_time_since_update = 0;
	ctx->aci_cache.sum_delta_crsglitch = 0;
	ctx->aci_cache.sum_delta_bphy_crsglitch = 0;
	ctx->aci_cache.sum_delta_badplcp = 0;
	ctx->aci_cache.sum_delta_bphy_badplcp = 0;
}
#endif /* WLPHYACICACHE */
#endif /* WLC_DISABLE_ACI */

/* Generic routines to read and write sets of phy regs */
/* Callers to make sure the clocks are on, memory for the save/restore space is valid */

typedef enum access_phy_or_radio {
	ACCESS_PHY = 0,
	ACCESS_RADIO = 1
} access_phy_or_radio;

/*
 * wlc_regs_bulkread - Table driven read of multiple PHY or RADIO registers
 *
 * Parameters:
 *   pi           - Phy Info for the call to read_XXX_reg()
 *   addrvals     - A series of uint16: addr1, value1, addr2, value2, ..., addrN, valueN
 *                  The register contents are written into the "valueX" elements.
 *   nregs        - Number of registers to read.
 *                  There are this many addresses *plus* this many values in the array parameter.
 *   which        - Whether reading PHY or RADIO registers
 */
static void
wlc_regs_bulkread(phy_info_t *pi, uint16 *addrvals, uint32 nregs, access_phy_or_radio which)
{
	/* Pointer to step through array of address/value pairs. */
	uint16 * reginfop = addrvals;

	/*
	 * Use a function pointer to choose between
	 * access PHY or RADIO registers.
	 */
	uint16 (*readfp)(phy_info_t*, uint16) = 0;

	if (which == ACCESS_PHY)
		readfp = phy_reg_read;
	else
		readfp = read_radio_reg;

	/*
	 * Read the registers using address from the array parameters,
	 * and store the results back into the array.
	 */
	while (reginfop < addrvals + (2 * nregs)) {
		reginfop[1] = readfp(pi, reginfop[0]);
		reginfop += 2;
	}
}

/*
 * wlc_phyregs_bulkwrite - Table driven write of multiple PHY registers
 *
 * Parameters:
 *   pi           - Phy Info for the call to phy_reg_read()
 *   addrvals     - A series of uint16: addr1, value1, addr2, value2, ..., addrN, valueN
 *                  The register contents are written into the "valueX" elements.
 *   nregs        - Number of registers to read.
 *                  There are this many addresses *plus* this many values in the array parameter.
 *   which        - Whether reading phy or radio registers (0=phy, 1=radio)
 */
static void
wlc_regs_bulkwrite(phy_info_t *pi, const uint16 *addrvals, uint32 nregs, access_phy_or_radio which)
{
	/* Pointer to step through array of address/value pairs. */
	const uint16 *reginfop = addrvals;

	/*
	 * Use a function pointer to choose between
	 * accessing PHY or RADIO registers.
	 */
	void (*writefp)(phy_info_t*, uint16 addr, uint16 value) = 0;

	if (which == ACCESS_PHY)
		writefp = phy_reg_write;
	else
		writefp = write_radio_reg;

	while (reginfop < addrvals + (2 * nregs)) {
		writefp(pi, reginfop[0], reginfop[1]);
		reginfop += 2;
	}
}

void
wlc_phyregs_bulkread(phy_info_t *pi, uint16 *addrvals, uint32 nregs)
{
	wlc_regs_bulkread(pi, addrvals, nregs, ACCESS_PHY);
}

void
wlc_phyregs_bulkwrite(phy_info_t *pi, const uint16 *addrvals, uint32 nregs)
{
	wlc_regs_bulkwrite(pi, addrvals, nregs, ACCESS_PHY);
}

void
wlc_radioregs_bulkread(phy_info_t *pi, uint16 *addrvals, uint32 nregs)
{
	wlc_regs_bulkread(pi, addrvals, nregs, ACCESS_RADIO);
}

void
wlc_radioregs_bulkwrite(phy_info_t *pi, const uint16 *addrvals, uint32 nregs)
{
	wlc_regs_bulkwrite(pi, addrvals, nregs, ACCESS_RADIO);
}

void
wlc_mod_phyreg_bulk(phy_info_t *pi, uint16 *regs, uint16 *mask, uint16 *val, uint32 nregs)
{
	uint32 i;

	for (i = 0; i < nregs; i++)
		phy_reg_mod(pi, regs[i], mask[i], val[i]);
}

int
wlc_phy_txpower_core_offset_set(wlc_phy_t *ppi, struct phy_txcore_pwr_offsets *offsets)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	int err = BCME_UNSUPPORTED;

	if (pi->pi_fptr.txcorepwroffsetset)
		err = (*pi->pi_fptr.txcorepwroffsetset)(pi, offsets);

	return err;
}

int
wlc_phy_txpower_core_offset_get(wlc_phy_t *ppi, struct phy_txcore_pwr_offsets *offsets)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	int err = BCME_UNSUPPORTED;

	if (pi->pi_fptr.txcorepwroffsetget)
		err = (*pi->pi_fptr.txcorepwroffsetget)(pi, offsets);

	return err;
}

#ifndef PPR_API
static void
BCMNMIATTACHFN(wlc_phy_txpwr_srom9_convert)(phy_info_t *pi, uint8 *srom_max, uint32 pwr_offset,
	uint8 tmp_max_pwr, uint8 rate_start, uint8 rate_end, bool shift)
{
	uint8 rate;
	uint8 nibble;

	if (pi->sh->sromrev < 9) {
		ASSERT(0 && "SROMREV < 9");
		return;
	}

	for (rate = rate_start; rate <= rate_end; rate++) {
		nibble = (uint8)(pwr_offset & 0xf);
		if (shift)
			pwr_offset >>= 4;
		/* nibble info indicates offset in 0.5dB units convert to 0.25dB */
		srom_max[rate] = tmp_max_pwr - (nibble << 1);
	}
}
void
BCMNMIATTACHFN(wlc_phy_txpwr_apply_srom9)(phy_info_t *pi)
{

	srom_pwrdet_t	*pwrdet  = &pi->pwrdet;
	uint8 tmp_max_pwr = 0;
	uint8 *tx_srom_max_rate = NULL;
	uint32 ppr_offsets[PWR_OFFSET_SIZE];
	uint32 pwr_offsets;
	uint rate_cnt, rate;
	int band_num;
	bool shift;

	for (band_num = 0; band_num < NUMSUBBANDS(pi); band_num++) {
		bzero((uint8 *)ppr_offsets, PWR_OFFSET_SIZE * sizeof(uint32));
		if (ISNPHY(pi)) {
			/* find MIN of 2  cores, board limits */
			tmp_max_pwr = MIN(pwrdet->max_pwr[0][band_num],
				pwrdet->max_pwr[1][band_num]);
		}
		if (ISPHY_HT_CAP(pi)) {
			tmp_max_pwr =
				MIN(pwrdet->max_pwr[0][band_num], pwrdet->max_pwr[1][band_num]);
			tmp_max_pwr =
				MIN(tmp_max_pwr, pwrdet->max_pwr[2][band_num]);
		}

		ppr_offsets[OFDM_20_PO] = pi->ppr.sr9.ofdm[band_num].bw20;
		ppr_offsets[OFDM_20UL_PO] = pi->ppr.sr9.ofdm[band_num].bw20ul;
		ppr_offsets[OFDM_40DUP_PO] = pi->ppr.sr9.ofdm[band_num].bw40;
		ppr_offsets[MCS_20_PO] = pi->ppr.sr9.mcs[band_num].bw20;
		ppr_offsets[MCS_20UL_PO] = pi->ppr.sr9.mcs[band_num].bw20ul;
		ppr_offsets[MCS_40_PO] = pi->ppr.sr9.mcs[band_num].bw40;
		tx_srom_max_rate = (uint8*)(&(pi->tx_srom_max_rate[band_num][0]));

		switch (band_num) {
			case WL_CHAN_FREQ_RANGE_2G:
				ppr_offsets[MCS32_PO] = (uint32)(pi->ppr.sr9.mcs32po & 0xf);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw202gpo, tmp_max_pwr,
					TXP_FIRST_CCK, TXP_LAST_CCK, TRUE);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw202gpo, tmp_max_pwr,
					TXP_FIRST_CCK_CDD_S1x2, TXP_LAST_CCK_CDD_S1x2, TRUE);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw202gpo, tmp_max_pwr,
					TXP_FIRST_CCK_CDD_S1x3, TXP_LAST_CCK_CDD_S1x3, TRUE);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw20ul2gpo, tmp_max_pwr,
					TXP_FIRST_20UL_CCK, TXP_LAST_20UL_CCK, TRUE);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw20ul2gpo, tmp_max_pwr,
					TXP_FIRST_CCK_20U_CDD_S1x2,
					TXP_LAST_CCK_20U_CDD_S1x2, TRUE);
				wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate,
					pi->ppr.sr9.cckbw20ul2gpo, tmp_max_pwr,
					TXP_FIRST_CCK_20U_CDD_S1x3,
					TXP_LAST_CCK_20U_CDD_S1x3, TRUE);
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5G_BAND0:
				ppr_offsets[MCS32_PO] = (uint32)(pi->ppr.sr9.mcs32po >> 4) & 0xf;
				break;
			case WL_CHAN_FREQ_RANGE_5G_BAND1:
				ppr_offsets[MCS32_PO] = (uint32)(pi->ppr.sr9.mcs32po >> 8) & 0xf;
				break;
			case WL_CHAN_FREQ_RANGE_5G_BAND2:
				ppr_offsets[MCS32_PO] = (uint32)(pi->ppr.sr9.mcs32po >> 12) & 0xf;
				break;
			case WL_CHAN_FREQ_RANGE_5G_BAND3:
				ppr_offsets[MCS32_PO] = (uint32)(pi->ppr.sr9.mcs32po >> 12) & 0xf;
				break;
#endif /* BAND5G */
			default:
				break;
		}

		for (rate = TXP_FIRST_CCK; rate < TXP_NUM_RATES; rate += rate_cnt) {
			shift = TRUE;
			pwr_offsets = 0;
			switch (rate) {
				case TXP_FIRST_CCK:
				case TXP_FIRST_20UL_CCK:
				case TXP_FIRST_CCK_CDD_S1x2:
				case TXP_FIRST_CCK_CDD_S1x3:
				case TXP_FIRST_CCK_20U_CDD_S1x2:
				case TXP_FIRST_CCK_20U_CDD_S1x3:
					rate_cnt = WL_NUM_RATES_CCK;
					continue;
				case TXP_FIRST_OFDM:
				case TXP_FIRST_OFDM_20_CDD:
					pwr_offsets = ppr_offsets[OFDM_20_PO];
					rate_cnt = WL_NUM_RATES_OFDM;
					break;
				case TXP_FIRST_MCS_20_S1x1:
				case TXP_FIRST_MCS_20_S1x2:
				case TXP_FIRST_MCS_20_S1x3:
				case TXP_FIRST_MCS_20_S2x2:
				case TXP_FIRST_MCS_20_S2x3:
				case TXP_FIRST_MCS_20_S3x3:
					pwr_offsets = ppr_offsets[MCS_20_PO];
					rate_cnt = WL_NUM_RATES_MCS_1STREAM;
					break;
				case TXP_FIRST_OFDM_40_SISO:
				case TXP_FIRST_OFDM_40_CDD:
					pwr_offsets = ppr_offsets[OFDM_40DUP_PO];
					rate_cnt = WL_NUM_RATES_OFDM;
					break;
				case TXP_FIRST_MCS_40_S1x1:
				case TXP_FIRST_MCS_40_S1x2:
				case TXP_FIRST_MCS_40_S1x3:
				case TXP_FIRST_MCS_40_S2x2:
				case TXP_FIRST_MCS_40_S2x3:
				case TXP_FIRST_MCS_40_S3x3:
					pwr_offsets = ppr_offsets[MCS_40_PO];
					rate_cnt = WL_NUM_RATES_MCS_1STREAM;
					break;
				case TXP_MCS_32:
					pwr_offsets = ppr_offsets[MCS32_PO];
					rate_cnt = WL_NUM_RATES_MCS32;
					break;
				case TXP_FIRST_20UL_OFDM:
				case TXP_FIRST_20UL_OFDM_CDD:
					pwr_offsets = ppr_offsets[OFDM_20UL_PO];
					rate_cnt = WL_NUM_RATES_OFDM;
					break;
				case TXP_FIRST_20UL_S1x1:
				case TXP_FIRST_20UL_S1x2:
				case TXP_FIRST_20UL_S1x3:
				case TXP_FIRST_20UL_S2x2:
				case TXP_FIRST_20UL_S2x3:
				case TXP_FIRST_20UL_S3x3:
					pwr_offsets = ppr_offsets[MCS_20UL_PO];
					rate_cnt = WL_NUM_RATES_MCS_1STREAM;
					break;
				default:
					PHY_ERROR(("Invalid rate %d\n", rate));
					rate_cnt = 1;
					ASSERT(0);
					break;
			}
			wlc_phy_txpwr_srom9_convert(pi, tx_srom_max_rate, pwr_offsets,
				tmp_max_pwr, (uint8)rate, (uint8)rate+rate_cnt-1, shift);
		}
	}
}

#endif /* !PPR_API */

#ifdef PPR_API
/* add 1MSB to represent 5bit-width ppr value, for mcs8 and mcs9 only */
void
wlc_phy_txpwr_ppr_bit_ext_mcs8and9(ppr_vht_mcs_rateset_t* vht, uint8 msb)
{
	/* this added 1MSB is the 4th bit, so left shift 4 bits
	 * then left shift 1 more bit since boardlimit is 0.5dB format
	 */
	vht->pwr[8] -= ((msb & 0x1) << 4) << 1;
	vht->pwr[9] -= ((msb & 0x2) << 3) << 1;
}

/* for CCK case, 4 rates only */
void
wlc_phy_txpwr_srom_convert_cck(uint16 po, uint8 max_pwr, ppr_dsss_rateset_t *dsss)
{
	uint8 i;
	/* Extract offsets for 4 CCK rates, convert from .5 to .25 dbm units. */
	for (i = 0; i < WL_RATESET_SZ_DSSS; i++) {
		dsss->pwr[i] = max_pwr - ((po & 0xf) * 2);
		po >>= 4;
	}
}

/* for OFDM cases, 8 rates only */
void
wlc_phy_txpwr_srom_convert_ofdm(uint32 po, uint8 max_pwr, ppr_ofdm_rateset_t *ofdm)
{
	uint8 i;
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		ofdm->pwr[i] = max_pwr - ((po & 0xf) * 2);
		po >>= 4;
	}
}

/* for MCS20&40_2G case, 10 rates only */
static void
wlc_phy_txpwr_srom11_convert_mcs_2g(uint32 po, uint8 nibble,
         uint8 tmp_max_pwr, ppr_vht_mcs_rateset_t* vht) {
	uint8 i;
	int8 offset;
	offset = (nibble + 8)%16 - 8;

	for (i = 0; i < WL_RATESET_SZ_VHT_MCS; i++) {
		if ((i == 1)||(i == 2)) {
			vht->pwr[i] = vht->pwr[0];
		} else {
			vht->pwr[i] = tmp_max_pwr - ((po & 0xf)<<1);
			po = po >> 4;
		}
	}
	vht->pwr[1] -= (offset << 1);
	vht->pwr[2] = vht->pwr[1];
}

/* for 2G Legacy 40Dup mode, providing the base pwr */
static void
wlc_phy_txpwr_srom11_convert_ofdm_2g_dup40(uint32 po, uint8 nibble,
         uint8 tmp_max_pwr, ppr_ofdm_rateset_t* ofdm) {
	uint8 i;
	int8 offset;
	offset = (nibble + 8)%16 - 8;
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		if ((i == 1)||(i == 2)||(i == 3)) {
			ofdm->pwr[i] = ofdm->pwr[0];
		} else {
			ofdm->pwr[i] = tmp_max_pwr - ((po & 0xf) <<1);
			po = po >> 4;
		}
	}
	ofdm->pwr[2] -= (offset << 1);
	ofdm->pwr[3] = ofdm->pwr[2];
}

/* for ofdm20in40_2G case, 8 rates only */
static void
wlc_phy_txpwr_srom11_convert_ofdm_offset(ppr_ofdm_rateset_t* po,
                                         uint8 nibble2, ppr_ofdm_rateset_t* ofdm)
{
	uint8 i;
	int8 offsetL, offsetH;
	offsetL = ((nibble2 & 0xf) + 8)%16 - 8;
	offsetH = (((nibble2>>4) & 0xf) + 8)%16 - 8;
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		if (i < 6)
			ofdm->pwr[i] = po->pwr[i] + (offsetL << 1);
		else
			ofdm->pwr[i] = po->pwr[i] + (offsetH << 1);
	}
}

/* for mcs20in40_2G case, 10 rates only */
static void
wlc_phy_txpwr_srom11_convert_mcs_offset(ppr_vht_mcs_rateset_t* po,
                                        uint8 nibble2, ppr_vht_mcs_rateset_t* vht)
{
	uint8 i;
	int8 offsetL, offsetH;
	offsetL = ((nibble2 & 0xf) + 8)%16 - 8;
	offsetH = (((nibble2>>4) & 0xf) + 8)%16 - 8;
	for (i = 0; i < WL_RATESET_SZ_VHT_MCS; i++) {
		if (i < 5)
			vht->pwr[i] = po->pwr[i] + (offsetL << 1);
		else
			vht->pwr[i] = po->pwr[i] + (offsetH << 1);
	}
}

#ifdef BAND5G
/* for ofdm20_5G case, 8 rates only */
static void
wlc_phy_txpwr_srom11_convert_ofdm_5g(uint32 po, uint8 nibble,
         uint8 tmp_max_pwr, ppr_ofdm_rateset_t* ofdm) {
	uint8 i;
	int8 offset;
	offset = (nibble + 8)%16 - 8;
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		if ((i == 1)||(i == 2)||(i == 3)) {
			ofdm->pwr[i] = ofdm->pwr[0];
		} else {
			ofdm->pwr[i] = tmp_max_pwr - ((po & 0xf) <<1);
			po = po >> 4;
		}
	}
	ofdm->pwr[2] -= (offset << 1);
	ofdm->pwr[3] = ofdm->pwr[2];
}

/* for MCS20&40_5G case, 10 rates only */
static void
wlc_phy_txpwr_srom11_convert_mcs_5g(uint32 po, uint8 nibble,
         uint8 tmp_max_pwr, ppr_vht_mcs_rateset_t* vht) {
	uint8 i;
	int8 offset;
	offset = (nibble + 8)%16 - 8;
	for (i = 0; i < WL_RATESET_SZ_VHT_MCS; i++) {
		if ((i == 1)||(i == 2)) {
			vht->pwr[i] = vht->pwr[0];
		} else {
			vht->pwr[i] = tmp_max_pwr - ((po & 0xf)<<1);
			po = po >> 4;
		}
	}
	vht->pwr[1] -= (offset << 1);
	vht->pwr[2] = vht->pwr[1];
}
#endif /* BAND5G */

static void
wlc_phy_ppr_set_dsss(ppr_t* tx_srom_max_pwr, uint8 bwtype,
          ppr_dsss_rateset_t* pwr_offsets, phy_info_t *pi) {
	uint8 chain;
	for (chain = WL_TX_CHAINS_1; chain <= PHYCORENUM(pi->pubpi.phy_corenum); chain++)
		/* for 2g_dsss: S1x1, S1x2, S1x3 */
		ppr_set_dsss(tx_srom_max_pwr, bwtype, chain,
		      (const ppr_dsss_rateset_t*)pwr_offsets);
}

static void
wlc_phy_ppr_set_ofdm(ppr_t* tx_srom_max_pwr, uint8 bwtype,
          ppr_ofdm_rateset_t* pwr_offsets, phy_info_t *pi) {

	uint8 chain;
	ppr_set_ofdm(tx_srom_max_pwr, bwtype, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
	       (const ppr_ofdm_rateset_t*)pwr_offsets);
	BCM_REFERENCE(chain);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
		for (chain = WL_TX_CHAINS_2; chain <= PHYCORENUM(pi->pubpi.phy_corenum); chain++) {
			ppr_set_ofdm(tx_srom_max_pwr, bwtype, WL_TX_MODE_CDD, chain,
				(const ppr_ofdm_rateset_t*)pwr_offsets);
#ifdef WL_BEAMFORMING
			/* Add TXBF */
			ppr_set_ofdm(tx_srom_max_pwr, bwtype, WL_TX_MODE_TXBF, chain,
				(const ppr_ofdm_rateset_t*)pwr_offsets);
#endif // endif
		}
	}
}

static void
wlc_phy_ppr_set_ht_mcs(ppr_t* tx_srom_max_pwr, uint8 bwtype,
         ppr_ht_mcs_rateset_t* pwr_offsets, phy_info_t *pi) {
	ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_NONE,
		WL_TX_CHAINS_1, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
		/* for ht_S1x2_CDD */
		ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_CDD,
			WL_TX_CHAINS_2, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
		/* for ht_S2x2_STBC */
		ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_STBC,
			WL_TX_CHAINS_2, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
		/* for ht_S2x2_SDM */
		ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_NONE,
			WL_TX_CHAINS_2, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
			/* for ht_S1x3_CDD */
			ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_CDD,
				WL_TX_CHAINS_3, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
			/* for ht_S2x3_STBC */
			ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_STBC,
				WL_TX_CHAINS_3, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
			/* for ht_S2x3_SDM */
			ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_NONE,
				WL_TX_CHAINS_3, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
			/* for ht_S3x3_SDM */
			ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_3, WL_TX_MODE_NONE,
				WL_TX_CHAINS_3, (const ppr_ht_mcs_rateset_t*)pwr_offsets);
		}
	}
}

static void
wlc_phy_ppr_set_mcs(ppr_t* tx_srom_max_pwr, uint8 bwtype,
          ppr_vht_mcs_rateset_t* pwr_offsets, phy_info_t *pi) {
		int8 tmp_mcs8, tmp_mcs9;

	ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_NONE,
		WL_TX_CHAINS_1, (const ppr_vht_mcs_rateset_t*)pwr_offsets);

	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
		/* for vht_S1x2_CDD */
		ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_CDD,
			WL_TX_CHAINS_2, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
		/* for vht_S2x2_STBC */
		ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_STBC,
			WL_TX_CHAINS_2, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
		/* for vht_S2x2_SDM */
		ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_NONE,
			WL_TX_CHAINS_2, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
		/* for vht_S1x2_TXBF */
		ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_TXBF,
			WL_TX_CHAINS_2, (const ppr_vht_mcs_rateset_t*)pwr_offsets);

		tmp_mcs8 = pwr_offsets->pwr[8];
		tmp_mcs9 = pwr_offsets->pwr[9];
		pwr_offsets->pwr[8] = WL_RATE_DISABLED;
		pwr_offsets->pwr[9] = WL_RATE_DISABLED;
		/* for vht_S2x2_TXBF */
		/* VHT8SS2_TXBF0 and VHT9SS2_TXBF0 are invalid */
		ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_TXBF,
			WL_TX_CHAINS_2, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
		pwr_offsets->pwr[8] = tmp_mcs8;
		pwr_offsets->pwr[9] = tmp_mcs9;
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
			/* for vht_S1x3_CDD */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_CDD,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			/* for vht_S2x3_STBC */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_STBC,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			/* for vht_S2x3_SDM */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_NONE,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			/* for vht_S3x3_SDM */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_3, WL_TX_MODE_NONE,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			/* for vht_S1x3_TXBF */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_1, WL_TX_MODE_TXBF,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			/* for vht_S2x3_TXBF */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_2, WL_TX_MODE_TXBF,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			tmp_mcs8 = pwr_offsets->pwr[8];
			tmp_mcs9 = pwr_offsets->pwr[9];
			pwr_offsets->pwr[8] = WL_RATE_DISABLED;
			pwr_offsets->pwr[9] = WL_RATE_DISABLED;
			/* for vht_S3x3_TXBF */
			/* VHT8SS3_TXBF0 and VHT9SS3_TXBF0 are invalid */
			ppr_set_vht_mcs(tx_srom_max_pwr, bwtype, WL_TX_NSS_3, WL_TX_MODE_TXBF,
				WL_TX_CHAINS_3, (const ppr_vht_mcs_rateset_t*)pwr_offsets);
			pwr_offsets->pwr[8] = tmp_mcs8;
			pwr_offsets->pwr[9] = tmp_mcs9;
		}
	}
	BCM_REFERENCE(tmp_mcs8);
	BCM_REFERENCE(tmp_mcs9);
}

void
ppr_dsss_printf(ppr_t *p)
{
	int chain, bitN;
	ppr_dsss_rateset_t dsss_boardlimits;

	for (chain = WL_TX_CHAINS_1; chain <= WL_TX_CHAINS_3; chain++) {
		ppr_get_dsss(p, WL_TX_BW_20, chain, &dsss_boardlimits);
		PHY_ERROR(("--------DSSS-BW_20-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_DSSS; bitN++)
			PHY_ERROR(("max-pwr = %d\n", dsss_boardlimits.pwr[bitN]));

		ppr_get_dsss(p, WL_TX_BW_20IN40, chain, &dsss_boardlimits);
		PHY_ERROR(("--------DSSS-BW_20IN40-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_DSSS; bitN++)
			PHY_ERROR(("max-pwr = %d\n", dsss_boardlimits.pwr[bitN]));

	}
}

void
ppr_ofdm_printf(ppr_t *p)
{

	int chain, bitN;
	ppr_ofdm_rateset_t ofdm_boardlimits;
	wl_tx_mode_t mode = WL_TX_MODE_NONE;

	for (chain = WL_TX_CHAINS_1; chain <= WL_TX_CHAINS_3; chain++) {
		ppr_get_ofdm(p, WL_TX_BW_20, mode, chain, &ofdm_boardlimits);
		PHY_ERROR(("--------OFDM-BW_20-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_OFDM; bitN++)
			PHY_ERROR(("max-pwr = %d\n", ofdm_boardlimits.pwr[bitN]));

		ppr_get_ofdm(p, WL_TX_BW_20IN40, mode, chain, &ofdm_boardlimits);
		PHY_ERROR(("--------OFDM-BW_20IN40-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_OFDM; bitN++)
			PHY_ERROR(("max-pwr = %d\n", ofdm_boardlimits.pwr[bitN]));

		ppr_get_ofdm(p, WL_TX_BW_20IN80, mode, chain, &ofdm_boardlimits);
		PHY_ERROR(("--------OFDM-BW_20IN80-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_OFDM; bitN++)
			PHY_ERROR(("max-pwr = %d\n", ofdm_boardlimits.pwr[bitN]));

		ppr_get_ofdm(p, WL_TX_BW_40, mode, chain, &ofdm_boardlimits);
		PHY_ERROR(("--------OFDM-BW_DUP40-S1x%d-----\n", chain));
		for (bitN = 0; bitN < WL_RATESET_SZ_OFDM; bitN++)
			PHY_ERROR(("max-pwr = %d\n", ofdm_boardlimits.pwr[bitN]));
		mode = WL_TX_MODE_CDD;
	}
}

void
ppr_mcs_printf(ppr_t* tx_srom_max_pwr)
{

	int bitN, bwtype;
	ppr_vht_mcs_rateset_t mcs_boardlimits;
#if defined(BCMDBG)
	char* bw[6] = { "20IN20", "40IN40", "80IN80", "20IN40", "20IN80", "40IN80" };
#endif // endif
	for (bwtype = 0; bwtype < 6; bwtype++) {
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S1x1-----\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S1x2_CDD */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S1x2-CDD-----\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S1x3_CDD */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 1, WL_TX_MODE_CDD, WL_TX_CHAINS_3,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S1x3-CDD-----\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S2x2_STBC */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 2, WL_TX_MODE_STBC, WL_TX_CHAINS_2,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S2x2-STBC------\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S2x3_STBC */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 2, WL_TX_MODE_STBC, WL_TX_CHAINS_3,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S2x3-STBC------\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S2x2_SDM */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S2x2-SDM------\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S2x3_SDM */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 2, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S2x3-SDM------\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
		/* for ht_20IN20_S3x3_SDM */
		ppr_get_vht_mcs(tx_srom_max_pwr, bwtype, 3, WL_TX_MODE_NONE, WL_TX_CHAINS_3,
			&mcs_boardlimits);
		PHY_INFORM(("--------MCS-%s-S3x3-SDM------\n", bw[bwtype]));
		for (bitN = 0; bitN < WL_RATESET_SZ_VHT_MCS; bitN++)
			PHY_INFORM(("max-pwr = %d\n", mcs_boardlimits.pwr[bitN]));
	}
}

void
wlc_phy_txpower_sromlimit_get_abglpphy_ppr_new(phy_info_t *pi, uint chan, ppr_t *max_pwr,
	uint8 core)
{
	ppr_dsss_rateset_t ppr_dsss;
	ppr_ofdm_rateset_t ppr_ofdm;
	uint8 tmp_max_pwr = 0;
	uint16 offset;
	uint32 offset_ofdm;

	if (ISGPHY(pi) || chan <= CH_MAX_2G_CHANNEL) {
		tmp_max_pwr = pi->tx_srom_max_2g;
		offset = pi->ppr.srlgcy.cckpo;
		if (offset) {
			/* 2g cck */
			wlc_phy_txpwr_srom_convert_cck(offset, tmp_max_pwr, &ppr_dsss);
			ppr_set_dsss(max_pwr, WL_TX_BW_20, WL_TX_CHAINS_1, &ppr_dsss);
			/* 2g ofdm */
			offset_ofdm =  pi->ppr.srlgcy.ofdmgpo;
			wlc_phy_txpwr_srom_convert_ofdm(offset_ofdm, tmp_max_pwr, &ppr_ofdm);
			ppr_set_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
				&ppr_ofdm);
		} else {
			/* Populate max power array for CCK rates */
			ppr_set_same_dsss(max_pwr, WL_TX_BW_20,
				WL_TX_CHAINS_1, tmp_max_pwr);

			/* Populate max power array for OFDM rates */
			ppr_set_same_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
				WL_TX_CHAINS_1, tmp_max_pwr - pi->ppr.srlgcy.opo);
		}
	}
#ifdef BAND5G
	else {
		uint i;

		ppr_set_cmn_val(max_pwr, (int8)WLC_TXPWR_MAX);
		/* max txpwr is channel dependent */
		for (i = 0; i < ARRAYSIZE(chan_info_all); i++) {
			if (chan == chan_info_all[i].chan) {
				break;
			}
		}
		ASSERT(i < ARRAYSIZE(chan_info_all));

		if (pi->hwtxpwr) {
			ppr_set_cmn_val(max_pwr, (int8)pi->hwtxpwr[i]);
		} else {
			/* When would we get here?  B only? */
			if (pi->sh->sromrev <= 1) {
				tmp_max_pwr = pi->tx_srom_max_5g_mid;
				ppr_set_same_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, tmp_max_pwr);	/* mid */
				ppr_set_same_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, tmp_max_pwr);	/* low */
				ppr_set_same_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, tmp_max_pwr);	/* hi */
			} else {
				/* mid */
				if ((i >= FIRST_MID_5G_CHAN) && (i <= LAST_MID_5G_CHAN)) {
					tmp_max_pwr = pi->tx_srom_max_5g_mid;
					offset_ofdm = pi->ppr.srlgcy.ofdmapo;
					wlc_phy_txpwr_srom_convert_ofdm(offset_ofdm,
						tmp_max_pwr, &ppr_ofdm);
					ppr_set_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, &ppr_ofdm);
				}
				/* low */
				if ((i >= FIRST_LOW_5G_CHAN) && (i <= LAST_LOW_5G_CHAN)) {
					tmp_max_pwr = pi->tx_srom_max_5g_low;
					offset_ofdm = pi->ppr.srlgcy.ofdmalpo;
					wlc_phy_txpwr_srom_convert_ofdm(offset_ofdm,
						tmp_max_pwr, &ppr_ofdm);
					ppr_set_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, &ppr_ofdm);
				}
				/* hi */
				if ((i >= FIRST_HIGH_5G_CHAN) && (i <= LAST_HIGH_5G_CHAN)) {
					tmp_max_pwr = pi->tx_srom_max_5g_hi;
					offset_ofdm = pi->ppr.srlgcy.ofdmahpo;
					wlc_phy_txpwr_srom_convert_ofdm(offset_ofdm,
						tmp_max_pwr, &ppr_ofdm);
					ppr_set_ofdm(max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
						WL_TX_CHAINS_1, &ppr_ofdm);
				}
			}
		}
	}
#endif /* BAND5G */
}

static uint8
wlc_phy_make_byte(uint16 nibbleH, uint16 nibbleL)
{
	return (uint8) (((nibbleH & 0xf) << 4) | (nibbleL & 0xf));
}

void
wlc_phy_txpwr_apply_srom11(phy_info_t *pi, uint8 band, chanspec_t chanspec,
                           uint8 tmp_max_pwr, ppr_t *tx_srom_max_pwr)
{
	uint8 nibbles;
	uint8 ppr_bit_ext, msb;
	const struct srom11_ppr *sr11 = &pi->ppr.sr11;

	if (!ISACPHY(pi))
		return;

	ppr_bit_ext = pi->u.pi_acphy->srom.ppr_bit_ext;

	if (CHSPEC_IS2G(chanspec))
	{
		ppr_ofdm_rateset_t	ofdm20_offset_2g;
		ppr_vht_mcs_rateset_t	mcs20_offset_2g;

		/* 2G - OFDM_20 */
		wlc_phy_txpwr_srom_convert_ofdm(sr11->ofdm_2g.bw20, tmp_max_pwr, &ofdm20_offset_2g);

		/* 2G - MCS_20 */
		nibbles = (sr11->offset_2g >> 8) & 0xf;   /* 2LSB is needed */
		wlc_phy_txpwr_srom11_convert_mcs_2g(sr11->mcs_2g.bw20, nibbles,
		        tmp_max_pwr, &mcs20_offset_2g);

		if (ppr_bit_ext) {
			/* msb: bit 1 for mcs9, bit 0 for mcs8
			 * sb40and80hr5glpo, nib3 is 2G
			 * bit13 and bit12 are 2g-20MHz: mcs9,mcs8
			 */
			msb = (sr11->offset_40in80_h[0] >> 12) & 0x3;
			wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs20_offset_2g, msb);
		}

		if (CHSPEC_IS20(chanspec)) {
			ppr_dsss_rateset_t	cck20_offset;

			/* 2G - CCK */
			wlc_phy_txpwr_srom_convert_cck(sr11->cck.bw20, tmp_max_pwr, &cck20_offset);

			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20, &cck20_offset, pi);
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20, &ofdm20_offset_2g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_20, &mcs20_offset_2g, pi);
		} else if (CHSPEC_IS40(chanspec)) {
			ppr_dsss_rateset_t	cck20in40_offset;
			ppr_ofdm_rateset_t	ofdm20in40_offset_2g;
			ppr_ofdm_rateset_t	ofdmdup40_offset_2g;
			ppr_ofdm_rateset_t	ofdm40_offset_2g;
			ppr_vht_mcs_rateset_t	mcs40_offset_2g;
			ppr_vht_mcs_rateset_t	mcs20in40_offset_2g;

			/* 2G - CCK */
			wlc_phy_txpwr_srom_convert_cck(sr11->cck.bw20in40,
			        tmp_max_pwr, &cck20in40_offset);

			/* 2G - MCS_40 */
			nibbles = (sr11->offset_2g >> 12) & 0xf;   /* 3LSB is needed */
			wlc_phy_txpwr_srom11_convert_mcs_2g(sr11->mcs_2g.bw40, nibbles,
			        tmp_max_pwr, &mcs40_offset_2g);

			if (ppr_bit_ext) {
				/* msb: bit 1 for mcs9, bit 0 for mcs8
				 * sb40and80hr5glpo, nib3 is 2G
				 * bit15 and bit14 are 2g-40MHz: mcs9,mcs8
				 */
				msb = (sr11->offset_40in80_h[0] >> 14) & 0x3;
				wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs40_offset_2g, msb);
			}
			/* this is used for 2g_ofdm_dup40 mode,
			 * remapping mcs40_offset_2g to ofdm40_offset_2g as the basis for dup
			 */
			wlc_phy_txpwr_srom11_convert_ofdm_2g_dup40(sr11->mcs_2g.bw40,
			        nibbles, tmp_max_pwr, &ofdm40_offset_2g);

			/* 2G - OFDM_20IN40 */
			nibbles = wlc_phy_make_byte(sr11->offset_20in40_h, sr11->offset_20in40_l);
			wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm20_offset_2g, nibbles,
				&ofdm20in40_offset_2g);

			/* 2G - MCS_20IN40 */
			wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs20_offset_2g, nibbles,
			        &mcs20in40_offset_2g);

			/* 2G OFDM_DUP40 */
			nibbles = wlc_phy_make_byte(sr11->offset_dup_h, sr11->offset_dup_l);
			wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm40_offset_2g, nibbles,
			        &ofdmdup40_offset_2g);

			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40, &ofdmdup40_offset_2g,
				pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_40, &mcs40_offset_2g, pi);

			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &cck20in40_offset, pi);
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &ofdm20in40_offset_2g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_20IN40,
			                     &mcs20in40_offset_2g, pi);
		}
	}

#ifdef BAND5G
	else if (CHSPEC_IS5G(chanspec)) {
		uint8 band5g = band - 1;
		int bitN = (band == 1) ? 4 : ((band == 2) ? 8 : 12);
		ppr_ofdm_rateset_t	ofdm20_offset_5g;
		ppr_vht_mcs_rateset_t	mcs20_offset_5g;

		/* 5G 11agnac_20IN20 */
		nibbles = sr11->offset_5g[band5g] & 0xf;		/* 0LSB */
		wlc_phy_txpwr_srom11_convert_ofdm_5g(sr11->ofdm_5g.bw20[band5g],
		        nibbles, tmp_max_pwr, &ofdm20_offset_5g);
		wlc_phy_txpwr_srom11_convert_mcs_5g(sr11->ofdm_5g.bw20[band5g],
		        nibbles, tmp_max_pwr, &mcs20_offset_5g);

		if (ppr_bit_ext) {
			/* msb: bit 1 for mcs9, bit 0 for mcs8
			 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
			 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
			 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
			 * bit5 and bit4 are 5g-20MHz: mcs9,mcs8
			 */
			msb = (sr11->offset_40in80_h[band5g] >> 4) & 0x3;
			wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs20_offset_5g, msb);
		}

		if (CHSPEC_IS20(chanspec)) {
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20, &ofdm20_offset_5g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20, &mcs20_offset_5g, pi);
		} else {
			ppr_ofdm_rateset_t	ofdm40_offset_5g;
			ppr_vht_mcs_rateset_t	mcs40_offset_5g;

			/* 5G 11nac 40IN40 */
			nibbles = (sr11->offset_5g[band5g] >> 4) & 0xf; /* 1LSB */
			wlc_phy_txpwr_srom11_convert_mcs_5g(sr11->mcs_5g.bw40[band5g],
			        nibbles, tmp_max_pwr, &mcs40_offset_5g);

			if (ppr_bit_ext) {
				/* msb: bit 1 for mcs9, bit 0 for mcs8
				 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
				 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
				 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
				 * bit7andbit6 are 5g-40MHz: mcs9, mcs8
				 */
				msb = (sr11->offset_40in80_h[band5g] >> 6) & 0x3;
				wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs40_offset_5g, msb);
			}

			/* same for ofdm 5g dup40 in 40MHz and dup80 in 80MHz */
			wlc_phy_txpwr_srom11_convert_ofdm_5g(sr11->mcs_5g.bw40[band5g],
			        nibbles, tmp_max_pwr, &ofdm40_offset_5g);

			if (CHSPEC_IS40(chanspec)) {
				ppr_ofdm_rateset_t	ofdm20in40_offset_5g;
				ppr_ofdm_rateset_t	ofdmdup40_offset_5g;
				ppr_vht_mcs_rateset_t	mcs20in40_offset_5g;

				/* 5G 11agnac_20IN40 */
				nibbles = wlc_phy_make_byte(sr11->offset_20in40_h >> bitN,
				                            sr11->offset_20in40_l >> bitN);
				wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm20_offset_5g,
				        nibbles, &ofdm20in40_offset_5g);
				wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs20_offset_5g,
				        nibbles, &mcs20in40_offset_5g);

				/* 5G ofdm_DUP40 */
				nibbles = wlc_phy_make_byte(sr11->offset_dup_h >> bitN,
				                            sr11->offset_dup_l >> bitN);
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
				      &ofdm40_offset_5g, nibbles, &ofdmdup40_offset_5g);

				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40,
				                     &ofdmdup40_offset_5g, pi);
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_40,
				                     &mcs40_offset_5g, pi);

				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40,
				                     &ofdm20in40_offset_5g, pi);
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20IN40,
				                     &mcs20in40_offset_5g, pi);

#ifdef WL11AC
			} else if (CHSPEC_IS80(chanspec)) {
				ppr_ofdm_rateset_t	ofdm20in80_offset_5g;
				ppr_ofdm_rateset_t	ofdm80_offset_5g;
				ppr_ofdm_rateset_t	ofdmdup80_offset_5g;
				ppr_ofdm_rateset_t	ofdmquad80_offset_5g;
				ppr_vht_mcs_rateset_t	mcs80_offset_5g;
				ppr_vht_mcs_rateset_t	mcs20in80_offset_5g;
				ppr_vht_mcs_rateset_t	mcs40in80_offset_5g;

				/* 5G 11nac 80IN80 */
				nibbles = (sr11->offset_5g[band5g] >> 8) & 0xf; /* 2LSB */
				wlc_phy_txpwr_srom11_convert_mcs_5g(sr11->mcs_5g.bw80[band5g],
				        nibbles, tmp_max_pwr, &mcs80_offset_5g);
				wlc_phy_txpwr_srom11_convert_ofdm_5g(sr11->mcs_5g.bw80[band5g],
				        nibbles, tmp_max_pwr, &ofdm80_offset_5g);

				if (ppr_bit_ext) {
					/* msb: bit 1 for mcs9, bit 0 for mcs8
					 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
					 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
					 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
					 * bit9andbit8 are 5g-80MHz: mcs9,mcs8
					 */
					msb = (sr11->offset_40in80_h[band5g] >> 8) & 0x3;
					wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs80_offset_5g, msb);
				}

				/* 5G ofdm_QUAD80, 80in80 */
				nibbles = wlc_phy_make_byte(sr11->offset_dup_h >> bitN,
				                            sr11->offset_dup_l >> bitN);
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
				        &ofdm80_offset_5g, nibbles, &ofdmquad80_offset_5g);

				/* 5G ofdm_DUP40in80 */
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
			            &ofdm40_offset_5g, nibbles, &ofdmdup80_offset_5g);

				/* 5G 11agnac_20Ul/20LU/20UU/20LL */
				/* 8 for 20LU/20UL subband  */
				nibbles = wlc_phy_make_byte(sr11->offset_20in80_h[band5g],
				                            sr11->offset_20in80_l[band5g]);
				wlc_phy_txpwr_srom11_convert_ofdm_offset(
				        &ofdm20_offset_5g,
				        nibbles, &ofdm20in80_offset_5g);
				wlc_phy_txpwr_srom11_convert_mcs_offset(
				        &mcs20_offset_5g, nibbles, &mcs20in80_offset_5g);

				if ((CHSPEC_CTL_SB(chanspec) == WL_CHANSPEC_CTL_SB_UU) ||
					(CHSPEC_CTL_SB(chanspec) == WL_CHANSPEC_CTL_SB_LL)) {
					/* for 20UU/20LL subband = offset + 20UL/20LU */
					/* 8 for 20LL/20UU subband  */
					nibbles = wlc_phy_make_byte(
							sr11->offset_20in80_h[band5g] >> 2,
							sr11->offset_20in80_l[band5g] >> 2);
					wlc_phy_txpwr_srom11_convert_ofdm_offset(
					    &ofdm20in80_offset_5g, nibbles, &ofdm20in80_offset_5g);
					wlc_phy_txpwr_srom11_convert_mcs_offset(
					    &mcs20in80_offset_5g, nibbles, &mcs20in80_offset_5g);
				}

				/* 5G 11nac_40IN80 */
				nibbles = wlc_phy_make_byte(sr11->offset_40in80_h[band5g],
				                            sr11->offset_40in80_l[band5g]);
				wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs40_offset_5g,
					nibbles, &mcs40in80_offset_5g);

				/* for 80IN80MHz OFDM or OFDMQUAD80 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_80,
				                     &ofdmquad80_offset_5g, pi);
				/* for 80IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_80,
				                     &mcs80_offset_5g, pi);
				/* for ofdm_20IN80: S1x1, S1x2, S1x3 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN80,
				                     &ofdm20in80_offset_5g, pi);
				/* for 20IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20IN80,
				                     &mcs20in80_offset_5g, pi);
				/* for 40IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_40IN80,
				                     &mcs40in80_offset_5g, pi);

				/* for ofdm_40IN80: S1x1, S1x2, S1x3 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40IN80,
				                     &ofdmdup80_offset_5g, pi);
#endif /* WL11AC */

			}
		}
	}
#endif /* BAND5G */
}

#ifdef SROM12
void wlc_phy_txpwr_apply_srom12(phy_info_t *pi, uint8 band, chanspec_t chanspec,
                                    uint8 tmp_max_pwr, ppr_t *tx_srom_max_pwr)
{
	uint8 nibble, nibbleL, nibbleH; /* 4bits */
	uint8 ppr_bit_ext, msb;

	ppr_dsss_rateset_t	cck20_offset, cck20in40_offset;
	ppr_ofdm_rateset_t	ofdm20_offset_2g, ofdm20in40_offset_2g, ofdmdup40_offset_2g,
	                    ofdm40_offset_2g;
	ppr_vht_mcs_rateset_t	mcs20_offset_2g, mcs40_offset_2g, mcs20in40_offset_2g;
#ifdef BAND5G
#ifdef WL11AC
	ppr_ofdm_rateset_t	ofdm20in80_offset_5g, ofdm80_offset_5g,
		ofdmdup80_offset_5g, ofdmquad80_offset_5g;
	ppr_vht_mcs_rateset_t	mcs80_offset_5g,
		mcs20in80_offset_5g, mcs40in80_offset_5g;
#endif // endif
	uint8 band5g;
	int bitN;
	ppr_ofdm_rateset_t	ofdm20_offset_5g, ofdm20in40_offset_5g, ofdm40_offset_5g,
	                        ofdmdup40_offset_5g;
	ppr_vht_mcs_rateset_t	mcs20_offset_5g, mcs40_offset_5g, mcs20in40_offset_5g;
#endif /* BAND5G */

	if (!ISACPHY(pi))
		return;

	ppr_bit_ext = pi->u.pi_acphy->srom.ppr_bit_ext;
	if (CHSPEC_IS2G(chanspec))
	{
		/* 2G - OFDM_20 */
		wlc_phy_txpwr_srom_convert_ofdm(pi->ppr.sr12.ofdm_2g.bw20,
		        tmp_max_pwr, &ofdm20_offset_2g);

		/* 2G - MCS_20 */
		nibble = (pi->ppr.sr12.offset_2g >>8 ) & 0xf;   /* 2LSB is needed */
		wlc_phy_txpwr_srom11_convert_mcs_2g(pi->ppr.sr12.mcs_2g.bw20, nibble,
		        tmp_max_pwr, &mcs20_offset_2g);

		if (ppr_bit_ext) {
			/* msb: bit 1 for mcs9, bit 0 for mcs8
			 * sb40and80hr5glpo, nib3 is 2G
			 * bit13 and bit12 are 2g-20MHz: mcs9,mcs8
			 */
			msb = (pi->ppr.sr12.offset_40in80_h[0] >> 12) & 0x3;
			wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs20_offset_2g, msb);
		}

		if (CHSPEC_IS20(chanspec)) {

			/* 2G - CCK */
			wlc_phy_txpwr_srom_convert_cck(pi->ppr.sr12.cck.bw20,
			        tmp_max_pwr,  &cck20_offset);

			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20, &cck20_offset, pi);
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20, &ofdm20_offset_2g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_20, &mcs20_offset_2g, pi);
		}

		else if (CHSPEC_IS40(chanspec)) {

			/* 2G - CCK */
			wlc_phy_txpwr_srom_convert_cck(pi->ppr.sr12.cck.bw20in40,
			        tmp_max_pwr, &cck20in40_offset);

			/* 2G - MCS_40 */
			nibble = (pi->ppr.sr12.offset_2g >>12 ) & 0xf;   /* 3LSB is needed */
			wlc_phy_txpwr_srom11_convert_mcs_2g(pi->ppr.sr12.mcs_2g.bw40, nibble,
			        tmp_max_pwr, &mcs40_offset_2g);

			if (ppr_bit_ext) {
				/* msb: bit 1 for mcs9, bit 0 for mcs8
				 * sb40and80hr5glpo, nib3 is 2G
				 * bit15 and bit14 are 2g-40MHz: mcs9,mcs8
				 */
				msb = (pi->ppr.sr12.offset_40in80_h[0] >> 14) & 0x3;
				wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs40_offset_2g, msb);
			}
			/* this is used for 2g_ofdm_dup40 mode,
			 * remapping mcs40_offset_2g to ofdm40_offset_2g as the basis for dup
			 */
			wlc_phy_txpwr_srom11_convert_ofdm_2g_dup40(pi->ppr.sr12.mcs_2g.bw40,
			        nibble, tmp_max_pwr, &ofdm40_offset_2g);

			/* 2G - OFDM_20IN40 */
			nibbleL = pi->ppr.sr12.offset_20in40_l & 0xf;
			nibbleH = pi->ppr.sr12.offset_20in40_h & 0xf;
			nibble = (nibbleH<<4)|nibbleL;
			wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm20_offset_2g, nibble,
			        &ofdm20in40_offset_2g);

			/* 2G - MCS_20IN40 */
			wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs20_offset_2g, nibble,
			        &mcs20in40_offset_2g);

			/* 2G OFDM_DUP40 */
			nibbleL = pi->ppr.sr12.offset_dup_l & 0xf;
			nibbleH = pi->ppr.sr12.offset_dup_h & 0xf;
			nibble = (nibbleH<<4)|nibbleL;
			wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm40_offset_2g, nibble,
			        &ofdmdup40_offset_2g);

			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40, &ofdmdup40_offset_2g,
				pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_40, &mcs40_offset_2g, pi);

			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &cck20in40_offset, pi);
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &ofdm20in40_offset_2g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr,  WL_TX_BW_20IN40,
			                     &mcs20in40_offset_2g, pi);

		}
	}

#ifdef BAND5G
	else if (CHSPEC_IS5G(chanspec)) {

		band5g = band - 1;

		/* 5G 11agnac_20IN20 */
		nibble = pi->ppr.sr12.offset_5g[band5g] & 0xf;		/* 0LSB */
		wlc_phy_txpwr_srom11_convert_ofdm_5g(pi->ppr.sr12.ofdm_5g.bw20[band5g],
		        nibble, tmp_max_pwr, &ofdm20_offset_5g);
		wlc_phy_txpwr_srom11_convert_mcs_5g(pi->ppr.sr12.ofdm_5g.bw20[band5g],
		        nibble, tmp_max_pwr, &mcs20_offset_5g);

		if (ppr_bit_ext) {
			/* msb: bit 1 for mcs9, bit 0 for mcs8
			 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
			 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
			 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
			 * bit5 and bit4 are 5g-20MHz: mcs9,mcs8
			 */
			msb = (pi->ppr.sr12.offset_40in80_h[band5g] >> 4) & 0x3;
			wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs20_offset_5g, msb);
		}

		if (CHSPEC_IS20(chanspec))
		{
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20,
			                     &ofdm20_offset_5g, pi);
			wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20,
			                     &mcs20_offset_5g, pi);

		} else {

			/* 5G 11nac 40IN40 */
			nibble = (pi->ppr.sr12.offset_5g[band5g] >> 4) & 0xf; /* 1LSB */
			wlc_phy_txpwr_srom11_convert_mcs_5g(pi->ppr.sr12.mcs_5g.bw40[band5g],
			        nibble, tmp_max_pwr, &mcs40_offset_5g);

			if (ppr_bit_ext) {
				/* msb: bit 1 for mcs9, bit 0 for mcs8
				 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
				 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
				 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
				 * bit7andbit6 are 5g-40MHz: mcs9, mcs8
				 */
				msb = (pi->ppr.sr12.offset_40in80_h[band5g] >> 6) & 0x3;
				wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs40_offset_5g, msb);
			}

			/* same for ofdm 5g dup40 in 40MHz and dup80 in 80MHz */
			wlc_phy_txpwr_srom11_convert_ofdm_5g(pi->ppr.sr12.mcs_5g.bw40[band5g],
			        nibble, tmp_max_pwr, &ofdm40_offset_5g);

			if (CHSPEC_IS40(chanspec)) {

				/* 5G 11agnac_20IN40 */
				bitN = (band == 1)? 4 : ((band == 2) ? 8 : 12);
				nibbleL = (pi->ppr.sr12.offset_20in40_l >> bitN) & 0xf;
				nibbleH = (pi->ppr.sr12.offset_20in40_h >> bitN) & 0xf;
				nibble = (nibbleH<<4)|nibbleL;
				wlc_phy_txpwr_srom11_convert_ofdm_offset(&ofdm20_offset_5g,
				        nibble, &ofdm20in40_offset_5g);
				wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs20_offset_5g,
				        nibble, &mcs20in40_offset_5g);

				/* 5G ofdm_DUP40 */
				bitN = (band == 1)? 4 : ((band == 2) ? 8 : 12);
				nibbleL = (pi->ppr.sr12.offset_dup_l>>bitN) & 0xf;
				nibbleH = (pi->ppr.sr12.offset_dup_h>>bitN) & 0xf;
				nibble = (nibbleH<<4)|nibbleL;
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
				      &ofdm40_offset_5g,
				      nibble, &ofdmdup40_offset_5g);

				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40,
				                     &ofdmdup40_offset_5g, pi);
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_40,
				                     &mcs40_offset_5g, pi);

				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40,
				                     &ofdm20in40_offset_5g, pi);
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20IN40,
				                     &mcs20in40_offset_5g, pi);

#ifdef WL11AC
			} else if (CHSPEC_IS80(chanspec)) {

				/* 5G 11nac 80IN80 */
				nibble = (pi->ppr.sr12.offset_5g[band5g] >> 8) & 0xf; /* 2LSB */
				wlc_phy_txpwr_srom11_convert_mcs_5g(
				        pi->ppr.sr12.mcs_5g.bw80[band5g],
				        nibble, tmp_max_pwr, &mcs80_offset_5g);
				wlc_phy_txpwr_srom11_convert_ofdm_5g(
				        pi->ppr.sr12.mcs_5g.bw80[band5g],
				        nibble, tmp_max_pwr, &ofdm80_offset_5g);

				if (ppr_bit_ext) {
					/* msb: bit 1 for mcs9, bit 0 for mcs8
					 * sb40and80hr5glpo, nib2 and nib1 is 5G-low
					 * sb40and80hr5gmpo, nib2 and nib1 is 5G-mid
					 * sb40and80hr5ghpo, nib2 and nib1 is 5G-high
					 * bit9andbit8 are 5g-80MHz: mcs9,mcs8
					 */
					msb = (pi->ppr.sr12.offset_40in80_h[band5g]>>8) & 0x3;
					wlc_phy_txpwr_ppr_bit_ext_mcs8and9(&mcs80_offset_5g,
					                                   msb);
				}

				/* 5G ofdm_QUAD80, 80in80 */
				bitN = (band == 1)? 4 : ((band == 2) ? 8 : 12);
				nibbleL = (pi->ppr.sr12.offset_dup_l>>bitN) & 0xf;
				nibbleH = (pi->ppr.sr12.offset_dup_h>>bitN) & 0xf;
				nibble = (nibbleH<<4)|nibbleL;
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
				        &ofdm80_offset_5g,
				        nibble, &ofdmquad80_offset_5g);
				/* 5G ofdm_DUP40in80 */
				wlc_phy_txpwr_srom11_convert_ofdm_offset((ppr_ofdm_rateset_t*)
			            &ofdm40_offset_5g,
			            nibble, &ofdmdup80_offset_5g);
				/* 5G 11agnac_20Ul/20LU/20UU/20LL */
				/* 8 for 20LU/20UL subband  */
				nibbleL = (pi->ppr.sr12.offset_20in80_l[band5g] >> 0) & 0xf;
				/* 8 for 20LU/20UL subband  */
				nibbleH = (pi->ppr.sr12.offset_20in80_h[band5g] >> 0) & 0xf;
				nibble = (nibbleH<<4)|nibbleL;
				wlc_phy_txpwr_srom11_convert_ofdm_offset(
				        &ofdm20_offset_5g,
				        nibble, &ofdm20in80_offset_5g);
				wlc_phy_txpwr_srom11_convert_mcs_offset(
				        &mcs20_offset_5g,
				        nibble, &mcs20in80_offset_5g);

				if ((CHSPEC_CTL_SB(chanspec) == WL_CHANSPEC_CTL_SB_UU) ||
					(CHSPEC_CTL_SB(chanspec) == WL_CHANSPEC_CTL_SB_LL)) {
					/* for 20UU/20LL subband = offset + 20UL/20LU */
					nibbleL = (pi->ppr.sr12.offset_20in80_l[band5g] >> 2) & 0xf;
					/* 8 for 20LL/20UU subband  */
					nibbleH = (pi->ppr.sr12.offset_20in80_h[band5g] >> 2) & 0xf;
					nibble = (nibbleH<<4)|nibbleL;
					wlc_phy_txpwr_srom11_convert_ofdm_offset(
					    &ofdm20in80_offset_5g,
					    nibble, &ofdm20in80_offset_5g);
					wlc_phy_txpwr_srom11_convert_mcs_offset(
					    &mcs20in80_offset_5g,
					    nibble, &mcs20in80_offset_5g);
				}

				/* 5G 11nac_40IN80 */
				bitN = (band == 1)? 0 : ((band == 2) ? 4 : 8);
				nibbleL = (pi->ppr.sr12.offset_40in80_l[band5g] >> 0) & 0xf;
				nibbleH = (pi->ppr.sr12.offset_40in80_h[band5g] >> 0) & 0xf;
				nibble = (nibbleH<<4)|nibbleL;
				wlc_phy_txpwr_srom11_convert_mcs_offset(&mcs40_offset_5g,
				    nibble, &mcs40in80_offset_5g);

				/* for 80IN80MHz OFDM or OFDMQUAD80 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_80,
				                     &ofdmquad80_offset_5g, pi);
				/* for 80IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_80,
				                     &mcs80_offset_5g, pi);
				/* for ofdm_20IN80: S1x1, S1x2, S1x3 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN80,
				                     &ofdm20in80_offset_5g, pi);
				/* for 20IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_20IN80,
				                     &mcs20in80_offset_5g, pi);
				/* for 40IN80MHz HT */
				wlc_phy_ppr_set_mcs(tx_srom_max_pwr, WL_TX_BW_40IN80,
				                     &mcs40in80_offset_5g, pi);

				/* for ofdm_40IN80: S1x1, S1x2, S1x3 */
				wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40IN80,
				                     &ofdmdup80_offset_5g, pi);
#endif /* WL11AC */

			}
		}
	}
#endif /* BAND5G */
}
#endif /* SROM12 */

uint8
wlc_phy_get_band_from_channel(phy_info_t *pi, uint channel)
{
	/* NOTE: At present this function has only been validated for
	 * SSNLPPHY, LCN and LCN40 phys. It may apply to others, but
	 * that is left as an exercise to the reader.
	 */
	uint8 band = 0;

#ifdef BAND5G
	if ((channel >= FIRST_LOW_5G_CHAN_SSLPNPHY) &&
		(channel <= LAST_LOW_5G_CHAN_SSLPNPHY)) {
		band = WL_CHAN_FREQ_RANGE_5GL;
	} else if ((channel >= FIRST_MID_5G_CHAN_SSLPNPHY) &&
		(channel <= LAST_MID_5G_CHAN_SSLPNPHY)) {
		band = WL_CHAN_FREQ_RANGE_5GM;
	} else if ((channel >= FIRST_HIGH_5G_CHAN_SSLPNPHY) &&
		(channel <= LAST_HIGH_5G_CHAN_SSLPNPHY)) {
		band = WL_CHAN_FREQ_RANGE_5GH;
	} else
#endif /* BAND5G */
	if (channel <= CH_MAX_2G_CHANNEL) {
		band = WL_CHAN_FREQ_RANGE_2G;
	} else {
		PHY_ERROR(("%s: invalid channel %d\n", __FUNCTION__, channel));
		ASSERT(0);
	}

	return band;
}
#endif /* PPR_API */

static const char BCMATTACHDATA(rstr_cckbw202gpo)[] = "cckbw202gpo";
static const char BCMATTACHDATA(rstr_cckbw20ul2gpo)[] = "cckbw20ul2gpo";
static const char BCMATTACHDATA(rstr_legofdmbw202gpo)[] = "legofdmbw202gpo";
static const char BCMATTACHDATA(rstr_legofdmbw20ul2gpo)[] = "legofdmbw20ul2gpo";
static const char BCMATTACHDATA(rstr_legofdmbw205glpo)[] = "legofdmbw205glpo";
static const char BCMATTACHDATA(rstr_legofdmbw20ul5glpo)[] = "legofdmbw20ul5glpo";
static const char BCMATTACHDATA(rstr_legofdmbw205gmpo)[] = "legofdmbw205gmpo";
static const char BCMATTACHDATA(rstr_legofdmbw20ul5gmpo)[] = "legofdmbw20ul5gmpo";
static const char BCMATTACHDATA(rstr_legofdmbw205ghpo)[] = "legofdmbw205ghpo";
static const char BCMATTACHDATA(rstr_legofdmbw20ul5ghpo)[] = "legofdmbw20ul5ghpo";
static const char BCMATTACHDATA(rstr_mcsbw202gpo)[] = "mcsbw202gpo";
static const char BCMATTACHDATA(rstr_mcsbw20ul2gpo)[] = "mcsbw20ul2gpo";
static const char BCMATTACHDATA(rstr_mcsbw402gpo)[] = "mcsbw402gpo";
static const char BCMATTACHDATA(rstr_mcsbw205glpo)[] = "mcsbw205glpo";
static const char BCMATTACHDATA(rstr_mcsbw20ul5glpo)[] = "mcsbw20ul5glpo";
static const char BCMATTACHDATA(rstr_mcsbw405glpo)[] = "mcsbw405glpo";
static const char BCMATTACHDATA(rstr_mcsbw205gmpo)[] = "mcsbw205gmpo";
static const char BCMATTACHDATA(rstr_mcsbw20ul5gmpo)[] = "mcsbw20ul5gmpo";
static const char BCMATTACHDATA(rstr_mcsbw405gmpo)[] = "mcsbw405gmpo";
static const char BCMATTACHDATA(rstr_mcsbw205ghpo)[] = "mcsbw205ghpo";
static const char BCMATTACHDATA(rstr_mcsbw20ul5ghpo)[] = "mcsbw20ul5ghpo";
static const char BCMATTACHDATA(rstr_mcsbw405ghpo)[] = "mcsbw405ghpo";
static const char BCMATTACHDATA(rstr_legofdm40duppo)[] = "legofdm40duppo";
static const char BCMATTACHDATA(rstr_ofdmlrbw202gpo)[] = "ofdmlrbw202gpo";
static const char BCMATTACHDATA(rstr_dot11agofdmhrbw202gpo)[] = "dot11agofdmhrbw202gpo";
static const char BCMATTACHDATA(rstr_sb20in40lrpo)[] = "sb20in40lrpo";
static const char BCMATTACHDATA(rstr_sb20in40hrpo)[] = "sb20in40hrpo";
static const char BCMATTACHDATA(rstr_dot11agduphrpo)[] = "dot11agduphrpo";
static const char BCMATTACHDATA(rstr_dot11agduplrpo)[] = "dot11agduplrpo";
static const char BCMATTACHDATA(rstr_mcslr5glpo)[] = "mcslr5glpo";
static const char BCMATTACHDATA(rstr_mcslr5gmpo)[] = "mcslr5gmpo";
static const char BCMATTACHDATA(rstr_mcslr5ghpo)[] = "mcslr5ghpo";
static const char BCMATTACHDATA(rstr_mcsbw805glpo)[] = "mcsbw805glpo";
static const char BCMATTACHDATA(rstr_mcsbw805gmpo)[] = "mcsbw805gmpo";
static const char BCMATTACHDATA(rstr_mcsbw805ghpo)[] = "mcsbw805ghpo";
static const char BCMATTACHDATA(rstr_sb20in80and160lr5glpo)[] = "sb20in80and160lr5glpo";
static const char BCMATTACHDATA(rstr_sb20in80and160hr5glpo)[] = "sb20in80and160hr5glpo";
static const char BCMATTACHDATA(rstr_sb20in80and160lr5gmpo)[] = "sb20in80and160lr5gmpo";
static const char BCMATTACHDATA(rstr_sb20in80and160hr5gmpo)[] = "sb20in80and160hr5gmpo";
static const char BCMATTACHDATA(rstr_sb20in80and160lr5ghpo)[] = "sb20in80and160lr5ghpo";
static const char BCMATTACHDATA(rstr_sb20in80and160hr5ghpo)[] = "sb20in80and160hr5ghpo";
static const char BCMATTACHDATA(rstr_sb40and80lr5glpo)[] = "sb40and80lr5glpo";
static const char BCMATTACHDATA(rstr_sb40and80hr5glpo)[] = "sb40and80hr5glpo";
static const char BCMATTACHDATA(rstr_sb40and80lr5gmpo)[] = "sb40and80lr5gmpo";
static const char BCMATTACHDATA(rstr_sb40and80hr5gmpo)[] = "sb40and80hr5gmpo";
static const char BCMATTACHDATA(rstr_sb40and80lr5ghpo)[] = "sb40and80lr5ghpo";
static const char BCMATTACHDATA(rstr_sb40and80hr5ghpo)[] = "sb40and80hr5ghpo";

#ifdef SROM12
static const char BCMATTACHDATA(rstr_mcsbw205gx1po)[] = "mcsbw205gx1po";
static const char BCMATTACHDATA(rstr_mcsbw20ul5gx1po)[] = "mcsbw20ul5gx1po";
static const char BCMATTACHDATA(rstr_mcsbw405gx1po)[] = "mcsbw405gx1po";
static const char BCMATTACHDATA(rstr_mcsbw205gx2po)[] = "mcsbw205gx2po";
static const char BCMATTACHDATA(rstr_mcsbw20ul5gx2po)[] = "mcsbw20ul5gx2po";
static const char BCMATTACHDATA(rstr_mcsbw405gx2po)[] = "mcsbw405gx2po";
static const char BCMATTACHDATA(rstr_mcslr5gx1po)[] = "mcslr5gx1po";
static const char BCMATTACHDATA(rstr_mcslr5gx2po)[] = "mcslr5gx2po";
static const char BCMATTACHDATA(rstr_mcsbw805gx1po)[] = "mcsbw805gx1po";
static const char BCMATTACHDATA(rstr_mcsbw805gx2po)[] = "mcsbw805gx2po";
static const char BCMATTACHDATA(rstr_sb20in80and160lr5gx1po)[] = "sb20in80and160lr5gx1po";
static const char BCMATTACHDATA(rstr_sb20in80and160hr5gx1po)[] = "sb20in80and160hr5gx1po";
static const char BCMATTACHDATA(rstr_sb20in80and160lr5gx2po)[] = "sb20in80and160lr5gx2po";
static const char BCMATTACHDATA(rstr_sb20in80and160hr5gx2po)[] = "sb20in80and160hr5gx2po";
static const char BCMATTACHDATA(rstr_sb40and80lr5gx1po)[] = "sb40and80lr5gx1po";
static const char BCMATTACHDATA(rstr_sb40and80hr5gx1po)[] = "sb40and80hr5gx1po";
static const char BCMATTACHDATA(rstr_sb40and80lr5gx2po)[] = "sb40and80lr5gx2po";
static const char BCMATTACHDATA(rstr_sb40and80hr5gx2po)[] = "sb40and80hr5gx2po";
#endif /* SROM12 */

void
wlc_phy_txpwr_srom_convert_mcs(uint32 po, uint8 max_pwr, ppr_ht_mcs_rateset_t *mcs)
{
	wlc_phy_txpwr_srom_convert_mcs_offset(po, 0, max_pwr, mcs, 0);
}

void
wlc_phy_txpwr_srom_convert_mcs_offset(uint32 po,
	uint8 offset, uint8 max_pwr, ppr_ht_mcs_rateset_t* mcs, int8 mcs7_15_offset)
{
	uint8 i;
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		mcs->pwr[i] = max_pwr - ((po & 0xF) * 2) - (offset * 2);
		po >>= 4;
	}

	mcs->pwr[WL_RATESET_SZ_HT_MCS - 1] -= mcs7_15_offset;
}

static void
wlc_phy_txpwr_srom8_sub_ofdm(ppr_ofdm_rateset_t* ofdm, uint8 ppr_offset)
{
	uint8 i;
	for (i = 0; i < WL_RATESET_SZ_OFDM; i++) {
		ofdm->pwr[i] = ofdm->pwr[i] - (ppr_offset << 1);
	}
}

static void
wlc_phy_txpwr_srom8_sub_mcs(ppr_ht_mcs_rateset_t* mcs, uint8 ppr_offset)
{
	uint8 i;
	for (i = 0; i < WL_RATESET_SZ_HT_MCS; i++) {
		mcs->pwr[i] = mcs->pwr[i] - (ppr_offset << 1);
	}
}

static void
wlc_phy_ppr_set_dsss_srom8(ppr_t* tx_srom_max_pwr, uint8 bwtype,
          ppr_dsss_rateset_t* pwr_offsets)
{
	uint8 chain;
	for (chain = WL_TX_CHAINS_1; chain <= WL_TX_CHAINS_2; chain++)
		/* for 2g_dsss_20IN20: S1x1, S1x2 */
		ppr_set_dsss(tx_srom_max_pwr, bwtype, chain,
			(const ppr_dsss_rateset_t*)pwr_offsets);
}

static void
wlc_phy_ppr_set_ofdm_srom8(ppr_t* tx_srom_max_pwr, uint8 bwtype, wl_tx_mode_t mode,
          wl_tx_chains_t tx_chain, ppr_ofdm_rateset_t* pwr_offsets)
{
	ppr_set_ofdm(tx_srom_max_pwr, bwtype, mode, tx_chain,
		(const ppr_ofdm_rateset_t*)pwr_offsets);

}

static void
wlc_phy_ppr_set_mcs_srom8(ppr_t* tx_srom_max_pwr, uint8 bwtype, wl_tx_nss_t Nss,
	wl_tx_mode_t mode, wl_tx_chains_t tx_chains, ppr_ht_mcs_rateset_t* pwr_offsets)
{
	ppr_set_ht_mcs(tx_srom_max_pwr, bwtype, Nss, mode,
		tx_chains, (const ppr_ht_mcs_rateset_t*)pwr_offsets);

}

void
wlc_phy_txpwr_apply_srom8(phy_info_t *pi, uint8 band,
	uint8 tmp_max_pwr, ppr_t *tx_srom_max_pwr)
{

	chanspec_t chanspec = pi->radio_chanspec;
	uint8 tmp_bw40po = 0, tmp_cddpo = 0, tmp_stbcpo = 0;
	uint32 tmp_mcs_word = 0;

	ppr_dsss_rateset_t cck20_offset;
	ppr_ofdm_rateset_t ofdm20_offset_siso, ofdm20_offset_cdd,
		ofdm40_offset_siso, ofdm40_offset_cdd;

	ppr_ht_mcs_rateset_t mcs20_offset_siso, mcs20_offset_cdd, mcs20_offset_stbc,
		mcs20_offset_sdm, mcs40_offset_siso, mcs40_offset_cdd, mcs40_offset_stbc,
		mcs40_offset_sdm;

	ASSERT(ISNPHY(pi));

	if (band == 0) {	/* 2G case */

		/* ----------------2G--------------------- */
		/* 2G - CCK */
		wlc_phy_txpwr_srom_convert_cck(pi->ppr.sr8.cck2gpo,
		        tmp_max_pwr,  &cck20_offset);

		if (CHSPEC_IS20(chanspec)) {

			/* for 2g_dsss_20IN20: S1x1, S1x2 */
			wlc_phy_ppr_set_dsss_srom8(tx_srom_max_pwr, WL_TX_BW_20, &cck20_offset);
		}
		if (CHSPEC_IS40(chanspec)) {

			/* for 2g_dsss_20IN40: S1x1, S1x2 */
			wlc_phy_ppr_set_dsss_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40, &cck20_offset);
		}

	}

	if (CHSPEC_IS20(chanspec)) {

		/* 2G - OFDM_20 */
		wlc_phy_txpwr_srom_convert_ofdm(pi->ppr.sr8.ofdm[band], tmp_max_pwr,
			&ofdm20_offset_siso);

		/* for ofdm_20IN20: S1x1   */
		wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE,
			WL_TX_CHAINS_1, &ofdm20_offset_siso);

		/* for 20MHz Mapping Legacy OFDM SISo to MCS0-7 SISO */
		wlc_phy_copy_ofdm_to_mcs_powers(&ofdm20_offset_siso, &mcs20_offset_siso);

		/* for mcs_20IN20 SISO: S1x1  */
		wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_NSS_1,
			WL_TX_MODE_NONE, 1, &mcs20_offset_siso);

		/* 2G - MCS_CDD  */
		if (ISNPHY(pi)) {
			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
				/* Apply power-offset specified by the cddpo SROM field to
				 * rates sent in the CDD STF mode
				 */
				tmp_cddpo = pi->ppr.sr8.cdd[band];
			}
			else {
				tmp_cddpo = 0;
			}
		}

		tmp_mcs_word = (pi->ppr.sr8.mcs[band][1] << 16)|(pi->ppr.sr8.mcs[band][0]);
		wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word, tmp_cddpo, tmp_max_pwr,
			&mcs20_offset_cdd, 0);

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
			/* for mcs_20IN20 CDD: S1x1, S1x2  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_NSS_1,
				WL_TX_MODE_CDD, WL_TX_CHAINS_2, &mcs20_offset_cdd);
		}

		/* for 20MHz Mapping MCS0-7 CDD to Legacy OFDM CDD  */
		wlc_phy_copy_mcs_to_ofdm_powers(&mcs20_offset_cdd, &ofdm20_offset_cdd);

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
			/* for ofdm_20IN20 CDD:  S1x2  */
			wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_MODE_CDD,
				WL_TX_CHAINS_2, &ofdm20_offset_cdd);
		}

		/* STBC 20 MHz */
		if (ISNPHY(pi)) {
			if (NREV_GE(pi->pubpi.phy_rev, 3)) {
				/* Apply power-offset specified by the cddpo SROM field to
				 * rates sent in the CDD STF mode
				 */
				tmp_stbcpo = pi->ppr.sr8.stbc[band];
			}
			else {
				tmp_stbcpo = 0;
			}
		}

		tmp_mcs_word = (pi->ppr.sr8.mcs[band][1] << 16)|(pi->ppr.sr8.mcs[band][0]);
		wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word, tmp_stbcpo, tmp_max_pwr,
			&mcs20_offset_stbc, 0);

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
			/* for mcs_20IN20 STBC: S2x2  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_NSS_2,
				WL_TX_MODE_STBC, WL_TX_CHAINS_2, &mcs20_offset_stbc);
		}

		/* SDM 20 MHz */
		tmp_mcs_word = (pi->ppr.sr8.mcs[band][3] << 16)|(pi->ppr.sr8.mcs[band][2]);
		wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word, 0, tmp_max_pwr,
			&mcs20_offset_sdm, 0);

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
			/* for mcs_20IN20 SDM: S2x2  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_NSS_2,
				WL_TX_MODE_NONE, WL_TX_CHAINS_2, &mcs20_offset_sdm);
		}
	}

	/* 40 MHz PPRs */
	/* For nphy_rev>=5, re-interpret the mcs[2g,5g,5gl,5gh]po4-7 SROM fields to be the
	 * power-offsets for 40 MHz mcs0-15 w.r.t the max power. For nphy_rev<5, 40 MHz
	 * mcs0-15, use the same power offsets as for 20 MHz mcs0-15.
	 * The bw402gpo field is further used to implement an additional uniform power
	 * back-off for all 40 MHz OFDM rates.
	 */
	if (CHSPEC_IS40(chanspec)) {
		if (NPHY_IS_SROM_REINTERPRET) {
			int8 mcs7_15_offset = 0;

			/* Hack for LCNXNPHY  rev 0 */
			/* 2 channels are looking 2 dB off with respect to evm and SM performance */
			/* Dropping the srom powers only for those 2 channels */
			if (ISNPHY(pi) && NREV_IS(pi->pubpi.phy_rev, LCNXN_BASEREV)) {
				uint channel = CHSPEC_CHANNEL(pi->radio_chanspec);
				if (channel == 151)  {
					mcs7_15_offset = 4;
				}
			}

			/* MCS 40 SISO */
			tmp_bw40po = pi->ppr.sr8.bw40[band];

			tmp_mcs_word = (pi->ppr.sr8.mcs[band][5] << 16)|(pi->ppr.sr8.mcs[band][4]);
			wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word, tmp_bw40po, tmp_max_pwr,
				&mcs40_offset_siso, mcs7_15_offset);

			/* for mcs_40 SISO: S1x1  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_1,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &mcs40_offset_siso);

			/* for mcs_20in40 SISO: S1x1  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40, WL_TX_NSS_1,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &mcs40_offset_siso);

			/* for 40MHz Mapping MCS0-7 SISO to Legacy OFDM SISO	*/
			wlc_phy_copy_mcs_to_ofdm_powers(&mcs40_offset_siso, &ofdm40_offset_siso);

			/* for ofdm_40 SISO: S1x1, */
			wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_MODE_NONE,
				WL_TX_CHAINS_1, &ofdm40_offset_siso);

			/* for ofdm_20IN40 SISO: S1x1, */
			wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm40_offset_siso);

			/* MCS 40 CDD */
			tmp_cddpo = pi->ppr.sr8.cdd[band];

			tmp_mcs_word = (pi->ppr.sr8.mcs[band][5] << 16)|(pi->ppr.sr8.mcs[band][4]);
			wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word,
				(tmp_bw40po + tmp_cddpo), tmp_max_pwr, &mcs40_offset_cdd,
				mcs7_15_offset);

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				/* for mcs_40 CDD: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_1,
					WL_TX_MODE_CDD, WL_TX_CHAINS_2, &mcs40_offset_cdd);

				/* for mcs_20in40 CDD: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
					&mcs40_offset_cdd);
			}
			/* for 40MHz Mapping MCS0-7 CDD to Legacy OFDM CDD	*/
			wlc_phy_copy_mcs_to_ofdm_powers(&mcs40_offset_cdd, &ofdm40_offset_cdd);

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				/* for ofdm_40 CDD: S1x2, */
				wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_40,
					WL_TX_MODE_CDD,	WL_TX_CHAINS_2, &ofdm40_offset_cdd);

				/* for ofdm_20IN40 CDD: S1x2, */
				wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_MODE_CDD, WL_TX_CHAINS_2, &ofdm40_offset_cdd);

				/* MCS 40 STBC */
				tmp_stbcpo = pi->ppr.sr8.stbc[band];

				tmp_mcs_word = (pi->ppr.sr8.mcs[band][5] << 16)|
					(pi->ppr.sr8.mcs[band][4]);
				wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word,
					(tmp_bw40po + tmp_stbcpo), tmp_max_pwr, &mcs40_offset_stbc,
					mcs7_15_offset);

				/* for mcs_40 STBC: S2x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_2,
					WL_TX_MODE_STBC, WL_TX_CHAINS_2, &mcs40_offset_stbc);

				/* for mcs_20in40 STBC: S2x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_2, WL_TX_MODE_STBC, WL_TX_CHAINS_2,
					&mcs40_offset_stbc);

				/* MCS 40 SDM */
				tmp_mcs_word = (pi->ppr.sr8.mcs[band][7] << 16)|
					(pi->ppr.sr8.mcs[band][6]);
				wlc_phy_txpwr_srom_convert_mcs_offset(tmp_mcs_word, tmp_bw40po,
					tmp_max_pwr, &mcs40_offset_sdm, mcs7_15_offset);

				/* for mcs_40 SDM: S2x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_2,
					WL_TX_MODE_NONE, WL_TX_CHAINS_2, &mcs40_offset_sdm);

				/* for mcs_20in40 SDM: S2x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
					&mcs40_offset_sdm);
			}

		}
		else {
			/* For nphy_rev<5, set the powers of the 40MHz rates sames as the
			 * 20 MHz rates + bw40po
			 */

			tmp_bw40po = pi->ppr.sr8.bw40[band];
			wlc_phy_txpwr_srom8_sub_ofdm(&ofdm20_offset_siso, tmp_bw40po);
			wlc_phy_txpwr_srom8_sub_ofdm(&ofdm20_offset_cdd, tmp_bw40po);

			wlc_phy_txpwr_srom8_sub_mcs(&mcs20_offset_siso, tmp_bw40po);
			wlc_phy_txpwr_srom8_sub_mcs(&mcs20_offset_cdd, tmp_bw40po);
			wlc_phy_txpwr_srom8_sub_mcs(&mcs20_offset_stbc, tmp_bw40po);
			wlc_phy_txpwr_srom8_sub_mcs(&mcs20_offset_sdm, tmp_bw40po);

			/* for mcs_40 SISO: S1x1  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_1,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &mcs20_offset_siso);

			/* for mcs_20in40 SISO: S1x1  */
			wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40, WL_TX_NSS_1,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &mcs20_offset_siso);

			/* for ofdm_40 SISO: S1x1, */
			wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_MODE_NONE,
				WL_TX_CHAINS_1, &ofdm20_offset_siso);

			/* for ofdm_20IN40 SISO: S1x1, */
			wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
				WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ofdm20_offset_siso);

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				/* for mcs_40 CDD: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_1,
					WL_TX_MODE_CDD, WL_TX_CHAINS_2, &mcs20_offset_cdd);

				/* for mcs_20in40 CDD: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_1, WL_TX_MODE_CDD, WL_TX_CHAINS_2,
					&mcs20_offset_cdd);

				/* for ofdm_40 CDD: S1x2, */
				wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_40,
					WL_TX_MODE_CDD,	WL_TX_CHAINS_2, &ofdm20_offset_cdd);

				/* for ofdm_20in40 CDD: S1x2, */
				wlc_phy_ppr_set_ofdm_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_MODE_CDD,	WL_TX_CHAINS_2, &ofdm20_offset_cdd);

				/* for mcs_40 STBC: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_2,
					WL_TX_MODE_STBC, WL_TX_CHAINS_2, &mcs20_offset_stbc);

				/* for mcs_20in40 STBC: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_2, WL_TX_MODE_STBC, WL_TX_CHAINS_2,
					&mcs20_offset_stbc);

				/* for mcs_40 SDM: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_2,
					WL_TX_MODE_NONE, WL_TX_CHAINS_2, &mcs20_offset_sdm);

				/* for mcs_20in40 SDM: S1x2  */
				wlc_phy_ppr_set_mcs_srom8(tx_srom_max_pwr, WL_TX_BW_20IN40,
					WL_TX_NSS_2, WL_TX_MODE_NONE, WL_TX_CHAINS_2,
					&mcs20_offset_sdm);
			}

		}
	}

}

#ifdef BAND5G
static int8
wlc_phy_txpwr40Moffset_srom_convert(uint8 offset)
{
	/* XXX
	 * This function checks to see if the 40MHz offset
	 * programmed into srom is
	 * in the correcr range and if the values are programmed
	 * right, it converts a 3 bit 2 complement
	 * number to decimal that is used to offset the estpower
	 * in the estpower look up table
	 */
	if (offset == 0xf)
		return 0;
	else if (offset > 0x7) {
		PHY_ERROR(("ILLEGAL 40MHZ PWRCTRL OFFSET VALUE, APPLYING 0 OFFSET \n"));
		return 0;
	} else {
		if (offset < 4)
			return offset;
		else
			return (-8+offset);
	}
}
#endif /* BAND5G */

static const char BCMATTACHDATA(rstr_bw40po)[] = "bw40po";
static const char BCMATTACHDATA(rstr_cddpo)[] = "cddpo";
static const char BCMATTACHDATA(rstr_stbcpo)[] = "stbcpo";
static const char BCMATTACHDATA(rstr_bwduppo)[] = "bwduppo";
static const char BCMATTACHDATA(rstr_txpid2ga0)[] = "txpid2ga0";
static const char BCMATTACHDATA(rstr_txpid2ga1)[] = "txpid2ga1";
static const char BCMATTACHDATA(rstr_maxp2ga0)[] = "maxp2ga0";
static const char BCMATTACHDATA(rstr_maxp2ga1)[] = "maxp2ga1";
static const char BCMATTACHDATA(rstr_maxp2ga2)[] = "maxp2ga2";
static const char BCMATTACHDATA(rstr_pa2gw0a2)[] = "pa2gw0a2";
static const char BCMATTACHDATA(rstr_pa2gw1a2)[] = "pa2gw1a2";
static const char BCMATTACHDATA(rstr_pa2gw2a2)[] = "pa2gw2a2";
static const char BCMATTACHDATA(rstr_maxp5gla2)[] = "maxp5gla2";
static const char BCMATTACHDATA(rstr_pa5glw0a2)[] = "pa5glw0a2";
static const char BCMATTACHDATA(rstr_pa5glw1a2)[] = "pa5glw1a2";
static const char BCMATTACHDATA(rstr_pa5glw2a2)[] = "pa5glw2a2";
static const char BCMATTACHDATA(rstr_maxp5ga2)[] = "maxp5ga2";
static const char BCMATTACHDATA(rstr_pa5gw0a2)[] = "pa5gw0a2";
static const char BCMATTACHDATA(rstr_pa5gw1a2)[] = "pa5gw1a2";
static const char BCMATTACHDATA(rstr_pa5gw2a2)[] = "pa5gw2a2";
static const char BCMATTACHDATA(rstr_maxp5gha2)[] = "maxp5gha2";
static const char BCMATTACHDATA(rstr_pa5ghw0a2)[] = "pa5ghw0a2";
static const char BCMATTACHDATA(rstr_pa5ghw1a2)[] = "pa5ghw1a2";
static const char BCMATTACHDATA(rstr_pa5ghw2a2)[] = "pa5ghw2a2";
static const char BCMATTACHDATA(rstr_pa2gw0a0)[] = "pa2gw0a0";
static const char BCMATTACHDATA(rstr_pa2gw0a1)[] = "pa2gw0a1";
static const char BCMATTACHDATA(rstr_pa2gw1a0)[] = "pa2gw1a0";
static const char BCMATTACHDATA(rstr_pa2gw1a1)[] = "pa2gw1a1";
static const char BCMATTACHDATA(rstr_pa2gw2a0)[] = "pa2gw2a0";
static const char BCMATTACHDATA(rstr_pa2gw2a1)[] = "pa2gw2a1";
static const char BCMATTACHDATA(rstr_itt2ga0)[] = "itt2ga0";
static const char BCMATTACHDATA(rstr_itt2ga1)[] = "itt2ga1";
static const char BCMATTACHDATA(rstr_cck2gpo)[] = "cck2gpo";
static const char BCMATTACHDATA(rstr_ofdm2gpo)[] = "ofdm2gpo";
static const char BCMATTACHDATA(rstr_mcs2gpo0)[] = "mcs2gpo0";
static const char BCMATTACHDATA(rstr_mcs2gpo1)[] = "mcs2gpo1";
static const char BCMATTACHDATA(rstr_mcs2gpo2)[] = "mcs2gpo2";
static const char BCMATTACHDATA(rstr_mcs2gpo3)[] = "mcs2gpo3";
static const char BCMATTACHDATA(rstr_mcs2gpo4)[] = "mcs2gpo4";
static const char BCMATTACHDATA(rstr_mcs2gpo5)[] = "mcs2gpo5";
static const char BCMATTACHDATA(rstr_mcs2gpo6)[] = "mcs2gpo6";
static const char BCMATTACHDATA(rstr_mcs2gpo7)[] = "mcs2gpo7";
static const char BCMATTACHDATA(rstr_txpid5gla0)[] = "txpid5gla0";
static const char BCMATTACHDATA(rstr_txpid5gla1)[] = "txpid5gla1";
static const char BCMATTACHDATA(rstr_maxp5gla0)[] = "maxp5gla0";
static const char BCMATTACHDATA(rstr_maxp5gla1)[] = "maxp5gla1";
static const char BCMATTACHDATA(rstr_pa5glw0a0)[] = "pa5glw0a0";
static const char BCMATTACHDATA(rstr_pa5glw0a1)[] = "pa5glw0a1";
static const char BCMATTACHDATA(rstr_pa5glw1a0)[] = "pa5glw1a0";
static const char BCMATTACHDATA(rstr_pa5glw1a1)[] = "pa5glw1a1";
static const char BCMATTACHDATA(rstr_pa5glw2a0)[] = "pa5glw2a0";
static const char BCMATTACHDATA(rstr_pa5glw2a1)[] = "pa5glw2a1";
static const char BCMATTACHDATA(rstr_ofdm5glpo)[] = "ofdm5glpo";
static const char BCMATTACHDATA(rstr_mcs5glpo0)[] = "mcs5glpo0";
static const char BCMATTACHDATA(rstr_mcs5glpo1)[] = "mcs5glpo1";
static const char BCMATTACHDATA(rstr_mcs5glpo2)[] = "mcs5glpo2";
static const char BCMATTACHDATA(rstr_mcs5glpo3)[] = "mcs5glpo3";
static const char BCMATTACHDATA(rstr_mcs5glpo4)[] = "mcs5glpo4";
static const char BCMATTACHDATA(rstr_mcs5glpo5)[] = "mcs5glpo5";
static const char BCMATTACHDATA(rstr_mcs5glpo6)[] = "mcs5glpo6";
static const char BCMATTACHDATA(rstr_mcs5glpo7)[] = "mcs5glpo7";
static const char BCMATTACHDATA(rstr_txpid5ga0)[] = "txpid5ga0";
static const char BCMATTACHDATA(rstr_txpid5ga1)[] = "txpid5ga1";
static const char BCMATTACHDATA(rstr_maxp5ga0)[] = "maxp5ga0";
static const char BCMATTACHDATA(rstr_maxp5ga1)[] = "maxp5ga1";
static const char BCMATTACHDATA(rstr_pa5gw0a0)[] = "pa5gw0a0";
static const char BCMATTACHDATA(rstr_pa5gw0a1)[] = "pa5gw0a1";
static const char BCMATTACHDATA(rstr_pa5gw1a0)[] = "pa5gw1a0";
static const char BCMATTACHDATA(rstr_pa5gw1a1)[] = "pa5gw1a1";
static const char BCMATTACHDATA(rstr_pa5gw2a0)[] = "pa5gw2a0";
static const char BCMATTACHDATA(rstr_pa5gw2a1)[] = "pa5gw2a1";
static const char BCMATTACHDATA(rstr_itt5ga0)[] = "itt5ga0";
static const char BCMATTACHDATA(rstr_itt5ga1)[] = "itt5ga1";
static const char BCMATTACHDATA(rstr_ofdm5gpo)[] = "ofdm5gpo";
static const char BCMATTACHDATA(rstr_mcs5gpo0)[] = "mcs5gpo0";
static const char BCMATTACHDATA(rstr_mcs5gpo1)[] = "mcs5gpo1";
static const char BCMATTACHDATA(rstr_mcs5gpo2)[] = "mcs5gpo2";
static const char BCMATTACHDATA(rstr_mcs5gpo3)[] = "mcs5gpo3";
static const char BCMATTACHDATA(rstr_mcs5gpo4)[] = "mcs5gpo4";
static const char BCMATTACHDATA(rstr_mcs5gpo5)[] = "mcs5gpo5";
static const char BCMATTACHDATA(rstr_mcs5gpo6)[] = "mcs5gpo6";
static const char BCMATTACHDATA(rstr_mcs5gpo7)[] = "mcs5gpo7";
static const char BCMATTACHDATA(rstr_txpid5gha0)[] = "txpid5gha0";
static const char BCMATTACHDATA(rstr_txpid5gha1)[] = "txpid5gha1";
static const char BCMATTACHDATA(rstr_maxp5gha0)[] = "maxp5gha0";
static const char BCMATTACHDATA(rstr_maxp5gha1)[] = "maxp5gha1";
static const char BCMATTACHDATA(rstr_pa5ghw0a0)[] = "pa5ghw0a0";
static const char BCMATTACHDATA(rstr_pa5ghw0a1)[] = "pa5ghw0a1";
static const char BCMATTACHDATA(rstr_pa5ghw1a0)[] = "pa5ghw1a0";
static const char BCMATTACHDATA(rstr_pa5ghw1a1)[] = "pa5ghw1a1";
static const char BCMATTACHDATA(rstr_pa5ghw2a0)[] = "pa5ghw2a0";
static const char BCMATTACHDATA(rstr_pa5ghw2a1)[] = "pa5ghw2a1";
static const char BCMATTACHDATA(rstr_ofdm5ghpo)[] = "ofdm5ghpo";
static const char BCMATTACHDATA(rstr_mcs5ghpo0)[] = "mcs5ghpo0";
static const char BCMATTACHDATA(rstr_mcs5ghpo1)[] = "mcs5ghpo1";
static const char BCMATTACHDATA(rstr_mcs5ghpo2)[] = "mcs5ghpo2";
static const char BCMATTACHDATA(rstr_mcs5ghpo3)[] = "mcs5ghpo3";
static const char BCMATTACHDATA(rstr_mcs5ghpo4)[] = "mcs5ghpo4";
static const char BCMATTACHDATA(rstr_mcs5ghpo5)[] = "mcs5ghpo5";
static const char BCMATTACHDATA(rstr_mcs5ghpo6)[] = "mcs5ghpo6";
static const char BCMATTACHDATA(rstr_mcs5ghpo7)[] = "mcs5ghpo7";

static void
BCMATTACHFN(wlc_phy_txpwr_srom8_read_ppr)(phy_info_t *pi)
{
		uint16 bw40po, cddpo, stbcpo, bwduppo;
		int band_num;
		phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
		srom_pwrdet_t	*pwrdet  = &pi->pwrdet;

		/* Read bw40po value
		 * each nibble corresponds to 2g, 5g, 5gl, 5gh specific offset respectively
		 */
		bw40po = (uint16)PHY_GETINTVAR(pi, rstr_bw40po);
		pi->ppr.sr8.bw40[WL_CHAN_FREQ_RANGE_2G] = bw40po & 0xf;
#ifdef BAND5G
		pi->ppr.sr8.bw40[WL_CHAN_FREQ_RANGE_5G_BAND0] = (bw40po & 0xf0) >> 4;
		pi->ppr.sr8.bw40[WL_CHAN_FREQ_RANGE_5G_BAND1] = (bw40po & 0xf00) >> 8;
		pi->ppr.sr8.bw40[WL_CHAN_FREQ_RANGE_5G_BAND2] = (bw40po & 0xf000) >> 12;
		if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			pi->ppr.sr8.bw40[WL_CHAN_FREQ_RANGE_5G_BAND3] =
				(bw40po & 0xf000) >> 12;
#endif /* BAND5G */
		/* Read cddpo value
		 * each nibble corresponds to 2g, 5g, 5gl, 5gh specific offset respectively
		 */
		cddpo = (uint16)PHY_GETINTVAR(pi, rstr_cddpo);
		pi->ppr.sr8.cdd[WL_CHAN_FREQ_RANGE_2G] = cddpo & 0xf;
#ifdef BAND5G
		pi->ppr.sr8.cdd[WL_CHAN_FREQ_RANGE_5G_BAND0]  = (cddpo & 0xf0) >> 4;
		pi->ppr.sr8.cdd[WL_CHAN_FREQ_RANGE_5G_BAND1]  = (cddpo & 0xf00) >> 8;
		pi->ppr.sr8.cdd[WL_CHAN_FREQ_RANGE_5G_BAND2]  = (cddpo & 0xf000) >> 12;
		if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			pi->ppr.sr8.cdd[WL_CHAN_FREQ_RANGE_5G_BAND3]  = (cddpo & 0xf000) >> 12;
#endif /* BAND5G */

		/* Read stbcpo value
		 * each nibble corresponds to 2g, 5g, 5gl, 5gh specific offset respectively
		 */
		stbcpo = (uint16)PHY_GETINTVAR(pi, rstr_stbcpo);
		pi->ppr.sr8.stbc[WL_CHAN_FREQ_RANGE_2G] = stbcpo & 0xf;
#ifdef BAND5G
		pi->ppr.sr8.stbc[WL_CHAN_FREQ_RANGE_5G_BAND0]  = (stbcpo & 0xf0) >> 4;
		pi->ppr.sr8.stbc[WL_CHAN_FREQ_RANGE_5G_BAND1]  = (stbcpo & 0xf00) >> 8;
		pi->ppr.sr8.stbc[WL_CHAN_FREQ_RANGE_5G_BAND2]  = (stbcpo & 0xf000) >> 12;
		if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			pi->ppr.sr8.stbc[WL_CHAN_FREQ_RANGE_5G_BAND3]  = (stbcpo & 0xf000) >> 12;
#endif /* BAND5G */

		/* Read bwduppo value
		 * each nibble corresponds to 2g, 5g, 5gl, 5gh specific offset respectively
		 */
		bwduppo = (uint16)PHY_GETINTVAR(pi, rstr_bwduppo);
		pi->ppr.sr8.bwdup[WL_CHAN_FREQ_RANGE_2G] = bwduppo & 0xf;
#ifdef BAND5G
		pi->ppr.sr8.bwdup[WL_CHAN_FREQ_RANGE_5G_BAND0]  = (bwduppo & 0xf0) >> 4;
		pi->ppr.sr8.bwdup[WL_CHAN_FREQ_RANGE_5G_BAND1]  = (bwduppo & 0xf00) >> 8;
		pi->ppr.sr8.bwdup[WL_CHAN_FREQ_RANGE_5G_BAND2]  = (bwduppo & 0xf000) >> 12;
		if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			pi->ppr.sr8.bwdup[WL_CHAN_FREQ_RANGE_5G_BAND3]  = (bwduppo & 0xf000) >> 12;
#endif /* BAND5G */

		for (band_num = 0; band_num < NUMSUBBANDS(pi); band_num++) {
			switch (band_num) {
				case WL_CHAN_FREQ_RANGE_2G:
					/* 2G band */
					if (ISNPHY(pi)) {
						pi_nphy->nphy_txpid2g[PHY_CORE_0]  =
						(uint8)PHY_GETINTVAR(pi, rstr_txpid2ga0);
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_0].
						idle_targ_2g =
						(int8)PHY_GETINTVAR(pi, rstr_itt2ga0);
					}
					pwrdet->max_pwr[PHY_CORE_0][band_num] =
						(int8)PHY_GETINTVAR(pi, rstr_maxp2ga0);
					pwrdet->pwrdet_a1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa2gw0a0);
					pwrdet->pwrdet_b0[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa2gw1a0);
					pwrdet->pwrdet_b1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa2gw2a0);

					if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
						if (ISNPHY(pi)) {
							pi_nphy->nphy_txpid2g[PHY_CORE_1]  =
							(uint8)PHY_GETINTVAR(pi, rstr_txpid2ga1);
							pi_nphy->nphy_pwrctrl_info[PHY_CORE_1].
							idle_targ_2g =
							(int8)PHY_GETINTVAR(pi, rstr_itt2ga1);
						}
						pwrdet->max_pwr[PHY_CORE_1][band_num] =
							(int8)PHY_GETINTVAR(pi, rstr_maxp2ga1);
						pwrdet->pwrdet_a1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw0a1);
						pwrdet->pwrdet_b0[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw1a1);
						pwrdet->pwrdet_b1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw2a1);
					}
					if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
						pwrdet->max_pwr[PHY_CORE_2][band_num] =
							(int8)PHY_GETINTVAR(pi, rstr_maxp2ga2);
						pwrdet->pwrdet_a1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw0a2);
						pwrdet->pwrdet_b0[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw1a2);
						pwrdet->pwrdet_b1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa2gw2a2);
					}

					/* 2G CCK */
					pi->ppr.sr8.cck2gpo =
						(uint16)PHY_GETINTVAR(pi, rstr_cck2gpo);

					/* 2G ofdm2gpo power offsets */
					pi->ppr.sr8.ofdm[band_num] =
						(uint32)PHY_GETINTVAR(pi, rstr_ofdm2gpo);

					/* 2G mcs2gpo power offsets */
					pi->ppr.sr8.mcs[band_num][0] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo0);
					pi->ppr.sr8.mcs[band_num][1] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo1);
					pi->ppr.sr8.mcs[band_num][2] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo2);
					pi->ppr.sr8.mcs[band_num][3] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo3);
					pi->ppr.sr8.mcs[band_num][4] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo4);
					pi->ppr.sr8.mcs[band_num][5] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo5);
					pi->ppr.sr8.mcs[band_num][6] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo6);
					pi->ppr.sr8.mcs[band_num][7] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs2gpo7);
					break;
#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5G_BAND0:
					/* 5G lowband */
					if (ISNPHY(pi)) {
						pi_nphy->nphy_txpid5g[PHY_CORE_0][band_num] =
						(uint8)PHY_GETINTVAR(pi, rstr_txpid5gla0);
					}
					pwrdet->max_pwr[PHY_CORE_0][band_num]  =
						(int8)PHY_GETINTVAR(pi, rstr_maxp5gla0);
					pwrdet->pwrdet_a1[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a0);
					pwrdet->pwrdet_b0[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a0);
					pwrdet->pwrdet_b1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a0);

					if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
						if (ISNPHY(pi)) {
							pi_nphy->nphy_txpid5g[PHY_CORE_1][band_num]
							= (uint8)PHY_GETINTVAR(pi, rstr_txpid5gla1);
						}
						pwrdet->pwrdet_a1[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a1);
						pwrdet->max_pwr[PHY_CORE_1][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gla1);
						pwrdet->pwrdet_b0[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a1);
						pwrdet->pwrdet_b1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a1);
					}
					if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
						pwrdet->pwrdet_a1[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a2);
						pwrdet->max_pwr[PHY_CORE_2][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gla2);
						pwrdet->pwrdet_b0[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a2);
						pwrdet->pwrdet_b1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a2);
					}

					if (ISNPHY(pi)) {
						pi_nphy->nphy_pwrctrl_info[0].
						idle_targ_5g[band_num] = 0;
						pi_nphy->nphy_pwrctrl_info[1].
						idle_targ_5g[band_num] = 0;
					}

					/* 5G lowband ofdm5glpo power offsets */
					pi->ppr.sr8.ofdm[band_num] =
						(uint32)PHY_GETINTVAR(pi, rstr_ofdm5glpo);

					/* 5G lowband mcs5glpo power offsets */
					pi->ppr.sr8.mcs[band_num][0] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo0);
					pi->ppr.sr8.mcs[band_num] [1] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo1);
					pi->ppr.sr8.mcs[band_num] [2] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo2);
					pi->ppr.sr8.mcs[band_num] [3] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo3);
					pi->ppr.sr8.mcs[band_num] [4] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo4);
					pi->ppr.sr8.mcs[band_num] [5] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo5);
					pi->ppr.sr8.mcs[band_num] [6] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo6);
					pi->ppr.sr8.mcs[band_num] [7] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5glpo7);
					break;
				case WL_CHAN_FREQ_RANGE_5G_BAND1:
					/* 5G band, mid */
					if (ISNPHY(pi)) {
						pi_nphy->nphy_txpid5g[PHY_CORE_0][band_num]  =
						(uint8)PHY_GETINTVAR(pi, rstr_txpid5ga0);
					}
					pwrdet->max_pwr[PHY_CORE_0][band_num] =
						(int8)PHY_GETINTVAR(pi, rstr_maxp5ga0);
					pwrdet->pwrdet_a1[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5gw0a0);
					pwrdet->pwrdet_b0[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5gw1a0);
					pwrdet->pwrdet_b1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa5gw2a0);

					if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
						if (ISNPHY(pi)) {
							pi_nphy->nphy_txpid5g[PHY_CORE_1][band_num]
							= (uint8)PHY_GETINTVAR(pi, rstr_txpid5ga1);
						}
						pwrdet->pwrdet_a1[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw0a1);
						pwrdet->max_pwr[PHY_CORE_1][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5ga1);
						pwrdet->pwrdet_b0[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw1a1);
						pwrdet->pwrdet_b1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw2a1);
					}
					if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
						pwrdet->pwrdet_a1[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw0a2);
						pwrdet->max_pwr[PHY_CORE_2][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5ga2);
						pwrdet->pwrdet_b0[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw1a2);
						pwrdet->pwrdet_b1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5gw2a2);
					}

					if (ISNPHY(pi)) {
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_0].
						idle_targ_5g[band_num] =
						(int8)PHY_GETINTVAR(pi, rstr_itt5ga0);
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_1].
						idle_targ_5g[band_num] =
						(int8)PHY_GETINTVAR(pi, rstr_itt5ga1);
					}

					/* 5G midband ofdm5gpo power offsets */
					pi->ppr.sr8.ofdm[band_num] =
						(uint32)PHY_GETINTVAR(pi, rstr_ofdm5gpo);

					/* 5G midband mcs5gpo power offsets */
					pi->ppr.sr8.mcs[band_num] [0] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo0);
					pi->ppr.sr8.mcs[band_num] [1] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo1);
					pi->ppr.sr8.mcs[band_num] [2] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo2);
					pi->ppr.sr8.mcs[band_num] [3] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo3);
					pi->ppr.sr8.mcs[band_num] [4] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo4);
					pi->ppr.sr8.mcs[band_num] [5] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo5);
					pi->ppr.sr8.mcs[band_num] [6] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo6);
					pi->ppr.sr8.mcs[band_num] [7] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5gpo7);
					break;
				case WL_CHAN_FREQ_RANGE_5G_BAND2:
					/* 5G highband */
					if (ISNPHY(pi)) {
						pi_nphy->nphy_txpid5g[PHY_CORE_0][band_num] =
						(uint8)PHY_GETINTVAR(pi, rstr_txpid5gha0);
					}
					pwrdet->max_pwr[PHY_CORE_0][band_num]  =
						(int8)PHY_GETINTVAR(pi, rstr_maxp5gha0);
					pwrdet->pwrdet_a1[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a0);
					pwrdet->pwrdet_b0[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a0);
					pwrdet->pwrdet_b1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a0);

					if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
						if (ISNPHY(pi)) {
							pi_nphy->nphy_txpid5g[PHY_CORE_1][band_num]
							= (uint8)PHY_GETINTVAR(pi, rstr_txpid5gha1);
						}
						pwrdet->max_pwr[PHY_CORE_1][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gha1);
						pwrdet->pwrdet_a1[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a1);
						pwrdet->pwrdet_b0[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a1);
						pwrdet->pwrdet_b1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a1);
					}
					if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
						pwrdet->max_pwr[PHY_CORE_2][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gha2);
						pwrdet->pwrdet_a1[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a2);
						pwrdet->pwrdet_b0[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a2);
						pwrdet->pwrdet_b1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a2);
					}

					if (ISNPHY(pi)) {
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_0].
						idle_targ_5g[band_num] = 0;
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_1].
						idle_targ_5g[band_num] = 0;
					}

					/* 5G highband ofdm5ghpo power offsets */
					pi->ppr.sr8.ofdm[band_num] =
						(uint32)PHY_GETINTVAR(pi, rstr_ofdm5ghpo);

					/* 5G highband mcs5ghpo power offsets */
					pi->ppr.sr8.mcs[band_num][0] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo0);
					pi->ppr.sr8.mcs[band_num][1] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo1);
					pi->ppr.sr8.mcs[band_num][2] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo2);
					pi->ppr.sr8.mcs[band_num][3] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo3);
					pi->ppr.sr8.mcs[band_num][4] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo4);
					pi->ppr.sr8.mcs[band_num][5] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo5);
					pi->ppr.sr8.mcs[band_num][6] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo6);
					pi->ppr.sr8.mcs[band_num][7] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo7);
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND3:
					/* 5G highband */
					if (ISNPHY(pi)) {
						pi_nphy->nphy_txpid5g[PHY_CORE_0][band_num] =
						(uint8)PHY_GETINTVAR(pi, rstr_txpid5gha0);
					}
					pwrdet->max_pwr[PHY_CORE_0][band_num]  =
						(int8)PHY_GETINTVAR(pi, rstr_maxp5gha0);
					pwrdet->pwrdet_a1[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a0);
					pwrdet->pwrdet_b0[PHY_CORE_0][band_num]	=
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a0);
					pwrdet->pwrdet_b1[PHY_CORE_0][band_num] =
						(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a0);

					if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
						if (ISNPHY(pi)) {
							pi_nphy->nphy_txpid5g[PHY_CORE_1][band_num]
							= (uint8)PHY_GETINTVAR(pi, rstr_txpid5gha1);
						}
						pwrdet->max_pwr[PHY_CORE_1][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gha1);
						pwrdet->pwrdet_a1[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a1);
						pwrdet->pwrdet_b0[PHY_CORE_1][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a1);
						pwrdet->pwrdet_b1[PHY_CORE_1][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a1);
					}
					if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
						pwrdet->max_pwr[PHY_CORE_2][band_num]  =
							(int8)PHY_GETINTVAR(pi, rstr_maxp5gha2);
						pwrdet->pwrdet_a1[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a2);
						pwrdet->pwrdet_b0[PHY_CORE_2][band_num]	=
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a2);
						pwrdet->pwrdet_b1[PHY_CORE_2][band_num] =
							(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a2);
					}

					if (ISNPHY(pi)) {
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_0].
						idle_targ_5g[band_num] = 0;
						pi_nphy->nphy_pwrctrl_info[PHY_CORE_1].
						idle_targ_5g[band_num] = 0;
					}

					/* 5G highband ofdm5ghpo power offsets */
					pi->ppr.sr8.ofdm[band_num] =
						(uint32)PHY_GETINTVAR(pi, rstr_ofdm5ghpo);

					/* 5G highband mcs5ghpo power offsets */
					pi->ppr.sr8.mcs[band_num][0] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo0);
					pi->ppr.sr8.mcs[band_num][1] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo1);
					pi->ppr.sr8.mcs[band_num][2] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo2);
					pi->ppr.sr8.mcs[band_num][3] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo3);
					pi->ppr.sr8.mcs[band_num][4] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo4);
					pi->ppr.sr8.mcs[band_num][5] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo5);
					pi->ppr.sr8.mcs[band_num][6] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo6);
					pi->ppr.sr8.mcs[band_num][7] =
						(uint16)PHY_GETINTVAR(pi, rstr_mcs5ghpo7);
					break;
#endif /* BAND5G */
				}
			}

		/* Finished reading from SROM, calculate and apply powers */
}

static void
BCMATTACHFN(wlc_phy_txpwr_srom9_read_ppr)(phy_info_t *pi)
{

	/* Read and interpret the power-offset parameters from the SROM for each band/subband */
	if (pi->sh->sromrev >= 9) {
		int i, j;

		PHY_INFORM(("Get SROM 9 Power Offset per rate\n"));
		/* 2G CCK */
		pi->ppr.sr9.cckbw202gpo = (uint16)PHY_GETINTVAR(pi, rstr_cckbw202gpo);
		pi->ppr.sr9.cckbw20ul2gpo = (uint16)PHY_GETINTVAR(pi, rstr_cckbw20ul2gpo);
		/* 2G OFDM power offsets */
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw202gpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw20ul2gpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw202gpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw20ul2gpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw40 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw402gpo);

#ifdef BAND5G
		/* 5G power offsets */
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND0].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw205glpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND0].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw20ul5glpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND1].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw205gmpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND1].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw20ul5gmpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND2].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw205ghpo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND2].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw20ul5ghpo);

		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND0].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw205glpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND0].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw20ul5glpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND0].bw40 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw405glpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND1].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw205gmpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND1].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw20ul5gmpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND1].bw40 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw405gmpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND2].bw20 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw205ghpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND2].bw20ul =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw20ul5ghpo);
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND2].bw40 =
			(uint32)PHY_GETINTVAR(pi, rstr_mcsbw405ghpo);
		if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
		{
			pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND3].bw20 =
				(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw205ghpo);
			pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND3].bw20ul =
				(uint32)PHY_GETINTVAR(pi, rstr_legofdmbw20ul5ghpo);

			pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND3].bw20 =
				(uint32)PHY_GETINTVAR(pi, rstr_mcsbw205ghpo);
			pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND3].bw20ul =
				(uint32)PHY_GETINTVAR(pi, rstr_mcsbw20ul5ghpo);
			pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_5G_BAND3].bw40 =
				(uint32)PHY_GETINTVAR(pi, rstr_mcsbw405ghpo);
		}
#endif /* BAND5G */

		/* 40 Dups */
		pi->ppr.sr9.ofdm40duppo = (uint16)PHY_GETINTVAR(pi, rstr_legofdm40duppo);
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw40 =
			pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20ul;
		for (i = 0; i < NUMSUBBANDS(pi); i++) {
			uint32 nibble, dup40_offset = 0;
			nibble = pi->ppr.sr9.ofdm40duppo & 0xf;
			for (j = 0; j < WL_NUM_RATES_OFDM; j++) {
				dup40_offset |= nibble;
				nibble <<= 4;
			}
			if (i == 0)
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw40 =
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20ul +
				dup40_offset;
#ifdef BAND5G
			else if (i == 1)
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND0].bw40 =
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND0].bw20ul +
				dup40_offset;
			else if (i == 2)
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND1].bw40 =
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND1].bw20ul +
				dup40_offset;
			else if (i == 3)
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND2].bw40 =
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND2].bw20ul +
				dup40_offset;
			else if (i == 4)
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND3].bw40 =
				pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_5G_BAND3].bw20ul +
				dup40_offset;

#endif /* BAND5G */
		}
	}

	PHY_INFORM(("CCK: 0x%04x 0x%04x\n", pi->ppr.sr9.cckbw202gpo, pi->ppr.sr9.cckbw202gpo));
	PHY_INFORM(("OFDM: 0x%08x 0x%08x 0x%02x\n",
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20,
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw20ul,
		pi->ppr.sr9.ofdm[WL_CHAN_FREQ_RANGE_2G].bw40));
	PHY_INFORM(("MCS: 0x%08x 0x%08x 0x%08x\n",
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw20,
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw20ul,
		pi->ppr.sr9.mcs[WL_CHAN_FREQ_RANGE_2G].bw40));
}

static void
BCMATTACHFN(wlc_phy_txpwr_srom11_read_ppr)(phy_info_t *pi)
{

	/* Read and interpret the power-offset parameters from the SROM for each band/subband */
	if (pi->sh->sromrev >= 11) {
		uint16 _tmp;
		uint8 nibble, nibble01;

		PHY_INFORM(("Get SROM 11 Power Offset per rate\n"));
		/* --------------2G------------------- */
		/* 2G CCK */
		pi->ppr.sr11.cck.bw20 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_cckbw202gpo);
		pi->ppr.sr11.cck.bw20in40 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_cckbw20ul2gpo);

		pi->ppr.sr11.offset_2g			=
		                (uint16)PHY_GETINTVAR(pi, rstr_ofdmlrbw202gpo);
		/* 2G OFDM_20 */
		_tmp 		= (uint16)PHY_GETINTVAR(pi, rstr_dot11agofdmhrbw202gpo);
		nibble 		= pi->ppr.sr11.offset_2g & 0xf;
		nibble01 	= (nibble<<4)|nibble;
		nibble 		= (pi->ppr.sr11.offset_2g>>4)& 0xf;
		pi->ppr.sr11.ofdm_2g.bw20 		=
		                (((nibble<<8)|(nibble<<12))|(nibble01))&0xffff;
		pi->ppr.sr11.ofdm_2g.bw20 		|=
		                (_tmp << 16);
		/* 2G MCS_20 */
		pi->ppr.sr11.mcs_2g.bw20 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw202gpo);
		/* 2G MCS_40 */
		pi->ppr.sr11.mcs_2g.bw40 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw402gpo);

		pi->ppr.sr11.offset_20in40_l 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in40lrpo);
		pi->ppr.sr11.offset_20in40_h 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in40hrpo);

		pi->ppr.sr11.offset_dup_h 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_dot11agduphrpo);
		pi->ppr.sr11.offset_dup_l 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_dot11agduplrpo);

#ifdef BAND5G
		/* ---------------5G--------------- */
		/* 5G 11agnac_20IN20 */
		pi->ppr.sr11.ofdm_5g.bw20[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205glpo);
		pi->ppr.sr11.ofdm_5g.bw20[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205gmpo);
		pi->ppr.sr11.ofdm_5g.bw20[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205ghpo);

		pi->ppr.sr11.offset_5g[0]			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5glpo);
		pi->ppr.sr11.offset_5g[1] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5gmpo);
		pi->ppr.sr11.offset_5g[2] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5ghpo);

		/* 5G 11nac 40IN40 */
		pi->ppr.sr11.mcs_5g.bw40[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405glpo);
		pi->ppr.sr11.mcs_5g.bw40[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405gmpo);
		pi->ppr.sr11.mcs_5g.bw40[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405ghpo);

		/* 5G 11nac 80IN80 */
		pi->ppr.sr11.mcs_5g.bw80[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805glpo);
		pi->ppr.sr11.mcs_5g.bw80[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805gmpo);
		pi->ppr.sr11.mcs_5g.bw80[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805ghpo);

		/* 5G 11agnac_20Ul/20LU */
		pi->ppr.sr11.offset_20in80_l[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5glpo);
		pi->ppr.sr11.offset_20in80_h[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5glpo);
		pi->ppr.sr11.offset_20in80_l[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5gmpo);
		pi->ppr.sr11.offset_20in80_h[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5gmpo);
		pi->ppr.sr11.offset_20in80_l[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5ghpo);
		pi->ppr.sr11.offset_20in80_h[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5ghpo);

		/* 5G 11nac_40IN80 */
		pi->ppr.sr11.offset_40in80_l[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5glpo);
		pi->ppr.sr11.offset_40in80_h[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5glpo);
		pi->ppr.sr11.offset_40in80_l[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5gmpo);
		pi->ppr.sr11.offset_40in80_h[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5gmpo);
		pi->ppr.sr11.offset_40in80_l[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5ghpo);
		pi->ppr.sr11.offset_40in80_h[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5ghpo);

#endif /* BAND5G */
		if (0) {
			/* printf srom value for verification */
			PHY_ERROR(("		cckbw202gpo=%x\n", pi->ppr.sr11.cck.bw20));
			PHY_ERROR(("		cckbw20ul2gpo=%x\n", pi->ppr.sr11.cck.bw20in40));
			PHY_ERROR(("		ofdmlrbw202gpo=%x\n", pi->ppr.sr11.offset_2g));
			PHY_ERROR(("		dot11agofdmhrbw202gpo=%x\n", _tmp));
			PHY_ERROR(("		mcsbw202gpo=%x\n", pi->ppr.sr11.mcs_2g.bw20));
			PHY_ERROR(("		mcsbw402gpo=%x\n", pi->ppr.sr11.mcs_2g.bw40));
			PHY_ERROR(("		sb20in40lrpo=%x\n", pi->ppr.sr11.offset_20in40_l));
			PHY_ERROR(("		sb20in40hrpo=%x\n", pi->ppr.sr11.offset_20in40_h));
			PHY_ERROR(("		dot11agduphrpo=%x\n", pi->ppr.sr11.offset_dup_h));
			PHY_ERROR(("		dot11agduplrpo=%x\n", pi->ppr.sr11.offset_dup_l));
			PHY_ERROR(("		mcsbw205glpo=%x\n", pi->ppr.sr11.ofdm_5g.bw20[0]));
			PHY_ERROR(("		mcsbw205gmpo=%x\n", pi->ppr.sr11.ofdm_5g.bw20[1]));
			PHY_ERROR(("		mcsbw205ghpo=%x\n", pi->ppr.sr11.ofdm_5g.bw20[2]));
			PHY_ERROR(("		mcslr5glpo=%x\n", pi->ppr.sr11.offset_5g[0]));
			PHY_ERROR(("		mcslr5gmpo=%x\n", pi->ppr.sr11.offset_5g[1]));
			PHY_ERROR(("		mcslr5ghpo=%x\n", pi->ppr.sr11.offset_5g[2]));
			PHY_ERROR(("		mcsbw405glpo=%x\n", pi->ppr.sr11.mcs_5g.bw40[0]));
			PHY_ERROR(("		mcsbw405gmpo=%x\n", pi->ppr.sr11.mcs_5g.bw40[1]));
			PHY_ERROR(("		mcsbw405ghpo=%x\n", pi->ppr.sr11.mcs_5g.bw40[2]));
			PHY_ERROR(("		mcsbw805glpo=%x\n", pi->ppr.sr11.mcs_5g.bw80[0]));
			PHY_ERROR(("		mcsbw805gmpo=%x\n", pi->ppr.sr11.mcs_5g.bw80[1]));
			PHY_ERROR(("		mcsbw805ghpo=%x\n", pi->ppr.sr11.mcs_5g.bw80[2]));
			PHY_ERROR(("		sb20in80and160lr5glpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_l[0]));
			PHY_ERROR(("		sb20in80and160hr5glpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_h[0]));
			PHY_ERROR(("		sb20in80and160lr5gmpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_l[1]));
			PHY_ERROR(("		sb20in80and160hr5gmpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_h[1]));
			PHY_ERROR(("		sb20in80and160lr5ghpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_l[2]));
			PHY_ERROR(("		sb20in80and160hr5ghpo=%x\n",
			                    pi->ppr.sr11.offset_20in80_h[2]));
			PHY_ERROR(("		sb40and80lr5glpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_l[0]));
			PHY_ERROR(("		sb40and80hr5glpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_h[0]));
			PHY_ERROR(("		sb40and80lr5gmpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_l[1]));
			PHY_ERROR(("		sb40and80hr5gmpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_h[1]));
			PHY_ERROR(("		sb40and80lr5ghpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_l[2]));
			PHY_ERROR(("		sb40and80hr5ghpo=%x\n",
			                    pi->ppr.sr11.offset_40in80_h[2]));
		}
	}
}

#ifdef SROM12
static void
BCMATTACHFN(wlc_phy_txpwr_srom12_read_ppr)(phy_info_t *pi)
{

	/* Read and interpret the power-offset parameters from the SROM for each band/subband */
	if (pi->sh->sromrev >= 12) {
		uint16 _tmp;
		uint8 nibble, nibble01;

		PHY_INFORM(("Get SROM 12 Power Offset per rate\n"));
		/* --------------2G------------------- */
		/* 2G CCK */
		pi->ppr.sr12.cck.bw20 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_cckbw202gpo);
		pi->ppr.sr12.cck.bw20in40 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_cckbw20ul2gpo);

		pi->ppr.sr12.offset_2g			=
		                (uint16)PHY_GETINTVAR(pi, rstr_ofdmlrbw202gpo);
		/* 2G OFDM_20 */
		_tmp 		= (uint16)PHY_GETINTVAR(pi, rstr_dot11agofdmhrbw202gpo);
		nibble 		= pi->ppr.sr12.offset_2g & 0xf;
		nibble01 	= (nibble<<4)|nibble;
		nibble 		= (pi->ppr.sr12.offset_2g>>4)& 0xf;
		pi->ppr.sr12.ofdm_2g.bw20 		=
		                (((nibble<<8)|(nibble<<12))|(nibble01))&0xffff;
		pi->ppr.sr12.ofdm_2g.bw20 		|=
		                (_tmp << 16);
		/* 2G MCS_20 */
		pi->ppr.sr12.mcs_2g.bw20 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw202gpo);
		/* 2G MCS_40 */
		pi->ppr.sr12.mcs_2g.bw40 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw402gpo);

		pi->ppr.sr12.offset_20in40_l 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in40lrpo);
		pi->ppr.sr12.offset_20in40_h 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in40hrpo);

		pi->ppr.sr12.offset_dup_h 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_dot11agduphrpo);
		pi->ppr.sr12.offset_dup_l 		=
		                (uint16)PHY_GETINTVAR(pi, rstr_dot11agduplrpo);

#ifdef BAND5G
		/* ---------------5G--------------- */
		/* 5G 11agnac_20IN20 */
		pi->ppr.sr12.ofdm_5g.bw20[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205glpo);
		pi->ppr.sr12.ofdm_5g.bw20[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205gmpo);
		pi->ppr.sr12.ofdm_5g.bw20[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205ghpo);
		pi->ppr.sr12.ofdm_5g.bw20[3] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205gx1po);
		pi->ppr.sr12.ofdm_5g.bw20[4] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw205gx2po);

		pi->ppr.sr12.offset_5g[0]			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5glpo);
		pi->ppr.sr12.offset_5g[1] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5gmpo);
		pi->ppr.sr12.offset_5g[2] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5ghpo);
		pi->ppr.sr12.offset_5g[3] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5gx1po);
		pi->ppr.sr12.offset_5g[4] 			=
		                (uint16)PHY_GETINTVAR(pi, rstr_mcslr5gx2po);

		/* 5G 11nac 40IN40 */
		pi->ppr.sr12.mcs_5g.bw40[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405glpo);
		pi->ppr.sr12.mcs_5g.bw40[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405gmpo);
		pi->ppr.sr12.mcs_5g.bw40[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405ghpo);
		pi->ppr.sr12.mcs_5g.bw40[3] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405gx1po);
		pi->ppr.sr12.mcs_5g.bw40[4] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw405gx2po);

		/* 5G 11nac 80IN80 */
		pi->ppr.sr12.mcs_5g.bw80[0] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805glpo);
		pi->ppr.sr12.mcs_5g.bw80[1] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805gmpo);
		pi->ppr.sr12.mcs_5g.bw80[2] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805ghpo);
		pi->ppr.sr12.mcs_5g.bw80[3] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805gx1po);
		pi->ppr.sr12.mcs_5g.bw80[4] 		=
		                (uint32)PHY_GETINTVAR(pi, rstr_mcsbw805gx2po);

		pi->ppr.sr12.offset_20in80_l[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5glpo);
		pi->ppr.sr12.offset_20in80_h[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5glpo);
		pi->ppr.sr12.offset_20in80_l[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5gmpo);
		pi->ppr.sr12.offset_20in80_h[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5gmpo);
		pi->ppr.sr12.offset_20in80_l[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5ghpo);
		pi->ppr.sr12.offset_20in80_h[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5ghpo);
		pi->ppr.sr12.offset_20in80_l[3] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5gx1po);
		pi->ppr.sr12.offset_20in80_h[3] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5gx1po);
		pi->ppr.sr12.offset_20in80_l[4] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160lr5gx2po);
		pi->ppr.sr12.offset_20in80_h[4] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb20in80and160hr5gx2po);

		pi->ppr.sr12.offset_40in80_l[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5glpo);
		pi->ppr.sr12.offset_40in80_h[0] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5glpo);
		pi->ppr.sr12.offset_40in80_l[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5gmpo);
		pi->ppr.sr12.offset_40in80_h[1] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5gmpo);
		pi->ppr.sr12.offset_40in80_l[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5ghpo);
		pi->ppr.sr12.offset_40in80_h[2] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5ghpo);
		pi->ppr.sr12.offset_40in80_l[3] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5gx1po);
		pi->ppr.sr12.offset_40in80_h[3] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5gx1po);
		pi->ppr.sr12.offset_40in80_l[4] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80lr5gx2po);
		pi->ppr.sr12.offset_40in80_h[4] 	=
		                (uint16)PHY_GETINTVAR(pi, rstr_sb40and80hr5gx2po);

#endif /* BAND5G */
		if (0) {
			/* printf srom value for verification */
			PHY_ERROR(("		cckbw202gpo=%x\n", pi->ppr.sr12.cck.bw20));
			PHY_ERROR(("		cckbw20ul2gpo=%x\n", pi->ppr.sr12.cck.bw20in40));
			PHY_ERROR(("		ofdmlrbw202gpo=%x\n", pi->ppr.sr12.offset_2g));
			PHY_ERROR(("		dot11agofdmhrbw202gpo=%x\n", _tmp));
			PHY_ERROR(("		mcsbw202gpo=%x\n", pi->ppr.sr12.mcs_2g.bw20));
			PHY_ERROR(("		mcsbw402gpo=%x\n", pi->ppr.sr12.mcs_2g.bw40));
			PHY_ERROR(("		sb20in40lrpo=%x\n", pi->ppr.sr12.offset_20in40_l));
			PHY_ERROR(("		sb20in40hrpo=%x\n", pi->ppr.sr12.offset_20in40_h));
			PHY_ERROR(("		dot11agduphrpo=%x\n", pi->ppr.sr12.offset_dup_h));
			PHY_ERROR(("		dot11agduplrpo=%x\n", pi->ppr.sr12.offset_dup_l));
			PHY_ERROR(("		mcsbw205glpo=%x\n", pi->ppr.sr12.ofdm_5g.bw20[0]));
			PHY_ERROR(("		mcsbw205gmpo=%x\n", pi->ppr.sr12.ofdm_5g.bw20[1]));
			PHY_ERROR(("		mcsbw205ghpo=%x\n", pi->ppr.sr12.ofdm_5g.bw20[2]));
			PHY_ERROR(("		mcsbw205gx1po=%x\n", pi->ppr.sr12.ofdm_5g.bw20[3]));
			PHY_ERROR(("		mcsbw205gx2po=%x\n", pi->ppr.sr12.ofdm_5g.bw20[4]));
			PHY_ERROR(("		mcslr5glpo=%x\n", pi->ppr.sr12.offset_5g[0]));
			PHY_ERROR(("		mcslr5gmpo=%x\n", pi->ppr.sr12.offset_5g[1]));
			PHY_ERROR(("		mcslr5ghpo=%x\n", pi->ppr.sr12.offset_5g[2]));
			PHY_ERROR(("		mcslr5gx1po=%x\n", pi->ppr.sr12.offset_5g[3]));
			PHY_ERROR(("		mcslr5gx2po=%x\n", pi->ppr.sr12.offset_5g[4]));
			PHY_ERROR(("		mcsbw405glpo=%x\n", pi->ppr.sr12.mcs_5g.bw40[0]));
			PHY_ERROR(("		mcsbw405gmpo=%x\n", pi->ppr.sr12.mcs_5g.bw40[1]));
			PHY_ERROR(("		mcsbw405ghpo=%x\n", pi->ppr.sr12.mcs_5g.bw40[2]));
			PHY_ERROR(("		mcsbw405gx1po=%x\n", pi->ppr.sr12.mcs_5g.bw40[3]));
			PHY_ERROR(("		mcsbw405gx2po=%x\n", pi->ppr.sr12.mcs_5g.bw40[4]));
			PHY_ERROR(("		mcsbw805glpo=%x\n", pi->ppr.sr12.mcs_5g.bw80[0]));
			PHY_ERROR(("		mcsbw805gmpo=%x\n", pi->ppr.sr12.mcs_5g.bw80[1]));
			PHY_ERROR(("		mcsbw805ghpo=%x\n", pi->ppr.sr12.mcs_5g.bw80[2]));
			PHY_ERROR(("		mcsbw805gx1po=%x\n", pi->ppr.sr12.mcs_5g.bw80[3]));
			PHY_ERROR(("		mcsbw805gx2po=%x\n", pi->ppr.sr12.mcs_5g.bw80[4]));
			PHY_ERROR(("		sb20in80and160lr5glpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_l[0]));
			PHY_ERROR(("		sb20in80and160hr5glpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_h[0]));
			PHY_ERROR(("		sb20in80and160lr5gmpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_l[1]));
			PHY_ERROR(("		sb20in80and160hr5gmpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_h[1]));
			PHY_ERROR(("		sb20in80and160lr5ghpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_l[2]));
			PHY_ERROR(("		sb20in80and160hr5ghpo=%x\n",
			                    pi->ppr.sr12.offset_20in80_h[2]));
			PHY_ERROR(("		sb20in80and160lr5gx1po=%x\n",
			                    pi->ppr.sr12.offset_20in80_l[3]));
			PHY_ERROR(("		sb20in80and160hr5gx1po=%x\n",
			                    pi->ppr.sr12.offset_20in80_h[3]));
			PHY_ERROR(("		sb20in80and160lr5gx2po=%x\n",
			                    pi->ppr.sr12.offset_20in80_l[4]));
			PHY_ERROR(("		sb20in80and160hr5gx2po=%x\n",
			                    pi->ppr.sr12.offset_20in80_h[4]));
			PHY_ERROR(("		sb40and80lr5glpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_l[0]));
			PHY_ERROR(("		sb40and80hr5glpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_h[0]));
			PHY_ERROR(("		sb40and80lr5gmpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_l[1]));
			PHY_ERROR(("		sb40and80hr5gmpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_h[1]));
			PHY_ERROR(("		sb40and80lr5ghpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_l[2]));
			PHY_ERROR(("		sb40and80hr5ghpo=%x\n",
			                    pi->ppr.sr12.offset_40in80_h[2]));
			PHY_ERROR(("		sb40and80lr5gx1po=%x\n",
			                    pi->ppr.sr12.offset_40in80_l[3]));
			PHY_ERROR(("		sb40and80hr5gx1po=%x\n",
			                    pi->ppr.sr12.offset_40in80_h[3]));
			PHY_ERROR(("		sb40and80lr5gx2po=%x\n",
			                    pi->ppr.sr12.offset_40in80_l[4]));
			PHY_ERROR(("		sb40and80hr5gx2po=%x\n",
			                    pi->ppr.sr12.offset_40in80_h[4]));
		}
	}
}
#endif /* SROM12 */

static void
wlc_phy_txpwr_srom9_convert(phy_info_t *pi, int8 *srom_max,
                                            uint32 pwr_offset, uint8 tmp_max_pwr, uint8 rate_cnt)
{
	uint8 rate;
	uint8 nibble;

	if (pi->sh->sromrev < 9) {
		ASSERT(0 && "SROMREV < 9");
		return;
	}

	for (rate = 0; rate < rate_cnt; rate++) {
		nibble = (uint8)(pwr_offset & 0xf);
		pwr_offset >>= 4;
		/* nibble info indicates offset in 0.5dB units convert to 0.25dB */
		srom_max[rate] = (int8)(tmp_max_pwr - (nibble << 1));
		/* XXX
		  printf("****** srom_max[rate] = %d nibble = %d \n", srom_max[rate], nibble << 1);
		*/
	}
}

void
wlc_phy_txpwr_apply_srom9(phy_info_t *pi, uint8 band_num, chanspec_t chanspec,
	uint8 tmp_max_pwr, ppr_t *tx_srom_max_pwr)
{
	srom_pwrdet_t *pwrdet  = &pi->pwrdet;
	ppr_dsss_rateset_t cck20_offset_ppr_api, cck20in40_offset_ppr_ppr_api;

	ppr_ofdm_rateset_t ofdm20_offset_ppr_api;
	ppr_ofdm_rateset_t ofdm20in40_offset_ppr_api;
	ppr_ofdm_rateset_t ofdmdup40_offset_ppr_api;

	ppr_ht_mcs_rateset_t mcs20_offset_ppr_api;
	ppr_ht_mcs_rateset_t mcs40_offset_ppr_api;
	ppr_ht_mcs_rateset_t mcs20in40_offset_ppr_api;

	ASSERT(tx_srom_max_pwr);

	tmp_max_pwr = pwrdet->max_pwr[0][band_num];

	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp_max_pwr = MIN(tmp_max_pwr, pwrdet->max_pwr[1][band_num]);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp_max_pwr = MIN(tmp_max_pwr, pwrdet->max_pwr[2][band_num]);

	switch (band_num) {
	case WL_CHAN_FREQ_RANGE_2G:
		/* XXX
		   printf("wlc_phy_txpwr_apply_srom9:
		   pi->ppr.sr9.cckbw202gpo = %d ************ \n",pi->ppr.sr9.cckbw202gpo);
		   printf("wlc_phy_txpwr_apply_srom9: pi->ppr.sr9.cckbw20ul2gpo
		   = %d*************** \n",pi->ppr.sr9.cckbw20ul2gpo);
		*/
		if (CHSPEC_IS20(chanspec)) {
			wlc_phy_txpwr_srom9_convert(pi, cck20_offset_ppr_api.pwr,
			                            pi->ppr.sr9.cckbw202gpo, tmp_max_pwr,
			                            WL_RATESET_SZ_DSSS);
			/* populating tx_srom_max_pwr = pi->tx_srom_max_pwr[band]
			   structure
			*/
			/* for 2g_dsss_20IN20: S1x1, S1x2, S1x3 */
			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20,
			                     &cck20_offset_ppr_api, pi);
		}
		else if (CHSPEC_IS40(chanspec)) {
			wlc_phy_txpwr_srom9_convert(pi, cck20in40_offset_ppr_ppr_api.pwr,
			                            pi->ppr.sr9.cckbw20ul2gpo, tmp_max_pwr,
			                            WL_RATESET_SZ_DSSS);
			/* for 2g_dsss_20IN40: S1x1, S1x2, S1x3 */
			wlc_phy_ppr_set_dsss(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &cck20in40_offset_ppr_ppr_api, pi);
		}
		/* Fall through to set OFDM and .11n rates for 2.4GHz band */
	case WL_CHAN_FREQ_RANGE_5G_BAND0:
	case WL_CHAN_FREQ_RANGE_5G_BAND1:
	case WL_CHAN_FREQ_RANGE_5G_BAND2:
	case WL_CHAN_FREQ_RANGE_5G_BAND3:
		/* OFDM srom conversion */
		/* ofdm_20IN20: S1x1, S1x2, S1x3 */
		/*  pwr_offsets = pi->ppr.sr9.ofdm[band_num].bw20; */
		/* XXX
		   printf("wlc_phy_txpwr_apply_srom9: pi->ppr.sr9.ofdm[band_num].bw20 =
		   %d ************ \n",pi->ppr.sr9.ofdm[band_num].bw20);
		   printf("wlc_phy_txpwr_apply_srom9:  pi->ppr.sr9.ofdm[band_num].bw20ul =
		   %d*************** \n", pi->ppr.sr9.ofdm[band_num].bw20ul);
		   printf("wlc_phy_txpwr_apply_srom9:  pi->ppr.sr9.ofdm[band_num].bw40 =
		   %d*************** \n", pi->ppr.sr9.ofdm[band_num].bw40);
		*/
		if (CHSPEC_IS20(chanspec)) {
			wlc_phy_txpwr_srom9_convert(pi, ofdm20_offset_ppr_api.pwr,
			                            pi->ppr.sr9.ofdm[band_num].bw20,
			                            tmp_max_pwr, WL_RATESET_SZ_OFDM);
			/* ofdm_20IN20: S1x1, S1x2, S1x3 */
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20, &ofdm20_offset_ppr_api,
				pi);
			/* HT srom conversion  */
			/*  20MHz HT */
			/* rate_cnt = WL_RATESET_SZ_HT_MCS; */
			/* pwr_offsets = pi->ppr.sr9.mcs[band_num].bw20; */
			wlc_phy_txpwr_srom9_convert(pi, mcs20_offset_ppr_api.pwr,
			                            pi->ppr.sr9.mcs[band_num].bw20,
			                            tmp_max_pwr, WL_RATESET_SZ_HT_MCS);
			/* 20MHz HT  */
			wlc_phy_ppr_set_ht_mcs(tx_srom_max_pwr,
			                       WL_TX_BW_20, &mcs20_offset_ppr_api, pi);
		}
		else if (CHSPEC_IS40(chanspec)) {
			/* * ofdm 20 in 40 */
			/* pwr_offsets = pi->ppr.sr9.ofdm[band_num].bw20ul; */
			wlc_phy_txpwr_srom9_convert(pi, ofdm20in40_offset_ppr_api.pwr,
			                            pi->ppr.sr9.ofdm[band_num].bw20ul,
			                            tmp_max_pwr, WL_RATESET_SZ_OFDM);
			/*  ofdm dup */
			/*  pwr_offsets = pi->ppr.sr9.ofdm[band_num].bw40; */
			wlc_phy_txpwr_srom9_convert(pi, ofdmdup40_offset_ppr_api.pwr,
			                            pi->ppr.sr9.ofdm[band_num].bw40,
			                            tmp_max_pwr, WL_RATESET_SZ_OFDM);
			/* ofdm_20IN40: S1x1, S1x2, S1x3 */
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40,
			                     &ofdm20in40_offset_ppr_api, pi);
			/* ofdm DUP: S1x1, S1x2, S1x3 */
			wlc_phy_ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40,
			                     &ofdmdup40_offset_ppr_api, pi);

			/* XXX
			  printf("wlc_phy_txpwr_apply_srom9:  pi->ppr.sr9.mcs[band_num].bw20 =
			  %d ************ \n", pi->ppr.sr9.mcs[band_num].bw20);
			  printf("wlc_phy_txpwr_apply_srom9:  pi->ppr.sr9.mcs[band_num].bw20ul =
			  %d*************** \n", pi->ppr.sr9.ofdm[band_num].bw20ul);
			  printf("wlc_phy_txpwr_apply_srom9:  pi->ppr.sr9.mcs[band_num].bw40 =
			  %d*************** \n", pi->ppr.sr9.mcs[band_num].bw40);
			*/

			/* 40MHz HT  */

			/* pwr_offsets = pi->ppr.sr9.mcs[band_num].bw20ul; */
			wlc_phy_txpwr_srom9_convert(pi, mcs20in40_offset_ppr_api.pwr,
			                            pi->ppr.sr9.mcs[band_num].bw20ul,
			                            tmp_max_pwr, WL_RATESET_SZ_HT_MCS);
			/* 20IN40MHz HT */
			/* pwr_offsets = pi->ppr.sr9.mcs[band_num].bw40; */
			wlc_phy_txpwr_srom9_convert(pi, mcs40_offset_ppr_api.pwr,
			                            pi->ppr.sr9.mcs[band_num].bw40,
			                            tmp_max_pwr, WL_RATESET_SZ_HT_MCS);
			/* 40MHz HT */
			wlc_phy_ppr_set_ht_mcs(tx_srom_max_pwr,
			                       WL_TX_BW_40, &mcs40_offset_ppr_api, pi);
			/* 20IN40MHz HT */
			wlc_phy_ppr_set_ht_mcs(tx_srom_max_pwr,
			                       WL_TX_BW_20IN40, &mcs20in40_offset_ppr_api, pi);
		}
			break;
		default:
			break;
		}
		/* XXX
		  printf("wlc_phy_txpwr_apply_srom9: *******************
		  band = %d ******************** \n", band_num);
		  ppr_dsss_printf(tx_srom_max_pwr);
		  ppr_ofdm_printf(tx_srom_max_pwr);
		  ppr_mcs_ht_printf(tx_srom_max_pwr);
		*/
}

void
wlc_phy_txpwr_apply_srom_5g_subband(int8 max_pwr_ref, ppr_t *tx_srom_max_pwr,
	uint32 ofdm_20_offsets, uint32 mcs_20_offsets, uint32 mcs_40_offsets)
{
	ppr_ofdm_rateset_t ppr_ofdm;
	ppr_ht_mcs_rateset_t ppr_mcs;
	uint32 offset_mcs, last_offset_mcs;

	/* 5G-hi - OFDM_20 */
	wlc_phy_txpwr_srom_convert_ofdm(ofdm_20_offsets, max_pwr_ref, &ppr_ofdm);
	ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_MODE_NONE, WL_TX_CHAINS_1, &ppr_ofdm);

	/* 5G-hi - MCS_20 */
	offset_mcs = mcs_20_offsets;
	wlc_phy_txpwr_srom_convert_mcs(offset_mcs, max_pwr_ref, &ppr_mcs);
	ppr_set_ht_mcs(tx_srom_max_pwr, WL_TX_BW_20, WL_TX_NSS_1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		&ppr_mcs);

	/* 5G-hi - MCS_40 */
	last_offset_mcs = offset_mcs;
	offset_mcs = mcs_40_offsets;
	if (!offset_mcs)
		offset_mcs = last_offset_mcs;

	wlc_phy_txpwr_srom_convert_mcs(offset_mcs, max_pwr_ref, &ppr_mcs);
	ppr_set_ht_mcs(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_NSS_1, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		&ppr_mcs);
	/* Infer 20in40 MCS from this limit */
	ppr_set_ht_mcs(tx_srom_max_pwr, WL_TX_BW_20IN40, WL_TX_NSS_1, WL_TX_MODE_NONE,
		WL_TX_CHAINS_1, &ppr_mcs);
	/* Infer 20in40 OFDM from this limit */
	ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_20IN40, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		(ppr_ofdm_rateset_t*)&ppr_mcs);
	/* Infer 40MHz OFDM from this limit */
	ppr_set_ofdm(tx_srom_max_pwr, WL_TX_BW_40, WL_TX_MODE_NONE, WL_TX_CHAINS_1,
		(ppr_ofdm_rateset_t*)&ppr_mcs);
}

static const char BCMATTACHDATA(rstr_elna2g)[] = "elna2g";
static const char BCMATTACHDATA(rstr_elna5g)[] = "elna5g";
static const char BCMATTACHDATA(rstr_antswitch)[] = "antswitch";
static const char BCMATTACHDATA(rstr_aa2g)[] = "aa2g";
static const char BCMATTACHDATA(rstr_aa5g)[] = "aa5g";
static const char BCMATTACHDATA(rstr_tssipos2g)[] = "tssipos2g";
static const char BCMATTACHDATA(rstr_extpagain2g)[] = "extpagain2g";
static const char BCMATTACHDATA(rstr_pdetrange2g)[] = "pdetrange2g";
static const char BCMATTACHDATA(rstr_triso2g)[] = "triso2g";
static const char BCMATTACHDATA(rstr_antswctl2g)[] = "antswctl2g";
static const char BCMATTACHDATA(rstr_tssipos5g)[] = "tssipos5g";
static const char BCMATTACHDATA(rstr_extpagain5g)[] = "extpagain5g";
static const char BCMATTACHDATA(rstr_pdetrange5g)[] = "pdetrange5g";
static const char BCMATTACHDATA(rstr_triso5g)[] = "triso5g";
static const char BCMATTACHDATA(rstr_antswctl5g)[] = "antswctl5g";
#if HTCONF != 0
static const char BCMATTACHDATA(rstr_pcieingress_war)[] = "pcieingress_war";
#endif // endif
static const char BCMATTACHDATA(rstr_pa2gw0a3)[] = "pa2gw0a3";
static const char BCMATTACHDATA(rstr_pa2gw1a3)[] = "pa2gw1a3";
static const char BCMATTACHDATA(rstr_pa2gw2a3)[] = "pa2gw2a3";
static const char BCMATTACHDATA(rstr_pa2ga0)[] = "pa2ga0";
static const char BCMATTACHDATA(rstr_pa2ga1)[] = "pa2ga1";
static const char BCMATTACHDATA(rstr_pa2ga2)[] = "pa2ga2";
static const char BCMATTACHDATA(rstr_pa2ga3)[] = "pa2ga3";
static const char BCMATTACHDATA(rstr_pa5ga0)[] = "pa5ga0";
static const char BCMATTACHDATA(rstr_pa5ga1)[] = "pa5ga1";
static const char BCMATTACHDATA(rstr_pa5ga2)[] = "pa5ga2";
static const char BCMATTACHDATA(rstr_pa5ga3)[] = "pa5ga3";
static const char BCMATTACHDATA(rstr_pa5gbw4080a0)[] = "pa5gbw4080a0";
static const char BCMATTACHDATA(rstr_pa5gbw4080a1)[] = "pa5gbw4080a1";
static const char BCMATTACHDATA(rstr_pa2gccka0)[] = "pa2gccka0";
static const char BCMATTACHDATA(rstr_pa2gccka1)[] = "pa2gccka1";
static const char BCMATTACHDATA(rstr_pa2gbw40a0)[] = "pa2gbw40a0";
static const char BCMATTACHDATA(rstr_pa5gbw40a0)[] = "pa5gbw40a0";
static const char BCMATTACHDATA(rstr_pa5gbw80a0)[] = "pa5gbw80a0";
static const char BCMATTACHDATA(rstr_tssifloor2g)[] = "tssifloor2g";
static const char BCMATTACHDATA(rstr_tssifloor2ga1)[] = "tssifloor2ga1";
static const char BCMATTACHDATA(rstr_tssifloor5g)[] = "tssifloor5g";
static const char BCMATTACHDATA(rstr_tssifloor5ga1)[] = "tssifloor5ga1";
/* tssifloor2/5g is for core0, tssifloor2/5ga1 is for core1 */
static const char BCMATTACHDATA(rstr_tempoffset)[] = "tempoffset";
#ifdef POWPERCHANNL2G
static const char BCMATTACHDATA(rstr_PowOffs2GTNA0)[] = "powoffs2gtna0";
static const char BCMATTACHDATA(rstr_PowOffs2GTNA1)[] = "powoffs2gtna1";
static const char BCMATTACHDATA(rstr_PowOffs2GTNA2)[] = "powoffs2gtna2";
static const char BCMATTACHDATA(rstr_PowOffs2GTLA0)[] = "powoffs2gtla0";
static const char BCMATTACHDATA(rstr_PowOffs2GTLA1)[] = "powoffs2gtla1";
static const char BCMATTACHDATA(rstr_PowOffs2GTLA2)[] = "powoffs2gtla2";
static const char BCMATTACHDATA(rstr_PowOffs2GTHA0)[] = "powoffs2gtha0";
static const char BCMATTACHDATA(rstr_PowOffs2GTHA1)[] = "powoffs2gtha1";
static const char BCMATTACHDATA(rstr_PowOffs2GTHA2)[] = "powoffs2gtha2";
static const char BCMATTACHDATA(rstr_PowOffsTempRange)[] = "powoffstemprange";
#endif /* POWPERCHANNL2G */
#ifdef POWPERCHANNL5G
static const char BCMATTACHDATA(rstr_PowOffs5G20MTNA0)[] = "powoffs5g20mtna0";
static const char BCMATTACHDATA(rstr_PowOffs5G20MTNA1)[] = "powoffs5g20mtna1";
static const char BCMATTACHDATA(rstr_PowOffs5G20MTNA2)[] = "powoffs5g20mtna2";
static const char BCMATTACHDATA(rstr_PowOffs5G40MTNA0)[] = "powoffs5g40mtna0";
static const char BCMATTACHDATA(rstr_PowOffs5G40MTNA1)[] = "powoffs5g40mtna1";
static const char BCMATTACHDATA(rstr_PowOffs5G40MTNA2)[] = "powoffs5g40mtna2";
static const char BCMATTACHDATA(rstr_PowOffs5G80MTNA0)[] = "powoffs5g80mtna0";
static const char BCMATTACHDATA(rstr_PowOffs5G80MTNA1)[] = "powoffs5g80mtna1";
static const char BCMATTACHDATA(rstr_PowOffs5G80MTNA2)[] = "powoffs5g80mtna2";
#endif /* POWPERCHANNL5G */
#ifdef POWPERBAND5G
static const char BCMATTACHDATA(rstr_SbPowOffs5G20MTNA0)[] = "sbpowoffs5g20mtna0";
static const char BCMATTACHDATA(rstr_SbPowOffs5G20MTNA1)[] = "sbpowoffs5g20mtna1";
static const char BCMATTACHDATA(rstr_SbPowOffs5G20MTNA2)[] = "sbpowoffs5g20mtna2";
static const char BCMATTACHDATA(rstr_SbPowOffs5G40MTNA0)[] = "sbpowoffs5g40mtna0";
static const char BCMATTACHDATA(rstr_SbPowOffs5G40MTNA1)[] = "sbpowoffs5g40mtna1";
static const char BCMATTACHDATA(rstr_SbPowOffs5G40MTNA2)[] = "sbpowoffs5g40mtna2";
static const char BCMATTACHDATA(rstr_SbPowOffs5G80MTNA0)[] = "sbpowoffs5g80mtna0";
static const char BCMATTACHDATA(rstr_SbPowOffs5G80MTNA1)[] = "sbpowoffs5g80mtna1";
static const char BCMATTACHDATA(rstr_SbPowOffs5G80MTNA2)[] = "sbpowoffs5g80mtna2";
#endif /* POWPERBAND5G */
static const char BCMATTACHDATA(rstr_pdoffset2g40mvalid)[] = "pdoffset2g40mvalid";
static const char BCMATTACHDATA(rstr_pdoffset40ma0)[]      = "pdoffset40ma0";
static const char BCMATTACHDATA(rstr_pdoffset80ma0)[]      = "pdoffset80ma0";
static const char BCMATTACHDATA(rstr_pdoffset2g40ma0)[]    = "pdoffset2g40ma0";
static const char BCMATTACHDATA(rstr_pdoffsetcckma0)[]     = "pdoffsetcckma0";
static const char BCMATTACHDATA(rstr_cckpwroffset0)[]      = "cckpwroffset0";
static const char BCMATTACHDATA(rstr_pdoffset40ma1)[]      = "pdoffset40ma1";
static const char BCMATTACHDATA(rstr_pdoffset80ma1)[]      = "pdoffset80ma1";
static const char BCMATTACHDATA(rstr_pdoffset2g40ma1)[]    = "pdoffset2g40ma1";
static const char BCMATTACHDATA(rstr_pdoffsetcckma1)[]     = "pdoffsetcckma1";
static const char BCMATTACHDATA(rstr_cckpwroffset1)[]      = "cckpwroffset1";
static const char BCMATTACHDATA(rstr_pdoffset40ma2)[]      = "pdoffset40ma2";
static const char BCMATTACHDATA(rstr_pdoffset80ma2)[]      = "pdoffset80ma2";
static const char BCMATTACHDATA(rstr_pdoffset2g40ma2)[]    = "pdoffset2g40ma2";
static const char BCMATTACHDATA(rstr_pdoffsetcckma2)[]     = "pdoffsetcckma2";
static const char BCMATTACHDATA(rstr_cckpwroffset2)[]      = "cckpwroffset2";
static const char BCMATTACHDATA(rstr_cckPwrIdxCorr)[]      = "cckPwrIdxCorr";
#ifdef SROM12
static const char BCMATTACHDATA(rstr_pa2g40a0)[] = "pa2g40a0";
static const char BCMATTACHDATA(rstr_pa2g40a1)[] = "pa2g40a1";
static const char BCMATTACHDATA(rstr_pa2g40a2)[] = "pa2g40a2";
static const char BCMATTACHDATA(rstr_pa5g40a0)[] = "pa5g40a0";
static const char BCMATTACHDATA(rstr_pa5g40a1)[] = "pa5g40a1";
static const char BCMATTACHDATA(rstr_pa5g40a2)[] = "pa5g40a2";
static const char BCMATTACHDATA(rstr_pa5g80a0)[] = "pa5g80a0";
static const char BCMATTACHDATA(rstr_pa5g80a1)[] = "pa5g80a1";
static const char BCMATTACHDATA(rstr_pa5g80a2)[] = "pa5g80a2";
static const char BCMATTACHDATA(rstr_maxp2gb0a0)[] = "maxp2ga0";
static const char BCMATTACHDATA(rstr_maxp2gb0a1)[] = "maxp2ga1";
static const char BCMATTACHDATA(rstr_maxp2gb0a2)[] = "maxp2ga2";
static const char BCMATTACHDATA(rstr_maxp5gb0a0)[] = "maxp5gb0a0";
static const char BCMATTACHDATA(rstr_maxp5gb0a1)[] = "maxp5gb0a1";
static const char BCMATTACHDATA(rstr_maxp5gb0a2)[] = "maxp5gb0a2";
static const char BCMATTACHDATA(rstr_maxp5gb1a0)[] = "maxp5gb1a0";
static const char BCMATTACHDATA(rstr_maxp5gb1a1)[] = "maxp5gb1a1";
static const char BCMATTACHDATA(rstr_maxp5gb1a2)[] = "maxp5gb1a2";
static const char BCMATTACHDATA(rstr_maxp5gb2a0)[] = "maxp5gb2a0";
static const char BCMATTACHDATA(rstr_maxp5gb2a1)[] = "maxp5gb2a1";
static const char BCMATTACHDATA(rstr_maxp5gb2a2)[] = "maxp5gb2a2";
static const char BCMATTACHDATA(rstr_maxp5gb3a0)[] = "maxp5gb3a0";
static const char BCMATTACHDATA(rstr_maxp5gb3a1)[] = "maxp5gb3a1";
static const char BCMATTACHDATA(rstr_maxp5gb3a2)[] = "maxp5gb3a2";
static const char BCMATTACHDATA(rstr_maxp5gb4a0)[] = "maxp5gb4a0";
static const char BCMATTACHDATA(rstr_maxp5gb4a1)[] = "maxp5gb4a1";
static const char BCMATTACHDATA(rstr_maxp5gb4a2)[] = "maxp5gb4a2";
static const char BCMATTACHDATA(rstr_pdoffset2gcck)[]     = "pdoffsetcck";
static const char BCMATTACHDATA(rstr_pdoffset20in40m5gb0)[] = "pdoffset20in40m5gb0";
static const char BCMATTACHDATA(rstr_pdoffset20in40m5gb1)[] = "pdoffset20in40m5gb1";
static const char BCMATTACHDATA(rstr_pdoffset20in40m5gb2)[] = "pdoffset20in40m5gb2";
static const char BCMATTACHDATA(rstr_pdoffset20in40m5gb3)[] = "pdoffset20in40m5gb3";
static const char BCMATTACHDATA(rstr_pdoffset20in40m5gb4)[] = "pdoffset20in40m5gb4";
static const char BCMATTACHDATA(rstr_pdoffset20in80m5gb0)[] = "pdoffset20in80m5gb0";
static const char BCMATTACHDATA(rstr_pdoffset20in80m5gb1)[] = "pdoffset20in80m5gb1";
static const char BCMATTACHDATA(rstr_pdoffset20in80m5gb2)[] = "pdoffset20in80m5gb2";
static const char BCMATTACHDATA(rstr_pdoffset20in80m5gb3)[] = "pdoffset20in80m5gb3";
static const char BCMATTACHDATA(rstr_pdoffset20in80m5gb4)[] = "pdoffset20in80m5gb4";
static const char BCMATTACHDATA(rstr_pdoffset40in80m5gb0)[] = "pdoffset40in80m5gb0";
static const char BCMATTACHDATA(rstr_pdoffset40in80m5gb1)[] = "pdoffset40in80m5gb1";
static const char BCMATTACHDATA(rstr_pdoffset40in80m5gb2)[] = "pdoffset40in80m5gb2";
static const char BCMATTACHDATA(rstr_pdoffset40in80m5gb3)[] = "pdoffset40in80m5gb3";
static const char BCMATTACHDATA(rstr_pdoffset40in80m5gb4)[] = "pdoffset40in80m5gb4";
#endif /* SROM12 */

#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
static void BCMATTACHFN(wlc_phy_txpwr_srom11_read_offset)(
	phy_info_t *pi, const char* nvname, int8 *offset, uint32 range);

static void
BCMATTACHFN(wlc_phy_txpwr_srom11_read_offset)(phy_info_t *pi, const char* nvname,
	int8 *offset, uint32 range)
{
	uint8 index;
	/* Proceed to the different parameters reading. */
	for (index = 0; index < range; index++) {
		offset[index] =
			(int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi, nvname, index, 0);
		PHY_TXPWR(("id=%d Offset=%d \n", index, offset[index]));
	}
}
#endif  /* POWPERCHANNL2G || POWPERCHANNL5G || POWPERBAND5G */

#ifdef POWPERCHANNL5G
const char* BCMATTACHDATA(nv_pwrperch5g_names)[BW_MAX][3] = {
	{rstr_PowOffs5G20MTNA0, rstr_PowOffs5G20MTNA1, rstr_PowOffs5G20MTNA2},
	{rstr_PowOffs5G40MTNA0, rstr_PowOffs5G40MTNA1, rstr_PowOffs5G40MTNA2},
	{rstr_PowOffs5G80MTNA0, rstr_PowOffs5G80MTNA1, rstr_PowOffs5G80MTNA2}
};

static void BCMATTACHFN(wlc_phy_txpwr_srom11_read_5g_ch_offset)(
	phy_info_t *pi, uint core);

static void
BCMATTACHFN(wlc_phy_txpwr_srom11_read_5g_ch_offset)(phy_info_t *pi, uint core)
{
	uint32 bw;
	uint range;
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;

	for (bw = BW_20M; bw < BW_MAX; bw++) {
		switch (bw) {
		case BW_20M:
			range = EDGE_CH20MHz_NUM_5G;
			break;
		case BW_40M:
			range = EDGE_CH40MHz_NUM_5G;
			break;
		case BW_80M:
			range = EDGE_CH80MHz_NUM_5G;
			break;
		}

		PHY_TXPWR(("BE Core=%d BW=%d\n", core, bw));
		wlc_phy_txpwr_srom11_read_offset(pi, nv_pwrperch5g_names[bw][core],
			pwrdet->PwrOffsets5GNormTemp[bw][core], range);
	}
}
#endif /* POWPERCHANNL5G */

#ifdef POWPERBAND5G
const char* BCMATTACHDATA(nv_pwrperband5g_names)[BW_MAX][3] = {
	{rstr_SbPowOffs5G20MTNA0, rstr_SbPowOffs5G20MTNA1, rstr_SbPowOffs5G20MTNA2},
	{rstr_SbPowOffs5G40MTNA0, rstr_SbPowOffs5G40MTNA1, rstr_SbPowOffs5G40MTNA2},
	{rstr_SbPowOffs5G80MTNA0, rstr_SbPowOffs5G80MTNA1, rstr_SbPowOffs5G80MTNA2}
};

static void BCMATTACHFN(wlc_phy_txpwr_srom11_read_5g_band_offset)(
	phy_info_t *pi, uint core);

static void
BCMATTACHFN(wlc_phy_txpwr_srom11_read_5g_band_offset)(phy_info_t *pi, uint core)
{
	uint32 bw;
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;

	for (bw = BW_20M; bw < BW_MAX; bw++) {
		PHY_TXPWR(("SB Core=%d BW=%d\n", core, bw));
		wlc_phy_txpwr_srom11_read_offset(pi, nv_pwrperband5g_names[bw][core],
			pwrdet->SbPwrOffsets5GNormTemp[bw][core], CH_5G_4BAND);
	}
}
#endif /* POWPERCHANNL5G */

#ifdef POWPERCHANNL2G
const char* BCMATTACHDATA(nv_pwrperch2g_names)[PWR_PER_CH_MAX_TEMP][3] = {
	{rstr_PowOffs2GTNA0, rstr_PowOffs2GTNA1, rstr_PowOffs2GTNA2},	/* Normal temp. */
	{rstr_PowOffs2GTLA0, rstr_PowOffs2GTLA1, rstr_PowOffs2GTLA2},	/* Low temp. */
	{rstr_PowOffs2GTHA0, rstr_PowOffs2GTHA1, rstr_PowOffs2GTHA2}	/* High temp. */
};

static void BCMATTACHFN(wlc_phy_txpwr_srom11_read_2g_ch_offset)(
	phy_info_t *pi, uint core);

static void
BCMATTACHFN(wlc_phy_txpwr_srom11_read_2g_ch_offset)(phy_info_t *pi, uint core)
{
	uint32 temp;
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;

	for (temp = PWR_PER_CH_NORM_TEMP; temp < PWR_PER_CH_MAX_TEMP; temp++) {
		PHY_TXPWR(("Core=%d temp=%d\n", core, temp));
		wlc_phy_txpwr_srom11_read_offset(pi, nv_pwrperch2g_names[temp][core],
			pwrdet->PwrOffsets2GTemp[temp][core], CH20MHz_NUM_2G);
	}
}
#endif /* POWPERCHANNL2G */

bool
BCMATTACHFN(wlc_phy_txpwr_srom11_read)(phy_info_t *pi)
{
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 b, maxval;
#ifdef BAND5G
	uint8 b_offset, b_triple_offset;
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
	uint8 core;
#endif /* POWPERCHANNL5G || POWPERBAND5G */
#endif /* BAND5G */

	ASSERT(pi->sh->sromrev >= 11);

	if (!ISACPHY(pi)) {
		return FALSE;
	}
#ifdef BAND5G
	maxval = CH_2G_GROUP + CH_5G_4BAND;
#else  /* BAND5G */
	maxval = CH_2G_GROUP;
#endif  /* BAND5G */

	/* read pwrdet params for each band/subband */
	for (b = 0; b < maxval; b++) {
		switch (b) {
			case WL_CHAN_FREQ_RANGE_2G: /* 0 */
			/* 2G band */
				pwrdet->max_pwr[0][b]	=
					(int8)PHY_GETINTVAR(pi, rstr_maxp2ga0);
				pwrdet->pwrdet_a1[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 0);
				pwrdet->pwrdet_b0[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 1);
				pwrdet->pwrdet_b1[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 2);
				pwrdet->tssifloor[0][b] =
					(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
							pi, rstr_tssifloor2g, 0, 0);

#ifdef POWPERCHANNL2G

				/* power per channel and Temp */
				pwrdet->max_pwr_SROM2G[0] = (int8)PHY_GETINTVAR(pi, rstr_maxp2ga0);

				PHY_TXPWR(("wl%d: %s: Loading max = %d \n",
					pi->sh->unit, __FUNCTION__,
					pwrdet->max_pwr_SROM2G[0]));

				wlc_phy_txpwr_srom11_read_2g_ch_offset(pi, 0);

				pwrdet->Low2NormTemp =
					(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
						pi, rstr_PowOffsTempRange, 0, 0xff);
				pwrdet->High2NormTemp =
					(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
						pi, rstr_PowOffsTempRange, 1, 0xff);

				PHY_TXPWR((" Low Temp Limit=%d  High Temp Limit=%d \n",
					pwrdet->Low2NormTemp,
					pwrdet->High2NormTemp));
#endif  /* POWPERCHANNL2G */
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
					pwrdet->max_pwr[1][b]	=
						(int8)PHY_GETINTVAR(pi, rstr_maxp2ga1);
					pwrdet->tssifloor[1][b] =
						(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
						pi, rstr_tssifloor2ga1, 0,
						pwrdet->tssifloor[0][b]);

#ifdef POWPERCHANNL2G
					pwrdet->max_pwr_SROM2G[1] =
						(int8)PHY_GETINTVAR(pi, rstr_maxp2ga1);
					wlc_phy_txpwr_srom11_read_2g_ch_offset(pi, 1);

#endif  /* POWPERCHANNL2G */
				}
				if ((PHYCORENUM(pi->pubpi.phy_corenum) > 1) ||
					(pi->u.pi_acphy->srom_tworangetssi2g &&
					ACMAJORREV_1(pi->pubpi.phy_rev))) {
					pwrdet->pwrdet_a1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 0);
					pwrdet->pwrdet_b0[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 1);
					pwrdet->pwrdet_b1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 2);
				}
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 2 ||
					(pi->u.pi_acphy->srom_tworangetssi2g &&
					ACMAJORREV_2(pi->pubpi.phy_rev))) {
					pwrdet->pwrdet_a1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 0);
					pwrdet->pwrdet_b0[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 1);
					pwrdet->pwrdet_b1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 2);
				}
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
					pwrdet->max_pwr[2][b]	=
						(int8)PHY_GETINTVAR(pi, rstr_maxp2ga2);
#ifdef POWPERCHANNL2G
					pwrdet->max_pwr_SROM2G[2] =
						(int8)PHY_GETINTVAR(pi, rstr_maxp2ga2);
					wlc_phy_txpwr_srom11_read_2g_ch_offset(pi, 2);
#endif  /* POWPERCHANNL2G */
				}
#ifdef POWPERCHANNL2G
				/* input range limit for power per channel */
				wlc_phy_tx_target_pwr_per_channel_limit_acphy(pi);
#endif  /* POWPERCHANNL2G */
				if (pi->u.pi_acphy->srom_tworangetssi2g &&
					ACMAJORREV_2(pi->pubpi.phy_rev)) {
					pwrdet->pwrdet_a1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga3, 0);
					pwrdet->pwrdet_b0[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga3, 1);
					pwrdet->pwrdet_b1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga3, 2);
				}

				if ((pi->u.pi_acphy->srom.tssi_div_war) &&
					(ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi))) {
					pwrdet->pwrdet_a1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 0);
					pwrdet->pwrdet_b0[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 1);
					pwrdet->pwrdet_b1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 2);
					pwrdet->pwrdet_a1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gbw40a0, 0);
					pwrdet->pwrdet_b0[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gbw40a0, 1);
					pwrdet->pwrdet_b1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gbw40a0, 2);

				}
				if ((pi->u.pi_acphy->srom.tssi_div_war) &&
					(ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi))) {
					pwrdet->pwrdet_a1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 0);
					pwrdet->pwrdet_b0[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 1);
					pwrdet->pwrdet_b1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka0, 2);
					pwrdet->pwrdet_a1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka1, 0);
					pwrdet->pwrdet_b0[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka1, 1);
					pwrdet->pwrdet_b1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2gccka1, 2);
				}
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5G_BAND0: /* 1 */
				/* intentional fall through case */
			case WL_CHAN_FREQ_RANGE_5G_BAND1: /* 2 */
				/* intentional fall through case */
			case WL_CHAN_FREQ_RANGE_5G_BAND2: /* 3 */
				/* intentional fall through case */
			case WL_CHAN_FREQ_RANGE_5G_BAND3: /* 4 */
				b_offset = b - CH_2G_GROUP;
				b_triple_offset = 3 * b_offset;

				/* CORE 0 */
				pwrdet->max_pwr[0][b]	=
					(int8)PHY_GETINTVAR_ARRAY(pi, rstr_maxp5ga0, b_offset);
				pwrdet->tssifloor[0][b] =
					(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
						pi, rstr_tssifloor5g, b_offset, 0);

#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
				pwrdet->max_pwr_SROM5G[0][b_offset] =
						pwrdet->max_pwr[0][b];
#endif /* POWPERCHANNL5G || POWPERBAND5G */

				pwrdet->pwrdet_a1[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi,
					rstr_pa5ga0, b_triple_offset + 0);
				pwrdet->pwrdet_b0[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi,
					rstr_pa5ga0, b_triple_offset + 1);
				pwrdet->pwrdet_b1[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi,
					rstr_pa5ga0, b_triple_offset + 2);
				pwrdet->tssifloor[0][b] =
					(int16)PHY_GETINTVAR_ARRAY(pi,
					rstr_tssifloor5g, b_offset);

				/* CORE 1 no reuse */
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
					pwrdet->max_pwr[1][b]	=
						(int8)PHY_GETINTVAR_ARRAY(pi,
						rstr_maxp5ga1, b_offset);
					pwrdet->tssifloor[1][b] =
						(int16)PHY_GETINTVAR_ARRAY_DEFAULT(
						pi, rstr_tssifloor5ga1, b_offset,
						pwrdet->tssifloor[0][b]);

#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
					pwrdet->max_pwr_SROM5G[1][b_offset] =
						pwrdet->max_pwr[1][b];
#endif /* POWPERCHANNL5G || POWPERBAND5G */
				}
				/* CORE 1 or reuse */
				if ((PHYCORENUM(pi->pubpi.phy_corenum) > 1) ||
					(pi->u.pi_acphy->srom_tworangetssi5g &&
					ACMAJORREV_1(pi->pubpi.phy_rev)))  {
					pwrdet->pwrdet_a1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga1, b_triple_offset + 0);
					pwrdet->pwrdet_b0[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga1, b_triple_offset + 1);
					pwrdet->pwrdet_b1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga1, b_triple_offset + 2);
				}
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
					pwrdet->max_pwr[2][b]	=
						(int8)PHY_GETINTVAR_ARRAY(pi,
						rstr_maxp5ga2, b_offset);
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
					pwrdet->max_pwr_SROM5G[2][b_offset] =
						pwrdet->max_pwr[2][b];
#endif /* POWPERCHANNL5G || POWPERBAND5G */
				}
				/* CORE 2 or reuse */
				if (PHYCORENUM(pi->pubpi.phy_corenum) > 2 ||
					(pi->u.pi_acphy->srom_tworangetssi5g &&
					ACMAJORREV_2(pi->pubpi.phy_rev))) {
					pwrdet->pwrdet_a1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga2, b_triple_offset + 0);
					pwrdet->pwrdet_b0[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga2, b_triple_offset + 1);
					pwrdet->pwrdet_b1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga2, b_triple_offset + 2);
				}
				/* CORE 3 reuse only */
				if (pi->u.pi_acphy->srom_tworangetssi5g &&
					ACMAJORREV_2(pi->pubpi.phy_rev)) {
					pwrdet->pwrdet_a1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga3, b_triple_offset + 0);
					pwrdet->pwrdet_b0[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga3, b_triple_offset + 1);
					pwrdet->pwrdet_b1[3][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5ga3, b_triple_offset + 2);
				}
				/* Partial BW */
				if ((pi->u.pi_acphy->srom.tssi_div_war) &&
					(ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi))) {
					pwrdet->pwrdet_a1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw40a0, b_triple_offset + 0);
					pwrdet->pwrdet_b0[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw40a0, b_triple_offset + 1);
					pwrdet->pwrdet_b1[1][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw40a0, b_triple_offset + 2);
					pwrdet->pwrdet_a1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw80a0, b_triple_offset + 0);
					pwrdet->pwrdet_b0[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw80a0, b_triple_offset + 1);
					pwrdet->pwrdet_b1[2][b] =
						(int16)PHY_GETINTVAR_ARRAY(pi,
						rstr_pa5gbw80a0, b_triple_offset + 2);
				}
				if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
				    pi->u.pi_acphy->srom.tssi_div_war) {
					pwrdet->pwrdet_a1[2][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a0, b_triple_offset + 0);
					pwrdet->pwrdet_b0[2][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a0, b_triple_offset + 1);
					pwrdet->pwrdet_b1[2][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a0, b_triple_offset + 2);
					pwrdet->pwrdet_a1[3][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a1, b_triple_offset + 0);
					pwrdet->pwrdet_b0[3][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a1, b_triple_offset + 1);
					pwrdet->pwrdet_b1[3][b] =
					    (int16)PHY_GETINTVAR_ARRAY(pi,
					    rstr_pa5gbw4080a1, b_triple_offset + 2);
				}
				break;
#endif /* BAND5G */
			default:
				break;
		}
	}

#ifdef BAND5G
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
	FOREACH_CORE(pi, core) {
	/* range check since functions below only support cores 0, 1, 2 */
		if (core <= 2) {
#ifdef POWPERCHANNL5G
			/* power per channel for edge 5 GHz channels */
			wlc_phy_txpwr_srom11_read_5g_ch_offset(pi, core);
#endif  /* POWPERCHANNL5G */
#ifdef POWPERBAND5G
			/* power per sub-bands of 5 GHz */
			wlc_phy_txpwr_srom11_read_5g_band_offset(pi, core);
#endif  /* POWPERBAND5G */
		}
	}
#endif /* POWPERCHANNL5G || POWPERBAND5G */
#endif /* BAND5G */

#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
	/* input range limit for power per channel */
	wlc_phy_tx_target_pwr_per_channel_limit_acphy(pi);
#endif  /* POWPERCHANNL2G || POWPERCHANNL5G || POWPERBAND5G */

	wlc_phy_txpwr_srom11_read_ppr(pi);

	/* read out power detect offset values */
	pwrdet->pdoffset2g40_flag = (uint8)PHY_GETINTVAR(pi, rstr_pdoffset2g40mvalid);
	pwrdet->pdoffset40[0] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset40ma0);
	pwrdet->pdoffset80[0] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset80ma0);
	pwrdet->pdoffset2g40[0] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffset2g40ma0);
	pwrdet->pdoffsetcck[0] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffsetcckma0);
	pi->cckpwroffset[0] = (int8)PHY_GETINTVAR(pi, rstr_cckpwroffset0);
	pi->sh->cckPwrIdxCorr = (int8) PHY_GETINTVAR(pi, rstr_cckPwrIdxCorr);

	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
		pwrdet->pdoffset40[1] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset40ma1);
		pwrdet->pdoffset80[1] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset80ma1);
		pwrdet->pdoffset2g40[1] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffset2g40ma1);
		pwrdet->pdoffsetcck[1] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffsetcckma1);
		pi->cckpwroffset[1] = (int8)PHY_GETINTVAR(pi, rstr_cckpwroffset1);
	}
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
		pwrdet->pdoffset40[2] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset40ma2);
		pwrdet->pdoffset80[2] = (uint16)PHY_GETINTVAR(pi, rstr_pdoffset80ma2);
		pwrdet->pdoffset2g40[2] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffset2g40ma2);
		pwrdet->pdoffsetcck[2] = (uint8)PHY_GETINTVAR(pi, rstr_pdoffsetcckma2);
		pi->cckpwroffset[2] = (int8)PHY_GETINTVAR(pi, rstr_cckpwroffset2);
	}

	pi->phy_tempsense_offset = (int8)PHY_GETINTVAR(pi, rstr_tempoffset);
	if (pi->phy_tempsense_offset == -1) {
		pi->phy_tempsense_offset = 0;
	} else if (pi->phy_tempsense_offset != 0) {
		if (pi->phy_tempsense_offset >
			(ACPHY_SROM_TEMPSHIFT + ACPHY_SROM_MAXTEMPOFFSET)) {
			pi->phy_tempsense_offset = ACPHY_SROM_MAXTEMPOFFSET;
		} else if (pi->phy_tempsense_offset < (ACPHY_SROM_TEMPSHIFT +
			ACPHY_SROM_MINTEMPOFFSET)) {
			pi->phy_tempsense_offset = ACPHY_SROM_MINTEMPOFFSET;
		} else {
			pi->phy_tempsense_offset -= ACPHY_SROM_TEMPSHIFT;
		}
	}

	/* For ACPHY, if the SROM contains a bogus value, then tempdelta
	 * will default to ACPHY_DEFAULT_CAL_TEMPDELTA. If the SROM contains
	 * a valid value, then the default will be overwritten with this value
	 */
	wlc_phy_read_tempdelta_settings(pi, ACPHY_CAL_MAXTEMPDELTA);

	return TRUE;
}

#ifdef SROM12
bool
BCMATTACHFN(wlc_phy_txpwr_srom12_read)(phy_info_t *pi)
{
	srom12_pwrdet_t *pwrdet = pi->pwrdet12_ac;
	uint8 b, i = 0, j = 0, maxval = 0, core;
	uint16 temp1, mask, t2;

	ASSERT(pi->sh->sromrev >= 12);

	if (!ISACPHY(pi)) {
		return FALSE;
	}

	maxval = ((2 * CH_2G_GROUP) + (3 * CH_5G_5BAND));

	/* read pwrdet params for each band/subband/bandwidth */
	for (b = 0; b < maxval; b++) {
		/* Adjust index to get 40M array to start at 0 */
		if (b > 5)
			i = (b - (CH_2G_GROUP + CH_5G_5BAND));

		/* Adjust index to get 80M array to start at 0 */
		if (b > 11)
			j = (b - (2 * (CH_2G_GROUP + CH_5G_5BAND)));

		switch (b) {
		case WL_CHAN_FREQ_RANGE_2G: /* 0 */
			/* 2G band */
			pwrdet->max_pwr[0][b]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 0);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 1);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 2);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga0, 3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 0);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 1);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 2);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga1, 3);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 0);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 1);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 2);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2ga2, 3);
			}
			break;
#ifdef BAND5G
		case WL_CHAN_FREQ_RANGE_5G_BAND0: /* 1 */
			pwrdet->max_pwr[0][b] =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 0);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 1);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 2);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 0);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 1);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 2);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 3);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 0);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 1);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 2);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 3);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND1: /* 2 */
			pwrdet->max_pwr[0][b]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 4);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 5);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 6);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 7);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 4);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 5);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 6);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 7);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 4);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 5);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 6);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 7);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND2: /* 3 */
			pwrdet->max_pwr[0][b]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 8);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 9);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 10);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 11);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 8);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 9);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 10);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 11);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 8);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 9);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 10);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 11);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND3: /* 4 */
			pwrdet->max_pwr[0][b]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 12);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 13);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 14);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 15);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 12);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 13);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 14);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 15);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 12);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 13);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 14);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 15);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND4: /* 5 */
			pwrdet->max_pwr[0][b]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a0);
			pwrdet->pwrdet_a[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 16);
			pwrdet->pwrdet_b[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 17);
			pwrdet->pwrdet_c[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 18);
			pwrdet->pwrdet_d[0][b] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga0, 19);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a1);
				pwrdet->pwrdet_a[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 16);
				pwrdet->pwrdet_b[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 17);
				pwrdet->pwrdet_c[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 18);
				pwrdet->pwrdet_d[1][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga1, 19);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][b]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a2);
				pwrdet->pwrdet_a[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 16);
				pwrdet->pwrdet_b[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 17);
				pwrdet->pwrdet_c[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 18);
				pwrdet->pwrdet_d[2][b] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5ga2, 19);
			}
			break;
#endif /* BAND5G */
		case WL_CHAN_FREQ_RANGE_2G_40: /* 6 */
			/* 2G band */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a0, 0);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a0, 1);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a0, 2);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a0, 3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a1, 0);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a1, 1);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a1, 2);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a1, 3);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp2gb0a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a2, 0);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a2, 1);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a2, 2);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa2g40a2, 3);
			}
			break;
#ifdef BAND5G
		case WL_CHAN_FREQ_RANGE_5G_BAND0_40: /* 7 */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 0);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 1);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 2);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 0);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 1);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 2);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 3);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb0a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 0);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 1);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 2);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 3);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND1_40: /* 8 */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 4);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 5);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 6);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 7);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 4);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 5);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 6);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 7);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb1a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 4);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 5);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 6);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 7);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND2_40: /* 9 */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 8);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 9);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 10);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 11);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 8);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 9);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 10);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 11);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb2a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 8);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 9);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 10);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 11);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND3_40: /* 10 */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 12);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 13);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 14);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 15);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 12);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 13);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 14);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 15);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb3a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 12);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 13);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 14);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 15);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND4_40: /* 11 */
			pwrdet->max_pwr[0][i]  =
			        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a0);
			pwrdet->pwrdet_a_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 16);
			pwrdet->pwrdet_b_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 17);
			pwrdet->pwrdet_c_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 18);
			pwrdet->pwrdet_d_40[0][i] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a0, 19);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[1][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a1);
				pwrdet->pwrdet_a_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 16);
				pwrdet->pwrdet_b_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 17);
				pwrdet->pwrdet_c_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 18);
				pwrdet->pwrdet_d_40[1][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a1, 19);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[2][i]  =
				        (int8)PHY_GETINTVAR(pi, rstr_maxp5gb4a2);
				pwrdet->pwrdet_a_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 16);
				pwrdet->pwrdet_b_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 17);
				pwrdet->pwrdet_c_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 18);
				pwrdet->pwrdet_d_40[2][i] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g40a2, 19);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND0_80: /* 12 */
			pwrdet->pwrdet_a_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 0);
			pwrdet->pwrdet_b_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 1);
			pwrdet->pwrdet_c_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 2);
			pwrdet->pwrdet_d_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->pwrdet_a_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 0);
				pwrdet->pwrdet_b_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 1);
				pwrdet->pwrdet_c_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 2);
				pwrdet->pwrdet_d_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 3);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->pwrdet_a_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 0);
				pwrdet->pwrdet_b_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 1);
				pwrdet->pwrdet_c_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 2);
				pwrdet->pwrdet_d_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 3);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND1_80: /* 13 */
			pwrdet->pwrdet_a_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 4);
			pwrdet->pwrdet_b_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 5);
			pwrdet->pwrdet_c_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 6);
			pwrdet->pwrdet_d_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 7);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->pwrdet_a_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 4);
				pwrdet->pwrdet_b_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 5);
				pwrdet->pwrdet_c_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 6);
				pwrdet->pwrdet_d_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 7);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->pwrdet_a_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 4);
				pwrdet->pwrdet_b_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 5);
				pwrdet->pwrdet_c_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 6);
				pwrdet->pwrdet_d_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 7);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND2_80: /* 14 */
			pwrdet->pwrdet_a_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 8);
			pwrdet->pwrdet_b_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 9);
			pwrdet->pwrdet_c_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 10);
			pwrdet->pwrdet_d_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 11);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->pwrdet_a_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 8);
				pwrdet->pwrdet_b_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 9);
				pwrdet->pwrdet_c_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 10);
				pwrdet->pwrdet_d_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 11);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->pwrdet_a_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 8);
				pwrdet->pwrdet_b_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 9);
				pwrdet->pwrdet_c_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 10);
				pwrdet->pwrdet_d_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 11);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND3_80: /* 15 */
			pwrdet->pwrdet_a_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 12);
			pwrdet->pwrdet_b_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 13);
			pwrdet->pwrdet_c_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 14);
			pwrdet->pwrdet_d_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 15);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->pwrdet_a_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 12);
				pwrdet->pwrdet_b_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 13);
				pwrdet->pwrdet_c_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 14);
				pwrdet->pwrdet_d_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 15);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->pwrdet_a_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 12);
				pwrdet->pwrdet_b_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 13);
				pwrdet->pwrdet_c_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 14);
				pwrdet->pwrdet_d_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 15);
			}
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND4_80: /* 16 */
			pwrdet->pwrdet_a_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 16);
			pwrdet->pwrdet_b_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 17);
			pwrdet->pwrdet_c_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 18);
			pwrdet->pwrdet_d_80[0][j] =
			        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a0, 19);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->pwrdet_a_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 16);
				pwrdet->pwrdet_b_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 17);
				pwrdet->pwrdet_c_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 18);
				pwrdet->pwrdet_d_80[1][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a1, 19);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->pwrdet_a_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 16);
				pwrdet->pwrdet_b_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 17);
				pwrdet->pwrdet_c_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 18);
				pwrdet->pwrdet_d_80[2][j] =
				        (int16)PHY_GETINTVAR_ARRAY(pi, rstr_pa5g80a2, 19);
			}
			break;
#endif /* BAND5G */
		}
	}
	wlc_phy_txpwr_srom12_read_ppr(pi);

	/* read out power detect offset values */
	FOREACH_CORE(pi, core) {
	  if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
	    temp1 = 5*core;
	    mask = 0x1f;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset2gcck) >> temp1) & mask;
	    pwrdet->pdoffsetcck[core] = (uint8)t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in40m5gb0) >> temp1) & mask;
	    pwrdet->pdoffset20in40[core][0] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in40m5gb1) >> temp1) & mask;
	    pwrdet->pdoffset20in40[core][1] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in40m5gb2) >> temp1) & mask;
	    pwrdet->pdoffset20in40[core][2] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in40m5gb3) >> temp1) & mask;
	    pwrdet->pdoffset20in40[core][3] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in40m5gb4) >> temp1) & mask;
	    pwrdet->pdoffset20in40[core][4] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in80m5gb0) >> temp1) & mask;
	    pwrdet->pdoffset20in80[core][0] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in80m5gb1) >> temp1) & mask;
	    pwrdet->pdoffset20in80[core][1] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in80m5gb2) >> temp1) & mask;
	    pwrdet->pdoffset20in80[core][2] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in80m5gb3) >> temp1) & mask;
	    pwrdet->pdoffset20in80[core][3] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset20in80m5gb4) >> temp1) & mask;
	    pwrdet->pdoffset20in80[core][4] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset40in80m5gb0) >> temp1) & mask;
	    pwrdet->pdoffset40in80[core][0] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset40in80m5gb1) >> temp1) & mask;
	    pwrdet->pdoffset40in80[core][1] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset40in80m5gb2) >> temp1) & mask;
	    pwrdet->pdoffset40in80[core][2] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset40in80m5gb3) >> temp1) & mask;
	    pwrdet->pdoffset40in80[core][3] = t2;
	    t2 = ((uint16)PHY_GETINTVAR(pi, rstr_pdoffset40in80m5gb4) >> temp1) & mask;
	    pwrdet->pdoffset40in80[core][4] = t2;
	  }
	}

	pi->phy_tempsense_offset = (int8)PHY_GETINTVAR(pi, rstr_tempoffset);
	if (pi->phy_tempsense_offset == -1) {
		pi->phy_tempsense_offset = 0;
	} else if (pi->phy_tempsense_offset != 0) {
		if (pi->phy_tempsense_offset >
		    (ACPHY_SROM_TEMPSHIFT + ACPHY_SROM_MAXTEMPOFFSET)) {
			pi->phy_tempsense_offset = ACPHY_SROM_MAXTEMPOFFSET;
		} else if (pi->phy_tempsense_offset < (ACPHY_SROM_TEMPSHIFT +
		                                       ACPHY_SROM_MINTEMPOFFSET)) {
			pi->phy_tempsense_offset = ACPHY_SROM_MINTEMPOFFSET;
		} else {
			pi->phy_tempsense_offset -= ACPHY_SROM_TEMPSHIFT;
		}
	}

	/* For ACPHY, if the SROM contains a bogus value, then tempdelta
	 * will default to ACPHY_DEFAULT_CAL_TEMPDELTA. If the SROM contains
	 * a valid value, then the default will be overwritten with this value
	 */
	wlc_phy_read_tempdelta_settings(pi, ACPHY_CAL_MAXTEMPDELTA);

	return TRUE;
}
#endif /* SROM12 */

bool
BCMATTACHFN(wlc_phy_txpwr_srom8_read)(phy_info_t *pi)
{

	/* read in antenna-related config */
	pi->antswitch = (uint8) PHY_GETINTVAR(pi, rstr_antswitch);
	pi->aa2g = (uint8) PHY_GETINTVAR(pi, rstr_aa2g);

#ifdef BAND5G
	pi->aa5g = (uint8) PHY_GETINTVAR(pi, rstr_aa5g);
#endif /* BAND5G */

	/* read in FEM stuff */
	pi->fem2g.tssipos = (uint8)PHY_GETINTVAR(pi, rstr_tssipos2g);
	pi->fem2g.extpagain = (uint8)PHY_GETINTVAR(pi, rstr_extpagain2g);
	pi->fem2g.pdetrange = (uint8)PHY_GETINTVAR(pi, rstr_pdetrange2g);
	pi->fem2g.triso = (uint8)PHY_GETINTVAR(pi, rstr_triso2g);
	pi->fem2g.antswctrllut = (uint8)PHY_GETINTVAR(pi, rstr_antswctl2g);

#ifdef BAND5G
	pi->fem5g.tssipos = (uint8)PHY_GETINTVAR(pi, rstr_tssipos5g);
	pi->fem5g.extpagain = (uint8)PHY_GETINTVAR(pi, rstr_extpagain5g);
	pi->fem5g.pdetrange = (uint8)PHY_GETINTVAR(pi, rstr_pdetrange5g);
	pi->fem5g.triso = (uint8)PHY_GETINTVAR(pi, rstr_triso5g);

	/* If antswctl5g entry exists, use it.
	 * Fallback to antswctl2g value if 5g entry does not exist.
	 * Previous code used 2g value only, thus...
	 * this is a WAR for any legacy NVRAMs that only had a 2g entry.
	 */
	pi->fem5g.antswctrllut = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_antswctl5g,
		PHY_GETINTVAR(pi, rstr_antswctl2g));
#endif /* BAND5G */

	if (PHY_GETVAR(pi, rstr_elna2g)) {
		/* extlnagain2g entry exists, so use it. */
		if (ISNPHY(pi)) {
			pi->u.pi_nphy->elna2g = (uint8)PHY_GETINTVAR(pi, rstr_elna2g);
		}
	}
#ifdef BAND5G
	if (PHY_GETVAR(pi, rstr_elna5g)) {
		/* extlnagain5g entry exists, so use it. */
		if (ISNPHY(pi)) {
			pi->u.pi_nphy->elna5g = (uint8)PHY_GETINTVAR(pi, rstr_elna5g);
		}
	}
#endif /* BAND5G */

	/* srom_fem2/5g.extpagain changed */
	wlc_phy_txpower_ipa_upd(pi);

	pi->phy_tempsense_offset = (int8)PHY_GETINTVAR(pi, rstr_tempoffset);
	if (pi->phy_tempsense_offset != 0) {
		if (pi->phy_tempsense_offset >
			(NPHY_SROM_TEMPSHIFT + NPHY_SROM_MAXTEMPOFFSET)) {
			pi->phy_tempsense_offset = NPHY_SROM_MAXTEMPOFFSET;
		} else if (pi->phy_tempsense_offset < (NPHY_SROM_TEMPSHIFT +
			NPHY_SROM_MINTEMPOFFSET)) {
			pi->phy_tempsense_offset = NPHY_SROM_MINTEMPOFFSET;
		} else {
			pi->phy_tempsense_offset -= NPHY_SROM_TEMPSHIFT;
		}
	}

	wlc_phy_read_tempdelta_settings(pi, NPHY_CAL_MAXTEMPDELTA);

	/* Power per Rate */
	wlc_phy_txpwr_srom8_read_ppr(pi);

	return TRUE;

}

static const char BCMATTACHDATA(rstr_maxp5ga3)[] = "maxp5ga3";
static const char BCMATTACHDATA(rstr_maxp5gla3)[] = "maxp5gla3";
static const char BCMATTACHDATA(rstr_pa5gw0a3)[] = "pa5gw0a3";
static const char BCMATTACHDATA(rstr_pa5glw0a3)[] = "pa5glw0a3";
static const char BCMATTACHDATA(rstr_pa5gw1a3)[] = "pa5gw1a3";
static const char BCMATTACHDATA(rstr_pa5glw1a3)[] = "pa5glw1a3";
static const char BCMATTACHDATA(rstr_pa5gw2a3)[] = "pa5gw2a3";
static const char BCMATTACHDATA(rstr_pa5glw2a3)[] = "pa5glw2a3";
static const char BCMATTACHDATA(rstr_maxp5gha3)[] = "maxp5gha3";
static const char BCMATTACHDATA(rstr_pa5ghw0a3)[] = "pa5ghw0a3";
static const char BCMATTACHDATA(rstr_pa5ghw1a3)[] = "pa5ghw1a3";
static const char BCMATTACHDATA(rstr_pa5ghw2a3)[] = "pa5ghw2a3";

/* */
bool
BCMATTACHFN(wlc_phy_txpwr_srom9_read)(phy_info_t *pi)
{
	srom_pwrdet_t	*pwrdet  = &pi->pwrdet;
#ifdef BAND5G
	uint32 offset_40MHz[PHY_MAX_CORES] = {0};
#endif /* BAND5G */
	int b;

	if (PHY_GETVAR(pi, rstr_elna2g)) {
		/* extlnagain2g entry exists, so use it. */
		if (ISNPHY(pi)) {
			pi->u.pi_nphy->elna2g = (uint8)PHY_GETINTVAR(pi, rstr_elna2g);
		}
	}
#ifdef BAND5G
	if (PHY_GETVAR(pi, rstr_elna5g)) {
		/* extlnagain5g entry exists, so use it. */
		if (ISNPHY(pi)) {
			pi->u.pi_nphy->elna5g = (uint8)PHY_GETINTVAR(pi, rstr_elna5g);
		}
	}
#endif /* BAND5G */

	/* read in antenna-related config */
	pi->antswitch = (uint8) PHY_GETINTVAR(pi, rstr_antswitch);
	pi->aa2g = (uint8) PHY_GETINTVAR(pi, rstr_aa2g);
#ifdef BAND5G
	pi->aa5g = (uint8) PHY_GETINTVAR(pi, rstr_aa5g);
#endif /* BAND5G */

	/* read in FEM stuff */
	pi->fem2g.tssipos = (uint8)PHY_GETINTVAR(pi, rstr_tssipos2g);
	pi->fem2g.extpagain = (uint8)PHY_GETINTVAR(pi, rstr_extpagain2g);
	pi->fem2g.pdetrange = (uint8)PHY_GETINTVAR(pi, rstr_pdetrange2g);
	pi->fem2g.triso = (uint8)PHY_GETINTVAR(pi, rstr_triso2g);
	pi->fem2g.antswctrllut = (uint8)PHY_GETINTVAR(pi, rstr_antswctl2g);

#ifdef BAND5G
	pi->fem5g.tssipos = (uint8)PHY_GETINTVAR(pi, rstr_tssipos5g);
	pi->fem5g.extpagain = (uint8)PHY_GETINTVAR(pi, rstr_extpagain5g);
	pi->fem5g.pdetrange = (uint8)PHY_GETINTVAR(pi, rstr_pdetrange5g);
	pi->fem5g.triso = (uint8)PHY_GETINTVAR(pi, rstr_triso5g);
	pi->fem5g.antswctrllut = (uint8)PHY_GETINTVAR(pi, rstr_antswctl5g);
#endif /* BAND5G */

	/* srom_fem2/5g.extpagain changed */
	if (ISNPHY(pi))
		wlc_phy_txpower_ipa_upd(pi);

#ifdef BAND5G
	offset_40MHz[PHY_CORE_0] = PHY_GETINTVAR(pi, rstr_pa2gw0a3);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		offset_40MHz[PHY_CORE_1] = PHY_GETINTVAR(pi, rstr_pa2gw1a3);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		offset_40MHz[PHY_CORE_2] = PHY_GETINTVAR(pi, rstr_pa2gw2a3);
#endif /* BAND5G */

	/* read pwrdet params for each band/subband */
	for (b = 0; b < NUMSUBBANDS(pi); b++) {
		switch (b) {
		case WL_CHAN_FREQ_RANGE_2G: /* 0 */
			/* 2G band */
			pwrdet->max_pwr[PHY_CORE_0][b] = (int8)PHY_GETINTVAR(pi, rstr_maxp2ga0);
			pwrdet->pwrdet_a1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa2gw0a0);
			pwrdet->pwrdet_b0[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa2gw1a0);
			pwrdet->pwrdet_b1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa2gw2a0);
			pwrdet->pwr_offset40[PHY_CORE_0][b] = 0;

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[PHY_CORE_1][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp2ga1);
				pwrdet->pwrdet_a1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw0a1);
				pwrdet->pwrdet_b0[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw1a1);
				pwrdet->pwrdet_b1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw2a1);
				pwrdet->pwr_offset40[PHY_CORE_1][b] = 0;
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[PHY_CORE_2][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp2ga2);
				pwrdet->pwrdet_a1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw0a2);
				pwrdet->pwrdet_b0[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw1a2);
				pwrdet->pwrdet_b1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa2gw2a2);
				pwrdet->pwr_offset40[PHY_CORE_2][b] = 0;
			}
			break;
#ifdef BAND5G
		case WL_CHAN_FREQ_RANGE_5G_BAND0: /* 1 */
			pwrdet->max_pwr[PHY_CORE_0][b] = (int8)PHY_GETINTVAR(pi, rstr_maxp5gla0);
			pwrdet->pwrdet_a1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5glw0a0);
			pwrdet->pwrdet_b0[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5glw1a0);
			pwrdet->pwrdet_b1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5glw2a0);
			pwrdet->pwr_offset40[PHY_CORE_0][b] = wlc_phy_txpwr40Moffset_srom_convert(
				(offset_40MHz[0] & PWROFFSET40_MASK_0)
					>> PWROFFSET40_SHIFT_0);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[PHY_CORE_1][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gla1);
				pwrdet->pwrdet_a1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a1);
				pwrdet->pwrdet_b0[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a1);
				pwrdet->pwrdet_b1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a1);
				pwrdet->pwr_offset40[PHY_CORE_1][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[1] & PWROFFSET40_MASK_0)
						>> PWROFFSET40_SHIFT_0);
			}
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[PHY_CORE_2][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gla2);
				pwrdet->pwrdet_a1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a2);
				pwrdet->pwrdet_b0[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a2);
				pwrdet->pwrdet_b1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a2);
				pwrdet->pwr_offset40[PHY_CORE_2][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[2] & PWROFFSET40_MASK_0)
						>> PWROFFSET40_SHIFT_0);
			}
			break;

		case WL_CHAN_FREQ_RANGE_5G_BAND1: /* 2 */
			pwrdet->max_pwr[PHY_CORE_0][b] = (int8)PHY_GETINTVAR(pi, rstr_maxp5ga0);
			pwrdet->pwrdet_a1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw0a0);
			pwrdet->pwrdet_b0[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw1a0);
			pwrdet->pwrdet_b1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw2a0);
			pwrdet->pwr_offset40[PHY_CORE_0][b] = wlc_phy_txpwr40Moffset_srom_convert(
				(offset_40MHz[0] & PWROFFSET40_MASK_1) >> PWROFFSET40_SHIFT_1);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[PHY_CORE_1][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5ga1);
				pwrdet->pwrdet_a1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw0a1);
				pwrdet->pwrdet_b0[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw1a1);
				pwrdet->pwrdet_b1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw2a1);
				pwrdet->pwr_offset40[PHY_CORE_1][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[1] & PWROFFSET40_MASK_1)
						>> PWROFFSET40_SHIFT_1);
			}

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[PHY_CORE_2][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5ga2);
				pwrdet->pwrdet_a1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw0a2);
				pwrdet->pwrdet_b0[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw1a2);
				pwrdet->pwrdet_b1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5gw2a2);
				pwrdet->pwr_offset40[PHY_CORE_2][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[2] & PWROFFSET40_MASK_1)
						>> PWROFFSET40_SHIFT_1);
			}
			break;

		case WL_CHAN_FREQ_RANGE_5G_BAND2: /* 3 */
			pwrdet->max_pwr[PHY_CORE_0][b] = (int8)PHY_GETINTVAR(pi, rstr_maxp5gha0);
			pwrdet->pwrdet_a1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a0);
			pwrdet->pwrdet_b0[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a0);
			pwrdet->pwrdet_b1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a0);
			pwrdet->pwr_offset40[0][b] = wlc_phy_txpwr40Moffset_srom_convert(
				(offset_40MHz[PHY_CORE_0] & PWROFFSET40_MASK_2) >>
					PWROFFSET40_SHIFT_2);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[PHY_CORE_1][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gha1);
				pwrdet->pwrdet_a1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a1);
				pwrdet->pwrdet_b0[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a1);
				pwrdet->pwrdet_b1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a1);
				pwrdet->pwr_offset40[1][b] = wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[PHY_CORE_1] & PWROFFSET40_MASK_2) >>
						PWROFFSET40_SHIFT_2);
			}

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[PHY_CORE_2][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gha2);
				pwrdet->pwrdet_a1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a2);
				pwrdet->pwrdet_b0[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a2);
				pwrdet->pwrdet_b1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a2);
				pwrdet->pwr_offset40[2][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[PHY_CORE_2] & PWROFFSET40_MASK_2)
						>> PWROFFSET40_SHIFT_2);
			}
			break;

		case WL_CHAN_FREQ_RANGE_5G_BAND3: /* 4 */
			pwrdet->max_pwr[PHY_CORE_0][b] = (int8)PHY_GETINTVAR(pi, rstr_maxp5ga3);
			pwrdet->pwrdet_a1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw0a3);
			pwrdet->pwrdet_b0[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw1a3);
			pwrdet->pwrdet_b1[PHY_CORE_0][b] = (int16)PHY_GETINTVAR(pi, rstr_pa5gw2a3);
			pwrdet->pwr_offset40[PHY_CORE_0][b] = wlc_phy_txpwr40Moffset_srom_convert(
				(offset_40MHz[0] & PWROFFSET40_MASK_3) >> PWROFFSET40_SHIFT_3);
			if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
				pwrdet->max_pwr[PHY_CORE_1][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gla3);
				pwrdet->pwrdet_a1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw0a3);
				pwrdet->pwrdet_b0[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw1a3);
				pwrdet->pwrdet_b1[PHY_CORE_1][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5glw2a3);
				pwrdet->pwr_offset40[PHY_CORE_1][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[1] & PWROFFSET40_MASK_3)
						>> PWROFFSET40_SHIFT_3);
			}

			if (PHYCORENUM(pi->pubpi.phy_corenum) > 2) {
				pwrdet->max_pwr[PHY_CORE_2][b] =
					(int8)PHY_GETINTVAR(pi, rstr_maxp5gha3);
				pwrdet->pwrdet_a1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw0a3);
				pwrdet->pwrdet_b0[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw1a3);
				pwrdet->pwrdet_b1[PHY_CORE_2][b] =
					(int16)PHY_GETINTVAR(pi, rstr_pa5ghw2a3);
				pwrdet->pwr_offset40[PHY_CORE_2][b] =
					wlc_phy_txpwr40Moffset_srom_convert(
					(offset_40MHz[2] & PWROFFSET40_MASK_3)
						>> PWROFFSET40_SHIFT_3);
			}
			break;
#endif /* BAND5G */
		}
	}
	wlc_phy_txpwr_srom9_read_ppr(pi);
	return TRUE;
}

void
wlc_phy_antsel_init(wlc_phy_t *ppi, bool lut_init)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISNPHY(pi))
		wlc_phy_antsel_init_nphy(ppi, lut_init);
}

#define BTCX_FLUSH_WAIT_MAX_MS  500
void
wlc_btcx_override_enable(phy_info_t *pi)
{
	/* This is required only for 2G operation. No BTCX in 5G */
	if ((pi->sh->machwcap & MCAP_BTCX) &&
		CHSPEC_IS2G(pi->radio_chanspec)) {
		/* Ucode better be suspended when we mess with BTCX regs directly */
		ASSERT(!(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));
		wlapi_coex_flush_a2dp_buffers(pi->sh->physhim);

		/* Enable manual BTCX mode */
		OR_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_CTRL, BTCX_CTRL_EN | BTCX_CTRL_SW);
		/* Force WLAN antenna and priority */
		OR_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_TRANS_CTRL,
			BTCX_TRANS_TXCONF | BTCX_TRANS_ANTSEL);

		/* SWWLAN-30288 For 4324x ucode is not setting clb_rf_sw_ctrl_mask with value
		 * needed for WLAN to  have control whenever BT->WLAN priority switch happens,
		 * so forcing it use correct value
		 */
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3)) {
			pi->saved_clb_sw_ctrl_mask = phy_reg_read(pi,
			NPHY_REV19_clb_rf_sw_ctrl_mask_ctrl);
			phy_reg_write(pi, NPHY_REV19_clb_rf_sw_ctrl_mask_ctrl,
				LCNXN_SWCTRL_MASK_DEFAULT);
			}
	}
}

void
wlc_phy_btcx_override_disable(phy_info_t *pi)
{
	if ((pi->sh->machwcap & MCAP_BTCX) &&
		CHSPEC_IS2G(pi->radio_chanspec)) {
		/* Ucode better be suspended when we mess with BTCX regs directly */
		ASSERT(!(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC));

		/* SWWLAN-30288 For 4324x ucode is not setting clb_rf_sw_ctrl_mask with value
		 * needed for WLAN to have control whenever BT->WLAN priority switch happens
		 * so it was forced to wlan prefered value, so restoring the correct value
		 * for BT to have control
		 */
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, LCNXN_BASEREV + 3))
			phy_reg_write(pi, NPHY_REV19_clb_rf_sw_ctrl_mask_ctrl,
				pi->saved_clb_sw_ctrl_mask);

		/* Enable manual BTCX mode */
		OR_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_CTRL, BTCX_CTRL_EN | BTCX_CTRL_SW);
		/* Force BT priority */
		AND_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_TRANS_CTRL,
			~(BTCX_TRANS_TXCONF | BTCX_TRANS_ANTSEL));
	}
}

bool
wlc_phy_no_cal_possible(phy_info_t *pi)
{
	return (SCAN_RM_IN_PROGRESS(pi));
}

#if !defined(EFI)

#if PHY_TSSI_CAL_DBG_EN
static void
print_int64(int64 *a)
{
	void *llp = a;
	uint32 *lp_low = (uint32 *)llp;
	uint32 *lp_high = lp_low + 1;
	printf("0x%08x%08x ", *lp_high, *lp_low);
}
#endif // endif

#if PHY_TSSI_CAL_DBG_EN
/*
 * matrix print
 * dimensions a (m x n)
 * name - matrix name
 */
static void
mat_print(int64 *a, int m, int n, const char *name)
{
	int i, j;

	printf("\n%s\n", name);
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++)
			print_int64(a + (i * n) + j);
		printf("\n");
	}
}
#else /* PHY_TSSI_CAL_DBG_EN */
static void
mat_print(int64 *a, int m, int n, const char *name)
{
}
#endif /* PHY_TSSI_CAL_DBG_EN */

/*
 * Compute matrix rho ( m x 3)
 *
 * column 1 = all 1s
 * column 2 = n[i]
 * column 3 = - n[i] * P[i]
 */
static void
mat_rho(int64 *n, int64 *p, int64 *rho, int m)
{
	int i;
	int q1 = 2;

	for (i = 0; i < m; i++) {
		*(rho + (i * 3) + 0) = 1;
		*(rho + (i * 3) + 1) = *(n + (i * 1) + 0);
		*(rho + (i * 3) + 2) =
			- (*(n + (i * 1) + 0) * (*(p + (i * 1) + 0)));
		*(rho + (i * 3) + 2) = (*(rho + (i * 3) + 2) + (int64)(1<<(q1-1))) >> q1;
	}
}

/*
 * Matrix transpose routine
 * matrix a (m x n)
 * matrix b = a_transpose(n x m)
 */
static void
mat_transpose(int64 *a, int64 *b, int m, int n)
{
	int i, j;

	for (i = 0; i < m; i++)
		for (j = 0; j < n; j++)
			/* b[j][i] = a[i][j]; */
			*(b + (j * m) + i) = *(a + (i * n) + j);
}

/*
 * Matrix multiply routine.
 * matrix a (m x n)
 * matrix b (n x r)
 * c = result matrix (m x r)
 * m = number of rows of matrix a
 * n = number of cols of matrix a and number of rows of matrix b
 * r = number of cols of matrix b
 * assumes matrixes are allocated in memory contiguously one row after
 * the other
 *
 */
static void
mat_mult(int64 *a, int64 *b, int64 *c, int m, int n, int r)
{
	int i, j, k;

	for (i = 0; i < m; i++)
		for (j = 0; j < r; j++) {
			*(c + (i * r) + j) = 0;
			for (k = 0; k < n; k++)
				/* c[i][j] += a[i][k] * b[k][j]; */
				*(c + (i * r) + j)
					+= *(a + (i * n) + k) *
					*(b + (k * r) + j);
		}
}

/*
 * Matrix inverse of a 3x3 matrix * det(matrix)
 * a and b: matrices of 3x3
 */
static void
mat_inv_prod_det(int64 *a, int64 *b)
{

	/* C2_calc = [	a22*a33 - a32*a23  a13*a32 - a12*a33  a12*a23 - a13*a22
					a23*a31 - a21*a33  a11*a33 - a13*a31  a13*a21 - a11*a23
					a21*a32 - a31*a22  a12*a31 - a11*a32  a11*a22 - a12*a21];
	*/

	int64 a11 = *(a + (0 * 3) + 0);
	int64 a12 = *(a + (0 * 3) + 1);
	int64 a13 = *(a + (0 * 3) + 2);

	int64 a21 = *(a + (1 * 3) + 0);
	int64 a22 = *(a + (1 * 3) + 1);
	int64 a23 = *(a + (1 * 3) + 2);

	int64 a31 = *(a + (2 * 3) + 0);
	int64 a32 = *(a + (2 * 3) + 1);
	int64 a33 = *(a + (2 * 3) + 2);

	*(b + (0 * 3) + 0) = a22 * a33 - a32 * a23;
	*(b + (0 * 3) + 1) = a13 * a32 - a12 * a33;
	*(b + (0 * 3) + 2) = a12 * a23 - a13 * a22;

	*(b + (1 * 3) + 0) = a23 * a31 - a21 * a33;
	*(b + (1 * 3) + 1) = a11 * a33 - a13 * a31;
	*(b + (1 * 3) + 2) = a13 * a21 - a11 * a23;

	*(b + (2 * 3) + 0) = a21 * a32 - a31 * a22;
	*(b + (2 * 3) + 1) =  a12 * a31 - a11 * a32;
	*(b + (2 * 3) + 2) = a11 * a22 - a12 * a21;
}

static void
mat_det(int64 *a, int64 *det)
{

	/* det_C1 = a11*a22*a33 + a12*a23*a31 + a13*a21*a32 -
				 a11*a23*a32 - a12*a21*a33 - a13*a22*a31;
	*/

	int64 a11 = *(a + (0 * 3) + 0);
	int64 a12 = *(a + (0 * 3) + 1);
	int64 a13 = *(a + (0 * 3) + 2);

	int64 a21 = *(a + (1 * 3) + 0);
	int64 a22 = *(a + (1 * 3) + 1);
	int64 a23 = *(a + (1 * 3) + 2);

	int64 a31 = *(a + (2 * 3) + 0);
	int64 a32 = *(a + (2 * 3) + 1);
	int64 a33 = *(a + (2 * 3) + 2);

	*det = a11 * a22 * a33 + a12 * a23 * a31 + a13 * a21 * a32 -
		a11 * a23 * a32 - a12 * a21 * a33 - a13 * a22 * a31;
}

/* ================================================================
function [b0 b1 a1] = ratmodel_paparams_fix64(n, P)

%This is the algorithm used for curve fitting to get PA Params
%n: Adjusted TSSI values
%P: Power in qdBm

q1 = 4;
n = reshape(n, length(n), 1);
P = (reshape(P, length(P), 1)*q1);
P = round(P);

rho = ones(length(n), 3)*q1;
rho(:,2) = n*q1;
rho(:,3) = -n.*P;
rho = (rho./q1);
rho = round(rho);

C1 = rho' * rho;

a11 = C1(1,1); a12 = C1(1,2); a13 = C1(1,3);
a21 = C1(2,1); a22 = C1(2,2); a23 = C1(2,3);
a31 = C1(3,1); a32 = C1(3,2); a33 = C1(3,3);

C2_calc = [a22*a33 - a32*a23  a13*a32 - a12*a33  a12*a23 - a13*a22
		a23*a31 - a21*a33  a11*a33 - a13*a31  a13*a21 - a11*a23
		a21*a32 - a31*a22  a12*a31 - a11*a32  a11*a22 - a12*a21];

det_C1 = a11*a22*a33 + a12*a23*a31 + a13*a21*a32
		- a11*a23*a32 - a12*a21*a33 - a13*a22*a31;

C3 = C2_calc * rho';

C4 = C3 * P

C4 = round(C4./q1)

C = C4./det_C1;

b0=round(2^8*C(1)) ;
b1=round(2^12*C(2));
a1=round(2^15*C(3));

return;
*/
static void
ratmodel_paparams_fix64(ratmodel_paparams_t* rsd, int m)
{
	int i, j, n, q;
	int64 *a, temp;

	mat_rho((int64 *)(&rsd->n), (int64 *)(&rsd->p),
		(int64 *)(&rsd->rho), m);
	mat_print((int64 *)(&rsd->rho), m, 3, "rho");

	mat_transpose((int64 *)(&rsd->rho),
		(int64 *)(&rsd->rho_t), m, 3);
	mat_print((int64 *)(&rsd->rho_t), 3, m, "rho_t");

	mat_mult((int64*)(&rsd->rho_t), (int64 *)(&rsd->rho),
		(int64*)(&rsd->c1), 3, m, 3);
	mat_print((int64 *)(&rsd->c1), 3, 3, "c1");

	mat_inv_prod_det((int64 *)(&rsd->c1),
		(int64 *)(&rsd->c2_calc));
	mat_print((int64 *)(&rsd->c2_calc), 3, 3, "c2_calc");

	mat_det((int64 *)(&rsd->c1), (int64 *)(&rsd->det_c1));

#if PHY_TSSI_CAL_DBG_EN
	printf("\ndet_c1 = ");
	print_int64(&rsd->det_c1);
	printf("\n");
#endif // endif

	mat_mult((int64*)(&rsd->c2_calc), (int64 *)(&rsd->rho_t),
		(int64*)(&rsd->c3), 3, 3, m);
	mat_print((int64 *)(&rsd->c3), 3, m, "c3");

	mat_mult((int64*)(&rsd->c3), (int64 *)(&rsd->p),
		(int64*)(&rsd->c4), 3, m, 1);

	m = 3; n = 1; q = 2;
	a = (int64*)(&rsd->c4);
	for (i = 0; i < m; i++)
		for (j = 0; j < n; j++) {
			temp = *(a + (i * n) + j);
			temp = (temp + (int64)(1 << (q-1)));
			temp = temp >> q;
			*(a + (i * n) + j) = temp;
		}

	mat_print((int64 *)(&rsd->c4), 3, 1, "c4");
}

int
wlc_phy_tssi_cal(phy_info_t *pi)
{
	uint16 count;
	count = tssi_cal_sweep(pi);
	ratmodel_paparams_fix64(&pi->ptssi_cal->rsd, count);
	return 0;
}

static uint16
tssi_cal_sweep(phy_info_t *pi)
{

	uint16 i, k = 0;

	uint16 count = 0;
	int8 *des_pwr = NULL;
	uint8 *adj_tssi = NULL;
	int *sort_pwr = NULL, avg_pwr;
	uint8 *sort_pwr_cnt = NULL;
	int16 MIN_PWR = 32; /* 8dBm */
	int16 MAX_PWR = 72; /* 18dBm */

	int64* tssi = pi->ptssi_cal->rsd.n;
	int64* pwr = pi->ptssi_cal->rsd.p;

	des_pwr = (int8*)MALLOC(pi->sh->osh, sizeof(int8)* 80 * MAX_NUM_ANCHORS);
	if (des_pwr == NULL)
		goto cleanup;

	adj_tssi = (uint8*)MALLOC(pi->sh->osh, sizeof(uint8) * 80 * MAX_NUM_ANCHORS);
	if (adj_tssi == NULL)
		goto cleanup;

	sort_pwr = (int*)MALLOC(pi->sh->osh, sizeof(int)*128);
	if (sort_pwr == NULL)
		goto cleanup;

	sort_pwr_cnt = (uint8*)MALLOC(pi->sh->osh, sizeof(uint8)*128);
	if (sort_pwr_cnt == NULL)
		goto cleanup;

	if (pi->pi_fptr.tssicalsweep)
		count = (*pi->pi_fptr.tssicalsweep)(pi, des_pwr, adj_tssi);
	else
		goto cleanup;

	for (i = 0; i < 128; i++) {
		sort_pwr[i] = 0xffffffff;
		sort_pwr_cnt[i] = 0;
	}

	for (i = 0; i < count; i++) {
		if (sort_pwr[adj_tssi[i]] == 0xffffffff)
			sort_pwr[adj_tssi[i]] = des_pwr[i];
		else {
			sort_pwr[adj_tssi[i]] += des_pwr[i];
		}
		sort_pwr_cnt[adj_tssi[i]]++;
	}

	k = 0;
	for (i = 0; i < 128; i++) {
		if (sort_pwr[i] != 0xffffffff) {
			avg_pwr =  sort_pwr[i]/sort_pwr_cnt[i];
			if ((avg_pwr >= MIN_PWR) && (avg_pwr <= MAX_PWR)) {
				tssi[k] = (int64) i;
				pwr[k] =  (int64) avg_pwr;
				k++;
			}
		}
	}

#if PHY_TSSI_CAL_DBG_EN
	printf("TSSI\tPWR, k = %d\n", k);
	for (i = 0; i < k; i++) {
		print_int64(&tssi[i]);
		printf("\t\t");
		print_int64(&pwr[i]);
		printf("\n");
	}
#endif // endif

cleanup:
	if (des_pwr)
		MFREE(pi->sh->osh, des_pwr, sizeof(int8) * 80 * MAX_NUM_ANCHORS);
	if (adj_tssi)
		MFREE(pi->sh->osh, adj_tssi, sizeof(uint8) * 80 * MAX_NUM_ANCHORS);
	if (sort_pwr)
		MFREE(pi->sh->osh, sort_pwr, sizeof(int)*128);
	if (sort_pwr_cnt)
		MFREE(pi->sh->osh, sort_pwr_cnt, sizeof(uint8)*128);

	return k;
}

#endif // endif

/* a simple implementation of gcd(greatest common divisor)
 * assuming argument 1 is bigger than argument 2, both of them
 * are positive numbers.
 */
uint32
wlc_phy_gcd(uint32 bigger, uint32 smaller)
{
	uint32 remainder;

	do {
		remainder = bigger % smaller;
		if (remainder) {
			bigger = smaller;
			smaller = remainder;
		} else {
			return smaller;
		}
	} while (TRUE);
}

#if ((defined(LCNCONF) && (LCNCONF != 0)) || (defined(LCN40CONF) && (LCN40CONF != 0)) \
	|| (defined(LCN20CONF) && (LCN20CONF != 0)))
void
wlc_phy_get_paparams_for_band(phy_info_t *pi, int32 *a1, int32 *b0, int32 *b1)
{
	/* On lcnphy, estPwrLuts0/1 table entries are in S6.3 format */
	switch (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)) {
	case WL_CHAN_FREQ_RANGE_2G:
			/* 2.4 GHz */
			ASSERT((pi->txpa_2g[0] != -1) && (pi->txpa_2g[1] != -1) &&
				(pi->txpa_2g[2] != -1));
			*b0 = pi->txpa_2g[0];
			*b1 = pi->txpa_2g[1];
			*a1 = pi->txpa_2g[2];
			break;
#ifdef BAND5G
	case WL_CHAN_FREQ_RANGE_5GL:
			/* 5 GHz low */
			ASSERT((pi->txpa_5g_low[0] != -1) &&
				(pi->txpa_5g_low[1] != -1) &&
				(pi->txpa_5g_low[2] != -1));
			*b0 = pi->txpa_5g_low[0];
			*b1 = pi->txpa_5g_low[1];
			*a1 = pi->txpa_5g_low[2];
			break;

		case WL_CHAN_FREQ_RANGE_5GM:
			/* 5 GHz middle */
			ASSERT((pi->txpa_5g_mid[0] != -1) &&
				(pi->txpa_5g_mid[1] != -1) &&
				(pi->txpa_5g_mid[2] != -1));
			*b0 = pi->txpa_5g_mid[0];
			*b1 = pi->txpa_5g_mid[1];
			*a1 = pi->txpa_5g_mid[2];
			break;

		case WL_CHAN_FREQ_RANGE_5GH:
			/* 5 GHz high */
			ASSERT((pi->txpa_5g_hi[0] != -1) &&
				(pi->txpa_5g_hi[1] != -1) &&
				(pi->txpa_5g_hi[2] != -1));
			*b0 = pi->txpa_5g_hi[0];
			*b1 = pi->txpa_5g_hi[1];
			*a1 = pi->txpa_5g_hi[2];
			break;
#endif /* BAND5G */
		default:
			ASSERT(FALSE);
			break;
	}
	return;
}
#endif /* lcn40 || lcn */

/* --------------------------------------------- */
/* this will evetually be moved to lcncommon.c */
phy_info_lcnphy_t *
wlc_phy_getlcnphy_common(phy_info_t *pi)
{
	if (ISLCNPHY(pi))
		return pi->u.pi_lcnphy;
	else if (ISLCN40PHY(pi))
		return (phy_info_lcnphy_t *)pi->u.pi_lcn40phy;
	else {
		ASSERT(FALSE);
		return NULL;
	}
}

uint16
wlc_txpwrctrl_lcncommon(phy_info_t *pi)
{
	if (ISLCNPHY(pi))
		return LCNPHY_TX_PWR_CTRL_HW;
	else if (ISLCN40PHY(pi))
		return LCN40PHY_TX_PWR_CTRL_HW;
	else {
		ASSERT(FALSE);
		return 0;
	}
}

#ifdef ENABLE_FCBS

/* Fast Channel/Band Switch (FCBS) engine functions */

/* Function prototype */
void wlc_phy_fcbs_read_regs_tbls(phy_info_t *pi, int chanidx, chanspec_t chanspec);

bool wlc_phy_is_fcbs_chan(phy_info_t *pi, chanspec_t chanspec, int *chanidx_ptr)
{
	int chanidx;
	bool retval = FALSE;

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
		if (pi->phy_fcbs.initialized[chanidx]) {
			if (pi->phy_fcbs.chanspec[chanidx] == chanspec) {
				*chanidx_ptr = chanidx;
				retval = TRUE;
				break;
			}
		}
	}

	return retval;
}

bool wlc_phy_is_fcbs_pending(phy_info_t *pi, chanspec_t chanspec, int *chanidx_ptr)
{
	int chanidx;
	bool retval = FALSE;

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
		if (!pi->phy_fcbs.initialized[chanidx]) {
			if ((pi->phy_fcbs.chanspec[chanidx] == chanspec) ||
				((pi->phy_fcbs.chanspec[chanidx] == 0xFFFF))) {
				*chanidx_ptr = chanidx;
				retval = TRUE;
				break;
			}
		}
	}

	return retval;
}

void wlc_phy_fcbs_exit(wlc_phy_t *ppi)
{
	int chanidx;
	phy_info_t *pi = (phy_info_t*)ppi;

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
		pi->phy_fcbs.chanspec[chanidx] = 0;
		pi->phy_fcbs.initialized[chanidx] = FALSE;
	}
}

bool wlc_phy_fcbs_uninit(wlc_phy_t *ppi, chanspec_t chanspec)
{
	int chanidx;
	phy_info_t *pi = (phy_info_t*)ppi;

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
		if (pi->phy_fcbs.chanspec[chanidx] == chanspec) {
			pi->phy_fcbs.chanspec[chanidx] = 0;
			pi->phy_fcbs.initialized[chanidx] = FALSE;
			PHY_INFORM(("%s: Uninitting channel %d on idx %d\n",
				__FUNCTION__, CHSPEC_CHANNEL(chanspec), chanidx));

			return TRUE;
		}
	}
	PHY_ERROR(("%s: Cannot uninit unused fcbs context!! 0x%x, %d\n",
		__FUNCTION__, chanspec, CHSPEC_CHANNEL(chanspec)));

	return FALSE;
}

void wlc_phy_fcbs_read_regs_tbls(phy_info_t *pi, int chanidx, chanspec_t chanspec)
{
	/* TBD */
}

/* using chanspec of 0 cancels an arm request */
/* Might call mac_suspend() */
bool wlc_phy_fcbs_arm(wlc_phy_t *ppi, chanspec_t chanspec, int chanidx)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	ASSERT((chanidx >= 0) && (chanidx < MAX_FCBS_CHANS));
	ASSERT(!wf_chspec_malformed(chanspec) || chanspec == 0 || chanspec == 0xff);

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
		if (pi->phy_fcbs.chanspec[chanidx] == chanspec) {
			PHY_ERROR(("%s: channel %d is already armed.\n",
				__FUNCTION__, CHSPEC_CHANNEL(chanspec)));
			return TRUE;
		}
	}

	for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
			if ((!pi->phy_fcbs.chanspec[chanidx]))
				break;
	}

	if (chanidx >= MAX_FCBS_CHANS) {
		PHY_ERROR(("%s: ERROR: No Free Entry!!\n", __FUNCTION__));
		return FALSE;
	}

	/* If we lucky enough to be on channel, call init directly */
	if ((chanspec == pi->radio_chanspec) && IS_FCBS(pi) &&
	    !(SCAN_INPROG_PHY(pi) || RM_INPROG_PHY(pi) || PLT_INPROG_PHY(pi)) &&
		(chanidx == wlc_phy_channelindicator_obtain_acphy(pi))) {
		PHY_ERROR(("%s: Already on channel %d, call fcbs_init immediatly\n",
			__FUNCTION__, CHSPEC_CHANNEL(pi->radio_chanspec)));
		pi->phy_fcbs.chanspec[chanidx] = chanspec;
		return wlc_phy_fcbs_init(ppi, chanidx);
	} else {
		PHY_INFORM(("%s: Arming channel %d\n", __FUNCTION__, CHSPEC_CHANNEL(chanspec)));
		pi->phy_fcbs.chanspec[chanidx] = chanspec;
		pi->phy_fcbs.initialized[chanidx] = FALSE;
		return TRUE;
	}
}

bool wlc_phy_hw_fcbs_init(wlc_phy_t *ppi, int chanidx)
{
	fcbsinitfn_t fcbs_init = NULL;
	phy_info_t *pi = (phy_info_t*)ppi;

	if (chanidx >= MAX_FCBS_CHANS) {
		PHY_ERROR(("%s: ERROR: Out of empty contexts!!\n", __FUNCTION__));
		return FALSE;
	}

	ASSERT((chanidx >= 0) && (chanidx < MAX_FCBS_CHANS));

	PHY_INFORM(("%s: Initting slot %d, channel %d\n",
		__FUNCTION__, chanidx, CHSPEC_CHANNEL(pi->radio_chanspec)));

	pi->phy_fcbs.chanspec[chanidx] = pi->radio_chanspec;

	/* Get the pointer to the PHY specfic FCBS init function */
	fcbs_init = pi->pi_fptr.fcbsinit;

	if (!fcbs_init) {
		PHY_ERROR(("%s: Missing fcbsinit pointer\n", __FUNCTION__));
		pi->phy_fcbs.initialized[chanidx] = FALSE;
		ASSERT(fcbs_init);
		return TRUE;
	}
	/* phy-specific fcbs_init function needs to just initialize the pointers to the
	 * lists of regs/tbls that need to be saved into the FCBS TBL
	 */
	(*fcbs_init)(pi, chanidx, pi->radio_chanspec);
	/* actual reading and saving of all the required regs/btls is done in this fctn */
	pi->phy_fcbs.initialized[chanidx] =
		wlc_phy_hw_fcbs_init_chanidx((wlc_phy_t*)pi, chanidx);

	return TRUE;
}

bool wlc_phy_hw_fcbs_init_chanidx(wlc_phy_t *ppi, int chanidx)
{
	/* compiling and writing all FCBS data */

	uint16 *p_fcbs_tbl_data;
	fcbs_radioreg_core_list_entry *radioreg_list_ptr;
	uint16 *reg_list_ptr;
	fcbs_phytbl_list_entry *tbl_list_ptr;
	phy_info_t *pi = (phy_info_t*)ppi;
	int length;
	uint8 stall_val;

	p_fcbs_tbl_data = pi->phy_fcbs.hw_fcbs_tbl_data;
	length = 0;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);
	for (radioreg_list_ptr = pi->phy_fcbs.fcbs_radioreg_list;
			radioreg_list_ptr->regaddr != 0xFFFF; radioreg_list_ptr++) {
		*p_fcbs_tbl_data = (radioreg_list_ptr->regaddr) |
			((radioreg_list_ptr->core_info & 0x7) << FCBS_TBL_RADIOREG_CORE_SHIFT) |
			FCBS_TBL_INST_INDICATOR;
		p_fcbs_tbl_data += (chanidx + 1);
		*p_fcbs_tbl_data = read_radio_reg(pi, radioreg_list_ptr->regaddr);
		p_fcbs_tbl_data += (MAX_FCBS_CHANS - chanidx);
	}
	*p_fcbs_tbl_data = 0xFFFF;
	p_fcbs_tbl_data++;

	for (reg_list_ptr = pi->phy_fcbs.fcbs_phyreg_list;
			*reg_list_ptr != 0xFFFF; reg_list_ptr++) {
		*p_fcbs_tbl_data = *reg_list_ptr | FCBS_TBL_INST_INDICATOR;
		p_fcbs_tbl_data += (chanidx + 1);
		*p_fcbs_tbl_data = phy_reg_read(pi, *reg_list_ptr);
		p_fcbs_tbl_data += (MAX_FCBS_CHANS - chanidx);
	}
	*p_fcbs_tbl_data = 0xFFFF;
	p_fcbs_tbl_data++;

	if (!pi->phy_fcbs.FCBS_ucode) {
		for (tbl_list_ptr = pi->phy_fcbs.fcbs_phytbl16_list;
		    tbl_list_ptr->tbl_id != 0xFFFF; tbl_list_ptr++) {
			int num_entries;
			int tbl_idx;
			uint16 fcbs_phytbl_copy[20];

			num_entries = tbl_list_ptr->num_entries;
			/* Setup the information tuple */
			*p_fcbs_tbl_data++ = tbl_list_ptr->tbl_id | FCBS_TBL_INST_INDICATOR;
			*p_fcbs_tbl_data++ = tbl_list_ptr->tbl_offset;
			*p_fcbs_tbl_data++ = tbl_list_ptr->tbl_offset +
				tbl_list_ptr->num_entries - 1;

			stall_val = (phy_reg_read(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev)) &
				ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev))
				>> ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev);
			phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
				ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
				1 << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));
			wlc_phy_table_read_acphy(pi, tbl_list_ptr->tbl_id,
			     tbl_list_ptr->num_entries, tbl_list_ptr->tbl_offset,
			     16, fcbs_phytbl_copy);
			phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
				ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
				stall_val <<
				ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));

			/* valA and valB are interleved and we can align the 1st element correctly
			 * and then increment by 2 to write the subsequent entries of the same chan
			 */
			p_fcbs_tbl_data += chanidx;
			for (tbl_idx = 0; tbl_idx < num_entries; tbl_idx++) {
				*p_fcbs_tbl_data = fcbs_phytbl_copy[tbl_idx];
				p_fcbs_tbl_data += MAX_FCBS_CHANS;
			}
			p_fcbs_tbl_data -= chanidx;
			/* Setup the information tuple */
		}
	} else {
		uint16 * p_phytbl16_buf;
		int offset, len, phytbl_idx;
		uint16 num_entries;

		p_phytbl16_buf = pi->phy_fcbs.phytbl16_buf[chanidx];
		phytbl_idx = 0;
		/* radio regs are being handle through HW FCBS  */
		if (chanidx == FCBS_CHAN_A) {
			pi->phy_fcbs.chan_cache_offset[chanidx] =
			    pi->phy_fcbs.cache_startaddr;
		}
		offset = pi->phy_fcbs.chan_cache_offset[chanidx];
		len = 0;
		pi->phy_fcbs.radioreg_cache_offset[chanidx] = offset;
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_radioreg, (uint16)len);
		PHY_FCBS(("radio reg buf: start offset=%d, len=%d\n", offset, len));

		/* Store the 16-bit PHY table entries in the FCBS cache */
		offset += len;
		len = 0;
		for (tbl_list_ptr = pi->phy_fcbs.fcbs_phytbl16_list;
		    tbl_list_ptr->tbl_id != 0xFFFF; tbl_list_ptr++) {
			/* Setup the information tuple */
			p_phytbl16_buf[phytbl_idx++] = (tbl_list_ptr->tbl_id << 10) |
			    tbl_list_ptr->tbl_offset;
			p_phytbl16_buf[phytbl_idx++] = tbl_list_ptr->num_entries;
			num_entries = tbl_list_ptr->num_entries;

			stall_val = (phy_reg_read(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev))
				& ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev))
				>> ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev);
			phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
				ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
				1 << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));
			wlc_phy_table_read_acphy(pi, tbl_list_ptr->tbl_id,
			     tbl_list_ptr->num_entries, tbl_list_ptr->tbl_offset,
			     16, p_phytbl16_buf + phytbl_idx);
			phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
				ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
				stall_val <<
				ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));

			phytbl_idx += tbl_list_ptr->num_entries;

			/* if we don't have even number of entries pad
			 * the buffer by 16-bits of zeros
			 */
			if (((num_entries/2) * 2) != num_entries) {
				p_phytbl16_buf[phytbl_idx++] = 0;
				num_entries += 1;
			}

			len += 4 + (num_entries * 2);
		}

		pi->phy_fcbs.phytbl16_cache_offset[chanidx] = offset;
		/* buffer has to end at 4-byte boundary in the RAM */
		if (((len/4) * 4) != len) {
			len += 2;
		}
		wlapi_bmac_write_template_ram(pi->sh->physhim,
		    offset, len, p_phytbl16_buf);
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phytbl16, (uint16)len);
		PHY_FCBS(("phytbl16: start offset = %d, len = %d\n", offset, len));

		/* 32-bit PHY tables entries handled through HW FCBS TBL */
		offset += len;
		len = 0;
		pi->phy_fcbs.phytbl32_cache_offset[chanidx] = offset;
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phytbl32, (uint16)len);
		PHY_FCBS(("phytbl32: start offset = %d, len = %d\n", offset, len));

		/* PHY regs handled through HW FCBS TBL */
		offset += len;
		len = 0;
		pi->phy_fcbs.phyreg_cache_offset[chanidx] = offset;

		pi->phy_fcbs.phyreg_buflen[chanidx] = len;
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phyreg, (uint16)len);
		PHY_FCBS(("PHY reg buf: start offset=%d, len = %d\n", offset, len));

		if (chanidx == FCBS_CHAN_A) {
			/* Now that we have finished storing the
			 * cache for CHAN_A, we know the starting
			 * cache address for CHAN_B
			 */
			pi->phy_fcbs.chan_cache_offset[FCBS_CHAN_B] = offset + len;
		}

		/* Clear the cache pointer in case it had a non-zero value
		 * before the init
		 */
		wlapi_bmac_write_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr, 0);

	}

	*p_fcbs_tbl_data = 0xFFFF;
	p_fcbs_tbl_data++;
	/* length gets number of array entries */
	length = (int)(p_fcbs_tbl_data - pi->phy_fcbs.hw_fcbs_tbl_data);
	stall_val = (phy_reg_read(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev)) &
		ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev))
		>> ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev);
	phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
		ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
		1 << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH,
	                         length, 0, 16, pi->phy_fcbs.hw_fcbs_tbl_data);
	phy_reg_mod(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev),
		ACPHY_RxFeCtrl1_disable_stalls_MASK(pi->pubpi.phy_rev),
		stall_val << ACPHY_RxFeCtrl1_disable_stalls_SHIFT(pi->pubpi.phy_rev));
	/* FCBS has been written into FCBS tbl */

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
	return TRUE;
}

/* Might call mac_suspend() */
/* NOTE: chanidx isn't used anymore, leaving it for now to try it out */

bool wlc_phy_fcbs_init(wlc_phy_t *ppi, int chanidx)
{
	int offset, bphy_offset;
	int len, bphy_len;
	fcbsinitfn_t fcbs_init = NULL;
	phy_info_t *pi = (phy_info_t*)ppi;

#if defined(FCBS_GPIO_PROFILE)
	uint32 gpio_mask_val = 0x10000; /* CCTRL4331_BT_SHD0_ON_GPIO4 */
#endif // endif
	if (IS_FCBS(pi)) {
		return wlc_phy_hw_fcbs_init((wlc_phy_t*)pi, chanidx);
	}

#if defined(FCBS_GPIO_PROFILE)
	/* Use a GPIO to measure the FCBS time on an oscilloscope */
	if (chanidx == FCBS_CHAN_A) {
		/* Enable the GPIO */
		si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
		           gpio_mask_val, 0);
	}
#endif /* FCBS_GPIO_PROFILE */

	ASSERT((chanidx >= 0) && (chanidx < MAX_FCBS_CHANS));

#ifdef LATER
	/* Chan A has to be initialized before Chan B */
	/* Why ?? */
	if ((chanidx == FCBS_CHAN_B) && (!pi->phy_fcbs.initialized[FCBS_CHAN_A])) {
		PHY_ERROR(("%s: Error: Chan A has to be initialized before Chan B\n",
			__FUNCTION__));
		return FALSE;
	}
#endif /* LATER */

	PHY_INFORM(("%s: Initting slot %d, channel %d\n",
		__FUNCTION__, chanidx, CHSPEC_CHANNEL(pi->radio_chanspec)));

	pi->phy_fcbs.chanspec[chanidx] = pi->radio_chanspec;

	/* Get the pointer to the PHY specfic FCBS init function */
	fcbs_init = pi->pi_fptr.fcbsinit;

	if (!fcbs_init) {
		PHY_ERROR(("%s: Missing fcbsinit pointer\n", __FUNCTION__));
		pi->phy_fcbs.initialized[chanidx] = FALSE;
		ASSERT(fcbs_init);
		return TRUE;
	}

	wlapi_suspend_mac_and_wait(pi->sh->physhim);

	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Clear the flag which is used by the PHY specific FCBS init code to indicate
	   if the FCBS engine should load the PHY tables and PHY/Radio registers
	*/
	pi->phy_fcbs.load_regs_tbls = FALSE;

	/* Call the PHY specific initialization function. This will update the phy_fcbs
	   fields with the starting h/w address of the on-chip RAM and the shmem locations
	   used by the driver to specify to the ucode, the various offsets within the
	   FCBS cache

	   This function will also set the pointers to the memory buffers used to
	   read the PHY tables and PHY/radio regs. It may also (optionally) load these
	   buffers with the contents of the PHY tables and PHY/Radio regs.
	*/
	pi->phy_fcbs.initialized[chanidx] = (*fcbs_init)(pi, chanidx, pi->radio_chanspec);

	wlc_phyreg_exit((wlc_phy_t *)pi);

	if (pi->phy_fcbs.initialized[chanidx] == TRUE) {
		if (chanidx == FCBS_CHAN_A) {
			/* Reset the BPHY update bit. This is used by
			 * the ucode to determine if BPHY registers
			 * need to be updated during FCBS
			 */
			wlapi_bmac_write_shm(pi->sh->physhim,
			    pi->phy_fcbs.shmem_bphyctrl, 0);

			pi->phy_fcbs.chan_cache_offset[FCBS_CHAN_A] =
			    pi->phy_fcbs.cache_startaddr;

			/* This keeps a count of how many times we did a FCBS */
			pi->phy_fcbs.switch_count = 0;
		}

		if (pi->phy_fcbs.load_regs_tbls) {
			/* The PHY specific FCBS init routine wants
			 * the FCBS engine to read the PHY tables
			 * and PHY/Radio regs
			 */
			wlc_phy_fcbs_read_regs_tbls(pi, chanidx,
			    pi->radio_chanspec);
		}

		pi->phy_fcbs.curr_fcbs_chan = chanidx;

		/* Store the radio registers in the FCBS cache */
		offset = pi->phy_fcbs.chan_cache_offset[chanidx];
		/* Each cache entry contains an address and value */
		len = pi->phy_fcbs.num_radio_regs * 2 * sizeof(uint16);
		pi->phy_fcbs.radioreg_cache_offset[chanidx] = offset;
		wlapi_bmac_write_template_ram(pi->sh->physhim, offset,
		    len, pi->phy_fcbs.radioreg_buf[chanidx]);
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_radioreg, (uint16)len);
		PHY_FCBS(("radio reg buf: start offset=%d, len=%d\n", offset, len));

		/* Store the 16-bit PHY table entries in the FCBS cache */
		offset += len;
		len = pi->phy_fcbs.phytbl16_buflen;
		pi->phy_fcbs.phytbl16_cache_offset[chanidx] = offset;
		/* buffer has to end at 4-byte boundary in the RAM */
		if (((len/4) * 4) != len) {
			len += 2;
		}
		wlapi_bmac_write_template_ram(pi->sh->physhim,
		    offset, len, pi->phy_fcbs.phytbl16_buf[chanidx]);
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phytbl16, (uint16)len);
		PHY_FCBS(("phytbl16: start offset = %d, len = %d\n", offset, len));

		/* Store the 32-bit PHY table entries in the FCBS cache */
		offset += len;
		len = pi->phy_fcbs.phytbl32_buflen;
		pi->phy_fcbs.phytbl32_cache_offset[chanidx] = offset;
		wlapi_bmac_write_template_ram(pi->sh->physhim, offset,
		    len, pi->phy_fcbs.phytbl32_buf[chanidx]);
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phytbl32, (uint16)len);
		PHY_FCBS(("phytbl32: start offset = %d, len = %d\n", offset, len));

		/* Store the PHY registers in the FCBS cache */
		offset += len;
		/* Each cache entry contains an address and value */
		len = pi->phy_fcbs.num_phy_regs * 2 * sizeof(uint16);
		pi->phy_fcbs.phyreg_cache_offset[chanidx] = offset;
		wlapi_bmac_write_template_ram(pi->sh->physhim, offset,
		    len, pi->phy_fcbs.phyreg_buf[chanidx]);

		if (pi->phy_fcbs.num_bphy_regs[chanidx] > 0) {
			/* Store BPHY registers in the cache */
			bphy_offset = offset + len;
			bphy_len = pi->phy_fcbs.num_bphy_regs[chanidx] * sizeof(uint32);
			pi->phy_fcbs.bphyreg_cache_offset[chanidx] = bphy_offset;
			wlapi_bmac_write_template_ram(pi->sh->physhim, bphy_offset,
			    bphy_len, pi->phy_fcbs.bphyreg_buf[chanidx]);
			len += bphy_len;
		}

		pi->phy_fcbs.phyreg_buflen[chanidx] = len;
		wlapi_bmac_write_shm(pi->sh->physhim,
		    pi->phy_fcbs.shmem_phyreg, (uint16)len);
		PHY_FCBS(("PHY reg buf: start offset=%d, len = %d\n", offset, len));

		if (chanidx == FCBS_CHAN_A) {
			/* Now that we have finished storing the
			 * cache for CHAN_A, we know the starting
			 * cache address for CHAN_B
			 */
			pi->phy_fcbs.chan_cache_offset[FCBS_CHAN_B] = offset + len;
		}

		/* Clear the cache pointer in case it had a non-zero value
		 * before the init
		 */
		wlapi_bmac_write_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr, 0);

		wlapi_enable_mac(pi->sh->physhim);
	}
	return TRUE;
}

#define FCBS_MAX_ITERS 200
int wlc_phy_hw_fcbs(wlc_phy_t *ppi, int chanidx, bool set)
{
	uint16 ptr;
	int i;
	fcbspostfn_t post_fcbs = NULL;
	fcbsprefn_t pre_fcbs = NULL;
	fcbsfn_t fcbs = NULL;
	phy_info_t *pi = (phy_info_t*)ppi;

	ASSERT((chanidx >= 0) && (chanidx < MAX_FCBS_CHANS));
	if (!pi->phy_fcbs.initialized[chanidx]) {
		return -1;
	}
	if (!set) {
		return pi->phy_fcbs.curr_fcbs_chan;
	}
	pi->phy_fcbs.curr_fcbs_chan = chanidx;

	/* About to start FCBS. Call the PHY specific pre-FCBS function, if any */
	if ((pre_fcbs = pi->pi_fptr.prefcbs)) {
		(*pre_fcbs)(pi, chanidx);
	}

	if ((fcbs = pi->pi_fptr.fcbs)) {
		(*fcbs)(pi, chanidx);
	}
	/* If we are currently in the 2G band and we are switching to 5G, tell
	   the ucode to turn the BPHY core off
	*/
	if (CHSPEC_IS2G(pi->phy_fcbs.chanspec[pi->phy_fcbs.curr_fcbs_chan])) {
		if (CHSPEC_IS5G(pi->phy_fcbs.chanspec[chanidx])) {
			wlapi_bmac_write_shm(pi->sh->physhim,
			    pi->phy_fcbs.shmem_bphyctrl, FCBS_BPHY_OFF);
		}
	} else {
		/* We are currently in 5G. If we are switching to the 2G band
		   tell the ucode to turn the BPHY core ON
		*/
		if (CHSPEC_IS2G(pi->phy_fcbs.chanspec[chanidx])) {
			wlapi_bmac_write_shm(pi->sh->physhim,
			    pi->phy_fcbs.shmem_bphyctrl, FCBS_BPHY_ON);
		}
	}

	/* If one of the FCBS channel is in the 2G band and the other is in the
	   5G band, then the length of the PHY register cache will be different
	   due to the BPHY register values. In this case update the shmem
	   location with the appropriate value for the channel that we are
	   switching to
	*/
	if (pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_A] !=
		pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_B]) {
		wlapi_bmac_write_shm(pi->sh->physhim,
			pi->phy_fcbs.shmem_phyreg, (uint16)(pi->phy_fcbs.phyreg_buflen[chanidx]));
	}

	/* Now tell the ucode which cache (CHAN_A or CHAN_B) it should use */
	wlapi_bmac_write_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr,
	    (uint16) (pi->phy_fcbs.chan_cache_offset[chanidx]));

	/*
	Wait for ucode to write register tables:
	Using 4331 Rev B0
	Measuring 162 usecs from poking cache_ptr until it reads back 0.
	Each wlapi_bmac_read_shm() call takes 1.8 usecs.
	*/
	OSL_DELAY(100);
	ptr = wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr);
	for (i = 0; ptr != 0 && i < FCBS_MAX_ITERS; i++) {
		OSL_DELAY(1);
		ptr = wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr);
	}
	if (i >= FCBS_MAX_ITERS) {
		PHY_ERROR(("%s: Failed to complete ucode channel switch\n", __FUNCTION__));
	}
	ASSERT(i < FCBS_MAX_ITERS);

	pi->phy_fcbs.switch_count++;

	/* FCBS is done. Call the PHY specific post-FCBS function, if any */
	if ((post_fcbs = pi->pi_fptr.postfcbs)) {
		(*post_fcbs)(pi, chanidx);
	}

	return pi->phy_fcbs.curr_fcbs_chan;
}

int wlc_phy_fcbs(wlc_phy_t *ppi, int chanidx, bool set)
{
	fcbspostfn_t post_fcbs = NULL;
	fcbsprefn_t pre_fcbs = NULL;
	uint16 ptr;
	int i;
	phy_info_t *pi = (phy_info_t*)ppi;
#if defined(FCBS_CPU_PROFILE)
	unsigned long tick1, tick2, tick_diff;
#endif /* FCBS_CPU_PROFILE */

	if (IS_FCBS(pi)) {
		return wlc_phy_hw_fcbs((wlc_phy_t*)pi, chanidx, set);
	}
	ASSERT((chanidx >= 0) && (chanidx < MAX_FCBS_CHANS));

	if (!pi->phy_fcbs.initialized[chanidx]) {
		return -1;
	}

	if (!set) {
		return pi->phy_fcbs.curr_fcbs_chan;
	}

#if defined(FCBS_GPIO_PROFILE)
	/* Assert GPIO 4 before switching */
	si_gpioout(pi->sh->sih, (1 << 4), (1 << 4), GPIO_DRV_PRIORITY);
	si_gpioouten(pi->sh->sih, (1 << 4), (1 << 4), GPIO_DRV_PRIORITY);
#endif /* FCBS_GPIO_PROFILE */

	/* If we are currently in the 2G band and we are switching to 5G, tell
	   the ucode to turn the BPHY core off
	*/
	if (CHSPEC_IS2G(pi->phy_fcbs.chanspec[pi->phy_fcbs.curr_fcbs_chan])) {
		if (CHSPEC_IS5G(pi->phy_fcbs.chanspec[chanidx])) {
			wlapi_bmac_write_shm(pi->sh->physhim,
			    pi->phy_fcbs.shmem_bphyctrl, FCBS_BPHY_OFF);
		}
	} else {
		/* We are currently in 5G. If we are switching to the 2G band
		   tell the ucode to turn the BPHY core ON
		*/
		if (CHSPEC_IS2G(pi->phy_fcbs.chanspec[chanidx])) {
			wlapi_bmac_write_shm(pi->sh->physhim,
			    pi->phy_fcbs.shmem_bphyctrl, FCBS_BPHY_ON);
		}
	}

	pi->phy_fcbs.curr_fcbs_chan = chanidx;

	/* If one of the FCBS channel is in the 2G band and the other is in the
	   5G band, then the length of the PHY register cache will be different
	   due to the BPHY register values. In this case update the shmem
	   location with the appropriate value for the channel that we are
	   switching to
	*/
	if (pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_A] !=
		pi->phy_fcbs.phyreg_buflen[FCBS_CHAN_B]) {
		wlapi_bmac_write_shm(pi->sh->physhim,
			pi->phy_fcbs.shmem_phyreg, (uint16)(pi->phy_fcbs.phyreg_buflen[chanidx]));
	}

	/* About to start FCBS. Call the PHY specific pre-FCBS function, if any */
	if ((pre_fcbs = pi->pi_fptr.prefcbs)) {
		(*pre_fcbs)(pi, chanidx);
	}

	/* Now tell the ucode which cache (CHAN_A or CHAN_B) it should use */
	wlapi_bmac_write_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr,
	    (uint16) (pi->phy_fcbs.chan_cache_offset[chanidx] >> 2));

	pi->phy_fcbs.switch_count++;

#if defined(FCBS_GPIO_PROFILE)
	/* De-assert GPIO 4 after switching */
	si_gpioout(pi->sh->sih, (1 << 4), 0, GPIO_DRV_PRIORITY);
	si_gpioouten(pi->sh->sih, (1 << 4), (1 << 4),
	    GPIO_DRV_PRIORITY);
#endif /* FCBS_GPIO_PROFILE */

#if defined(FCBS_CPU_PROFILE)
	OSL_GETCYCLES(tick1);
#endif /* FCBS_CPU_PROFILE */

	/*
	Wait for ucode to write register tables:
	Using 4331 Rev B0
	Measuring 162 usecs from poking cache_ptr until it reads back 0.
	Each wlapi_bmac_read_shm() call takes 1.8 usecs.
	*/
	OSL_DELAY(100);
	ptr = wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr);
	for (i = 0; ptr != 0 && i < FCBS_MAX_ITERS; i++) {
		OSL_DELAY(1);
		ptr = wlapi_bmac_read_shm(pi->sh->physhim, pi->phy_fcbs.shmem_cache_ptr);
	}
#if defined(FCBS_CPU_PROFILE)
	OSL_GETCYCLES(tick2);
	tick_diff = tick2 - tick1;
	PHY_ERROR(("%s: completed chan %d, %ld usecs\n",
		__FUNCTION__, CHSPEC_CHANNEL(pi->phy_fcbs.chanspec[chanidx]),
		tick_diff/3000)); /* 3 Ghz cpu */
#endif /* FCBS_CPU_PROFILE */
	if (i >= FCBS_MAX_ITERS) {
		PHY_ERROR(("%s: Failed to complete ucode channel switch\n", __FUNCTION__));
	}
	ASSERT(i < FCBS_MAX_ITERS);

	/* FCBS is done. Call the PHY specific post-FCBS function, if any */
	if ((post_fcbs = pi->pi_fptr.postfcbs)) {
		(*post_fcbs)(pi, chanidx);
	}

	return pi->phy_fcbs.curr_fcbs_chan;
}
#endif /* ENABLE_FCBS */

void
wlc_phy_get_SROMnoiselvl_phy(phy_info_t *pi, int8 *noiselvl)
{
	/* Returns noise level (read from srom) for current channel */
	uint8 core;

	if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 14) {
		/* 2G */
		FOREACH_CORE(pi, core) {
			noiselvl[core] = pi->noiselvl_2g[core];
		}
	} else {
#ifdef BAND5G
		/* 5G */
		if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 48) {
			/* 5G-low: channels 36 through 48 */
			FOREACH_CORE(pi, core) {
				noiselvl[core] = pi->noiselvl_5gl[core];
			}
		} else if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 64) {
			/* 5G-mid: channels 52 through 64 */
			FOREACH_CORE(pi, core) {
				noiselvl[core] = pi->noiselvl_5gm[core];
			}
		} else if (CHSPEC_CHANNEL(pi->radio_chanspec) <= 128) {
			/* 5G-high: channels 100 through 128 */
			FOREACH_CORE(pi, core) {
				noiselvl[core] = pi->noiselvl_5gh[core];
			}
		} else {
			/* 5G-upper: channels 132 and above */
			FOREACH_CORE(pi, core) {
				noiselvl[core] = pi->noiselvl_5gu[core];
			}
		}
#endif /* BAND5G */
	}
}

void
wlc_phy_upd_gain_wrt_temp_phy(phy_info_t *pi, int16 *gain_err_temp_adj)
{
	*gain_err_temp_adj = 0;

	/* now, adjust for temperature */
	if ((ISNPHY(pi) &&
	     (NREV_GE(pi->pubpi.phy_rev, 3) &&
	      NREV_LE(pi->pubpi.phy_rev, 6))) || ISHTPHY(pi) || ISACPHY(pi)) {
		/* read in the temperature */
		int16 temp_diff, curr_temp = 0, gain_temp_slope = 0;

		if (ISNPHY(pi)) {
			/* make sure mac is suspended before calling tempsense */
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			curr_temp = wlc_phy_tempsense_nphy(pi);
			wlapi_enable_mac(pi->sh->physhim);
		} else if (ISHTPHY(pi)) {
			curr_temp = pi->u.pi_htphy->current_temperature;
		} else if (ISACPHY(pi)) {
		  curr_temp = pi->u.pi_acphy->current_temperature;
		}

		curr_temp = MIN(MAX(curr_temp, PHY_TEMPSENSE_MIN), PHY_TEMPSENSE_MAX);

		/* check that non programmed SROM for cal temp are not changed */
		if (pi->srom_rawtempsense != 255) {
			temp_diff = curr_temp - pi->srom_rawtempsense;
		} else {
			temp_diff = 0;
		}

		/* adjust gain based on the temperature difference now vs. calibration time:
		 * make gain diff rounded to nearest 0.25 dbm, where 1 tick is 0.25 dbm
		 */
		if (ISNPHY(pi)) {
			gain_temp_slope = CHSPEC_IS2G(pi->radio_chanspec) ?
			        NPHY_GAIN_VS_TEMP_SLOPE_2G : NPHY_GAIN_VS_TEMP_SLOPE_5G;
		} else if (ISHTPHY(pi)) {
			gain_temp_slope = CHSPEC_IS2G(pi->radio_chanspec) ?
			        HTPHY_GAIN_VS_TEMP_SLOPE_2G : HTPHY_GAIN_VS_TEMP_SLOPE_5G;
		} else if (ISACPHY(pi)) {
			gain_temp_slope = CHSPEC_IS2G(pi->radio_chanspec) ?
			        ACPHY_GAIN_VS_TEMP_SLOPE_2G : ACPHY_GAIN_VS_TEMP_SLOPE_5G;
		}

		if (temp_diff >= 0) {
			*gain_err_temp_adj = (temp_diff * gain_temp_slope*2 + 25)/50;
		} else {
			*gain_err_temp_adj = (temp_diff * gain_temp_slope*2 - 25)/50;
		}
	}

#ifdef WLTEST
	if (ISLCN40PHY(pi)) {
		*gain_err_temp_adj  = wlc_lcn40phy_rxgaincal_tempadj(pi);
	}
#endif // endif

}

void
wlc_phy_upd_gain_wrt_gain_cal_temp_phy(phy_info_t *pi, int16 *gain_err_temp_adj, int core)
{
#ifdef WL11AC
	/* now, adjust for temperature */

	/* read in the temperature */
	int16 temp_diff, curr_temp = 0, gain_temp_slope = 0;
	int16 subband_idx;

	*gain_err_temp_adj = 0;

	curr_temp = pi->u.pi_acphy->current_temperature;

	curr_temp = MIN(MAX(curr_temp, PHY_TEMPSENSE_MIN_RSSI_CAL_REV_1), PHY_TEMPSENSE_MAX);

	/* check that non programmed SROM for cal temp are not changed */
	if (pi->srom_gain_cal_temp != 255) {
		temp_diff = curr_temp - pi->srom_gain_cal_temp;
	} else {
		temp_diff = 0;
	}

	/* adjust gain based on the temperature difference now vs. calibration time:
	* make gain diff rounded to nearest 0.25 dbm, where 1 tick is 0.25 dbm
	*/
	subband_idx = wlc_phy_rssi_get_chan_freq_range_acphy(pi,
		CHSPEC_CHANNEL(pi->radio_chanspec));
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		gain_temp_slope = pi->u.pi_acphy->srom.rxgain_tempadj_2g_sub[core][subband_idx];
	} else {
		if (subband_idx == 0) {
			gain_temp_slope =
			  pi->u.pi_acphy->srom.rxgain_tempadj_5gl[core];
		} else if (subband_idx == 1) {
			gain_temp_slope =
			  pi->u.pi_acphy->srom.rxgain_tempadj_5gml[core];
		} else if (subband_idx == 2) {
			gain_temp_slope =
			  pi->u.pi_acphy->srom.rxgain_tempadj_5gmu[core];
		} else if (subband_idx == 3) {
			gain_temp_slope =
			  pi->u.pi_acphy->srom.rxgain_tempadj_5gh[core];
		}
	}

	if (temp_diff >= 0) {
		*gain_err_temp_adj = (temp_diff * gain_temp_slope*2 + 250)/500;
	} else {
		*gain_err_temp_adj = (temp_diff * gain_temp_slope*2 - 250)/500;
	}
#endif /* WL11AC */
}

#ifdef WLTEST
void
wlc_phy_pkteng_boostackpwr(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISLCN40PHY(pi) && (pi->boostackpwr == 1)) {
		pi->pi_fptr.settxpwrbyindex(pi, (int)0);
	}
}
#endif /* ifdef WLTEST */

#ifdef LP_P2P_SOFTAP
uint8
BCMATTACHFN(wlc_lcnphy_get_index)(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
		phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
		int8 offset = pi_lcn->pwr_offset_val;
		uint8 i;

		if (offset) {
			/* Search for the offset */
			for (i = 0;
				(i < LCNPHY_TX_PWR_CTRL_MACLUT_LEN) && (-offset >= pwr_lvl_qdB[i]);
				i++);
			return --i;
		}
	}

	/* For other PHYs return 0: Nominal power */
	return 0;
}
#endif /* LP_P2P_SOFTAP */

#if defined(BCMDBG) || defined(DBG_PHYTXERR)
void
wlc_acphy_txerr_dump(uint16 PhyErr)
{
	char flagstr[128];
	const bcm_bit_desc_t attr_flags_phy_err[] = {
		{ACPHY_TxError_NDPError_MASK(0), "NDPError"},
		{ACPHY_TxError_RsvdBitError_MASK(0), "RsvdBitError"},
		{ACPHY_TxError_illegal_frame_type_MASK(0), "Illegal frame type"},
		{ACPHY_TxError_COMBUnsupport_MASK(0), "COMBUnsupport"},
		{ACPHY_TxError_BWUnsupport_MASK(0), "BWUnsupport"},
		{ACPHY_TxError_txInCal_MASK(0), "txInCal_MASK"},
		{ACPHY_TxError_send_frame_low_MASK(0), "send_frame_low"},
		{ACPHY_TxError_lengthmismatch_short_MASK(0), "lengthmismatch_short"},
		{ACPHY_TxError_lengthmismatch_long_MASK(0), "lengthmismatch_long"},
		{ACPHY_TxError_invalidRate_MASK(0), "invalidRate_MASK"},
		{ACPHY_TxError_unsupportedmcs_MASK(0), "unsupported mcs"},
		{ACPHY_TxError_send_frame_low_MASK(0), "send_frame_low"},
		{0, NULL}
	};
	if (PhyErr) {
		bcm_format_flags(attr_flags_phy_err, PhyErr, flagstr, 128);
		printf("Tx PhyErr 0x%04x (%s)\n", PhyErr, flagstr);
	}
}

void
wlc_htphy_txerr_dump(uint16 PhyErr)
{
	char flagstr[128];
	const bcm_bit_desc_t attr_flags_phy_err[] = {
		{HTPHY_TxError_NDPError_MASK, "NDPError"},
		{HTPHY_TxError_illegal_frame_type_MASK, "Illegal frame type"},
		{HTPHY_TxError_COMBUnsupport_MASK, "COMBUnsupport"},
		{HTPHY_TxError_BWUnsupport_MASK, "BWUnsupport"},
		{HTPHY_TxError_txInCal_MASK, "txInCal_MASK"},
		{HTPHY_TxError_send_frame_low_MASK, "send_frame_low"},
		{HTPHY_TxError_lengthmismatch_short_MASK, "lengthmismatch_short"},
		{HTPHY_TxError_lengthmismatch_long_MASK, "lengthmismatch_long"},
		{HTPHY_TxError_invalidRate_MASK, "invalidRate_MASK"},
		{0, NULL}
	};
	if (PhyErr) {
		bcm_format_flags(attr_flags_phy_err, PhyErr, flagstr, 128);
		printf("Tx PhyErr 0x%04x (%s)\n", PhyErr, flagstr);
	}
}
#endif /* BCMDBG || DBG_PHYTXERR */

#ifdef WL_LPC
uint8
wlc_phy_lpc_getminidx(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.lpcgetminidx)
		return (*pi->pi_fptr.lpcgetminidx)();
	return 0;
}

uint8
wlc_phy_lpc_getoffset(wlc_phy_t *ppi, uint8 index)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.lpcgetpwros)
		return (*pi->pi_fptr.lpcgetpwros)(index);
	return 0;
}

uint8
wlc_phy_lpc_get_txcpwrval(wlc_phy_t *ppi, uint16 phytxctrlword)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.lpcgettxcpwrval)
		return (*pi->pi_fptr.lpcgettxcpwrval)(phytxctrlword);
	return 0;
}

void
wlc_phy_lpc_set_txcpwrval(wlc_phy_t *ppi, uint16 *phytxctrlword, uint8 txcpwrval)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.lpcsettxcpwrval)
		(*pi->pi_fptr.lpcsettxcpwrval)(phytxctrlword, txcpwrval);
	return;
}

void
wlc_phy_lpc_algo_set(wlc_phy_t *ppi, bool enable)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	pi->lpc_algo = enable;
	if (pi->pi_fptr.lpcsetmode)
		(*pi->pi_fptr.lpcsetmode)(pi, enable);
	return;
}

#ifdef WL_LPC_DEBUG
uint8 *
wlc_phy_lpc_get_pwrlevelptr(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.lpcgetpwrlevelptr)
		return (*pi->pi_fptr.lpcgetpwrlevelptr)();
	return 0;
}
#endif // endif
#endif /* WL_LPC */

#if defined(WLC_LOWPOWER_BEACON_MODE)
void
wlc_phy_lowpower_beacon_mode(wlc_phy_t *pih, int lowpower_beacon_mode)
{
	phy_info_t *pi = (phy_info_t *)pih;
	if (pi->pi_fptr.lowpowerbeaconmode)
		pi->pi_fptr.lowpowerbeaconmode(pi, lowpower_beacon_mode);
}
#endif /* WLC_LOWPOWER_BEACON_MODE */

/* block bbpll change if ILP cal is in progress */
void
wlc_phy_block_bbpll_change(wlc_phy_t *pih, bool block, bool going_down)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (block) {
		pi->block_for_slowcal = TRUE;
	} else {
		pi->block_for_slowcal = FALSE;

		if (pi->blocked_freq_for_slowcal && ISACPHY(pi) && !going_down) {
			wlc_phy_set_spurmode(pi, pi->blocked_freq_for_slowcal);
		} else if (pi->blocked_freq_for_slowcal && ISNPHY(pi) && !going_down) {
			wlc_phy_set_spurmode_nphy(pi, pi->blocked_freq_for_slowcal);
		}
	}

}

#ifdef WLTXPWR_CACHE
void wlc_phy_clear_tx_power_offset(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

/*	if ((pi->tx_power_offset != NULL) &&
		(!wlc_phy_is_pwr_cached(pi->txpwr_cache, TXPWR_CACHE_POWER_OFFSETS,
		pi->tx_power_offset))) {
		ppr_delete(pi->sh->osh, pi->tx_power_offset);
	}
*/
	pi->tx_power_offset = NULL;
}
#endif /* WLTXPWR_CACHE */

void
wlc_phy_btcx_wlan_critical_enter(phy_info_t *pi)
{
	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_WLAN_CRITICAL, MHF1_WLAN_CRITICAL, WLC_BAND_2G);
}

void
wlc_phy_btcx_wlan_critical_exit(phy_info_t *pi)
{
	wlapi_bmac_mhf(pi->sh->physhim, MHF1, MHF1_WLAN_CRITICAL, 0, WLC_BAND_2G);
}

void
wlc_phy_trigger_cals_for_btc_adjust(phy_info_t *pi)
{
	wlc_phy_cal_perical_mphase_reset(pi);
	if (ISNPHY(pi)) {
		pi->u.pi_nphy->cal_type_override = PHY_PERICAL_FULL;
	}
	wlc_phy_cal_perical_mphase_schedule(pi, PHY_PERICAL_NODELAY);
}

void
wlc_phy_set_femctrl_bt_wlan_ovrd(wlc_phy_t *pih, int8 state)
{
	phy_info_t *pi = (phy_info_t *)pih;

	if (ISACPHY(pi))
	  {
	    pi->u.pi_acphy->bt_sw_state = state;
	    wlc_phy_set_femctrl_bt_wlan_ovrd_acphy(pi, state);
	  }
}

int8
wlc_phy_get_femctrl_bt_wlan_ovrd(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	int8 state = AUTO;

	if (ISACPHY(pi))
		state = wlc_phy_get_femctrl_bt_wlan_ovrd_acphy(pi);

	return state;
}

#ifdef PREASSOC_PWRCTRL
void
wlc_phy_store_tx_pwrctrl_setting(phy_info_t *pi, chanspec_t previous_chanspec)
{
	if (!pi->sh->up)
		return;
	if (ISACPHY(pi)) {
		wlc_phy_store_tx_pwrctrl_setting_acphy(pi, previous_chanspec);
	}
}
void
wlc_phy_pwrctrl_shortwindow_upd(phy_info_t *pi, bool new_channel)
{
	uint8 offset;
	uint32 txallfrm_cnt, txallfrm_diff;
	if ((!ISACPHY(pi)) || (!pi->sh->up))
		return;
	offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, txallfrm);
	/* default is long term */
	pi->channel_short_window = FALSE;

	wlc_phyreg_enter((wlc_phy_t *)pi);
	if (new_channel) {
		wlc_phy_pwrctrl_shortwindow_upd_acphy(pi, TRUE);
		pi->channel_short_window = TRUE;
		pi->txallfrm_cnt_ref = wlapi_bmac_read_shm(pi->sh->physhim, offset);
	} else {
		txallfrm_cnt = wlapi_bmac_read_shm(pi->sh->physhim, offset);
		if (pi->txallfrm_cnt_ref > txallfrm_cnt) {
			pi->txallfrm_cnt_ref = 0;
		} else {
			txallfrm_diff = txallfrm_cnt - pi->txallfrm_cnt_ref;
			if (txallfrm_diff > NUM_FRAME_BEFORE_PWRCTRL_CHANGE) {
				wlc_phy_pwrctrl_shortwindow_upd_acphy(pi, FALSE);
				pi->channel_short_window = FALSE;

			} else {
				wlc_phy_pwrctrl_shortwindow_upd_acphy(pi, TRUE);
				pi->channel_short_window = TRUE;
			}
		}
	}
	wlc_phyreg_exit((wlc_phy_t *)pi);
}
#endif /* PREASSOC_PWRCTRL */

int wlc_phy_tssivisible_thresh(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	int visi_thresh_qdbm;

	if (ISACPHY(pi) && !(ACMAJORREV_2(pi->pubpi.phy_rev) &&
		pi->olpc_idx_in_use && pi->olpc_idx_valid))
		/* For 4350 disable OLPC in olpc_engine */
		visi_thresh_qdbm = wlc_phy_tssivisible_thresh_acphy(pi);
	else visi_thresh_qdbm = -128;
	return visi_thresh_qdbm;
}

#ifdef WLSRVSDB
#ifdef WFD_PHY_LL
int
wlc_phy_sr_vsdb_invalidate_active(wlc_phy_t * ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (pi->srvsdb_state.sr_vsdb_channels[0] ==
	    CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)) {
		pi->srvsdb_state.swbkp_snapshot_valid[0] = 0;
		return 0;
	}
	else if (pi->srvsdb_state.sr_vsdb_channels[1] ==
	         CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)) {
		pi->srvsdb_state.swbkp_snapshot_valid[1] = 0;
		return 1;
	}

	return -1;
}
#endif /* WFD_PHY_LL */

void
wlc_phy_sr_vsdb_reset(wlc_phy_t * ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	pi->srvsdb_state.swbkp_snapshot_valid[0] = 0;
	pi->srvsdb_state.swbkp_snapshot_valid[1] = 0;
	pi->srvsdb_state.sr_vsdb_bank_valid[0] = FALSE;
	pi->srvsdb_state.sr_vsdb_bank_valid[1] = FALSE;
	pi->srvsdb_state.prev_chanspec = CHANNEL_UNDEFINED;
	pi->srvsdb_state.vsdb_trig_cnt = 0;
}

/** reset SR VSDB hw */
void
wlc_phy_reset_srvsdb_engine(wlc_phy_t *ppi)
{
	uint origidx;
	chipcregs_t *cc;
	si_t *sih;
	phy_info_t *pi = (phy_info_t*)ppi;

	sih = (si_t*)pi->sh->sih;

	origidx = si_coreidx(sih);

	/* setcore to chipcmn */
	cc = si_setcoreidx(sih, SI_CC_IDX);

	/* Jira-SWWLAN-28550: A fix of Sr related changes from B0 to B1 created a problem for VSDB
	For VSDB, Bit 9 of PMU chip control 2 gates off the clock to the SR engine, in VSDB
	mode this Bit is always SET.
	Fix: RESET the Bit Before SRVSDB, and SET it back after SRVSDB, this is done presently
	only for 4324B4 chips
	*/
	if (CHIP_4324_B4(pi)) {
		uint32 temp, temp1;
		W_REG(si_osh(sih), &cc->chipcontrol_addr, 2);
		temp = R_REG(si_osh(sih), &cc->chipcontrol_data);
		temp1 = temp & 0xFFFFFDFF;
		W_REG(si_osh(sih), &cc->chipcontrol_data, temp1);
	}

	/* Reset 2nd bit */
	sr_chipcontrol(sih, 0x4, 0x0);
	/* Set 2nd bit */
	sr_chipcontrol(sih, 0x4, 0x4);

	/* Jira-SWWLAN-28550: A fix of Sr related changes from B0 to B1 created a problem for VSDB
	For VSDB, Bit 9 of PMU chip control 2 gates off the clock to the SR engine, in VSDB
	mode this Bit is always SET.
	Fix: RESET the Bit Before SRVSDB, and SET it back after SRVSDB, this is done presently
	only for 4324B4 chips
	*/
	if (CHIP_4324_B4(pi)) {
		uint32 temp, temp1;
		W_REG(si_osh(sih), &cc->chipcontrol_addr, 2);
		temp = R_REG(si_osh(sih), &cc->chipcontrol_data);
		temp1 = temp | 0x200;
		W_REG(si_osh(sih), &cc->chipcontrol_data, temp1);
	}

	/* Set core orig core */
	si_setcoreidx(sih, origidx);

}

void
wlc_phy_force_vsdb_chans(wlc_phy_t *ppi, uint16* vsdb_chans, uint8 set)
{
	uint16 chans[2];
	phy_info_t *pi = (phy_info_t*)ppi;

	if (set) {
		pi->srvsdb_state.force_vsdb = 1;

		bcopy(vsdb_chans, chans, 2*sizeof(uint16));

		wlc_phy_attach_srvsdb_module(ppi, chans[0], chans[1]);

		pi->srvsdb_state.prev_chanspec = chans[0];
		pi->srvsdb_state.force_vsdb_chans[0] = chans[0];
		pi->srvsdb_state.force_vsdb_chans[1] = chans[1];

	} else {
		wlc_phy_detach_srvsdb_module(ppi);

		/* Reset force vsdb chans */
		pi->srvsdb_state.force_vsdb_chans[0] = 0;
		pi->srvsdb_state.force_vsdb_chans[1] = 0;
		pi->srvsdb_state.force_vsdb = 0;
	}
}

void
wlc_phy_detach_srvsdb_module(wlc_phy_t *ppi)
{
	uint8 i;
	phy_info_t *pi = (phy_info_t*)ppi;

	/* Disable the flags */
	wlc_phy_sr_vsdb_reset(ppi);

	for (i = 0; i < SR_MEMORY_BANK; i++) {
		if (pi->vsdb_bkp[i] != NULL) {
			if (pi->vsdb_bkp[i]->pi_nphy != NULL) {
				MFREE(pi->sh->osh, pi->vsdb_bkp[i]->pi_nphy,
					sizeof(phy_info_nphy_t));

				pi->vsdb_bkp[i]->pi_nphy = NULL;
			}

			if (pi->vsdb_bkp[i]->tx_power_offset != NULL)
				ppr_delete(pi->sh->osh, pi->vsdb_bkp[i]->tx_power_offset);
#ifdef WLTXPWR_PER_CORE
			if (pi->vsdb_bkp[i]->p_openlp_tx_power_min != NULL) {
				MFREE(pi->vsdb_bkp[i]->p_openlp_tx_power_min, WL_TXPWR_CORE_MAX);
				pi->vsdb_bkp[i]->p_openlp_tx_power_min = NULL;
			}
#endif /* WLTXPWR_PER_CORE */
			MFREE(pi->sh->osh, pi->vsdb_bkp[i], sizeof(vsdb_backup_t));
			pi->vsdb_bkp[i] = NULL;
			PHY_INFORM(("de allocate %d of mem \n", (sizeof(vsdb_backup_t) +
				sizeof(phy_info_nphy_t))));
		}
	}
	pi->srvsdb_state.sr_vsdb_channels[0] = 0;
	pi->srvsdb_state.sr_vsdb_channels[1] = 0;
	pi->srvsdb_state.srvsdb_active = 0;

	pi->srvsdb_state.acimode_noisemode_reset_done[0] = FALSE;
	pi->srvsdb_state.acimode_noisemode_reset_done[1] = FALSE;

	/* srvsdb switch status */
	pi->srvsdb_state.switch_successful = FALSE;

	/* Timers */
	bzero(pi->srvsdb_state.prev_timer, 2 * sizeof(uint32));
	bzero(pi->srvsdb_state.sum_delta_timer, 2 * sizeof(uint32));

	/* counter for no of switch iterations */
	bzero(pi->srvsdb_state.num_chan_switch, 2 * sizeof(uint8));

	/* crsglitch */
	bzero(pi->srvsdb_state.prev_crsglitch_cnt, 2 * sizeof(uint32));
	bzero(pi->srvsdb_state.sum_delta_crsglitch, 2 * sizeof(uint32));
	/* bphy_crsglitch */
	bzero(pi->srvsdb_state.prev_bphy_rxcrsglitch_cnt, 2 * sizeof(uint32));
	bzero(pi->srvsdb_state.sum_delta_bphy_crsglitch, 2 * sizeof(uint32));
	/* badplcp */
	bzero(pi->srvsdb_state.prev_badplcp_cnt, 2 * sizeof(uint32));
	bzero(pi->srvsdb_state.sum_delta_prev_badplcp, 2 * sizeof(uint32));
	/* bphy_badplcp */
	bzero(pi->srvsdb_state.prev_bphy_badplcp_cnt, 2 * sizeof(uint32));
	bzero(pi->srvsdb_state.sum_delta_prev_bphy_badplcp, 2 * sizeof(uint32));
}

/**
 * Despite the 'attach' in its name: is not meant to be called in the 'attach' phase.
 * Returns TRUE on success. Caller supplied arguments chan0 and chan1 may not reside in the same
 * band.
 */
uint8
wlc_phy_attach_srvsdb_module(wlc_phy_t *ppi, chanspec_t chan0, chanspec_t chan1)
{

	uint8 i;
	phy_info_t *pi = (phy_info_t*)ppi;

	/* Detach allready existing structire */
	wlc_phy_detach_srvsdb_module(ppi);

	/* reset srvsdb enigne */
	wlc_phy_reset_srvsdb_engine(ppi);

	/* Alloc mem for sw backup structures */
	for (i = 0; i < SR_MEMORY_BANK; i++) {
		if ((pi->vsdb_bkp[i] = (vsdb_backup_t*)MALLOC(pi->sh->osh,
			sizeof(vsdb_backup_t))) == NULL) {

			PHY_ERROR(("SRVSDB: MEM alloc fail for vsdb_backup_t\n"));
			ASSERT(0);
			return FALSE;
		}

		bzero(pi->vsdb_bkp[i], sizeof(vsdb_backup_t));

		if ((pi->vsdb_bkp[i]->pi_nphy = (phy_info_nphy_t *)MALLOC(pi->sh->osh,
			sizeof(phy_info_nphy_t))) == NULL) {

			PHY_ERROR(("SRVSDB: MEM alloc fail for phy_info_nphy_t\n"));
			ASSERT(0);
			MFREE(pi->sh->osh, pi->vsdb_bkp[i], sizeof(vsdb_backup_t));
			return FALSE;
		}
		bzero(pi->vsdb_bkp[i]->pi_nphy, sizeof(phy_info_nphy_t));

#ifdef WLTXPWR_PER_CORE
		if ((pi->vsdb_bkp[i]->p_openlp_tx_power_min = (int8 *)MALLOCZ(pi->sh->osh,
			WL_TXPWR_CORE_MAX)) == NULL) {

			PHY_ERROR(("SRVSDB: MEM alloc fail for p_openlp_tx_power_min\n"));
			ASSERT(0);
			MFREE(pi->sh->osh, pi->vsdb_bkp[i]->pi_nphy, sizeof(phy_info_nphy_t));
			MFREE(pi->sh->osh, pi->vsdb_bkp[i], sizeof(vsdb_backup_t));
			return FALSE;
		}

		PHY_INFORM(("allocate %d of mem \n", (sizeof(vsdb_backup_t) +
			sizeof(phy_info_nphy_t) + WL_TXPWR_CORE_MAX)));
#else
		PHY_INFORM(("allocate %d of mem \n", (sizeof(vsdb_backup_t) +
			sizeof(phy_info_nphy_t))));
#endif /* WLTXPWR_PER_CORE */
	}

	pi->srvsdb_state.sr_vsdb_channels[0] = CHSPEC_CHANNEL(chan0);
	pi->srvsdb_state.sr_vsdb_channels[1] = CHSPEC_CHANNEL(chan1);
	pi->srvsdb_state.srvsdb_active = 1;

	return TRUE;
}
#endif /* WLSRVSDB */

/**
 * Reduce channel switch time by attempting to use hardware acceleration.
 */
uint8
wlc_set_chanspec_sr_vsdb(wlc_phy_t *ppi, chanspec_t chanspec, uint8 *last_chan_saved)
{
	uint8 switched = FALSE;

#ifdef WLSRVSDB
	phy_info_t *pi = (phy_info_t*)ppi;

	switched = wlc_set_chanspec_sr_vsdb_nphy(pi, chanspec, last_chan_saved);

#if defined(WLTXPWR_CACHE) && defined(WLC_LOW_ONLY)
	if (switched) {
		/*
		 * For split MAC driver, for faster channel switching, reserve an entry for the new
		 * channel.
		 */
		wlc_phy_pwr_cache_reserve(pi, chanspec);
	}
#endif /* WLTXPWR_CACHE && WLC_LOW_ONLY */
#endif /* WLSRVSDB */
	return switched;
}

void wlc_phy_clear_match_tx_offset(wlc_phy_t *ppi, ppr_t *pprptr)
{
	if (ppi != NULL) {
		phy_info_t *pi = (phy_info_t*)ppi;
		if (pprptr == pi->tx_power_offset)
			pi->tx_power_offset = NULL;
	}
}

#ifdef ATE_BUILD
void
wlc_ate_gpiosel_disable(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISACPHY(pi) && ACMAJORREV_3(pi->pubpi.phy_rev)) {
		wlc_phyreg_enter(ppi);
		phy_reg_write(pi, ACPHY_gpioLoOutEn(pi->pubpi.phy_rev), 0);
		phy_reg_write(pi, ACPHY_gpioHiOutEn(pi->pubpi.phy_rev), 0);
		wlc_phyreg_exit(ppi);
	} else {
		/* Not supported for other PHYs yet */
		ASSERT(FALSE);
	}
}
#endif /* ATE_BUILD */

#if defined(RXDESENS_EN)
/* Main wrapper for dynamic phy rxdesens */
void
wlc_phy_rxdesens(wlc_phy_t *ppi, bool densens_en)
{
	phy_info_t *pi = (phy_info_t *)ppi;
#ifdef WLSRVSDB
	bool invalidate_swbkp = FALSE;
#endif // endif

	if (CHSPEC_IS5G(pi->radio_chanspec))
		return;

	if (pi->sh->phyrxdesens == 0)
		return;

	if (densens_en) {
#ifndef WLC_DISABLE_ACI
		if (pi->sh->interference_mode != INTERFERE_NONE) {
			/* disable interference */
			wlc_phy_interference(pi, INTERFERE_NONE, TRUE);
			pi->sh->saved_interference_mode = pi->sh->interference_mode;
			pi->sh->interference_mode = INTERFERE_NONE;
#ifdef WLSRVSDB
			invalidate_swbkp = TRUE;
#endif // endif
		}
#endif /* !defined(WLC_DISABLE_ACI) */
		/* apply densens */
		wlc_nphy_set_rxdesens((wlc_phy_t *)pi, pi->sh->phyrxdesens);
		pi->u.pi_nphy->ntd_rxdesens_active = TRUE;
		PHY_INFORM(("%s: applied desens on Ch %d |"
			" phyreg 0x21 %x | 0x283: %x | 0x4aa: %x\n",
			__FUNCTION__, CHSPEC_CHANNEL(pi->radio_chanspec),
			phy_reg_read(pi, 0x21), phy_reg_read(pi, 0x283),
			phy_reg_read(pi, 0x4aa)));
	} else {
		/* remove desens */
		wlc_nphy_set_rxdesens((wlc_phy_t *)pi, 0);
		pi->u.pi_nphy->ntd_rxdesens_active = FALSE;
		PHY_INFORM(("%s: removed desens on Ch %d |"
			" phyreg 0x21: %x | 0x283: %x | 0x4aa: %x\n",
			__FUNCTION__, CHSPEC_CHANNEL(pi->radio_chanspec),
			phy_reg_read(pi, 0x21), phy_reg_read(pi, 0x283),
			phy_reg_read(pi, 0x4aa)));
#ifndef WLC_DISABLE_ACI
		/* enable interference */
		pi->sh->interference_mode = pi->sh->saved_interference_mode;
		wlc_phy_interference(pi, pi->sh->interference_mode, TRUE);
#ifdef WLSRVSDB
		invalidate_swbkp = TRUE;
#endif // endif
#endif /* !defined(WLC_DISABLE_ACI) */
	}

#ifdef WLSRVSDB
	if (invalidate_swbkp) {
		/* invalidate swbkp to update per cfg phyrxdesens & interference_mode */
		if (pi->srvsdb_state.sr_vsdb_channels[0] ==
			CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)) {

			pi->srvsdb_state.swbkp_snapshot_valid[0] = 0;
			PHY_INFORM(("invalidating swbkp for Ch %d\n",
				CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)));

		} else if (pi->srvsdb_state.sr_vsdb_channels[1] ==
			CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)) {

			pi->srvsdb_state.swbkp_snapshot_valid[1] = 0;
			PHY_INFORM(("invalidating swbkp for Ch %d\n",
				CHSPEC_CHANNEL(pi->srvsdb_state.prev_chanspec)));
		}
	}
#endif /* defined(WLSRVSDB) */
}
#ifdef WLSRVSDB
/* Returns a flag to defer dynamic rxdesens if srvsdb engine
 * is not ready or SW backup is not taken.
 */
bool
wlc_phy_rxdesens_defer(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	int i = 0;
	bool defer = FALSE;

	for (i = 0; i < 2; i++) {
		if (pi->srvsdb_state.srvsdb_active &&
			!pi->srvsdb_state.swbkp_snapshot_valid[i]) {
			defer = TRUE;
			break;
		}
	}
	return defer;
}
#endif /* WLSRVSDB */
#endif /* RXDESENS_EN */

#if defined(WLMCHAN)
/* Returns a flag to reset aci and noise mitigation states (in vsdb mode) when back in home chanspec
 * to ensure corruption free sw backup and hardware state save/restore.
 */
bool
wlc_phy_acimode_noisemode_reset_allowed(wlc_phy_t *ppi, uint16 home_channel)
{
	bool allow = FALSE;
#if !defined(WLC_DISABLE_ACI) && defined(WLSRVSDB)
	phy_info_t *pi = (phy_info_t *)ppi;

	int i = 0;
	for (i = 0; i < 2; i++)
		if ((pi->srvsdb_state.sr_vsdb_channels[i] == home_channel) &&
			(!pi->srvsdb_state.swbkp_snapshot_valid[i]) &&
			(!pi->srvsdb_state.acimode_noisemode_reset_done[i])) {
			allow = TRUE;
			pi->srvsdb_state.acimode_noisemode_reset_done[i] = TRUE;
			break;
		}
#endif // endif
	return allow;
}

#ifdef WLSRVSDB
bool
wlc_phy_srvsdb_switch_status(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	return pi->srvsdb_state.switch_successful;
}
#endif /* WLSRVSDB */
#endif /* defined(WLMCHAN) */

#ifdef ATE_BUILD
void
wlc_phy_gpaio(wlc_phy_t *ppi, wl_gpaio_option_t option)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (pi->pi_fptr.gpaioconfigptr) {
		return (*pi->pi_fptr.gpaioconfigptr)(pi, option);
	}
	return;
}
#endif // endif

#ifdef	WL_DYNAMIC_TEMPSENSE
#if defined(BCMDBG) || defined(WLTEST)
int
wlc_phy_temperature_override(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	return  pi->tempsense_override;
}
#endif /* BCMDBG || WLTEST */

int
wlc_phy_temperature_threshold(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	return pi->txcore_temp.disable_temp;
}

/*
 * Move this to wlc_phy_cmn.c and do it based on PHY
 * This function DOES NOT calculate temperature and it also DOES NOT
 * read any register from MAC and/or RADIO. This function returns
 * last recorded temperature that is stored in phy_info_t.
 * There are few types of phy that DO NOT record last temperature
 * but derives it based on various other mechnism. This function
 * returns BCME_RANGE for such type of PHY. So that the code would
 * continue as per old fashioned tempsense mechanism at every 10S.
 */
int
wlc_phy_current_temperature(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	int ct = BCME_RANGE;

	if (pi->txcore_temp.heatedup) {
		return BCME_RANGE; /* Indicate we are already heated up */
	}
	if (ISHTPHY(pi))
		ct = pi->u.pi_htphy->current_temperature;
	if (ISACPHY(pi))
		ct = pi->u.pi_acphy->current_temperature;

	if (ct >= (pi->txcore_temp.disable_temp))
		return BCME_RANGE;
	return ct;
}
#endif /* WL_DYNAMIC_TEMPSENSE */

#ifdef WLC_TXDIVERSITY
/*
 * Returns Oclscd Enable status
 */
uint8
wlc_phy_get_oclscdenable_status(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *)pih;
	return pi->nphy_oclscd;
}
#endif /* WLC_TXDIVERSITY */

void
wlc_phy_update_link_rssi(wlc_phy_t *pih, int8 rssi)
{
	phy_info_t *pi = (phy_info_t*)pih;

	pi->interf.link_rssi = rssi;
}

static void
BCMATTACHFN(wlc_phy_interference_mode_attach)(phy_info_t *pi, int bandtype)
{
	pi->interf.curr_home_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
	pi->sh->interference_mode_override = FALSE;
	pi->sh->interference_mode_2G = INTERFERE_NONE;
	pi->sh->interference_mode_5G = INTERFERE_NONE;

	pi->aci_exit_check_period = (ISNPHY(pi) || ISHTPHY(pi)) ? 15 : 60;
	pi->aci_enter_check_period = 16;
	pi->aci_state = 0;

	if (ISACPHY(pi))
		wlc_phy_interference_mode_attach_acphy(pi);
	else if (ISNPHY(pi))
		wlc_phy_interference_mode_attach_nphy(pi);
	else if (ISHTPHY(pi))
		wlc_phy_interference_mode_attach_htphy(pi);
	else if (ISLCNPHY(pi))
		wlc_phy_interference_mode_attach_lcnphy(pi);
	else if (ISLCN40PHY(pi))
		wlc_phy_interference_mode_attach_lcn40phy(pi);
	else if (ISSSLPNPHY(pi))
		wlc_phy_interference_mode_attach_sslpnphy(pi);
	else
		PHY_ERROR(("wl: %s | Interference mitigation not supported for this PHY\n",
			__FUNCTION__));

	if (BAND_2G(bandtype)) {
		pi->sh->interference_mode =
			pi->sh->interference_mode_2G;
	} else {
		pi->sh->interference_mode =
			pi->sh->interference_mode_5G;
	}

	pi->interf.scanroamtimer = 0;
	pi->interf.rssi_index = 0;
	pi->rssi1_index = 0;
	pi->rssi0_index = 0;
	pi->interf.rssi = 0;
}

static void
BCMATTACHFN(wlc_phy_srom_attach)(phy_info_t *pi, int bandtype)
{
	int i = 0;

	pi->ucode_tssi_limit_en = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_tssilimucod, 1);
	pi->rssi_corr_normal = (int8)PHY_GETINTVAR_DEFAULT(pi, rstr_rssicorrnorm, 0);
	pi->rssi_corr_boardatten = (int8)PHY_GETINTVAR_DEFAULT(pi, rstr_rssicorratten, 7);

	/* Re-init the interference value based on the nvram variables */
	if (PHY_GETVAR(pi, rstr_interference) != NULL) {
		pi->sh->interference_mode_2G = (int)PHY_GETINTVAR(pi, rstr_interference);
		pi->sh->interference_mode_5G = (int)PHY_GETINTVAR(pi, rstr_interference);

		if (BAND_2G(bandtype))
			pi->sh->interference_mode = pi->sh->interference_mode_2G;
		else
			pi->sh->interference_mode = pi->sh->interference_mode_5G;
	}

#if defined(RXDESENS_EN)
	/* phyrxdesens in db for SS SPC production */
	pi->sh->phyrxdesens = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_phyrxdesens, 0);
#endif // endif

#ifdef BAND5G
	for (i = 0; i < 3; i++) {
		pi->rssi_corr_normal_5g[i] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_rssicorrnorm5g, i, 0);
		pi->rssi_corr_boardatten_5g[i] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_rssicorratten5g, i, 0);
	}
#endif /* BAND5G */
	/* The below parameters are used to adjust JSSI based range */
	pi->rssi_corr_perrg_2g[0] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
		rstr_rssicorrperrg2g, 0, -150);
	pi->rssi_corr_perrg_2g[1] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
		rstr_rssicorrperrg2g, 1, -150);
#ifdef BAND5G
	pi->rssi_corr_perrg_5g[0] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
		rstr_rssicorrperrg5g, 0, -150);
	pi->rssi_corr_perrg_5g[1] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
		rstr_rssicorrperrg5g, 1, -150);
#endif /* BAND5G */
	for (i = 2; i < 5; i++) {
		pi->rssi_corr_perrg_2g[i] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_rssicorrperrg2g, i, 0);
#ifdef BAND5G
		pi->rssi_corr_perrg_5g[i] = (int8)PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_rssicorrperrg5g, i, 0);
#endif /* BAND5G */
	}

	for (i = 0; i < 14; i++)
		pi->phy_cga_2g[i] = (int8)PHY_GETINTVAR_ARRAY(pi, rstr_2g_cga, i);
#ifdef BAND5G
	for (i = 0; i < 24; i++)
		pi->phy_cga_5g[i] = (int8)PHY_GETINTVAR_ARRAY(pi, rstr_5g_cga, i);
#endif /* BAND5G */

	/* minimum reliable txpwr target is 8 dBm/mimo, 9dBm/lcn40, 10 dbm/legacy  */
	if (ISNPHY(pi))
		pi->min_txpower =
			(uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_mintxpower, PHY_TXPWR_MIN_NPHY);
	else if (ISHTPHY(pi))
		pi->min_txpower = PHY_TXPWR_MIN_HTPHY;
	else if (ISLCN40PHY(pi))
		pi->min_txpower = PHY_TXPWR_MIN_LCN40PHY;
	else if (ISACPHY(pi)) {
		if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			pi->min_txpower = PHY_TXPWR_MIN_ACPHY2X2;
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			/* set ePa value, iPa will override value later on, */
			/* at this point IS_IPA(pi) is not valid */
			pi->min_txpower = PHY_TXPWR_MIN_ACPHY1X1EPA;
		} else {
			pi->min_txpower = PHY_TXPWR_MIN_ACPHY;
		}
	} else
		pi->min_txpower = PHY_TXPWR_MIN;

	if (ISLCN40PHY(pi) && CHIPID(pi->sh->chip) != BCM43143_CHIP_ID)
		pi->tx_pwr_backoff = (int8)PHY_GETINTVAR_DEFAULT(pi, rstr_txpwrbckof, 4);
	else
		pi->tx_pwr_backoff = (int8)PHY_GETINTVAR_DEFAULT(pi, rstr_txpwrbckof, 6);

	if (ISLCN40PHY(pi)) {
		pi->rssi_corr_boardatten =
			(int8)PHY_GETINTVAR_DEFAULT(pi, rstr_rssicorratten, 0);
	}

	pi->phy_tempsense_offset = 0;

	/* Read default temp delta setting. */
	wlc_phy_read_tempdelta_settings(pi, NPHY_CAL_MAXTEMPDELTA);
}

static void
BCMATTACHFN(wlc_phy_std_params_attach)(phy_info_t *pi)
{
	/* set default rx iq est antenna/samples */
	pi->phy_rxiq_samps = PHY_NOISE_SAMPLE_LOG_NUM_NPHY;
	pi->phy_rxiq_antsel = ANT_RX_DIV_DEF;

	/* initialize SROM "isempty" flags for rxgainerror */
	pi->rxgainerr2g_isempty = FALSE;
	pi->rxgainerr5gl_isempty = FALSE;
	pi->rxgainerr5gm_isempty = FALSE;
	pi->rxgainerr5gh_isempty = FALSE;
	pi->rxgainerr5gu_isempty = FALSE;

	/* Do not enable the PHY watchdog for ATE */
#ifndef ATE_BUILD
	pi->phywatchdog_override = TRUE;
#endif // endif
	/* pi->phy_rx_diglpf_default_coeffs are not set yet */
	pi->phy_rx_diglpf_default_coeffs_valid = FALSE;

	/* Enable both cores by default */
	pi->sh->phyrxchain = 0x3;

#ifdef N2WOWL
	/* Reduce phyrxchain to 1 to save power in WOWL mode */
	if (CHIPID(pi->sh->chip) == BCM43237_CHIP_ID) {
		pi->sh->phyrxchain = 0x1;
	}
#endif /* N2WOWL */

#if defined(WLTEST)
	/* Initialize to invalid index values */
	pi->nphy_tbldump_minidx = -1;
	pi->nphy_tbldump_maxidx = -1;
	pi->nphy_phyreg_skipcnt = 0;
#endif // endif

	/* This is the temperature at which the last PHYCAL was done.
	 * Initialize to a very low value.
	 */
	pi->def_cal_info.last_cal_temp = -50;
	pi->def_cal_info.cal_suppress_count = 0;

#ifdef PREASSOC_PWRCTRL
	if (ISACPHY(pi))
		pi->channel_short_window = TRUE;
#endif // endif

	/* only NPHY/LPPHY support interrupt based noise measurement */
	pi->phynoise_polling = TRUE;
	if (ISNPHY(pi) || ISLPPHY(pi) || ISLCNCOMMONPHY(pi) || ISHTPHY(pi) || ISACPHY(pi))
		pi->phynoise_polling = FALSE;

	/* still need to have this information hanging around, even for OPT version */
	pi->tx_power_offset = NULL;

	/* initialize our txpwr limit to a large value until we know what band/channel
	 * we settle on in wlc_up() set the txpwr user override to the max
	 */
#ifdef WLTXPWR_PER_CORE
	pi->p_tx_user_target[0] = pi->p_tx_user_target[1] = WLC_TXPWR_MAX;
#else
	pi->tx_user_target = WLC_TXPWR_MAX;
#endif /* WLTXPWR_PER_CORE */

#ifdef WL_SARLIMIT
	memset(pi->sarlimit, WLC_TXPWR_MAX, PHY_MAX_CORES);
#endif /* WL_SARLIMIT */

#ifdef WL_SAR_SIMPLE_CONTROL
	/* user specified sarlimit by nvram. off as a default */
	pi->dynamic_sarctrl_2g = 0;
	pi->dynamic_sarctrl_5g = 0;
#endif /* WL_SAR_CONTROL_LIMIT */

	/* default radio power */
	pi->radiopwr_override = RADIOPWR_OVERRIDE_DEF;

	/* user specified power is at the ant port */
	pi->user_txpwr_at_rfport = FALSE;

#ifdef WLNOKIA_NVMEM
	/* user specified power is at the ant port */
	pi->user_txpwr_at_rfport = TRUE;
#endif // endif
	/* Assign the default cal info */
	pi->cal_info = &pi->def_cal_info;
	pi->cal_info->cal_suppress_count = 0;

	/* set default power output percentage to 100 percent */
	pi->txpwr_percent = 100;

	/* this will get the value from the SROM */
	pi->papdcal_indexdelta = 4;
	pi->papdcal_indexdelta_default = 4;
}

#if ((ACCONF != 0) || (NCONF != 0) || (HTCONF != 0) || (LCN40CONF != 0))
static int
wlc_phy_adjust_ed_thres(phy_info_t *pi, int32 *assert_thresh_dbm, bool set_threshold)
{
	if (ISACPHY(pi))
		wlc_phy_adjust_ed_thres_acphy(pi, assert_thresh_dbm, set_threshold);
	else if (ISNPHY(pi))
		wlc_phy_adjust_ed_thres_nphy(pi, assert_thresh_dbm, set_threshold);
	else if (ISLCN40PHY(pi))
		wlc_phy_adjust_ed_thres_lcn40phy(pi, assert_thresh_dbm, set_threshold);
	else
		return BCME_UNSUPPORTED;

	return BCME_OK;
}
#endif // endif

#ifndef PHYMOD3_TRUNK_MERGE
static int
wlc_phy_iovars_radar(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(bool_val);

	switch (actionid) {
#if defined(AP) && defined(RADAR)
	case IOV_GVAL(IOV_RADAR_ARGS):
		bcopy((char*)&pi->ri->rparams.radar_args, (char*)a, sizeof(wl_radar_args_t));
		break;
	case IOV_SVAL(IOV_RADAR_THRS):
		if (ISAPHY(pi) || ISLPPHY(pi) || ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			wl_radar_thr_t radar_thr;

			/* len is check done before gets here */
			bzero((char*)&radar_thr, sizeof(wl_radar_thr_t));
			bcopy((char*)p, (char*)&radar_thr, sizeof(wl_radar_thr_t));
			if (radar_thr.version != WL_RADAR_THR_VERSION) {
				err = BCME_VERSION;
				break;
			}
			pi->ri->rparams.radar_thrs.thresh0_20_lo = radar_thr.thresh0_20_lo;
			pi->ri->rparams.radar_thrs.thresh1_20_lo = radar_thr.thresh1_20_lo;
			pi->ri->rparams.radar_thrs.thresh0_20_hi = radar_thr.thresh0_20_hi;
			pi->ri->rparams.radar_thrs.thresh1_20_hi = radar_thr.thresh1_20_hi;
			if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
				pi->ri->rparams.radar_thrs.thresh0_40_lo = radar_thr.thresh0_40_lo;
				pi->ri->rparams.radar_thrs.thresh1_40_lo = radar_thr.thresh1_40_lo;
				pi->ri->rparams.radar_thrs.thresh0_40_hi = radar_thr.thresh0_40_hi;
				pi->ri->rparams.radar_thrs.thresh1_40_hi = radar_thr.thresh1_40_hi;
			}
			if (ISACPHY(pi)) {
				pi->ri->rparams.radar_thrs.thresh0_80_lo = radar_thr.thresh0_80_lo;
				pi->ri->rparams.radar_thrs.thresh1_80_lo = radar_thr.thresh1_80_lo;
				pi->ri->rparams.radar_thrs.thresh0_80_hi = radar_thr.thresh0_80_hi;
				pi->ri->rparams.radar_thrs.thresh1_80_hi = radar_thr.thresh1_80_hi;
			}
			wlc_phy_radar_detect_init(pi, pi->sh->radar);
		} else
			err = BCME_UNSUPPORTED;
		break;
	case IOV_SVAL(IOV_RADAR_ARGS):
		if (!pi->sh->up) {
			err = BCME_NOTUP;
			break;
		}
		if (ISAPHY(pi) || ISLPPHY(pi) || ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			wl_radar_args_t radarargs;

			/* len is check done before gets here */
			bcopy((char*)p, (char*)&radarargs, sizeof(wl_radar_args_t));
			if (radarargs.version != WL_RADAR_ARGS_VERSION) {
				err = BCME_VERSION;
				break;
			}
			bcopy((char*)&radarargs, (char*)&pi->ri->rparams.radar_args,
			      sizeof(wl_radar_args_t));
			/* apply radar inits to hardware if we are on the A/LP/NPHY */
			wlc_phy_radar_detect_init(pi, pi->sh->radar);
		} else
			err = BCME_UNSUPPORTED;
		break;
	case IOV_SVAL(IOV_PHY_DFS_LP_BUFFER):
		if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			pi->dfs_lp_buffer_nphy = bool_val;
		} else
			err = BCME_UNSUPPORTED;
		break;
	case IOV_GVAL(IOV_RADAR_STATUS):
		if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			bcopy((char*)&pi->ri->radar_status,
				(char*)a, sizeof(wl_radar_status_t));
		} else
		      err = BCME_UNSUPPORTED;
		break;
	case IOV_SVAL(IOV_CLEAR_RADAR_STATUS):
		if (ISNPHY(pi) || ISHTPHY(pi) || ISACPHY(pi)) {
			pi->ri->radar_status.detected = FALSE;
			pi->ri->radar_status.count = 0;
		} else
			err = BCME_UNSUPPORTED;
		break;
#endif /* defined(AP) && defined(RADAR) */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}
#endif /* PHYMOD3_TRUNK_MERGE */

static int
wlc_phy_iovars_phy_specific(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen,
	void *a, int alen, int vsize)
{
	int err = BCME_OK;

	if (ISACPHY(pi))
		err = wlc_phy_iovars_acphy(pi, actionid, type, p, plen, a, alen, vsize);
	else if (ISLCNCOMMONPHY(pi))
		err = wlc_phy_iovars_lcncmnphy(pi, actionid, type, p, plen, a, alen, vsize);
	else if (ISNPHY(pi))
		err = wlc_phy_iovars_nphy(pi, actionid, type, p, plen, a, alen, vsize);
	else
		err = BCME_UNSUPPORTED;

	return err;
}

static int
wlc_phy_iovars_nphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(*ret_int_ptr);
	BCM_REFERENCE(bool_val);

	switch (actionid) {
	case IOV_GVAL(IOV_PHY_OCLSCDENABLE):
		err = wlc_phy_iovar_oclscd(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_OCLSCDENABLE):
		err = wlc_phy_iovar_oclscd(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_LNLDO2):
		wlc_phy_iovar_prog_lnldo2(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_LNLDO2):
		err = wlc_phy_iovar_prog_lnldo2(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

#if defined(WLTEST) || defined(DBG_PHY_IOV)
	case IOV_GVAL(IOV_PHY_DYN_ML):
		err =  wlc_phy_dynamic_ml(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_DYN_ML):
		err =  wlc_phy_dynamic_ml(pi, int_val, ret_int_ptr, vsize, TRUE);
		break;

	case IOV_GVAL(IOV_PHY_ACI_NAMS):
		err =  wlc_phy_aci_nams(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_ACI_NAMS):
		err =  wlc_phy_aci_nams(pi, int_val, ret_int_ptr, vsize, TRUE);
		break;

	 case IOV_GVAL(IOV_PHY_RF_SWCTRL_TOGGLE):
		err = wlc_phy_rf_swctrl_toggle(pi, int_val, p, a, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_RF_SWCTRL_TOGGLE):
		err = wlc_phy_rf_swctrl_toggle(pi, int_val, p, a, TRUE);
		break;
#endif // endif

	case IOV_GVAL(IOV_PHY_OCL_FORCE_CORE0):
		err = wlc_phy_iovar_ocl_force_core0(pi, int_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_OCL_FORCE_CORE0):
		err = wlc_phy_iovar_ocl_force_core0(pi, int_val, ret_int_ptr, TRUE);
		break;

	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_lcncmnphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	BCM_REFERENCE(*ret_int_ptr);

	switch (actionid) {
#if defined(WLTEST)
	case IOV_SVAL(IOV_PHY_AUXPGA):
			if (ISLCNCOMMONPHY(pi)) {
				phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
				uint8 *aug_pga_val = (uint8*)p;
				pi_lcn->lcnphy_rssi_vf = aug_pga_val[0];
				pi_lcn->lcnphy_rssi_vc = aug_pga_val[1];
				pi_lcn->lcnphy_rssi_gs = aug_pga_val[2];
#ifdef BAND5G
				pi_lcn->rssismf5g = aug_pga_val[3];
				pi_lcn->rssismc5g = aug_pga_val[4];
				pi_lcn->rssisav5g = aug_pga_val[5];
#endif // endif
			}
		break;

	case IOV_GVAL(IOV_PHY_AUXPGA):
			if (ISLCNCOMMONPHY(pi)) {
				phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
				uint8 *aug_pga_val = (uint8*)a;
				aug_pga_val[0] = pi_lcn->lcnphy_rssi_vf;
				aug_pga_val[1] = pi_lcn->lcnphy_rssi_vc;
				aug_pga_val[2] = pi_lcn->lcnphy_rssi_gs;
#ifdef BAND5G
				aug_pga_val[3] = (uint8) pi_lcn->rssismf5g;
				aug_pga_val[4] = (uint8) pi_lcn->rssismc5g;
				aug_pga_val[5] = (uint8) pi_lcn->rssisav5g;
#endif // endif
			}
		break;
#endif // endif
#if defined(WLTEST)
#if defined(LCNCONF) || defined(LCN40CONF)
	case IOV_GVAL(IOV_LCNPHY_RXIQGAIN):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->rxpath_gain;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_RXIQGSPOWER):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->rxpath_gainselect_power;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_RXIQPOWER):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->rxpath_final_power;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_RXIQSTATUS):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->rxpath_status;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_RXIQSTEPS):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->rxpath_steps;
		}
		break;
	case IOV_SVAL(IOV_LCNPHY_RXIQSTEPS):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			pi_lcn->rxpath_steps = (uint8)int_val;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_TSSI_MAXPWR):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->tssi_maxpwr_limit;
		}
		break;
	case IOV_GVAL(IOV_LCNPHY_TSSI_MINPWR):
		{
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->tssi_minpwr_limit;
		}
		break;
#endif /* #if defined(LCNCONF) || defined(LCN40CONF) */

#if ((defined(LCN40CONF) && (LCN40CONF != 0)) || (defined(LCN20CONF) && (LCN20CONF != \
	0)))

	case IOV_GVAL(IOV_LCNPHY_TXPWRCLAMP_DIS):
		if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->txpwr_clamp_dis;
		}
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		else if (ISLCN20PHY(pi)) {
			*ret_int_ptr = (int32)(int32)pi->u.pi_lcn20phy->txpwr_clamp_dis;
		}
#endif /* (defined(LCN20CONF) && (LCN20CONF != 0)) */
		break;
	case IOV_SVAL(IOV_LCNPHY_TXPWRCLAMP_DIS):
		if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			pi_lcn->txpwr_clamp_dis = (uint8)int_val;
		}
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		else if (ISLCN20PHY(pi)) {
			pi->u.pi_lcn20phy->txpwr_clamp_dis = (uint8)int_val;
		}
#endif /* (defined(LCN20CONF) && (LCN20CONF != 0)) */
		break;
	case IOV_GVAL(IOV_LCNPHY_TXPWRCLAMP_OFDM):
		if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->target_pwr_ofdm_max;
		}
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		else if (ISLCN20PHY(pi)) {
			*ret_int_ptr = (int32)pi->u.pi_lcn20phy->target_pwr_ofdm_max;
		}
#endif /* (defined(LCN20CONF) && (LCN20CONF != 0)) */
		break;
	case IOV_GVAL(IOV_LCNPHY_TXPWRCLAMP_CCK):
		if (ISLCNPHY(pi) || ISLCN40PHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
			*ret_int_ptr = (int32)pi_lcn->target_pwr_cck_max;
		}
#if (defined(LCN20CONF) && (LCN20CONF != 0))
		else if (ISLCN20PHY(pi)) {
			*ret_int_ptr = (int32)pi->u.pi_lcn20phy->target_pwr_cck_max;
		}
#endif /* (defined(LCN20CONF) && (LCN20CONF != 0)) */
		break;

#endif /*  LCN40 and LCN20 */
#endif /* #if defined(WLTEST) */

#if defined(BCMDBG)
	case IOV_GVAL(IOV_LCNPHY_CWTXPWRCTRL):
		if (ISLCNPHY(pi))
			wlc_lcnphy_iovar_cw_tx_pwr_ctrl(pi, int_val, ret_int_ptr, FALSE);
		break;
	case IOV_SVAL(IOV_LCNPHY_CWTXPWRCTRL):
		if (ISLCNPHY(pi))
			wlc_lcnphy_iovar_cw_tx_pwr_ctrl(pi, int_val, ret_int_ptr, TRUE);
		break;
#endif // endif
	case IOV_SVAL(IOV_PHY_CRS_WAR):
		if (ISLCN40PHY(pi)) {
			pi->u.pi_lcn40phy->phycrs_war_en = (bool)int_val;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_GVAL(IOV_PHY_CRS_WAR):
		if (ISLCN40PHY(pi)) {
			*ret_int_ptr = (int32) pi->u.pi_lcn40phy->phycrs_war_en;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_acphy(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	BCM_REFERENCE(*ret_int_ptr);

	switch (actionid) {
#if defined(BCMDBG) || defined(WLTEST) || defined(WLMEDIA_CALDBG) || \
	defined(PHYCAL_CHNG_CS) || defined(WLMEDIA_FLAMES)
	case IOV_GVAL(IOV_HIRSSI_PERIOD):
		*ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_period;
		break;
	case IOV_SVAL(IOV_HIRSSI_PERIOD):
		pi->u.pi_acphy->hirssi_period = (int_val <= 0) ? PHY_SW_HIRSSI_PERIOD  :
		(uint16)int_val;
		break;
	case IOV_GVAL(IOV_HIRSSI_EN):
		*ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_en;
		break;
	case IOV_SVAL(IOV_HIRSSI_EN):
		pi->u.pi_acphy->hirssi_en = (int_val == 0) ? FALSE : TRUE;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi)) {
			wlc_phy_hirssi_elnabypass_init_acphy(pi);
			if (!pi->u.pi_acphy->hirssi_en)
				wlc_phy_hirssi_elnabypass_apply_acphy(pi);
		}
		break;
	case IOV_GVAL(IOV_HIRSSI_BYP_RSSI):
		*ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_byp_rssi;
		break;
	case IOV_SVAL(IOV_HIRSSI_BYP_RSSI):
		pi->u.pi_acphy->hirssi_byp_rssi = (int8)int_val;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi))
			wlc_phy_hirssi_elnabypass_init_acphy(pi);
		break;
	case IOV_GVAL(IOV_HIRSSI_RES_RSSI):
		*ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_res_rssi;
		break;
	case IOV_SVAL(IOV_HIRSSI_RES_RSSI):
		pi->u.pi_acphy->hirssi_res_rssi = (int8)int_val;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi))
			wlc_phy_hirssi_elnabypass_init_acphy(pi);
		break;
	case IOV_GVAL(IOV_HIRSSI_BYP_CNT):
		*ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_byp_cnt;
		break;
	case IOV_SVAL(IOV_HIRSSI_BYP_CNT):
		pi->u.pi_acphy->hirssi_byp_cnt = (int_val == -1) ? PHY_SW_HIRSSI_W1_BYP_CNT :
		(uint16)int_val;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi))
			wlc_phy_hirssi_elnabypass_init_acphy(pi);
		break;
	case IOV_GVAL(IOV_HIRSSI_RES_CNT):
	        *ret_int_ptr = (int32)pi->u.pi_acphy->hirssi_res_cnt;
		break;
	case IOV_SVAL(IOV_HIRSSI_RES_CNT):
		pi->u.pi_acphy->hirssi_res_cnt = (int_val == -1) ? PHY_SW_HIRSSI_W1_RES_CNT :
		(uint16)int_val;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi))
			wlc_phy_hirssi_elnabypass_init_acphy(pi);
		break;
	case IOV_GVAL(IOV_HIRSSI_STATUS):
		*ret_int_ptr = 0;
		if (ISACPHY(pi) && PHY_SW_HIRSSI_UCODE_CAP(pi))
			*ret_int_ptr = (int32) wlc_phy_hirssi_elnabypass_status_acphy(pi);
		break;
#endif /*  BCMDBG || WLTEST || WLMEDIA_CALDBG || PHYCAL_CHNG_CS || WLMEDIA_FLAMES */
#if defined(WLTEST)
	case IOV_SVAL(IOV_RPCALVARS): {
		const wl_rpcal_t *rpcal = p;
		if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			PHY_ERROR(("Number of TX Chain has to be > 1!\n"));
			err = BCME_UNSUPPORTED;
		} else {
			pi->sh->rpcal2g = rpcal[WL_CHAN_FREQ_RANGE_2G].update ?
			rpcal[WL_CHAN_FREQ_RANGE_2G].value: pi->sh->rpcal2g;

			pi->sh->rpcal5gb0 = rpcal[WL_CHAN_FREQ_RANGE_5G_BAND0].update ?
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND0].value : pi->sh->rpcal5gb0;

			pi->sh->rpcal5gb1 = rpcal[WL_CHAN_FREQ_RANGE_5G_BAND1].update ?
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND1].value : pi->sh->rpcal5gb1;

			pi->sh->rpcal5gb2 = rpcal[WL_CHAN_FREQ_RANGE_5G_BAND2].update ?
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND2].value : pi->sh->rpcal5gb2;

			pi->sh->rpcal5gb3 = rpcal[WL_CHAN_FREQ_RANGE_5G_BAND3].update ?
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND3].value : pi->sh->rpcal5gb3;
		}
		break;
	}

	case IOV_GVAL(IOV_RPCALVARS): {
		wl_rpcal_t *rpcal = a;
		if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			PHY_ERROR(("Number of TX Chain has to be > 1!\n"));
			err = BCME_UNSUPPORTED;
		} else {
			rpcal[WL_CHAN_FREQ_RANGE_2G].value = pi->sh->rpcal2g;
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND0].value = pi->sh->rpcal5gb0;
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND1].value = pi->sh->rpcal5gb1;
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND2].value = pi->sh->rpcal5gb2;
			rpcal[WL_CHAN_FREQ_RANGE_5G_BAND3].value = pi->sh->rpcal5gb3;
		}
		break;
	}

	case IOV_GVAL(IOV_PHY_VCOCAL):
	case IOV_SVAL(IOV_PHY_VCOCAL):
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phy_force_vcocal_acphy(pi);
		wlapi_enable_mac(pi->sh->physhim);
		break;
	case IOV_GVAL(IOV_XTAL_LDO):
		*ret_int_ptr = pi->u.pi_acphy->xtalldo;
		break;

	case IOV_SVAL(IOV_XTAL_LDO):
		wlc_acphy_set_ldo((wlc_phy_t *)pi, (uint8)int_val);
		break;

#endif // endif
#if (defined(BCMDBG) || defined(BCMDBG_DUMP)) || defined(BCMDBG_PHYDUMP)
	case IOV_SVAL(IOV_PHY_FORCE_GAINLEVEL):
	{
		wlc_phy_force_gainlevel_acphy(pi, (int16) int_val);
		break;
	}
#endif /* BCMDBG */
#if defined(WLTEST)
	case IOV_SVAL(IOV_PHY_FORCE_SPURMODE):
	{
		if (int_val == -1)
			pi->acphy_spuravoid_mode_override = 0;
		else
			pi->acphy_spuravoid_mode_override = 1;

		wlc_phy_force_spurmode_acphy(pi, (int16)int_val);
		break;
	}
	case IOV_GVAL(IOV_PHY_FORCE_SPURMODE):
	{
	  if (pi->acphy_spuravoid_mode_override == 1)
			*ret_int_ptr = pi->acphy_spuravoid_mode;
		else
			*ret_int_ptr = -1;
		break;
	}
#endif /* WLTEST */
#if defined(BCMDBG)
	case IOV_SVAL(IOV_PHY_FORCE_FDIQI):
	{

		wlc_phy_force_fdiqi_acphy(pi, (uint16) int_val);

		break;
	}
#endif /* BCMDBG */
	case IOV_SVAL(IOV_PHY_FORCE_CRSMIN):
	{
		wlc_phy_force_crsmin_acphy(pi, p);
		break;
	}
#if defined(BCMDBG)
	case IOV_SVAL(IOV_PHY_BTCOEX_DESENSE):
	{
	  wlc_phy_desense_btcoex_acphy(pi, int_val);
		break;
	}
#endif /* BCMDBG */
#ifndef WLC_DISABLE_ACI
#endif /* WLC_DISABLE_ACI */
	case IOV_SVAL(IOV_EDCRS):
	{

		if (int_val == 0)
		{
			W_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_CTL_SEL_PRICRS, 0x000F);
		}
		else
		{
			W_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_CTL_SEL_PRICRS, 0x0F0F);
		}
		break;
	}
	case IOV_SVAL(IOV_LP_MODE):
	{
		if ((int_val > 3) || (int_val < 1)) {
			PHY_ERROR(("LP MODE %d is not supported \n", (uint16)int_val));
		} else {
			wlc_phy_lp_mode(pi, (int8) int_val);
		}
		break;
	}
	case IOV_GVAL(IOV_LP_MODE):
	{
		if (ISACPHY(pi))
			*ret_int_ptr = pi->u.pi_acphy->acphy_lp_status;
		break;

	}
	case IOV_SVAL(IOV_LP_VCO_2G):
	{
		if ((int_val != 0) && (int_val != 1)) {
			PHY_ERROR(("LP MODE %d is not supported \n", (uint16)int_val));
		} else {
			wlc_phy_force_lpvco_2G(pi, (int8) int_val);
		}
		break;
	}
	case IOV_GVAL(IOV_LP_VCO_2G):
	{
		if (ISACPHY(pi))
			*ret_int_ptr = pi->u.pi_acphy->acphy_force_lpvco_2G;
		break;
	}
	case IOV_SVAL(IOV_SMTH):
	{
		if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
		    (ACMAJORREV_3(pi->pubpi.phy_rev) && (!ACMINORREV_0(pi->pubpi.phy_rev)))) {
			if ((int_val > SMTH_FOR_TXBF) || (int_val < SMTH_DISABLE)) {
				PHY_ERROR(("Smth %d is not supported \n", (uint16)int_val));
			} else {
				wlc_phy_smth(pi, (int8) int_val, SMTH_NODUMP);
			}
		} else {
			PHY_ERROR(("Smth is not supported for this chip \n"));
		}
		break;
	}
	case IOV_GVAL(IOV_SMTH):
	{
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
			if (ISACPHY(pi))
				*ret_int_ptr = pi->u.pi_acphy->acphy_enable_smth;
		} else {
			PHY_ERROR(("Smth is not supported for this chip \n"));
		}
		break;
	}
#if defined(WLTEST)
	case IOV_SVAL(IOV_RADIO_PD):
	{
		if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID) {
			if (int_val == 1) {
				pi->u.pi_acphy->acphy_4335_radio_pd_status = 1;
				wlc_phy_radio2069_pwrdwn_seq(pi);
			} else if (int_val == 0) {
				wlc_phy_radio2069_pwrup_seq(pi);
				pi->u.pi_acphy->acphy_4335_radio_pd_status = 0;
			} else {
				PHY_ERROR(("RADIO PD %d is not supported \n", (uint16)int_val));
			}
		} else {
			PHY_ERROR(("RADIO PD is not supported for this chip \n"));
		}
		break;
	}
	case IOV_GVAL(IOV_RADIO_PD):
	{
	    *ret_int_ptr = pi->u.pi_acphy->acphy_4335_radio_pd_status;
		break;
	}
#endif /* WLTEST */
	case IOV_GVAL(IOV_EDCRS):
	{
		if (R_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_CTL_SEL_PRICRS) == 0x000F)
		{
			*ret_int_ptr = 0;
		}
		else if (R_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_CTL_SEL_PRICRS) == 0x0F0F)
		{
			*ret_int_ptr = 1;
		}
		break;
	}
	case IOV_GVAL(IOV_PHY_AFE_OVERRIDE):
		*ret_int_ptr = (int32)pi->afe_override;
		break;
	case IOV_SVAL(IOV_PHY_AFE_OVERRIDE):
		pi->afe_override = (uint8)int_val;
		break;
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

#ifdef SAMPLE_COLLECT
static int
wlc_phy_iovars_sample_collect(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen,
	void *a, int alen, int vsize)
{
	int32 int_val = 0;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	BCM_REFERENCE(*ret_int_ptr);

	switch (actionid) {
	case IOV_SVAL(IOV_PHY_SAMPLE_COLLECT_GAIN_ADJUST):
		if (ISNPHY(pi))	{
			phy_info_nphy_t *pi_n = pi->u.pi_nphy;
			pi_n->sample_collect_gainadj = (int8)int_val;
		} else if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			pi_lcn40->sample_collect_gainadj = (int8)int_val;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;

	case IOV_GVAL(IOV_PHY_SAMPLE_COLLECT_GAIN_ADJUST):
		if (ISNPHY(pi))	{
			phy_info_nphy_t *pi_n = pi->u.pi_nphy;
			*ret_int_ptr = (int32)pi_n->sample_collect_gainadj;
		} else if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			*ret_int_ptr = (int32)pi_lcn40->sample_collect_gainadj;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;

	case IOV_SVAL(IOV_PHY_SAMPLE_COLLECT_GAIN_INDEX):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			pi_lcn40->sample_collect_gainidx = (uint8)int_val;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_PHY_SAMPLE_COLLECT_GAIN_INDEX):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			*ret_int_ptr = (int32)pi_lcn40->sample_collect_gainidx;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_PHY_SAMPLE_COLLECT):
	{
		wl_samplecollect_args_t samplecollect_args;
		if (plen < (int)sizeof(wl_samplecollect_args_t)) {
			PHY_ERROR(("plen (%d) < sizeof(wl_samplecollect_args_t) (%d)\n",
				plen, (int)sizeof(wl_samplecollect_args_t)));
			err = BCME_BUFTOOSHORT;
			break;
		}
		bcopy((char*)p, (char*)&samplecollect_args, sizeof(wl_samplecollect_args_t));
		if (samplecollect_args.version != WL_SAMPLECOLLECT_T_VERSION) {
			PHY_ERROR(("Incompatible version; use %d expected version %d\n",
				samplecollect_args.version, WL_SAMPLECOLLECT_T_VERSION));
			err = BCME_BADARG;
			break;
		}
		if (!ISLCN40PHY(pi)) {
			if (ltoh16(samplecollect_args.length) > (uint16)alen) {
				PHY_ERROR(("Bad length, length requested > buf len (%d > %d)\n",
					samplecollect_args.length, alen));
				err = BCME_BADLEN;
				break;
			}
		} else {
			if (samplecollect_args.nsamps > ((uint16)alen >> 2)) {
				PHY_ERROR(("Bad length, length requested > buf len (%d > %d)\n",
					samplecollect_args.nsamps, alen));
				err = BCME_BADLEN;
				break;
			}
		}
		err = wlc_phy_sample_collect(pi, &samplecollect_args, a);
		break;
	}
	case IOV_GVAL(IOV_PHY_MAC_TRIGGERED_SAMPLE_COLLECT):
	{
		wl_samplecollect_args_t samplecollect_args;
		if (plen < (int)sizeof(wl_samplecollect_args_t)) {
			PHY_ERROR(("plen (%d) < sizeof(wl_samplecollect_args_t) (%d)\n",
				plen, (int)sizeof(wl_samplecollect_args_t)));
			err = BCME_BUFTOOSHORT;
			break;
		}
		bcopy((char*)p, (char*)&samplecollect_args, sizeof(wl_samplecollect_args_t));
		if (samplecollect_args.version != WL_SAMPLECOLLECT_T_VERSION) {
			PHY_ERROR(("Incompatible version; use %d expected version %d\n",
				samplecollect_args.version, WL_SAMPLECOLLECT_T_VERSION));
			err = BCME_BADARG;
			break;
		}
		if (!ISLCN40PHY(pi)) {
			if (ltoh16(samplecollect_args.length) > (uint16)alen) {
				PHY_ERROR(("Bad length, length requested > buf len (%d > %d)\n",
					samplecollect_args.length, alen));
				err = BCME_BADLEN;
				break;
			}
		} else {
			if (samplecollect_args.nsamps > ((uint16)alen >> 2)) {
				PHY_ERROR(("Bad length, length requested > buf len (%d > %d)\n",
					samplecollect_args.nsamps, alen));
				err = BCME_BADLEN;
				break;
			}
		}
		err = wlc_phy_mac_triggered_sample_collect(pi, &samplecollect_args, a);
		break;
	}
	case IOV_GVAL(IOV_PHY_SAMPLE_DATA):
	{
		wl_sampledata_t sampledata_args;
		if (plen < (int)sizeof(wl_sampledata_t)) {
			PHY_ERROR(("plen (%d) < sizeof(wl_samplecollect_args_t) (%d)\n",
				plen, (int)sizeof(wl_sampledata_t)));
			err = BCME_BUFTOOSHORT;
			break;
		}
		bcopy((char*)p, (char*)&sampledata_args, sizeof(wl_sampledata_t));

		if ((ltoh16(sampledata_args.version) != WL_SAMPLEDATA_T_VERSION) &&
		     (ltoh16(sampledata_args.version) != WL_SAMPLEDATA_T_VERSION_SPEC_AN)) {
			PHY_ERROR(("Incompatible version; use %d expected version %d\n",
				sampledata_args.version, WL_SAMPLEDATA_T_VERSION));
			err = BCME_BADARG;
			break;
		}

		if (ltoh16(sampledata_args.length) > (uint16)alen) {
			PHY_TRACE(("length requested > buf len (%d > %d) limiting to buf len\n",
				sampledata_args.length, alen));
			/* limit the user request to alen */
			sampledata_args.length = htol16((uint16)alen);
		}
		err = wlc_phy_sample_data(pi, &sampledata_args, a);
		break;
	}

	case IOV_GVAL(IOV_IQ_IMBALANCE_METRIC_DATA):
	{
		/* driver must be "out" (not up but chip is alive) */
		if (pi->sh->up) {
			err = BCME_NOTDOWN;
			break;
		}
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}

		if (ISLCN40PHY(pi))
			err = wlc_lcn40phy_iqimb_check(pi, 2048, (uint32 *)a, NULL, NULL);
		break;
	}

	case IOV_GVAL(IOV_IQ_IMBALANCE_METRIC):
	{
		/* driver must be "out" (not up but chip is alive) */
		if (pi->sh->up) {
			err = BCME_NOTDOWN;
			break;
		}
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}

		if (ISLCN40PHY(pi))
			err = wlc_lcn40phy_iqimb_check(pi, 8000, NULL, ret_int_ptr, NULL);
		break;
	}

	case IOV_GVAL(IOV_IQ_IMBALANCE_METRIC_PASS):
	{
		/* driver must be "out" (not up but chip is alive) */
		if (pi->sh->up) {
			err = BCME_NOTDOWN;
			break;
		}
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}

		if (ISLCN40PHY(pi))
			err = wlc_lcn40phy_iqimb_check(pi, 8000, NULL, NULL, ret_int_ptr);
		break;
	}

	case IOV_GVAL(IOV_PHY_MAC_TRIGGERED_SAMPLE_DATA):
	{
		wl_sampledata_t sampledata_args;

		if (plen < (int)sizeof(wl_sampledata_t)) {
			PHY_ERROR(("plen (%d) < sizeof(wl_samplecollect_args_t) (%d)\n",
				plen, (int)sizeof(wl_sampledata_t)));
			err = BCME_BUFTOOSHORT;
			break;
		}

		bcopy((char*)p, (char*)&sampledata_args, sizeof(wl_sampledata_t));

		if ((ltoh16(sampledata_args.version) != WL_SAMPLEDATA_T_VERSION) &&
		     (ltoh16(sampledata_args.version) != WL_SAMPLEDATA_T_VERSION_SPEC_AN)) {
			PHY_ERROR(("Incompatible version; use %d expected version %d\n",
				sampledata_args.version, WL_SAMPLEDATA_T_VERSION));
			err = BCME_BADARG;
			break;
		}

		if (ltoh16(sampledata_args.length) > (uint16)alen) {
			PHY_TRACE(("length requested > buf len (%d > %d) limiting to buf len\n",
				sampledata_args.length, alen));
			/* limit the user request to alen */
			sampledata_args.length = htol16((uint16)alen);
		}
		err = wlc_phy_mac_triggered_sample_data(pi, &sampledata_args, a);
		break;
	}
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}
#endif /* SAMPLE_COLLECT */

static int
wlc_phy_iovars_calib(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(bool_val);
	BCM_REFERENCE(*ret_int_ptr);

	switch (actionid) {
#if defined(WLTEST) || defined(ATE_BUILD)
	case IOV_GVAL(IOV_PHY_TXIQCC):
	{
		int32 iqccValues[4];
		uint16 valuea = 0;
		uint16 valueb = 0;
		uint16 valuea1 = 0;
		uint16 valueb1 = 0;
		if (!(ISNPHY(pi))) {
			txiqccgetfn_t txiqcc_fn = pi->pi_fptr.txiqccget;
			if (txiqcc_fn) {
				(*txiqcc_fn)(pi, &valuea, &valueb);
				iqccValues[0] = valuea;
				iqccValues[1] = valueb;
				bcopy(iqccValues, a, 2*sizeof(int32));
			}
		} else {
			txiqccmimogetfn_t txiqcc_fn = pi->pi_fptr.txiqccmimoget;
			if (txiqcc_fn) {
				(*txiqcc_fn)(pi, &valuea, &valueb, &valuea1, &valueb1);
				iqccValues[0] = valuea;
				iqccValues[1] = valueb;
				iqccValues[2] = valuea1;
				iqccValues[3] = valueb1;
				bcopy(iqccValues, a, 4*sizeof(int32));
			}
		}
		break;
	}
	case IOV_SVAL(IOV_PHY_TXIQCC):
	{
		int32 iqccValues[4];
		uint16 valuea, valueb, valuea1, valueb1;
		if (!(ISNPHY(pi))) {
			txiqccsetfn_t txiqcc_fn = pi->pi_fptr.txiqccset;
			if (txiqcc_fn) {
				bcopy(p, iqccValues, 2*sizeof(int32));
				valuea = (uint16)(iqccValues[0]);
				valueb = (uint16)(iqccValues[1]);
				(*txiqcc_fn)(pi, valuea, valueb);
			}
		} else {
			txiqccmimosetfn_t txiqcc_fn = pi->pi_fptr.txiqccmimoset;
			if (txiqcc_fn) {
				bcopy(p, iqccValues, 4*sizeof(int32));
				valuea = (uint16)(iqccValues[0]);
				valueb = (uint16)(iqccValues[1]);
				valuea1 = (uint16)(iqccValues[2]);
				valueb1 = (uint16)(iqccValues[3]);
				(*txiqcc_fn)(pi, valuea, valueb, valuea1, valueb1);
			}
		}
		break;
	}
	case IOV_GVAL(IOV_PHY_TXLOCC):
	{
		uint16 di0dq0;
		uint16 di1dq1;
		uint8 *loccValues = a;

		if (!(ISNPHY(pi))) {
			txloccgetfn_t txlocc_fn = pi->pi_fptr.txloccget;
			radioloftgetfn_t radio_loft_fn = pi->pi_fptr.radioloftget;
			if ((txlocc_fn) && (radio_loft_fn))
			{
				/* copy the 6 bytes to a */
				di0dq0 = (*txlocc_fn)(pi);
				loccValues[0] = (uint8)(di0dq0 >> 8);
				loccValues[1] = (uint8)(di0dq0 & 0xff);
				(*radio_loft_fn)(pi, &loccValues[2], &loccValues[3],
					&loccValues[4], &loccValues[5]);
			}
		} else {
			txloccmimogetfn_t txlocc_fn = pi->pi_fptr.txloccmimoget;
			radioloftmimogetfn_t radio_loft_fn = pi->pi_fptr.radioloftmimoget;

			if ((txlocc_fn) && (radio_loft_fn))
			{
				/* copy the 6 bytes to a */
				(*txlocc_fn)(pi, &di0dq0, &di1dq1);
				loccValues[0] = (uint8)(di0dq0 >> 8);
				loccValues[1] = (uint8)(di0dq0 & 0xff);
				loccValues[6] = (uint8)(di1dq1 >> 8);
				loccValues[7] = (uint8)(di1dq1 & 0xff);
				(*radio_loft_fn)(pi, &loccValues[2], &loccValues[3],
					&loccValues[4], &loccValues[5], &loccValues[8],
					&loccValues[9], &loccValues[10], &loccValues[11]);
			}
		}
		break;
	}
	case IOV_SVAL(IOV_PHY_TXLOCC):
	{
		/* copy 6 bytes from a to radio */
		uint16 di0dq0, di1dq1;
		uint8 *loccValues = p;

		if (!(ISNPHY(pi))) {
			di0dq0 = ((uint16)loccValues[0] << 8) | loccValues[1];
			if (ISLPPHY(pi)) {
				wlc_phy_set_tx_locc_lpphy(pi, di0dq0);
				wlc_phy_set_radio_loft_lpphy(pi, loccValues[2],
					loccValues[3], loccValues[4], loccValues[5]);
				wlc_phy_set_tx_locc_ucode_lpphy(pi, FALSE, di0dq0);
			} else if (pi->pi_fptr.txloccset && pi->pi_fptr.radioloftset) {
				pi->pi_fptr.txloccset(pi, di0dq0);
				pi->pi_fptr.radioloftset(pi, loccValues[2],
					loccValues[3], loccValues[4], loccValues[5]);
			} else
			return BCME_UNSUPPORTED;
		} else {
			di0dq0 = ((uint16)loccValues[0] << 8) | loccValues[1];
			di1dq1 = ((uint16)loccValues[6] << 8) | loccValues[7];
			if (pi->pi_fptr.txloccmimoset && pi->pi_fptr.radioloftmimoset) {
				pi->pi_fptr.txloccmimoset(pi, di0dq0, di1dq1);
				pi->pi_fptr.radioloftmimoset(pi, loccValues[2],
					loccValues[3], loccValues[4], loccValues[5],
					loccValues[8], loccValues[9], loccValues[10],
					loccValues[11]);
			}
		}
		break;
	}
#endif // endif
#if defined(BCMDBG) || defined(WLTEST)
	case IOV_GVAL(IOV_PHY_TEMPTHRESH):
		*ret_int_ptr = (int32) pi->txcore_temp.disable_temp;
		break;

	case IOV_SVAL(IOV_PHY_TEMPTHRESH):
		pi->txcore_temp.disable_temp = (uint8) int_val;
		pi->txcore_temp.enable_temp =
			pi->txcore_temp.disable_temp - pi->txcore_temp.hysteresis;
		break;

	case IOV_GVAL(IOV_PHY_TEMPOFFSET):
		*ret_int_ptr = (int32) pi->phy_tempsense_offset;
		break;

	case IOV_SVAL(IOV_PHY_TEMPOFFSET):
		pi->phy_tempsense_offset = (int8) int_val;
		break;

	case IOV_GVAL(IOV_PHY_TEMPSENSE_OVERRIDE):
		*ret_int_ptr = (int32)pi->tempsense_override;
		break;

	case IOV_SVAL(IOV_PHY_TEMPSENSE_OVERRIDE):
		pi->tempsense_override = (uint16)int_val;
		break;

	case IOV_GVAL(IOV_PHY_TEMP_HYSTERESIS):
		*ret_int_ptr = (int32)pi->txcore_temp.hysteresis;
		break;

	case IOV_SVAL(IOV_PHY_TEMP_HYSTERESIS):
		pi->txcore_temp.hysteresis = (uint8)int_val;
		pi->txcore_temp.enable_temp =
			pi->txcore_temp.disable_temp - pi->txcore_temp.hysteresis;
		break;

#endif /* BCMDBG || WLTEST */

#if defined(BCMDBG) || defined(WLTEST) || defined(MACOSX) || defined(ATE_BUILD) || \
	defined(BCMDBG_TEMPSENSE)
	case IOV_GVAL(IOV_PHY_TEMPSENSE):
		err = wlc_phy_iovar_tempsense(pi, ret_int_ptr);
		break;
#endif /* BCMDBG || WLTEST || MACOSX || ATE_BUILD || BCMDBG_TEMPSENSE */
#if defined(WLTEST) || defined(WLMEDIA_CALDBG)
	case IOV_GVAL(IOV_PHY_CAL_DISABLE):
		*ret_int_ptr = (int32)pi->disable_percal;
		break;

	case IOV_SVAL(IOV_PHY_CAL_DISABLE):
		pi->disable_percal = bool_val;
		break;
#endif // endif

#if defined(WLTEST)
	case IOV_GVAL(IOV_PHY_IDLETSSI):
		wlc_phy_iovar_idletssi(pi, ret_int_ptr, TRUE);
		break;

	case IOV_SVAL(IOV_PHY_IDLETSSI):
		wlc_phy_iovar_idletssi(pi, ret_int_ptr, bool_val);
		break;

	case IOV_GVAL(IOV_PHY_VBATSENSE):
		wlc_phy_iovar_vbatsense(pi, ret_int_ptr);
		break;

	case IOV_GVAL(IOV_PHY_IDLETSSI_REG):
		if (!pi->sh->clk)
			err = BCME_NOCLK;
		else
			err = wlc_phy_iovar_idletssi_reg(pi, ret_int_ptr, int_val, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_IDLETSSI_REG):
		if (!pi->sh->clk)
			err = BCME_NOCLK;
		else
			err = wlc_phy_iovar_idletssi_reg(pi, ret_int_ptr, int_val, TRUE);
		break;

	case IOV_GVAL(IOV_PHY_AVGTSSI_REG):
		if (!pi->sh->clk)
			err = BCME_NOCLK;
		else
			wlc_phy_iovar_avgtssi_reg(pi, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_PHY_RESETCCA):
		if (ISNPHY(pi)) {
			wlc_phy_resetcca_nphy(pi);
		}
		else if (ISACPHY(pi)) {
			bool macSuspended;
			/* check if MAC already suspended */
			macSuspended = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
			if (!macSuspended) {
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
			}
			wlc_phy_resetcca_acphy(pi);
			if (!macSuspended)
				wlapi_enable_mac(pi->sh->physhim);
		}
		break;
	case IOV_GVAL(IOV_PHY_PACALIDX0):

		if (ISLCNPHY(pi)) {
			uint32 papd_cal_idx;
			papd_cal_idx = 0;
			papd_cal_idx = (uint32) (pi->u.pi_lcnphy)->papd_lut0_cal_idx;
			bcopy(&papd_cal_idx, a, sizeof(uint32));
		} else if (ISACPHY(pi)) {
			int32 papd_cal_idx;
			papd_cal_idx = (int32) (pi->u.pi_acphy)->papd_lut0_cal_idx;
			bcopy(&papd_cal_idx, a, sizeof(int32));
		}

		break;
	case IOV_GVAL(IOV_PHY_PACALIDX1):

		if (ISLCNPHY(pi)) {
			uint32 papd_cal_idx;
			papd_cal_idx = 0;
			papd_cal_idx = (uint32) (pi->u.pi_lcnphy)->papd_lut1_cal_idx;
			bcopy(&papd_cal_idx, a, sizeof(uint32));
		} else if (ISACPHY(pi)) {
			uint32 papd_cal_idx;
			papd_cal_idx = (int32) (pi->u.pi_acphy)->papd_lut1_cal_idx;
			bcopy(&papd_cal_idx, a, sizeof(int32));
		}

		break;

	case IOV_SVAL(IOV_PHY_IQLOCALIDX):
		if (ISLCNPHY(pi)) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				OSL_DELAY(1000);
				(pi->u.pi_lcnphy)->iqlocalidx_2g = (int8) *ret_int_ptr;
				(pi->u.pi_lcnphy)->iqlocalidx2goffs = 0;
			}
#ifdef BAND5G
			else {
				OSL_DELAY(1000);
				(pi->u.pi_lcnphy)->iqlocalidx_5g = (int8) *ret_int_ptr;
				(pi->u.pi_lcnphy)->iqlocalidx5goffs = 0;
			}
#endif /* BAND5G */
		}
		break;

	case IOV_SVAL(IOV_PHY_PACALIDX):
		if (ISLCNPHY(pi)) {
				OSL_DELAY(1000);
				(pi->u.pi_lcnphy)->pacalidx = (int8) *ret_int_ptr;
		} else if (ISACPHY(pi)) {
				(pi->u.pi_acphy)->pacalidx_iovar = (int8) *ret_int_ptr;
		}
		break;

	case IOV_GVAL(IOV_PHYCAL_TEMPDELTA):
		*ret_int_ptr = (int32)pi->phycal_tempdelta;
		break;

	case IOV_SVAL(IOV_PHYCAL_TEMPDELTA):
		if (int_val == -1)
			pi->phycal_tempdelta = pi->phycal_tempdelta_default;
		else
			pi->phycal_tempdelta = (uint8)int_val;
		break;
	case IOV_GVAL(IOV_PHY_PACALSTATUS):
		if (ISACPHY(pi)) {
			wlc_phy_papd_phase_check_acphy(pi);
			*ret_int_ptr = (int32)pi->phy_pacalstatus;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
#endif // endif
	case IOV_SVAL(IOV_PHY_SROM_TEMPSENSE):
	{
		pi->srom_rawtempsense = (int16)int_val;
		break;
	}

	case IOV_GVAL(IOV_PHY_SROM_TEMPSENSE):
	{
		*ret_int_ptr = pi->srom_rawtempsense;
		break;
	}
	case IOV_SVAL(IOV_PHY_RXGAIN_RSSI):
	{
		pi->u.pi_acphy->rxgaincal_rssical = (bool)int_val;
		break;
	}

	case IOV_GVAL(IOV_PHY_RXGAIN_RSSI):
	{
		*ret_int_ptr = pi->u.pi_acphy->rxgaincal_rssical;
		break;
	}
	case IOV_SVAL(IOV_PHY_GAIN_CAL_TEMP):
	{
		pi->srom_gain_cal_temp  = (int16)int_val;
		if (ISACPHY(pi) && pi->srom_gain_cal_temp == 255) {
			uint8 core;
			pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp = FALSE;

			FOREACH_CORE(pi, core) {
				wlc_phy_set_trloss_reg_acphy(pi, core);
			}

		}
		break;
	}
	case IOV_GVAL(IOV_PHY_GAIN_CAL_TEMP):
	{
		*ret_int_ptr = pi->srom_gain_cal_temp;
		break;
	}
	case IOV_SVAL(IOV_PHY_RSSI_CAL_REV):
	{
		pi->u.pi_acphy->rssi_cal_rev = (bool)int_val;
		break;
	}

	case IOV_GVAL(IOV_PHY_RSSI_CAL_REV):
	{
		*ret_int_ptr = pi->u.pi_acphy->rssi_cal_rev;
		break;
	}
	case IOV_SVAL(IOV_PHY_RUD_AGC_ENABLE):
	{
		pi->u.pi_acphy->rud_agc_enable = (bool)int_val;
		break;
	}

	case IOV_GVAL(IOV_PHY_RUD_AGC_ENABLE):
	{
		*ret_int_ptr = pi->u.pi_acphy->rud_agc_enable;
		break;
	}
	case IOV_SVAL(IOV_PHY_TEMP_COMP_TRLOSS):
	{
		pi->u.pi_acphy->temp_comp_tr_loss = (bool)int_val;
		break;
	}

	case IOV_GVAL(IOV_PHY_TEMP_COMP_TRLOSS):
	{
		*ret_int_ptr = pi->u.pi_acphy->temp_comp_tr_loss;
		break;
	}

#ifdef PHYMON
	case IOV_GVAL(IOV_PHYCAL_STATE): {
		if (alen < (int)sizeof(wl_phycal_state_t)) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		if (ISNPHY(pi))
			err = wlc_phycal_state_nphy(pi, a, alen);
		else
			err = BCME_UNSUPPORTED;

		break;
	}
#endif /* PHYMON */
#if defined(WLTEST) || defined(AP) || defined(WLAWDL)
	case IOV_GVAL(IOV_PHY_PERICAL):
		wlc_phy_iovar_perical_config(pi, int_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_PERICAL):
		wlc_phy_iovar_perical_config(pi, int_val, ret_int_ptr, TRUE);
		break;
#endif // endif

	case IOV_GVAL(IOV_PHY_PERICAL_DELAY):
		*ret_int_ptr = (int32)pi->phy_cal_delay;
		break;

	case IOV_SVAL(IOV_PHY_PERICAL_DELAY):
		if ((int_val >= PHY_PERICAL_DELAY_MIN) && (int_val <= PHY_PERICAL_DELAY_MAX))
			pi->phy_cal_delay = (uint16)int_val;
		else
			err = BCME_RANGE;
		break;

	case IOV_GVAL(IOV_PHY_PAPD_DEBUG):
		if (ISSSLPNPHY(pi))
		{
			wlc_sslpnphy_iovar_papd_debug(pi, a);
		}
		break;

	case IOV_GVAL(IOV_NOISE_MEASURE):
#if LCNCONF
		if (ISLCNPHY(pi))
		  wlc_lcnphy_noise_measure_start(pi, TRUE);
#endif // endif
		int_val = 0;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_GVAL(IOV_NOISE_MEASURE_DISABLE):
#if LCNCONF
		if (ISLCNPHY(pi))
		  wlc_lcnphy_noise_measure_disable(pi, 0, (uint32*)&int_val);
		else
#endif // endif
#if LCN40CONF
		if (ISLCN40PHY(pi))
		  wlc_lcn40phy_noise_measure_disable(pi, 0, (uint32*)&int_val);
		else
#endif // endif
		  int_val = 0;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_SVAL(IOV_NOISE_MEASURE_DISABLE):
#if LCNCONF
		if (ISLCNPHY(pi))
		  wlc_lcnphy_noise_measure_disable(pi, int_val, NULL);
		else
#endif // endif
#if LCN40CONF
		if (ISLCN40PHY(pi))
		  wlc_lcn40phy_noise_measure_disable(pi, int_val, NULL);
#endif // endif
		break;
#ifdef WLC_TXCAL
	case IOV_GVAL(IOV_PHY_ADJUSTED_TSSI):
		if (!pi->sh->clk)
			err = BCME_NOCLK;
		else
			err = wlc_phy_iovar_adjusted_tssi(pi, ret_int_ptr,
			        (uint8) int_val);
		break;
#if defined(WLTEST)
	case IOV_SVAL(IOV_PHY_TXCAL_GAINSWEEP):
	{
		wl_txcal_params_t txcal_params;
		bcopy(p, &txcal_params, sizeof(wl_txcal_params_t));
		wlc_phy_txcal_gainsweep(pi, &txcal_params);
		break;
	}
#endif // endif
	case IOV_GVAL(IOV_PHY_TXCAL_GAINSWEEP_MEAS):
	{
		bcopy(&pi->txcal_meas, a, sizeof(wl_txcal_meas_t));
		break;
	}

	case IOV_SVAL(IOV_PHY_TXCAL_GAINSWEEP_MEAS):
		bcopy(p, &pi->txcal_meas.pwr, 2 *
		        MAX_NUM_TXCAL_MEAS*sizeof(pi->txcal_meas.pwr[0][0]));
		break;

	case IOV_SVAL(IOV_PHY_TXCAL_PWR_TSSI_TBL):
	{
		wl_txcal_power_tssi_t *txcal_pwr_tssi_ptr;
		txcal_pwr_tssi_ptr = (wl_txcal_power_tssi_t*)p;
		if (txcal_pwr_tssi_ptr->gen_tbl) {
			pi->txcal_pwr_tssi.gen_tbl = txcal_pwr_tssi_ptr->gen_tbl;
			pi->txcal_pwr_tssi.channel = txcal_pwr_tssi_ptr->channel;
			memcpy(pi->txcal_pwr_tssi.pwr_start,
			        txcal_pwr_tssi_ptr->pwr_start,
			        2*sizeof(txcal_pwr_tssi_ptr->pwr_start[0]));
			memcpy(pi->txcal_pwr_tssi.num_entries,
			        txcal_pwr_tssi_ptr->num_entries,
			        2*sizeof(txcal_pwr_tssi_ptr->num_entries[0]));
			pi->txcal_pwr_tssi.set_core = txcal_pwr_tssi_ptr->set_core;
			wlc_phy_txcal_generate_pwr_tssi_tbl(pi);
		} else {
			bcopy(p, &pi->txcal_pwr_tssi, sizeof(wl_txcal_power_tssi_t));
		}
		err = wlc_phy_txcal_store_pwr_tssi_tbl(pi);
		break;
	}

	case IOV_GVAL(IOV_PHY_TXCAL_PWR_TSSI_TBL):
	{
		wlc_phy_txcal_get_pwr_tssi_tbl(pi, (uint8) int_val);
		bcopy(&pi->txcal_pwr_tssi, a, sizeof(wl_txcal_power_tssi_t));
		break;
	}
	case IOV_GVAL(IOV_OLPC_ANCHOR_IDX):
	{
		wlc_phy_txcal_get_pwr_tssi_tbl(pi, (uint8) int_val);
		bcopy(&pi->txcal_pwr_tssi, a, sizeof(wl_txcal_power_tssi_t));
		break;
	}
	case IOV_SVAL(IOV_OLPC_ANCHOR_IDX):
	{
		bcopy(p, &pi->txcal_pwr_tssi, sizeof(wl_txcal_power_tssi_t));
		err = wlc_phy_txcal_store_pwr_tssi_tbl(pi);
		/* If in use, update olpc anchor info for curchan */
		if (ISACPHY(pi) && pi->olpc_idx_in_use)
			wlc_phy_set_olpc_anchor_acphy(pi);
		break;
	}
	case IOV_SVAL(IOV_PHY_TXCAL_APPLY_PWR_TSSI_TBL):
	{
		if (ISACPHY(pi)) {
			if (int_val) {
				/* Use Tx cal based pwr_tssi_tbl */
				wlc_phy_apply_pwr_tssi_tble_chan_acphy(pi);
			} else {
				/* Use PA Params */
				wlc_phy_txcal_apply_pa_params(pi);
			}
			pi->txcal_pwr_tssi_tbl_in_use = (bool)int_val;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	}

	case IOV_GVAL(IOV_PHY_TXCAL_APPLY_PWR_TSSI_TBL):
	{
		if (ISACPHY(pi)) {
			*ret_int_ptr = (int32)pi->txcal_pwr_tssi_tbl_in_use;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	}

	case IOV_GVAL(IOV_PHY_READ_ESTPWR_LUT):
	{
		if (ISACPHY(pi)) {
			uint16 estpwr[128];
			uint8 tx_pwr_ctrl_state;
			uint32 tbl_len = 128;
			uint32 tbl_offset = 0;
			uint8 core;
			core = (uint8) int_val;

			tx_pwr_ctrl_state =  pi->txpwrctrl;
			wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core), tbl_len,
			        tbl_offset, 16, estpwr);
			wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
			bcopy(estpwr, a, 128*sizeof(uint16));
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	}

	case IOV_GVAL(IOV_PHY_TXCAL_STATUS):
		if (!pi->sh->up) {
			err = BCME_NOTUP;
		} else {
			*ret_int_ptr = (int32) pi->txcal_status;
		}
		break;
#endif /* WLC_TXCAL */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_txpwrctl(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(*ret_int_ptr);
	BCM_REFERENCE(bool_val);

	switch (actionid) {
#if defined(BCMDBG) || defined(WLTEST) || defined(BCMCCX)
	case IOV_GVAL(IOV_TXINSTPWR):
		wlc_phyreg_enter((wlc_phy_t *)pi);
		/* Return the current instantaneous est. power
		 * For swpwr ctrl it's based on current TSSI value (as opposed to average)
		 */
		wlc_phy_txpower_get_instant(pi, a);
		wlc_phyreg_exit((wlc_phy_t *)pi);
		break;
#endif // endif
#if defined(BCMDBG) || defined(WLTEST)
	case IOV_SVAL(IOV_TSSICAL_START_IDX):
	case IOV_SVAL(IOV_TSSICAL_START):
		if (ISLCNPHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
			uint16 curr_anchor;
			if (!pi->ptssi_cal) {
				pi->ptssi_cal = (tssi_cal_info_t *)MALLOC(pi->sh->osh,
					sizeof(tssi_cal_info_t));
				if (pi->ptssi_cal == NULL) {
					PHY_ERROR(("wl%d: %s: MALLOC failure\n",
						pi->sh->unit, __FUNCTION__));
					err = BCME_UNSUPPORTED;
					break;
				}
				bzero((char *)pi->ptssi_cal, sizeof(tssi_cal_info_t));
			}
			curr_anchor = pi->ptssi_cal->curr_anchor;
			wlc_lcnphy_clear_tx_power_offsets(pi);
			PHY_REG_MOD(pi, LCNPHY, TxPwrCtrlRangeCmd, cckPwrOffset,
				pi_lcn->cckPwrOffset);
			PHY_REG_MOD(pi, LCNPHY, TxPwrCtrlCmd, txPwrCtrl_en, 1);

			if (actionid == IOV_SVAL(IOV_TSSICAL_START_IDX))
				bcopy(p, &(pi->ptssi_cal->anchor_txidx[curr_anchor]),
					sizeof(uint16));
			else
				bcopy(p, &(pi->ptssi_cal->target_pwr_qdBm[curr_anchor]),
					sizeof(int));

			pi->ptssi_cal->paparams_calc_done = 0;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_TSSICAL_POWER):
		if (ISLCNPHY(pi)) {
			uint16 curr_anchor;
			if (!pi->ptssi_cal) {
				err = BCME_UNSUPPORTED;
				break;
			}
			curr_anchor = pi->ptssi_cal->curr_anchor;
			bcopy(p, &(pi->ptssi_cal->measured_pwr_qdBm[curr_anchor]), sizeof(int));
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_TSSICAL_POWER):
		if (ISLCNPHY(pi)) {
			uint16 anchor_var[3];
			uint16 curr_anchor;
			if (!pi->ptssi_cal) {
				err = BCME_UNSUPPORTED;
				break;
			}
			curr_anchor = pi->ptssi_cal->curr_anchor;
			pi->ptssi_cal->anchor_txidx[curr_anchor] =
				wlc_lcnphy_get_current_tx_pwr_idx(pi);
			pi->ptssi_cal->anchor_tssi[curr_anchor] =
				PHY_REG_READ(pi, LCNPHY, TxPwrCtrlStatusNew4, avgTssi);
			pi->ptssi_cal->anchor_bbmult[curr_anchor] =
				wlc_lcnphy_get_bbmult_from_index(pi,
				pi->ptssi_cal->anchor_txidx[curr_anchor]);

			anchor_var[0] = pi->ptssi_cal->anchor_bbmult[curr_anchor];
			anchor_var[1] = pi->ptssi_cal->anchor_txidx[curr_anchor];
			anchor_var[2] = pi->ptssi_cal->anchor_tssi[curr_anchor];

			bcopy(anchor_var, a, 3*sizeof(uint16));

			pi->ptssi_cal->curr_anchor++;
			if (pi->ptssi_cal->curr_anchor >= MAX_NUM_ANCHORS)
				pi->ptssi_cal->curr_anchor = 0;

		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_TSSICAL_PARAMS):
		if (ISLCNPHY(pi)) {
			uint16 num_anchor;
			if (!pi->ptssi_cal) {
				err = BCME_UNSUPPORTED;
				break;
			}
			if ((!pi->ptssi_cal->paparams_calc_done) &&
				(!pi->ptssi_cal->paparams_calc_in_progress)) {

				if (pi->ptssi_cal->anchor_bbmult[0]) { /* Atleast One Anchor */

					pi->ptssi_cal->paparams_calc_in_progress = 1;
					wlc_phy_tssi_cal(pi);

					pi->ptssi_cal->paparams_new[0] =
						pi->ptssi_cal->rsd.c4[0][0];
					pi->ptssi_cal->paparams_new[1] =
						pi->ptssi_cal->rsd.c4[1][0];
					pi->ptssi_cal->paparams_new[2] =
						pi->ptssi_cal->rsd.c4[2][0];
					pi->ptssi_cal->paparams_new[3] =
						pi->ptssi_cal->rsd.det_c1;
				}
				else {
					pi->ptssi_cal->paparams_new[0] = 1;
					pi->ptssi_cal->paparams_new[1] = 1;
					pi->ptssi_cal->paparams_new[2] = 1;
					pi->ptssi_cal->paparams_new[3] = 1;
				}

				pi->ptssi_cal->paparams_calc_done = 1;
			}

			if (pi->ptssi_cal->paparams_calc_done) {
				bcopy(pi->ptssi_cal->paparams_new, a, 4*sizeof(int64));
				pi->ptssi_cal->paparams_calc_in_progress = 0;
				pi->ptssi_cal->curr_anchor = 0;
				for (num_anchor = 0; num_anchor < MAX_NUM_ANCHORS; num_anchor++)
					pi->ptssi_cal->anchor_bbmult[num_anchor] = 0;
			}
		} else
			err = BCME_UNSUPPORTED;
		break;
	case IOV_SVAL(IOV_PHY_TSSITXDELAY):
		if (ISLCNPHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
			pi_lcn->lcnphy_tssical_txdelay = (uint32)int_val;
		}
		break;

	case IOV_GVAL(IOV_PHY_TSSITXDELAY):
		if (ISLCNPHY(pi)) {
			phy_info_lcnphy_t *pi_lcn = pi->u.pi_lcnphy;
			int_val = pi_lcn->lcnphy_tssical_txdelay;
			bcopy(&int_val, a, sizeof(int_val));
		}
		break;
#endif /* BCMDBG || WLTEST */

#if defined(WLTEST) || defined(ATE_BUILD)
	case IOV_GVAL(IOV_PHY_TXPWRCTRL):
		wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_TXPWRCTRL):
		err = wlc_phy_iovar_txpwrctrl(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_SVAL(IOV_PHY_TXPWRINDEX):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		err = wlc_phy_iovar_txpwrindex_set(pi, p);
		break;

	case IOV_GVAL(IOV_PHY_TXPWRINDEX):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		wlc_phy_iovar_txpwrindex_get(pi, int_val, bool_val, ret_int_ptr);
		break;
#endif // endif
#if defined(WLTEST)
	case IOV_GVAL(IOV_PATRIM):
		if (ISACPHY(pi))
			wlc_phy_iovar_patrim_acphy(pi, ret_int_ptr);
		else
			*ret_int_ptr = 0;
	break;

	case IOV_SVAL(IOV_PAVARS): {
		uint16 inpa[WL_PHY_PAVARS_LEN];
		uint j = 3;	/* PA parameters start from offset 3 */
		int chain;
		int freq_range;
		int num_paparams;
		bcopy(p, inpa, sizeof(inpa));
		if (ISHTPHY(pi)) {
			if (inpa[0] != PHY_TYPE_HT) {
				break;
			}

			if (inpa[2] >= PHYCORENUM(pi->pubpi.phy_corenum))
				return BCME_BADARG;

			switch (inpa[1]) {
			case WL_CHAN_FREQ_RANGE_2G:
			case WL_CHAN_FREQ_RANGE_5G_BAND0:
			case WL_CHAN_FREQ_RANGE_5G_BAND1:
			case WL_CHAN_FREQ_RANGE_5G_BAND2:
			case WL_CHAN_FREQ_RANGE_5G_BAND3:
				wlc_phy_pavars_set_htphy(pi, &inpa[j], inpa[1], inpa[2]);
				break;
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[1]));
				break;
			}
		} else if (ISNPHY(pi)) {
			srom_pwrdet_t	*pwrdet  = &pi->pwrdet;

			if (inpa[0] != PHY_TYPE_N)
				break;

			if (inpa[2] > 1)
				return BCME_BADARG;

			pwrdet->pwrdet_a1[inpa[2]][inpa[1]] = inpa[j++];
			pwrdet->pwrdet_b0[inpa[2]][inpa[1]] = inpa[j++];
			pwrdet->pwrdet_b1[inpa[2]][inpa[1]] = inpa[j++];

		} else if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
			if ((inpa[0] != PHY_TYPE_LP) && (inpa[0] != PHY_TYPE_SSN) &&
				(inpa[0] != PHY_TYPE_LCN) && (inpa[0] != PHY_TYPE_LCN40))
				break;

			if (inpa[2] != 0)
				return BCME_BADARG;
#if defined(LCNCONF) || defined(LCNCONF) || defined(LPCONF)
			switch (inpa[1]) {
			case WL_CHAN_FREQ_RANGE_2G:
				pi->txpa_2g[0] = inpa[j++];	/* b0 */
				pi->txpa_2g[1] = inpa[j++];	/* b1 */
				pi->txpa_2g[2] = inpa[j++];	/* a1 */
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5GL:
				pi->txpa_5g_low[0] = inpa[j++];	/* b0 */
				pi->txpa_5g_low[1] = inpa[j++];	/* b1 */
				pi->txpa_5g_low[2] = inpa[j++];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GM:
				pi->txpa_5g_mid[0] = inpa[j++];	/* b0 */
				pi->txpa_5g_mid[1] = inpa[j++];	/* b1 */
				pi->txpa_5g_mid[2] = inpa[j++];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GH:
				pi->txpa_5g_hi[0] = inpa[j++];	/* b0 */
				pi->txpa_5g_hi[1] = inpa[j++];	/* b1 */
				pi->txpa_5g_hi[2] = inpa[j++];	/* a1 */
				break;
#endif /* BAND5G */
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[0]));
				break;
			}
#else
			return BCME_UNSUPPORTED;
#endif /* Older PHYs */
		} else if (ISACPHY(pi)) {
#ifdef WL_CHAN_FREQ_RANGE_5G_4BAND
			int n;
#endif // endif
#ifdef SROM12
			srom12_pwrdet_t *pwrdet = pi->pwrdet12_ac;
#endif // endif
			srom11_pwrdet_t *pwrdet11 = pi->pwrdet_ac;
			chain = inpa[2];
			freq_range = inpa[1];
			num_paparams = PHY_CORE_MAX;

			if ((pi->u.pi_acphy->srom.tssi_div_war) &&
				(ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi))) {
				num_paparams = 3;
			} else if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
				pi->u.pi_acphy->srom.tssi_div_war) {
				num_paparams = 4;
			} else if ((pi->u.pi_acphy->srom_tworangetssi2g) &&
			 (inpa[1] == WL_CHAN_FREQ_RANGE_2G) && pi->ipa2g_on &&
				(ACMAJORREV_1(pi->pubpi.phy_rev))) {
				num_paparams = 2;
			} else if ((pi->u.pi_acphy->srom_tworangetssi5g) &&
			 (inpa[1] != WL_CHAN_FREQ_RANGE_2G) && pi->ipa5g_on &&
				(ACMAJORREV_1(pi->pubpi.phy_rev))) {
				num_paparams = 2;
			}

			if (inpa[0] != PHY_TYPE_AC) {
				PHY_ERROR(("Wrong phy type %d\n", inpa[0]));
				break;
			}

			if (chain > (num_paparams - 1)) {
				PHY_ERROR(("Wrong chain number %d\n", chain));
				break;
			}

			switch (freq_range) {
			case WL_CHAN_FREQ_RANGE_2G:
#ifdef SROM12
			  if (pi->sh->sromrev == 12) {
			    pwrdet->pwrdet_a[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_b[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_c[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_d[chain][freq_range] = inpa[j++];
			  }
#endif // endif
			  if (pi->sh->sromrev < 12) {
			    pwrdet11->pwrdet_a1[chain][freq_range] = inpa[j++];
			    pwrdet11->pwrdet_b0[chain][freq_range] = inpa[j++];
			    pwrdet11->pwrdet_b1[chain][freq_range] = inpa[j++];
			  }
			  break;
#ifdef SROM12
			case WL_CHAN_FREQ_RANGE_2G_40:
			  pwrdet->pwrdet_a_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_b_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_c_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_d_40[chain][freq_range-6] = inpa[j++];
			  break;
#endif // endif
/* allow compile in branches without 4BAND definition */
#ifdef WL_CHAN_FREQ_RANGE_5G_4BAND
			case WL_CHAN_FREQ_RANGE_5G_4BAND:
			  /* or WL_CHAN_FREQ_RANGE_5G_BAND4, since both macro have same val. */
			  /* all 4 subband params for srom<12 */
			  /* or 5th subband params for srom=12 respectively */
#ifdef SROM12
			  if (pi->sh->sromrev == 12) {
			    pwrdet->pwrdet_a[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_b[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_c[chain][freq_range] = inpa[j++];
			    pwrdet->pwrdet_d[chain][freq_range] = inpa[j++];
			  }
#endif // endif
			  if (pi->sh->sromrev < 12) {
			    for (n = 1; n <= 4; n ++) {
			      pwrdet11->pwrdet_a1[chain][n] = inpa[j++];
			      pwrdet11->pwrdet_b0[chain][n] = inpa[j++];
			      pwrdet11->pwrdet_b1[chain][n] = inpa[j++];
			    }
			  }
			  break;

			case WL_CHAN_FREQ_RANGE_5G_BAND0:
			case WL_CHAN_FREQ_RANGE_5G_BAND1:
			case WL_CHAN_FREQ_RANGE_5G_BAND2:
			case WL_CHAN_FREQ_RANGE_5G_BAND3:
				if (ACMAJORREV_2(pi->pubpi.phy_rev) ||
				    ACMAJORREV_5(pi->pubpi.phy_rev)) {
#ifdef SROM12
				  if (pi->sh->sromrev == 12) {
				    pwrdet->pwrdet_a[chain][freq_range] = inpa[j++];
				    pwrdet->pwrdet_b[chain][freq_range] = inpa[j++];
				    pwrdet->pwrdet_c[chain][freq_range] = inpa[j++];
				    pwrdet->pwrdet_d[chain][freq_range] = inpa[j++];
				  }
#endif // endif
				  if (pi->sh->sromrev < 12) {
				    pwrdet11->pwrdet_a1[chain][freq_range] = inpa[j++];
				    pwrdet11->pwrdet_b0[chain][freq_range] = inpa[j++];
				    pwrdet11->pwrdet_b1[chain][freq_range] = inpa[j++];
				  }
				} else {
					PHY_ERROR(("bandrange %d is out of scope\n",
					           inpa[1]));
				}
				break;

#ifdef SROM12
			case WL_CHAN_FREQ_RANGE_5G_BAND0_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND1_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND2_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND3_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND4_40:
			  pwrdet->pwrdet_a_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_b_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_c_40[chain][freq_range-6] = inpa[j++];
			  pwrdet->pwrdet_d_40[chain][freq_range-6] = inpa[j++];
			  break;

			case WL_CHAN_FREQ_RANGE_5G_BAND0_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND1_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND2_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND3_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND4_80:
			  pwrdet->pwrdet_a_80[chain][freq_range-12] = inpa[j++];
			  pwrdet->pwrdet_b_80[chain][freq_range-12] = inpa[j++];
			  pwrdet->pwrdet_c_80[chain][freq_range-12] = inpa[j++];
			  pwrdet->pwrdet_d_80[chain][freq_range-12] = inpa[j++];
			  break;

			case WL_CHAN_FREQ_RANGE_5G_5BAND:
				for (n = 1; n <= 5; n++) {
				  pwrdet->pwrdet_a[chain][n] = inpa[j++];
				  pwrdet->pwrdet_b[chain][n] = inpa[j++];
				  pwrdet->pwrdet_c[chain][n] = inpa[j++];
				  pwrdet->pwrdet_d[chain][n] = inpa[j++];
				}
				break;
			case WL_CHAN_FREQ_RANGE_5G_5BAND_40:
			        for (n = 1; n <= 5; n++) {
				  pwrdet->pwrdet_a_40[chain][n] = inpa[j++];
				  pwrdet->pwrdet_b_40[chain][n] = inpa[j++];
				  pwrdet->pwrdet_c_40[chain][n] = inpa[j++];
				  pwrdet->pwrdet_d_40[chain][n] = inpa[j++];
				}
				break;
			case WL_CHAN_FREQ_RANGE_5G_5BAND_80:
			        for (n = 0; n <= 4; n++) {
				  pwrdet->pwrdet_a_80[chain][n] = inpa[j++];
				  pwrdet->pwrdet_b_80[chain][n] = inpa[j++];
				  pwrdet->pwrdet_c_80[chain][n] = inpa[j++];
				  pwrdet->pwrdet_d_80[chain][n] = inpa[j++];
				}
				break;
#endif /* SROM12 */
#endif /* WL_CHAN_FREQ_RANGE_5G_4BAND */
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[1]));
				break;
			}
		} else {
			PHY_ERROR(("Unsupported PHY type!\n"));
			err = BCME_UNSUPPORTED;
		}
	}
	break;
	case IOV_GVAL(IOV_PAVARS2): {
			wl_pavars2_t *invar = (wl_pavars2_t *)p;
			wl_pavars2_t *outvar = (wl_pavars2_t *)a;
			uint16 *outpa = outvar->inpa;
			uint j = 0; /* PA parameters start from offset */

			if (invar->ver	!= WL_PHY_PAVAR_VER) {
				PHY_ERROR(("Incompatible version; use %d expected version %d\n",
					invar->ver, WL_PHY_PAVAR_VER));
				return BCME_BADARG;
			}

			outvar->ver = WL_PHY_PAVAR_VER;
			outvar->len = sizeof(wl_pavars2_t);
			if (wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec)
				== invar->bandrange)
				outvar->inuse = 1;
			else
				outvar->inuse = 0;

#ifdef BAND5G
			if (pi->sh->subband5Gver == PHY_SUBBAND_5BAND) {
				if ((invar->bandrange == WL_CHAN_FREQ_RANGE_5GL) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GM) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GH)) {
					outvar->phy_type = PHY_TYPE_NULL;
					break;
				}
			}

			if (pi->sh->subband5Gver == PHY_SUBBAND_3BAND_JAPAN) {
				if ((invar->bandrange == WL_CHAN_FREQ_RANGE_5GLL_5BAND) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GLH_5BAND) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GML_5BAND) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GMH_5BAND) ||
					(invar->bandrange == WL_CHAN_FREQ_RANGE_5GH_5BAND)) {
					outvar->phy_type = PHY_TYPE_NULL;
					break;
				}
			}
#endif /* BAND5G */

			if (ISHTPHY(pi)) {
				if (invar->phy_type != PHY_TYPE_HT) {
					outvar->phy_type = PHY_TYPE_NULL;
					break;
				}

				if (invar->chain >= PHYCORENUM(pi->pubpi.phy_corenum))
					return BCME_BADARG;

				switch (invar->bandrange) {
				case WL_CHAN_FREQ_RANGE_2G:
				case WL_CHAN_FREQ_RANGE_5GL:
				case WL_CHAN_FREQ_RANGE_5GM:
				case WL_CHAN_FREQ_RANGE_5GH:
				case WL_CHAN_FREQ_RANGE_5GLL_5BAND:
				case WL_CHAN_FREQ_RANGE_5GLH_5BAND:
				case WL_CHAN_FREQ_RANGE_5GML_5BAND:
				case WL_CHAN_FREQ_RANGE_5GMH_5BAND:
				case WL_CHAN_FREQ_RANGE_5GH_5BAND:
					wlc_phy_pavars_get_htphy(pi, &outpa[j], invar->bandrange,
						invar->chain);
					break;
				default:
					PHY_ERROR(("bandrange %d is out of scope\n",
						invar->bandrange));
					break;
				}
			} else if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
				if ((invar->phy_type != PHY_TYPE_LP) &&
					(invar->phy_type != PHY_TYPE_SSN) &&
					(invar->phy_type != PHY_TYPE_LCN) &&
					(invar->phy_type != PHY_TYPE_LCN40)) {
					outvar->phy_type = PHY_TYPE_NULL;
					break;
				}

				if (invar->chain != 0)
					return BCME_BADARG;

				switch (invar->bandrange) {
				case WL_CHAN_FREQ_RANGE_2G:
					outpa[j++] = pi->txpa_2g[0];		/* b0 */
					outpa[j++] = pi->txpa_2g[1];		/* b1 */
					outpa[j++] = pi->txpa_2g[2];		/* a1 */
					break;
#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5GL:
					outpa[j++] = pi->txpa_5g_low[0];	/* b0 */
					outpa[j++] = pi->txpa_5g_low[1];	/* b1 */
					outpa[j++] = pi->txpa_5g_low[2];	/* a1 */
					break;

				case WL_CHAN_FREQ_RANGE_5GM:
					outpa[j++] = pi->txpa_5g_mid[0];	/* b0 */
					outpa[j++] = pi->txpa_5g_mid[1];	/* b1 */
					outpa[j++] = pi->txpa_5g_mid[2];	/* a1 */
					break;

				case WL_CHAN_FREQ_RANGE_5GH:
					outpa[j++] = pi->txpa_5g_hi[0]; /* b0 */
					outpa[j++] = pi->txpa_5g_hi[1]; /* b1 */
					outpa[j++] = pi->txpa_5g_hi[2]; /* a1 */
					break;
#endif /* BAND5G */
				default:
					PHY_ERROR(("bandrange %d is out of scope\n",
						invar->bandrange));
					break;
				}
			} else {
				PHY_ERROR(("Unsupported PHY type!\n"));
				err = BCME_UNSUPPORTED;
			}
		}
		break;

		case IOV_SVAL(IOV_PAVARS2): {
			wl_pavars2_t *invar = (wl_pavars2_t *)p;
			uint16 *inpa = invar->inpa;
			uint j = 0; /* PA parameters start from offset */

			if (invar->ver	!= WL_PHY_PAVAR_VER) {
				PHY_ERROR(("Incompatible version; use %d expected version %d\n",
					invar->ver, WL_PHY_PAVAR_VER));
				return BCME_BADARG;
			}

			if (ISHTPHY(pi)) {
				if (invar->phy_type != PHY_TYPE_HT) {
					break;
				}

				if (invar->chain >= PHYCORENUM(pi->pubpi.phy_corenum))
					return BCME_BADARG;

				switch (invar->bandrange) {
				case WL_CHAN_FREQ_RANGE_2G:
				case WL_CHAN_FREQ_RANGE_5GL:
				case WL_CHAN_FREQ_RANGE_5GM:
				case WL_CHAN_FREQ_RANGE_5GH:
				case WL_CHAN_FREQ_RANGE_5GLL_5BAND:
				case WL_CHAN_FREQ_RANGE_5GLH_5BAND:
				case WL_CHAN_FREQ_RANGE_5GML_5BAND:
				case WL_CHAN_FREQ_RANGE_5GMH_5BAND:
				case WL_CHAN_FREQ_RANGE_5GH_5BAND:
					if (invar->bandrange < (CH_2G_GROUP + CH_5G_4BAND)) {
						wlc_phy_pavars_set_htphy(pi, &inpa[j],
							invar->bandrange, invar->chain);
					} else {
						err = BCME_RANGE;
						PHY_ERROR(("bandrange %d is out of scope\n",
							invar->bandrange));
					}
					break;
				default:
					err = BCME_RANGE;
					PHY_ERROR(("bandrange %d is out of scope\n",
						invar->bandrange));
					break;
				}
			} else if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
				if ((invar->phy_type != PHY_TYPE_LP) &&
					(invar->phy_type != PHY_TYPE_SSN) &&
					(invar->phy_type != PHY_TYPE_LCN) &&
					(invar->phy_type != PHY_TYPE_LCN40))
					break;

				if (invar->chain != 0)
					return BCME_BADARG;

				switch (invar->bandrange) {
				case WL_CHAN_FREQ_RANGE_2G:
					pi->txpa_2g[0] = inpa[j++]; /* b0 */
					pi->txpa_2g[1] = inpa[j++]; /* b1 */
					pi->txpa_2g[2] = inpa[j++]; /* a1 */
					break;
#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5GL:
					pi->txpa_5g_low[0] = inpa[j++]; /* b0 */
					pi->txpa_5g_low[1] = inpa[j++]; /* b1 */
					pi->txpa_5g_low[2] = inpa[j++]; /* a1 */
					break;

				case WL_CHAN_FREQ_RANGE_5GM:
					pi->txpa_5g_mid[0] = inpa[j++]; /* b0 */
					pi->txpa_5g_mid[1] = inpa[j++]; /* b1 */
					pi->txpa_5g_mid[2] = inpa[j++]; /* a1 */
					break;

				case WL_CHAN_FREQ_RANGE_5GH:
					pi->txpa_5g_hi[0] = inpa[j++];	/* b0 */
					pi->txpa_5g_hi[1] = inpa[j++];	/* b1 */
					pi->txpa_5g_hi[2] = inpa[j++];	/* a1 */
					break;
#endif /* BAND5G */
				default:
					PHY_ERROR(("bandrange %d is out of scope\n",
						invar->bandrange));
					break;
				}
			} else {
				PHY_ERROR(("Unsupported PHY type!\n"));
				err = BCME_UNSUPPORTED;
			}
		}
		break;

	case IOV_GVAL(IOV_POVARS): {
		wl_po_t tmppo;

		/* tmppo has the input phy_type and band */
		bcopy(p, &tmppo, sizeof(wl_po_t));
		if (ISHTPHY(pi)) {
			if ((tmppo.phy_type != PHY_TYPE_HT) && (tmppo.phy_type != PHY_TYPE_N))  {
				tmppo.phy_type = PHY_TYPE_NULL;
				break;
			}

			err = wlc_phy_get_po_htphy(pi, &tmppo);
			if (!err)
				bcopy(&tmppo, a, sizeof(wl_po_t));
			break;
		} else if (ISNPHY(pi)) {
			if (tmppo.phy_type != PHY_TYPE_N)  {
				tmppo.phy_type = PHY_TYPE_NULL;
				break;
			}

			/* Power offsets variables depend on the SROM revision */
			if (NREV_GE(pi->pubpi.phy_rev, 8) && (pi->sh->sromrev >= 9)) {
				err = wlc_phy_get_po_htphy(pi, &tmppo);

			} else {
				switch (tmppo.band) {
				case WL_CHAN_FREQ_RANGE_2G:
					tmppo.cckpo = pi->ppr.sr8.cck2gpo;
					tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
					bcopy(&pi->ppr.sr8.mcs[tmppo.band][0], &tmppo.mcspo,
						8*sizeof(uint16));
					break;
#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5G_BAND0:
					tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
					bcopy(&pi->ppr.sr8.mcs[tmppo.band], &tmppo.mcspo,
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND1:
					tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
					bcopy(&pi->ppr.sr8.mcs[tmppo.band], &tmppo.mcspo,
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND2:
					tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
					bcopy(&pi->ppr.sr8.mcs[tmppo.band], &tmppo.mcspo,
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND3:
					tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
					bcopy(&pi->ppr.sr8.mcs[tmppo.band], &tmppo.mcspo,
						8*sizeof(uint16));
					break;
#endif /* BAND5G */
				default:
					PHY_ERROR(("bandrange %d is out of scope\n", tmppo.band));
					err = BCME_BADARG;
					break;
				}
			}

			if (!err)
				bcopy(&tmppo, a, sizeof(wl_po_t));
		} else if (ISLCNCOMMONPHY(pi)) {
			if ((tmppo.phy_type != PHY_TYPE_LCN) &&
				(tmppo.phy_type != PHY_TYPE_LCN40)) {
				tmppo.phy_type = PHY_TYPE_NULL;
				break;
			}

			switch (tmppo.band) {
			case WL_CHAN_FREQ_RANGE_2G:
				tmppo.cckpo = pi->ppr.sr8.cck2gpo;
				tmppo.ofdmpo = pi->ppr.sr8.ofdm[tmppo.band];
				bcopy(&pi->ppr.sr8.mcs[tmppo.band], &tmppo.mcspo, 8*sizeof(uint16));

				break;

			default:
				PHY_ERROR(("bandrange %d is out of scope\n", tmppo.band));
				err = BCME_BADARG;
				break;
			}

			if (!err)
				bcopy(&tmppo, a, sizeof(wl_po_t));
		} else {
			PHY_ERROR(("Unsupported PHY type!\n"));
			err = BCME_UNSUPPORTED;
		}
	}
	break;

	case IOV_SVAL(IOV_POVARS): {
		wl_po_t inpo;

		bcopy(p, &inpo, sizeof(wl_po_t));

		if (ISHTPHY(pi)) {
			if ((inpo.phy_type == PHY_TYPE_HT) || (inpo.phy_type == PHY_TYPE_N))
				err = wlc_phy_set_po_htphy(pi, &inpo);
			break;
		} else if (ISNPHY(pi)) {
			if (inpo.phy_type != PHY_TYPE_N)
				break;

			/* Power offsets variables depend on the SROM revision */
			if (NREV_GE(pi->pubpi.phy_rev, 8) && (pi->sh->sromrev >= 9)) {
				err = wlc_phy_set_po_htphy(pi, &inpo);

			} else {

				switch (inpo.band) {
				case WL_CHAN_FREQ_RANGE_2G:
					pi->ppr.sr8.cck2gpo = inpo.cckpo;
					pi->ppr.sr8.ofdm[inpo.band]  = inpo.ofdmpo;
					bcopy(inpo.mcspo, &(pi->ppr.sr8.mcs[inpo.band][0]),
						8*sizeof(uint16));
					break;
#ifdef BAND5G
				case WL_CHAN_FREQ_RANGE_5G_BAND0:
					pi->ppr.sr8.ofdm[inpo.band] = inpo.ofdmpo;
					bcopy(inpo.mcspo, &(pi->ppr.sr8.mcs[inpo.band][0]),
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND1:
					pi->ppr.sr8.ofdm[inpo.band] = inpo.ofdmpo;
					bcopy(inpo.mcspo, &(pi->ppr.sr8.mcs[inpo.band][0]),
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND2:
					pi->ppr.sr8.ofdm[inpo.band] = inpo.ofdmpo;
					bcopy(inpo.mcspo, &(pi->ppr.sr8.mcs[inpo.band][0]),
						8*sizeof(uint16));
					break;

				case WL_CHAN_FREQ_RANGE_5G_BAND3:
					pi->ppr.sr8.ofdm[inpo.band] = inpo.ofdmpo;
					bcopy(inpo.mcspo, &(pi->ppr.sr8.mcs[inpo.band][0]),
						8*sizeof(uint16));
					break;
#endif /* BAND5G */
				default:
					PHY_ERROR(("bandrange %d is out of scope\n", inpo.band));
					err = BCME_BADARG;
					break;
				}

			}

		} else {
			PHY_ERROR(("Unsupported PHY type!\n"));
			err = BCME_UNSUPPORTED;
		}
	}
	break;
#endif // endif
	case IOV_GVAL(IOV_PAVARS): {
		uint16 *outpa = a;
		uint16 inpa[WL_PHY_PAVARS_LEN];
		uint j = 3;	/* PA parameters start from offset 3 */
		int chain;
		int freq_range;
		int num_paparams;

		bcopy(p, inpa, sizeof(inpa));

		outpa[0] = inpa[0]; /* Phy type */
		outpa[1] = inpa[1]; /* Band range */
		outpa[2] = inpa[2]; /* Chain */

		if (ISHTPHY(pi)) {
			if (inpa[0] != PHY_TYPE_HT) {
				outpa[0] = PHY_TYPE_NULL;
				break;
			}

			if (inpa[2] >= PHYCORENUM(pi->pubpi.phy_corenum))
				return BCME_BADARG;

			switch (inpa[1]) {
			case WL_CHAN_FREQ_RANGE_2G:
			case WL_CHAN_FREQ_RANGE_5G_BAND0:
			case WL_CHAN_FREQ_RANGE_5G_BAND1:
			case WL_CHAN_FREQ_RANGE_5G_BAND2:
			case WL_CHAN_FREQ_RANGE_5G_BAND3:
				wlc_phy_pavars_get_htphy(pi, &outpa[j], inpa[1], inpa[2]);
				break;
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[1]));
				break;
			}
		} else if (ISNPHY(pi)) {
			srom_pwrdet_t	*pwrdet  = &pi->pwrdet;

			if (inpa[0] != PHY_TYPE_N) {
				outpa[0] = PHY_TYPE_NULL;
				break;
			}
			outpa[j++] = pwrdet->pwrdet_a1[inpa[2]][inpa[1]];	/* a1 */
			outpa[j++] = pwrdet->pwrdet_b0[inpa[2]][inpa[1]];	/* b0 */
			outpa[j++] = pwrdet->pwrdet_b1[inpa[2]][inpa[1]];	/* b1 */
		} else if (ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNCOMMONPHY(pi)) {
			if ((inpa[0] != PHY_TYPE_LP) && (inpa[0] != PHY_TYPE_SSN) &&
				((inpa[0] != PHY_TYPE_LCN) && (inpa[0] != PHY_TYPE_LCN40))) {
				outpa[0] = PHY_TYPE_NULL;
				break;
			}

			if (inpa[2] != 0)
				return BCME_BADARG;
#if defined(LCNCONF) || defined(LCNCONF) || defined(LPCONF)
			switch (inpa[1]) {
			case WL_CHAN_FREQ_RANGE_2G:
				outpa[j++] = pi->txpa_2g[0];		/* b0 */
				outpa[j++] = pi->txpa_2g[1];		/* b1 */
				outpa[j++] = pi->txpa_2g[2];		/* a1 */
				break;
#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5GL:
				outpa[j++] = pi->txpa_5g_low[0];	/* b0 */
				outpa[j++] = pi->txpa_5g_low[1];	/* b1 */
				outpa[j++] = pi->txpa_5g_low[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GM:
				outpa[j++] = pi->txpa_5g_mid[0];	/* b0 */
				outpa[j++] = pi->txpa_5g_mid[1];	/* b1 */
				outpa[j++] = pi->txpa_5g_mid[2];	/* a1 */
				break;

			case WL_CHAN_FREQ_RANGE_5GH:
				outpa[j++] = pi->txpa_5g_hi[0];	/* b0 */
				outpa[j++] = pi->txpa_5g_hi[1];	/* b1 */
				outpa[j++] = pi->txpa_5g_hi[2];	/* a1 */
				break;
#endif /* BAND5G */
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[0]));
				break;
			}
#else
			return BCME_UNSUPPORTED;
#endif /* older PHYs */
		} else if (ISACPHY(pi)) {
#ifdef WL_CHAN_FREQ_RANGE_5G_4BAND
			int n;
#endif // endif
#ifdef SROM12
			srom12_pwrdet_t *pwrdet = pi->pwrdet12_ac;
#endif // endif
			srom11_pwrdet_t *pwrdet11 = pi->pwrdet_ac;

			chain = inpa[2];
			num_paparams = PHY_CORE_MAX;
			freq_range = inpa[1];

			if ((pi->u.pi_acphy->srom.tssi_div_war) &&
				(ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi))) {
				num_paparams = 3;
			} else if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
				pi->u.pi_acphy->srom.tssi_div_war) {
				num_paparams = 4;
			} else if ((pi->u.pi_acphy->srom_tworangetssi2g) &&
			 (inpa[1] == WL_CHAN_FREQ_RANGE_2G) && pi->ipa2g_on &&
				(ACMAJORREV_1(pi->pubpi.phy_rev))) {
				num_paparams = 2;
			} else if ((pi->u.pi_acphy->srom_tworangetssi5g) &&
			 (inpa[1] != WL_CHAN_FREQ_RANGE_2G) && pi->ipa5g_on &&
				(ACMAJORREV_1(pi->pubpi.phy_rev))) {
				num_paparams = 2;
			}
			if (inpa[0] != PHY_TYPE_AC) {
				PHY_ERROR(("Wrong phy type %d\n", inpa[0]));
				outpa[0] = PHY_TYPE_NULL;
				break;
			}
			if (chain > (num_paparams - 1)) {
				PHY_ERROR(("Wrong chain number %d\n", chain));
				outpa[0] = PHY_TYPE_NULL;
				break;
			}

			switch (freq_range) {
			case WL_CHAN_FREQ_RANGE_2G:
#ifdef SROM12
			  if (pi->sh->sromrev == 12) {
				outpa[j++] = pwrdet->pwrdet_a[chain][freq_range];
				outpa[j++] = pwrdet->pwrdet_b[chain][freq_range];
				outpa[j++] = pwrdet->pwrdet_c[chain][freq_range];
				outpa[j++] = pwrdet->pwrdet_d[chain][freq_range];
			  }
#endif // endif
			  if (pi->sh->sromrev < 12) {
				outpa[j++] = pwrdet11->pwrdet_a1[chain][freq_range];
				outpa[j++] = pwrdet11->pwrdet_b0[chain][freq_range];
				outpa[j++] = pwrdet11->pwrdet_b1[chain][freq_range];
			  }
				break;
#ifdef SROM12
			case WL_CHAN_FREQ_RANGE_2G_40:
				outpa[j++] = pwrdet->pwrdet_a_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_b_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_c_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_d_40[chain][freq_range-6];
				break;
#endif // endif
/* allow compile in branches without 4BAND definition */
#ifdef WL_CHAN_FREQ_RANGE_5G_4BAND
			case WL_CHAN_FREQ_RANGE_5G_4BAND:
			  /* or WL_CHAN_FREQ_RANGE_5G_BAND4, since both macro have same val. */
			  /* all 4 subband params for srom<12 */
			  /* or 5th subband params for srom=12 respectively */
#ifdef SROM12
			  if (pi->sh->sromrev == 12) {
			    outpa[j++] = pwrdet->pwrdet_a[chain][freq_range];
			    outpa[j++] = pwrdet->pwrdet_b[chain][freq_range];
			    outpa[j++] = pwrdet->pwrdet_c[chain][freq_range];
			    outpa[j++] = pwrdet->pwrdet_d[chain][freq_range];
			  }
#endif // endif
			  if (pi->sh->sromrev < 12) {
			    for (n = 1; n <= 4; n ++) {
			      outpa[j++] = pwrdet11->pwrdet_a1[chain][n];
			      outpa[j++] = pwrdet11->pwrdet_b0[chain][n];
			      outpa[j++] = pwrdet11->pwrdet_b1[chain][n];
			    }
			  }
			  break;

			case WL_CHAN_FREQ_RANGE_5G_BAND0:
			case WL_CHAN_FREQ_RANGE_5G_BAND1:
			case WL_CHAN_FREQ_RANGE_5G_BAND2:
			case WL_CHAN_FREQ_RANGE_5G_BAND3:
				if (ACMAJORREV_2(pi->pubpi.phy_rev) ||
				    ACMAJORREV_5(pi->pubpi.phy_rev)) {
#ifdef SROM12
				  if (pi->sh->sromrev == 12) {
					outpa[j++] = pwrdet->pwrdet_a[chain][freq_range];
					outpa[j++] = pwrdet->pwrdet_b[chain][freq_range];
					outpa[j++] = pwrdet->pwrdet_c[chain][freq_range];
					outpa[j++] = pwrdet->pwrdet_d[chain][freq_range];
				  }
#endif // endif
				  if (pi->sh->sromrev < 12) {
					outpa[j++] = pwrdet11->pwrdet_a1[chain][freq_range];
					outpa[j++] = pwrdet11->pwrdet_b0[chain][freq_range];
					outpa[j++] = pwrdet11->pwrdet_b1[chain][freq_range];
				  }
				} else {
					PHY_ERROR(("bandrange %d is out of scope\n",
					           inpa[1]));
				}
				break;

#ifdef SROM12
			case WL_CHAN_FREQ_RANGE_5G_BAND0_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND1_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND2_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND3_40:
			case WL_CHAN_FREQ_RANGE_5G_BAND4_40:
				outpa[j++] = pwrdet->pwrdet_a_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_b_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_c_40[chain][freq_range-6];
				outpa[j++] = pwrdet->pwrdet_d_40[chain][freq_range-6];
				break;

			case WL_CHAN_FREQ_RANGE_5G_BAND0_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND1_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND2_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND3_80:
			case WL_CHAN_FREQ_RANGE_5G_BAND4_80:
				outpa[j++] = pwrdet->pwrdet_a_80[chain][freq_range-12];
				outpa[j++] = pwrdet->pwrdet_b_80[chain][freq_range-12];
				outpa[j++] = pwrdet->pwrdet_c_80[chain][freq_range-12];
				outpa[j++] = pwrdet->pwrdet_d_80[chain][freq_range-12];
				break;

			case WL_CHAN_FREQ_RANGE_5G_5BAND:
				for (n = 1; n <= 5; n++) {
				        outpa[j++] = pwrdet->pwrdet_a[chain][n];
					outpa[j++] = pwrdet->pwrdet_b[chain][n];
					outpa[j++] = pwrdet->pwrdet_c[chain][n];
					outpa[j++] = pwrdet->pwrdet_d[chain][n];
				}
				break;
			case WL_CHAN_FREQ_RANGE_5G_5BAND_40:
			        for (n = 1; n <= 5; n++) {
				        outpa[j++] = pwrdet->pwrdet_a_40[chain][n];
					outpa[j++] = pwrdet->pwrdet_b_40[chain][n];
					outpa[j++] = pwrdet->pwrdet_c_40[chain][n];
					outpa[j++] = pwrdet->pwrdet_d_40[chain][n];
				}
				break;
			case WL_CHAN_FREQ_RANGE_5G_5BAND_80:
			        for (n = 0; n <= 4; n++) {
				        outpa[j++] = pwrdet->pwrdet_a_80[chain][n];
					outpa[j++] = pwrdet->pwrdet_b_80[chain][n];
					outpa[j++] = pwrdet->pwrdet_c_80[chain][n];
					outpa[j++] = pwrdet->pwrdet_d_80[chain][n];
				}
				break;
#endif /* SROM12 */
#endif /* WL_CHAN_FREQ_RANGE_5G_4BAND */
			default:
				PHY_ERROR(("bandrange %d is out of scope\n", inpa[1]));
				break;
			}
		} else {
			PHY_ERROR(("Unsupported PHY type!\n"));
			err = BCME_UNSUPPORTED;
		}
	}
	break;

	case IOV_GVAL(IOV_PA_BW_VER): {
		if (ISACPHY(pi)) {
			*ret_int_ptr = pi->u.pi_acphy->paparambwver;
		} else {
			*ret_int_ptr  = 0;
		}
	}
	break;

	case IOV_GVAL(IOV_SROM_REV): {
			*ret_int_ptr = pi->sh->sromrev;
	}
	break;
#ifdef WLTEST
	case IOV_GVAL(IOV_PHY_MAXP): {
		if (ISNPHY(pi)) {
			srom_pwrdet_t	*pwrdet  = &pi->pwrdet;
			uint8*	maxp = (uint8*)a;

			maxp[0] = pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_2G];
			maxp[1] = pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_2G];
			maxp[2] = pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND0];
			maxp[3] = pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND0];
			maxp[4] = pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND1];
			maxp[5] = pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND1];
			maxp[6] = pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND2];
			maxp[7] = pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND2];
			if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			{
				maxp[8] = pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND3];
				maxp[9] = pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND3];
			}
		}
		break;
	}
	case IOV_SVAL(IOV_PHY_MAXP): {
		if (ISNPHY(pi)) {
			uint8*	maxp = (uint8*)p;
			srom_pwrdet_t	*pwrdet  = &pi->pwrdet;

			pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_2G] = maxp[0];
			pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_2G] = maxp[1];
			pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND0] = maxp[2];
			pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND0] = maxp[3];
			pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND1] = maxp[4];
			pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND1] = maxp[5];
			pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND2] = maxp[6];
			pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND2] = maxp[7];
			if (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)
			{
				pwrdet->max_pwr[PHY_CORE_0][WL_CHAN_FREQ_RANGE_5G_BAND3] = maxp[8];
				pwrdet->max_pwr[PHY_CORE_1][WL_CHAN_FREQ_RANGE_5G_BAND3] = maxp[9];
			}
		}
		break;
	}
#endif /* WLTEST */
#if defined(WLC_TXPWRCAP)
	case IOV_GVAL(IOV_PHY_CELLSTATUS):
		if (ISACPHY(pi)) {
			*ret_int_ptr = wlc_phy_txpwrcap_get_cellstatus_acphy(pi);
		}
		else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_GVAL(IOV_PHY_TXPWRCAP):
		if (ISACPHY(pi)) {
			*ret_int_ptr = wlc_phy_get_txpwrcap_inuse_acphy(pi);
		}
		break;
	case IOV_SVAL(IOV_PHY_CELLSTATUS):
		if (ISACPHY(pi)) {
			if (int_val == -1)
				/* Clear the Force bit allowing WCI2 updates to take effect */
				wlc_phy_txpwrcap_set_cellstatus_acphy(pi,
					(TXPWRCAP_CELLSTATUS_FORCE_MASK |
					TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK),
					0);
			else
				wlc_phy_txpwrcap_set_cellstatus_acphy(pi,
					(TXPWRCAP_CELLSTATUS_FORCE_MASK |
					TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK |
					TXPWRCAP_CELLSTATUS_MASK),
					(TXPWRCAP_CELLSTATUS_FORCE_MASK |
					TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK |
					(int_val & TXPWRCAP_CELLSTATUS_MASK)));
		}
		break;
	case IOV_GVAL(IOV_PHY_TXPWRCAP_TBL):
		if (ISACPHY(pi)) {
			wl_txpwrcap_tbl_t txpwrcap_tbl;
			err = wlc_phy_txpwrcap_tbl_get((wlc_phy_t*)pi, &txpwrcap_tbl);
			if (err == BCME_OK)
				bcopy(&txpwrcap_tbl, a, sizeof(wl_txpwrcap_tbl_t));
		}
		break;
	case IOV_SVAL(IOV_PHY_TXPWRCAP_TBL):
		if (ISACPHY(pi)) {
			wl_txpwrcap_tbl_t txpwrcap_tbl;
			bcopy(p, &txpwrcap_tbl, sizeof(wl_txpwrcap_tbl_t));
			err = wlc_phy_txpwrcap_tbl_set((wlc_phy_t*)pi, &txpwrcap_tbl);
		}
		break;
#endif /* WLC_TXPWRCAP */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_rssi(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	BCM_REFERENCE(*ret_int_ptr);

	switch (actionid) {
#if defined(WLTEST)
	case IOV_GVAL(IOV_UNMOD_RSSI):
	{
		int32 input_power_db = 0;
		rxsigpwrfn_t rx_sig_pwr_fn = pi->pi_fptr.rxsigpwr;

		PHY_INFORM(("UNMOD RSSI Called\n"));

		if (!rx_sig_pwr_fn)
			return BCME_UNSUPPORTED;	/* lpphy and sslnphy support only for now */

		if (!pi->sh->up) {
			err = BCME_NOTUP;
			break;
		}

		input_power_db = (*rx_sig_pwr_fn)(pi, -1);

#if defined(WLNOKIA_NVMEM)
		input_power_db = wlc_phy_upd_rssi_offset(pi,
			(int8)input_power_db, pi->radio_chanspec);
#endif // endif

		*ret_int_ptr = input_power_db;
		break;
	}
#endif // endif
#if (defined(NCONF) || defined(LCN40CONF)) && defined(WLTEST) || ACCONF
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_CAL_TEMP):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			*ret_int_ptr = (int32)pi_lcn40->gain_cal_temp;
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			*ret_int_ptr = (int32)pi_nphy->gain_cal_temp;
		}
		break;

	case IOV_SVAL(IOV_PHY_RSSI_GAIN_CAL_TEMP):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			pi_lcn40->gain_cal_temp = (int8)int_val;
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			pi_nphy->gain_cal_temp = (int8)int_val;
		}
		break;
	case IOV_SVAL(IOV_PHY_RSSI_CAL_FREQ_GRP_2G):
	{
		int8 i;
		uint8 *nvramValues = p;

		for (i = 0; i < 14; i++) {
			pi->u.pi_acphy->srom.rssi_cal_freq_grp[i] =
				nvramValues[i];
		}
		break;
	}
	case IOV_GVAL(IOV_PHY_RSSI_CAL_FREQ_GRP_2G):
	{
		int8 i;
		uint8 *nvramValues = a;

		for (i = 0; i < 14; i++) {
		 nvramValues[i] =
		   pi->u.pi_acphy->srom.rssi_cal_freq_grp[i];
		}

		break;
	}
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB0):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB1):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB2):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB3):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB4):
		if (ISACPHY(pi)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
			  &pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = p;
			uint8 core = deltaValues[0];
			uint8 gain_idx, bw_idx, subband_idx;

			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB0)) {
				subband_idx = 0;
			} else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB1)) {
				subband_idx = 1;
			} else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB2)) {
				subband_idx = 2;
			} else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB3)) {
				subband_idx = 3;
			} else {
				subband_idx = 4;
			}

			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW_2G; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_2G_PARAMS_EXT;
					 gain_idx++) {
					pi_ac_rssioffset->rssi_corr_gain_delta_2g_sub[core]
							[gain_idx][bw_idx][subband_idx]
							= deltaValues[gain_idx + 4*bw_idx + 1];
				}
			}
			wlc_phy_set_trloss_reg_acphy(pi, core);

		}
		break;

	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB0):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB1):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB2):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB3):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB4):
		if (ISACPHY(pi)) {
		acphy_rssioffset_t *pi_ac_rssioffset =
		&pi->u.pi_acphy->srom.rssioffset;
		int8 *deltaValues = a;
		uint8 core;
		uint8 gain_idx, bw_idx, core_idx = 0, subband_idx;

		if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB0)) {
			subband_idx = 0;
		} else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB1)) {
			subband_idx = 1;
		} else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB2)) {
			subband_idx = 2;
		} else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GB3)) {
			subband_idx = 3;
		} else {
			subband_idx = 4;
		}

		FOREACH_CORE(pi, core) {
			deltaValues[9*core_idx] = core;
			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW_2G; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_2G_PARAMS_EXT;
					gain_idx++) {
					deltaValues[gain_idx + 4*bw_idx + 9*core_idx +1 ]=
					  pi_ac_rssioffset->rssi_corr_gain_delta_2g_sub[core]
					  [gain_idx][bw_idx][subband_idx];

				}
			}
			core_idx++;
		}

		deltaValues[9*core_idx] = -1;
		}
		break;

	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2G):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GHH):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			int8 *deltaValues = p;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2G))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2g;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2gh;
			else
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2ghh;

			for (i = 0; i < LCN40PHY_GAIN_DELTA_2G_PARAMS; i++)
				rssi_gain_delta[i] = deltaValues[i];
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			int8 *deltaValues = p;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2G))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2g;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2gh;
			else
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2ghh;

			for (i = 0; i < NPHY_GAIN_DELTA_2G_PARAMS; i++)
				rssi_gain_delta[i] = deltaValues[i];
		} else if (ISACPHY(pi)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
			        &pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = p;
			uint8 core = deltaValues[0];
			uint8 gain_idx, bw_idx;

			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_2G)) {
				for (bw_idx = 0; bw_idx < ACPHY_NUM_BW_2G; bw_idx++) {
					for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_2G_PARAMS;
					     gain_idx++) {
						pi_ac_rssioffset->rssi_corr_gain_delta_2g[core]
						        [gain_idx][bw_idx]
						        = deltaValues[gain_idx + 2*bw_idx + 1];
					}
				}
				wlc_phy_set_trloss_reg_acphy(pi, core);

			} else {
				PHY_ERROR(("Unsupported RSSI_GAIN_DELTA_2G type!\n"));
				err = BCME_UNSUPPORTED;
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2G):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GHH):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			int8 *deltaValues = a;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2G))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2g;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2gh;
			else
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_2ghh;

			for (i = 0; i < LCN40PHY_GAIN_DELTA_2G_PARAMS; i++)
				deltaValues[i] = rssi_gain_delta[i];
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			int8 *deltaValues = a;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2G))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2g;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2GH))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2gh;
			else
				rssi_gain_delta = pi_nphy->rssi_gain_delta_2ghh;

			for (i = 0; i < NPHY_GAIN_DELTA_2G_PARAMS; i++)
				deltaValues[i] = rssi_gain_delta[i];
		} else if (ISACPHY(pi)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
				&pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = a;
			uint8 core;
			uint8 gain_idx, bw_idx, core_idx = 0;

			if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_2G)) {
			   FOREACH_CORE(pi, core) {
			      deltaValues[5*core_idx] = core;
			      for (bw_idx = 0; bw_idx < ACPHY_NUM_BW_2G; bw_idx++) {
			         for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_2G_PARAMS;
				      gain_idx++) {
			            deltaValues[gain_idx + 2*bw_idx + 5*core_idx +1 ]=
			              pi_ac_rssioffset->rssi_corr_gain_delta_2g[core]
				            [gain_idx][bw_idx];
			         }
			      }
			      core_idx++;
			   }
			   /* set core to -1 after the last valid entry */
			   deltaValues[core_idx*5] = -1;

			   for (bw_idx = 0; bw_idx < core_idx*5; bw_idx++) {
				printf("%d ", deltaValues[bw_idx]);
			   }
			   printf("\n");
			} else {
				PHY_ERROR(("Unsupported RSSI_GAIN_DELTA_2G type!\n"));
				err = BCME_UNSUPPORTED;
			}
		}
		break;

	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU):
	case IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GH):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			int8 *deltaValues = p;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gl;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gml;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gmu;
			else
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gh;

			for (i = 0; i < LCN40PHY_GAIN_DELTA_5G_PARAMS; i++)
				rssi_gain_delta[i] = deltaValues[i];
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			int8 *deltaValues = p;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gl;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gml;
			else if (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gmu;
			else
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gh;

			for (i = 0; i < NPHY_GAIN_DELTA_5G_PARAMS; i++)
				rssi_gain_delta[i] = deltaValues[i];
		} else if (ISACPHY(pi) && (pi->u.pi_acphy->rssi_cal_rev == FALSE)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
				&pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = p;
			uint8 core = deltaValues[0];
			uint8 gain_idx, bw_idx, subband_idx;

			subband_idx = (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL)) ? 0:
			        (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML)) ? 1:
			        (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU)) ? 2:3;
			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS;
				     gain_idx++) {
					pi_ac_rssioffset->rssi_corr_gain_delta_5g
						[core][gain_idx][bw_idx][subband_idx]
						= deltaValues[gain_idx + 2*bw_idx + 1];
				}
			}
			wlc_phy_set_trloss_reg_acphy(pi, core);

			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS;
				     gain_idx++) {
					printf("%d ", pi_ac_rssioffset->rssi_corr_gain_delta_5g
						[core][gain_idx][bw_idx][subband_idx]);
				}
			}
			printf("\n");
		} else if (ISACPHY(pi) && (pi->u.pi_acphy->rssi_cal_rev == TRUE)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
				&pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = p;
			uint8 core = deltaValues[0];
			uint8 gain_idx, bw_idx, subband_idx;

			subband_idx = (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL)) ? 0:
			        (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML)) ? 1:
			        (actionid == IOV_SVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU)) ? 2:3;
			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS_EXT;
				     gain_idx++) {
					pi_ac_rssioffset->rssi_corr_gain_delta_5g_sub
						[core][gain_idx][bw_idx][subband_idx]
						= deltaValues[gain_idx + 4*bw_idx + 1];
				}
			}
			wlc_phy_set_trloss_reg_acphy(pi, core);

			for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
				for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS_EXT;
				     gain_idx++) {
					printf("%d ", pi_ac_rssioffset->rssi_corr_gain_delta_5g_sub
						[core][gain_idx][bw_idx][subband_idx]);
				}
			}
			printf("\n");
		}

		break;

	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU):
	case IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GH):
		if (ISLCN40PHY(pi)) {
			phy_info_lcn40phy_t *pi_lcn40 = pi->u.pi_lcn40phy;
			int8 *deltaValues = a;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gl;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gml;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU))
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gmu;
			else
				rssi_gain_delta = pi_lcn40->rssi_gain_delta_5gh;

			for (i = 0; i < LCN40PHY_GAIN_DELTA_5G_PARAMS; i++)
				deltaValues[i] = rssi_gain_delta[i];
		} else if (CHIPID_4324X_EPA_FAMILY(pi)) {
			phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
			int8 *deltaValues = a;
			uint8 i;
			int8 *rssi_gain_delta;
			if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gl;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gml;
			else if (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU))
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gmu;
			else
				rssi_gain_delta = pi_nphy->rssi_gain_delta_5gh;

			for (i = 0; i < NPHY_GAIN_DELTA_5G_PARAMS; i++)
				deltaValues[i] = rssi_gain_delta[i];
		} else if (ISACPHY(pi) && (pi->u.pi_acphy->rssi_cal_rev == FALSE)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
				&pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = a;
			uint8 core, core_idx = 0;
			uint8 gain_idx, bw_idx, subband_idx;

			subband_idx = (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL)) ? 0:
			        (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML)) ? 1:
			        (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU)) ? 2:3;

			FOREACH_CORE(pi, core) {
				deltaValues[7*core_idx] = core;
				for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
					for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS;
					     gain_idx++) {
						deltaValues[gain_idx + 2*bw_idx + 7*core_idx +1]=
							pi_ac_rssioffset->rssi_corr_gain_delta_5g
							[core][gain_idx][bw_idx][subband_idx];
					}
				}
				core_idx++;
			}
			deltaValues[core_idx*7] = -1;
		} else if (ISACPHY(pi) && (pi->u.pi_acphy->rssi_cal_rev == TRUE)) {
			acphy_rssioffset_t *pi_ac_rssioffset =
				&pi->u.pi_acphy->srom.rssioffset;
			int8 *deltaValues = a;
			uint8 core, core_idx = 0;
			uint8 gain_idx, bw_idx, subband_idx;

			subband_idx = (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GL)) ? 0:
			        (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GML)) ? 1:
			        (actionid == IOV_GVAL(IOV_PHY_RSSI_GAIN_DELTA_5GMU)) ? 2:3;

			FOREACH_CORE(pi, core) {
				deltaValues[13*core_idx] = core;
				for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
				  for (gain_idx = 0; gain_idx < ACPHY_GAIN_DELTA_5G_PARAMS_EXT;
				       gain_idx++) {
				    deltaValues[gain_idx + 4*bw_idx + 13*core_idx +1 ]=
				      pi_ac_rssioffset->rssi_corr_gain_delta_5g_sub
				      [core][gain_idx][bw_idx][subband_idx];
				  }
				}
				core_idx++;
			}
			/* set core to -1 after the last valid entry */
			deltaValues[core_idx*13] = -1;

		}
		break;
	case IOV_SVAL(IOV_PHY_RXGAINERR_2G):
		if (ISACPHY(pi)) {
			uint8 core;
			int8 *deltaValues = p;
			FOREACH_CORE(pi, core) {
				pi->rxgainerr_2g[core] = deltaValues[core];
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RXGAINERR_2G):
		if (ISACPHY(pi)) {
			int8 *deltaValues = a;
			uint8 core;
			FOREACH_CORE(pi, core) {
			  deltaValues[core] = pi->rxgainerr_2g[core];
			}
		}
		break;
	case IOV_SVAL(IOV_PHY_RXGAINERR_5GL):
		if (ISACPHY(pi)) {
			uint8 core;
			int8 *deltaValues = p;
			FOREACH_CORE(pi, core) {
				pi->rxgainerr_5gl[core] = deltaValues[core];
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RXGAINERR_5GL):
		if (ISACPHY(pi)) {
			int8 *deltaValues = a;
			uint8 core;
			FOREACH_CORE(pi, core) {
			  deltaValues[core] = pi->rxgainerr_5gl[core];
			}
		}
		break;

	case IOV_SVAL(IOV_PHY_RXGAINERR_5GM):
		if (ISACPHY(pi)) {
			uint8 core;
			int8 *deltaValues = p;
			FOREACH_CORE(pi, core) {
				pi->rxgainerr_5gm[core] = deltaValues[core];
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RXGAINERR_5GM):
		if (ISACPHY(pi)) {
			int8 *deltaValues = a;
			uint8 core;
			FOREACH_CORE(pi, core) {
			  deltaValues[core] = pi->rxgainerr_5gm[core];
			}
		}
		break;

	case IOV_SVAL(IOV_PHY_RXGAINERR_5GH):
		if (ISACPHY(pi)) {
			uint8 core;
			int8 *deltaValues = p;
			FOREACH_CORE(pi, core) {
				pi->rxgainerr_5gh[core] = deltaValues[core];
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RXGAINERR_5GH):
		if (ISACPHY(pi)) {
			int8 *deltaValues = a;
			uint8 core;
			FOREACH_CORE(pi, core) {
			  deltaValues[core] = pi->rxgainerr_5gh[core];
			}
		}
		break;

	case IOV_SVAL(IOV_PHY_RXGAINERR_5GU):
		if (ISACPHY(pi)) {
			uint8 core;
			int8 *deltaValues = p;
			FOREACH_CORE(pi, core) {
				pi->rxgainerr_5gu[core] = deltaValues[core];
			}
		}
		break;

	case IOV_GVAL(IOV_PHY_RXGAINERR_5GU):
		if (ISACPHY(pi)) {
			int8 *deltaValues = a;
			uint8 core;

			FOREACH_CORE(pi, core) {
			  deltaValues[core] = pi->rxgainerr_5gu[core];
			}
		}
		break;

#endif /* NCONF || LCN40CONF || ACCONF */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_aci(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	int err = BCME_OK;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	switch (actionid) {
#if defined(WLTEST)
	case IOV_SVAL(IOV_ACI_EXIT_CHECK_PERIOD):
		if (int_val == 0)
			err = BCME_RANGE;
		else
			pi->aci_exit_check_period = int_val;
		break;

	case IOV_GVAL(IOV_ACI_EXIT_CHECK_PERIOD):
		int_val = pi->aci_exit_check_period;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_PHY_GLITCHK):
		pi->tunings[0] = (uint16)int_val;
		break;

	case IOV_SVAL(IOV_PHY_NOISE_UP):
		pi->tunings[1] = (uint16)int_val;
		break;

	case IOV_SVAL(IOV_PHY_NOISE_DWN):
		pi->tunings[2] = (uint16)int_val;
		break;
#endif // endif
#ifndef WLC_DISABLE_ACI
	case IOV_SVAL(IOV_PHY_INTERFERENCE_OVERRIDE2):
		if (ISACPHY(pi) && !ACPHY_ENABLE_FCBS_HWACI(pi)) {
			pi->u.pi_acphy->aci->hwaci_desense_state_ovr = int_val;
			wlc_phy_hwaci_override_acphy(pi, int_val);
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;

	case IOV_GVAL(IOV_PHY_INTERFERENCE_OVERRIDE2):
		if (ISACPHY(pi)) {
			int_val = pi->u.pi_acphy->aci->hwaci_desense_state_ovr;
			bcopy(&int_val, a, vsize);
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
#endif /* WLC_DISABLE_ACI */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static int
wlc_phy_iovars_generic(phy_info_t *pi, uint32 actionid, uint16 type, void *p, uint plen, void *a,
	int alen, int vsize)
{
	int32 int_val = 0;
	bool bool_val;
	int err = BCME_OK;
	int32 *ret_int_ptr = (int32 *)a;

	if (plen >= (uint)sizeof(int_val))
		bcopy(p, &int_val, sizeof(int_val));

	/* bool conversion to avoid duplication below */
	bool_val = int_val != 0;

	BCM_REFERENCE(*ret_int_ptr);
	BCM_REFERENCE(bool_val);

	switch (actionid) {

#if defined(BCMDBG) || defined(WLTEST)
	case IOV_GVAL(IOV_FAST_TIMER):
		*ret_int_ptr = (int32)pi->sh->fast_timer;
		break;

	case IOV_SVAL(IOV_FAST_TIMER):
		pi->sh->fast_timer = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_SLOW_TIMER):
		*ret_int_ptr = (int32)pi->sh->slow_timer;
		break;

	case IOV_SVAL(IOV_SLOW_TIMER):
		pi->sh->slow_timer = (uint32)int_val;
		break;
#endif /* BCMDBG || WLTEST */
#if defined(BCMDBG) || defined(WLTEST) || defined(WLMEDIA_CALDBG) || \
	defined(PHYCAL_CHNG_CS) || defined(WLMEDIA_FLAMES) || defined(DBG_PHY_IOV)
	case IOV_GVAL(IOV_GLACIAL_TIMER):
		*ret_int_ptr = (int32)pi->sh->glacial_timer;
		break;

	case IOV_SVAL(IOV_GLACIAL_TIMER):
		pi->sh->glacial_timer = (uint32)int_val;
		break;
#endif // endif
#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WLMEDIA_N2DEV) || \
	defined(MACOSX) || defined(DBG_PHY_IOV)

	case IOV_GVAL(IOV_PHY_WATCHDOG):
		*ret_int_ptr = (int32)pi->phywatchdog_override;
		break;

	case IOV_SVAL(IOV_PHY_WATCHDOG):
		pi->phywatchdog_override = bool_val;
		break;
#endif // endif
#if defined(WLTEST)
#ifdef BAND5G
	case IOV_GVAL(IOV_PHY_CGA_5G):
		/* Pass on existing channel based offset into wl */
		bcopy(pi->phy_cga_5g, a, 24*sizeof(int8));
		break;
#endif /* BAND5G */
	case IOV_GVAL(IOV_PHY_CGA_2G):
		/* Pass on existing channel based offset into wl */
		bcopy(pi->phy_cga_2g, a, 14*sizeof(int8));
		break;

	case IOV_GVAL(IOV_NOISE_MEAS_TIMER):
		*ret_int_ptr = (int32)pi->sh->noise_meas_timer;
		break;

	case IOV_SVAL(IOV_NOISE_MEAS_TIMER):
		pi->sh->noise_meas_timer = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_PHYHAL_MSG):
		*ret_int_ptr = (int32)phyhal_msg_level;
		break;

	case IOV_SVAL(IOV_PHYHAL_MSG):
		phyhal_msg_level = (uint32)int_val;
		break;

	case IOV_SVAL(IOV_PHY_FIXED_NOISE):
		pi->phy_fixed_noise = bool_val;
		break;

	case IOV_GVAL(IOV_PHY_FIXED_NOISE):
		int_val = (int32)pi->phy_fixed_noise;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_GVAL(IOV_PHYNOISE_POLL):
		*ret_int_ptr = (int32)pi->phynoise_polling;
		break;

	case IOV_SVAL(IOV_PHYNOISE_POLL):
		pi->phynoise_polling = bool_val;
		break;

	case IOV_GVAL(IOV_CARRIER_SUPPRESS):
		if (!(ISLPPHY(pi) || ISSSLPNPHY(pi) || ISLCNPHY(pi)))
			err = BCME_UNSUPPORTED; /* lpphy, sslpnphy and lcnphy for now */
		*ret_int_ptr = (pi->carrier_suppr_disable == 0);
		break;

	case IOV_SVAL(IOV_CARRIER_SUPPRESS):
	{
		initfn_t carr_suppr_fn = pi->pi_fptr.carrsuppr;
		if (carr_suppr_fn) {
			pi->carrier_suppr_disable = bool_val;
			if (pi->carrier_suppr_disable) {
				(*carr_suppr_fn)(pi);
			}
			PHY_INFORM(("Carrier Suppress Called\n"));
		} else
			err = BCME_UNSUPPORTED;
		break;
	}

	case IOV_GVAL(IOV_PKTENG_STATS):
	  wlc_phy_pkteng_stats_get(pi, a, alen);
		break;
#ifdef BAND5G
	case IOV_GVAL(IOV_PHY_SUBBAND5GVER):
		/* Retrieve 5G subband version */
		int_val = (uint8)(pi->sh->subband5Gver);
		bcopy(&int_val, a, vsize);
		break;
#endif /* BAND5G */
	case IOV_GVAL(IOV_PHY_TXRX_CHAIN):
		wlc_phy_iovar_txrx_chain(pi, int_val, ret_int_ptr, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_TXRX_CHAIN):
		err = wlc_phy_iovar_txrx_chain(pi, int_val, ret_int_ptr, TRUE);
		break;

	case IOV_SVAL(IOV_PHY_BPHY_EVM):
		wlc_phy_iovar_bphy_testpattern(pi, NPHY_TESTPATTERN_BPHY_EVM, (bool) int_val);
		break;

	case IOV_GVAL(IOV_PHY_BPHY_RFCS):
		*ret_int_ptr = pi->phy_bphy_rfcs;
		break;

	case IOV_SVAL(IOV_PHY_BPHY_RFCS):
		wlc_phy_iovar_bphy_testpattern(pi, NPHY_TESTPATTERN_BPHY_RFCS, (bool) int_val);
		break;

	case IOV_GVAL(IOV_PHY_SCRAMINIT):
		*ret_int_ptr = pi->phy_scraminit;
		break;

	case IOV_SVAL(IOV_PHY_SCRAMINIT):
		wlc_phy_iovar_scraminit(pi, (uint8)int_val);
		break;

	case IOV_SVAL(IOV_PHY_RFSEQ):
		wlc_phy_iovar_force_rfseq(pi, (uint8)int_val);
		break;

	case IOV_GVAL(IOV_PHY_TEST_TSSI):
		*((uint*)a) = wlc_phy_iovar_test_tssi(pi, (uint8)int_val, 0);
		break;

	case IOV_GVAL(IOV_PHY_TEST_TSSI_OFFS):
		*((uint*)a) = wlc_phy_iovar_test_tssi(pi, (uint8)int_val, 12);
		break;

	case IOV_GVAL(IOV_PHY_TEST_IDLETSSI):
		*((uint*)a) = wlc_phy_iovar_test_idletssi(pi, (uint8)int_val);
		break;

	case IOV_SVAL(IOV_PHY_SETRPTBL):
		wlc_phy_iovar_setrptbl(pi);
		break;

	case IOV_SVAL(IOV_PHY_FORCEIMPBF):
		wlc_phy_iovar_forceimpbf(pi);
		break;

	case IOV_SVAL(IOV_PHY_FORCESTEER):
		wlc_phy_iovar_forcesteer(pi, (uint8)int_val);
		break;
#ifdef BAND5G
	case IOV_SVAL(IOV_PHY_5G_PWRGAIN):
		pi->phy_5g_pwrgain = bool_val;
		break;

	case IOV_GVAL(IOV_PHY_5G_PWRGAIN):
		*ret_int_ptr = (int32)pi->phy_5g_pwrgain;
		break;
#endif /* BAND5G */

	case IOV_SVAL(IOV_PHY_ENABLERXCORE):
		wlc_phy_iovar_rxcore_enable(pi, int_val, bool_val, ret_int_ptr, TRUE);
		break;

	case IOV_GVAL(IOV_PHY_ENABLERXCORE):
		wlc_phy_iovar_rxcore_enable(pi, int_val, bool_val, ret_int_ptr, FALSE);
		break;

	case IOV_GVAL(IOV_PHY_ACTIVECAL):
		*ret_int_ptr = (int32)((pi->cal_info->cal_phase_id !=
			MPHASE_CAL_STATE_IDLE)? 1 : 0);
		break;

	case IOV_SVAL(IOV_PHY_BBMULT):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		err = wlc_phy_iovar_bbmult_set(pi, p);
		break;

	case IOV_GVAL(IOV_PHY_BBMULT):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		wlc_phy_iovar_bbmult_get(pi, int_val, bool_val, ret_int_ptr);
		break;

#if defined(WLC_LOWPOWER_BEACON_MODE)
	case IOV_GVAL(IOV_PHY_LOWPOWER_BEACON_MODE):
		if (ISLCN40PHY(pi)) {
			*ret_int_ptr = (pi->u.pi_lcn40phy)->lowpower_beacon_mode;
		}
		break;

	case IOV_SVAL(IOV_PHY_LOWPOWER_BEACON_MODE):
		wlc_phy_lowpower_beacon_mode(pih, int_val);
		break;
#endif /* WLC_LOWPOWER_BEACON_MODE */
#endif // endif
#if defined(WLTEST) || defined(WLMEDIA_CALDBG)
	case IOV_GVAL(IOV_PKTENG_GAININDEX):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		err = wlc_phy_pkteng_get_gainindex(pi, ret_int_ptr);
		break;

	case IOV_GVAL(IOV_PHY_RXGAININDEX):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		err = wlc_phy_get_rx_gainindex(pi, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_PHY_RXGAININDEX):
		if (!pi->sh->clk) {
			err = BCME_NOCLK;
			break;
		}
		err = wlc_phy_set_rx_gainindex(pi, int_val);
		break;

#endif // endif
#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WLMEDIA_N2DEV) || \
	defined(DBG_PHY_IOV) || defined(WFD_PHY_LL_DEBUG) || defined(ATE_BUILD)
	case IOV_GVAL(IOV_PHY_FORCECAL):
		err = wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_FORCECAL):
		err = wlc_phy_iovar_forcecal(pi, int_val, ret_int_ptr, vsize, TRUE);
		break;

	case IOV_SVAL(IOV_PAPD_EN_WAR):
		wlapi_bmac_write_shm(pi->sh->physhim, M_PAPDOFF_MCS, (uint16)int_val);
		break;

	case IOV_GVAL(IOV_PAPD_EN_WAR):
		*ret_int_ptr = wlapi_bmac_read_shm(pi->sh->physhim, M_PAPDOFF_MCS);
		break;

#ifndef ATE_BUILD
	case IOV_SVAL(IOV_PHY_SKIPPAPD):
		if ((int_val != 0) && (int_val != 1)) {
			err = BCME_RANGE;
			break;
		}
		if (ISACPHY(pi))
			pi->u.pi_acphy->acphy_papd_skip = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_PHY_SKIPPAPD):
		if (ISACPHY(pi))
		        *ret_int_ptr = pi->u.pi_acphy->acphy_papd_skip;
		break;

	case IOV_GVAL(IOV_PHY_FORCECAL_OBT):
		err = wlc_phy_iovar_forcecal_obt(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_FORCECAL_OBT):
		err = wlc_phy_iovar_forcecal_obt(pi, int_val, ret_int_ptr, vsize, FALSE);
		break;

	case IOV_GVAL(IOV_PHY_FORCECAL_NOISE): /* Get crsminpwr for core 0 & core 1 */
		err = wlc_phy_iovar_forcecal_noise(pi, int_val, a, vsize, FALSE);
		break;

	case IOV_SVAL(IOV_PHY_FORCECAL_NOISE): /* do only Noise Cal */
		err = wlc_phy_iovar_forcecal_noise(pi, int_val, a, vsize, TRUE);
		break;
#endif /* !ATE_BUILD */
#endif // endif
#if defined(WLTEST) || defined(MACOSX)
	case IOV_SVAL(IOV_PHY_DEAF):
		wlc_phy_iovar_set_deaf(pi, int_val);
		break;
	case IOV_GVAL(IOV_PHY_DEAF):
		err = wlc_phy_iovar_get_deaf(pi, ret_int_ptr);
		break;
#endif // endif
#ifdef WLTEST
	case IOV_GVAL(IOV_PHY_FEM2G): {
		bcopy(&pi->fem2g, a, sizeof(srom_fem_t));
		break;
	}

	case IOV_SVAL(IOV_PHY_FEM2G): {
		bcopy(p, &pi->fem2g, sizeof(srom_fem_t));
		/* srom_fem2g.extpagain changed after attach time */
		wlc_phy_txpower_ipa_upd(pi);
		break;
	}

#ifdef BAND5G
	case IOV_GVAL(IOV_PHY_FEM5G): {
		bcopy(&pi->fem5g, a, sizeof(srom_fem_t));
		break;
	}

	case IOV_SVAL(IOV_PHY_FEM5G): {
		bcopy(p, &pi->fem5g, sizeof(srom_fem_t));
		/* srom_fem5g.extpagain changed after attach time */
		wlc_phy_txpower_ipa_upd(pi);
		break;
	}
#endif /* BAND5G */
#endif /* WLTEST */
	case IOV_GVAL(IOV_PHY_RXIQ_EST):
	{
		bool suspend;
		bool low_pwr = FALSE;
		uint16 r;
		int temp_dBm;
		if (ISSSLPNPHY(pi))
			return BCME_UNSUPPORTED;        /* lpphy support only for now */

		if (!pi->sh->up) {
			err = BCME_NOTUP;
			break;
		}

		/* make sure bt-prisel is on WLAN side */
		wlc_phy_btcx_wlan_critical_enter(pi);

		suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
		if (!suspend) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
		}

		wlc_phyreg_enter((wlc_phy_t *)pi);

		/* For 4350 Olympic program, -i 0 should behave exactly same as -i 1
		 * So, if there is force gain type is 0, then make it 1 for 4350
		 */
		if ((pi->u.pi_acphy->rud_agc_enable == TRUE) &&
			(pi->phy_rxiq_force_gain_type == 0) &&
			(pi->phy_rxiq_extra_gain_3dB == 0)) {
			pi->phy_rxiq_force_gain_type = 1;
		}
		/* get IQ power measurements */
		*ret_int_ptr = wlc_phy_rx_iq_est(pi, pi->phy_rxiq_samps, pi->phy_rxiq_antsel,
		                                 pi->phy_rxiq_resln, pi->phy_rxiq_lpfhpc,
		                                 pi->phy_rxiq_diglpf,
		                                 pi->phy_rxiq_gain_correct,
		                                 pi->phy_rxiq_extra_gain_3dB, 0,
		                                 pi->phy_rxiq_force_gain_type);

		if ((pi->u.pi_acphy->rud_agc_enable == TRUE) &&
			(pi->phy_rxiq_force_gain_type == 1) && (pi->phy_rxiq_resln == 1)) {
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, r) {
				temp_dBm = *ret_int_ptr;
				temp_dBm = (temp_dBm >> (10*r)) & 0x3ff;
				temp_dBm = ((int16)(temp_dBm << 6)) >> 6; /* sign extension */
				if ((temp_dBm >> 2) < -82) {
					low_pwr = TRUE;
				}
				PHY_RXIQ(("In %s: | For core %d | iqest_dBm = %d"
					  " \n", __FUNCTION__, r, (temp_dBm >> 2)));
			}
			if (low_pwr) {
				pi->phy_rxiq_force_gain_type = 9;
				*ret_int_ptr = wlc_phy_rx_iq_est(pi, pi->phy_rxiq_samps,
					pi->phy_rxiq_antsel,
					pi->phy_rxiq_resln, pi->phy_rxiq_lpfhpc,
					pi->phy_rxiq_diglpf, pi->phy_rxiq_gain_correct,
					pi->phy_rxiq_extra_gain_3dB, 0,
					pi->phy_rxiq_force_gain_type);
			}
		}

		wlc_phyreg_exit((wlc_phy_t *)pi);

		if (!suspend)
			wlapi_enable_mac(pi->sh->physhim);
		wlc_phy_btcx_wlan_critical_exit(pi);
		break;
	}

	case IOV_SVAL(IOV_PHY_RXIQ_EST):
		if (ISSSLPNPHY(pi))
			return BCME_UNSUPPORTED;        /* lpphy support only for now */

		if (!ISLPPHY(pi)) {
			uint8 samples, antenna, resolution, lpf_hpc, dig_lpf;
			uint8 gain_correct, extra_gain_3dB, force_gain_type;

			extra_gain_3dB = (int_val >> 28) & 0xf;
			gain_correct = (int_val >> 24) & 0xf;
			lpf_hpc = (int_val >> 20) & 0x3;
			dig_lpf = (int_val >> 22) & 0x3;
			resolution = (int_val >> 16) & 0xf;
			samples = (int_val >> 8) & 0xff;
			antenna = int_val & 0xf;
			force_gain_type = (int_val >> 4) & 0xf;
#if defined(WLTEST)
			if (ISLCNCOMMONPHY(pi)) {
				uint8 index, elna, index_valid;
				phy_info_lcnphy_t *pi_lcn = wlc_phy_getlcnphy_common(pi);
				antenna = int_val & 0x7f;
				elna =  (int_val >> 20) & 0x1;
				index = (((int_val >> 28) & 0xF) << 3) | ((int_val >> 21) & 0x7);
				index_valid = (int_val >> 7) & 0x1;
				if (index_valid)
					pi_lcn->rxpath_index = index;
				else
					pi_lcn->rxpath_index = 0xFF;
				pi_lcn->rxpath_elna = elna;
			}
#endif // endif
		       if (CHIPID_4324X_EPA_FAMILY(pi)) {
				uint8 index;
				phy_info_nphy_t *pi_nphy = pi->u.pi_nphy;
				index = (((int_val >> 28) & 0xF) << 3) | ((int_val >> 21) & 0x7);
				pi_nphy->gainindex = index;
			}

			if (gain_correct > 4) {
				err = BCME_RANGE;
				break;
			}

			if (!ISLCNCOMMONPHY(pi) && !(CHIPID_4324X_EPA_FAMILY(pi))) {
				if ((lpf_hpc != 0) && (lpf_hpc != 1)) {
					err = BCME_RANGE;
					break;
				}
				if (dig_lpf > 2) {
					err = BCME_RANGE;
					break;
					}
			}

			if ((resolution != 0) && (resolution != 1)) {
				err = BCME_RANGE;
				break;
			}

			if (samples < 10 || samples > 15) {
				err = BCME_RANGE;
				break;
			}

			/* Limit max number of samples to 2^14 since Lcnphy RXIQ Estimator
			 * takes too much and variable time for more than that.
			*/
			if (ISLCNCOMMONPHY(pi)) {
				samples = MIN(14, samples);
			}
			if (!(CHIPID_4324X_EPA_FAMILY(pi))) {
				if ((antenna != ANT_RX_DIV_FORCE_0) &&
					(antenna != ANT_RX_DIV_FORCE_1) &&
					(antenna != ANT_RX_DIV_DEF)) {
						err = BCME_RANGE;
						break;
				}
			}
			pi->phy_rxiq_samps = samples;
			pi->phy_rxiq_antsel = antenna;
			pi->phy_rxiq_resln = resolution;
			pi->phy_rxiq_lpfhpc = lpf_hpc;
			pi->phy_rxiq_diglpf = dig_lpf;
			pi->phy_rxiq_gain_correct = gain_correct;
			pi->phy_rxiq_extra_gain_3dB = extra_gain_3dB;
			pi->phy_rxiq_force_gain_type = force_gain_type;
		}
		break;

	case IOV_GVAL(IOV_PHYNOISE_SROM):
		if (ISHTPHY(pi) || ISACPHY(pi) ||
		(ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 3))) {

			int8 noiselvl[PHY_CORE_MAX];
			uint8 core;
			uint32 pkd_noise = 0;
			if (!pi->sh->up) {
				err = BCME_NOTUP;
				break;
			}
			wlc_phy_get_SROMnoiselvl_phy(pi, noiselvl);
			for (core = PHYCORENUM(pi->pubpi.phy_corenum); core >= 1; core--) {
				pkd_noise = (pkd_noise << 8) | (uint8)(noiselvl[core-1]);
			}
			*ret_int_ptr = pkd_noise;
		} else if (ISLCNPHY(pi)) {
#if defined(WLTEST)
			int8 noiselvl;
			uint32 pkd_noise = 0;
			if (!pi->sh->up) {
				err = BCME_NOTUP;
				break;
			}
			wlc_phy_get_SROMnoiselvl_lcnphy(pi, &noiselvl);
			pkd_noise  = (uint8)noiselvl;
			*ret_int_ptr = pkd_noise;
#else
			return BCME_UNSUPPORTED;
#endif // endif
		} else {
			return BCME_UNSUPPORTED;        /* only htphy supported for now */
		}
		break;

	case IOV_GVAL(IOV_NUM_STREAM):
		if (ISNPHY(pi)) {
			int_val = 2;
		} else if (ISHTPHY(pi)) {
			int_val = 3;
		} else if (ISAPHY(pi) || ISGPHY(pi) || ISLPPHY(pi) || ISSSLPNPHY(pi) ||
			ISLCNPHY(pi)) {
			int_val = 1;
		} else {
			int_val = -1;
		}
		bcopy(&int_val, a, vsize);
		break;

	case IOV_GVAL(IOV_BAND_RANGE):
		int_val = wlc_phy_chanspec_bandrange_get(pi, pi->radio_chanspec);
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_MIN_TXPOWER):
		pi->min_txpower = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_MIN_TXPOWER):
		int_val = pi->min_txpower;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_ANT_DIV_SW_CORE0):
	{
		if (ISACPHY(pi)) {
			if ((int_val > 2) || (int_val < 0)) {
				PHY_ERROR(("Value %d is not supported \n", (uint16)int_val));
			} else {
#ifdef WLC_SW_DIVERSITY
				if (pi->u.pi_acphy->swdiv_enable) {
					PHY_ERROR(("Not supported with SWDIV, Use antdiv\n"));
				} else
#endif // endif
				wlc_ant_div_sw_control(pi, (int8) int_val, 0);
			}
		} else {
			PHY_ERROR(("IOVAR is not supported for this chip \n"));
		}
		break;
	}

	case IOV_GVAL(IOV_ANT_DIV_SW_CORE0):
	{
		if (ISACPHY(pi)) {
#ifdef WLC_SW_DIVERSITY
				if (pi->u.pi_acphy->swdiv_enable) {
					PHY_ERROR(("Not supported with SWDIV, Use antdiv\n"));
				} else
#endif // endif
				*ret_int_ptr = pi->u.pi_acphy->ant_swOvr_state_core0;
		} else {
			PHY_ERROR(("IOVAR is not supported for this chip \n"));
		}
		break;
	}
	case IOV_SVAL(IOV_ANT_DIV_SW_CORE1):
	{
		if (ISACPHY(pi)) {
			if ((int_val > 2) || (int_val < 0)) {
				PHY_ERROR(("Value %d is not supported \n", (uint16)int_val));
			} else {
				wlc_ant_div_sw_control(pi, (int8) int_val, 1);
			}
		} else {
			PHY_ERROR(("IOVAR is not supported for this chip \n"));
		}
		break;
	}

	case IOV_GVAL(IOV_ANT_DIV_SW_CORE1):
	{
		if (ISACPHY(pi)) {
				*ret_int_ptr = pi->u.pi_acphy->ant_swOvr_state_core1;
		} else {
			PHY_ERROR(("IOVAR is not supported for this chip \n"));
		}
		break;
	}

#if defined(WLTEST)
	case IOV_GVAL(IOV_TSSIVISI_THRESH):
		int_val = wlc_phy_tssivisible_thresh((wlc_phy_t *)pi);
		bcopy(&int_val, a, sizeof(int_val));
		break;
#endif // endif

#if defined(MACOSX)
	case IOV_GVAL(IOV_PHYWREG_LIMIT):
		int_val = pi->phy_wreg_limit;
		bcopy(&int_val, a, vsize);
		break;

	case IOV_SVAL(IOV_PHYWREG_LIMIT):
		pi->phy_wreg_limit = (uint8)int_val;
		break;
#endif // endif
	case IOV_GVAL(IOV_PHY_MUTED):
		*ret_int_ptr = PHY_MUTED(pi) ? 1 : 0;
		break;

#ifdef WLMEDIA_TXFILTER_OVERRIDE
	case IOV_GVAL(IOV_PHY_TXFILTER_SM_OVERRIDE):
		int_val = pi->sh->txfilter_sm_override;
		bcopy(&int_val, a, sizeof(int_val));
		break;

	case IOV_SVAL(IOV_PHY_TXFILTER_SM_OVERRIDE):
		if (int_val < WLC_TXFILTER_OVERRIDE_DISABLED ||
			int_val > WLC_TXFILTER_OVERRIDE_ENABLED) {
			err = BCME_RANGE;
		} else {
			pi->sh->txfilter_sm_override = int_val;
		}

		break;
#endif /* WLMEDIA_TXFILTER_OVERRIDE */
#if defined(WLMEDIA_N2DEV) || defined(WLMEDIA_N2DBG) || defined(RXDESENS_EN)
	case IOV_GVAL(IOV_PHY_RXDESENS):
		if (ISNPHY(pi))
			err = wlc_nphy_get_rxdesens((wlc_phy_t *)pi, ret_int_ptr);
		else if (ISACPHY(pi) && !ACPHY_ENABLE_FCBS_HWACI(pi) &&
		         pi->u.pi_acphy->total_desense.forced) {
			*ret_int_ptr = (int32)pi->u.pi_acphy->total_desense.ofdm_desense;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_PHY_RXDESENS):
		if (ISNPHY(pi) && (pi->sh->interference_mode == INTERFERE_NONE))
			err = wlc_nphy_set_rxdesens((wlc_phy_t *)pi, int_val);
		else
#if ACCONF
			if (ISACPHY(pi) && !ACPHY_ENABLE_FCBS_HWACI(pi)) {
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
				if (int_val <= 0) {
					/* disable phy_rxdesens and restore
					 * default interference mode
					 */
					pi->u.pi_acphy->total_desense.forced = FALSE;

					pi->sh->interference_mode_override = FALSE;
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						pi->sh->interference_mode =
							pi->sh->interference_mode_2G;
					} else {
						pi->sh->interference_mode =
							pi->sh->interference_mode_5G;
					}

#ifndef WLC_DISABLE_ACI
					/* turn off interference mode
					 * before entering another mode
					 */
					if (pi->sh->interference_mode != INTERFERE_NONE)
						wlc_phy_interference(pi, INTERFERE_NONE, TRUE);

					if (!wlc_phy_interference
						(pi, pi->sh->interference_mode, TRUE))
						err = BCME_BADOPTION;
#endif /* !defined(WLC_DISABLE_ACI) */

					/* restore crsmincal automode, and force crsmincal */
					int8 negative = -1;
					wlc_phy_force_crsmin_acphy(pi, &negative);

				} else {
					/* enable phy_rxdesens and disable interference mode
					* through override mode
					*/
					pi->sh->interference_mode_override = TRUE;
					pi->sh->interference_mode_2G_override = INTERFERE_NONE;
					pi->sh->interference_mode_5G_override = INTERFERE_NONE;
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						pi->sh->interference_mode =
							pi->sh->interference_mode_2G_override;
					} else {
						pi->sh->interference_mode =
							pi->sh->interference_mode_5G_override;
					}
					wlc_phy_interference(pi, INTERFERE_NONE, TRUE);

					/* disable crsmincal */
					pi->u.pi_acphy->crsmincal_enable = FALSE;

					/* apply desense */
					pi->u.pi_acphy->total_desense.forced = TRUE;
					pi->u.pi_acphy->total_desense.ofdm_desense = (uint8)int_val;
					pi->u.pi_acphy->total_desense.bphy_desense = (uint8)int_val;
					wlc_phy_desense_apply_acphy(pi, TRUE);

				}
				wlapi_enable_mac(pi->sh->physhim);

			} else
#endif /* ACCONF */
				err = BCME_UNSUPPORTED;
		break;
#endif /* defined(WLMEDIA_N2DEV) || defined(WLMEDIA_N2DBG) || defined(RXDESENS_EN) */
#if defined(WLMEDIA_N2DEV) || defined(WLMEDIA_N2DBG)
	case IOV_GVAL(IOV_NTD_GDS_LOWTXPWR):
		if (ISNPHY(pi))
			err = wlc_nphy_get_lowtxpwr((wlc_phy_t *)pi, ret_int_ptr);
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_NTD_GDS_LOWTXPWR):
		if (ISNPHY(pi))
			err = wlc_nphy_set_lowtxpwr((wlc_phy_t *)pi, int_val);
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_PAPDCAL_INDEXDELTA):
		*ret_int_ptr = (int32)pi->papdcal_indexdelta;
		break;

	case IOV_SVAL(IOV_PAPDCAL_INDEXDELTA):
		if (int_val == -1)
			pi->papdcal_indexdelta = pi->papdcal_indexdelta_default;
		else
			pi->papdcal_indexdelta = (uint8)int_val;
		break;

#endif /* defined(WLMEDIA_N2DEV) || defined(WLMEDIA_N2DBG) */
	case IOV_GVAL(IOV_PHY_RXANTSEL):
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7))
			*ret_int_ptr = pi->nphy_enable_hw_antsel ? 1 : 0;
		break;

	case IOV_SVAL(IOV_PHY_RXANTSEL):
		if (ISNPHY(pi) && NREV_GE(pi->pubpi.phy_rev, 7)) {
			pi->nphy_enable_hw_antsel = bool_val;
			/* make sure driver is up (so clks are on) before writing to PHY regs */
			if (pi->sh->up) {
				wlc_phy_init_hw_antsel(pi);
			}
		}
		break;
#ifdef ENABLE_FCBS
	case IOV_SVAL(IOV_PHY_FCBSINIT):
		if (ISHTPHY(pi)) {
			if ((int_val >= FCBS_CHAN_A) && (int_val <= FCBS_CHAN_B)) {
				wlc_phy_fcbs_init((wlc_phy_t*)pi, int_val);
			} else {
				err = BCME_RANGE;
			}
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_SVAL(IOV_PHY_FCBS):
		if (ISACPHY(pi)) {
			pi->FCBS = (bool)int_val;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_GVAL(IOV_PHY_FCBS):
		if (ISACPHY(pi)) {
			*ret_int_ptr = pi->FCBS;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_GVAL(IOV_PHY_FCBSARM):
		if (ISACPHY(pi)) {
			wlc_phy_fcbs_arm((wlc_phy_t*)pi, 0xFFFF, 0);
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	case IOV_GVAL(IOV_PHY_FCBSEXIT):
		if (ISACPHY(pi)) {
			 wlc_phy_fcbs_exit((wlc_phy_t*)pi);
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
#endif /* ENABLE_FCBS */
#if ((ACCONF != 0) || (NCONF != 0) || (HTCONF != 0) || (LCN40CONF != 0))
	case IOV_SVAL(IOV_ED_THRESH):
		err = wlc_phy_adjust_ed_thres(pi, &int_val, TRUE);
		break;
	case IOV_GVAL(IOV_ED_THRESH):
		err = wlc_phy_adjust_ed_thres(pi, ret_int_ptr, FALSE);
		break;
#endif /* ACCONF || NCONF || LCN40CONF */
	case IOV_GVAL(IOV_PHY_BTC_RESTAGE_RXGAIN):
		err = wlc_phy_iovar_get_btc_restage_rxgain(pi, ret_int_ptr);
		break;
	case IOV_SVAL(IOV_PHY_BTC_RESTAGE_RXGAIN):
		err = wlc_phy_iovar_set_btc_restage_rxgain(pi, int_val);
		break;
	case IOV_GVAL(IOV_PHY_DSSF):
	        err = wlc_phy_iovar_get_dssf(pi, ret_int_ptr);
		break;
	case IOV_SVAL(IOV_PHY_DSSF):
		err = wlc_phy_iovar_set_dssf(pi, int_val);
		break;
#ifdef WL_SARLIMIT
	case IOV_SVAL(IOV_PHY_SAR_LIMIT):
	{
		wlc_phy_sar_limit_set((wlc_phy_t*)pi, (uint32)int_val);
		break;
	}

	case IOV_GVAL(IOV_PHY_TXPWR_CORE):
	{
		uint core;
		uint32 sar = 0;
		uint8 tmp;

		FOREACH_CORE(pi, core) {
			if (pi->txpwr_max_percore_override[core] != 0)
				tmp = pi->txpwr_max_percore_override[core];
			else
				tmp = pi->txpwr_max_percore[core];

			sar |= (tmp << (core * 8));
		}
		*ret_int_ptr = (int32)sar;
		break;
	}
#if defined(WLTEST) || defined(BCMDBG)
	case IOV_SVAL(IOV_PHY_TXPWR_CORE):
	{
		uint core;

		if (!pi->sh->up) {
			err = BCME_NOTUP;
			break;
		} else if (!ISHTPHY(pi)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		FOREACH_CORE(pi, core) {
			pi->txpwr_max_percore_override[core] =
				(uint8)(((uint32)int_val) >> (core * 8) & 0x7f);
			if (pi->txpwr_max_percore_override[core] != 0) {
				pi->txpwr_max_percore_override[core] =
					MIN(WLC_TXPWR_MAX,
					MAX(pi->txpwr_max_percore_override[core],
					pi->min_txpower));
			}
		}
		if (pi->pi_fptr.txpwrrecalc)
			(*pi->pi_fptr.txpwrrecalc)(pi);
		break;
	}
#endif /* WLTEST || BCMDBG */
#endif /* WL_SARLIMIT */

	case IOV_GVAL(IOV_PHY_TXSWCTRLMAP): {
		/* Getter mode, return the previously set value. */
		if (pi->pi_fptr.txswctrlmapgetptr) {
			*ret_int_ptr = (int32) pi->pi_fptr.txswctrlmapgetptr(pi);
		} else {
			/* Not implemented for this phy. */
			err = BCME_UNSUPPORTED;
			PHY_ERROR(("Command not supported for this phy\n"));
		}
		break;
	}
	case IOV_SVAL(IOV_PHY_TXSWCTRLMAP): {
		if (pi->pi_fptr.txswctrlmapsetptr) {
			if (!((int_val >= AUTO) && (int_val <= PAMODE_HI_EFF))) {
				PHY_ERROR(("Value out of range\n"));
				err = BCME_RANGE;
				break;
			}
			/* Setter mode, sets the value. */
			pi->pi_fptr.txswctrlmapsetptr(pi, (int8)int_val);
		} else {
			/* Not implemented for this phy. */
			err = BCME_UNSUPPORTED;
			PHY_ERROR(("Command not supported for this phy\n"));
		}
		break;
	}

#if defined(WFD_PHY_LL)
	case IOV_SVAL(IOV_PHY_WFD_LL_ENABLE):
		if ((int_val < 0) || (int_val > 2)) {
			err = BCME_RANGE;
			break;
		}
		if (ISNPHY(pi) || ISACPHY(pi)) {
			/* Force the channel to be active */
			pi->wfd_ll_chan_active_force =  (int_val == 2) ?TRUE : FALSE;

			pi->wfd_ll_enable_pending = (uint8)int_val;
			if (!PHY_PERICAL_MPHASE_PENDING(pi)) {
				/* Apply it since there is no CAL in progress */
				pi->wfd_ll_enable = (uint8)int_val;
				if (!int_val) {
					/* Force a watchdog CAL when disabling WFD optimization
					 * As PADP CAL has not been executed since a long time
					 * a PADP CAL is executed at the next watchdog timeout
					 */
					 pi->cal_info->last_cal_time = 0;
				}
			}
		}
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_PHY_WFD_LL_ENABLE):
		if (ISNPHY(pi) || ISACPHY(pi)) {
			*ret_int_ptr = pi->wfd_ll_enable;
		}
		else err = BCME_UNSUPPORTED;
		break;
#endif /* WFD_PHY_LL */

#if defined(WLTEST) || defined(BCMDBG)

		case IOV_SVAL(IOV_PHY_ENABLE_EPA_DPD_2G):
		case IOV_SVAL(IOV_PHY_ENABLE_EPA_DPD_5G):
		{
			if (pi->pi_fptr.epadpdsetptr) {
				if ((int_val < 0) || (int_val > 1)) {
					err = BCME_RANGE;
					PHY_ERROR(("Value out of range\n"));
					break;
				}
				pi->pi_fptr.epadpdsetptr(pi, (uint8)int_val,
					(actionid == IOV_SVAL(IOV_PHY_ENABLE_EPA_DPD_2G)));
			} else {
				/* Not implemented for this phy. */
				err = BCME_UNSUPPORTED;
				PHY_ERROR(("Command not supported for this phy\n"));
			}
			break;
		}

		case IOV_GVAL(IOV_PHY_EPACAL2GMASK): {
			*ret_int_ptr = (uint32)pi->epacal2g_mask;
			break;
		}

		case IOV_SVAL(IOV_PHY_EPACAL2GMASK): {
			pi->epacal2g_mask = (uint16)int_val;
			break;
		}
#endif /* defined(WLTEST) || defined(BCMDBG) */
#if defined(WLTEST) || defined(DBG_PHY_IOV)
	case IOV_GVAL(IOV_PHYTABLE):
		wlc_phy_table_get(pi, int_val, p, a);
		break;

	case IOV_SVAL(IOV_PHYTABLE):
		wlc_phy_table_set(pi, int_val, p);
		break;
#endif /* BCMDBG || WLTEST || DBG_PHY_IOV */

#if defined(WLTEST) || defined(ATE_BUILD)
	case IOV_GVAL(IOV_PHY_TX_TONE):
	case IOV_GVAL(IOV_PHY_TX_TONE_HZ):
		*ret_int_ptr = pi->phy_tx_tone_freq;
		break;

	case IOV_SVAL(IOV_PHY_TX_TONE_STOP):
		wlc_phy_iovar_tx_tone_stop(pi);
		break;

	case IOV_SVAL(IOV_PHY_TX_TONE):
		wlc_phy_iovar_tx_tone(pi, (int32)int_val);
		break;

	case IOV_SVAL(IOV_PHY_TX_TONE_HZ):
		wlc_phy_iovar_tx_tone_hz(pi, (int32)int_val);
		break;
#endif // endif

#if defined(WLTEST)
	case IOV_GVAL(IOV_PHY_SWCTRLMAP): {
		/* Return the previously set value. */
		if (pi->pi_fptr.swctrlmapgetptr) {
			pi->pi_fptr.swctrlmapgetptr(pi, (uint32 *)ret_int_ptr);
		} else {
			/* Not implemented for this phy. */
			err = BCME_UNSUPPORTED;
			PHY_ERROR(("Command not supported for this phy\n"));
		}
		break;
	}

	case IOV_SVAL(IOV_PHY_SWCTRLMAP): {
		if (pi->pi_fptr.swctrlmapsetptr) {
			uint32 swctrlmap[2] = { 0 };
			/* Note swctrlmap_entry and swctrlmap_mask */
			bcopy(p, swctrlmap, 2 * sizeof(uint32));
			pi->pi_fptr.swctrlmapsetptr(pi, swctrlmap[0], swctrlmap[1]);
		} else {
			/* Not implemented for this phy. */
			err = BCME_UNSUPPORTED;
			PHY_ERROR(("Command not supported for this phy\n"));
		}
		break;
	}
#endif // endif
	case IOV_GVAL(IOV_OLPC_ANCHOR_2G):
		int_val = pi->olpc_anchor2g;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_SVAL(IOV_OLPC_ANCHOR_2G):
		pi->olpc_anchor2g = (int8) int_val;
		break;
	case IOV_GVAL(IOV_OLPC_ANCHOR_5G):
		int_val = pi->olpc_anchor5g;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_SVAL(IOV_OLPC_ANCHOR_5G):
		pi->olpc_anchor5g = (int8) int_val;
		break;
	case IOV_GVAL(IOV_OLPC_THRESH):
		int_val = pi->olpc_thresh;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_SVAL(IOV_OLPC_THRESH):
		/* iovar override for olpc_thresh */
		pi->olpc_thresh = (int8) int_val;
		pi->olpc_thresh_iovar_ovr = 1;
		break;
	case IOV_GVAL(IOV_DISABLE_OLPC):
		int_val = pi->disable_olpc;
		bcopy(&int_val, a, sizeof(int_val));
		break;
	case IOV_SVAL(IOV_DISABLE_OLPC):
		pi->disable_olpc = (int8) int_val;
		break;
	case IOV_GVAL(IOV_OLPC_IDX_VALID):
		int_val = pi->olpc_idx_valid;
		bcopy(&int_val, a, sizeof(int_val));
		break;
#ifdef PHY_XTAL_SPUR_CAL
#if defined(WLTEST)
	case IOV_GVAL(IOV_PHY_CAL_XTAL_SPUR): {
		phy_cal_xtal_spur_t cal_xtal_spur_params;
		memcpy(&cal_xtal_spur_params, p, sizeof(cal_xtal_spur_params));
		err = wlc_phy_cal_xtal_spur(pi, &cal_xtal_spur_params);
		memcpy(a, &cal_xtal_spur_params, sizeof(cal_xtal_spur_params));
		break;
	}
#endif // endif
#endif /* PHY_XTAL_SPUR_CAL */
	default:
		err = BCME_UNSUPPORTED;
	}
	return err;
}

static bool
wlc_phy_cmn_attach(phy_info_t *pi)
{
#ifdef WLRSDB
	int ref_count = 0;

	/* OBJECT REGISTRY: check if shared key has value already stored */
	pi->cmn = (phy_cmn_info_t*) wlapi_obj_registry_get(pi->sh->physhim, OBJR_PHY_CMN_INFO);

	if (pi->cmn == NULL) {
		if ((pi->cmn = (phy_cmn_info_t*)MALLOC(pi->sh->osh,
			sizeof(phy_cmn_info_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			          __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->cmn, sizeof(phy_cmn_info_t));

		/* OBJECT REGISTRY: We are the first instance, store value for key */
		wlapi_obj_registry_set(pi->sh->physhim, OBJR_PHY_CMN_INFO, pi->cmn);

#if defined(AP) && defined(RADAR)
		if ((pi->cmn->ri = (radar_info_t *)MALLOC(pi->sh->osh,
			sizeof(radar_info_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			          __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->cmn->ri, sizeof(radar_info_t));
#endif // endif
	}

	/* assign allocated common ptrs pi->cmn->xx to pi->xx */

#if defined(AP) && defined(RADAR)
	pi->ri = pi->cmn->ri;
#endif /* AP && RADAR */

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		if ((pi->pwrdet12_ac = (srom12_pwrdet_t *)
		     MALLOC(pi->sh->osh, sizeof(srom12_pwrdet_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			           __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->pwrdet12_ac, sizeof(srom12_pwrdet_t));
	}
#endif /* SROM12 */
	if (pi->sh->sromrev == 11) {
		if ((pi->pwrdet_ac = (srom11_pwrdet_t *)
		     MALLOC(pi->sh->osh, sizeof(srom11_pwrdet_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			           __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->pwrdet_ac, sizeof(srom11_pwrdet_t));
	}

	/* OBJECT REGISTRY: Reference the stored value in both instances */
	ref_count = wlapi_obj_registry_ref(pi->sh->physhim, OBJR_PHY_CMN_INFO);
	ASSERT(ref_count <= MAX_RSDB_MAC_NUM);

	pi->cmn->pi[ref_count - 1] = pi;
	pi->cmn->num_d11_cores++;

	printf("\n*** wl%d: %s: pi->cmn->pi[%d] = pi = %p | num_d11_cores = %d ***\n\n",
		pi->sh->unit, __FUNCTION__,
		ref_count - 1, pi,
		pi->cmn->num_d11_cores);
#else

	if ((pi->cmn = (phy_cmn_info_t *)MALLOC(pi->sh->osh, sizeof(phy_cmn_info_t))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		          __FUNCTION__, MALLOCED(pi->sh->osh)));
		return FALSE;
	}
	bzero(pi->cmn, sizeof(phy_cmn_info_t));

#if defined(AP) && defined(RADAR)

	if ((pi->cmn->ri = (radar_info_t *)MALLOC(pi->sh->osh, sizeof(radar_info_t))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		          __FUNCTION__, MALLOCED(pi->sh->osh)));
		return FALSE;
	}
	bzero(pi->cmn->ri, sizeof(radar_info_t));

	/* assign allocated common pointers pi->cmn->XX to pi->XX here */
	pi->ri = pi->cmn->ri;
#endif /* AP && RADAR */

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		if ((pi->pwrdet12_ac = (srom12_pwrdet_t *)
		     MALLOC(pi->sh->osh, sizeof(srom12_pwrdet_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			           __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->pwrdet12_ac, sizeof(srom12_pwrdet_t));
	}
#endif /* SROM12 */
	if (pi->sh->sromrev == 11) {
		if ((pi->pwrdet_ac = (srom11_pwrdet_t *)
		     MALLOC(pi->sh->osh, sizeof(srom11_pwrdet_t))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			           __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}
		bzero((char*)pi->pwrdet_ac, sizeof(srom11_pwrdet_t));
	}
#endif /* WLRSDB */

	return TRUE;
}

static void
wlc_phy_cmn_detach(phy_info_t *pi)
{
#ifdef WLRSDB
	if (wlapi_obj_registry_unref(pi->sh->physhim, OBJR_PHY_CMN_INFO) == 0) {
#if defined(AP) && defined(RADAR)
		if (pi->cmn->ri != NULL) {
			MFREE(pi->sh->osh, pi->cmn->ri, sizeof(radar_info_t));
			pi->cmn->ri = NULL;
		}
#endif /* AP && RADAR */
#ifdef SROM12
		  if (pi->pwrdet12_ac != NULL) {
		    MFREE(pi->sh->osh, pi->pwrdet12_ac, sizeof(srom12_pwrdet_t));
		    pi->pwrdet12_ac = NULL;
		  }
#endif /* SROM12 */
		  if (pi->pwrdet_ac != NULL) {
		    MFREE(pi->sh->osh, pi->pwrdet_ac, sizeof(srom11_pwrdet_t));
		    pi->pwrdet_ac = NULL;
		  }
		wlapi_obj_registry_set(pi->sh->physhim, OBJR_PHY_CMN_INFO, NULL);
		MFREE(pi->sh->osh, pi->cmn, sizeof(phy_cmn_info_t));
	}
#else
	if (pi->cmn != NULL) {
#if defined(AP) && defined(RADAR)
		if (pi->cmn->ri != NULL) {
			MFREE(pi->sh->osh, pi->cmn->ri, sizeof(radar_info_t));
			pi->cmn->ri = NULL;
		}
#endif /* AP && RADAR */
#ifdef SROM12
		if (pi->sh->sromrev == 12) {
		  if (pi->pwrdet12_ac != NULL) {
		    MFREE(pi->sh->osh, pi->pwrdet12_ac, sizeof(srom12_pwrdet_t));
		    pi->pwrdet12_ac = NULL;
		  }
		}
#endif /* SROM12 */
		if (pi->sh->sromrev == 11) {
		  if (pi->pwrdet_ac != NULL) {
		    MFREE(pi->sh->osh, pi->pwrdet_ac, sizeof(srom11_pwrdet_t));
		    pi->pwrdet_ac = NULL;
		  }
		}
		MFREE(pi->sh->osh, pi->cmn, sizeof(phy_cmn_info_t));
		pi->cmn = NULL;
	}
#endif /* WLRSDB */
}
#ifdef WL_PROXDETECT

#ifdef WL_PROXD_SEQ
/* Configure phy appropiately for RTT measurements */
int
wlc_phy_tof(wlc_phy_t *ppi, bool enter, bool tx, bool hw_adj, bool seq_en, int core)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi)) {
		wlc_phy_hold_upd(ppi, PHY_HOLD_FOR_TOF, enter);
		return wlc_phy_tof_acphy(pi, enter, tx, hw_adj, seq_en, core);

	}
	return BCME_UNSUPPORTED;
}
#else
/* Configure phy appropiately for RTT measurements */
int
wlc_phy_tof(wlc_phy_t *ppi, bool enter, bool hw_adj)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi)) {
		wlc_phy_hold_upd(ppi, PHY_HOLD_FOR_TOF, enter);
		wlc_phy_tof_acphy(pi, enter, FALSE, hw_adj, FALSE, 0);

		return BCME_OK;
	}
	return BCME_UNSUPPORTED;
}
#endif /* WL_PROXD_SEQ */

/* Get channel frequency response for deriving 11v rx timestamp */
int
wlc_phy_chan_freq_response(wlc_phy_t *ppi, int len, int nbits,
	int32* Hr, int32* Hi, uint32* Hraw)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		return wlc_phy_chan_freq_response_acphy(pi, len, nbits, (cint32 *)Hr, Hraw);

	return BCME_UNSUPPORTED;
}
/* Get mag sqrd channel impulse response(from channel smoothing hw) to derive 11v rx timestamp */
int
wlc_phy_chan_mag_sqr_impulse_response(wlc_phy_t *ppi, int frame_type,
	int len, int offset, int nbits, int32* h, int* pgd, uint32* hraw, uint16 tof_shm_ptr)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		return wlc_phy_chan_mag_sqr_impulse_response_acphy(pi,
			frame_type, len, offset, nbits, h, pgd, hraw, tof_shm_ptr);

	return BCME_UNSUPPORTED;
}
#ifdef WL_PROXD_SEQ
/* Extract information from status bytes of last rxd frame */
int wlc_phy_tof_info(wlc_phy_t *ppi, int* p_frame_type, int* p_frame_bw, int* p_cfo, int8* p_rssi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi)) {
	  return wlc_phy_tof_info_acphy(pi, p_frame_type, p_frame_bw, p_cfo, p_rssi);
	}
	return BCME_UNSUPPORTED;
}
#else
/* Extract information from status bytes of last rxd frame */
int wlc_phy_tof_info(wlc_phy_t *ppi, int* p_frame_type, int* p_frame_bw, int8* p_rssi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	int cfo;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		return wlc_phy_tof_info_acphy(pi, p_frame_type, p_frame_bw, &cfo, p_rssi);

	return BCME_UNSUPPORTED;
}
#endif /* WL_PROXD_SEQ */

/* Get timestamps from ranging sequence */
int
wlc_phy_seq_ts(wlc_phy_t *ppi, int n, void* p_buffer, int tx, int cfo, int adj, void* pparams,
               int32* p_ts, int32* p_seq_len, uint32* p_raw)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi)) {
	  return wlc_phy_seq_ts_acphy(pi, n, (cint32*)p_buffer, tx, cfo, adj, pparams, p_ts,
	                              p_seq_len, p_raw);
	}
	return BCME_UNSUPPORTED;
}

/* Do any phy specific setup needed for each command */
void wlc_phy_tof_cmd(wlc_phy_t *ppi, bool seq)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		wlc_phy_tof_cmd_acphy(pi, seq);
}

#ifdef WL_PROXD_SEQ

/* Get TOF K value for initiator and target */
int
wlc_phy_tof_kvalue(wlc_phy_t *ppi, chanspec_t chanspec, uint32 *kip, uint32 *ktp, bool seq_en)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		return wlc_phy_tof_kvalue_acphy(pi, chanspec, kip, ktp, seq_en);

	return -1;
}
#else
/* Get TOF K value for initiator and target */
int
wlc_phy_tof_kvalue(wlc_phy_t *ppi, chanspec_t chanspec, uint32 *kip, uint32 *ktp)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	ASSERT(pi != NULL);
	if (ISACPHY(pi))
		return wlc_phy_tof_kvalue_acphy(pi, chanspec, kip, ktp, FALSE);

	return -1;
}
#endif /* WL_PROXD_SEQ */
#endif /* WL_PROXDETECT */

#if (defined(WLTEST) || defined(WLPKTENG))
bool
wlc_phy_isperratedpden(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISACPHY(pi))
		return (*pi->pi_fptr.isperratedpdenptr)(pi);
	return FALSE;
}

void
wlc_phy_perratedpdset(wlc_phy_t *ppi, bool enable)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ISACPHY(pi))
		(*pi->pi_fptr.perratedpdsetptr)(pi, enable);
}
#endif // endif

#ifdef WLTXPWR_CACHE
tx_pwr_cache_entry_t* wlc_phy_get_txpwr_cache(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	return (tx_pwr_cache_entry_t*)pi->txpwr_cache;
}

#if !defined(WLC_LOW_ONLY) && !defined(WLTXPWR_CACHE_PHY_ONLY)

void wlc_phy_set_txpwr_cache(wlc_phy_t *ppi, tx_pwr_cache_entry_t* cacheptr)
{
	phy_info_t *pi = (phy_info_t *)ppi;

	pi->txpwr_cache = cacheptr;
}

#endif // endif

#endif	/* WLTXPWR_CACHE */

uint8
wlc_phy_get_txpwr_backoff(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return pi->tx_pwr_backoff;

}

void
wlc_phy_get_txpwr_min(wlc_phy_t *ppi, uint8 *min_pwr)
{
	/* wlc_phy_get_thresh_acphy() returns OLPC threshold when OLPC
	 * is on otherwise returns tssivisible.
	 * XXX Why tssivisible is used as min TxPwr instead of SROM min
	 * limit only for ACPHY.
	 */
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	phy_info_t *pi = (phy_info_t *)ppi;

	if (ISACPHY(pi))
		*min_pwr = pi->min_txpower;
#endif /* PHYCAL_CACHING || WLMACHAN */

}

#ifndef WLC_DISABLE_ACI
#ifdef WLPHYACICACHE
/* Wrapper function for acicaching and updation in multilink scenario (eg, AWDL) */
extern void
wlc_phy_do_aci_update_cache(wlc_phy_t *ppi, chanspec_t chanspec, bool entry)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	ch_acicache_t *ctx;
	uint cntr_offset;
	uint16 cur_cnt;

	ctx = wlc_phy_get_aci_chanctx(pi, chanspec);
	if (ctx == NULL) {
		return;
	}

	if (entry) {

		/* Restore the ACI state: pick up from wherever it left */
		/* Software restore */
		wlc_phy_aci_cache_restore(pi, ctx);
		/* Write ACI related registers */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			wlc_phy_aci_hw_set_nphy(pi, pi->aci_state, pi->aci_active_pwr_level);
		}
		wlc_phy_aci_noise_shared_hw_set_nphy(pi, FALSE, FALSE);

		/* Check if the time since last update is more than a second */
		if (!(ACI_SCAN_INPROG_PHY(pi) || SCAN_RM_IN_PROGRESS(pi))) {
			if (ctx->dwell_time_since_update >= 1000)
				wlc_phy_aci_upd_multilink(pi, ctx);
		}

		/* Note the time at which drv enters into this link */
		ctx->link_entry_time =
			(R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->tsf_timerlow))/1000;

		/* Update glitch and badplcp counters while entering the channel */
		/* rxcrs glitches */
		cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxcrsglitch);
		cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
		ctx->aci_cache.entry_crsglitch_cnt = cur_cnt;
		/* bphy glitches */
		cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_rxcrsglitch);
		cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
		ctx->aci_cache.entry_bphy_crsglitch_cnt = cur_cnt;
		/* rxbadplcp */
		cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxbadplcp);
		cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
		ctx->aci_cache.entry_badplcp_cnt = cur_cnt;
		/* bphy rxbadplcp */
		cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_badplcp);
		cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
		ctx->aci_cache.entry_bphy_badplcp_cnt = cur_cnt;

	} else /* About to switch this link */
	{
		/* Update glitch etc counters and dwell time */
		wlc_phy_aci_update_counters_multilink(pi, ctx);

		/* Save ACI state */
		wlc_phy_aci_cache_save(pi, ctx);
	}
}

void
wlc_phy_aci_upd_multilink(phy_info_t *pi, ch_acicache_t *ctx)
{
	/* Increase the 'link up time' by one */
	ctx->now += 1;

	/* Normalize the counters to per second */
	ctx->aci_cache.sum_delta_crsglitch =
		(ctx->aci_cache.sum_delta_crsglitch*1000)/
		(ctx->dwell_time_since_update);
	ctx->aci_cache.sum_delta_bphy_crsglitch =
		(ctx->aci_cache.sum_delta_bphy_crsglitch*1000)/
		(ctx->dwell_time_since_update);
	ctx->aci_cache.sum_delta_badplcp =
		(ctx->aci_cache.sum_delta_badplcp*1000)/
		(ctx->dwell_time_since_update);
	ctx->aci_cache.sum_delta_bphy_badplcp =
		(ctx->aci_cache.sum_delta_bphy_badplcp*1000)/
		(ctx->dwell_time_since_update);

	/* Call ACI and Noise mitgation algorithm */
	if (!SCAN_RM_IN_PROGRESS(pi)) {
		if (pi->interf.scanroamtimer != 0)
			pi->interf.scanroamtimer -= 1;

		wlc_phy_aci_upd(pi);

	} else {
		pi->interf.scanroamtimer = 2;
	}

	/* Reset all per second counters */
	ctx->dwell_time_since_update = 0;
	ctx->aci_cache.sum_delta_crsglitch = 0;
	ctx->aci_cache.sum_delta_bphy_crsglitch = 0;
	ctx->aci_cache.sum_delta_badplcp = 0;
	ctx->aci_cache.sum_delta_bphy_badplcp = 0;
}

void
wlc_phy_aci_update_counters_multilink(phy_info_t *pi, ch_acicache_t *ctx)
{
	uint cntr_offset;
	uint16 cur_cnt, delta;
	uint32 present_time;

	/* Update glitch and badplcp counters before exiting the channel */
	/* rxcrs glitches */
	cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxcrsglitch);
	cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
	delta = cur_cnt - ctx->aci_cache.entry_crsglitch_cnt;
	ctx->aci_cache.sum_delta_crsglitch += delta;
	ctx->aci_cache.entry_crsglitch_cnt = cur_cnt;
	/* bphy glitches */
	cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_rxcrsglitch);
	cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
	delta = cur_cnt - ctx->aci_cache.entry_bphy_crsglitch_cnt;
	ctx->aci_cache.sum_delta_bphy_crsglitch += delta;
	ctx->aci_cache.entry_bphy_crsglitch_cnt = cur_cnt;
	/* rxbadplcp */
	cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, rxbadplcp);
	cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
	delta = cur_cnt - ctx->aci_cache.entry_badplcp_cnt;
	ctx->aci_cache.sum_delta_badplcp += delta;
	ctx->aci_cache.entry_badplcp_cnt = cur_cnt;
	/* bphy rxbadplcp */
	cntr_offset = M_UCODE_MACSTAT + OFFSETOF(macstat_t, bphy_badplcp);
	cur_cnt = wlapi_bmac_read_shm(pi->sh->physhim, cntr_offset);
	delta = cur_cnt - ctx->aci_cache.entry_bphy_badplcp_cnt;
	ctx->aci_cache.sum_delta_bphy_badplcp += delta;
	ctx->aci_cache.entry_bphy_badplcp_cnt = cur_cnt;

	/* Update dwell time */
	present_time = (R_REG(GENERIC_PHY_INFO(pi)->osh, &pi->regs->tsf_timerlow))/1000;
	ctx->dwell_time_since_update += (present_time - ctx->link_entry_time);
}
#endif /* WLPHYACICACHE */

#ifdef DYNAMIC_THRESH_UPD
/* This function calculates the bphy desense threshold bsed on the amount
 * of wake duration in PM modes. This threshold is compared against the
 * no. of glitch counts to increase/ decrease bphy desense. Since the glitch
 * count depends upon the wake duration, threshold should also be
 * decided based wake duration in PM mode
 */
static void
wlc_phy_update_glitch_thresholds(phy_info_t *pi)
{
	static uint32 pmdur_prev, pmu_prev;
	uint32 sleep_time, pmdur_cur, pmu_cur, total_time;

	/* Don't change these thresholds for 4324_EPA chips for now.
	 * This change can be incorporated in 4324_EPA chips later if required
	 */
	if (CHIPID_4324X_EPA_FAMILY(pi))
		return;

	/* Computing actual total_time and sleep_time (ms) between watchdog's */

	/* Time in 32usec per tick */
	pmu_cur = wlapi_current_pmu_time();

	/* read sleep (cumulative) time */
	pmdur_cur = wlapi_get_accum_pmdur(pi->sh->physhim);

	if (pmu_cur >= pmu_prev) {
		total_time = ((pmu_cur - pmu_prev)>>5);
		sleep_time = pmdur_cur - pmdur_prev;
		pmdur_prev = pmdur_cur;
		pmu_prev = pmu_cur;
	} else {
		pmdur_prev = pmdur_cur;
		pmu_prev = pmu_cur;
		return;
	}

	/* Computing desense threshold based on wake duration */
	if (total_time >= sleep_time)
		wlc_phy_update_glitch_thresholds_nphy(pi, total_time, sleep_time);
}
#endif /* DYNAMIC_THRESH_UPD */
#endif /* ifndef WLC_DISABLE_ACI */
void wlc_phy_radar_detect_on_off_cfg(wlc_phy_t *ppi, bool radar_on)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	if (ISACPHY(pi)) {
		wlc_phy_radar_detect_on_off_cfg_acphy(pi, radar_on);
	}
}

#if defined(WLC_TXPWRCAP)
int
wlc_phy_txpwrcap_tbl_set(wlc_phy_t *pih, wl_txpwrcap_tbl_t *txpwrcap_tbl)
{
	phy_info_t *pi = (phy_info_t*)pih;
	if (ISACPHY(pi))
		return wlc_phy_txpwrcap_tbl_set_acphy(pi, txpwrcap_tbl);
	else
		return BCME_UNSUPPORTED;
}

int
wlc_phy_txpwrcap_tbl_get(wlc_phy_t *pih, wl_txpwrcap_tbl_t *txpwrcap_tbl)
{
	phy_info_t *pi = (phy_info_t*)pih;
	if (ISACPHY(pi))
		return wlc_phy_txpwrcap_tbl_get_acphy(pi, txpwrcap_tbl);
	else
		return BCME_UNSUPPORTED;
}

int
wlc_phyhal_txpwrcap_get_cellstatus(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	if (ISACPHY(pi))
		return wlc_phy_txpwrcap_get_cellstatus_acphy(pi);
	else
		return BCME_UNSUPPORTED;
}

void
wlc_phyhal_txpwrcap_set_cellstatus(wlc_phy_t *pih, int status)
{
	phy_info_t *pi = (phy_info_t*)pih;
	if (ISACPHY(pi))
		wlc_phy_txpwrcap_set_cellstatus_acphy(pi, TXPWRCAP_CELLSTATUS_WCI2_MASK,
			(status & 1) << TXPWRCAP_CELLSTATUS_WCI2_NBIT);
}

#endif /* WLC_TXPWRCAP */

void
wlc_phy_btc_mode_set(wlc_phy_t *ppi, int btc_mode)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISACPHY(pi)) {
		wlc_phy_btc_dyn_preempt(pi);
	}
}

void
wlc_phy_btc_simrx(wlc_phy_t *ppi, bool enable)
{
	phy_info_t *pi = (phy_info_t*)ppi;

	if (ISACPHY(pi)) {
		/* simultaneous RX for all 4350 chips with shared LNA, under hybrid mode */
		if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
		    (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_FEM_BT)) {
			wlc_phy_btcx_hybrid_mode_simul_rx_acphy(pi, enable);
		}
	}
}

#ifdef WLC_TXCAL
static int
wlc_phy_iovar_adjusted_tssi(phy_info_t *pi, int32 *ret_int_ptr, uint8 int_val)
{
	if (ISACPHY(pi)) {
		if (int_val >= PHY_CORE_MAX)
			*ret_int_ptr = 0;
		else
			*ret_int_ptr = wlc_phy_adjusted_tssi_acphy(pi, int_val);
	}
	return BCME_OK;
}

static int
wlc_phy_txcal_generate_pwr_tssi_tbl(phy_info_t *pi)
{
	uint8 core = pi->txcal_pwr_tssi.set_core;
	int16 pwr_start = pi->txcal_pwr_tssi.pwr_start[core];
	uint8 num_entries = pi->txcal_pwr_tssi.num_entries[core];
	int32 pwr_val = pwr_start;

	int8 i = 0;
	uint8 j, k;
	int16 *pwr = pi->txcal_meas.pwr[core];
#ifdef TXCAL_ROUNDING_FIX
	uint16 *tssi = pi->txcal_meas.tssi[core];
#else
	uint8 *tssi = pi->txcal_meas.tssi[core];
#endif /* TXCAL_ROUNDING_FIX */
	uint8 valid_cnt = pi->txcal_meas.valid_cnt;
	int32 tssi_val;
	uint8 flag;
	int32 num, den;
	for (j = 0; j < num_entries; j++) {
		flag = 0;
		for (k = 0; k < valid_cnt; k++) {
			if (pwr[k] <= pwr_val) {
				flag = 1;
				i = k-1;
				if (i < 0)
					i = 0;
				break;
			}
		}
		if (flag == 0) {
			i = valid_cnt - 2;
			if (i < 0) {
				return BCME_ERROR;
			}
		}
		num = (pwr_val - pwr[i])*(tssi[i+1] - tssi[i]);
		den = pwr[i+1] - pwr[i];
		tssi_val = tssi[i] + (num + (num > 0 ? ABS(den) :
			-ABS(den))/2)/den;
		tssi_val = (tssi_val > 0 ? tssi_val+2 :	tssi_val-2)/4;
		/* Limiting tssi_val in range of 0-255 */
		if (tssi_val < 0)
			tssi_val = 0;
		else if (tssi_val > 255)
			tssi_val = 255;

		pi->txcal_pwr_tssi.tssi[core][j] = (uint8) tssi_val;
		pwr_val = pwr_val + 8;
	}

	pi->txcal_pwr_tssi.gen_tbl = 0;
	return BCME_OK;
}

static int
wlc_phy_txcal_get_pwr_tssi_tbl(phy_info_t *pi, uint8 channel)
{
	/* Go over the list for inquiry of the pwr tssi tbl */
	txcal_pwr_tssi_lut_t *LUT_pt;
	if (channel < 15) {
		LUT_pt = &pi->root_pwr_tssi_lut_2G;
	} else if ((channel & 0x06) == 0x06) {
		LUT_pt = &pi->root_pwr_tssi_lut_5G40;
	} else if ((channel & 0x0A) == 0x0A) {
		LUT_pt = &pi->root_pwr_tssi_lut_5G80;
	} else {
		LUT_pt = &pi->root_pwr_tssi_lut_5G20;
	}
	while (LUT_pt->next_chan != 0) {
		if (LUT_pt->txcal_pwr_tssi.channel == channel) {

			bcopy(&LUT_pt->txcal_pwr_tssi, &pi->txcal_pwr_tssi,
			        sizeof(wl_txcal_power_tssi_t));
			break;
		} else {
			LUT_pt = LUT_pt->next_chan;
		}
	}

	if (LUT_pt->txcal_pwr_tssi.channel == channel) {
		bcopy(&LUT_pt->txcal_pwr_tssi, &pi->txcal_pwr_tssi, sizeof(wl_txcal_power_tssi_t));
	} else {
		memset(&pi->txcal_pwr_tssi, 0, sizeof(wl_txcal_power_tssi_t));
	}
	return BCME_OK;
}

static int
wlc_phy_txcal_store_pwr_tssi_tbl(phy_info_t *pi)
{
	txcal_pwr_tssi_lut_t *LUT_pt;
	txcal_pwr_tssi_lut_t *LUT_tmp;
	txcal_pwr_tssi_lut_t *LUT_root;

	if (pi->txcal_pwr_tssi.channel < 15) {
		LUT_root = &pi->root_pwr_tssi_lut_2G;
	} else if ((pi->txcal_pwr_tssi.channel & 0x06) == 0x06) {
		LUT_root = &pi->root_pwr_tssi_lut_5G40;
	} else if ((pi->txcal_pwr_tssi.channel & 0x0A) == 0x0A) {
		LUT_root = &pi->root_pwr_tssi_lut_5G80;
	} else {
		LUT_root = &pi->root_pwr_tssi_lut_5G20;
	}

	if (LUT_root->txcal_pwr_tssi.channel == 0) {
		/* First valid entry of the linked list */
		bcopy(&pi->txcal_pwr_tssi, &LUT_root->txcal_pwr_tssi,
		      sizeof(wl_txcal_power_tssi_t));
		LUT_root->next_chan = 0;
	} else {
		LUT_pt = LUT_root;
		if (LUT_pt->txcal_pwr_tssi.channel > pi->txcal_pwr_tssi.channel) {
			/* Add entry at the beginning of the linked list */
			if (!(LUT_tmp = (txcal_pwr_tssi_lut_t *) MALLOC(pi->sh->osh,
				sizeof(txcal_pwr_tssi_lut_t)))) {
				PHY_ERROR(("%s: out of memory %d\n", __FUNCTION__,
				        MALLOCED(pi->sh->osh)));
				return BCME_NOMEM;
			}

			bcopy(&LUT_root->txcal_pwr_tssi, &LUT_tmp->txcal_pwr_tssi,
			        sizeof(wl_txcal_power_tssi_t));
			LUT_tmp->next_chan = LUT_root->next_chan;
			bcopy(&pi->txcal_pwr_tssi, &LUT_root->txcal_pwr_tssi,
			        sizeof(wl_txcal_power_tssi_t));
			LUT_root->next_chan = LUT_tmp;
			pi->txcal_pwr_tssi_tbl_count++;
			return BCME_OK;
		}

		while (LUT_pt->next_chan != 0) {
			/* Go over all the entries in the list */
			if (LUT_pt->txcal_pwr_tssi.channel == pi->txcal_pwr_tssi.channel)
				break;
			if ((LUT_pt->txcal_pwr_tssi.channel < pi->txcal_pwr_tssi.channel) &&
			    (LUT_pt->next_chan->txcal_pwr_tssi.channel >
			    pi->txcal_pwr_tssi.channel))
				break;
			LUT_pt = LUT_pt->next_chan;
		}

		if (LUT_pt->txcal_pwr_tssi.channel == pi->txcal_pwr_tssi.channel) {
			/* Channel found, override */
			bcopy(&pi->txcal_pwr_tssi, &LUT_pt->txcal_pwr_tssi,
			        sizeof(wl_txcal_power_tssi_t));
		} else {
			if (pi->txcal_pwr_tssi_tbl_count > 31)
				return BCME_NOMEM;
			if (LUT_pt->next_chan == 0) {
				/* Add to the end of the linked list */
				if (!(LUT_pt->next_chan = (txcal_pwr_tssi_lut_t *)
				        MALLOC(pi->sh->osh, sizeof(txcal_pwr_tssi_lut_t)))) {
					PHY_ERROR(("%s: out of memory %d\n", __FUNCTION__,
					        MALLOCED(pi->sh->osh)));
					return BCME_NOMEM;
				}
				LUT_pt = LUT_pt->next_chan;
				bcopy(&pi->txcal_pwr_tssi, &LUT_pt->txcal_pwr_tssi,
				        sizeof(wl_txcal_power_tssi_t));
				LUT_pt->next_chan = 0;
			} else {
				/* Insert into the linked list */
				if (!(LUT_tmp = (txcal_pwr_tssi_lut_t *) MALLOC(pi->sh->osh,
					sizeof(txcal_pwr_tssi_lut_t)))) {
					PHY_ERROR(("%s: out of memory %d\n", __FUNCTION__,
						MALLOCED(pi->sh->osh)));
					return BCME_NOMEM;
				}

				bcopy(&pi->txcal_pwr_tssi, &LUT_tmp->txcal_pwr_tssi,
				        sizeof(wl_txcal_power_tssi_t));
				LUT_tmp->next_chan = LUT_pt->next_chan;
				LUT_pt->next_chan = LUT_tmp;
			}
			pi->txcal_pwr_tssi_tbl_count++;
		}
	}
	return BCME_OK;
}

#if defined(WLTEST)
static int
wlc_phy_txcal_gainsweep(phy_info_t *pi, wl_txcal_params_t *txcal_params)
{
	int16 gidx;
	uint64 gidx_2core = 0;
	uint16 adj_tssi = 0;
	bool more_steps;
	uint8 cnt = 0;
	uint16 save_TxPwrCtrlCmd = 0;
	uint8 tx_pwr_ctrl_state = pi->txpwrctrl;
	uint8 core;
	if (ISACPHY(pi))
		save_TxPwrCtrlCmd = phy_reg_read(pi, ACPHY_TxPwrCtrlCmd(pi->pubpi.phy_rev));

	gidx = txcal_params->gidx_start;
	do {
		/* Set txpwrindex for two cores to be the same */
		gidx_2core = ((uint64) gidx) | ((uint64) gidx << 32);
		wlc_phy_iovar_txpwrindex_set(pi, &gidx_2core);
		/* Disable HWTXPwrCtrl */
		if (ISACPHY(pi)) {
			wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
		}

		wlapi_bmac_pkteng_txcal(pi->sh->physhim, 0, 0, &(txcal_params->pkteng));

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (ISACPHY(pi)) {
				adj_tssi = wlc_phy_adjusted_tssi_acphy(pi, core);
			}
#ifdef TXCAL_ROUNDING_FIX
			pi->txcal_meas.tssi[core][cnt] = adj_tssi;
#else
			pi->txcal_meas.tssi[core][cnt] = adj_tssi/8;
#endif /* TXCAL_ROUNDING_FIX */
		}
		cnt++;

		wlapi_bmac_pkteng_txcal(pi->sh->physhim, 0, 0, 0);
		wlapi_bmac_service_txstatus(pi->sh->physhim);

		gidx = gidx + txcal_params->gidx_step;
		if ((gidx > 127) || (gidx < 0))
			more_steps = FALSE;
		else
			more_steps = (txcal_params->gidx_step > 0) ?
				(gidx <= txcal_params->gidx_stop) :
				(gidx >= txcal_params->gidx_stop);

	} while (more_steps);
	pi->txcal_meas.valid_cnt = cnt;
	if (ISACPHY(pi)) {
		phy_reg_write(pi, ACPHY_TxPwrCtrlCmd(pi->pubpi.phy_rev), save_TxPwrCtrlCmd);
		wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
	}
	return BCME_OK;
}
#endif // endif

int
wlc_phy_txcal_generate_estpwr_lut(wl_txcal_power_tssi_t *txcal_pwr_tssi, uint16 *estpwr, uint8 core)
{
	uint8 tssi_val_idx;
	uint8 tssi_val;
	int8 i = 0, k;
	int16 pwr_start = txcal_pwr_tssi->pwr_start[core];
	uint8 num_entries = txcal_pwr_tssi->num_entries[core];
	uint8 *tssi = txcal_pwr_tssi->tssi[core];
	int16 pwr_i, pwr_i_1;
	int32 est_pwr_calc;
	int32 num, den;
	for (tssi_val_idx = 0; tssi_val_idx < 128; tssi_val_idx++) {
		tssi_val = tssi_val_idx * 2;
		for (k = num_entries-1; k >= 0; k--) {
			if (tssi[k] >= tssi_val) {
				i = k+1;
				if (i >= num_entries)
					i = num_entries-1;
				break;
			}
		}
		pwr_i = pwr_start + 8*i;
		pwr_i_1 = pwr_start + 8*(i-1);
		if (tssi[i-1] - tssi[i] == 0) {
			est_pwr_calc = pwr_i;
		} else {
			num = (tssi_val - tssi[i])*(pwr_i_1 - pwr_i);
			den = tssi[i-1] - tssi[i];
			est_pwr_calc = pwr_i + (num + (num > 0 ? ABS(den) :
				-ABS(den))/2)/den;
		}
		/* Convert to qdBm for writing to LUT */
		est_pwr_calc = (est_pwr_calc + 1) >> 1;
		if (est_pwr_calc > 127)
			est_pwr_calc = 127;
		else if (est_pwr_calc < -128)
			est_pwr_calc = -128;
		estpwr[tssi_val_idx] = (uint16) (est_pwr_calc & 0xFF);
	}
	return BCME_OK;
}

int
wlc_phy_txcal_apply_pwr_tssi_tbl(phy_info_t *pi, wl_txcal_power_tssi_t *txcal_pwr_tssi)
{
	uint16 estpwr[128];
	uint32 tbl_len = 128;
	uint32 tbl_offset = 0;
	uint8 core;
	uint8 tx_pwr_ctrl_state;

	if (ISACPHY(pi)) {
		tx_pwr_ctrl_state =  pi->txpwrctrl;
		wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (txcal_pwr_tssi->num_entries[core] == 0) {
				/* sanity check */
				wlc_phy_txcal_apply_pa_params(pi);
			} else {
				wlc_phy_txcal_generate_estpwr_lut(txcal_pwr_tssi,
					estpwr, core);
				wlc_phy_table_write_acphy(pi,
					ACPHY_TBL_ID_ESTPWRLUTS(core),
					tbl_len, tbl_offset, 16, estpwr);
			}
		}
		wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
	}
	return BCME_OK;
}

int
wlc_phy_txcal_apply_pa_params(phy_info_t *pi)
{
	uint16 estpwr[128];
	uint32 tbl_len = 128;
	uint32 tbl_offset = 0;
	uint8 core;
	uint8 tx_pwr_ctrl_state;
	int16 a1[PHY_CORE_MAX];
	int16 b0[PHY_CORE_MAX];
	int16 b1[PHY_CORE_MAX];
	uint8 tssi_val;

	if (ISACPHY(pi)) {
		tx_pwr_ctrl_state =  pi->txpwrctrl;
		wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
		wlc_phy_get_paparams_for_band_acphy(pi, a1, b0, b1);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			for (tssi_val = 0; tssi_val < 128; tssi_val++) {
				estpwr[tssi_val] = wlc_phy_tssi2dbm_acphy(pi,
				        tssi_val, a1[core], b0[core], b1[core]);
			}
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core),
				tbl_len, tbl_offset, 16, estpwr);
		}
		wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
		pi->txcal_status = 0;
	}
	return BCME_OK;
}
#endif /* WLC_TXCAL */

/* This function tells you locale info, e.g EU, so that correct edcrs setting could be done */
void
wlc_phy_set_locale(wlc_phy_t *ppi, uint8 region_group)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	pi->region_group = region_group;

	/* Usage Example:
	   if (region_group ==  REGION_EU)
	*/
}

uint8
wlc_phy_get_locale(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return (pi->region_group);
}

#ifdef WLOLPC
int8
wlc_phy_calc_ppr_pwr_cap(wlc_phy_t *pih, uint8 core)
{
	phy_info_t *pi = (phy_info_t*)pih;
	return pi->adjusted_pwr_cap[core];
}
#endif /* WLOLPC */

#ifdef PHY_XTAL_SPUR_CAL
#if defined(WLTEST)
static int
wlc_phy_cal_xtal_spur(phy_info_t *pi, phy_cal_xtal_spur_t *params)
{
	int ret = BCME_OK;

	/* driver must be "up" */
	if (!pi->sh->up)
		return BCME_NOTUP;
	if (!pi->sh->clk)
		return BCME_NOCLK;

	if (!ISACPHY(pi))
		return BCME_UNSUPPORTED;

	ret = wlc_acphy_do_nmos_pmos(pi, params);

	return ret;
}
#endif // endif
#endif /* PHY_XTAL_SPUR_CAL */
