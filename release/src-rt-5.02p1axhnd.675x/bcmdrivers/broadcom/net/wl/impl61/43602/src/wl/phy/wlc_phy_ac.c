/*
 * PHY and RADIO specific portion of Broadcom BCM43XX 802.11abgn
 * Networking Device Driver.
 *
 * Copyright 2020 Broadcom
 *
 * This program is the proprietary software of Broadcom and/or
 * its licensors, and may only be used, duplicated, modified or distributed
 * pursuant to the terms and conditions of a separate, written license
 * agreement executed between you and Broadcom (an "Authorized License").
 * Except as set forth in an Authorized License, Broadcom grants no license
 * (express or implied), right to use, or waiver of any kind with respect to
 * the Software, and Broadcom expressly reserves all rights in and to the
 * Software and all intellectual property rights therein.  IF YOU HAVE NO
 * AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
 * WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
 * THE SOFTWARE.
 *
 * Except as expressly set forth in the Authorized License,
 *
 * 1. This program, including its structure, sequence and organization,
 * constitutes the valuable trade secrets of Broadcom, and you shall use
 * all reasonable efforts to protect the confidentiality thereof, and to
 * use this information only in connection with your use of Broadcom
 * integrated circuit products.
 *
 * 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
 * "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
 * REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR
 * OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
 * DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
 * NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
 * ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING
 * OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
 *
 * 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL
 * BROADCOM OR ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL,
 * SPECIAL, INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR
 * IN ANY WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
 * IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii)
 * ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF
 * OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS SHALL APPLY
 * NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
 *
 * $Id: wlc_phy_ac.c 703921 2017-06-09 15:15:02Z $
 */

#include <wlc_cfg.h>

#if ACCONF != 0
#include <typedefs.h>
#include <qmath.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmutils.h>
#include <siutils.h>
#include <bcmendian.h>
#include <wlioctl.h>
#include <wlc_phy_radio.h>
#include <bitfuncs.h>
#include <bcmdevs.h>
#include <bcmnvram.h>
#include <proto/802.11.h>
#include <hndpmu.h>
#include <bcmsrom_fmt.h>
#include <sbsprom.h>
#include <wlc_phy_hal.h>
#include <wlc_phy_int.h>
#include <wlc_phy_ac.h>
#include <sbchipc.h>
#include <bcmotp.h>

#include "wlc_phyreg_ac.h"
#include "wlc_phytbl_ac.h"
#include "wlc_phytbl_20691.h"
#include "wlc_phytbl_20693.h"
#include "wlc_radioreg_20691.h"
#include "wlc_radioreg_20693.h"
#include "wlc_phy_ac_gains.h"

#ifdef ATE_BUILD
#include <wl_ate.h>
#endif // endif

#ifdef EVENT_LOG_COMPILE
#include <event_log.h>
#endif // endif

#ifndef WLPAPDPARAMS_CACHE
#define ACPHY_PAPD_EPS_TBL_SIZE 64
#endif /* WLPAPDPARAMS_CACHE */

#define ACPHYREGC(pi, reg, core) ((ACPHY_Core0##reg(pi->pubpi.phy_rev)) + ((core) * 0x200))
#define ACPHYREGCE(pi, reg, core) ((ACPHY_##reg##0(pi->pubpi.phy_rev)) + ((core) * 0x200))
#define ACPHYREGCC(pi, reg, core) ((ACPHY_##reg##c0(pi->pubpi.phy_rev)) + ((core) * 0x200))

/* wrapper macros to enable invalid register accesses error messages */
#if defined(BCMDBG_PHYREGS_TRACE)
#define _PHY_REG_READ(pi, reg)			phy_reg_read_debug(pi, reg, #reg)
#define _PHY_REG_MOD(pi, reg, mask, val)	phy_reg_mod_debug(pi, reg, mask, val, #reg)
#define _READ_RADIO_REG(pi, reg)		read_radio_reg_debug(pi, reg, #reg)
#define _MOD_RADIO_REG(pi, reg, mask, val)	mod_radio_reg_debug(pi, reg, mask, val, #reg)
#define _PHY_REG_WRITE(pi, reg, val)		phy_reg_write_debug(pi, reg, val, #reg)
#else
#define _PHY_REG_READ(pi, reg)			phy_reg_read(pi, reg)
#define _PHY_REG_MOD(pi, reg, mask, val)	phy_reg_mod(pi, reg, mask, val)
#define _READ_RADIO_REG(pi, reg)		read_radio_reg(pi, reg)
#define _MOD_RADIO_REG(pi, reg, mask, val)	mod_radio_reg(pi, reg, mask, val)
#define _PHY_REG_WRITE(pi, reg, val)		phy_reg_write(pi, reg, val)
#endif /* BCMDBG_PHYREGS_TRACE */

#define RADIO_REG_2069X(pi, id, regnm, core)	RF##core##_##id##_##regnm(pi->pubpi.radiorev)

/**
 * Macro's to access a bitfield in a PHY register. Differences between these macro's (no postfix,
 * postfixes 'E', 'EE') are there because PHY registers have no consistent naming scheme.
 */
#if PHY_CORE_MAX == 1	/* Single PHY core chips */

#define ACPHY_REG_FIELD_MASK(pi, reg, core, field)	\
	ACPHY_Core0##reg##_##field##_MASK(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_SHIFT(pi, reg, core, field)	\
	ACPHY_Core0##reg##_##field##_SHIFT(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_MASKE(pi, reg, core, field)	\
	ACPHY_##reg##0_##field##_MASK(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field)	\
	ACPHY_##reg##0_##field##_SHIFT(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_MASKEE(pi, reg, core, field)	\
	ACPHY_##reg##0_##field##0_MASK(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_SHIFTEE(pi, reg, core, field)	\
	ACPHY_##reg##0_##field##0_SHIFT(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_MASKCE(pi, reg, core, field)	\
	ACPHY_Core0##reg##_##field##0_MASK(pi->pubpi.phy_rev)
#define ACPHY_REG_FIELD_SHIFTCE(pi, reg, core, field)	\
	ACPHY_Core0##reg##_##field##0_SHIFT(pi->pubpi.phy_rev)

#define RADIO_REG_20693(pi, regnm, core)	RADIO_REG_2069X(pi, 20693, regnm, 0)

#elif PHY_CORE_MAX == 2	/* Dual PHY core chips */

#define ACPHY_REG_FIELD_MASK(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##_MASK(pi->pubpi.phy_rev) : \
	 ACPHY_Core1##reg##_##field##_MASK(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_SHIFT(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##_SHIFT(pi->pubpi.phy_rev) : \
	 ACPHY_Core1##reg##_##field##_SHIFT(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_MASKE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##_MASK(pi->pubpi.phy_rev) : \
	 ACPHY_##reg##1_##field##_MASK(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##_SHIFT(pi->pubpi.phy_rev) : \
	 ACPHY_##reg##1_##field##_SHIFT(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_MASKEE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##0_MASK(pi->pubpi.phy_rev) : \
	 ACPHY_##reg##1_##field##1_MASK(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_SHIFTEE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##0_SHIFT(pi->pubpi.phy_rev) : \
	 ACPHY_##reg##1_##field##1_SHIFT(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_MASKCE(pi, reg, core, field) \
		((core == 0) ? ACPHY_Core0##reg##_##field##0_MASK(pi->pubpi.phy_rev) : \
		 ACPHY_Core1##reg##_##field##1_MASK(pi->pubpi.phy_rev))
#define ACPHY_REG_FIELD_SHIFTCE(pi, reg, core, field) \
		((core == 0) ? ACPHY_Core0##reg##_##field##0_SHIFT(pi->pubpi.phy_rev) : \
		 ACPHY_Core1##reg##_##field##1_SHIFT(pi->pubpi.phy_rev))

#define RADIO_REG_20693(pi, regnm, core)	\
	((core == 0) ? RADIO_REG_2069X(pi, 20693, regnm, 0) : \
	 RADIO_REG_2069X(pi, 20693, regnm, 1))

#else

#define ACPHY_REG_FIELD_MASK(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##_MASK(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_Core1##reg##_##field##_MASK(pi->pubpi.phy_rev) : \
	ACPHY_Core2##reg##_##field##_MASK(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_SHIFT(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##_SHIFT(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_Core1##reg##_##field##_SHIFT(pi->pubpi.phy_rev) : \
	ACPHY_Core2##reg##_##field##_SHIFT(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_MASKE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##_MASK(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_##reg##1_##field##_MASK(pi->pubpi.phy_rev) : \
	ACPHY_##reg##2_##field##_MASK(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##_SHIFT(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_##reg##1_##field##_SHIFT(pi->pubpi.phy_rev) : \
	ACPHY_##reg##2_##field##_SHIFT(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_MASKEE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##0_MASK(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_##reg##1_##field##1_MASK(pi->pubpi.phy_rev) : \
	ACPHY_##reg##2_##field##2_MASK(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_SHIFTEE(pi, reg, core, field) \
	((core == 0) ? ACPHY_##reg##0_##field##0_SHIFT(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_##reg##1_##field##1_SHIFT(pi->pubpi.phy_rev) : \
	ACPHY_##reg##2_##field##2_SHIFT(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_MASKCE(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##0_MASK(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_Core1##reg##_##field##1_MASK(pi->pubpi.phy_rev) : \
	ACPHY_Core2##reg##_##field##2_MASK(pi->pubpi.phy_rev)))
#define ACPHY_REG_FIELD_SHIFTCE(pi, reg, core, field) \
	((core == 0) ? ACPHY_Core0##reg##_##field##0_SHIFT(pi->pubpi.phy_rev) : \
	((core == 1) ? ACPHY_Core1##reg##_##field##1_SHIFT(pi->pubpi.phy_rev) : \
	ACPHY_Core2##reg##_##field##2_SHIFT(pi->pubpi.phy_rev)))

#define RADIO_REG_20693(pi, regnm, core)	\
	((core == 0) ? RADIO_REG_2069X(pi, 20693, regnm, 0) : \
	((core == 1) ? RADIO_REG_2069X(pi, 20693, regnm, 1) : INVALID_ADDRESS))

#endif	/* PHY_CORE_MAX */

/* radio-specific macros */
#define RADIO_REG_20691(pi, regnm, core)	RADIO_REG_2069X(pi, 20691, regnm, 0)

#define RADIO_REG(pi, regnm, core)	\
	((RADIOID((pi)->pubpi.radioid) == BCM20691_ID) \
		? RADIO_REG_20691(pi, regnm, core) : \
	 (RADIOID((pi)->pubpi.radioid) == BCM20693_ID) \
		? RADIO_REG_20693(pi, regnm, core) : INVALID_ADDRESS)

/**
 * Register and register bitfield access macro's. Macro postfixes and associated (example)
 * register bitfields:
 *
 * None: e.g. ACPHY_RfctrlCmd_chip_pu (does not take core# into account)
 * C   : e.g. ACPHY_Core2FastAgcClipCntTh_fastAgcNbClipCntTh
 * CE  : e.g. ACPHY_RfctrlOverrideAfeCfg0_afe_iqdac_pwrup
 * CEE : e.g. ACPHY_EpsilonTableAdjust0_epsilonOffset0
 */

#define WRITE_PHYREG(pi, reg, value)					\
	_PHY_REG_WRITE(pi, ACPHY_##reg(pi->pubpi.phy_rev), (value))

#define WRITE_PHYREGC(pi, reg, core, value)			\
	_PHY_REG_WRITE(pi, ACPHYREGC(pi, reg, core), (value))

#define WRITE_PHYREGCE(pi, reg, core, value)			\
	_PHY_REG_WRITE(pi, ACPHYREGCE(pi, reg, core), (value))

#define MOD_PHYREG(pi, reg, field, value)				\
	_PHY_REG_MOD(pi, ACPHY_##reg(pi->pubpi.phy_rev),		\
		ACPHY_##reg##_##field##_MASK(pi->pubpi.phy_rev),	\
		((value) << ACPHY_##reg##_##field##_##SHIFT(pi->pubpi.phy_rev)))

#define MOD_PHYREGC(pi, reg, core, field, value)			\
	_PHY_REG_MOD(pi,						\
	            ACPHYREGC(pi, reg, core),				\
	            ACPHY_REG_FIELD_MASK(pi, reg, core, field),		\
	            ((value) << ACPHY_REG_FIELD_SHIFT(pi, reg, core, field)))

#define MOD_PHYREGCE(pi, reg, core, field, value)			\
	_PHY_REG_MOD(pi,						\
	            ACPHYREGCE(pi, reg, core),				\
	            ACPHY_REG_FIELD_MASKE(pi, reg, core, field),	\
	            ((value) << ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field)))

#define MOD_PHYREGCEE(pi, reg, core, field, value)			\
	_PHY_REG_MOD(pi,						\
	            ACPHYREGCE(pi, reg, core),				\
	            ACPHY_REG_FIELD_MASKEE(pi, reg, core, field),		\
	            ((value) << ACPHY_REG_FIELD_SHIFTEE(pi, reg, core, field)))

#define READ_PHYREG(pi, reg) \
	_PHY_REG_READ(pi, ACPHY_##reg(pi->pubpi.phy_rev))

#define READ_PHYREGC(pi, reg, core) \
	_PHY_REG_READ(pi, ACPHYREGC(pi, reg, core))

#define READ_PHYREGCE(pi, reg, core) \
	_PHY_REG_READ(pi, ACPHYREGCE(pi, reg, core))

#define READ_PHYREGFLD(pi, reg, field)				\
	((READ_PHYREG(pi, reg)					\
	 & ACPHY_##reg##_##field##_##MASK(pi->pubpi.phy_rev)) >>	\
	 ACPHY_##reg##_##field##_##SHIFT(pi->pubpi.phy_rev))

#define READ_PHYREGFLDC(pi, reg, core, field) \
	((READ_PHYREGC(pi, reg, core) \
		& ACPHY_REG_FIELD_MASK(pi, reg, core, field)) \
		>> ACPHY_REG_FIELD_SHIFT(pi, reg, core, field))

#define READ_PHYREGFLDCE(pi, reg, core, field) \
	((READ_PHYREGCE(pi, reg, core) \
		& ACPHY_REG_FIELD_MASKE(pi, reg, core, field)) \
		>> ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field))

/* Used in PAPD cal */
#define READ_PHYREGFLDCEE(pi, reg, core, field) \
	((READ_PHYREGCE(pi, reg, core) \
		& ACPHY_REG_FIELD_MASKEE(pi, reg, core, field)) \
		>> ACPHY_REG_FIELD_SHIFTEE(pi, reg, core, field))

#define READ_PHYREGFLDCCE(pi, reg, core, field) \
	((READ_PHYREGC(pi, reg, core) \
		& ACPHY_REG_FIELD_MASKCE(pi, reg, core, field)) \
		>> ACPHY_REG_FIELD_SHIFTCE(pi, reg, core, field))

#define MOD_RADIO_REG(pi, regpfx, regnm, fldname, value) \
	_MOD_RADIO_REG(pi, \
	              regpfx##_2069_##regnm, \
	              RF_2069_##regnm##_##fldname##_MASK, \
	              ((value) << RF_2069_##regnm##_##fldname##_SHIFT))

#define MOD_RADIO_REG_2069X(pi, id, regnm, core, fldname, value) \
	_MOD_RADIO_REG(pi, \
		RADIO_REG_##id(pi, regnm, core), \
		RF_##id##_##regnm##_##fldname##_MASK(pi->pubpi.radiorev), \
		((value) << RF_##id##_##regnm##_##fldname##_SHIFT(pi->pubpi.radiorev)))

#define MOD_RADIO_REG_20691(pi, regnm, core, fldname, value) \
	MOD_RADIO_REG_2069X(pi, 20691, regnm, core, fldname, value)

#define MOD_RADIO_REG_20693(pi, regnm, core, fldname, value) \
	MOD_RADIO_REG_2069X(pi, 20693, regnm, core, fldname, value)

#define MOD_RADIO_REG_TINY(pi, regnm, core, fldname, value) \
	(RADIOID((pi)->pubpi.radioid) == BCM20691_ID) \
		? MOD_RADIO_REG_20691(pi, regnm, core, fldname, value) : \
	(RADIOID((pi)->pubpi.radioid) == BCM20693_ID) \
		? MOD_RADIO_REG_20693(pi, regnm, core, fldname, value) : BCM_REFERENCE(pi)

#define MOD_RADIO_REGC(pi, regnm, core, fldname, value) \
	_MOD_RADIO_REG(pi, \
	               RF_2069_##regnm(core), \
	               RF_2069_##regnm##_##fldname##_MASK, \
	               ((value) << RF_2069_##regnm##_##fldname##_SHIFT))

#define READ_RADIO_REG(pi, regpfx, regnm) \
	_READ_RADIO_REG(pi, regpfx##_2069_##regnm)

#define READ_RADIO_REG_20691(pi, regnm, core) \
	_READ_RADIO_REG(pi, RADIO_REG_20691(pi, regnm, core))

#define READ_RADIO_REG_20693(pi, regnm, core) \
	_READ_RADIO_REG(pi, RADIO_REG_20693(pi, regnm, core))

#define READ_RADIO_REG_TINY(pi, regnm, core) \
	((RADIOID((pi)->pubpi.radioid) == BCM20691_ID) ? READ_RADIO_REG_20691(pi, regnm, core) : \
	 (RADIOID((pi)->pubpi.radioid) == BCM20693_ID) ? READ_RADIO_REG_20693(pi, regnm, core) : 0)

#define READ_RADIO_REGC(pi, regpfx, regnm, core) \
	_READ_RADIO_REG(pi, regpfx##_2069_##regnm(core))

#define READ_RADIO_REGFLD(pi, regpfx, regnm, fldname) \
	((_READ_RADIO_REG(pi, regpfx##_2069_##regnm) & \
	              RF_2069_##regnm##_##fldname##_MASK) \
	              >> RF_2069_##regnm##_##fldname##_SHIFT)

#define READ_RADIO_REGFLD_20691(pi, regnm, core, fldname) \
	((_READ_RADIO_REG(pi, RADIO_REG_20691(pi, regnm, core)) & \
		RF_20691_##regnm##_##fldname##_MASK(pi->pubpi.radiorev)) \
		>> RF_20691_##regnm##_##fldname##_SHIFT(pi->pubpi.radiorev))

#define READ_RADIO_REGFLD_20693(pi, regnm, core, fldname) \
	((_READ_RADIO_REG(pi, RADIO_REG_20693(pi, regnm, core)) & \
		RF_20693_##regnm##_##fldname##_MASK(pi->pubpi.radiorev)) \
		>> RF_20693_##regnm##_##fldname##_SHIFT(pi->pubpi.radiorev))

#define READ_RADIO_REGFLD_TINY(pi, regnm, core, fldname) \
	((RADIOID((pi)->pubpi.radioid) == BCM20691_ID) \
		? READ_RADIO_REGFLD_20691(pi, regnm, core, fldname) : \
	 (RADIOID((pi)->pubpi.radioid) == BCM20693_ID) \
		? READ_RADIO_REGFLD_20693(pi, regnm, core, fldname) : 0)

#define READ_RADIO_REGFLDC(pi, regnmcr, regnm, fldname) \
	((_READ_RADIO_REG(pi, regnmcr) & \
	              RF_2069_##regnm##_##fldname##_MASK) \
	              >> RF_2069_##regnm##_##fldname##_SHIFT)

#define ACPHYREG_BCAST(pi, reg, val) \
	_PHY_REG_WRITE(pi, ACPHY_##reg(pi->pubpi.phy_rev) | ACPHY_REG_BROADCAST, val)

#define ACPHY_DISABLE_STALL(pi)	MOD_PHYREG(pi, RxFeCtrl1, disable_stalls, 1)

#define ACPHY_ENABLE_STALL(pi, stall_val) MOD_PHYREG(pi, RxFeCtrl1, disable_stalls, stall_val)

#define WLC_PHY_PRECAL_TRACE(tx_idx, target_gains) \
	PHY_TRACE(("Index was found to be %d\n", tx_idx)); \
	PHY_TRACE(("Gain Code was found to be : \n")); \
	PHY_TRACE(("radio gain = 0x%x%x%x, bbm=%d, dacgn = %d  \n", \
		target_gains->rad_gain_hi, \
		target_gains->rad_gain_mi, \
		target_gains->rad_gain, \
		target_gains->bbmult, \
		target_gains->dac_gain))

/* Table driven register access for dongle memory optimizations */
/* XXX: table driven approach can not be applied as-is on AC PHY, because of the way the AC PHY
 * register access macros are defined (using rev-dependency inside the macro). For that reason,
 * AC-PHY specific table macros are defined that apply the table approach only if a builds is
 * sufficiently chip, radio and PHY rev specific.
 */
#if defined(DONGLEBUILD) && !IS_MULTI_REV(ACCONF) && defined(BCMRADIOREV) && \
	defined(BCMCHIPID)
#define ACPHY_REG_LIST_START						\
	{ static const uint16 write_phy_reg_table[] = {
#define ACPHY_REG_LIST_EXECUTE(pi)					\
	};								\
	phy_reg_write_array(pi, write_phy_reg_table,			\
	sizeof(write_phy_reg_table)/sizeof(write_phy_reg_table[0])); }

#define ACPHYREG_BCAST_ENTRY(pi, reg, val)				\
	PHY_REG_WRITE_RAW_ENTRY(ACPHY_##reg(pi->pubpi.phy_rev) | ACPHY_REG_BROADCAST, val)
#define ACPHY_DISABLE_STALL_ENTRY(pi)					\
	MOD_PHYREG_ENTRY(pi, RxFeCtrl1, disable_stalls, 1)

#define WRITE_PHYREG_ENTRY(pi, reg, value)				\
	PHY_REG_WRITE_RAW_ENTRY(ACPHY_##reg(pi->pubpi.phy_rev), (value))
#define MOD_PHYREG_ENTRY(pi, reg, field, value)				\
	PHY_REG_MOD_RAW_ENTRY(ACPHY_##reg(pi->pubpi.phy_rev),		\
		ACPHY_##reg##_##field##_MASK(pi->pubpi.phy_rev),	\
		((value) << ACPHY_##reg##_##field##_##SHIFT(pi->pubpi.phy_rev)))
#define MOD_PHYREGCE_ENTRY(pi, reg, core, field, value)			\
	PHY_REG_MOD_RAW_ENTRY(ACPHYREGCE(pi, reg, core),		\
	            ACPHY_REG_FIELD_MASKE(pi, reg, core, field),	\
	            ((value) << ACPHY_REG_FIELD_SHIFTE(pi, reg, core, field)))

#define MOD_RADIO_REGC_ENTRY(pi, regnm, core, fldname, value)		\
	RADIO_REG_MOD_ENTRY(RF_2069_##regnm(core),			\
	               RF_2069_##regnm##_##fldname##_MASK,		\
	               ((value) << RF_2069_##regnm##_##fldname##_SHIFT))

#define MOD_RADIO_REG_ENTRY(pi, regpfx, regnm, fldname, value)		\
	RADIO_REG_MOD_ENTRY(regpfx##_2069_##regnm,			\
	              RF_2069_##regnm##_##fldname##_MASK,		\
	              ((value) << RF_2069_##regnm##_##fldname##_SHIFT))
#define WRITE_RADIO_REG_ENTRY(pi, reg, val)				\
		RADIO_REG_WRITE_ENTRY(reg, val)

#define MOD_RADIO_REG_2069X_ENTRY(pi, id, regnm, core, fldname, value)	\
	RADIO_REG_MOD_ENTRY(RADIO_REG_##id(pi, regnm, core),		\
		RF_##id##_##regnm##_##fldname##_MASK(pi->pubpi.radiorev), \
		((value) << RF_##id##_##regnm##_##fldname##_SHIFT(pi->pubpi.radiorev)))
#define MOD_RADIO_REG_20691_ENTRY(pi, regnm, core, fldname, value)	\
	MOD_RADIO_REG_2069X_ENTRY(pi, 20691, regnm, core, fldname, value)

#else /* DONGLEBUILD && !IS_MULTI_REV && BCMCHIPID */
/* XXX: For AC builds that are not sufficiently specific to a PHY REV and CHIP ID,
 * use the non-table driver register access method
 */
#define ACPHY_REG_LIST_START
#define ACPHY_REG_LIST_EXECUTE(pi)
#define ACPHYREG_BCAST_ENTRY(pi, reg, val)				\
	ACPHYREG_BCAST(pi, reg, val);
#define ACPHY_DISABLE_STALL_ENTRY(pi)					\
	ACPHY_DISABLE_STALL(pi);
#define WRITE_PHYREG_ENTRY(pi, reg, value)				\
	WRITE_PHYREG(pi, reg, value);
#define MOD_PHYREG_ENTRY(pi, reg, field, value)				\
	MOD_PHYREG(pi, reg, field, value);
#define MOD_PHYREGCE_ENTRY(pi, reg, core, field, value)			\
	MOD_PHYREGCE(pi, reg, core, field, value);
#define MOD_RADIO_REGC_ENTRY(pi, regnm, core, fldname, value)		\
	MOD_RADIO_REGC(pi, regnm, core, fldname, value);
#define MOD_RADIO_REG_ENTRY(pi, regpfx, regnm, fldname, value)		\
	MOD_RADIO_REG(pi, regpfx, regnm, fldname, value);
#define WRITE_RADIO_REG_ENTRY(pi, reg, val)				\
	write_radio_reg(pi, reg, val);
#define MOD_RADIO_REG_20691_ENTRY(pi, regnm, core, fldname, value)	\
	MOD_RADIO_REG_20691(pi, regnm, core, fldname, value);

#endif /* DONGLEBUILD && !IS_MULTI_REV && BCMCHIPID */
/* Force use of ACPHY specific REG_LIST_xxx macros instead of generic ones */
#undef PHY_REG_LIST_START
#undef PHY_REG_LIST_EXECUTE

#ifndef D11AC_IOTYPES
/* 80 MHz support is included if D11AC_IOTYPES is defined */
#define CHSPEC_IS80(chspec) (0)
#define WL_CHANSPEC_CTL_SB_LL (0)
#define WL_CHANSPEC_CTL_SB_LU (0)
#define WL_CHANSPEC_CTL_SB_UL (0)
#define WL_CHANSPEC_CTL_SB_UU (0)
#endif /* D11AC_IOTYPES */

#define ACPHY_FEMCTRL_ACTIVE(pi)			\
		((ACMAJORREV_0((pi)->pubpi.phy_rev) ||	\
		  ACMAJORREV_1((pi)->pubpi.phy_rev) ||	\
		  ACMAJORREV_2((pi)->pubpi.phy_rev) ||	\
		  ACMAJORREV_5((pi)->pubpi.phy_rev))	\
			? (((pi)->u.pi_acphy->srom.femctrl_from_nvram) == 0) : 0)

#ifdef PHY_IBOARD
#define IBOARD(pi)	TRUE
#else
#define IBOARD(pi)	FALSE
#endif // endif

typedef struct {
	acphy_txgains_t gains;
	bool useindex;
	uint8 index;
} acphy_ipa_txcalgains_t;
typedef struct acphy_papd_restore_state_t {
	uint16 fbmix[2];
	uint16 vga_master[2];
	uint16 intpa_master[2];
	uint16 afectrl[2];
	uint16 afeoverride[2];
	uint16 pwrup[2];
	uint16 atten[2];
	uint16 mm;
	uint16 tr2g_config1;
	uint16 tr2g_config1_core[2];
	uint16 tr2g_config4_core[2];
	uint16 reg10;
	uint16 reg20;
	uint16 reg21;
	uint16 reg29;
} acphy_papd_restore_state;

typedef struct _acphy_ipa_txrxgain {
	uint16 hpvga;
	uint16 lpf_biq1;
	uint16 lpf_biq0;
	uint16 lna2;
	uint16 lna1;
	int8 txpwrindex;
} acphy_ipa_txrxgain_t;

typedef struct {
	uint8 percent;
	uint8 g_env;
} acphy_txiqcal_ladder_t;

typedef struct {
	uint8 nwords;
	uint8 offs;
	uint8 boffs;
} acphy_coeff_access_t;

typedef struct {
	uint8 idx;
	uint16 val;
} sparse_array_entry_t;

typedef struct {
	uint16 gi;
	uint16 g21;
	uint16 g32;
	uint16 g43;
	uint16 r12;
	uint16 r34;
	uint16 gff1;
	uint16 gff2;
	uint16 gff3;
	uint16 gff4;
	uint16 g11;
	uint16 ri3;
	uint16 g54;
	uint16 g65;
} tiny_adc_tuning_array_t;

typedef struct {
	int32 i_accum;
	int32 q_accum;
} phy_hpf_dc_est_t;

/* HWACI Fast channel band switch (FCBS) structures and definitions */
#ifndef WLC_DISABLE_ACI

typedef struct _fcbs_phytbl_list_entry {
	uint16 tbl_id;
	uint16 tbl_offset;
	uint16 num_entries;
} hwaci_fcbs_phytbl_list_entry;

#endif /* !WLC_DISABLE_ACI */

typedef enum  _acphy_enc {
	ACPHY_ENC_CCK,
	ACPHY_ENC_OFDM
} acphy_enc_t;

#define TXPWR_INDEX_INVALID (-1)

/* State for nmos/pmos Xtal spur calibration */
typedef struct {
	phy_info_t *pi;
	uint16 nfft;        /* FFT size: 64 for 20 MHz, 128 for 40 MHz .. */
	uint8  core;        /* which core to measure the spur */
	uint8  fail;        /* increased when a measurement is not valid due to too high noise */
	uint8  spur_low;    /* index of the lower bin of the spur */
	uint8  spur_high;   /* index of the higher bin of the spur */
	uint8  noise1;      /* index of the bin #1 to measure noise */
	uint8  noise2;      /* index of the bin #2 to measure noise */
	uint16 noise_lvl;   /* last measured noise level */
} npmos_cal_state_t;

typedef struct {
	uint8  core;
	uint16 OVR3;
	uint16 auxpga_cfg1;
	uint16 auxpga_vmid;
	uint16 iqcal_cfg1;
	uint16 tx5g_tssi;
	uint16 pa2g_tssi;
	uint16 RfctrlIntc;
	uint16 RfctrlOverrideRxPus;
	uint16 RfctrlCoreRxPu;
	uint16 RfctrlOverrideAuxTssi;
	uint16 RfctrlCoreAuxTssi1;
	uint16 RfctrlOverrideTxPus;
	uint16 RfctrlCoreTxPus;
	uint16 PapdEnable;
	uint16 txgain1_save;
	uint16 txgain2_save;
	uint16 dacgain_save;
	uint16 bq2gain_save;
	uint16 overridegains_save;
	uint16 OVR11;
	uint16 LPF_MAIN_CONTROLS;
} acphy_papdtempcomp_coreregs_t;

typedef struct {
	acphy_papdtempcomp_coreregs_t regs[PHY_CORE_MAX];
	txgain_setting_t orig_gain[PHY_CORE_MAX];
	bool suspend;
	bool suspend_flag;
	uint8 tx_pwr_ctrl_state;
	uint8 core_count;
	uint8 stall_val;
	uint16 save_afePuCtrl;
	uint16 save_gpio;
	uint16 save_gpioHiOutEn;
	uint16 fval2g_orig;
	uint16 fval5g_orig;
	uint16 fval2g, fval5g;
	uint32 save_chipc;
} acphy_papdtempcomp_saved_vals_t;

#ifndef BCMCHIPID
int acphychipid;	/* To select radio offsets depending on chipid */
#endif // endif
static uint16 qt_rfseq_val1[] = {0x8b5, 0x8b5, 0x8b5};
static uint16 qt_rfseq_val2[] = {0x0, 0x0, 0x0};
static uint16 rfseq_reset2rx_cmd[] = {0x4, 0x3, 0x6, 0x2, 0x5, 0x1, 0x8,
            0x2a, 0x2b, 0xf, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f};
static uint16 rfseq_reset2rx_dly[] = {12, 2, 2, 4, 4, 6, 1, 4, 1, 2, 1, 1, 1, 1, 1, 1};
static uint16 rfseq_rx2tx_cmd[] =
        {0x0, 0x1, 0x5, 0x8, 0x2, 0x0, 0x6, 0x3, 0xf, 0x4, 0x0, 0x35, 0xf, 0x0, 0x36, 0x1f};
static uint16 rfseq_rx2tx_dly[] =
	{0x8, 0x6, 0x4, 0x4, 0x6, 0x2, 0x10, 0x26, 0x2, 0x5, 0x1, 0x4, 0xfa, 0xfa, 0x2, 0x1};
static uint16 rfseq_rx2tx_dly_epa1_20[] =
	{0x8, 0x6, 0x4, 0x4, 0x6, 0x2, 0x10, 60, 0x2, 0x5, 0x1, 0x4, 0xe4, 0xfa, 0x2, 0x1};
static uint16 rfseq_rx2tx_dly_epa1_40[] =
	{0x8, 0x6, 0x4, 0x4, 0x6, 0x2, 0x10, 30, 0x2, 0xd, 0x1, 0x4, 0xfa, 0xfa, 0x2, 0x1};
static uint16 rfseq_rx2tx_dly_epa1_80[] =
	{0x8, 0x6, 0x4, 0x4, 0x6, 0x2, 0x10, 20, 0x2, 0x17, 0x1, 0x4, 0xfa, 0xfa, 0x2, 0x1};
static uint16 rfseq_rx2tx_cmd_dacmode[] =
        {0x0, 0x1, 0x5, 0x8, 0x2, 0x3d, 0x6, 0x3, 0xf, 0x4, 0x3e, 0x35, 0xf, 0x0, 0x36, 0x1f};
static uint16 rfseq_tx2rx_cmd_dacmode[] =
	{0x4, 0x3, 0x6, 0x2, 0x3d, 0x5, 0x1, 0x8, 0x2a, 0xf, 0x3e, 0xf, 0x2b, 0x1f, 0x1f, 0x1f};

static uint16 tiny_rfseq_rx2tx_cmd[] =
	{0x42, 0x1, 0x5, 0x8, 0x2, 0x6, 0x3, 0xf, 0x4, 0x35, 0xf, 0x84, 0x36, 0x1f, 0x1f, 0x1f};
static uint16 tiny_rfseq_rx2tx_dly[] =
	{0x8, 0x6, 0x4, 0x4, 0x6, 0x10, 0x26, 0x2, 0x5, 0x4, 0xFA, 0xFA, 0x1, 0x1, 0x1, 0x1};
static uint16 rfseq_rx2tx_cmd_withtssisleep[] =
{0x0000, 0x0001, 0x0005, 0x0008, 0x0002, 0x0006, 0x0003, 0x000f, 0x0004, 0x0035,
0x000f, 0x0000, 0x0000, 0x0036, 0x0080, 0x001f};
static uint16 rfseq_rx2tx_dly_withtssisleep[] =
{0x0008, 0x0006, 0x0006, 0x0004, 0x0006, 0x0010, 0x0026, 0x0002, 0x0006, 0x0004,
0x00ff, 0x00ff, 0x00a8, 0x0004, 0x0001, 0x0001};
static uint16 rfseq_rx2tx_cmd_rev15_ipa[] =
        {0x0, 0x1, 0x5, 0x8, 0x2, 0x6, 0x35, 0x3, 0xf, 0x4, 0x0f, 0x0, 0x0, 0x36, 0x00, 0x1f};
static uint16 rfseq_rx2tx_cmd_rev15_ipa_withtssisleep[] =
        {0x0, 0x1, 0x5, 0x8, 0x2, 0x6, 0x35, 0x3, 0xf, 0x4, 0x0f, 0x0, 0x0, 0x36, 0x80, 0x1f};
static uint16 rfseq_rx2tx_dly_rev15_ipa20[] =
	{0x8, 0x6, 0x6, 0x4, 0x6, 0x10, 40, 0x26, 0x2, 0x6, 0xff, 0xff, 0x56, 0x4, 0x1, 0x1};
static uint16 rfseq_rx2tx_dly_rev15_ipa40[] =
	{0x8, 0x6, 0x6, 0x4, 0x6, 0x10, 16, 0x26, 0x2, 0x6, 0xff, 0xff, 0x6e, 0x4, 0x1, 0x1};
static uint16 rfseq_tx2rx_cmd[] =
        {0x4, 0x3, 0x6, 0x2, 0x0, 0x5, 0x1, 0x8, 0x2a, 0xf, 0x0, 0xf, 0x2b, 0x1f, 0x1f, 0x1f};

/* XXX JIRA:CRDOT11ACPHY-119
 * Add ADC/DAC power down to RFSeq
 */
static uint16 rfseq_tx2rx_dly[] =
	{0x01, 0x8, 0x4, 0x1, 0x2, 0x2, 0x3, 0x4, 0x6, 0x04, 0xa, 0x4, 0x2, 0x01, 0x01, 0x01};

static uint16 tiny_rfseq_tx2rx_cmd[] =
	{0x4, 0x3, 0x6, 0x2, 0x85, 0x5, 0x1, 0x84, 0x85, 0x8, 0x2a, 0xf, 0x0, 0xf, 0x2b, 0x43};
static uint16 tiny_rfseq_tx2rx_dly[] =
	{0x8, 0x4, 0x2, 0x3, 0x1, 0x2, 0x4, 0x2, 0x2, 0x6, 0x4, 0x1, 0x2, 0x1, 0x1, 0x1};

static uint16 rf_updh_cmd_clamp[] = {0x2a, 0x07, 0x0a, 0x00, 0x08, 0x2b, 0x1f, 0x1f};
static uint16 rf_updh_dly_clamp[] = {0x01, 0x02, 0x02, 0x02, 0x10, 0x01, 0x01, 0x01};
static uint16 rf_updl_cmd_clamp[] = {0x2a, 0x07, 0x08, 0x0c, 0x0e, 0x2b, 0x1f, 0x1f};
static uint16 rf_updl_dly_clamp[] = {0x01, 0x06, 0x12, 0x08, 0x10, 0x01, 0x01, 0x01};
static uint16 rf_updu_cmd_clamp[] = {0x2a, 0x07, 0x08, 0x0e, 0x2b, 0x1f, 0x1f, 0x1f};
static uint16 rf_updu_dly_clamp[] = {0x01, 0x06, 0x1e, 0x1c, 0x01, 0x01, 0x01, 0x01};

static uint16 rf_updh_cmd_adcrst[] = {0x07, 0x0a, 0x00, 0x08, 0xb0, 0xb1, 0x1f, 0x1f};
static uint16 rf_updh_dly_adcrst[] = {0x02, 0x02, 0x02, 0x01, 0x0a, 0x01, 0x01, 0x01};
static uint16 rf_updl_cmd_adcrst[] = {0x07, 0x08, 0x0c, 0x0e, 0xb0, 0xb2, 0x1f, 0x1f};
static uint16 rf_updl_dly_adcrst[] = {0x06, 0x12, 0x08, 0x01, 0x0a, 0x01, 0x01, 0x01};
static uint16 rf_updu_cmd_adcrst[] = {0x07, 0x08, 0x0e, 0xb0, 0xb1, 0x1f, 0x1f, 0x1f};
static uint16 rf_updu_dly_adcrst[] = {0x06, 0x1e, 0x1c, 0x0a, 0x01, 0x01, 0x01, 0x01};

static uint16 rfseq_updl_lpf_hpc_ml[] = {0x0aaa, 0x0aaa};
static uint16 rfseq_updl_tia_hpc_ml[] = {0x0222, 0x0222};

static uint32 acphy_papd_scaltbl[] = {	0xB5E002D, 0xAE2002F, 0xA3B0032, 0x9A70035, 0x9220038,
        0x8AB003B, 0x81F003F, 0x7A20043, 0x7340047, 0x6D2004B, 0x67A004F, 0x6170054,
        0x5BF0059, 0x571005E, 0x51E0064, 0x4D3006A, 0x4910070, 0x44C0077, 0x40F007E,
        0x3D90085, 0x3A1008D, 0x36F0095, 0x33D009E, 0x30B00A8, 0x2E000B2, 0x2B900BC,
        0x29200C7, 0x26D00D3, 0x24900E0, 0x22900ED, 0x20A00FB, 0x1EC010A, 0x1D20119,
        0x1B7012A, 0x19E013C, 0x188014E, 0x1720162, 0x15D0177, 0x149018E, 0x13701A5,
        0x12601BE, 0x11501D8, 0x10601F4, 0x0F70212, 0x0E90231, 0x0DC0253, 0x0D00276,
        0x0C4029B, 0x0B902C3, 0x0AF02ED, 0x0A50319, 0x09C0348, 0x093037A, 0x08B03AF,
        0x08303E6, 0x07C0422, 0x0750460, 0x06E04A3, 0x06804E9, 0x0620533, 0x05D0582,
        0x05805D6, 0x053062E, 0x04E068C};
#define TXFILT_SHAPING_OFDM20   0
#define TXFILT_SHAPING_OFDM40   1
#define TXFILT_SHAPING_CCK      2
#define TXFILT_DEFAULT_OFDM20   3
#define TXFILT_DEFAULT_OFDM40   4
uint16 ACPHY_IPA_REV4_txdigi_filtcoeffs[][ACPHY_NUM_DIG_FILT_COEFFS] = {
	{-377, 137, -407, 208, -1527, 956, 93, 186, 93, 230, -44, 230, 201, -191, 201}, /* ofdm20 */
	{-77, 20, -98, 49, -93, 60, 56, 111, 56, 26, -5, 26, 34, -32, 34},              /* ofdm40 */
	{-360, 164, -376, 164, -1533, 576, 308, -314, 308, 121, -73,
	121, 91, 124, 91}, /* cck gauss2.2 */
	{-295, 200, -363, 142, -1391, 826, 151, 301, 151, 151, 301,
	151, 602, -752, 602},  /* 4322 default 20mhz */
	{-92, 58, -96, 49, -104, 44, 17, 35, 17, 12, 25, 12, 13, 27,
	13},   /* 4322 default 40mhz */
	{-375, 136, -399, 209, -1479, 949, 130, 260, 130,
	230, -44, 230, 201, -191, 201}, /* a-band ofdm20 */
	{0xed9, 0xc8, 0xe95, 0x8e, 0xa91, 0x33a, 0x97, 0x12d, 0x97,
	0x97, 0x12d, 0x97, 0x25a, 0xd10, 0x25a}, /* Japan channel 14 (CCK) */
	{-77, 20, -97, 47, -96, 59, 62, 122, 62, 20, -4,
	20, 32, -30, 32},		/* ofdm40 sharper cut-off. ofdm22 in Tcl. */
	{-77, 20, -98, 49, -93, 60, 76, 0, 0, 38, 24,
	4, 76, -82, 76},		/* ofdm40 for 53572 */
	{-375, 136, -407, 208, -1527, 956, 93, 186, 93,
	230, -44, 230, 201, -191, 201}, /* ofdm20 for 43228 */
	{-337, 144, -376, 164, -1533, 576, 308, -235, 308,
	121, -73, 121, 91, 124, 91},	/* New cck filter for 43239 with better SM */
	{-77, 20, -96, 49, -92, 60, 58, 99, 58,
	29, -18, 29, 58, -63, 58}, /* ofdm26 for 43217 */
	{-377, 137, -409, 213, -1517, 964, 93, 186, 93,
	230, -44, 230, 201, -191, 201},	/* ofdm5 for 43217 20HMz */
	{-352, 207, -255, 64, -1168, 433, 151, 301, 151,
	151, 24, 151, 602, -380, 602},  /* ofdm20 for 43239 */
	{-375, 136, -407, 208, -1527, 956, 93, 186, 93,
	230, -44, 230, 201, -191, 201},	/* ofdm20 for 43217 */
	{-307, 82, -389, 189, -1529, 938, 256, 511, 256,
	102, -20, 102, 273, -260, 273} /* ofdm3 */
};
int8 *rfpwrlut_ptr;
uint16 papd_gainctrl_pga[PHY_CORE_MAX];
/* PAPD MODE CONFIGURATION */
#define PAPD_LMS 0
#define PAPD_ANALYTIC 1
#define PAPD_ANALYTIC_WO_YREF 2

/* PHY_PACALSTATUS */
#define PHY_PACALSTATUS_CAL_TIMEOUT 0x1
#define PHY_PACALSTATUS_POWER_CONTROL_DIVERGED 0x2
#define PHY_PACALSTATUS_AMPM_OVERFLOW 0x4

int8 gain_ctrl = 0; /* Use this flag for PAPD gain control */

/*
 * ATE want this global variable so they can check the 4345 sample capture timeouts.
 * And we also want to limit the number of retires.
 */
uint32 sample_capture_pointer_timeouts;

static int8 pga_gain_array_2g[256] = {-14, -14, -14, -14, -14, -14, -14,
    -14, -14, -14, -14, -14, -14, -14, -14, -14,
    -13, -12, -11, -10, -9, -8, -8, -7, -6, -6, -5, -4, -4, -3, -2, -2,
     -1,  0,  0,  1,  1,  2,  2,  3,  3,  3,  4,  4,  5,  5,  5,  6,
      6,  6,  6,  7,  7,  7,  8,  8,  8,  8,  9,  9,  9, 10, 10, 10,
     10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14,
     14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 17, 17,
     17, 17, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 20,
     20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 22, 21,
     21, 22, 21, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25,
     26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27,
     27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
     29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30,
     30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31,
     31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 33};

static int8  pga_gain_array_5g_0[256] = {-43, -37, -28, -22, -18, -14, -11, -9, -7,
-5, -3, -2, 0, 1, 3, 4,
5,  6,  7,  8,  9,  9, 10, 11, 11, 12, 12, 13, 14, 14, 15, 15,
16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 20, 21, 21, 21, 22,
22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26,
26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29,
29, 29, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 32, 32,
32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34,
34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36,
36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38,
38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39,
39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
44, 44, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45};
static int8  pga_gain_array_5g_1[256] = {-44, -37, -28, -22, -18, -14, -11, -9, -7, -5,
-3, -2, 0, 1, 2, 4,
4,  5,  6,  7,  8,  9, 10, 11, 11, 11, 12, 13, 13, 14, 15, 15,
16, 16, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21,
22, 22, 22, 23, 23, 23, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25,
25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29,
29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
31, 31, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33,
33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35,
35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37,
37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39,
39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40,
40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41,
41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42,
42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43,
43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44,
44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44};
static int8  pga_gain_array_5g_2[256] = {-43, -37, -28, -22, -18, -14, -11, -9, -7, -5,
-3, -2, 0, 1, 2, 4,
4,  5,  6,  7,  8,  9, 10, 10, 10, 11, 12, 13, 13, 14, 14, 15,
15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 21, 21, 21,
21, 22, 21, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25,
25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29,
29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
31, 31, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33,
33, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35,
35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37,
37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39,
39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40,
40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41,
41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42,
42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43,
43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44};
static int8  pga_gain_array_5g_3[256] =  {-45, -37, -27, -21, -18, -14, -11, -8, -7, -4, -3,
-1, 0, 1, 3, 4,
5,  6,  7,  8,  8,  9, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16,
16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21, 20, 21, 21, 21,
21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 26, 26,
26, 26, 26, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29,
29, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 32, 32, 32,
32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34,
34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36,
36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38,
38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39,
39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
41, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,
42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,
44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45};
static int8 pga_gain_array_2g_4354[256] = {	-23, -23, -23, -23, -23, -23,
-23, -23, -20, -20, -18, -17, -15, -14, -13, -12,
-12, -12, -11, -10, -9, -8, -7, -6, -6, -6, -6, -5, -5, -5, -5, -4,
 -4, -4, -4, -4, -4, -4, -4, -2, -2, -2, -2, -2, -2, -2, -2, -2,
 -2, -2, -1, -1, -1,  0,  0,  0,  0,  1,  1,  1,  2,  2,  2,  2,
  3,  3,  4,  4,  4,  4,  4,  6,  7,  7,  7,  7,  7,  7,  7,  7,
  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,
  9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12,
 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20,
 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21,
 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25};
static int8 pga_gain_array_5g_4354[256] = {-43, -43, -35, -30, -27,
-23, -21, -18, -16, -14, -12, -11, -10, -8, -7, -6,
-5, -4, -3, -2, -2, -1, 0, 1, 2, 2, 3, 4, 4, 5, 5, 6,
6,  7,  7,  8,  8,  9,  9,  10, 10, 10, 11, 11, 11, 12, 12, 13,
13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17,
17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19,
19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22,
22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24,
24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28,
28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31,
31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32,
32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34,
34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35,
35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36,
36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 36, 37};
static int8 pga_gain_array_5g_435x_radiorev40[256] = {-45, -45, -37, -32, -29, -25, -23,
-20, -18, -16, -14, -13, -12, -10, -9, -8,
-7, -6, -5, -4, -4, -3, -2, -1,  0,  0,  1,  2,  2,  3,  3,  4,
 4,  5,  5,  6,  6,  7,  7,  8,  8,  8,  9,  9,  9, 10, 10, 11,
11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15,
15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19,
19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22,
22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24,
24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28,
28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31,
31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32,
32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34,
34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35,
35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36,
36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 36, 37};

static int8 pga_gain_array_5g_435x_radiorev44[256] = {-43, -43, -35, -30, -27,
-23, -21, -18, -16, -14, -12, -11, -10, -8, -7, -6,
-5, -4, -3, -2, -2, -1, 0, 1, 2, 2, 3, 4, 4, 5, 5, 6,
6, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 13,
13, 13, 14, 14, 14, 14, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19,
19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22,
22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24,
24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28,
28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31,
31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32,
32, 32, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34,
34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35,
35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36,
36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 36, 37};

static int8 pga_gain_array_2g_epapd[2][256] = {{ -31, -27, -24, -21, -18,
 -15, -13, -10, -10, -8, -7, -5, -4, -2, -1,  0,
  1,  2,  3,  4,  5,  6,  6,  7,  7,  8,  9,  9, 10, 11, 11, 12,
 13, 13, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19,
 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24,
 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28,
 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30,
 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33,
 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35,
 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38,
 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43,
 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44,
 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46},
{ -31, -27, -24, -21, -18, -15, -13, -10, -10, -8, -7, -5, -4, -2, -1, 0,
  1,  2,  3,  4,  5,  6,  6,  7,  7,  8,  9,  9, 10, 11, 11, 12,
 13, 13, 14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 19, 19,
 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 22, 22, 23, 23, 23, 24,
 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28,
 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30,
 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33,
 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35,
 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38,
 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43,
 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44,
 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46}};

static int8 pga_gain_array_5g_epapd_0[256] = {-12, -12, -12, -12, -12, -12,
-12, -9, -9, -9, -9, -9, -8, -7, -6, -5,
-4, -3, -3, -3, -3, -3, -2, -1,	 0,  0,	 1,  1,	 2,  3,	 3,  4,
 4,  5,	 5,  6,	 6,  7,	 7,  7,	 8,  8,	 9,  9,	 9, 10, 10, 10,
11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15, 15,
15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 22,
22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32,
32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33,
33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34,
34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35,
35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 37, 37};

static uint16 sdadc_cfg20 = 0xd5eb;
static uint16 sdadc_cfg40 = 0x45ea;
/* High SNR 40M */
static uint16 sdadc_cfg40hs = 0x43e9;
static uint16 sdadc_cfg80 = 0x07f8;

static uint8 ac_lna1_2g[]       = {0xf6, 0xff, 0x6, 0xc, 0x12, 0x19};
static uint8 ac_lna1_2g_ilna[]  = {0xff, 0xff, 0x6, 0xc, 0x12, 0x19};
static uint8 ac_lna1_2g_tiny[]	= {0xfa, 0x00, 0x6, 0xc, 0x12, 0x18};
static uint8 ac_lna1_5g_tiny[]	= {0xfb, 0x00, 0x6, 0xc, 0x12, 0x18};
static uint8 ac_tiny_g_lna_rout_map[] = {9, 9, 9, 9, 6, 0};
static uint8 ac_tiny_g_lna_gain_map[] = {2, 3, 4, 5, 5, 5};
static uint8 ac_tiny_a_lna_rout_map[] = {11, 11, 11, 11, 7, 0};
static uint8 ac_tiny_a_lna_gain_map[] = {4, 5, 6, 7, 7, 7};
static uint8 ac_lna1_2g_ltecoex[]       = {0xf6, 0xff, 0x6, 0xc, 0x12, 0x16};
static uint8 ac_lna1_2g_43569_btdesense_rout_4[] = {5, 5, 5, 5, 5, 5};
static uint8 ac_lna1_2g_43569_btdesense_rout_0[] = {9, 9, 9, 9, 9, 9};
static uint8 ac_lna1_5g[] = {0xf9, 0xfe, 0x4, 0xa, 0x10, 0x17};
static uint8 ac_lna2_2g_gm2[] = {0xf4, 0xf8, 0xfc, 0xff, 0x2, 0x5, 0x9};
static uint8 ac_lna2_2g_gm3[] = {0xf6, 0xfa, 0xfe, 0x01, 0x4, 0x7, 0xb};
static uint8 ac_lna2_tiny[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};
static uint8 ac_lna2_tiny_ilna_dcc_comp[] = {0, 20, 16, 12, 8, 4, 0};
static uint8 ac_lna2_2g_ltecoex[] = {0xf4, 0xf8, 0xfc, 0xff, 0xff, 0x5, 0x9};
static uint8 ac_lna2_2g_ilna[] = {0xfa, 0xfa, 0xfe, 0x01, 0x4, 0x7, 0xb};
static uint8 ac_lna2_5g[] = {0xf5, 0xf8, 0xfb, 0xfe, 0x2, 0x5, 0x9};
static uint8 ac_lna1_rout_delta_2g[] = {0, 1, 2, 2, 3, 5, 6, 8, 10, 12, 14, 16};
static uint8 ac_lna2_rout_delta_2g[] = {0, 0, 1, 1, 1, 2, 3, 4,  5,  6,  8, 10};
static uint8 ac_lna1_rout_delta_5g[] = {10, 7, 4, 2, 0};

/* China 40M Spur WAR */
static uint16 resamp_cnwar_5270[] = {0x4bda, 0x0038, 0x10e0, 0x4bda, 0x0038, 0x10e0,
0xed0e, 0x0068, 0xed0e, 0x0068};
static uint16 resamp_cnwar_5310[] = {0x0000, 0x00d8, 0x0b40, 0x0000, 0x00d8, 0x0b40,
0x6c79, 0x0045, 0x6c79, 0x0045};

static uint8 avvmid_set[25][5][6] = {{{2, 1, 2,   107, 150, 110},  /* pdet_id = 0 */
			       {2, 2, 1,   157, 153, 160},
			       {2, 2, 1,   157, 153, 161},
			       {2, 2, 0,   157, 153, 186},
			       {2, 2, 0,   157, 153, 187}},
			       {{1, 0, 1,   159, 174, 161},  /* pdet_id = 1 */
			       {1, 0, 1,   160, 185, 156},
			       {1, 0, 1,   163, 185, 162},
			       {1, 0, 1,   169, 187, 167},
			       {1, 0, 1,   152, 188, 160}},
			       {{1, 1, 1,   159, 166, 166},  /* pdet_id = 2 */
			       {2, 2, 4,   140, 151, 100},
			       {2, 2, 3,   143, 153, 116},
			       {2, 2, 2,   143, 153, 140},
			       {2, 2, 2,   145, 160, 154}},
			       {{1, 1, 2,   130, 131, 106},  /* pdet_id = 3 */
			       {1, 1, 2,   130, 131, 106},
			       {1, 1, 2,   128, 127, 97},
			       {0, 1, 3,   159, 137, 75},
			       {0, 0, 3,   164, 162, 76}},
			       {{1, 1, 1,   156, 160, 158},  /* pdet_id = 4 */
			       {1, 1, 1,   156, 160, 158},
			       {1, 1, 1,   156, 160, 158},
			       {1, 1, 1,   156, 160, 158},
			       {1, 1, 1,   156, 160, 158}},
			       {{2, 2, 2,   104, 108, 106},  /* pdet_id = 5 */
			       {2, 2, 2,   104, 108, 106},
			       {2, 2, 2,   104, 108, 106},
			       {2, 2, 2,   104, 108, 106},
			       {2, 2, 2,   104, 108, 106}},
			       {{2, 0, 2,   102, 170, 104},  /* pdet_id = 6 */
			       {3, 4, 3,    82, 102,  82},
			       {1, 3, 1,   134, 122, 136},
			       {1, 3, 1,   134, 124, 136},
			       {2, 3, 2,   104, 122, 108}},
			       {{0, 0, 0,   180, 180, 180},  /* pdet_id = 7 */
			       {0, 0, 0,   180, 180, 180},
			       {0, 0, 0,   180, 180, 180},
			       {0, 0, 0,   180, 180, 180},
			       {0, 0, 0,   180, 180, 180}},
			       {{2, 1, 2,   102, 138, 104},  /* pdet_id = 8 */
			       {3, 5, 3,    82, 100,  82},
			       {1, 4, 1,   134, 116, 136},
			       {1, 3, 1,   134, 136, 136},
			       {2, 3, 2,   104, 136, 108}},
			       {{3, 2, 3,    90, 106,  86},  /* pdet_id = 9 */
			       {3, 1, 3,    90, 158,  90},
			       {2, 1, 2,   114, 158, 112},
			       {2, 1, 1,   116, 158, 142},
			       {2, 1, 1,   116, 158, 142}},
			       {{2, 2, 2,   152, 156, 156},  /* pdet_id = 10 */
			       {2, 2, 2,   152, 156, 156},
			       {2, 2, 2,   152, 156, 156},
			       {2, 2, 2,   152, 156, 156},
			       {2, 2, 2,   152, 156, 156}},
			       {{1, 1, 1,   134, 134, 134},  /* pdet_id = 11 */
			       {1, 1, 1,   136, 136, 136},
			       {1, 1, 1,   136, 136, 136},
			       {1, 1, 1,   136, 136, 136},
			       {1, 1, 1,   136, 136, 136}},
			       {{3, 3, 3,    90,  92,  86},  /* pdet_id = 12 */
			       {3, 3, 3,    90,  86,  90},
			       {2, 3, 2,   114,  86, 112},
			       {2, 2, 1,   116, 109, 142},
			       {2, 2, 1,   116, 110, 142}},
			       {{2, 2, 2,   112, 114, 112},  /* pdet_id = 13 */
			       {2, 2, 2,   114, 114, 114},
			       {2, 2, 2,   114, 114, 114},
			       {2, 2, 2,   113, 114, 112},
			       {2, 2, 2,   113, 114, 112}},
			       {{1, 1, 1,   134, 134, 134},  /* pdet_id = 14 */
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168}},
			       {{0, 0, 0,   172, 172, 172},  /* pdet_id = 15 */
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168}},
			       {{3, 2, 3,    90, 106,  86},  /* pdet_id = 16 */
			       {3, 0, 3,    90, 186,  90},
			       {2, 0, 2,   114, 186, 112},
			       {2, 0, 1,   116, 186, 142},
			       {2, 0, 1,   116, 186, 142}},
			       {{4, 4, 4,   50,  45,  50},  /* pdet_id = 17 */
			       {3, 3, 3,    82,  82, 82},
			       {3, 3, 3,    82,  82, 82},
			       {3, 3, 3,    82,  82, 82},
			       {3, 3, 3,    82,  82, 82}},
			       {{5, 5, 5,   61,  61,  61},  /* pdet_id = 18 */
			       {2, 2, 2,   122, 122, 122},
			       {2, 2, 2,   122, 122, 122},
			       {2, 2, 2,   122, 122, 122},
			       {2, 2, 2,   122, 122, 122}},
			       {{2, 2, 2,  152, 156, 156},  /* pdet_id = 19 */
			       {1, 1, 1,   165, 165, 165},
			       {1, 1, 1,   160, 160, 160},
			       {1, 1, 1,   152, 150, 160},
			       {1, 1, 1,   152, 150, 160}},
                               {{3, 3, 3,  108, 108, 108},  /* pdet_id = 20 */
			       {1, 1, 1,   160, 160, 160},
			       {1, 1, 1,   160, 160, 160},
			       {1, 1, 1,   160, 160, 160},
			       {1, 1, 1,   160, 160, 160}},
                               {{2, 2, 2,  110, 110, 110},  /* pdet_id = 21 */
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168},
			       {0, 0, 0,   168, 168, 168}},
			       {{6, 6, 6,   40,  40,  40},  /* pdet_id = 22 */
			       {2, 2, 1,   115, 115, 142},
			       {1, 2, 1,   142, 115, 142},
			       {1, 1, 1,   142, 142, 142},
			       {1, 1, 1,   142, 142, 142}},
			       {{1, 1, 1,  156, 160, 158},  /* pdet_id = 23 */
			       {6, 6, 6,    47,  45,  48},
			       {1, 1, 1,   147, 146, 148},
			       {1, 1, 1,   146, 146, 152},
			       {1, 1, 1,   146, 146, 152}},
			       {{2, 2, 2,   120, 120, 120}, /* pdet_id =24 */
			       {2, 2, 2,   120, 120, 120},
			       {2, 2, 2,   120, 120, 120},
			       {2, 2, 2,   120, 120, 120},
			       {2, 2, 2,   120, 120, 120}}
};

static uint8 avvmid_set1[16][5][2] = {
	{{1, 154}, {0, 168}, {0, 168}, {0, 168}, {0, 168}},  /* pdet_id = 0 */
	{{1, 145}, {1, 145}, {1, 145}, {1, 145}, {1, 145}},  /* pdet_id = 1 WLBGA */
	{{6,  76}, {1, 160}, {6,  76}, {6,  76}, {6,  76}},  /* pdet_id = 2 */
	{{1, 156}, {1, 152}, {1, 152}, {1, 152}, {1, 152}},  /* pdet_id = 3 */
	{{1, 152}, {1, 152}, {1, 152}, {1, 152}, {1, 152}},  /* pdet_id = 4 WLCSP */
	{{3, 100}, {3,  75}, {3,  75}, {3,  75}, {3,  75}},  /* pdet_id = 5 WLCSP TM */
	{{1, 152}, {0, 166}, {0, 166}, {0, 166}, {0, 166}},  /* pdet_id = 6 WLCSP HK */
	{{1, 145}, {3, 120}, {3, 120}, {3, 120}, {3, 125}},  /* pdet_id = 7 WLiPA */
	{{1, 145}, {1, 155}, {1, 155}, {1, 155}, {1, 155}},  /* pdet_id = 8 WLBGA C0 */
	{{1, 135}, {1, 165}, {1, 165}, {1, 165}, {1, 165}}   /* pdet_id = 9 WLBGA RR FEM */
};
static uint8 avvmid_set2[16][5][4] = {
	{
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145}},  /* pdet_id = 0 */
	{
		{3, 3, 100, 100},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145}},  /* pdet_id = 1 */
	{
		{4, 4,  95,  95},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145}},  /* pdet_id = 2 */
	{
		{1, 1, 145, 145},
		{3, 3,  90,  90},
		{3, 3,  92,  92},
		{2, 3, 110,  90},
		{2, 3, 110,  93}},  /* pdet_id = 3 */
	{
		{2, 2, 140, 140},
		{2, 2, 145, 145},
		{2, 2, 145, 145},
		{2, 2, 145, 145},
		{2, 2, 145, 145}},  /* pdet_id = 4 */
	{
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{1, 1, 145, 145},
		{2, 2, 110, 110}},  /* pdet_id = 5 */
	{
		{3, 3, 98, 98},
		{2, 1, 122, 150},
		{2, 1, 122, 150},
		{2, 2, 122, 122},
		{2, 2, 122, 122}}  /* pdet_id = 6 */
};
static uint8 avvmid_set3[16][5][2] = {
	{{1, 115}, {2, 90}, {2, 90}, {2, 90}, {2, 90}},  /* pdet_id = 0 4345 TC */
	{{0, 131}, {0, 134}, {0, 134}, {0, 134}, {0, 134}},  /* pdet_id = 1 4345TC FCBGA EPA */
	{{4, 132}, {4, 127}, {4, 127}, {4, 127}, {4, 127}},  /* pdet_id = 2 4345A0 fcbusol */
	{{0, 150}, {2, 97}, {2, 97}, {2, 97}, {2, 97}},  /* pdet_id = 3 4345A0 fcpagb ipa */
};

static uint8 avvmid_set_from_nvram[3][5][2];

/* Coefficients generated by 47xxtcl/rgphy/20691/ */
/* lpf_tx_coefficient_generator/filter_tx_tiny_generate_python_and_tcl.py */
static uint16 lpf_g10[7][15] = {
	{1188, 1527, 1866, 2206, 2545, 2545, 1188, 1188,
	1188, 1188, 1188, 1188, 1188, 1188, 1188},
	{3300, 4242, 5185, 6128, 7071, 7071, 3300, 3300,
	3300, 3300, 3300, 3300, 3300, 3300, 3300},
	{16059, 16059, 16059, 17294, 18529, 18529, 9882,
	1976, 2470, 3088, 3953, 4941, 6176, 7906, 12353},
	{24088, 24088, 25941, 31500, 37059, 37059, 14823,
	2964, 3705, 4632, 5929, 7411, 9264, 11859, 18529},
	{29647, 32118, 34589, 42001, 49412, 49412, 19765,
	3705, 4941, 6176, 7411, 9882, 12353, 14823, 24706},
	{32941, 36236, 39530, 42824, 46118, 49412, 19765,
	4117, 4941, 6588, 8235, 9882, 13176, 16470, 26353},
	{10706, 10706, 10706, 11529, 12353, 12353, 6588,
	1317, 1647, 2058, 2635, 3294, 4117, 5270, 8235}
};
static uint16 lpf_g12[7][15] = {
	{1882, 1922, 1866, 1752, 1606, 1275, 2984, 14956,
	11880, 9436, 7495, 5954, 4729, 3756, 2370},
	{5230, 5341, 5185, 4868, 4461, 3544, 8289, 41544,
	33000, 26212, 20821, 16539, 13137, 10435, 6584},
	{24872, 19757, 15693, 13424, 11425, 9075, 24258, 24316,
	24144, 23972, 24374, 24201, 24029, 24432, 24086},
	{37309, 29635, 25351, 24452, 22850, 18151, 36388, 36474,
	36216, 35959, 36561, 36302, 36044, 36648, 36130},
	{44360, 38172, 32654, 31496, 29433, 23379, 46870, 44045,
	46648, 46318, 44150, 46759, 46428, 44254, 46538},
	{49288, 43066, 37319, 32113, 27471, 23379, 46870, 48939,
	46648, 49406, 49055, 46759, 49523, 49172, 49640},
	{16581, 13171, 10462, 8949, 7616, 6050, 16172, 16210,
	16096, 15981, 16249, 16134, 16019, 16288, 16057}
};
static uint16 lpf_g21[7][15] = {
	{1529, 1497, 1542, 1643, 1793, 2257, 965, 192, 242,
	305, 384, 483, 609, 766, 1215},
	{4249, 4160, 4285, 4565, 4981, 6270, 2681, 534, 673,
	847, 1067, 1343, 1691, 2129, 3375},
	{6135, 7723, 9723, 11367, 13356, 16814, 6290, 6275,
	6320, 6365, 6260, 6305, 6350, 6245, 6335},
	{9202, 11585, 13543, 14041, 15025, 18916, 9435, 9413,
	9480, 9548, 9391, 9458, 9525, 9368, 9503},
	{13760, 15990, 18693, 19380, 20738, 26108, 13023, 13858,
	13085, 13178, 13825, 13054, 13147, 13793, 13116},
	{22016, 25197, 29078, 33791, 39502, 46415, 23152, 22173,
	23262, 21964, 22121, 23207, 21912, 22068, 21860},
	{4090, 5149, 6482, 7578, 8904, 11209, 4193, 4183, 4213,
	4243, 4173, 4203, 4233, 4163, 4223}
};
static uint16 lpf_g11[7] = {994, 2763, 12353, 18529, 17470, 23293, 8235};
static uint16 g_passive_rc_tx[7] = {62, 172, 772, 1158, 1544, 2058, 514};
static uint16 biases[7] = {24, 48, 96, 96, 128, 128, 96};
static int8 g_index1[15] = {0, 1, 2, 3, 4, 5, -2, -9, -8, -7, -6, -5, -4, -3, -1};

static const uint8 BCMATTACHDATA(fectrl_fem5516_fc1)[] =
{0, 0, 4, 0, 0, 0, 4, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
 4, 0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0, 0};

/* FEMCTRL LUT for SKY 85806 on 4360 */
static const uint8 BCMATTACHDATA(fectrl_fem85806)[] =
{6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7};

/**
 * 43602 FEM table (fem subtype = 1) for core 0 (256 entries).
 */
static const uint8 BCMATTACHDATA(fectrl_fem85806_c0)[] =
{
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7
};
/**
 * 43602 FEM table (fem subtype = 1) for core 1 (64 entries).
 */
static const uint8 BCMATTACHDATA(fectrl_fem85806_c1)[] =
{
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7,
	 6, 6, 4, 6, 6, 6, 4, 6, 6, 7, 6, 7, 6, 7, 6, 7
};

/**
 * 43602 FEM table (fem subtype = 3,4) for core 0 (256 entries).
 * Used for e.g. 43602bu (3 ant no BT), 43602cd (X238, 3 Wifi + 1BT antenna) and 43602cs (X87, 3
 * antenna with shared BT) boards.
 */
static const uint8 BCMATTACHDATA(fectrl_fem5517_c0)[] =
{
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6, /* */
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6,
	 6,  6,  4,  6,  6,  6,  6,  6,  6,  7,  6,  6,  6,  6,  6,  6
};

/**
 * 43602 FEM table (fem subtype = 3,4) for core 1 (64 entries).
 * Used for 43602bu, 43602cd (X238, 4 antenna) and 43602cs (X87, 3 antenna) boards.
 */
static const uint8 BCMATTACHDATA(fectrl_fem5517_c1)[] =
{
	 2,  2,  0,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  2,  2, /* */
	66, 66, 64, 66, 66, 66, 66, 66, 66, 67, 66, 66, 66, 66, 66, 66,
	 2,  2,  0,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  2,  2,
	66, 66, 64, 66, 66, 66, 66, 66, 66, 67, 66, 66, 66, 66, 66, 66
};

/**
 * 43602 FEM table (fem subtype = 3,4) for core 2 (64 entries).
 * Used for 43602bu, 43602cd (X238, 4 antenna) and 43602cs (X87, 3 antenna) boards.
 * On the 43602, for core 2, bit3 in a table element steers the BAND_SEL pin (0=2.4G, 1=5G).
 */
static const uint8 BCMATTACHDATA(fectrl_fem5517_c2)[] =
{
	 2,  2,  0,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  2,  2, /* 2.4G */
	10, 10,  8, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 10, /*   5G */
	 2,  2,  4,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  2,  2, /* 2.4G */
	10, 10,  8, 10, 10, 10, 10, 10, 10, 11, 10, 10, 10, 10, 10, 10  /*   5G */
};

/* 43602 FEM table for MC2 and MC5 (fem type = 6, subtype 0) for cores 0 (256 entries) */
/* and core 1,2 (first 64 entries) */
/* RFMD FEM part may be marked 4501, but inside is 4591 */
static const uint8 BCMATTACHDATA(fectrl_rfmd4591)[] =
{0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0};

static const uint8 BCMATTACHDATA(fectrl_x29c_c1_fc2_sub0)[] =
{0, 0, 0x50, 0x10, 0, 0, 0x50, 0x10, 0, 0x80, 0,
 0, 0, 0, 0, 0, 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0};

static const uint8 BCMATTACHDATA(fectrl_x29c_c1_fc2_sub1)[] =
{0, 0, 0x30, 0x20, 0, 0, 0x30, 0x20, 0, 0x80, 0,
 0, 0, 0, 0, 0, 0x40, 0x40, 0x46, 0x42, 0x40, 0x40, 0x46, 0x42, 0x40, 0x41, 0x40,
 0x40, 0x40, 0x40, 0x40, 0x40};
static const uint8 BCMATTACHDATA(fectrl_femctrl2_sub2_c0)[] =
{6, 6, 4, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 4,
 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6};
static const uint8 BCMATTACHDATA(fectrl_femctrl2_sub2_c12)[] =
{2, 2, 0, 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 2, 2, 0,
 2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2};

static const uint8 BCMATTACHDATA(fectrl_mch5_c0_p200_p400_fc3_sub0)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x02, 0x2c, 0x03, 0x2d, 0x02, 0x2c, 0x03, 0x2d};
static const uint8 BCMATTACHDATA(fectrl_mch5_c1_p200_p400_fc3_sub0)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 9, 6, 14, 2, 9, 6, 14, 0x02, 0x29, 0x06, 0x2d, 0x02, 0x29, 0x06, 0x2d};
static const uint8 BCMATTACHDATA(fectrl_mch5_c2_p200_p400_fc3_sub0)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 4, 9, 6, 14, 4, 9, 6, 14, 0x04, 0x29, 0x06, 0x2b, 0x04, 0x29, 0x06, 0x2b};

static const uint8 BCMATTACHDATA(fectrl_mch5_c0_fc3_sub1)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 8, 4, 3, 8, 8, 4, 3, 8, 0x08, 0x24, 0x03, 0x25, 0x08, 0x24, 0x03, 0x25};
static const uint8 BCMATTACHDATA(fectrl_mch5_c1_fc3_sub1)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 8, 1, 6, 8, 8, 1, 6, 8, 0x08, 0x21, 0x06, 0x25, 0x08, 0x21, 0x06, 0x25};
static const uint8 BCMATTACHDATA(fectrl_mch5_c2_fc3_sub1)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 8, 1, 6, 8, 8, 1, 6, 8, 0x08, 0x21, 0x06, 0x23, 0x08, 0x21, 0x06, 0x23};

static const uint8 BCMATTACHDATA(fectrl_j28_fc3_sub2)[] =
{2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23,
 0x25, 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25};

static const uint8 BCMATTACHDATA(fectrl3_sub3_c0)[] =
{2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23,
 0x25, 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25};
static const uint8 BCMATTACHDATA(fectrl3_sub3_c1)[] =
{2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26,
 0x25, 2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26, 0x25};
static const uint8 BCMATTACHDATA(fectrl3_sub3_c2)[] =
{4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26,
 0x23, 4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26, 0x23};

static const uint8 BCMATTACHDATA(fectrl_43602_mch5_c0)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 12, 3, 11, 2, 12, 3, 11, 0x2, 0x2c, 0x3, 0x2d, 0x2, 0x2c, 0x3, 0x2d};
static const uint8 BCMATTACHDATA(fectrl_43602_mch5_c1)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 9, 6, 14, 2, 9, 6, 14, 0x2, 0x29, 0x6, 0x2d, 0x2, 0x29, 0x6, 0x2d,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 2, 9, 6, 14, 2, 9, 6, 14, 0x2, 0x29, 0x6, 0x2d, 0x2, 0x29, 0x6, 0x2d};
static const uint8 BCMATTACHDATA(fectrl_43602_mch5_c2)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 4, 9, 6, 14, 4, 9, 6, 14, 0x4, 0x29, 0x6, 0x2b, 0x4, 0x29, 0x6, 0x2b,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 4, 9, 6, 14, 4, 9, 6, 14, 0x4, 0x29, 0x6, 0x2b, 0x4, 0x29, 0x6, 0x2b};

/* 43602 MCH2, PAVREF enabled PAs */
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_c0)[] =
{2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25,
 2, 4, 3, 2, 2, 4, 3, 2, 0x22, 0x24, 0x23, 0x25, 0x22, 0x24, 0x23, 0x25};
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_c1)[] =
{2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26, 0x25,
 2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26, 0x25,
 2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26, 0x25,
 2, 1, 6, 2, 2, 1, 6, 2, 0x22, 0x21, 0x26, 0x25, 0x22, 0x21, 0x26, 0x25};
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_c2)[] =
{4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26, 0x23,
 4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26, 0x23,
 4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26, 0x23,
 4, 1, 6, 4, 4, 1, 6, 4, 0x24, 0x21, 0x26, 0x23, 0x24, 0x21, 0x26, 0x23};

/* 43602 MCH2, digitally enabled PAs */
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_1_c0)[] =
{2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13,
 2, 4, 3, 2, 2, 4, 3, 2, 10, 12, 11, 13, 10, 12, 11, 13};
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_1_c1)[] =
{2, 1, 6, 2, 2, 1, 6, 2, 10, 9, 14, 13, 10, 9, 14, 13,
 2, 1, 6, 2, 2, 1, 6, 2, 10, 9, 14, 13, 10, 9, 14, 13,
 2, 1, 6, 2, 2, 1, 6, 2, 10, 9, 14, 13, 10, 9, 14, 13,
 2, 1, 6, 2, 2, 1, 6, 2, 10, 9, 14, 13, 10, 9, 14, 13};
static const uint8 BCMATTACHDATA(fectrl_43602_mch2_1_c2)[] =
{4, 1, 6, 4, 4, 1, 6, 4, 12, 9, 14, 11, 12, 9, 14, 11,
 4, 1, 6, 4, 4, 1, 6, 4, 12, 9, 14, 11, 12, 9, 14, 11,
 4, 1, 6, 4, 4, 1, 6, 4, 12, 9, 14, 11, 12, 9, 14, 11,
 4, 1, 6, 4, 4, 1, 6, 4, 12, 9, 14, 11, 12, 9, 14, 11};
static const uint8 BCMATTACHDATA(fectrl3_sub6_43602)[] =
{2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2,
 2, 2, 1, 2, 2, 2, 2, 2, 42, 44, 2, 2, 2, 2, 2, 2};
static const uint8 BCMATTACHDATA(fectrl1_sub1_43602)[] =
{0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0,
 0, 0, 2, 6, 0, 0, 2, 6, 0, 5, 0, 0, 0, 0, 0, 0};
static const uint8 BCMATTACHDATA(fectrl1_sub2_43602)[] =
{0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 2, 6, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0};
static const uint8 BCMATTACHDATA(fectrl_femctrl5_c1)[] =
{0, 0, 0x50, 0x40, 0, 0, 0x50, 0x40, 0, 0x20, 0, 0, 0, 0, 0,
 0, 0x80, 0x80, 0x86, 0x82, 0x80, 0x80, 0x86, 0x82, 0x80, 0x81, 0x80, 0x80, 0x80,
 0x80, 0x80, 0x80};
static const uint8 BCMATTACHDATA(fectrl_zeros)[] =
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static const uint8 BCMATTACHDATA(fectrl_femctrl6)[] =
{0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0,
 0, 0, 6, 2, 0, 0, 6, 2, 0, 1, 0, 0, 0, 0, 0, 0};
static const sparse_array_entry_t BCMATTACHDATA(fectrl_fcbga_epa_elna_fc4_sub0)[] =
{{2, 264}, {3, 8}, {9, 32}, {18, 5}, {19, 4}, {25, 128}, {130, 64}, {192, 64}};

static const sparse_array_entry_t BCMATTACHDATA(fectrl_wlbga_epa_elna_fc4_sub1)[] =
{{2, 3}, {3, 1}, {9, 256}, {18, 20}, {19, 16}, {25, 8}, {66, 3}, {67, 1},
 {73, 256}, {82, 20}, {83, 16}, {89, 8}, {128, 3}, {129, 1}, {130, 3}, {131, 1},
 {132, 1}, {133, 1}, {134, 1}, {135, 1}, {136, 3}, {137, 1}, {138, 3}, {139, 1},
 {140, 1}, {141, 1}, {142, 1}, {143, 1}, {160, 3}, {161, 1}, {162, 3}, {163, 1},
 {164, 1}, {165, 1}, {166, 1}, {167, 1}, {168, 3}, {169, 1}, {170, 3}, {171, 1},
 {172, 1}, {173, 1}, {174, 1}, {175, 1}, {192, 128}, {193, 128}, {196, 128}, {197, 128},
 {200, 128}, {201, 128}, {204, 128}, {205, 128}, {224, 128}, {225, 128}, {228, 128},
 {229, 128}, {232, 128}, {233, 128}, {236, 128}, {237, 128} };

static const sparse_array_entry_t BCMATTACHDATA(fectrl_fchm_epa_elna_fc4_sub2)[] =
{{2, 280}, {3, 24}, {9, 48}, {18, 21}, {19, 20}, {25, 144}, {34, 776}, {35, 520},
 {41, 544}, {50, 517}, {51, 516}, {57, 640}, {66, 280}, {67, 24}, {73, 48}, {82, 21},
 {83, 20}, {89, 144}, {98, 776}, {99, 520}, {105, 544}, {114, 517}, {115, 516}, {121, 640},
 {128, 280}, {129, 24}, {130, 280}, {131, 24}, {132, 24}, {133, 24}, {134, 24}, {135, 24},
 {136, 280}, {137, 24}, {138, 280}, {139, 24}, {140, 24}, {141, 24}, {142, 24}, {143, 24},
 {160, 776}, {161, 520}, {162, 776}, {163, 520}, {164, 520}, {165, 520}, {166, 520},
 {167, 520}, {168, 776}, {169, 520}, {170, 776}, {171, 520}, {172, 520}, {173, 520},
 {174, 520}, {175, 520},	{192, 16}, {193, 16}, {196, 16}, {197, 16}, {200, 16}, {201, 16},
 {204, 16}, {205, 16}, {224, 512}, {225, 512}, {228, 512}, {229, 512}, {232, 512},
 {233, 512}, {236, 512}, {237, 512}};

static const sparse_array_entry_t BCMATTACHDATA(fectrl_wlcsp_epa_elna_fc4_sub34)[] =
{{2, 34}, {3, 2}, {9, 17}, {18, 80}, {19, 16}, {25, 8}, {66, 34}, {67, 2},
 {73, 1}, {82, 80}, {83, 16}, {89, 8}, {128, 34}, {129, 2}, {130, 34}, {131, 2},
 {132, 2}, {133, 2}, {134, 2}, {135, 2}, {136, 34}, {137, 2}, {138, 34}, {139, 2},
 {140, 2}, {141, 2}, {142, 2}, {143, 2}, {160, 34}, {161, 2}, {162, 34}, {163, 2},
 {164, 2}, {165, 2}, {166, 2}, {167, 2}, {168, 34}, {169, 2}, {170, 34}, {171, 2},
 {172, 2}, {173, 2}, {174, 2}, {175, 2}, {192, 4}, {193, 4}, {196, 4}, {197, 4},
 {200, 4}, {201, 4}, {204, 4}, {205, 4}, {224, 4}, {225, 4}, {228, 4}, {229, 4},
 {232, 4}, {233, 4}, {236, 4}, {237, 4} };

static const sparse_array_entry_t BCMATTACHDATA(fectrl_fp_dpdt_epa_elna_fc4_sub5)[] =
{{2, 280}, {3, 24}, {9, 48}, {18, 21}, {19, 20}, {25, 144}, {34, 776},
 {35, 520}, {41, 544}, {50, 517}, {51, 516}, {57, 640}, {130, 80},
 {192, 80}};

static const sparse_array_entry_t BCMATTACHDATA(fectrl_43162_fcbga_ipa_ilna_fc4_sub6)[] =
{{2, 10}, {3, 2}, {9, 2}, {18, 4}, {19, 12}, {25, 12}, {34, 1}, {35, 8},
 {41, 8}, {50, 6}, {51, 14}, {57, 14}, {66, 10}, {67, 2}, {73, 2},
 {82, 4}, {83, 12}, {89, 12}, {98, 9}, {99, 3}, {105, 3}, {114, 6},
 {115, 14}, {121, 14}, {128, 11}, {129, 11}, {130, 11}, {131, 11},
 {132, 11}, {133, 11}, {134, 11}, {135, 11}, {136, 11}, {137, 11},
 {138, 11}, {139, 11}, {140, 11}, {141, 11}, {142, 11}, {143, 11},
 {146, 5}, {147, 13}, {153, 13}, {178, 7}, {179, 15}, {185, 15}, {192, 9},
 {193, 9}, {196, 9}, {197, 9}, {200, 3}, {201, 3}, {204, 3}, {205, 3},
 {210, 4}, {211, 12}, {217, 12}, {242, 6}, {243, 14}, {249, 14}};

static const sparse_array_entry_t BCMATTACHDATA(fectrl_43162_fcbga_ipa_elna_fc4_sub7)[] =
{{2, 26}, {3, 10}, {9, 2}, {18, 36}, {19, 4}, {25, 12}, {34, 17}, {35, 1},
 {41, 8}, {50, 38}, {51, 6}, {57, 14}, {66, 26}, {67, 10}, {73, 2},
 {82, 36}, {83, 4}, {89, 12}, {98, 25}, {99, 9}, {105, 3}, {114, 38},
 {115, 6}, {121, 14}, {128, 27}, {129, 27}, {130, 27}, {131, 27},
 {132, 27}, {133, 27}, {134, 27}, {135, 27}, {136, 11}, {137, 11},
 {138, 11}, {139, 11}, {140, 11}, {141, 11}, {142, 11}, {143, 11},
 {146, 37}, {147, 5}, {153, 13}, {178, 39}, {179, 7}, {185, 15}, {192, 25},
 {193, 25}, {196, 25}, {197, 25}, {200, 3}, {201, 3}, {204, 3}, {205, 3},
 {210, 36}, {211, 4}, {217, 12}, {242, 38}, {243, 6}, {249, 14}};

static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_WLBGA_add_fc7)[] =
{18, 50, 80, 112, 129, 130, 131, 134, 135, 137,
 145, 146, 147, 150, 151, 153, 161, 162, 163, 166, 167, 169, 177, 178, 179, 182,
 183, 185};
static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_WLBGA_fc7)[] =
{66, 34, 68, 36, 72, 64, 72, 64, 72,
 72, 65, 66, 65,
 66, 65, 65, 40,
 32, 40, 32, 40,
 40, 33, 34, 33,
 34, 33, 33};
static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_WLBGA_iPa_add_fc7)[] =
{2, 3, 9, 18, 19, 25, 34, 35, 41, 50, 51, 57};
static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_WLBGA_iPa_fc7)[] =
{66, 65, 65, 80, 72, 72, 34, 33, 33, 48, 40, 40};

static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_FCBGA_add_fc8)[] =
{161, 162, 163, 166, 167, 169, 177, 178, 179,
 182, 183, 185};
static const uint16 BCMATTACHDATA(fectrl_femctrl_4335_FCBGA_fc8)[] =
{9, 12, 9, 12, 9, 9, 65, 9, 65, 9, 65, 65};

static const uint16 BCMATTACHDATA(fectrl_fcbgabu_epa_elna_idx_fc9)[] =
{2, 3, 9, 18, 19, 25, 130, 192};
static const uint16 BCMATTACHDATA(fectrl_fcbgabu_epa_elna_val_fc9)[] =
{128, 0, 4, 64, 0, 3, 8, 8};

static const uint16 BCMATTACHDATA(fectrl_fcbga_epa_elna_idx_fc10_sub0)[] =
{  2,   3,   9,  18,  19,  25,  66,  67,  73,  82,  83, 128, 129, 130, 131, 132, 133,
 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164, 165, 166,
 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 196, 197, 200, 201, 204, 205,
 210, 211, 224, 225, 228, 229, 232, 233, 236, 237, 258, 259, 265, 274, 275, 281};
static const uint16 BCMATTACHDATA(fectrl_fcbga_epa_elna_val_fc10_sub0)[] =
{ 96,  32,   8,   6,   2,   1,  96,  32,   8,   6,   2,  96,  32,  96,  32,  32,  32,
  32,  32,  96,  32,  96,  32,  32,  32,  32,  32,  96,  32,  96,  32,  32,  32,  32,
  32,  96,  32,  96,  32,  32,  32,  32,  32, 128, 128, 128, 128, 128, 128, 128, 128,
 134, 130, 128, 128, 128, 128, 128, 128, 128, 128,   5,   4,   8,  48,  32,  64};

static const uint16 BCMATTACHDATA(fectrl_wlbga_epa_elna_idx_fc10_sub1)[] =
{2, 3, 9, 18, 19, 25, 66, 67, 73, 82, 83,
 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
 192, 193, 196, 197, 200, 201, 204, 205, 210, 211, 258, 259, 265, 274, 275, 281};
static const uint16 BCMATTACHDATA(fectrl_wlbga_epa_elna_val_fc10_sub1)[] =
{48, 32, 8, 6, 2, 1, 48, 32, 8, 6, 2,
 48, 32, 48, 32, 32, 32, 32, 32, 48, 32, 48, 32, 32, 32, 32, 32,
 48, 32, 48, 32, 32, 32, 32, 32, 48, 32, 48, 32, 32, 32, 32, 32,
 128, 128, 128, 128, 128, 128, 128, 128, 134, 130, 48, 32, 8, 6, 2, 1};

static const uint16 BCMATTACHDATA(fectrl_wlbga_ipa_ilna_idx_fc10_sub2)[] =
{2, 3, 9, 18, 19, 25, 66, 67, 73, 82, 83, 128, 130, 132, 134, 192, 210, 211, 258, 259, 265, 274,
 275, 281};
static const uint16 BCMATTACHDATA(fectrl_wlbga_ipa_ilna_val_fc10_sub2)[] =
{16, 64, 64, 1, 2, 2, 16, 64, 64, 1, 2, 16, 16, 16, 16, 32, 33, 34, 64, 16, 16, 1, 2, 2};
static const uint16 BCMATTACHDATA(fectrl_43556usb_epa_elna_idx_fc10_sub3)[] =
{2, 3, 9, 18, 19, 25, 66, 67, 73, 82, 83, 128,
 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 192,
 193, 196, 197, 200, 201, 204, 205, 210, 211, 258, 259, 265, 274, 275, 281};
static const uint16 BCMATTACHDATA(fectrl_43556usb_epa_elna_val_fc10_sub3)[] =
{96, 32, 8, 6, 2, 1, 96, 32, 8, 6, 2, 96, 32, 96,
 32, 32, 32, 32, 32, 96, 32, 96, 32, 32, 32, 32, 32, 128, 128, 128, 128, 128, 128,
 128, 128, 134, 130, 5, 4, 8, 48, 32, 64};
static const uint16 BCMATTACHDATA(fectrl_fcbga_ipa_ilna_idx_fc10_sub4)[] =
{2, 3, 9, 18, 19, 25, 66, 67, 73, 82, 83, 128, 129,
 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 192, 193,
 196, 197, 200, 201, 204, 205, 210, 211, 258, 259, 265, 265, 274, 275, 281, 281};
static const uint16 BCMATTACHDATA(fectrl_fcbga_ipa_ilna_val_fc10_sub4)[] =
{128, 32, 32, 8, 1, 1, 128, 32, 32, 8, 8, 128, 32,
 128, 32, 128, 32, 128, 32, 128, 32, 128, 32, 128, 32, 128, 32, 64, 64, 64, 64,
 64, 64, 64, 64, 72, 72, 4, 8, 8, 8, 64, 16, 16, 16};

static const uint16 BCMATTACHDATA(fectrl_idx_fc10_sub5)[] =
{   2,   3,   9,  18,  19,  25,  34,  35,  41,  50,  51,  57,  66,  67,  73,
   82,  83,  89,  98,  99, 105, 114, 115, 121, 128, 129, 130, 131, 132, 133,
  134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 160, 161, 162, 163, 164,
  165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 192, 193, 194, 195,
  196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 224, 225, 226,
  227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 258, 259,
  265, 274, 275, 281, 290, 291, 297, 306, 307, 313};

static const uint16 BCMATTACHDATA(fectrl_val_fc10_sub5)[] =
{  32,  40,  24,   2,   3,   5,  32,  40,  24,   2,   3,   5,  32,  40,  24,
    2,   3,   5,  32,  40,  24,   2,   3,   5,  32,  32,  32,  32,  40,  40,
   40,  40,  32,  32,  32,  32,  40,  40,  40,  40,  32,  32,  32,  32,  40,
   40,  40,  40,  32,  32,  32,  32,  40,  40,  40,  40,  56,  56,  32,  32,
   56,  56,  40,  40,  56,  56,  32,  32,  56,  56,  40,  40,  56,  56,  32,
   32,  56,  56,  40,  40,  56,  56,  32,  32,  56,  56,  40,  40,   8,  40,
   48, 128, 192,  68,   8,  40,  48, 128, 192,  68};

static const uint16 BCMATTACHDATA(fectrl_fcbu_epa_idx_fc11)[] =
{2, 3, 9, 18, 19, 25, 130, 192,
 258, 259, 265, 274, 275, 281, 386, 448,
 514, 515, 521, 530, 531, 537, 642, 704};
static const uint16 BCMATTACHDATA(fectrl_fcbu_epa_val_fc11)[] =
{10, 10, 4, 96, 96, 16, 0, 0,
 10, 10, 4, 96, 96, 16, 0, 0,
 10, 10, 4, 96, 96, 16, 0, 0};

static const acphy_hwaci_state_t BCMATTACHDATA(hwaci_states_2g_4350)[] =
{{2500, 4, 4, 0, 0, 0, 0, 2500, 0},
 {5000, 4, 3, 0, 0, 0, 0, 5000, 0},
 {8000, 3, 3, 0, 0, 0, 0, 8000, 0}};

static const acphy_hwaci_state_t BCMATTACHDATA(hwaci_states_5g_4350)[] =
{{2500, 4, 4, 4, 0, 0, 0, 2500, 0},
 {5000, 4, 3, 4, 0, 0, 0, 5000, 0},
 {8000, 3, 3, 4, 0, 0, 0, 8000, 0}};

#ifdef WL_PROXDETECT
#define TOF_INITIATOR_K_4345_80M	34434 /* initiator K value for 80M */
#define TOF_TARGET_K_4345_80M		34474 /* target K value for 80M */
#define TOF_INITIATOR_K_4345_40M	35214 /* initiator K value for 40M */
#define TOF_TARGET_K_4345_40M		35214 /* target K value for 40M */
#define TOF_INITIATOR_K_4345_20M	36553 /* initiator K value for 20M */
#define TOF_TARGET_K_4345_20M		36553 /* target K value for 20M */
#define TOF_INITIATOR_K_4345_2G		37169 /* initiator K value for 2G */
#define TOF_TARGET_K_4345_2G		37169 /* target K value for 2G */

static const uint16 proxd_4345_80m_k_values[] =
{0x0, 0xee12, 0xe201, 0xe4fc, 0xe6f8, 0xe6f7 /* 42, 58, 106, 122, 138, 155 */};

static const uint16 proxd_4345_40m_k_values[] =
{0x7b7b, 0x757c, 0x7378, 0x7074, 0x9a9a, 0x9898, /* 38, 46, 54, 62, 102,110 */
0x9898, 0x9898, 0x9393, 0x9494, 0x9191, 0x8484 /* 118, 126, 134, 142,151,159 */};

static const uint16 proxd_4345_20m_k_values[] =
{0x0f0f, 0x0101, 0x0101, 0x1313, 0x0f0f, 0x0101, 0x0f0f, 0x0505, /* 36 -64 */
0xe9e9, 0xe8e8, 0xe6e6, 0xe4e4, 0xcbcb, 0xcbcb, 0xcbcb, 0xcbcb, /* 100 -128 */
0xcbcb, 0xd5d5, 0xdada, 0xcbcb, /* 132 -144 */
0xcbcb, 0xbfbf, 0xd5d5, 0xbfbf, 0xcbcb /* 149 - 165 */
};

static const uint16 proxd_4345_2g_k_values[] =
{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, /* 1 -7 */
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 /* 8 -14 */
};

#define TOF_INITIATOR_K_4350_80M	36546 /* initiator K value for 80M */
#define TOF_TARGET_K_4350_80M		36569 /* target K value for 80M */
#define TOF_INITIATOR_K_4350_40M	35713 /* initiator K value for 40M */
#define TOF_TARGET_K_4350_40M		35713 /* target K value for 40M */
#define TOF_INITIATOR_K_4350_20M	37733 /* initiator K value for 20M */
#define TOF_TARGET_K_4350_20M		37733 /* target K value for 20M */
#define TOF_INITIATOR_K_4350_2G		37733 /* initiator K value for 2G */
#define TOF_TARGET_K_4350_2G		37733 /* target K value for 2G */

static const uint16 proxd_4350_80m_k_values[] =
{0x0, 0xef02, 0xf404, 0xf704, 0xfc04, 0xf3f9 /* 42, 58, 106, 122, 138, 155 */};

static const uint16 proxd_4350_40m_k_values[] =
{0x0, 0xfdfd, 0xf6f6, 0x1414, 0xebeb, 0xebeb, /* 38, 46, 54, 62, 102,110 */
0xeeee, 0xeeee, 0xe2e2, 0xe5e5, 0xfdfa, 0xe5e5 /* 118, 126, 134, 142,151,159 */};

static const uint16 proxd_4350_20m_k_values[] =
{0x0, 0xfdfd, 0xfdfd, 0xf8f8, 0xf8f8, 0xf5f5, 0xf5f5, 0xf5f5, /* 36 -64 */
0xe9e9, 0xe6e6, 0xe3e3, 0xe3e3, 0xe6e6, 0xe6e6, 0xe6e6, 0xe6e6, /* 100 - 128 */
0xe6e6, 0xe6e6, 0xd6d6, 0xe9e9, /* 132 -144 */
0xe9e9, 0x0808, 0xd4d4, 0xd4d4, 0xd4d4 /* 149 - 165 */
};

static const uint16 proxd_4350_2g_k_values[] =
{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, /* 1 -7 */
0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 /* 8 -14 */
};

#define TOF_INITIATOR_K_4354_80M	36553 /* initiator K value for 80M */
#define TOF_TARGET_K_4354_80M		36559 /* target K value for 80M */
#define TOF_INITIATOR_K_4354_40M	35699 /* initiator K value for 40M */
#define TOF_TARGET_K_4354_40M		35713 /* target K value for 40M */
#define TOF_INITIATOR_K_4354_20M	37723 /* initiator K value for 20M */
#define TOF_TARGET_K_4354_20M		37728 /* target K value for 20M */
#define TOF_INITIATOR_K_4354_2G		37816 /* initiator K value for 2G */
#define TOF_TARGET_K_4354_2G		37816 /* target K value for 2G */

static const uint16 proxd_4354_80m_k_values[] =
{0, 0xF0F3, 0xFCFE, 0, 0xFEFE, 0xF0F4 /* 42, 58, 106, 122, 138, 155 */};

static const uint16 proxd_4354_40m_k_values[] =
{0, 0xFC04, 0xFA00, 0x0d1D, 0xF1FB, 0xF0FB, /* 38, 46, 54, 62, 102 */
0, 0, 0xE9F5, 0xE5F4, 0xFE0B, 0xE0EF /* 110, 118, 126, 134, 142,151,159 */};

static const uint16 proxd_4354_20m_k_values[] =
{0, 0xFFFE, 0xFAFB, 0xFBFA, 0xF9F8, 0xFAF7, 0xF4F4, 0xFDEC, /* 36 -64 */
0xEEE1, 0xE3E3, 0xE2E0, 0xE2E2, 0, 0, 0, 0, 0xD9DB, 0xDEDD, 0xD7D7, 0xD9D6, /* 100 -144 */
0x0BFD, 0x0209, 0xD6D1, 0xE1C6, 0xE1C6 /* 149 - 165 */
};

static const uint16 proxd_4354_2g_k_values[] =
{0xbbbb, 0xf1f1, 0xebeb, 0xe5e5, 0xe6e6, 0xe6e6, 0xe3e3, /* 1 -7 */
0xe6e6, 0xe3e3, 0xe3e3, 0xe6e6, 0xb5b5, 0xf0f0, 0x0c0c /* 8 -14 */
};
#endif /* WL_PROXDETECT */

static const uint16 pktabort_timing_search = 0x0001;
static const uint16 pktabort_wait_nclks = 0x0040;

static rxgain_ovrd_t rxgainindx_cmd_ovrd[PHY_CORE_MAX];

/* defs for iqlo cal */
enum {  /* mode selection for reading/writing tx iqlo cal coefficients */
	TB_START_COEFFS_AB, TB_START_COEFFS_D, TB_START_COEFFS_E, TB_START_COEFFS_F,
	TB_BEST_COEFFS_AB,  TB_BEST_COEFFS_D,  TB_BEST_COEFFS_E,  TB_BEST_COEFFS_F,
	TB_OFDM_COEFFS_AB,  TB_OFDM_COEFFS_D,  TB_BPHY_COEFFS_AB,  TB_BPHY_COEFFS_D,
	PI_INTER_COEFFS_AB, PI_INTER_COEFFS_D, PI_INTER_COEFFS_E, PI_INTER_COEFFS_F,
	PI_FINAL_COEFFS_AB, PI_FINAL_COEFFS_D, PI_FINAL_COEFFS_E, PI_FINAL_COEFFS_F
};

#define ACPHY_IQCAL_TONEFREQ_80MHz 8000
#define ACPHY_IQCAL_TONEFREQ_40MHz 4000
#define ACPHY_IQCAL_TONEFREQ_20MHz 2000
#define ACPHY_RXCAL_MAX_NUM_FREQ 6

#define CAL_TYPE_IQ                 0
#define CAL_TYPE_LOFT_DIG           2
#define CAL_TYPE_LOFT_ANA_FINE      3
#define CAL_TYPE_LOFT_ANA_COARSE    4

#define CAL_COEFF_READ    0
#define CAL_COEFF_WRITE   1
#define CAL_COEFF_WRITE_BIQ2BYP   2
#define MPHASE_TXCAL_CMDS_PER_PHASE  2 /* number of tx iqlo cal commands per phase in mphase cal */

#define IQTBL_CACHE_COOKIE_OFFSET	95
#define TXCAL_CACHE_VALID		0xACDC

#define TXMAC_IFHOLDOFF_DEFAULT		0x12	/* 9.0us */
#define TXMAC_MACDELAY_DEFAULT		0x2a8	/* 8.5us */

#define TXMAC_IFHOLDOFF_DEFAULT_MAJREV1		0x10	/* 8.0us */
#define TXMAC_MACDELAY_DEFAULT_MAJREV1		0x258	/* 7.5us */

#define MAX_PAD_GAIN				0xFF
#define MAX_TX_IDX				127

#define PWRCTRL_SHORTW_AVG 1
#define PWRCTRL_LONGW_AVG 4
#define PWRCTRL_MIN_INIT_IDX 5
#define PWRCTRL_MAX_INIT_IDX 127

#define LPFCONF_TXIQ_RX2 0
#define LPFCONF_TXIQ_RX4 1
/* %%%%%% function declaration */
/* 2069 related Radio Functions */
void wlc_phy_switch_radio_acphy(phy_info_t *pi, bool on);
static void wlc_phy_radio2069_pwron_seq(phy_info_t *pi);
static void wlc_phy_radio2069_upd_prfd_values(phy_info_t *pi);
static void wlc_phy_radio2069_rcal(phy_info_t *pi);
static void wlc_phy_radio2069_rccal(phy_info_t *pi);
static void wlc_phy_chanspec_radio2069_setup(phy_info_t *pi, const void *chan_info,
                                           uint8 toggle_logen_reset);
static void wlc_phy_radio2069_vcocal(phy_info_t *pi);
static void wlc_phy_radio2069_4335C0_vco_opt(phy_info_t *pi, uint8 vco_mode);
static void wlc_phy_radio20691_4345_vco_opt(phy_info_t *pi, uint8 vco_mode);
static void wlc_phy_radio_vco_opt(phy_info_t *pi, uint8 vco_mode);
static void wlc_phy_radio2069_afecal(phy_info_t *pi);
static void wlc_phy_radio20691_afecal(phy_info_t *pi);
static void wlc_phy_radio2069_afecal_invert(phy_info_t *pi);
static void wlc_phy_radio2069_mini_pwron_seq_rev16(phy_info_t *pi);
static void wlc_phy_radio2069_mini_pwron_seq_rev32(phy_info_t *pi);
static void wlc_phy_set_lowpwr_phy_reg(phy_info_t *pi);
static void wlc_phy_set_lowpwr_phy_reg_rev3(phy_info_t *pi);
void wlc_phy_radio2069_pwrdwn_seq(phy_info_t *pi);
void wlc_phy_radio2069_pwrup_seq(phy_info_t *pi);
static void acphy_get_lpmode(phy_info_t *pi);
static void acphy_set_lpmode(phy_info_t *pi, acphy_lp_opt_levels_t lp_opt_lvl);

/* 20691  Radio Functions */
static void wlc_phy_radio20691_vcocal(phy_info_t *pi);
static void wlc_phy_radio20691_upd_prfd_values(phy_info_t *pi);
static void wlc_phy_radio20691_lpf_tx_set(phy_info_t *pi, int8 bq_bw, int8 bq_gain,
	int8 rc_bw_ofdm, int8 rc_bw_cck);
static int8 wlc_phy_radio20691_minipmu_cal(phy_info_t *pi);
static void wlc_phy_chanspec_radio20691_setup(phy_info_t *pi,
	const void *chan_info, uint8 toggle_logen_reset);
static void wlc_phy_switch_radio_acphy_20691(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_band_change_acphy_20691(phy_info_t *pi);
static void wlc_phy_set_reg_on_reset_acphy_20691(phy_info_t *pi);
static void wlc_phy_radio20691_pwron_seq(phy_info_t *pi);
static void wlc_phy_radio20691_rccal(phy_info_t *pi);
static void wlc_phy_radio20691_rcal(phy_info_t *pi, uint8 mode);
static void wlc_phy_afe_war_setup_acphy(phy_info_t *pi);

/* 20693 Radio functions */
static void wlc_phy_radio20693_vco_opt(phy_info_t *pi, uint8 vco_mode);
static void wlc_phy_radio20693_afecal(phy_info_t *pi);
static void wlc_phy_radio20693_vcocal(phy_info_t *pi);
static void wlc_phy_radio20693_upd_prfd_values(phy_info_t *pi);
static void wlc_phy_radio20693_lpf_tx_set(phy_info_t *pi, int8 bq_bw, int8 bq_gain,
	int8 rc_bw_ofdm, int8 rc_bw_cck);
static int8 wlc_phy_radio20693_minipmu_cal(phy_info_t *pi);
static void wlc_phy_chanspec_radio20693_setup(phy_info_t *pi,
	const void *chan_info, uint8 toggle_logen_reset);
static void wlc_phy_switch_radio_acphy_20693(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_band_change_acphy_20693(phy_info_t *pi);
static void wlc_phy_set_reg_on_reset_acphy_20693(phy_info_t *pi);
static void wlc_phy_radio20693_pwron_seq(phy_info_t *pi);
static void wlc_phy_radio20693_rccal(phy_info_t *pi);
static void wlc_phy_radio20693_rcal(phy_info_t *pi, uint8 mode);
static void wlc_phy_radio20693_xtal_tune_prep(phy_info_t *pi);
static void wlc_phy_radio20693_xtal_tune(phy_info_t *pi);

/* 2069x related Radio Functions */
static void wlc_phy_radio2069x_vcocal_isdone(phy_info_t *pi, bool set_delay);

/* PHY Functions */

/* PAPRR Functions */
static void
wlc_phy_papr_acphy(phy_info_t *pi, bool enable, bool init, bool band_changed);
/* PAPD Functions */
static void
wlc_phy_papd_smooth_acphy(phy_info_t *pi, uint8 core, uint32 winsz, uint32 start, uint32 end);
static void
wlc_phy_txpwr_papd_cal_run_acphy(phy_info_t *pi, uint8 tx_pre_cal_pwr_ctrl_state);
void
wlc_phy_papd_tempcomp_acphy(phy_info_t *pi, uint8 mode);
static void
wlc_phy_tiny_papd_cal_run_acphy(phy_info_t *pi, uint8 tx_pre_cal_pwr_ctrl_state);
static uint8
wlc_phy_txpwr_idx_cur_get_acphy(phy_info_t *pi, uint8 core);
void
wlc_phy_papd_cal_acphy(phy_info_t *pi, uint16 num_iter, uint8 core, uint16 startindex,
                                     uint16 yrefindex, uint16 stopindex);
static void
wlc_phy_dac_rate_mode_acphy(phy_info_t *pi, uint8 dac_rate_mode);
static void
wlc_phy_papd_phy_setup_acphy(phy_info_t *pi, uint8 core);
static void
wlc_phy_papd_rx_gain_ctrl_acphy(phy_info_t *pi);

static void
wlc_phy_papd_set_rfpwrlut(phy_info_t *pi);
static int8
wlc_phy_set_eps_from_nvram(phy_info_t *pi, uint8 core);
static int16
wlc_phy_papd_adjust_rfpwrlut(phy_info_t *pi, int16 epsilonoffset, uint8 core, uint8 idx);
static void
wlc_phy_papd_set_rfpwrlut_tiny(phy_info_t *pi);
void
wlc_phy_get_tx_gain_acphy(phy_info_t *pi, uint8 core_no, acphy_txgains_t *target_gain);
static void
wlc_phy_papd_radio_loopback_setup_acphy(phy_info_t *pi, uint16 tx_atten, uint16 rx_atten,
 uint8 core);
static void
wlc_phy_papd_radio_loopback_setup_acphy_20691(phy_info_t *pi, uint16 tx_atten, uint16 rx_atten);
static void
wlc_phy_20691_tia_gain(phy_info_t *pi, uint16 gain);
static void
wlc_phy_papdcal_radio_cleanup_acphy(phy_info_t *pi, uint8 core);
static void
wlc_phy_papd_phy_cleanup_acphy(phy_info_t *pi, uint8 core);
#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP) || \
	defined(WLTEST)
static void
wlc_phy_papd_dump_eps_trace_acphy(phy_info_t *pi, struct bcmstrbuf *b);
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) */
#define PAPD_GAIN_CTRL
#ifdef PAPD_GAIN_CTRL
static uint16
wlc_phy_papd_cal_gain_cntl_acphy(phy_info_t *pi, uint16 num_iter, uint8 core, uint16 startindex,
                                 uint16 yrefindex, uint16 stopindex); /* Todo: REMOVE TAG HEZI */

static void
wlc_phy_write_tx_gain_acphy(phy_info_t *pi, uint8 core, acphy_txgains_t *target_gain,
uint16 * bbmult);
#endif /* PAPD_GAIN_CTRL */

static void wlc_phy_set_tx_iir_coeffs(phy_info_t *pi, bool cck, uint8 filter_type);
static void wlc_phy_detach_acphy(phy_info_t *pi);
static void wlc_phy_init_acphy(phy_info_t *pi);
static void wlc_phy_cal_init_acphy(phy_info_t *pi);
static void wlc_phy_edcrs_thresh_acphy(phy_info_t *pi);
static void wlc_phy_set_srom_eu_edthresh_acphy(phy_info_t *pi);
static void wlc_phy_chanspec_set_acphy(phy_info_t *pi, chanspec_t chanspec);
static void wlc_phy_set_regtbl_on_pwron_acphy(phy_info_t *pi);
static void wlc_phy_set_reg_on_reset_acphy(phy_info_t *pi);
static void wlc_phy_set_tbl_on_reset_acphy(phy_info_t *pi);
static void wlc_phy_cfg_energydrop_timeout(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_band_change_acphy(phy_info_t *pi);
static void wlc_phy_set_mask_for_femctrl10(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_bw_change_acphy(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_chan_change_acphy(phy_info_t *pi, const void *chan_info);
static void wlc_phy_set_reg_on_bw_change_acphy(phy_info_t *pi);
static void wlc_phy_set_regtbl_on_femctrl(phy_info_t *pi);
static void wlc_phy_set_pdet_on_reset_acphy(phy_info_t *pi);
static void wlc_phy_txpower_recalc_target_acphy(phy_info_t *pi);
static void wlc_phy_get_tssi_floor_acphy(phy_info_t *pi, int16 *floor);
static void wlc_phy_watchdog_acphy(phy_info_t *pi);
void wlc_phy_set_trloss_reg_acphy(phy_info_t *pi, int8 core);
static bool wlc_phy_chan2freq_acphy(phy_info_t *pi, uint channel, int *f, const void **chan_info);
static bool wlc_phy_chan2freq_20691(phy_info_t *pi, uint channel, int *f, const void **chan_info);
static void wlc_phy_rfldo_trim_value(phy_info_t *pi);

static void wlc_phy_get_tx_bbmult_acphy(phy_info_t *pi, uint16 *bb_mult, uint16 core);
static void wlc_phy_set_tx_bbmult_acphy(phy_info_t *pi, uint16 *bb_mult, uint16 core);
static void wlc_phy_farrow_setup_tiny(phy_info_t *pi, chanspec_t chanspec);
static void wlc_phy_farrow_setup_acphy(phy_info_t *pi, chanspec_t chanspec);
static void wlc_phy_write_rx_farrow_pre_tiny(phy_info_t *pi, chan_info_rx_farrow *rx_farrow,
	chanspec_t chanspec);
static void wlc_phy_tx_farrow_mu_setup(phy_info_t *pi, uint16 MuDelta_l, uint16 MuDelta_u,
	uint16 MuDeltaInit_l, uint16 MuDeltaInit_u);
static void wlc_phy_write_tx_farrow_tiny(phy_info_t *pi, chanspec_t chanspec);
static void wlc_phy_write_rx_farrow_tiny(phy_info_t *pi, chanspec_t chanspec);
#ifndef ACPHY_1X1_ONLY
static void wlc_phy_write_tx_farrow_acphy(phy_info_t *pi, chanspec_t chanspec);
#endif // endif
static void wlc_phy_write_rx_farrow_acphy(phy_info_t *pi, chanspec_t chanspec);
void wlc_phy_txpwr_by_index_acphy(phy_info_t *pi, uint8 core_mask, int8 txpwrindex);
static void wlc_phy_get_txgain_settings_by_index_acphy(phy_info_t *pi,
                                     txgain_setting_t *txgain_settings, int8 txpwrindex);
static void wlc_phy_runsamples_acphy(phy_info_t *pi, uint16 num_samps, uint16 loops,
                                     uint16 wait, uint8 iqmode, uint8 mac_based);
static void wlc_phy_loadsampletable_acphy(phy_info_t *pi, cint32 *tone_buf, uint16 num_samps,
                                          bool alloc, bool conj);
static uint16 wlc_phy_gen_load_samples_acphy(phy_info_t *pi, int32 f_kHz, uint16 max_val,
                                             uint8 mac_based);
static uint16 wlc_phy_gen_load_samples_acphy_papd(phy_info_t *pi, int32 f_kHz, uint16 max_val,
                                             uint8 mac_based);
int wlc_phy_tx_tone_acphy(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 iqmode,
                                     uint8 mac_based, bool modify_bbmult);
int wlc_phy_tx_tone_acphy_papd(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 iqmode,
                                     uint8 mac_based, bool modify_bbmult);
void wlc_phy_stopplayback_acphy(phy_info_t *pi);
static void wlc_phy_runsamples_acphy(phy_info_t *pi, uint16 num_samps, uint16 loops,
                                     uint16 wait, uint8 iqmode, uint8 mac_based);
static int  wlc_phy_cal_txiqlo_acphy(phy_info_t *pi, uint8 searchmode, uint8 mphase, uint8 Biq2byp);
static void wlc_phy_cal_txiqlo_coeffs_acphy(phy_info_t *pi,
                                            uint8 rd_wr, uint16 *coeffs, uint8 select, uint8 core);
static void wlc_phy_populate_tx_iqlo_comp_tables_acphy(phy_info_t *pi,
	uint8 start_idx, uint8 stop_idx);
static void wlc_phy_precal_txgain_acphy(phy_info_t *pi, txgain_setting_t *target_gains);

static void wlc_phy_precal_target_tssi_search(phy_info_t *pi, txgain_setting_t *target_gains);
static void wlc_phy_precal_txgain_control(phy_info_t *pi, txgain_setting_t *target_gains);

static void wlc_phy_txcal_txgain_setup_acphy(phy_info_t *pi, txgain_setting_t *txcal_txgain,
                                             txgain_setting_t *orig_txgain);
static void wlc_phy_txcal_txgain_cleanup_acphy(phy_info_t *pi, txgain_setting_t *orig_txgain);
static void wlc_phy_txcal_radio_setup_acphy(phy_info_t *pi);
static void wlc_phy_txcal_radio_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_txcal_phy_setup_acphy_core_disable_rf(phy_info_t *pi, uint8 core);
static void wlc_phy_txcal_phy_setup_acphy_core_loopback_path(phy_info_t *pi, uint8 core,
        uint8 lpf_config);
static void wlc_phy_txcal_phy_setup_acphy_core_sd_adc(phy_info_t *pi, uint8 core,
	uint16 sdadc_config);
static void wlc_phy_txcal_phy_setup_acphy_core_lpf(phy_info_t *pi, uint8 core, uint16 bw_idx);
static void wlc_phy_txcal_phy_setup_acphy_core(phy_info_t *pi, acphy_txcal_phyregs_t *porig,
	uint8 core, uint16 bw_idx, uint16 sdadc_config, uint8 Biq2byp);
static void wlc_phy_txcal_phy_setup_acphy(phy_info_t *pi, uint8 Biq2byp);
static void wlc_phy_txcal_phy_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_cal_txiqlo_update_ladder_acphy(phy_info_t *pi, uint16 bbmult);
static void wlc_phy_clip_det_acphy(phy_info_t *pi, bool enable);
static void wlc_phy_write_regtbl_fc_from_nvram(phy_info_t *pi);
static uint16 wlc_phy_femctrlout_get_val(uint32 val_ext, uint32 val, uint32 MASK);
/* function to read femctrl params from nvram */
static void wlc_phy_nvram_femctrl_read(phy_info_t *pi);
static void wlc_phy_nvram_rssioffset_read_sub(phy_info_t *pi);
static void wlc_phy_nvram_rssioffset_read(phy_info_t *pi);
static void wlc_phy_nvram_avvmid_read(phy_info_t *pi);

static void  wlc_phy_vlin_en_acphy(phy_info_t *pi);
static void  wlc_phy_nvram_vlin_params_read(phy_info_t *pi);

#ifdef WL_SAR_SIMPLE_CONTROL
static void wlc_phy_nvram_dynamicsarctrl_read(phy_info_t *pi);
#endif /* WL_SAR_SIMPLE_CONTROL */

void
wlc_phy_table_write_acphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset, uint32 width,
                          const void *data);
void
wlc_phy_table_read_acphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset, uint32 width,
                         void *data);
void wlc_2069_rfpll_150khz(phy_info_t *pi);
void wlc_phy_force_rfseq_acphy(phy_info_t *pi, uint8 cmd);
void wlc_phy_force_femreset_acphy(phy_info_t *pi, bool ovr);
void wlc_phy_force_rfseq_noLoleakage_acphy(phy_info_t *pi);
void wlc_phy_set_analog_tx_lpf(phy_info_t *pi, uint16 mode_mask, int bq0_bw, int bq1_bw,
                               int rc_bw, int gmult, int gmult_rc, int core_num);
void wlc_phy_set_analog_rx_lpf(phy_info_t *pi, uint8 mode_mask, int bq0_bw, int bq1_bw,
                               int rc_bw, int gmult, int gmult_rc, int core_num);
void wlc_phy_set_tx_afe_dacbuf_cap(phy_info_t *pi, uint16 mode_mask, int dacbuf_cap,
                                   int dacbuf_fixed_cap, int core_num);
void wlc_phy_rx_iq_est_acphy(phy_info_t *pi, phy_iq_est_t *est, uint16 num_samps,
                             uint8 wait_time, uint8 wait_for_crs, bool rxiq_cal);

static void wlc_phy_rx_iq_comp_acphy(phy_info_t *pi, uint8 write, phy_iq_comp_t *pcomp, uint8);
static void wlc_phy_rxcal_phy_setup_acphy_save_rfctrl(phy_info_t *pi, uint8 core,
	acphy_rxcal_phyregs_t *porig);
static void wlc_phy_rxcal_phy_setup_acphy_core_lpf(phy_info_t *pi, uint8 core, uint8 bw_idx);
static void wlc_phy_rxcal_phy_setup_acphy_core(phy_info_t *pi, uint8 core, uint8 bw_idx,
	uint16 sdadc_config);
static void wlc_phy_rxcal_phy_setup_acphy(phy_info_t *pi);
static void wlc_phy_rxcal_phy_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_rxcal_radio_setup_acphy(phy_info_t *pi);
static void wlc_phy_rxcal_radio_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_rxcal_radio_setup_acphy_tiny(phy_info_t *pi);
static void wlc_phy_rxcal_radio_cleanup_acphy_tiny(phy_info_t *pi);

static void wlc_phy_cal_txgain_control_dBm(phy_info_t *pi, int8 targetpwr_dBm);
static void wlc_phy_rxcal_loopback_gainctrl_acphy(phy_info_t *pi);
static void wlc_phy_rxcal_txrx_gainctrl_acphy_tiny(phy_info_t *pi);

static int  wlc_phy_cal_rx_fdiqi_acphy(phy_info_t *pi);
static void wlc_phy_rx_fdiqi_lin_reg_acphy(phy_info_t *pi, acphy_rx_fdiqi_t *freq_ang_mag,
                                        uint16 num_data);
static void wlc_phy_rx_fdiqi_comp_acphy(phy_info_t *pi, bool enable);
static void wlc_phy_rxcal_leakage_comp_acphy(phy_info_t *pi, phy_iq_est_t loopback_rx_iq,
                                   phy_iq_est_t leakage_rx_iq, int32 *angle, int32 *mag);

void wlc_phy_init_test_acphy(phy_info_t *pi);

#if defined(PHYCAL_CACHING) || defined(WLMCHAN)|| defined(WL_MODESW)
#ifdef WLOLPC
static int8 wlc_phy_olpcthresh(void);
#endif /* WLOLPC */
#endif /* PHYCAL_CACHE || WLMCHAN */
static void wlc_phy_rx_fdiqi_freq_config(phy_info_t *pi, int8 *fdiqi_cal_freqs, uint16 *num_data);
void wlc_phy_get_rxgain_acphy(phy_info_t *pi, rxgain_t rxgain[], int16 *tot_gain,
                              uint8 force_gain_type);

static void wlc_phy_tiny_rfseq_mode_set(phy_info_t *pi, bool cal_mode);
static bool wlc_phy_txpwrctrl_ison_acphy(phy_info_t *pi);
uint32 wlc_phy_txpwr_idx_get_acphy(phy_info_t *pi);
void wlc_phy_txpwrctrl_enable_acphy(phy_info_t *pi, uint8 ctrl_type);
static void wlc_phy_txpwrctrl_set_baseindex(phy_info_t *pi, uint8 core, uint8 baseindex,
	acphy_enc_t frame_type);
static void wlc_phy_txpwrctrl_set_idle_tssi_acphy(phy_info_t *pi, int16 idle_tssi, uint8 core);
static void wlc_phy_tssi_radio_setup_acphy(phy_info_t *pi, uint8 core_mask, uint8 for_iqcal);
static void wlc_phy_tssi_phy_setup_acphy(phy_info_t *pi, uint8 for_iqcal);
static void wlc_phy_gpiosel_acphy(phy_info_t *pi, uint16 sel, uint8 word_swap);
static void wlc_phy_poll_adc_acphy(phy_info_t *pi, int32 *adc_buf, uint8 nsamps,
                                   bool switch_gpiosel, uint16 core);
static void wlc_phy_poll_samps_acphy(phy_info_t *pi, int16 *samp, bool is_tssi,
                                     uint8 log2_nsamps, bool init_adc_inside,
                                     uint16 core);
static void wlc_phy_poll_samps_WAR_acphy(phy_info_t *pi, int16 *samp, bool is_tssi,
                                         bool for_idle, txgain_setting_t *target_gains,
                                         bool for_iqcal, bool init_adc_inside, uint16 core,
                                         bool champ);
static void wlc_phy_poll_tssi_samps_acphy(phy_info_t *pi, int16 *samp,
                                          txgain_setting_t *target_gains, uint16 ADCcore);
static void wlc_phy_init_adc_read(phy_info_t *pi, uint16 *save_afePuCtrl, uint16 *save_gpio,
                                  uint32 *save_chipc, uint16 *fval2g_orig, uint16 *fval5g_orig,
                                  uint16 *fval2g, uint16 *fval5g, uint8 *stall_val,
                                  uint16 *save_gpioHiOutEn);
static void wlc_phy_restore_after_adc_read(phy_info_t *pi, uint16 *save_afePuCtrl,
                                           uint16 *save_gpio, uint32 *save_chipc,
                                           uint16 *fval2g_orig, uint16 *fval5g_orig,
                                           uint16 *fval2g, uint16 *fval5g, uint8 *stall_val,
                                           uint16 *save_gpioHiOutEn);
static void wlc_phy_txpwrctrl_idle_tssi_meas_acphy(phy_info_t *pi);
static uint8 wlc_phy_set_txpwr_clamp_acphy(phy_info_t *pi, uint8 core);
static void wlc_phy_txpwrctrl_config_acphy(phy_info_t *pi);
#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
static void wlc_phy_tx_target_pwr_per_channel_set_acphy(phy_info_t *pi);
#endif /* POWPERCHANNL2G || POWPERCHANNL5G */
static void wlc_phy_txpwrctrl_setminpwr(phy_info_t *pi);
static void wlc_phy_txpwrctrl_pwr_setup_acphy(phy_info_t *pi);
#ifdef SROM12
static void wlc_phy_txpwrctrl_pwr_setup_srom12_acphy(phy_info_t *pi);
#endif /* SROM12 */
static void wlc_phy_txpwr_fixpower_acphy(phy_info_t *pi);
static void wlc_phy_pulse_adc_reset_acphy(phy_info_t *pi);
static int8 wlc_phy_tone_pwrctrl(phy_info_t *pi, int8 tx_idx, uint8 core);
#if defined(BCMDBG_RXCAL)
static void wlc_phy_rxcal_snr_acphy(phy_info_t *pi, uint16 num_samps, uint8 core_mask);
#endif /* BCMDBG_RXCAL */
static uint16 wlc_poll_adc_clamp_status(phy_info_t *pi, uint8 core, uint8 do_reset);
static bool wlc_phy_srom_read_acphy(phy_info_t *pi);
int16 wlc_phy_tempsense_acphy(phy_info_t *pi);
static void wlc_phy_tempsense_radio_setup_acphy(phy_info_t *pi, uint16 Av, uint16 Vmid);
static void wlc_phy_tempsense_phy_setup_acphy(phy_info_t *pi);
static void wlc_phy_tempsense_radio_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_tempsense_phy_cleanup_acphy(phy_info_t *pi);
static void wlc_phy_tx_gm_gain_boost(phy_info_t *pi);
static void acphy_load_txv_for_spexp(phy_info_t *pi);
static int wlc_phy_txpower_core_offset_set_acphy(phy_info_t *pi,
                                                 struct phy_txcore_pwr_offsets *offsets);
static int wlc_phy_txpower_core_offset_get_acphy(phy_info_t *pi,
                                                 struct phy_txcore_pwr_offsets *offsets);
static void wlc_phy_set_crs_min_pwr_acphy(phy_info_t *pi, uint8 ac_th,
                                          int8 offset_1, int8 offset_2);

static void wlc_phy_set_analog_rxgain(phy_info_t *pi, uint8 clipgain, uint8 *gain_idx,
                                      bool trtx, uint8 core);
static void wlc_phy_srom_read_gainctrl_acphy(phy_info_t *pi);

/* Rx Gainctrl */
static void wlc_phy_rxgainctrl_gainctrl_acphy_tiny(phy_info_t *pi);
static void wlc_phy_rxgainctrl_gainctrl_acphy(phy_info_t *pi);
static int8 wlc_phy_rxgainctrl_calc_low_sens_acphy(phy_info_t *pi, int8 clipgain, bool trtx,
                                                   uint8 core);
static int8 wlc_phy_rxgainctrl_calc_high_sens_acphy(phy_info_t *pi, int8 clipgain, bool trtx,
                                                    uint8 core);
static uint8 wlc_phy_rxgainctrl_set_init_clip_gain_acphy(phy_info_t *pi, uint8 clipgain,
                                       int8 gain_dB, bool trtx, bool lan1byp, uint8 core);

static void wlc_phy_rxgainctrl_set_gaintbls_acphy(phy_info_t *pi, bool init,
                                                         bool band_change, bool bw_change);
static int8 wlc_phy_rxgainctrl_encode_gain_acphy(phy_info_t *pi, uint8 core,
                                       int8 gain_dB, bool trloss, bool lna1byp, uint8 *gidx);
static void wlc_phy_rxgainctrl_nbclip_acphy(phy_info_t *pi, uint8 core, int8 rxpwr_dBm);
static int16 wlc_phy_rxgainctrl_nbclip_acphy_tiny(phy_info_t *pi, uint8 core, int16 rxpwr_dBm);
static void wlc_phy_rxgainctrl_w1clip_acphy(phy_info_t *pi, uint8 core, int8 rxpwr_dBm);
static void wlc_phy_rxgainctrl_w1clip_acphy_tiny(phy_info_t *pi, uint8 core, int8 rxpwr_dBm);

static uint8 wlc_phy_get_max_lna_index_acphy(phy_info_t *pi, uint8 lna);
static void wlc_phy_upd_lna1_lna2_gains_acphy(phy_info_t *pi);
static void wlc_phy_upd_lna1_lna2_gaintbls_acphy(phy_info_t *pi, uint8 lna12);
static void wlc_phy_upd_lna1_bypass_acphy(phy_info_t *pi, uint8 core, uint8 rout_offset);
static void wlc_phy_upd_lna1_lna2_gainlimittbls_acphy(phy_info_t *pi, uint8 lna12,
                                                      bool lmt_rout_pktgain);
static bool wlc_phy_upd_lna1_lna2_routs_acphy(phy_info_t *pi, uint8 lna12);
static void wlc_phy_limit_rxgaintbl_acphy(uint8 gaintbl[], uint8 gainbitstbl[], uint8 sz,
                                          uint8 default_gaintbl[], uint8 min_idx, uint8 max_idx);

static void wlc_phy_bt_on_gpio4_acphy(phy_info_t *pi);
static void wlc_phy_compute_rssi_gainerror_acphy(phy_info_t *pi);
static uint32 wlc_phy_pdoffset_cal_acphy(uint32 pdoffs, uint16 pdoffset, uint8 band, uint8 core);
static void wlc_phy_set_aci_regs_acphy(phy_info_t *pi);

uint8 wlc_phy_calc_extra_init_gain_acphy(phy_info_t *pi, uint8 extra_gain_3dB, rxgain_t rxgain[]);

#ifndef WLC_DISABLE_ACI
/* ACI, BT Desense (start) */
static void wlc_phy_apply_total_mitigation_acphy(phy_info_t *pi);
static void wlc_phy_hwaci_init_acphy(phy_info_t *pi);
static void wlc_phy_save_def_gain_settings_acphy(phy_info_t *pi);

static void wlc_phy_desense_calc_total_acphy(phy_info_t *pi);
void wlc_phy_desense_apply_acphy(phy_info_t *pi, bool apply_desense);
static void wlc_phy_desense_mf_high_thresh_acphy(phy_info_t *pi, bool on);
static acphy_aci_params_t* wlc_phy_desense_aci_getset_chanidx_acphy(phy_info_t *pi,
                                                                  chanspec_t chanspec, bool create);
static uint8 wlc_phy_desense_aci_calc_acphy(phy_info_t *pi, desense_history_t *aci_desense,
                                       uint8 desense, uint32 glitch_cnt, uint16 glitch_th_lo,
                                       uint16 glitch_th_hi);
static uint32 wlc_phy_desense_aci_get_avg_max_glitches_acphy(uint32 glitches[]);
static void wlc_phy_desense_print_phyregs_acphy(phy_info_t *pi, const char str[]);
static void wlc_phy_aci_updsts_acphy(phy_info_t *pi);
static void wlc_phy_desense_aci_upd_glitches_acphy(acphy_aci_params_t *aci,
                                       uint32 bphy_glitches, uint32 bphy_badplcp,
                                       uint32 ofdm_glitches, uint32 ofdm_badplcp);
/* Tiny related HWACI setup  */
static void wlc_phy_init_FCBS_hwaci(phy_info_t *pi);
static void wlc_phy_hwaci_write_table_acphy(phy_info_t *pi, uint16 table_id,
	uint16 start_off, uint8 *table_entry, bool check_5G);
/* ACI, BT Desense (end) */
#endif /* !WLC_DISABLE_ACI */

static void wlc_phy_mlua_adjust_acphy(phy_info_t *pi, bool btactive);
static void wlc_phy_spurwar_nvshp_acphy(phy_info_t *pi, bool bw_changed, bool spurwar, bool nvshp);
static void wlc_phy_spurwar_acphy(phy_info_t *pi, uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES],
                                        int8 *tone_id, uint8 *core_sp);
static uint8 wlc_phy_spurwar_4345(phy_info_t *pi, uint32 xtal_hz, uint8 i,
                        uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES], int8 *tone_id, uint8 *core_sp);

static void wlc_phy_set_noise_var_shaping_acphy(phy_info_t *pi,
                        uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES], int8 *tone_id, uint8 *core_nv);
static void wlc_phy_susp2tx_cts2self(phy_info_t *pi, uint16 duration);
/* uCode hirssi - bypass elna */
static bool wlc_phy_hirssi_elnabypass_shmem_read_clear_acphy(phy_info_t *pi);

static void wlc_phy_reset_noise_var_shaping_acphy(phy_info_t *pi);
static void wlc_phy_noise_var_shaping_acphy(phy_info_t *pi, uint8 core_nv, uint8 core_sp,
                       int8 *tone_id, uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES], uint8 reset);
static bool wlc_phy_is_scan_chan_acphy(phy_info_t *pi);

void wlc_phy_pwrctrl_shortwindow_upd_acphy(phy_info_t *pi, bool shortterm);
#ifdef PREASSOC_PWRCTRL
void wlc_phy_store_tx_pwrctrl_setting_acphy(phy_info_t *pi, chanspec_t previous_channel);
static uint8 wlc_phy_txpwrctrl_get_target_acphy(phy_info_t *pi, uint8 core);
#endif // endif

#ifdef ENABLE_FCBS
static bool wlc_phy_fcbsinit_acphy(phy_info_t *pi, int chanidx, chanspec_t chanspec);
static bool wlc_phy_prefcbsinit_acphy(phy_info_t *pi, int chanidx);
static bool wlc_phy_postfcbsinit_acphy(phy_info_t *pi, int chanidx);
static bool wlc_phy_fcbs_acphy(phy_info_t *pi, int chanidx);
static bool wlc_phy_prefcbs_acphy(phy_info_t *pi, int chanidx);
static bool wlc_phy_postfcbs_acphy(phy_info_t *pi, int chanidx);
#endif /* ENABLE_FCBS */

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
#ifdef BCMDBG
static void wlc_phy_cal_cache_dbg_acphy(wlc_phy_t *pih, ch_calcache_t *ctx);
#endif /* BCMDBG */
#endif /* PHYCAL_CACHING || WLMCHAN */

void wlc_phy_lpf_hpc_override_acphy(phy_info_t *pi, bool setup_not_cleanup);
static void wlc_phy_set_bt_on_core1_acphy(phy_info_t *pi, uint8 bt_fem_val, uint16 gpioen);
void wlc_phy_proprietary_mcs_acphy(phy_info_t *pi, bool enable_prop_mcs);
uint8 wlc_phy_11b_rssi_WAR(phy_info_t *pi, d11rxhdr_t *rxh);
void wlc_phy_populate_tx_loft_comp_tbl_acphy(phy_info_t *pi, uint16 *loft_coeffs);
static uint16 wlc_phy_set_txpwr_by_index_acphy(phy_info_t *pi, uint8 core_mask, int8 txpwrindex);
void wlc_phy_read_txgain_acphy(phy_info_t *pi);
static void wlc_phy_cal_coeffs_upd(phy_info_t *pi, txcal_coeffs_t *txcal_cache);
void wlc_phy_radar_detect_on_off_cfg_acphy(phy_info_t *pi, bool radar_on);

#ifdef WL_LPC
uint8 wlc_acphy_lpc_getminidx(void);
uint8 wlc_acphy_lpc_getoffset(uint8 index);
#ifdef WL_LPC_DEBUG
uint8 * wlc_acphy_lpc_get_pwrlevelptr(void);
#endif // endif
#endif /* WL_LPC */

static void wlc_acphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b);
static void wlc_acphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b);
static uint16 wlc_acphy_get_tx_locc(phy_info_t *pi);
static void wlc_acphy_set_tx_locc(phy_info_t *pi, uint16 didq);
static void wlc_acphy_get_radio_loft(phy_info_t *pi, uint8 *ei0,
	uint8 *eq0, uint8 *fi0, uint8 *fq0);
static void wlc_acphy_set_radio_loft(phy_info_t *pi, uint8, uint8, uint8, uint8);
static void wlc_phy_dssf_acphy(phy_info_t *pi, bool on);
static void wlc_phy_dssfB_acphy(phy_info_t *pi, bool on);
static void wlc_phy_dssf_setup_acphy(phy_info_t *pi);
static void wlc_phy_dssfB_setup_acphy(phy_info_t *pi);

/* 20691 PHY related functions */
static void wlc_phy_txcal_radio_setup_acphy_20691(phy_info_t *pi);
static void wlc_phy_txcal_radio_cleanup_acphy_20691(phy_info_t *pi);
static void wlc_phy_tssi_radio_setup_acphy_20691(phy_info_t *pi, uint8 core_mask, uint8 for_iqcal);
static void wlc_20691_tia_config(phy_info_t *pi);
static void wlc_20691_sigdel_slow0g6_tune(phy_info_t *pi, int g_mult_raw_p12,
                                   tiny_adc_tuning_array_t *gvalues, int gi_mult);
static void wlc_20691_sigdel_slow1g2_tune(phy_info_t *pi, int g_mult_raw_p12,
                                          tiny_adc_tuning_array_t *gvalues);
static void wlc_20691_sigdel_fast_tune(phy_info_t *pi, int g_mult_raw_p12,
                                          tiny_adc_tuning_array_t *gvalues);
static void wlc_20691_adc_setup_slow0g6(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues);
static void wlc_20691_adc_setup_slow1g2(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues);
static void wlc_20691_adc_setup_fast(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues);
static int wlc_20691_sigdel_wrap(int prod, int max_val);
static int wlc_20691_sigdel_fast_mult(int raw_p8, int mult_p12, int max_val, int rshift);
static void wlc_20691_setup_coarse_dcc(phy_info_t *pi);
static void wlc_enable_lna_dcc_comp_20691(phy_info_t *pi, bool on);
static void wlc_20691_dc_static_WAR(phy_info_t *pi);
static void wlc_20691_coarse_dcoc(phy_info_t *pi);
static void wlc_idac_read_20691(phy_info_t *pi, int16 *i, int16 *q);
static void wlc_idac_preload_20691(phy_info_t *pi, int16 i, int16 q);

#define IDAC_20691_I_CHANNEL 0
#define IDAC_20691_Q_CHANNEL 1
static void wlc_20691_dcoc_idac_set(phy_info_t *pi, int dac, int ch);
static int wlc_20691_idac_iterate_lim(phy_info_t *pi, int ch, int iters);
static int wlc_20691_idac_minsearch_iqest(phy_info_t *pi, int ch,
                                          int dac_min, int dac_max, int dac_step);
static void wlc_dcc_fsm_reset(phy_info_t *pi);
static int wlc_phy_tiny_static_dc_offset_cal(phy_info_t *pi);
static void wlc_rx_digi_dccomp_set(phy_info_t *pi, int16 i, int16 q, uint8 core);
static void wlc_dcc_fsm_restart(phy_info_t *pi);
static void wlc_phy_papd_radio_cleanup_acphy_20691(phy_info_t *pi);
static void wlc_phy_ipa_set_bbmult_acphy(phy_info_t *pi, uint16 *m0,
	uint16 *m1, uint16 *m2, uint8 coremask);

void
wlc_phy_antdiv_acphy(phy_info_t *pi, uint8 val);

void wlc_phy_switch_preemption_settings_AC4354REV(phy_info_t *pi, uint8 state);
void wlc_phy_switch_preemption_settings_ACMAJORREV5(phy_info_t *pi, uint8 state);

static int32 wlc_phy_tempsense_radio_swap_tiny(phy_info_t *pi,
	acphy_tempsense_cfg_opt_t type, uint8 swap);
static int32 wlc_phy_tempsense_poll_samps_tiny(phy_info_t *pi, uint16 samples,
	bool init_adc_inside);
static int32 wlc_phy_tempsense_poll_adc_war_tiny(phy_info_t *pi,
	bool init_adc_inside, int32 *measured_values);
static int32 wlc_phy_tempsense_gpiosel_tiny(phy_info_t *pi, uint16 sel, uint8 word_swap);
static int32 wlc_phy_tempsense_phy_setup_acphy_tiny(phy_info_t *pi);
static int32 wlc_phy_tempsense_phy_cleanup_acphy_tiny(phy_info_t *pi);
static int16 wlc_phy_tempsense_acphy_tiny(phy_info_t *pi);
static int32 wlc_phy_tempsense_radio_setup_acphy_tiny(phy_info_t *pi, uint16 Av, uint16 Vmid);
static int32 wlc_phy_tempsense_radio_cleanup_acphy_tiny(phy_info_t *pi);

#if (defined(WLTEST) || defined(WLPKTENG))
static bool wlc_phy_isperratedpden_acphy(phy_info_t *pi);
static void wlc_phy_perratedpdset_acphy(phy_info_t *pi, bool enable);
#endif // endif

uint32 acphy_get_sc_startptr(phy_info_t *pi);
uint32 acphy_get_sc_stopptr(phy_info_t *pi);
uint32 acphy_get_sc_curptr(phy_info_t *pi);
uint32 acphy_is_sc_done(phy_info_t *pi);
int acphy_sc_length(phy_info_t *pi);
void acphy_set_sc_startptr(phy_info_t *pi, uint32 start_idx);
void acphy_set_sc_stopptr(phy_info_t *pi, uint32 stop_idx);

#ifdef WL_PROXDETECT
static void wlc_phy_tof_reset_acphy(phy_info_t *pi);
#endif /* WL_PROXDETECT */

#if defined(WLC_TXPWRCAP)
static void wlc_phy_txpwrcap_set_acphy(phy_info_t *pi);
static void wlc_phy_txpwrcap_cellstatusupd_acphy(phy_info_t *pi);
static void wlc_phy_txpwrcap_attach_acphy(phy_info_t *pi);
#endif /* WLC_TXPWRCAP */

#ifdef WLC_TXCAL
static void wlc_phy_olpc_idx_tempsense_comp_acphy(phy_info_t *pi, uint8 *iidx, uint8 core);
#endif // endif

/* Calibrate nmos/pmos Xtal routines */
#ifdef PHY_XTAL_SPUR_CAL
static void   wlc_acphy_override_nmos_pmos(phy_info_t *pi, bool on);
static void   wlc_acphy_set_nmos_pmos(phy_info_t *pi, uint8 nmos, uint8 pmos);
static void   wlc_acphy_measure_spur_level(npmos_cal_state_t *pstate);
static uint16 wlc_acphy_get_bin_abs_val(phy_info_t *pi, int offset);
void          wlc_acphy_dump_samples(npmos_cal_state_t *pstate);
static uint16 wlc_acphy_get_npmos_spur_level(npmos_cal_state_t *state, uint8 nmos, uint8 pmos);
static uint8  wlc_acphy_reflect(uint8 val, uint8 bits);
static uint8  wlc_acphy_bin2idx(uint8 bin, npmos_cal_state_t *pstate);
static void   wlc_acphy_nmos_pmos_wrapper(bool do_cal, npmos_cal_state_t *pstate);
static bool   wlc_acphy_init_xtal_spur(phy_info_t *pi, npmos_cal_state_t *pstate);
static bool   wlc_acphy_cal_xtal_spur(phy_info_t *pi, bool force, bool cts2self);
static void   wlc_acphy_cal_xtal_nmos_pmos(npmos_cal_state_t *pstate);
#ifndef SAMPLE_COLLECT
static int    wlc_phy_spectrum_collect_acphy(phy_info_t *pi, wl_samplecollect_args_t *collect);
#endif /* SAMPLE_COLLECT */
#endif /* PHY_XTAL_SPUR_CAL */

/* ============= attach submodules ================ */
static bool
BCMATTACHFN(wlc_phy_attach_farrow)(phy_info_t *pi);
static bool
BCMATTACHFN(wlc_phy_attach_chan_tuning_tbl)(phy_info_t *pi);
static bool
BCMATTACHFN(wlc_phy_attach_femctrl_table)(phy_info_t *pi);

static void BCMATTACHFN(wlc_phy_fptr_attach_acphy)(phy_info_t *pi);
static void BCMATTACHFN(wlc_phy_nvram_attach_acphy)(phy_info_t *pi);
static void BCMATTACHFN(wlc_phy_std_params_attach_acphy)(phy_info_t *pi);
static void BCMATTACHFN(wlc_phy_nvram_epsdelta_read(phy_info_t *pi));

/* reclaim strings that are only used in attach functions */
static const char BCMATTACHDATA(rstr_pagc2g)[] = "pagc2g";
static const char BCMATTACHDATA(rstr_pagc5g)[] = "pagc5g";
static const char BCMATTACHDATA(rstr_rpcal2g)[] = "rpcal2g";
static const char BCMATTACHDATA(rstr_femctrl)[] = "femctrl";
static const char BCMATTACHDATA(rstr_papdmode)[] = "papdmode";
static const char BCMATTACHDATA(rstr_pdgain2g)[] = "pdgain2g";
static const char BCMATTACHDATA(rstr_pdgain5g)[] = "pdgain5g";
static const char BCMATTACHDATA(rstr_epacal2g)[] = "epacal2g";
static const char BCMATTACHDATA(rstr_epacal5g)[] = "epacal5g";
static const char BCMATTACHDATA(rstr_itrsw)[] = "itrsw";
static const char BCMATTACHDATA(rstr_pacal2g)[] = "pacal2g";
static const char BCMATTACHDATA(rstr_afewar40)[] = "afewar40";
static const char BCMATTACHDATA(rstr_pacal5g)[] = "pacal5g";
static const char BCMATTACHDATA(rstr_offtgpwr)[] = "offtgpwr";
static const char BCMATTACHDATA(rstr_epagain2g)[] = "epagain2g";
static const char BCMATTACHDATA(rstr_epagain5g)[] = "epagain5g";
static const char BCMATTACHDATA(rstr_rpcal5gb0)[] = "rpcal5gb0";
static const char BCMATTACHDATA(rstr_rpcal5gb1)[] = "rpcal5gb1";
static const char BCMATTACHDATA(rstr_rpcal5gb2)[] = "rpcal5gb2";
static const char BCMATTACHDATA(rstr_rpcal5gb3)[] = "rpcal5gb3";
static const char BCMATTACHDATA(rstr_txidxcap2g)[] = "txidxcap2g";
static const char BCMATTACHDATA(rstr_txidxcap5g)[] = "txidxcap5g";
static const char BCMATTACHDATA(rstr_extpagain2g)[] = "extpagain2g";
static const char BCMATTACHDATA(rstr_extpagain5g)[] = "extpagain5g";
static const char BCMATTACHDATA(rstr_boardflags3)[] = "boardflags3";
static const char BCMATTACHDATA(rstr_boardflags4)[] = "boardflags4";
static const char BCMATTACHDATA(rstr_pacalshift2g)[] = "pacalshift2g";
static const char BCMATTACHDATA(rstr_pacalshift5g)[] = "pacalshift5g";
static const char BCMATTACHDATA(rstr_pacalshift5ga0)[] = "pacalshift5ga0";
static const char BCMATTACHDATA(rstr_pacalshift5ga1)[] = "pacalshift5ga1";
static const char BCMATTACHDATA(rstr_pacalshift2ga0)[] = "pacalshift2ga0";
static const char BCMATTACHDATA(rstr_pacalshift2ga1)[] = "pacalshift2ga1";
static const char BCMATTACHDATA(rstr_pacalindex2g)[] = "pacalindex2g";
static const char BCMATTACHDATA(rstr_pacalindex5g)[] = "pacalindex5g";
static const char BCMATTACHDATA(rstr_txiqcalidx2g)[] = "txiqcalidx2g";
static const char BCMATTACHDATA(rstr_txiqcalidx5g)[] = "txiqcalidx5g";
static const char BCMATTACHDATA(rstr_pacalpwr2g)[] = "pacalpwr2g";
static const char BCMATTACHDATA(rstr_pacalpwr5g)[] = "pacalpwr5g";
static const char BCMATTACHDATA(rstr_pacalpwr5g40)[] = "pacalpwr5g40";
static const char BCMATTACHDATA(rstr_pacalpwr5g80)[] = "pacalpwr5g80";
static const char BCMATTACHDATA(rstr_papdpwrctrl)[] = "papdpwrctrl";
static const char BCMATTACHDATA(rstr_olpc_thresh)[] = "olpc_thresh";
static const char BCMATTACHDATA(rstr_olpc_thresh2g)[] = "olpc_thresh2g";
static const char BCMATTACHDATA(rstr_olpc_thresh5g)[] = "olpc_thresh5g";
static const char BCMATTACHDATA(rstr_olpc_tempslope2g)[] = "olpc_tempslope2g";
static const char BCMATTACHDATA(rstr_olpc_tempslope5g)[] = "olpc_tempslope5g";
static const char BCMATTACHDATA(rstr_olpc_anchor2g)[] = "olpc_anchor2g";
static const char BCMATTACHDATA(rstr_olpc_anchor5g)[] = "olpc_anchor5g";
static const char BCMATTACHDATA(rstr_olpc_idx_in_use)[] = "olpc_idx_in_use";
static const char BCMATTACHDATA(rstr_disable_olpc)[] = "disable_olpc";
static const char BCMATTACHDATA(rstr_initxidx2g)[] = "initxidx2g";
static const char BCMATTACHDATA(rstr_initxidx5g)[] = "initxidx5g";
static const char BCMATTACHDATA(rstr_txgaintbl5g)[] = "txgaintbl5g";
static const char BCMATTACHDATA(rstr_parfps2g)[] = "parfps2g";
static const char BCMATTACHDATA(rstr_parfps5g)[] = "parfps5g";
static const char BCMATTACHDATA(rstr_papdbbmult2g)[] = "papdbbmult2g";
static const char BCMATTACHDATA(rstr_papdbbmult5g)[] = "papdbbmult5g";
static const char BCMATTACHDATA(rstr_pacalmode)[] = "pacalmode";
static const char BCMATTACHDATA(rstr_pacalopt)[] = "pacalopt";
static const char BCMATTACHDATA(rstr_patoneidx2g)[] = "patoneidx2g";
static const char BCMATTACHDATA(rstr_patoneidx5g)[] = "patoneidx5g";
static const char BCMATTACHDATA(rstr_subband5gver)[] = "subband5gver";
static const char BCMATTACHDATA(rstr_dacratemode2g)[] = "dacratemode2g";
static const char BCMATTACHDATA(rstr_dacratemode5g)[] = "dacratemode5g";
static const char BCMATTACHDATA(rstr_vcodivmode)[] = "vcodivmode";
static const char BCMATTACHDATA(rstr_fdss_interp_en)[] = "fdss_interp_en";
static const char BCMATTACHDATA(rstr_fdss_level_2g)[] = "fdss_level_2g";
static const char BCMATTACHDATA(rstr_fdss_level_5g)[] = "fdss_level_5g";
static const char BCMATTACHDATA(rstr_epacal2g_mask)[] = "epacal2g_mask";
static const char BCMATTACHDATA(rstr_cckdigfilttype)[] = "cckdigfilttype";
static const char BCMATTACHDATA(rstr_ofdmfilttype)[] = "ofdmfilttype";
static const char BCMATTACHDATA(rstr_tworangetssi2g)[] = "tworangetssi2g";
static const char BCMATTACHDATA(rstr_tworangetssi5g)[] = "tworangetssi5g";
static const char BCMATTACHDATA(rstr_lowpowerrange2g)[] = "lowpowerrange2g";
static const char BCMATTACHDATA(rstr_lowpowerrange5g)[] = "lowpowerrange5g";
static const char BCMATTACHDATA(rstr_paprdis)[] = "paprdis";
static const char BCMATTACHDATA(rstr_papdwar)[] = "papdwar";
static const char BCMATTACHDATA(rstr_tssisleep_en)[] = "tssisleep_en";
static const char BCMATTACHDATA(rstr_tssiavg)[] = "tssiavg";
static const char BCMATTACHDATA(rstr_edpdcalset)[] = "edpdcalset";
static const char BCMATTACHDATA(ed_thresh2g)[] = "ed_thresh2g";
static const char BCMATTACHDATA(ed_thresh5g)[] = "ed_thresh5g";
static const char BCMATTACHDATA(rstr_phy4350_ss_opt)[] = "phy4350_ss_opt";
static const char BCMATTACHDATA(rstr_paparambwver)[] = "paparambwver";
static const char BCMATTACHDATA(rstr_LTEJ_WAR_en)[] = "LTEJ_WAR_en";
static const char BCMATTACHDATA(rstr_bphyscale)[] = "bphyscale";
static const char BCMATTACHDATA(rstr_antdiv_rfswctrlpin_a0)[]         = "antdiv_rfswctrlpin_a0";
static const char BCMATTACHDATA(rstr_antdiv_rfswctrlpin_a1)[]         = "antdiv_rfswctrlpin_a1";
static const char BCMATTACHDATA(rstr_rxgains2gelnagainaD)[]           = "rxgains2gelnagaina%d";
static const char BCMATTACHDATA(rstr_rxgains2gtrelnabypaD)[]          = "rxgains2gtrelnabypa%d";
static const char BCMATTACHDATA(rstr_rxgains2gtrisoaD)[]              = "rxgains2gtrisoa%d";
static const char BCMATTACHDATA(rstr_rxgains5gelnagainaD)[]           = "rxgains5gelnagaina%d";
static const char BCMATTACHDATA(rstr_rxgains5gtrelnabypaD)[]          = "rxgains5gtrelnabypa%d";
static const char BCMATTACHDATA(rstr_rxgains5gtrisoaD)[]              = "rxgains5gtrisoa%d";
static const char BCMATTACHDATA(rstr_rxgains5gmelnagainaD)[]          = "rxgains5gmelnagaina%d";
static const char BCMATTACHDATA(rstr_rxgains5gmtrelnabypaD)[]         = "rxgains5gmtrelnabypa%d";
static const char BCMATTACHDATA(rstr_rxgains5gmtrisoaD)[]             = "rxgains5gmtrisoa%d";
static const char BCMATTACHDATA(rstr_rxgains5ghelnagainaD)[]          = "rxgains5ghelnagaina%d";
static const char BCMATTACHDATA(rstr_rxgains5ghtrelnabypaD)[]         = "rxgains5ghtrelnabypa%d";
static const char BCMATTACHDATA(rstr_rxgains5ghtrisoaD)[]             = "rxgains5ghtrisoa%d";
static const char BCMATTACHDATA(rstr_VlinPwr2g_cD)[]                  = "VlinPwr2g_c%d";
static const char BCMATTACHDATA(rstr_VlinPwr5g_cD)[]                  = "VlinPwr5g_c%d";
static const char BCMATTACHDATA(rstr_Vlinmask2g_cD)[]                 = "Vlinmask2g_c%d";
static const char BCMATTACHDATA(rstr_Vlinmask5g_cD)[]                 = "Vlinmask5g_c%d";
static const char BCMATTACHDATA(rstr_rawtempsense)[]                  = "rawtempsense";
static const char BCMATTACHDATA(rstr_rxgainerr2ga0)[]                 = "rxgainerr2ga0";
static const char BCMATTACHDATA(rstr_rxgainerr2ga1)[]                 = "rxgainerr2ga1";
static const char BCMATTACHDATA(rstr_rxgainerr2ga2)[]                 = "rxgainerr2ga2";
static const char BCMATTACHDATA(rstr_rxgainerr5ga0)[]                 = "rxgainerr5ga0";
static const char BCMATTACHDATA(rstr_rxgainerr5ga1)[]                 = "rxgainerr5ga1";
static const char BCMATTACHDATA(rstr_rxgainerr5ga2)[]                 = "rxgainerr5ga2";
static const char BCMATTACHDATA(rstr_noiselvl2gaD)[]                  = "noiselvl2ga%d";
static const char BCMATTACHDATA(rstr_noiselvl5gaD)[]                  = "noiselvl5ga%d";
static const char BCMATTACHDATA(rstr_swctrlmap_2g)[]                  = "swctrlmap_2g";
static const char BCMATTACHDATA(rstr_swctrlmap_5g)[]                  = "swctrlmap_5g";
static const char BCMATTACHDATA(rstr_swctrlmapext_2g)[]               = "swctrlmapext_2g";
static const char BCMATTACHDATA(rstr_swctrlmapext_5g)[]               = "swctrlmapext_5g";
static const char BCMATTACHDATA(rstr_txswctrlmap_2g)[]                = "txswctrlmap_2g";
static const char BCMATTACHDATA(rstr_txswctrlmap_2g_mask)[]           = "txswctrlmap_2g_mask";
static const char BCMATTACHDATA(rstr_txswctrlmap_5g)[]                = "txswctrlmap_5g";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff2g)[]             = "rstr_rxgaintempcoeff2g";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff2g_sub)[]         =
							"rstr_rxgaintempcoeff2g_sub";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gl)[]            = "rstr_rxgaintempcoeff5gl";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gml)[]           = "rstr_rxgaintempcoeff5gml";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gmu)[]           = "rstr_rxgaintempcoeff5gmu";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gh)[]            = "rstr_rxgaintempcoeff5gh";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff2g_sub_elnaoff)[] =
							"rstr_rxgaintempcoeff2g_sub_elnaoff";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gl_elnaoff)[]    =
							"rstr_rxgaintempcoeff5gl_elnaoff";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gml_elnaoff)[]   =
							"rstr_rxgaintempcoeff5gml_elnaoff";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gmu_elnaoff)[]   =
							"rstr_rxgaintempcoeff5gmu_elnaoff";
static const char BCMATTACHDATA(rstr_rxgaintempcoeff5gh_elnaoff)[]    =
							"rstr_rxgaintempcoeff5gh_elnaoff";
static const char BCMATTACHDATA(rstr_rssicorrnorm_cD)[]               = "rssicorrnorm_c%d";
static const char BCMATTACHDATA(rstr_rssicorrnorm5g_cD)[]             = "rssicorrnorm5g_c%d";
static const char BCMATTACHDATA(rstr_rssi_delta_2g_cD)[]              = "rssi_delta_2g_c%d";
static const char BCMATTACHDATA(rstr_rssi_delta_5gS_cD)[]             = "rssi_delta_5g%s_c%d";
static const char BCMATTACHDATA(rstr_gain_cal_temp)[]                 = "gain_cal_temp";
static const char BCMATTACHDATA(rstr_rssi_cal_rev)[]                  = "rssi_cal_rev";
static const char BCMATTACHDATA(rstr_rxgaincal_rssical)[]             = "rxgaincal_rssical";
static const char BCMATTACHDATA(rstr_rud_agc_enable)[]                = "rud_agc_enable";
static const char BCMATTACHDATA(rstr_temp_comp_tr_loss)[]             = "temp_comp_tr_loss";
static const char BCMATTACHDATA(rstr_trloss_adj_time_dur)[]           = "trloss_adj_time_dur";
static const char BCMATTACHDATA(rstr_trloss_adj_temp_thresh)[]        = "trloss_adj_temp_thresh";
static const char BCMATTACHDATA(rstr_rssi_delta_2gS)[]                = "rssi_delta_2g%s";
static const char BCMATTACHDATA(rstr_rssi_delta_5gS)[]                = "rssi_delta_5g%s";
static const char BCMATTACHDATA(rstr_rssi_cal_freq_grp_2g)[]          = "rssi_cal_freq_grp_2g";
static const char BCMATTACHDATA(rstr_AvVmid_cD)[]                     = "AvVmid_c%d";
static const char BCMATTACHDATA(rstr_rssi_qdB_en)[]                   = "rssi_qdB_en";
static const char BCMATTACHDATA(rstr_rssi_corr_pchan2g_S_cD)[]        = "rssi_corr_pchan2g_%s_c%d";
static const char BCMATTACHDATA(rstr_rssi_corr_pchan5g_S_cD)[]        = "rssi_corr_pchan5g_%s_c%d";

static const char BCMATTACHDATA(rstr_dot11b_opts)[]	= "dot11b_opts";
static const char BCMATTACHDATA(rstr_tiny_maxrxgain)[]	= "tiny_maxrxgain";
static const char BCMATTACHDATA(rstr_rx5ggainwar)[]	= "rx5ggainwar";
static const char BCMATTACHDATA(rstr_cal_period)[]	= "cal_period";
static const char BCMATTACHDATA(rstr_ldo3p3_2g)[]	= "ldo3p3_2g";
static const char BCMATTACHDATA(rstr_ldo3p3_5g)[]	= "ldo3p3_5g";
static const char BCMATTACHDATA(rstr_fastpapdgainctrl)[] = "fastpapdgainctrl";

static const char BCMATTACHDATA(rstr_fem_table_init_val)[] = "fem_table_init_val";

#if (defined(WLTEST) || defined(WLPKTENG))
static const char BCMATTACHDATA(rstr_perratedpd2g)[] = "perratedpd2g";
static const char BCMATTACHDATA(rstr_perratedpd5g)[] = "perratedpd5g";
#endif // endif

#if (defined(WLTEST) || defined(ACMAJORREV2_THROUGHPUT_OPT))
static const char BCMATTACHDATA(rstr_dis_xtalldowar_2069)[] = "dis_xtalldowar_2069";
#endif // endif

#ifdef WLC_SW_DIVERSITY
static const char BCMATTACHDATA(rstr_swdiv_en)[] = "swdiv_en";
static const char BCMATTACHDATA(rstr_swdiv_gpio)[] = "swdiv_gpio";
static const char BCMATTACHDATA(rstr_swdiv_swctrl_en)[] = "swdiv_swctrl_en";
static const char BCMATTACHDATA(rstr_swdiv_swctrl_mask)[] = "swdiv_swctrl_mask";
static const char BCMATTACHDATA(rstr_swdiv_swctrl_ant0)[] = "swdiv_swctrl_ant0";
static const char BCMATTACHDATA(rstr_swdiv_swctrl_ant1)[] = "swdiv_swctrl_ant1";
#endif /* WLC_SW_DIVERSITY */

static const char BCMATTACHDATA(rstr_txnospurmod5g)[] = "txnospurmod5g";
static const char BCMATTACHDATA(rstr_txnospurmod2g)[] = "txnospurmod2g";

static const char BCMATTACHDATA(rstr_papdtempcomp_tempdelta)[] = "papdtempcomp_tempdelta";

#ifdef WLC_SW_DIVERSITY
static void wlc_phy_swdiv_srom_read_acphy(phy_info_t *pi);
static void wlc_phy_swdiv_init_acphy(phy_info_t *pi);
static void wlc_phy_swdiv_ovr_set_acphy(phy_info_t *pi);
#endif /* WLC_SW_DIVERSITY */

#ifdef ATE_BUILD
static void wlc_phy_gpaio_acphy(phy_info_t *pi, wl_gpaio_option_t option);
#endif // endif

/* PA Mode related configuration functions */
static void wlc_txswctrlmap_set_acphy(phy_info_t *pi, int8 pamode_requested);
static int8 wlc_txswctrlmap_get_acphy(phy_info_t *pi);
static void wlc_phy_wltx_word_get(phy_info_t *pi, uint8 band, uint32 swctrlmap_wltx,
	uint32 swctrlmap_wltx_ext, uint32 *swctrlword,	uint32 *swctrlwordext);

#if defined(WLTEST) || defined(BCMDBG)
static void wlc_phy_epa_dpd_set_acphy(phy_info_t *pi, uint8 enab_epa_dpd, bool in_2g_band);
#endif // endif

#if defined(WLTEST)
static void wlc_swctrlmap_set_acphy(phy_info_t *pi, uint32 swctrlmap_entry, uint32 swctrlmap_mask);
static void wlc_swctrlmap_get_acphy(phy_info_t *pi, uint32 *swctrlmap_params);
#endif // endif

static void wlc_phy_fdss_init(phy_info_t *pi);
static void wlc_phy_set_fdss_table(phy_info_t *pi);
static void wlc_phy_btcx_hybrid_mode_update_fem_acphy(phy_info_t *pi, bool on);
void wlc_acphy_paldo_change(phy_info_t *pi);

#if (defined(WLTEST) || defined(BCMDBG))
static void wlc_phy_iqlocal_state_check_acphy(phy_info_t *pi);
#endif // endif

/* ============= Function Definitions ============= */
bool
BCMATTACHFN(wlc_phy_attach_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac;

	phyhal_msg_level |= PHYHAL_ERROR;

	pi->u.pi_acphy = (phy_info_acphy_t*)MALLOC(pi->sh->osh, sizeof(phy_info_acphy_t));

	if (pi->u.pi_acphy == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		           __FUNCTION__, MALLOCED(pi->sh->osh)));
		return FALSE;
	}
	bzero((char *)pi->u.pi_acphy, sizeof(phy_info_acphy_t));
	pi_ac = pi->u.pi_acphy;

	/* Find out the number of cores contained in this ACPHY */
	pi->pubpi.phy_corenum = READ_PHYREGFLD(pi, PhyCapability0, NumberOfStreams);
	/* setup nvram driven config params */
	wlc_phy_nvram_attach_acphy(pi);

	/* set the gain tables for tiny radio */
	if (TINY_RADIO(pi))
		wlc_phy_set_txgain_tbls(pi);

	/* setup default config params */
	wlc_phy_std_params_attach_acphy(pi);
	pi->phycap = ((READ_PHYREGFLD(pi, PhyCapability0, Support80MHzBw)) ? (PHY_CAP_80MHZ) : 0);
	pi->phycap |= ((READ_PHYREGFLD(pi, PhyCapability1, SupportQAM256_5G)) ?
		(PHY_CAP_QAM256_5G) : 0);
	pi->phycap |= ((READ_PHYREGFLD(pi, PhyCapability1, SupportQAM256_24G)) ?
		(PHY_CAP_QAM256_24G) : 0);

	/* Initialize hw_chains to chip defaults */
	pi->sh->hw_phyrxchain = pi->pubpi.phy_corenum;
	pi->sh->hw_phytxchain = pi->pubpi.phy_corenum;

	wlc_phy_txpwrctrl_config_acphy(pi);

	if (!wlc_phy_srom_read_acphy(pi))
		return FALSE;

	acphy_get_lpmode(pi);

	/* Read RFLDO from OTP */
	wlc_phy_rfldo_trim_value(pi);

	/* setup function pointers */
	wlc_phy_fptr_attach_acphy(pi);

#ifndef WLC_DISABLE_ACI
	/* hwaci params */
	if (ACHWACIREV(pi)) {
		pi_ac->def_gains = MALLOC(pi->sh->osh, sizeof(acphy_hwaci_defgain_settings_t));
	}
	if (!(ACPHY_ENABLE_FCBS_HWACI(pi))) {
		wlc_phy_hwaci_init_acphy(pi);
	}
#endif /* !WLC_DISABLE_ACI */

	if (pi->u.pi_acphy->srom.rcal_otp_val_en == 1) {
		if (!otp_read_word(pi->sh->sih, ACPHY_RCAL_OFFSET, &pi->sh->rcal_otp_val)) {
			pi->sh->rcal_otp_val &= 0xf;
		} else {
			if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
					pi->sh->rcal_otp_val = ACPHY_RCAL_VAL_2X2;
				} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
					pi->sh->rcal_otp_val = ACPHY_RCAL_VAL_1X1;
				}
			} else if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
				pi->sh->rcal_otp_val = ACPHY_RCAL_VAL_1X1;
			}
		}
	}

	/* PA Mode is set so that NVRAM values are used by default */
	pi_ac->pa_mode = AUTO;
	if (!TINY_RADIO(pi) && !wlc_phy_attach_farrow(pi))
		return FALSE;
	if (!wlc_phy_attach_chan_tuning_tbl(pi))
		return FALSE;
	if (ACPHY_FEMCTRL_ACTIVE(pi) && !wlc_phy_attach_femctrl_table(pi))
		return FALSE;

#if defined(WLTEST)
	/* Switch Control Map default values */
	pi_ac->swctrlmap_entry = 0;
	pi_ac->swctrlmap_mask = 0;
#endif // endif

#if defined(WLC_TXPWRCAP)
	wlc_phy_txpwrcap_attach_acphy(pi);
#endif // endif

	return TRUE;
}

static void
BCMATTACHFN(acphy_get_lpmode)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	pi_ac->lpmode_2g = ACPHY_LPMODE_NONE;
	pi_ac->lpmode_5g = ACPHY_LPMODE_NONE;

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		switch (pi_ac->srom.lpmode_2g) {
			case 1:
				pi_ac->lpmode_2g = ACPHY_LPMODE_LOW_PWR_SETTINGS_1;
				break;
			case 2:
				pi_ac->lpmode_2g = ACPHY_LPMODE_LOW_PWR_SETTINGS_2;
				break;
			case 3:
				pi_ac->lpmode_2g = ACPHY_LPMODE_NORMAL_SETTINGS;
				break;
			case 0:
			default:
				pi_ac->lpmode_2g = ACPHY_LPMODE_NONE;
		}

		switch (pi_ac->srom.lpmode_5g) {
			case 1:
				pi_ac->lpmode_5g = ACPHY_LPMODE_LOW_PWR_SETTINGS_1;
				break;
			case 2:
				pi_ac->lpmode_5g = ACPHY_LPMODE_LOW_PWR_SETTINGS_2;
				break;
			case 3:
				pi_ac->lpmode_5g = ACPHY_LPMODE_NORMAL_SETTINGS;
				break;
			case 0:
			default:
				pi_ac->lpmode_5g = ACPHY_LPMODE_NONE;
		}
	}
}

static void
acphy_set_lpmode(phy_info_t *pi, acphy_lp_opt_levels_t lp_opt_lvl)
{
	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		switch (lp_opt_lvl) {
		case ACPHY_LP_RADIO_LVL_OPT:
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
				if (pi_ac->lpmode_2g == ACPHY_LPMODE_LOW_PWR_SETTINGS_1) {
					wlc_phy_radio_vco_opt(pi, ACPHY_VCO_2P5V);
				} else if (pi_ac->lpmode_2g == ACPHY_LPMODE_LOW_PWR_SETTINGS_2) {
					wlc_phy_radio_vco_opt(pi, ACPHY_VCO_1P35V);
				}
			}
			break;
		case ACPHY_LP_CHIP_LVL_OPT:
		case ACPHY_LP_PHY_LVL_OPT:
		default:
			break;
		}
	}
}
/*
************************ RADIO procs **************************
*/

void
wlc_phy_radio_override_acphy(phy_info_t *pi, bool on)
{
	uint8 core;
	uint16 addr, *tbl_ptr;
	uint16 ovr_val = on ? 0xFFFF : 0x0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		tbl_ptr = ovr_regs_2069_rev32;
	} else if ((RADIOMAJORREV(pi->pubpi.radiomajorrev)) == 1) {
		tbl_ptr = ovr_regs_2069_rev16;
	} else {
		tbl_ptr = ovr_regs_2069_rev2;
	}

	while ((addr = *tbl_ptr++) != 0xFFFF) {
		ASSERT(addr != 0);
		write_radio_reg(pi, addr, ovr_val);
	}

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, GE32_OVR2, core, ovr_otp_rcal_sel, 0);
		}
	} else {
		MOD_RADIO_REG(pi, RF2, OVR2, ovr_otp_rcal_sel, 0);
	}
	/* Reg conflict with 2069 rev 16 */
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
		MOD_RADIO_REG(pi, RFP,  OVR15, rfpll_vco_EN_DEGEN_jtag_ovr, 0);
	} else {
		MOD_RADIO_REG(pi, RFP,  GE16_OVR16, rfpll_vco_EN_DEGEN_jtag_ovr, 0);
	}
}

void
wlc_phy_switch_radio_acphy(phy_info_t *pi, bool on)
{
	uint8 core;
	uint16 data = 0;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
#ifdef LOW_TX_CURRENT_SETTINGS_2G
	uint8 is_ipa = 0;
#endif // endif

	PHY_TRACE(("wl%d: %s %s\n", pi->sh->unit, __FUNCTION__, on ? "ON" : "OFF"));

	if (on) {
		if (!pi->radio_is_on) {
			if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
					/*  set the low pwoer reg before radio init */
					wlc_phy_set_lowpwr_phy_reg(pi);
					wlc_phy_radio2069_mini_pwron_seq_rev16(pi);
				} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
					/*  set the low pwoer reg before radio init */
					wlc_phy_set_lowpwr_phy_reg_rev3(pi);
					wlc_phy_radio2069_mini_pwron_seq_rev32(pi);
				}

				wlc_phy_radio2069_pwron_seq(pi);
			} else if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
				wlc_phy_radio20691_pwron_seq(pi);
				wlc_phy_switch_radio_acphy_20691(pi);
			} else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID) {
				wlc_phy_radio20693_pwron_seq(pi);
				wlc_phy_switch_radio_acphy_20693(pi);
			}

			if (pi->u.pi_acphy->srom.rcal_otp_val_en == 1) {
				data = pi->sh->rcal_otp_val;
			} else {
				if (pi->u.pi_acphy->srom.rcal_war == 1) {
		/* --------------------------RCAL WAR ---------------------------- */
		/* Currently RCAL resistor is not connected on the board. The pin  */
		/* labelled TSSI_G/GPIO goes into the TSSI pin of the FEM through  */
		/* a 0 Ohm resistor. There is an option to add a shunt 10k to GND  */
		/* on this trace but it is depop. Adding shunt resistance on the   */
		/* TSSI line may affect the voltage from the FEM to our TSSI input */
		/* So, this issue is worked around by forcing below registers      */
		/* THIS IS APPLICABLE FOR BOARDTYPE = $def(boardtype)              */
		/* --------------------------RCAL WAR ---------------------------- */
					if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
						data = ACPHY_RCAL_VAL_2X2;
					} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
						data = ACPHY_RCAL_VAL_1X1;
					}
				} else {
					if (RADIOID(pi->pubpi.radioid) != BCM20691_ID)
						wlc_phy_radio2069_rcal(pi);
				}
			}

			if (pi->u.pi_acphy->srom.rcal_war == 1 ||
				pi->u.pi_acphy->srom.rcal_otp_val_en == 1) {
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
					FOREACH_CORE(pi, core) {
						MOD_RADIO_REGC(pi, GE32_BG_CFG1, core,
						               rcal_trim, data);
						MOD_RADIO_REGC(pi, GE32_OVR2, core,
						               ovr_bg_rcal_trim, 1);
						MOD_RADIO_REGC(pi, GE32_OVR2, core,
						               ovr_otp_rcal_sel, 0);
					}
				} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
					MOD_RADIO_REG(pi, RFP,  GE16_BG_CFG1, rcal_trim, data);
					MOD_RADIO_REG(pi, RFP,  GE16_OVR2, ovr_bg_rcal_trim, 1);
					MOD_RADIO_REG(pi, RFP,  GE16_OVR2, ovr_otp_rcal_sel, 0);
				}
			}

			if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
				wlc_phy_radio20691_rccal(pi);
			else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
				wlc_phy_radio20693_rccal(pi);
			else
				wlc_phy_radio2069_rccal(pi);

			if (pi_ac->init_done) {
			  wlc_phy_set_regtbl_on_pwron_acphy(pi);
			  wlc_phy_chanspec_set_acphy(pi, pi->radio_chanspec);
			}
			pi->radio_is_on = TRUE;
		}
	} else {
		/* wlc_phy_radio2069_off(); */
		pi->radio_is_on = FALSE;

		ACPHY_REG_LIST_START
			/* FEM */
			ACPHYREG_BCAST_ENTRY(pi, RfctrlIntc0, 0)

			/* AFE */
			ACPHYREG_BCAST_ENTRY(pi, RfctrlCoreAfeCfg10, 0)
			ACPHYREG_BCAST_ENTRY(pi, RfctrlCoreAfeCfg20, 0)
			ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideAfeCfg0, 0x1fff)

			/* Radio RX */
			ACPHYREG_BCAST_ENTRY(pi, RfctrlCoreRxPus0, 0)
			ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideRxPus0, 0xffff)

			/* Radio TX */
			ACPHYREG_BCAST_ENTRY(pi, RfctrlCoreTxPus0, 0)
			ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideTxPus0, 0x3ff)

			/* {radio, rfpll, pllldo}_pu = 0 */
			MOD_PHYREG_ENTRY(pi, RfctrlCmd, chip_pu, 0)
		ACPHY_REG_LIST_EXECUTE(pi);

		/* SW4345-58 */
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
			FOREACH_CORE(pi, core) {
				MOD_RADIO_REG_20691(pi, PMU_OP, core, wlpmu_en, 0);
			}
		}

		/* Turn off the mini PMU enable on all cores when going down.
		 * Will be powered up in the UP sequence
		 */
		if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
				FOREACH_CORE(pi, core)
				        MOD_RADIO_REGC(pi, GE32_PMU_OP, core, wlpmu_en, 0);
			}
		}

		WRITE_PHYREG(pi, RfctrlCoreGlobalPus, 0);
		WRITE_PHYREG(pi, RfctrlOverrideGlobalPus, 0x1);

		if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID) {
		    ACPHY_REG_LIST_START
			/* WAR for XTAL power up issues */
			MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_xtal_pu_corebuf_pfd, 1)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_pfddrv, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_corebuf_pfd, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_BT, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL1, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_caldrv, 0)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	if ((CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
	     !CST4335_CHIPMODE_USB20D(pi->sh->sih->chipst)) ||
	    (BCM4350_CHIP(pi->sh->chip) &&
	     !CST4350_CHIPMODE_HSIC20D(pi->sh->sih->chipst))) {
		/* Power down HSIC */
		ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
			MOD_RADIO_REG(pi, RFP,  GE16_PLL_XTAL2, xtal_pu_HSIC, 0x0);
		}
	} else if ((CHIPID(pi->sh->chip) == BCM4345_CHIP_ID &&
	           !CST4345_CHIPMODE_USB20D(pi->sh->sih->chipst))) {
		/* Power down HSIC */
		ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);
		if (RADIO20691_MAJORREV(pi->pubpi.radiomajorrev) != 0) {
			FOREACH_CORE(pi, core) {
				MOD_RADIO_REG_20691(pi, PLL_XTAL2, core, xtal_pu_HSIC, 0x0);
				MOD_RADIO_REG_20691(pi, PLL_XTAL_OVR1, core, ovr_xtal_pu_HSIC, 0x1);
			}
		}
	}

#ifdef LOW_TX_CURRENT_SETTINGS_2G
/* TODO: iPa low power in 2G - check if condition is needed) */
	if ((CHSPEC_IS2G(pi->radio_chanspec) && (pi->sh->extpagain2g == 2)) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && (pi->sh->extpagain5g == 2))) {
		is_ipa = 1;
	} else {
		is_ipa = 0;
	}

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) && (is_ipa == 0)) {
		PHY_TRACE(("Modifying PA Bias settings for lower power for 2G!\n"));
		MOD_RADIO_REG(pi, RFX, PA2G_IDAC2, pa2g_biasa_main, 0x36);
		MOD_RADIO_REG(pi, RFX, PA2G_IDAC2, pa2g_biasa_aux, 0x36);
	}

#endif /* LOW_TX_CURRENT_SETTINGS_2G */
}
static void
wlc_phy_radio2069_mini_pwron_seq_rev16(phy_info_t *pi)
{
	uint8 cntr = 0;

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, wlpmu_en, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, VCOldo_pu, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, TXldo_pu, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, AFEldo_pu, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, RXldo_pu, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	OSL_DELAY(100);

	/* WAR for XTAL power up issues */
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_xtal_pu_corebuf_pfd, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_pfddrv, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_BT, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_caldrv, 1)

		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, synth_pwrsw_en, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, wlpmu_ldobg_clk_en, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, ldoref_start_cal, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	if (!ISSIM_ENAB(pi->sh->sih)) {
		while (READ_RADIO_REGFLD(pi, RFP, GE16_PMU_STAT, ldobg_cal_done) == 0) {
			OSL_DELAY(100);
			cntr++;
			if (cntr > 100) {
				PHY_ERROR(("PMU cal Fail \n"));
				break;
			}
		}
	}

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, ldoref_start_cal, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PMU_OP, wlpmu_ldobg_clk_en, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_radio2069_mini_pwron_seq_rev32(phy_info_t *pi)
{

	uint8 cntr = 0;
	write_radio_reg(pi, RFX_2069_GE32_PMU_OP, 0x9e);

	OSL_DELAY(100);

	ACPHY_REG_LIST_START
		WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_PMU_OP, 0xbe)

		WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_PMU_OP, 0x20be)
		WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_PMU_OP, 0x60be)
	ACPHY_REG_LIST_EXECUTE(pi);

	if (!ISSIM_ENAB(pi->sh->sih)) {
		while (READ_RADIO_REGFLD(pi, RF0, GE32_PMU_STAT, ldobg_cal_done) == 0 ||
		       READ_RADIO_REGFLD(pi, RF1, GE32_PMU_STAT, ldobg_cal_done) == 0) {

			OSL_DELAY(100);
			cntr++;
			if (cntr > 100) {
				PHY_ERROR(("PMU cal Fail ...222\n"));
				break;
			}
		}
	}
	write_radio_reg(pi, RFX_2069_GE32_PMU_OP, 0xbe);
}

void
wlc_phy_radio2069_pwrdwn_seq(phy_info_t *pi)
{

	/* AFE */
	pi->u.pi_acphy->afeRfctrlCoreAfeCfg10 = READ_PHYREG(pi, RfctrlCoreAfeCfg10);
	pi->u.pi_acphy->afeRfctrlCoreAfeCfg20 = READ_PHYREG(pi, RfctrlCoreAfeCfg20);
	pi->u.pi_acphy->afeRfctrlOverrideAfeCfg0 = READ_PHYREG(pi, RfctrlOverrideAfeCfg0);
	ACPHY_REG_LIST_START
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreAfeCfg10, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreAfeCfg20, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlOverrideAfeCfg0, 0x1fff)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Radio RX */
	pi->u.pi_acphy->rxRfctrlCoreRxPus0 = READ_PHYREG(pi, RfctrlCoreRxPus0);
	pi->u.pi_acphy->rxRfctrlOverrideRxPus0 = READ_PHYREG(pi, RfctrlOverrideRxPus0);
	WRITE_PHYREG(pi, RfctrlCoreRxPus0, 0x40);
	WRITE_PHYREG(pi, RfctrlOverrideRxPus0, 0xffbf);

	/* Radio TX */
	pi->u.pi_acphy->txRfctrlCoreTxPus0 = READ_PHYREG(pi, RfctrlCoreTxPus0);
	pi->u.pi_acphy->txRfctrlOverrideTxPus0 = READ_PHYREG(pi, RfctrlOverrideTxPus0);
	WRITE_PHYREG(pi, RfctrlCoreTxPus0, 0);
	WRITE_PHYREG(pi, RfctrlOverrideTxPus0, 0x3ff);

	/* {radio, rfpll, pllldo}_pu = 0 */
	pi->u.pi_acphy->radioRfctrlCmd = READ_PHYREG(pi, RfctrlCmd);
	pi->u.pi_acphy->radioRfctrlCoreGlobalPus = READ_PHYREG(pi, RfctrlCoreGlobalPus);
	pi->u.pi_acphy->radioRfctrlOverrideGlobalPus = READ_PHYREG(pi, RfctrlOverrideGlobalPus);
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, RfctrlCmd, chip_pu, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreGlobalPus, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlOverrideGlobalPus, 0x1)
	ACPHY_REG_LIST_EXECUTE(pi);
}

void
wlc_phy_radio2069_pwrup_seq(phy_info_t *pi)
{

	/* AFE */
	WRITE_PHYREG(pi, RfctrlCoreAfeCfg10, pi->u.pi_acphy->afeRfctrlCoreAfeCfg10);
	WRITE_PHYREG(pi, RfctrlCoreAfeCfg20, pi->u.pi_acphy->afeRfctrlCoreAfeCfg20);
	WRITE_PHYREG(pi, RfctrlOverrideAfeCfg0, pi->u.pi_acphy->afeRfctrlOverrideAfeCfg0);

	/* Restore Radio RX */
	WRITE_PHYREG(pi, RfctrlCoreRxPus0, pi->u.pi_acphy->rxRfctrlCoreRxPus0);
	WRITE_PHYREG(pi, RfctrlOverrideRxPus0, pi->u.pi_acphy->rxRfctrlOverrideRxPus0);

	/* Radio TX */
	WRITE_PHYREG(pi, RfctrlCoreTxPus0, pi->u.pi_acphy->txRfctrlCoreTxPus0);
	WRITE_PHYREG(pi, RfctrlOverrideTxPus0, pi->u.pi_acphy->txRfctrlOverrideTxPus0);

	/* {radio, rfpll, pllldo}_pu = 0 */
	WRITE_PHYREG(pi, RfctrlCmd, pi->u.pi_acphy->radioRfctrlCmd);
	WRITE_PHYREG(pi, RfctrlCoreGlobalPus, pi->u.pi_acphy->radioRfctrlCoreGlobalPus);
	WRITE_PHYREG(pi, RfctrlOverrideGlobalPus, pi->u.pi_acphy->radioRfctrlOverrideGlobalPus);
}

static void
wlc_phy_set_lowpwr_phy_reg(phy_info_t *pi)
{
	/* These guys not required for tiny based phys */
	if (!TINY_RADIO(pi)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_gm, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_gm_2nd, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_qb, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_qb_2nd, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_qtx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_itx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_qrx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_irx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_buf, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_mix, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5g, idac_div, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5g, idac_vcob, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gbufs, idac_bufb, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5g, idac_mixb, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5g, idac_load, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gbufs, idac_buf2, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gbufs, idac_bufb2, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gbufs, idac_buf1, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gbufs, idac_bufb1, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen5gQI, idac_qtx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen5gQI, idac_itx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen5gQI, idac_qrx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_logen5gQI, idac_irx, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcocal, vcocal_rstn, 0x1)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcocal, vcocal_force_caps, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcocal, vcocal_force_caps_val, 0x40)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_ALC_ref_ctrl, 0xd)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_bias_mode, 0x1)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_cvar_extra, 0xb)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_cvar, 0xf)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_en_alc, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_tempco_dcadj, 0xe)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_tempco, 0xb)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_cal_en, 0x1)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_cal_en_empco, 0x1)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_cap_mode, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_ib_ctrl, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_por, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_r1, lf_r1, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_r2r3, lf_r2, 0xc)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_r2r3, lf_r3, 0xc)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cm, lf_rs_cm, 0xff)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cm, lf_rf_cm, 0xc)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cSet1, lf_c1, 0x99)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cSet1, lf_c2, 0x8b)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cSet2, lf_c3, 0x8b)
			MOD_PHYREG_ENTRY(pi, radio_pll_lf_cSet2, lf_c4, 0x8f)
			MOD_PHYREG_ENTRY(pi, radio_pll_cp, cp_kpd_scale, 0x34)
			MOD_PHYREG_ENTRY(pi, radio_pll_cp, cp_ioff, 0x60)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_1p2_xtalldo1p2_lowquiescenten, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_2p5_lowpwren_VCO, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_2p5_lowquiescenten_VCO_aux, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_2p5_lowpwren_VCO_aux, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_2p5_lowquiescenten_CP, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_ldo, ldo_2p5_lowquiescenten_VCO, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna2g, lna2g_lna1_bias_idac, 0x2)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna2g, lna2g_lna2_aux_bias_idac, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna2g, lna2g_lna2_main_bias_idac, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna5g, lna5g_lna1_bias_idac, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna5g, lna5g_lna2_aux_bias_idac, 0x7)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_lna5g, lna5g_lna2_main_bias_idac, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_rxmix, rxmix2g_aux_bias_idac, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_rxmix, rxmix2g_main_bias_idac, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_rxmix, rxmix5g_gm_aux_bias_idac_i, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxrf_rxmix, rxmix5g_gm_main_bias_idac_i, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_tia, tia_DC_Ib1, 0x6)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_tia, tia_DC_Ib2, 0x6)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_tia, tia_Ib_I, 0x6)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_tia, tia_Ib_Q, 0x6)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_bias12, lpf_bias_level1, 0x4)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_bias12, lpf_bias_level2, 0x8)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_bias34, lpf_bias_level3, 0x10)
			MOD_PHYREG_ENTRY(pi, radio_rxbb_bias34, lpf_bias_level4, 0x20)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_tempco_dcadj_1p2, 0x9)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_vctrl_buf_ical, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_ib_bias_opamp, 0x6)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_ib_bias_opamp_fastsettle, 0xf)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_bypass_vctrl_buf, 0x0)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_HDRM_CAL, 0x2)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_ICAL, 0x16)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_ICAL_1p2, 0xc)
			MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_USE_2p5V, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
}

static void
wlc_phy_set_lowpwr_phy_reg_rev3(phy_info_t *pi)
{
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_en_alc, 0x0)
		MOD_PHYREG_ENTRY(pi, radio_rxrf_lna5g, lna5g_lna1_bias_idac, 0x8)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_tempco_dcadj_1p2, 0x9)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_vctrl_buf_ical, 0x3)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_ib_bias_opamp, 0x6)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet4, vco_ib_bias_opamp_fastsettle, 0xf)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_bypass_vctrl_buf, 0x0)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_HDRM_CAL, 0x2)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet2, vco_ICAL, 0x16)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet3, vco_ICAL_1p2, 0xc)
		MOD_PHYREG_ENTRY(pi, radio_pll_vcoSet1, vco_USE_2p5V, 0x1)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, radio_logen2gN5g, idac_mix, 0x4);
	}
}

static void
wlc_phy_radio2069_pwron_seq(phy_info_t *pi)
{
	/* Note: if RfctrlCmd.rfctrl_bundle_en = 0, then rfpll_pu = radio_pu
	   So, to make rfpll_pu = 0 & radio_pwrup = 1, make RfctrlCmd.rfctrl_bundle_en = 1
	*/
	uint16 txovrd = READ_PHYREG(pi, RfctrlCoreTxPus0);
	uint16 rfctrlcmd = READ_PHYREG(pi, RfctrlCmd) & 0xfc38;

	ACPHY_REG_LIST_START
		/* Using usleep of 100us below, so don't need these */
		WRITE_PHYREG_ENTRY(pi, Pllldo_resetCtrl, 0)
		WRITE_PHYREG_ENTRY(pi, Rfpll_resetCtrl, 0)
		WRITE_PHYREG_ENTRY(pi, Logen_AfeDiv_reset, 0x2000)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Start with everything off: {radio, rfpll, plldlo, logen}_{pu, reset} = 0 */
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd);
	WRITE_PHYREG(pi, RfctrlCoreGlobalPus, 0);
	WRITE_PHYREG(pi, RfctrlOverrideGlobalPus, 0xd);
	WRITE_PHYREG(pi, RfctrlCoreTxPus0, txovrd & 0x7e7f);
	WRITE_PHYREG(pi, RfctrlOverrideTxPus0, READ_PHYREG(pi, RfctrlOverrideTxPus0) | 0x180);

	/* ***  Start Radio rfpll pwron seq  ***
	   Start with chip_pu = 0, por_reset = 0, rfctrl_bundle_en = 0
	*/
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd);

	/* Toggle jtag reset (not required for uCode PM) */
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd | 1);
	OSL_DELAY(1);
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd | 0);

	/* Update preferred values (not required for uCode PM) */
	wlc_phy_radio2069_upd_prfd_values(pi);

	/* Toggle radio_reset (while radio_pu = 1) */
	MOD_RADIO_REG(pi, RF2, VREG_CFG, bg_filter_en, 0);   /* radio_reset = 1 */
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd | 6);   /* radio_pwrup = 1, rfpll_pu = 0 */
	OSL_DELAY(100);                                      /* radio_reset to be high for 100us */
	MOD_RADIO_REG(pi, RF2, VREG_CFG, bg_filter_en, 1);   /* radio_reset = 0 */

	/* {rfpll, pllldo, logen}_{pu, reset} pwron seq */
	WRITE_PHYREG(pi, RfctrlCoreGlobalPus, 0xd);
	WRITE_PHYREG(pi, RfctrlCmd, rfctrlcmd | 2);
	WRITE_PHYREG(pi, RfctrlCoreTxPus0, txovrd | 0x180);
	OSL_DELAY(100);
	WRITE_PHYREG(pi, RfctrlCoreGlobalPus, 0x4);
	WRITE_PHYREG(pi, RfctrlCoreTxPus0, txovrd & 0xfeff);
}

static void
wlc_phy_radio20691_pwron_seq(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* Note: if RfctrlCmd.rfctrl_bundle_en = 0, then rfpll_pu = radio_pu
	   So, to make rfpll_pu = 0 & radio_pwrup = 1, make RfctrlCmd.rfctrl_bundle_en = 1
	*/
	ACPHY_REG_LIST_START
		/* # power down everything */
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreTxPus0, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlOverrideTxPus0, 0x3ff)

		/* Using usleep of 100us below, so don't need these */
		WRITE_PHYREG_ENTRY(pi, Pllldo_resetCtrl, 0)
		WRITE_PHYREG_ENTRY(pi, Rfpll_resetCtrl, 0)
		WRITE_PHYREG_ENTRY(pi, Logen_AfeDiv_reset, 0x2000)

		/* Start with everything off: {radio, rfpll, plldlo, logen}_{pu, reset} = 0 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCmd, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreGlobalPus, 0)
		WRITE_PHYREG_ENTRY(pi, RfctrlOverrideGlobalPus, 0xd)

		/* # Reset radio, jtag */
		WRITE_PHYREG_ENTRY(pi, RfctrlCmd, 0x7)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* # radio_reset to be high for 100us */
	OSL_DELAY(100);
	WRITE_PHYREG(pi, RfctrlCmd, 0x6);

	/* Update preferred values (not required for uCode PM) */
	wlc_phy_radio20691_upd_prfd_values(pi);

	ACPHY_REG_LIST_START
		/* # {rfpll, pllldo, logen}_{pu, reset} */
		/* # pllldo_{pu, reset} = 1, rfpll_reset = 1 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreGlobalPus, 0xd)
		/* # {radio, rfpll}_pwrup = 1 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCmd, 0x2)

		/* # logen_{pwrup, reset} = 1 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreTxPus0, 0x180)
	ACPHY_REG_LIST_EXECUTE(pi);
	OSL_DELAY(100); /* # resets to be on for 100us */
	ACPHY_REG_LIST_START
		/* # {pllldo, rfpll}_reset = 0 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreGlobalPus, 0x4)
		/* # logen_reset = 0 */
		WRITE_PHYREG_ENTRY(pi, RfctrlCoreTxPus0, 0x80)
		/* # leave overrides for logen_{pwrup, reset} */
		WRITE_PHYREG_ENTRY(pi, RfctrlOverrideTxPus0, 0x180)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_switch_radio_acphy_20691(phy_info_t *pi)
{
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	ACPHY_REG_LIST_START
		/* Power-up rcal clock (need both of them for rcal) */
		/* # RCCAL driver */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 1)
		/* # RCAL driver */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL1, 1)

		/* # baseband driver */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_bbdrv, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_xtal_pu_bbdrv, 1)
		/* # VCO cal */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_caldrv, 1)
		/* # xtal core */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_core, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_xtal_pu_core, 1)

		/* # xtal core baseband buffer */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_corebuf_bb, 1)
		/*	# Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_xtal_pu_corebuf_bb, 1)
		/* # xtal core main buffer */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_corebuf_pfd, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_xtal_pu_corebuf_pfd, 1)
		/* # pfd clock driver */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_pfddrv, 1)
		/* # xtal bandgap */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTALLDO1, 0, ldo_1p2_xtalldo1p2_BG_pu, 1)
	ACPHY_REG_LIST_EXECUTE(pi);
	/* Correct xtal-ldo supply */
	MOD_RADIO_REG_20691(pi, PLL_XTALLDO1, 0, ldo_1p2_xtalldo1p2_ctl,
	                    (RADIO20691_MAJORREV(radio_rev) == 1 &&
	                     RADIO20691_MINORREV(radio_rev) > 0) ? 0xE : 0x8);
	ACPHY_REG_LIST_START
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_ldo_1p2_xtalldo1p2_BG_pu, 1)

		/* 20691_mini_pwron_seq_phyregs_rev12() */
		/* # mini PMU init */
		/* #Step 1 */
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_en, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_VCOldo_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_TXldo_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_AFEldo_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_RXldo_pu, 1)
	ACPHY_REG_LIST_EXECUTE(pi);
	/* #Step 2 */
	OSL_DELAY(200);
	MOD_RADIO_REG_20691(pi, PLL_CFG1, 0, synth_pwrsw_en, 1);

	/* #Disable remaining overrides to exercise direct controls */
	if (RADIO20691_MAJORREV(radio_rev) == 0) {
		write_radio_reg(pi, RADIO_REG_20691(pi, RX_BB_2G_OVR1, 0), 0);
		write_radio_reg(pi, RADIO_REG_20691(pi, RX_TOP_2G_OVR1, 0), 0);
	}

	ACPHY_REG_LIST_START
		/* # DAC */
		MOD_RADIO_REG_20691_ENTRY(pi, CLK_DIV_CFG1, 0, dac_driver_size, 4)
		MOD_RADIO_REG_20691_ENTRY(pi, CLK_DIV_CFG1, 0, sel_dac_div, 3)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_DAC_CFG5, 0, DAC_invclk, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_DAC_CFG5, 0, DAC_pd_mode, 0)
		/* # improve settling behavior, need for level tracking */
		MOD_RADIO_REG_20691_ENTRY(pi, BG_CFG1, 0, bg_pulse, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_DAC_CFG1, 0, DAC_scram_off, 1)

		/* # ADC */
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_CFG4, 0, wlpmu_ADCldo_pu, 1)

		/* 20691_pmu_pll_pwrup */
		MOD_RADIO_REG_20691_ENTRY(pi, VREG_CFG, 0, vreg25_pu, 1) /* #powerup vreg2p5 */
		MOD_RADIO_REG_20691_ENTRY(pi, BG_CFG1, 0, bg_pu, 1) /* #powerup bandgap */

		/* # powerup pll */
		/* # VCO */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG1, 0, rfpll_vco_pu, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_vco_pu, 1)
		/* # VCO LDO */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO1, 0, ldo_2p5_pu_ldo_VCO, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_ldo_2p5_pu_ldo_VCO, 1)
		/* # VCO buf */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG1, 0, rfpll_vco_buf_pu, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_vco_buf_pu, 1)
		/* # Synth global */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG1, 0, rfpll_synth_pu, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_synth_pu, 1)
		/* # Charge Pump */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CP1, 0, rfpll_cp_pu, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_cp_pu, 1)
		/* # Charge Pump LDO */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO1, 0, ldo_2p5_pu_ldo_CP, 1)
		/* # Enable override */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_ldo_2p5_pu_ldo_CP, 1)
		/* # PLL lock monitor */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG1, 0, rfpll_monitor_pu, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* # Nishant's hack to get PLL lock: */
	/* # spare 127 is xtal_dcc_clk_sel */
	/* # spare 127 is bit 15 of this register. Just set that bit to 1. */
	if (RADIO20691_MAJORREV(radio_rev) == 0)
		or_radio_reg(pi, RF0_20691_SPARE_CFG8(pi->pubpi.radiorev), 0x8000);
	else
		MOD_RADIO_REG_20691(pi, PLL_XTAL12, 0, xtal_dcc_clk_sel, 1);

	/* # Mods from Low to improve cbuck stability - I think they increase
	 * # the sawtooth amplitude
	 * pci w 0x18000658 4 0x0
	 * pci w 0x1800065c 4 0xc003
	 * # Put LOGEN LDO in the intended high-PSRR mode. This will make it
	 * # wobbly when the LOGEN is off, but I presume we don't care for TC.
	 * # A0 will set this automatically and won't require this write.
	 */
	MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_VCOldo_hpm, 1);

	/* minipmu_cal */
	wlc_phy_radio20691_minipmu_cal(pi);

	/* r cal */
#ifdef ATE_BUILD
	/* ATE firmware performs the rcal and the value is put in the OTP. */
	wlc_phy_radio20691_rcal(pi, 2);
#else
	wlc_phy_radio20691_rcal(pi, 1);
#endif // endif
}

/*  R Calibration (takes ~50us) */
static void
wlc_phy_radio20691_rcal(phy_info_t *pi, uint8 mode)
{
	/* Format: 20691_r_cal [<mode>] [<rcalcode>] */
	/* If no arguments given, then mode is assumed to be 1 */
	/* The rcalcode argument works only with mode 1 and is optional. */
	/* If given, then that is the rcal value what will be used in the radio. */

	/* Documentation: */
	/* Mode 0 = Don't run cal, use rcal value stored in OTP. This is what driver should */
	/* do but is not good for bringup because the OTP is not programmed yet. */
	/* Mode 1 = Don't run cal, don't use OTP rcal value, use static rcal */
	/* value given here. Good for initial bringup. */
	/* Mode 2 = Run rcal and use the return value in bandgap. Needs the external 10k */
	/* resistor to be connected to GPAIO otherwise cal will return bogus value. */

	uint8 rcal_valid, loop_iter, rcal_value;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	/* Skip this function for QT */
	if (ISSIM_ENAB(pi->sh->sih))
		return;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	if (mode == 0) {
		/* Use OTP stored rcal value */
		MOD_RADIO_REG_20691(pi, BG_OVR1, 0, ovr_otp_rcal_sel, 1);
	} else if (mode == 1) {
		/* Default RCal code to be used with mode 1 is 11 */
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, BG_CFG1, 0, bg_rcal_trim, 11)
			MOD_RADIO_REG_20691_ENTRY(pi, BG_OVR1, 0, ovr_otp_rcal_sel, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, BG_OVR1, 0, ovr_bg_rcal_trim, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else if (mode == 2) {
		ACPHY_REG_LIST_START
			/* Run R Cal and use its output */
			MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL1, 0x1)
			MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 0x1)

			/* Make connection with the external 10k resistor */
			/* Also powers up rcal (RF_rcal_cfg.rcal_pu = 1) */
			MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL2, 0, gpaio_pu, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
			MOD_RADIO_REG_20691(pi, RCAL_CFG, 0, rcal_pu, 0);
		} else {
			MOD_RADIO_REG_20691(pi, RCAL_CFG_NORTH, 0, rcal_pu, 0);
		}
		MOD_RADIO_REG_20691(pi, GPAIO_SEL0, 0, gpaio_sel_0to15_port, 0);
		MOD_RADIO_REG_20691(pi, GPAIO_SEL1, 0, gpaio_sel_16to31_port, 0);
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
			MOD_RADIO_REG_20691(pi, RCAL_CFG, 0, rcal_pu, 1);
		} else {
			MOD_RADIO_REG_20691(pi, RCAL_CFG_NORTH, 0, rcal_pu, 1);
		}

		rcal_valid = 0;
		loop_iter = 0;
		while ((rcal_valid == 0) && (loop_iter <= 100)) {
			OSL_DELAY(1000);
			if (RADIO20691_MAJORREV(radio_rev) == 0) {
				rcal_valid = READ_RADIO_REGFLD_20691(pi, RCAL_CFG, 0, rcal_valid);
			} else {
				rcal_valid = READ_RADIO_REGFLD_20691(pi, RCAL_CFG_NORTH, 0,
				                                     rcal_valid);
			}
			loop_iter ++;
		}

		if (rcal_valid == 1) {
			if (RADIO20691_MAJORREV(radio_rev) == 0) {
				rcal_value  = READ_RADIO_REGFLD_20691(pi, RCAL_CFG, 0, rcal_value);
			} else {
				rcal_value = READ_RADIO_REGFLD_20691(pi, RCAL_CFG_NORTH, 0,
				                                     rcal_value);
			}
			rcal_value = rcal_value >> 1;

			/* Use the output of the rcal engine */
			MOD_RADIO_REG_20691(pi, BG_OVR1, 0, ovr_otp_rcal_sel, 0);
			MOD_RADIO_REG_20691(pi, BG_OVR1, 0, ovr_bg_rcal_trim,  0);

			/* Very coarse sanity check */
			if ((rcal_value < 2) || (12 < rcal_value)) {
				PHY_ERROR(("*** ERROR: R Cal value out of range. 4bit Rcal = %d.\n",
				 rcal_value));
			}
		} else {
			PHY_ERROR(("%s RCal unsucessful. RCal valid bit is %d.\n",
				__FUNCTION__, rcal_valid));
		}

		ACPHY_REG_LIST_START
			/* Power down blocks not needed anymore */
			MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL2, 0, gpaio_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL1, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL,  0)
		ACPHY_REG_LIST_EXECUTE(pi);
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
			MOD_RADIO_REG_20691(pi, RCAL_CFG, 0, rcal_pu, 0);
		} else {
			MOD_RADIO_REG_20691(pi, RCAL_CFG_NORTH, 0, rcal_pu, 0);
		}
	}
}

static int8
wlc_phy_radio20691_minipmu_cal(phy_info_t *pi)
{
	/* <vipulk>: This proc does a mini-PMU cal. Should be run before rcal. */
	uint8 waitcounter = 0;
	uint8 calsuccesful = 1;
	int8 calvalue = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	ACPHY_REG_LIST_START
		/* Setup the cal */
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_CFG3, 0, wlpmu_selavg, 2)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_OP, 0, wlpmu_vref_select, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_CFG2, 0, wlpmu_bypcal, 0)

	/* We need to make sure cal_done is 0 before we can use it to check if pmu cal is done */
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_STAT, 0, wlpmu_ldobg_cal_clken, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
	OSL_DELAY(100);
	MOD_RADIO_REG_20691(pi, PMU_OP, 0, wlpmu_ldoref_start_cal, 1);
	OSL_DELAY(100);
	MOD_RADIO_REG_20691(pi, PMU_OP, 0, wlpmu_ldoref_start_cal, 0);
	OSL_DELAY(100);

	/* Start cal */
	MOD_RADIO_REG_20691(pi, PMU_STAT, 0, wlpmu_ldobg_cal_clken, 1);
	OSL_DELAY(100);
	MOD_RADIO_REG_20691(pi, PMU_OP, 0, wlpmu_ldoref_start_cal, 1);

	/* Wait for cal_done */
	while (READ_RADIO_REGFLD_20691(pi, PMU_STAT, 0, wlpmu_ldobg_cal_done) == 0) {
		OSL_DELAY(100);
		waitcounter ++;
		if (waitcounter > 100) {
			/* This means the cal_done bit is not 1 even after waiting a while. */
			PHY_INFORM(("\nWarning : Mini PMU Cal Failed\n"));
			calsuccesful = 0;
			break;
		}
	}

	/* Cleanup */
	MOD_RADIO_REG_20691(pi, PMU_OP, 0, wlpmu_ldoref_start_cal, 0);
	MOD_RADIO_REG_20691(pi, PMU_STAT, 0, wlpmu_ldobg_cal_clken, 0);

	if (calsuccesful == 1) {
		calvalue = READ_RADIO_REGFLD_20691(pi, PMU_STAT, 0, wlpmu_calcode);
	} else {
		calvalue = -1;
	}

#ifdef ATE_BUILD
	ate_buffer_regval.pmucalcode = (int32) calvalue;
#endif // endif

	return calvalue;
}

static void
wlc_phy_radio2069_upd_prfd_values(phy_info_t *pi)
{
	uint8 core;
	radio_20xx_prefregs_t *prefregs_2069_ptr = NULL;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	switch (RADIOREV(pi->pubpi.radiorev)) {
	case 3:
		prefregs_2069_ptr = prefregs_2069_rev3;
		break;
	case 4:
	case 8:
		prefregs_2069_ptr = prefregs_2069_rev4;
		break;
	case 7:
	case 10:
	case 11:
		prefregs_2069_ptr = prefregs_2069_rev4;
		break;
	case 16:
		prefregs_2069_ptr = prefregs_2069_rev16;
		break;
	case 17:
		prefregs_2069_ptr = prefregs_2069_rev17;
		break;
	case 18:
		prefregs_2069_ptr = prefregs_2069_rev18;
		break;
	case 23:
		prefregs_2069_ptr = prefregs_2069_rev23;
		break;
	case 24:
		prefregs_2069_ptr = prefregs_2069_rev24;
		break;
	case 25:
		prefregs_2069_ptr = prefregs_2069_rev25;
		break;
	case 26:
		prefregs_2069_ptr = prefregs_2069_rev26;
		break;
	case 32:
	case 33:
	case 34:
	case 35:
	case 37:
	case 38:
		prefregs_2069_ptr = prefregs_2069_rev33_37;
		break;
	case 39:
	case 40:
	case 41:
	case 44:
	case 46:
		prefregs_2069_ptr = prefregs_2069_rev39;
		break;
	case 36:
	case 42:
	case 43:
	case 45:
		prefregs_2069_ptr = prefregs_2069_rev36;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
			pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
		ASSERT(0);
		return;
	}

	/* Update preferred values */
	wlc_phy_init_radio_prefregs_allbands(pi, prefregs_2069_ptr);

	if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		BFL_SROM11_WLAN_BT_SH_XTL) {
		MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_BT, 1);
	}

	/* **** NOTE : Move the following to XLS (whenever possible) *** */

	/* Reg conflict with 2069 rev 16 */
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_rst_n, 1)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_en_vcocal, 1)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR16, ovr_rfpll_vcocal_rstn, 1)

			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_cal_rst_n, 1)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_pll_pu, 1)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_vcocal_cal, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_en_vcocal, 1)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR17, ovr_rfpll_vcocal_rstn, 1)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_rst_n, 1)

				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_cal_rst_n, 1)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_pll_pu, 1)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_vcocal_cal, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
		}

		/* Until this is moved to XLS (give bg_filter_en control to radio) */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			MOD_RADIO_REG(pi, RFP, GE32_OVR1, ovr_vreg_bg_filter_en, 1);
		}

		/* Ensure that we read the values that are actually applied */
		/* to the radio block and not just the radio register values */

		write_radio_reg(pi, RFX_2069_GE16_READOVERRIDES, 1);
		MOD_RADIO_REG(pi, RFP, GE16_READOVERRIDES, read_overrides, 1);

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			/* For VREG power up in radio jtag as there is a bug in the digital
			 * connection
			 */
			if (RADIOMINORREV(pi->pubpi.radiominorrev) < 5) {
				MOD_RADIO_REG(pi, RF2, VREG_CFG, pup, 1);
				MOD_RADIO_REG(pi, RFP, GE32_OVR1, ovr_vreg_pup, 1);
			}

			/* This OVR enable is required to change the value of
			 * reg(RFP_pll_xtal4.xtal_outbufstrg) and used the value from the
			 * jtag. Otherwise the direct control from the chip has a fixed
			 * non-programmable value!
			 */
			MOD_RADIO_REG(pi, RFP, GE16_OVR27, ovr_xtal_outbufstrg, 1);
		}
	}

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) < 2) {
		MOD_RADIO_REG(pi, RF2, BG_CFG1, bg_pulse, 1);
	}
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, GE32_BG_CFG1, core, bg_pulse, 1);
			MOD_RADIO_REGC(pi, GE32_OVR2, core, ovr_bg_pulse, 1);
		}
	}

	/* Give control of bg_filter_en to radio */
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) < 2)
		MOD_RADIO_REG(pi, RF2, OVR2, ovr_vreg_bg_filter_en, 1);

	FOREACH_CORE(pi, core) {
		/* Fang's recommended settings */
		MOD_RADIO_REGC(pi, ADC_RC1, core, adc_ctl_RC_9_8, 1);
		MOD_RADIO_REGC(pi, ADC_RC2, core, adc_ctrl_RC_17_16, 2);

		/* These should be 0, as they are controlled via direct control lines
		   If they are 1, then during 5g, they will turn on
		*/
		MOD_RADIO_REGC(pi, PA2G_CFG1, core, pa2g_bias_cas_pu, 0);
		MOD_RADIO_REGC(pi, PA2G_CFG1, core, pa2g_2gtx_pu, 0);
		MOD_RADIO_REGC(pi, PA2G_CFG1, core, pa2g_bias_pu, 0);
		MOD_RADIO_REGC(pi, PAD2G_CFG1, core, pad2g_pu, 0);
	}
		/* SWWLAN-39535  LNA1 clamping issue for 4360b1 and 43602a0 */
	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) &&
		((RADIOREV(pi->pubpi.radiorev) == 7) || (RADIOREV(pi->pubpi.radiorev == 8)))) {
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, RXRF5G_CFG1, core, pu_pulse, 1);
			MOD_RADIO_REGC(pi, OVR18, core, ovr_rxrf5g_pu_pulse, 1);
		}
	}
}
static void
wlc_phy_radio20691_upd_prfd_values(phy_info_t *pi)
{
	radio_20xx_prefregs_t *prefregs_20691_ptr = NULL;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		BFL_SROM11_WLAN_BT_SH_XTL) {
		MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_BT, 1);
	}

	/* Choose the right table to use */
	switch (RADIOREV(radio_rev)) {
	case 18:
		prefregs_20691_ptr = prefregs_20691_rev18;
		break;
	case 27:
		prefregs_20691_ptr = prefregs_20691_rev27;
		break;
	case 30:
		prefregs_20691_ptr = prefregs_20691_rev30;
		break;
	case 31:
		prefregs_20691_ptr = prefregs_20691_rev31;
		break;
	case 32:
		prefregs_20691_ptr = prefregs_20691_rev32;
		break;
	case 48:
		prefregs_20691_ptr = prefregs_20691_rev48;
		break;
	case 50:
		prefregs_20691_ptr = prefregs_20691_rev50;
		break;
	case 60:
	case 68:
		prefregs_20691_ptr = prefregs_20691_rev68;
		break;
	case 75:
		prefregs_20691_ptr = prefregs_20691_rev75;
		break;
	case 79:
		prefregs_20691_ptr = prefregs_20691_rev79;
		break;
	case 74:
	case 82:
		prefregs_20691_ptr = prefregs_20691_rev82;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
			pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
		ASSERT(FALSE);
		return;
	}

	/* Update preferred values */
	wlc_phy_init_radio_prefregs_allbands(pi, prefregs_20691_ptr);

	MOD_RADIO_REG_20691(pi, LOGEN_OVR1, 0, ovr_logencore_5g_en_lowband, 0x1);
	MOD_RADIO_REG_20691(pi, LOGEN_CFG2, 0, logencore_5g_en_lowband, 0x0);

	if ((RADIO20691_MAJORREV(radio_rev) != 0) && !PHY_IPA(pi)) {
	    ACPHY_REG_LIST_START
		/* Saeed's settings for aband epa evm tuning */
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG1, 0, mx5g_idac_bleed_bias, 0x1f)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG5, 0, mx5g_idac_bbdc, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG5, 0, mx5g_idac_lodc, 0xf)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0xa)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_main, 0x17)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC3, 0, pa5g_idac_tuning_bias, 0xf)

		/* Utku's second setting for gband epa evm tuning */
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_IDAC2, 0, pad2g_idac_tuning_bias, 6)
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_INCAP, 0, pa2g_idac_incap_compen_main, 0x2c)
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_IDAC1, 0, pa2g_idac_main, 0x24)
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_IDAC1, 0, pa2g_idac_cas, 0x2b)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG2, 0, mx2g_idac_cascode, 0xc)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN2G_CFG1, 0, logen2g_tx_xover, 4)
		MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG1, 0, logencore_lcbuf_stg1_bias, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_lcbuf_stg2_bias, 7)
		MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG1, 0, logencore_lcbuf_stg1_ftune, 0x18)

		/* A band EVM floor tuning, dfu, cfraser */
		MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_EAST, 0, ovr_tx2g_bias_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX2G_CFG1, 0, tx2g_bias_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LPF_CFG3, 0, lpf_sel_2g_5g_cmref_gm, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG3, 0, mx5g_pu_bleed, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0x8)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pad5g_idac_pmos, 0x18)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_main, 0x1a)
		MOD_RADIO_REG_20691_ENTRY(pi, TXGM5G_CFG1, 0, pad5g_idac_cascode, 0xf)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}
	if ((RADIO20691_MAJORREV(radio_rev) == 1) && !PHY_IPA(pi) &&
		(RADIO20691_MINORREV(radio_rev) == 1)) {
		MOD_RADIO_REG_20691(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0xd);
	}

	/*  PA gm and PAD gm bias changes for 43457 */
	if ((RADIO20691_MAJORREV(radio_rev) == 1) && !PHY_IPA(pi) &&
		(RADIO20691_MINORREV(radio_rev) == 1)) {
		MOD_RADIO_REG_20691(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0xd);
		MOD_RADIO_REG_20691(pi, PLL_XTALLDO1, 0, ldo_1p2_xtalldo1p2_ctl, 0xe);
	}
	if ((RADIO20691_MAJORREV(radio_rev) == 1) && PHY_IPA(pi)) {
	    ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_INCAP, 0, pa2g_idac_incap_compen_main, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, PA2G_IDAC1, 0, pa2g_idac_cas, 0x20)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_main, 0x18)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR2, 0, ovr_mx5g_pu_lodc_loop, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG4, 0, mx5g_pu_lodc_loop, 0x1)
		/* For iPA PAPD and temperature-dependent iq cal */
		MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_logen5g_tx_reset, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0, logen5g_tx_reset, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG5, 0, mx5g_idac_bbdc, 0x3f)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG5, 0, mx5g_idac_lodc, 0xf)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG1, 0, mx5g_idac_bleed_bias, 0x1f)
		/* MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG3, 0, pa5g_ptat_slope_main, 0xf) */
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0, logen5g_tx_bias_q_5g_quad, 0x7)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0, logen5g_tx_bias_i_5g_quad, 0x7)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG4, 0, mix5g_IQ_bias_short, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_main, 0x20)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pa5g_idac_incap_compen_main, 0x1a)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG2, 0, pa5g_bias_filter_main, 0xc)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG2, 0, pa5g_bias_filter_aux, 0x5)
		/* MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG2, 0, pa5g_bias_cas, 0x8) */
		MOD_PHYREG_ENTRY(pi, fdiqImbCompEnable, txfdiqImbCompEnable, 1)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c0, c0, 1023)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c1, c1, 5)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c2, c2, 1011)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c3, c3, 1023)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c4, c4, 13)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c5, c5, 1019)
		MOD_PHYREG_ENTRY(pi, txfdiqcomp_str0_c6, c6, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_EAST, 0, ovr_tx2g_bias_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX2G_CFG1, 0, tx2g_bias_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TX_LPF_CFG3, 0, lpf_sel_2g_5g_cmref_gm, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0x3f)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0x18)
		MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG3, 0, mx5g_pu_bleed, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pad5g_idac_pmos, 0x20)
	    ACPHY_REG_LIST_EXECUTE(pi);
	    if ((RADIOREV(pi->pubpi.radiorev) == 82) ||
	        (RADIOREV(pi->pubpi.radiorev) == 79)) {
		ACPHY_REG_LIST_START
		    /* 43453b1 fcbga/wlbga ipa */
		    MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_main, 0x18)
		    MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0x12)
		    MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0x26)
		    MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG4, 0, mx5g_idac_cascode, 0xa)
		    MOD_RADIO_REG_20691_ENTRY(pi, TXGM5G_CFG1, 0, pad5g_idac_cascode, 0x8)
		    MOD_RADIO_REG_20691_ENTRY(pi, PA5G_IDAC1, 0, pa5g_idac_cas, 0x16)
		    ACPHY_REG_LIST_EXECUTE(pi);
	    } else {
		MOD_RADIO_REG_20691(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0x3f);
	    }
	    MOD_RADIO_REG_20691(pi, PA5G_CFG3, 0, pa5g_ptat_slope_main, 0xf);
	}
}

#ifndef WLC_DISABLE_ACI
static uint16 hwaci_fcbs_rfregs[5];
static uint16 hwaci_fcbs_phyregs[14];
#define FCBS_1DATA_PER_ADDR  0x2000
static  hwaci_fcbs_phytbl_list_entry  hwaci_fcbs_phytbls [ ] = {
	{ ACPHY_TBL_ID_RFSEQ | FCBS_1DATA_PER_ADDR,       0x0f6, 1 },
	{ ACPHY_TBL_ID_RFSEQ | FCBS_1DATA_PER_ADDR,		 0x0f9, 1 },
	{ ACPHY_TBL_ID_GAINLIMIT | FCBS_1DATA_PER_ADDR,	 0x008, 7 },
	{ ACPHY_TBL_ID_GAINLIMIT | FCBS_1DATA_PER_ADDR,	 0x048, 7 },
	{ ACPHY_TBL_ID_GAIN0 | FCBS_1DATA_PER_ADDR,		 0x008, 8 },
	{ ACPHY_TBL_ID_GAINBITS0 | FCBS_1DATA_PER_ADDR,	 0x008, 8 },
	{ 0xFFFF,	 0x000, 0 }
};

static void
wlc_phy_hwaci_fcbsinit_acphy(phy_info_t *pi)
{
	hwaci_fcbs_rfregs[0] = RF0_20691_LNA2G_RSSI1(pi->pubpi.radiorev);
	hwaci_fcbs_rfregs[1] = RF0_20691_LNA5G_RSSI1(pi->pubpi.radiorev);
	hwaci_fcbs_rfregs[2] = RF0_20691_TIA_CFG13(pi->pubpi.radiorev);
	hwaci_fcbs_rfregs[3] = RF0_20691_TIA_CFG12(pi->pubpi.radiorev);
	hwaci_fcbs_rfregs[4] = 0xFFFF;

	hwaci_fcbs_phyregs[0] = ACPHY_Core0clip2GainCodeA(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[1] = ACPHY_Core0clipHiGainCodeA(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[2] = ACPHY_Core0cliploGainCodeA(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[3] = ACPHY_Core0clipmdGainCodeA(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[4] = ACPHY_Core0InitGainCodeA(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[5] = ACPHY_Core0clip2GainCodeB(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[6] = ACPHY_Core0clipHiGainCodeB(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[7] = ACPHY_Core0cliploGainCodeB(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[8] = ACPHY_Core0clipmdGainCodeB(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[9] = ACPHY_Core0InitGainCodeB(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[10] = ACPHY_Core0DSSScckPktGain(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[11] = ACPHY_Core0HpFBw(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[12] = ACPHY_Core0RssiClipMuxSel(pi->pubpi.phy_rev);
	hwaci_fcbs_phyregs[13] = 0xFFFF;
}

#endif /* WLC_DISABLE_ACI */

#define afe_fcbs_rfregs_size  8
static uint16 afe_fcbs_rfregs[afe_fcbs_rfregs_size+1];
static uint16 afe_fcbs_phyregs[5];
static uint16 afe_fcbs_mask[afe_fcbs_rfregs_size];

static void
wlc_phy_afe_fcbsinit_acphy(phy_info_t *pi)
{
	afe_fcbs_rfregs[0] = RF0_20691_ADC_CFG17(pi->pubpi.radiorev);
	afe_fcbs_rfregs[1] = RF0_20691_ADC_CFG16(pi->pubpi.radiorev);
	afe_fcbs_rfregs[2] = RF0_20691_ADC_CFG4(pi->pubpi.radiorev);
	afe_fcbs_rfregs[3] = RF0_20691_ADC_CFG3(pi->pubpi.radiorev);
	afe_fcbs_rfregs[4] = RF0_20691_ADC_CFG6(pi->pubpi.radiorev);
	afe_fcbs_rfregs[5] = RF0_20691_ADC_CFG2(pi->pubpi.radiorev);
	afe_fcbs_rfregs[6] = RF0_20691_ADC_CFG19(pi->pubpi.radiorev);
	afe_fcbs_rfregs[7] = RF0_20691_ADC_CFG15(pi->pubpi.radiorev);
	afe_fcbs_rfregs[8] = 0xFFFF;
	afe_fcbs_phyregs[0] = ACPHY_RxSdFeConfig3(pi->pubpi.phy_rev);
	afe_fcbs_phyregs[1] = ACPHY_RxSdFeConfig2(pi->pubpi.phy_rev);
	afe_fcbs_phyregs[2] = ACPHY_RxSdFeSampCap(pi->pubpi.phy_rev);
	afe_fcbs_phyregs[3] = ACPHY_ACI_Mitigation_CTRL1(pi->pubpi.phy_rev);
	afe_fcbs_phyregs[4] = 0xFFFF;
	afe_fcbs_mask[0] = 0x007f;
	afe_fcbs_mask[1] = 0x3fff;
	afe_fcbs_mask[2] = 0x007f;
	afe_fcbs_mask[3] = 0x3fff;
	afe_fcbs_mask[4] = 0x00ff;
	afe_fcbs_mask[5] = 0x007f;
	afe_fcbs_mask[6] = 0x007f;
	afe_fcbs_mask[7] = 0x0008;
}

#ifdef ENABLE_FCBS
/* List of all PHY TBL segments to be saved during FCBS */
static fcbs_phytbl_list_entry fcbs_phytbl16_list_acphy [ ] =
{
	{ ACPHY_TBL_ID_RFSEQ, 0x30, 6 },
	{ ACPHY_TBL_ID_RFSEQ, 0x40, 6 },
	{ ACPHY_TBL_ID_RFSEQ, 0x50, 6 },
	{ ACPHY_TBL_ID_RFSEQ, 0xa0, 5 },
	{ ACPHY_TBL_ID_RFSEQ, 0xb0, 5 },
	{ ACPHY_TBL_ID_RFSEQ, 0xc0, 4 },
	{ ACPHY_TBL_ID_RFSEQ, 0xF9, 3 },
	{ ACPHY_TBL_ID_RFSEQ, 0x100, 9 },
	{ ACPHY_TBL_ID_RFSEQ, 0x14a, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x15a, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x16a, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x18e, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3cd, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3cf, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3dd, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3df, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3ed, 1 },
	{ ACPHY_TBL_ID_RFSEQ, 0x3ef, 1 },
	{ ACPHY_TBL_ID_NVRXEVMSHAPINGTBL, 0x1, 3},
	{ ACPHY_TBL_ID_NVRXEVMSHAPINGTBL, 0x3d, 3},
	{0xFFFF, 0xFFFF, 0}
};

/* List of all Radio regs to be saved during FCBS */
static fcbs_radioreg_core_list_entry fcbs_radioreg_list_acphy [ ] =
{
	{ RF1_2069_REV0_TXGM_LOFT_COARSE_I, 0x1 },
	{ RF0_2069_REV0_TXGM_LOFT_COARSE_Q, 0x0 },
	{ RF2_2069_REV0_TXGM_LOFT_FINE_I, 0x2   },
	{ RFP_2069_REV0_PLL_ADC4, 0x4           },
	{ RF0_2069_REV0_TXGM_LOFT_FINE_Q, 0x3           },
	{ RF1_2069_REV0_NBRSSI_BIAS, 0x1                },
	{ RF0_2069_REV0_LPF_BIAS_LEVELS_HIGH, 0x0       },
	{ RF0_2069_REV0_LPF_BIAS_LEVELS_LOW, 0x3        },
	{ RF2_2069_REV0_LPF_BIAS_LEVELS_MID, 0x2        },
	{ RF0_2069_REV0_LOGEN2G_IDAC2, 0x0              },
	{ RFP_2069_REV0_PLL_ADC1, 0x4                   },
	{ RF2_2069_REV0_BG_TRIM2, 0x2                   },
	{ RF0_2069_REV0_PA2G_TSSI, 0x3                  },
	{ RF0_2069_REV0_LNA2G_CFG1, 0x3                 },
	{ RF0_2069_REV0_LNA2G_CFG2, 0x3                 },
	{ RF1_2069_REV0_LNA2G_RSSI, 0x1                 },
	{ RF0_2069_REV0_LNA5G_CFG1, 0x3                 },
	{ RF0_2069_REV0_LNA5G_CFG2, 0x3                 },
	{ RF0_2069_REV0_LNA5G_RSSI, 0x3                 },
	{ RF0_2069_REV0_RXMIX2G_CFG1, 0x3               },
	{ RF0_2069_REV0_RXMIX5G_CFG1, 0x3               },
	{ RF0_2069_REV0_RXRF2G_CFG1, 0x3                },
	{ RF0_2069_REV0_RXRF5G_CFG1, 0x3                },
	{ RF0_2069_REV0_TIA_CFG1,	0x3                 },
	{ RF0_2069_REV0_LPF_MAIN_CONTROLS, 0x3          },
	{ RF0_2069_REV0_LPF_CORNER_FREQUENCY_TUNING, 0x3},
	{ RF0_2069_REV0_TXGM_CFG1, 0x3 },
	{ RF0_2069_REV0_PGA2G_CFG1, 0x3},
	{ RF2_2069_REV0_PGA5G_CFG1, 0x2},
	{ RF0_2069_REV0_PAD5G_CFG1, 0x3},
	{ RF0_2069_REV0_PA5G_CFG1, 0x3 },
	{ RF0_2069_REV0_LOGEN2G_CFG1, 0x0 },
	{ RF0_2069_REV0_LOGEN2G_CFG2, 0x3 },
	{ RF0_2069_REV0_LOGEN5G_CFG2, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE1, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE2, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE3, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE4, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE5, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE6, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE7, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE9, 0x3 },
	{ RF0_2069_REV0_ADC_CALCODE10, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE11, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE12, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE13, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE14, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE15, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE16, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE17, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE18, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE19, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE20, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE21, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE23, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE24, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE25, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE26, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE27, 0x3},
	{ RF0_2069_REV0_ADC_CALCODE28, 0x3},
	{ RFP_2069_REV0_PLL_VCOCAL5, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL6, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL2, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL1, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL11, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL12, 0x4},
	{ RFP_2069_REV0_PLL_FRCT2, 0x4},
	{ RFP_2069_REV0_PLL_FRCT3, 0x4},
	{ RFP_2069_REV0_PLL_VCOCAL10, 0x4},
	{ RFP_2069_REV0_PLL_XTAL3, 0x4},
	{ RFP_2069_REV0_PLL_VCO2, 0x4},
	{ RF0_2069_REV0_LOGEN5G_CFG1, 0x0},
	{ RFP_2069_REV0_PLL_VCO8, 0x4},
	{ RFP_2069_REV0_PLL_VCO6, 0x4},
	{ RFP_2069_REV0_PLL_VCO3, 0x4},
	{ RFP_2069_REV0_PLL_XTALLDO1, 0x4},
	{ RFP_2069_REV0_PLL_HVLDO1, 0x4},
	{ RFP_2069_REV0_PLL_HVLDO2, 0x4},
	{ RFP_2069_REV0_PLL_VCO5, 0x4},
	{ RFP_2069_REV0_PLL_VCO4, 0x4},
	{ RFP_2069_REV0_PLL_LF4, 0x4},
	{ RFP_2069_REV0_PLL_LF5, 0x4},
	{ RFP_2069_REV0_PLL_LF7, 0x4},
	{ RFP_2069_REV0_PLL_LF2, 0x4},
	{ RFP_2069_REV0_PLL_LF3, 0x4},
	{ RFP_2069_REV0_PLL_CP4, 0x4},
	{ RFP_2069_REV0_PLL_DSP1, 0x4},
	{ RFP_2069_REV0_PLL_DSP2, 0x4},
	{ RFP_2069_REV0_PLL_DSP3, 0x4},
	{ RFP_2069_REV0_PLL_DSP4, 0x4},
	{ RFP_2069_REV0_PLL_DSP6, 0x4},
	{ RFP_2069_REV0_PLL_DSP7, 0x4},
	{ RFP_2069_REV0_PLL_DSP8, 0x4},
	{ RFP_2069_REV0_PLL_DSP9, 0x4},
	{ RF0_2069_REV0_LOGEN2G_TUNE, 0x0},
	{ RF0_2069_REV0_LNA2G_TUNE, 0x3},
	{ RF0_2069_REV0_TXMIX2G_CFG1, 0x3},
	{ RF0_2069_REV0_PGA2G_CFG2, 0x3},
	{ RF0_2069_REV0_PAD2G_TUNE, 0x3},
	{ RF0_2069_REV0_LOGEN5G_TUNE1, 0x0},
	{ RF0_2069_REV0_LOGEN5G_TUNE2, 0x0},
	{ RF0_2069_REV0_LOGEN5G_RCCR, 0x3},
	{ RF0_2069_REV0_LNA5G_TUNE, 0x3},
	{ RF0_2069_REV0_TXMIX5G_CFG1, 0x3},
	{ RF0_2069_REV0_PGA5G_CFG2, 0x3},
	{ RF0_2069_REV0_PAD5G_TUNE, 0x3},
	{ RFP_2069_REV0_PLL_CP5, 0x4},
	{ RF0_2069_REV0_AFEDIV1, 0x0},
	{ RF0_2069_REV0_AFEDIV2, 0x0},
	{ RF1_2069_REV0_ADC_CFG5, 0x1},
	{ RF2_2069_REV0_ADC_CFG5, 0x2},
	{ RFP_2069_REV0_OVR15, 0x4 },
	{ RFP_2069_REV0_OVR16, 0x4 },
	{ RF1_2069_REV0_NBRSSI_CONFG, 0x1},
	{ RF0_2069_REV0_ADC_CFG1, 0x3},
	{ RF0_2069_REV0_ADC_CFG4, 0x3},
	{ RF0_2069_REV0_ADC_BIAS1, 0x3},
	{ 0xFFFF, 0}
};

/* List of all PHY regs to be saved during FCBS */
static uint16 fcbs_phyreg_list_acphy[83];

static bool
wlc_phy_prefcbsinit_acphy(phy_info_t *pi, int chanidx)
{
	MOD_PHYREG(pi, ChannelSwitch, ChannelIndicator, (uint16)chanidx);

	return TRUE;
}

uint16
wlc_phy_channelindicator_obtain_acphy(phy_info_t *pi)
{
	return READ_PHYREGFLD(pi, ChannelSwitch, ChannelIndicator);
}

static bool
wlc_phy_postfcbsinit_acphy(phy_info_t *pi, int chanidx)
{
	return TRUE;
	/* Nothing to do right now */
}

static bool
wlc_phy_fcbsinit_acphy(phy_info_t *pi, int chanidx, chanspec_t chanspec)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/* Values of these registers may depend on phy_rev. */
	fcbs_phyreg_list_acphy[0] = ACPHY_TxResamplerMuDelta0u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[1] = ACPHY_TxResamplerMuDelta0l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[2] = ACPHY_TxResamplerMuDeltaInit0u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[3] = ACPHY_TxResamplerMuDeltaInit0l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[4] = ACPHY_TxResamplerMuDelta1u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[5] = ACPHY_TxResamplerMuDelta1l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[6] = ACPHY_TxResamplerMuDeltaInit1u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[7] = ACPHY_TxResamplerMuDeltaInit1l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[8] = ACPHY_TxResamplerMuDelta2u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[9] = ACPHY_TxResamplerMuDelta2l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[10] = ACPHY_TxResamplerMuDeltaInit2u(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[11] = ACPHY_TxResamplerMuDeltaInit2l(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[12] = ACPHY_RfctrlCoreLowPwr0(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[13] = ACPHY_RfctrlCoreLowPwr1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[14] = ACPHY_RfctrlCoreLowPwr2(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[15] = ACPHY_nvcfg3(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[16] = ACPHY_DcFiltAddress(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[17] = ACPHY_RxFilt40Num00(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[18] = ACPHY_RxFilt40Num01(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[19] = ACPHY_RxFilt40Num02(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[20] = ACPHY_RxFilt40Den00(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[21] = ACPHY_RxFilt40Den01(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[22] = ACPHY_RxFilt40Num10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[23] = ACPHY_RxFilt40Num11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[24] = ACPHY_RxFilt40Num12(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[25] = ACPHY_RxFilt40Den10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[26] = ACPHY_RxFilt40Den11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[27] = ACPHY_RxStrnFilt40Num00(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[28] = ACPHY_RxStrnFilt40Num01(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[29] = ACPHY_RxStrnFilt40Num02(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[30] = ACPHY_RxStrnFilt40Den00(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[31] = ACPHY_RxStrnFilt40Den01(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[32] = ACPHY_RxStrnFilt40Num10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[33] = ACPHY_RxStrnFilt40Num11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[34] = ACPHY_RxStrnFilt40Num12(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[35] = ACPHY_RxStrnFilt40Den10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[36] = ACPHY_RxStrnFilt40Den11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[37] = ACPHY_rxfdiqImbCompCtrl(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[38] = ACPHY_RfctrlCoreAfeCfg20(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[39] = ACPHY_RfctrlCoreAfeCfg21(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[40] = ACPHY_RfctrlCoreAfeCfg22(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[41] = ACPHY_crsminpoweroffset0(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[42] = ACPHY_crsminpoweroffsetSub10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[43] = ACPHY_crsmfminpoweroffset0(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[44] = ACPHY_crsmfminpoweroffsetSub10(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[45] = ACPHY_crsminpoweroffset1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[46] = ACPHY_crsminpoweroffsetSub11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[47] = ACPHY_crsmfminpoweroffset1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[48] = ACPHY_crsmfminpoweroffsetSub11(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[49] = ACPHY_crsminpoweroffset2(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[50] = ACPHY_crsminpoweroffsetSub12(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[51] = ACPHY_crsmfminpoweroffset2(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[52] = ACPHY_crsmfminpoweroffsetSub12(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[53] = ACPHY_Core0RssiClipMuxSel(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[54] = ACPHY_Core1RssiClipMuxSel(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[55] = ACPHY_Core2RssiClipMuxSel(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[56] = ACPHY_Core0FastAgcClipCntTh(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[57] = ACPHY_Core1FastAgcClipCntTh(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[58] = ACPHY_Core2FastAgcClipCntTh(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[59] = ACPHY_TssiEnRate(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[60] = ACPHY_energydroptimeoutLen(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[61] = ACPHY_FSTRMetricTh(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[62] = ACPHY_ClassifierCtrl6(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[63] = ACPHY_ClassifierLogAC1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[64] = ACPHY_crsacidetectThreshl(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[65] = ACPHY_crsacidetectThreshu(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[66] = ACPHY_crsacidetectThreshlSub1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[67] = ACPHY_crsacidetectThreshuSub1(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[68] = ACPHY_Core0computeGainInfo(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[69] = ACPHY_Core0clip2GainCodeA(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[70] = ACPHY_Core0Adcclip(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[71] = ACPHY_Core1computeGainInfo(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[72] = ACPHY_Core1clip2GainCodeA(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[73] = ACPHY_Core1Adcclip(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[74] = ACPHY_Core2computeGainInfo(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[75] = ACPHY_Core2clip2GainCodeA(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[76] = ACPHY_Core2Adcclip(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[77] = ACPHY_Core0clip2GainCodeB(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[78] = ACPHY_Core1clip2GainCodeB(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[79] = ACPHY_Core2clip2GainCodeB(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[80] = ACPHY_defer_setClip1_CtrLen(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[81] = ACPHY_defer_setClip2_CtrLen(pi->pubpi.phy_rev);
	fcbs_phyreg_list_acphy[82] = 0xFFFF;

	pi->phy_fcbs.fcbs_phytbl16_list = fcbs_phytbl16_list_acphy;
	pi->phy_fcbs.fcbs_radioreg_list = fcbs_radioreg_list_acphy;
	pi->phy_fcbs.fcbs_phyreg_list = fcbs_phyreg_list_acphy;
	/* Obtain the buffer pointers for the appropriate FCBS channel */
	pi->phy_fcbs.phytbl16_buf[chanidx] = pi_ac->ac_fcbs.phytbl16_buf_ChanA;

	if (pi->phy_fcbs.FCBS_ucode) {
		/* Starting address of the FCBS cache on the on-chip RAM */
		pi->phy_fcbs.cache_startaddr = FCBS_ACPHY_TMPLRAM_STARTADDR;

		/* Shared memory locations for specifying the starting offset
		   of the radio register cache, phytbl16 cache, phytbl32 cache
		   phyreg cache, bphyctrl register and the FCBS channel specific
		   starting cache address
		*/
		pi->phy_fcbs.shmem_radioreg = M_FCBS_ACPHY_RADIOREG;
		pi->phy_fcbs.shmem_phytbl16 = M_FCBS_ACPHY_PHYTBL16;
		pi->phy_fcbs.shmem_phytbl32 = M_FCBS_ACPHY_PHYTBL32;
		pi->phy_fcbs.shmem_phyreg = M_FCBS_ACPHY_PHYREG;
		pi->phy_fcbs.shmem_bphyctrl = M_FCBS_ACPHY_BPHYCTRL;
		pi->phy_fcbs.shmem_cache_ptr = M_FCBS_ACPHY_TEMPLATE_PTR;
	}
	return TRUE;
}

static bool
wlc_phy_prefcbs_acphy(phy_info_t *pi, int chanidx)
{
	/* CRDOT11ACPHY-176 :: Timing issues cause the VCO cal not to be triggered during
	 * channel switch. we need to clear these ovr bits before the switch and
	 * set them during switch (throough the FCBS TBL which then triggers the VCO cal
	 */
	/* Reg conflict with 2069 rev 16 */
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_vcocal_cal, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR15, ovr_rfpll_rst_n, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, OVR16, ovr_rfpll_vcocal_rstn, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_vcocal_cal, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR16, ovr_rfpll_rst_n, 0)
			MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR17, ovr_rfpll_vcocal_rstn, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	return TRUE;
}

static bool
wlc_phy_postfcbs_acphy(phy_info_t *pi, int chanidx)
{
	return TRUE;
	/* Nothing to do right now */
}

static bool
wlc_phy_fcbs_acphy(phy_info_t *pi, int chanidx)
{
	uint16 chanspec;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	MOD_PHYREG(pi, ChannelSwitch, ChannelIndicator, (uint16)chanidx);
	MOD_PHYREG(pi, ChannelSwitch, VCO_cal_reqd, 0x1);
	MOD_PHYREG(pi, ChannelSwitch, SwitchTrigger, 0x1);
	SPINWAIT(READ_PHYREG(pi, ChannelSwitch) &
	        (0x1 << ACPHY_ChannelSwitch_SwitchTrigger_SHIFT(pi->pubpi.phy_rev)),
		ACPHY_SPINWAIT_FCBS_SWITCH);
	ASSERT(!(READ_PHYREG(pi, ChannelSwitch) &
	      (0x1 << ACPHY_ChannelSwitch_SwitchTrigger_SHIFT(pi->pubpi.phy_rev))));

	/* Set bandwidth bits in the SI Core flags, which is not cached.
	 * Some radio control lines are set after reset2rx with correct bandwidth bits.
	 * PHY seems to be a weird state after switch and we need rset CCA
	 */
	chanspec = pi->phy_fcbs.chanspec[chanidx];
	if (pi_ac->curr_bw != CHSPEC_BW(chanspec)) {
		pi_ac->curr_bw = CHSPEC_BW(chanspec);
		wlapi_bmac_bw_set(pi->sh->physhim, CHSPEC_BW(chanspec));
	}

	wlc_phy_resetcca_acphy(pi);
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RESET2RX);

	return TRUE;
}

#endif /* ENABLE_FCBS */

#define MAX_2069_RCAL_WAITLOOPS 100
/* rcal takes ~50us */
static void
wlc_phy_radio2069_rcal(phy_info_t *pi)
{
	uint8 done, rcal_val, core;
	uint16 rcal_itr;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	ACPHY_REG_LIST_START
		/* Power-up rcal clock (need both of them for rcal) */
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL1, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 1)

		/* Rcal can run with 40mhz cls, no diving */
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_sel_RCCAL, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_sel_RCCAL1, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* Make connection with the external 10k resistor */
	/* Turn off all test points in cgpaio block to avoid conflict */
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, GE32_CGPAIO_CFG1, core, cgpaio_pu, 1);
		}
		ACPHY_REG_LIST_START
			WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG2, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG3, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG4, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG5, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_TOP_SPARE1, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_TOP_SPARE2, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_TOP_SPARE4, 0)
			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_TOP_SPARE6, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_ENTRY(pi, RF2, CGPAIO_CFG1, cgpaio_pu, 1)
			WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG2, 0)
			WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG3, 0)
			WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG4, 0)
			WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG5, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
	/* NOTE: xtal_pu, xtal_buf_pu & xtalldo_pu direct control lines should be(& are) ON */

	/* Toggle the rcal pu for calibration engine */
	MOD_RADIO_REG(pi, RF2, RCAL_CFG, pu, 0);
	OSL_DELAY(1);
	MOD_RADIO_REG(pi, RF2, RCAL_CFG, pu, 1);

	/* Wait for rcal to be done, max = 10us * 100 = 1ms  */
	done = 0;
	for (rcal_itr = 0; rcal_itr < MAX_2069_RCAL_WAITLOOPS; rcal_itr++) {
		OSL_DELAY(10);
		done = READ_RADIO_REGFLD(pi, RF2, RCAL_CFG, i_wrf_jtag_rcal_valid);
		if (done == 1) {
			break;
		}
	}

	ASSERT(done & 0x1);

	/* Status */
	rcal_val = READ_RADIO_REGFLD(pi, RF2, RCAL_CFG, i_wrf_jtag_rcal_value);
	rcal_val = rcal_val >> 1;
	PHY_INFORM(("wl%d: %s rcal=%d\n", pi->sh->unit, __FUNCTION__, rcal_val));

	/* Valid range of values for rcal */
	ASSERT((rcal_val > 0) && (rcal_val < 15));

	/*  Power down blocks not needed anymore */
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, GE32_CGPAIO_CFG1, core, cgpaio_pu, 0);
		}
	} else {
		MOD_RADIO_REG(pi, RF2, CGPAIO_CFG1, cgpaio_pu, 0);
	}
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL1, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 0)
		MOD_RADIO_REG_ENTRY(pi, RF2, RCAL_CFG, pu, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

#define MAX_2069_RCCAL_WAITLOOPS 100
#define NUM_2069_RCCAL_CAPS 3
/* rccal takes ~3ms per, i.e. ~9ms total */
static void
wlc_phy_radio2069_rccal(phy_info_t *pi)
{
	uint8 cal, core, done, rccal_val[NUM_2069_RCCAL_CAPS];
	uint16 rccal_itr, n0, n1;

	/* lpf, adc, dacbuf */
	uint8 sr[] = {0x1, 0x0, 0x0};
	uint8 sc[] = {0x0, 0x2, 0x1};
	uint8 x1[] = {0x1c, 0x70, 0x40};
	uint16 trc[] = {0x14a, 0x101, 0x11a};
	uint16 gmult_const = 193;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
		if (PHY_XTAL_IS40M(pi)) {
		  if ((RADIOREV(pi->pubpi.radiorev) == 25) ||
		                      (RADIOREV(pi->pubpi.radiorev) == 26)) {
			gmult_const = 70;
			trc[0] = 0x294;
			trc[1] = 0x202;
			trc[2] = 0x214;
		  } else {
			gmult_const = 160;
		  }
		} else if (PHY_XTAL_IS37M4(pi)) {
		  if ((RADIOREV(pi->pubpi.radiorev) == 25) ||
		                      (RADIOREV(pi->pubpi.radiorev) == 26)) {
			gmult_const = 77;
			trc[0] = 0x45a;
			trc[1] = 0x1e0;
			trc[2] = 0x214;
		  } else {
			gmult_const = 158;
			trc[0] = 0x22d;
			trc[1] = 0xf0;
			trc[2] = 0x10a;
		  }
		} else if (PHY_XTAL_IS52M(pi)) {
			if ((RADIOREV(pi->pubpi.radiorev) == 25) ||
				(RADIOREV(pi->pubpi.radiorev) == 26)) {
				gmult_const = 77;
				trc[0] = 0x294;
				trc[1] = 0x202;
				trc[2] = 0x214;
			  } else {
				gmult_const = 160;
				trc[0] = 0x14a;
				trc[1] = 0x101;
				trc[2] = 0x11a;
			  }
		} else {
			gmult_const = 160;
		}

	} else {
		gmult_const = 193;
	}

	/* Powerup rccal driver & set divider radio (rccal needs to run at 20mhz) */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 1);
	MOD_RADIO_REG(pi, RFP, PLL_XTAL5, xtal_sel_RCCAL, 2);

	/* Calibrate lpf, adc, dacbuf */
	for (cal = 0; cal < NUM_2069_RCCAL_CAPS; cal++) {
		/* Setup */
		MOD_RADIO_REG(pi, RF2, RCCAL_CFG, sr, sr[cal]);
		MOD_RADIO_REG(pi, RF2, RCCAL_CFG, sc, sc[cal]);
		MOD_RADIO_REG(pi, RF2, RCCAL_LOGIC1, rccal_X1, x1[cal]);
		write_radio_reg(pi, RF2_2069_RCCAL_TRC, trc[cal]);

		/* For dacbuf force fixed dacbuf cap to be 0 while calibration, restore it later */
		if (cal == 2) {
			FOREACH_CORE(pi, core) {
				MOD_RADIO_REGC(pi, DAC_CFG2, core, DACbuf_fixed_cap, 0);
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
					MOD_RADIO_REGC(pi, GE16_OVR22, core,
					               ovr_afe_DACbuf_fixed_cap, 1);
				} else {
					MOD_RADIO_REGC(pi, OVR21, core,
					               ovr_afe_DACbuf_fixed_cap, 1);
				}
			}
		}

		/* Toggle RCCAL power */
		MOD_RADIO_REG(pi, RF2, RCCAL_CFG, pu, 0);
		OSL_DELAY(1);
		MOD_RADIO_REG(pi, RF2, RCCAL_CFG, pu, 1);

		OSL_DELAY(35);

		/* Start RCCAL */
		MOD_RADIO_REG(pi, RF2, RCCAL_LOGIC1, rccal_START, 1);

		/* Wait for rcal to be done, max = 100us * 100 = 10ms  */
		done = 0;
		for (rccal_itr = 0;
			(rccal_itr < MAX_2069_RCCAL_WAITLOOPS) && (done == 0);
			rccal_itr++) {
			OSL_DELAY(100);
			done = READ_RADIO_REGFLD(pi, RF2, RCCAL_LOGIC2, rccal_DONE);
		}

		/* Stop RCCAL */
		MOD_RADIO_REG(pi, RF2, RCCAL_LOGIC1, rccal_START, 0);

		/* Make sure that RC Cal ran to completion */
		ASSERT(done);

		if (cal == 0) {
			/* lpf */
			n0 = READ_RADIO_REG(pi, RF2, RCCAL_LOGIC3);
			n1 = READ_RADIO_REG(pi, RF2, RCCAL_LOGIC4);
			/* gmult = (30/40) * (n1-n0) = (193 * (n1-n0)) >> 8 */
			rccal_val[cal] = (gmult_const * (n1 - n0)) >> 8;
			pi_ac->rccal_gmult = rccal_val[cal];
			pi_ac->rccal_gmult_rc = pi_ac->rccal_gmult;
			PHY_INFORM(("wl%d: %s rccal_lpf_gmult = %d\n", pi->sh->unit,
				__FUNCTION__, rccal_val[cal]));
		} else if (cal == 1) {
			/* adc */
			rccal_val[cal] = READ_RADIO_REGFLD(pi, RF2, RCCAL_LOGIC5, rccal_raw_adc1p2);
			PHY_INFORM(("wl%d: %s rccal_adc = %d\n", pi->sh->unit,
				__FUNCTION__, rccal_val[cal]));

			/* don't change this loop to active core loop,
			   gives slightly higher floor, why?
			*/
			FOREACH_CORE(pi, core) {
				MOD_RADIO_REGC(pi, ADC_RC1, core, adc_ctl_RC_4_0, rccal_val[cal]);
				MOD_RADIO_REGC(pi, TIA_CFG3, core, rccal_hpc, rccal_val[cal]);
			}
		} else {
			/* dacbuf */
			rccal_val[cal] = READ_RADIO_REGFLD(pi, RF2, RCCAL_LOGIC5, rccal_raw_dacbuf);
			pi_ac->rccal_dacbuf = rccal_val[cal];

			/* take away the override on dacbuf fixed cap */
			FOREACH_CORE(pi, core) {
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
					MOD_RADIO_REGC(pi, GE16_OVR22, core,
					               ovr_afe_DACbuf_fixed_cap, 0);
				} else {
					MOD_RADIO_REGC(pi, OVR21, core,
					               ovr_afe_DACbuf_fixed_cap, 0);
				}
			}
			PHY_INFORM(("wl%d: %s rccal_dacbuf = %d\n", pi->sh->unit,
				__FUNCTION__, rccal_val[cal]));
		}

		/* Turn off rccal */
		MOD_RADIO_REG(pi, RF2, RCCAL_CFG, pu, 0);
	}

	/* Powerdown rccal driver */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 0);
}

void
wlc_phy_update_ed_thres_acphy(phy_info_t *pi, chanspec_t chanspec)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (CHSPEC_IS5G(chanspec)) {
		if (pi_ac->srom.ed_thresh5g)
			wlc_phy_adjust_ed_thres_acphy(pi, &pi_ac->srom.ed_thresh5g, TRUE);
		else
			wlc_phy_adjust_ed_thres_acphy(pi,
				&pi_ac->srom.ed_thresh_default, TRUE);
	}
#ifdef BCMLTECOEX
	else if (pi_ac->ltecx_ed_thresh)
		wlc_phy_adjust_ed_thres_acphy(pi, &pi_ac->ltecx_ed_thresh, TRUE);
#endif /* BCMLTECOEX */
	else if (pi_ac->srom.ed_thresh2g)
		wlc_phy_adjust_ed_thres_acphy(pi, &pi_ac->srom.ed_thresh2g, TRUE);
	else
		wlc_phy_adjust_ed_thres_acphy(pi, &pi_ac->srom.ed_thresh_default, TRUE);

	if (pi->region_group ==  REGION_EU)
		wlc_phy_set_srom_eu_edthresh_acphy(pi);

}

static void
wlc_phy_radio20691_rccal(phy_info_t *pi)
{
	uint8 cal, done;
	uint16 rccal_itr, n0, n1;

	/* lpf, adc, dacbuf */
	uint8 sr[] = {0x1, 0x1, 0x0};
	uint8 sc[] = {0x0, 0x1, 0x2};
	uint8 x1[] = {0x1c, 0x70, 0x40};
	uint16 trc[] = {0x22d, 0xf0, 0x10a};
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint32 dn;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* Powerup rccal driver & set divider radio (rccal needs to run at 20mhz) */
	MOD_RADIO_REG_20691(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 1);

	/* Calibrate lpf, adc, dacbuf */
	for (cal = 0; cal < NUM_2069_RCCAL_CAPS; cal++) {
		/* Setup */
		MOD_RADIO_REG_20691(pi, RCCAL_CFG0, 0, rccal_sr, sr[cal]);
		MOD_RADIO_REG_20691(pi, RCCAL_CFG0, 0, rccal_sc, sc[cal]);
		MOD_RADIO_REG_20691(pi, RCCAL_CFG1, 0, rccal_X1, x1[cal]);
		write_radio_reg(pi, RADIO_REG_20691(pi, RCCAL_CFG2, 0), trc[cal]);

		/* For dacbuf force fixed dacbuf cap to be 0 while calibration, restore it later */
		if (cal == 2) {
			MOD_RADIO_REG_20691(pi, TX_DAC_CFG5, 0, DACbuf_fixed_cap, 0);
			MOD_RADIO_REG_20691(pi, TX_BB_OVR1, 0, ovr_DACbuf_fixed_cap, 1);
		}

		/* Toggle RCCAL power */
		MOD_RADIO_REG_20691(pi, RCCAL_CFG0, 0, rccal_pu, 0);
		OSL_DELAY(1);
		MOD_RADIO_REG_20691(pi, RCCAL_CFG0, 0, rccal_pu, 1);

		OSL_DELAY(35);

		/* Start RCCAL */
		MOD_RADIO_REG_20691(pi, RCCAL_CFG1, 0, rccal_START, 1);

		/* Wait for rcal to be done, max = 100us * 100 = 10ms  */
		done = 0;
		for (rccal_itr = 0;
			(rccal_itr < MAX_2069_RCCAL_WAITLOOPS) && (done == 0);
			rccal_itr++) {
			OSL_DELAY(100);
			done = READ_RADIO_REGFLD_20691(pi, RCCAL_CFG3, 0, rccal_DONE);
		}

		/* Stop RCCAL */
		MOD_RADIO_REG_20691(pi, RCCAL_CFG1, 0, rccal_START, 0);

		/* Make sure that RC Cal ran to completion */
		ASSERT(done);

		n0 = READ_RADIO_REGFLD_20691(pi, RCCAL_CFG4, 0, rccal_N0);
		n1 = READ_RADIO_REGFLD_20691(pi, RCCAL_CFG5, 0, rccal_N1);
		dn = n1 - n0; /* set dn [expr {$N1 - $N0}] */

		if (cal == 0) {
			/* lpf */
			/* set k [expr {$is_adc ? 102051 : 101541}] */
			/* set gmult_p12 [expr {$prod1 / $fxtal_pm12}] */
			pi_ac->rccal_gmult = (101541 * dn) / (PHY_XTALFREQ(pi->xtalfreq) >> 12);
			pi_ac->rccal_gmult_rc = pi_ac->rccal_gmult;
			PHY_INFORM(("wl%d: %s rccal_lpf_gmult = %d\n", pi->sh->unit,
			            __FUNCTION__, pi_ac->rccal_gmult));
#ifdef ATE_BUILD
			ate_buffer_regval.gmult_lpf = pi_ac->rccal_gmult;
#endif // endif
		} else if (cal == 1) {
			/* adc */
			/* set k [expr {$is_adc ? 102051 : 101541}] */
			/* set gmult_p12 [expr {$prod1 / $fxtal_pm12}] */
			pi_ac->rccal_adc_gmult = (102051 * dn) / (PHY_XTALFREQ(pi->xtalfreq) >> 12);
			PHY_INFORM(("wl%d: %s rccal_adc = %d\n", pi->sh->unit,
			            __FUNCTION__, pi_ac->rccal_adc_gmult));
#ifdef ATE_BUILD
			ate_buffer_regval.gmult_adc = pi_ac->rccal_adc_gmult;
#endif // endif
		} else {
			/* dacbuf */
			pi_ac->rccal_dacbuf = READ_RADIO_REGFLD_20691(pi, RCCAL_CFG6, 0,
			                                              rccal_raw_dacbuf);
			MOD_RADIO_REG_20691(pi, TX_BB_OVR1, 0, ovr_DACbuf_fixed_cap, 0);
			PHY_INFORM(("wl%d: %s rccal_dacbuf = %d\n", pi->sh->unit,
				__FUNCTION__, pi_ac->rccal_dacbuf));
#ifdef ATE_BUILD
			ate_buffer_regval.rccal_dacbuf = pi_ac->rccal_dacbuf;
#endif // endif
		}
		/* Turn off rccal */
		MOD_RADIO_REG_20691(pi, RCCAL_CFG0, 0, rccal_pu, 0);
	}
	/* Powerdown rccal driver */
	MOD_RADIO_REG_20691(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 0);
}

static void
wlc_phy_radio2069_vcocal(phy_info_t *pi)
{
	/* Use legacy mode */
	uint8 legacy_n = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* VCO cal mode selection */
	MOD_RADIO_REG(pi, RFP, PLL_VCOCAL10, rfpll_vcocal_ovr_mode, legacy_n);

	ACPHY_REG_LIST_START
		/* VCO-Cal startup seq */
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CFG2, rfpll_rst_n, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCOCAL13, rfpll_vcocal_rst_n, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCOCAL1, rfpll_vcocal_cal, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
	OSL_DELAY(10);
	MOD_RADIO_REG(pi, RFP, PLL_CFG2, rfpll_rst_n, 1);
	MOD_RADIO_REG(pi, RFP, PLL_VCOCAL13, rfpll_vcocal_rst_n, 1);
	OSL_DELAY(1);
	MOD_RADIO_REG(pi, RFP, PLL_VCOCAL1, rfpll_vcocal_cal, 1);
}

static void
wlc_phy_radio20691_vcocal(phy_info_t *pi)
{
	/* Use legacy mode */
	uint8 legacy_n = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	MOD_RADIO_REG_20691(pi, PLL_HVLDO3, 0, ldo_2p5_ldo_VCO_vout_sel, 0xf);
	MOD_RADIO_REG_20691(pi, PLL_HVLDO3, 0, ldo_2p5_ldo_CP_vout_sel, 0xf);

	/* VCO-Cal startup seq */
	/* VCO cal mode selection */
	MOD_RADIO_REG_20691(pi, PLL_VCOCAL10, 0, rfpll_vcocal_ovr_mode, legacy_n);

	/* # TODO: The below registers have direct PHY control in 20691 (unlike 2069?)
	 * so this reset should ideally be done by writing phy registers
	 */
	ACPHY_REG_LIST_START
		/* # Reset delta-sigma modulator */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG2, 0, rfpll_rst_n, 0)
		/* # Disable PHY direct control for delta-sigma modulator reset signal */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_rst_n, 1)
		/* # Reset VCO cal */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCOCAL13, 0, rfpll_vcocal_rst_n, 0)
		/* # Disable PHY direct control for vcocal reset */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_vcocal_rst_n, 1)
		/* # Reset start of VCO Cal */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCOCAL1, 0, rfpll_vcocal_cal, 0)
		/* # Disable PHY direct control for vcocal start */
		MOD_RADIO_REG_20691_ENTRY(pi, RFPLL_OVR1, 0, ovr_rfpll_vcocal_cal, 1)
	ACPHY_REG_LIST_EXECUTE(pi);
	OSL_DELAY(11);
	/* # Release reset */
	MOD_RADIO_REG_20691(pi, PLL_CFG2, 0, rfpll_rst_n, 1);
	/* # Release reset */
	MOD_RADIO_REG_20691(pi, PLL_VCOCAL13, 0, rfpll_vcocal_rst_n, 1);
	OSL_DELAY(1);
	/* # Start VCO Cal */
	MOD_RADIO_REG_20691(pi, PLL_VCOCAL1, 0, rfpll_vcocal_cal, 1);

}

#define MAX_2069x_VCOCAL_WAITLOOPS 100
/* vcocal should take < 120 us */
static void
wlc_phy_radio2069x_vcocal_isdone(phy_info_t *pi, bool set_delay)
{
	/* Use legacy mode */
	uint8 done, itr;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	/* Wait for vco_cal to be done, max = 100us * 10 = 1ms  */
	done = 0;
	for (itr = 0; itr < MAX_2069x_VCOCAL_WAITLOOPS; itr++) {
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
			done = READ_RADIO_REGFLD_20691(pi, PLL_VCOCAL14, 0, rfpll_vcocal_done_cal);
		} else
			done = READ_RADIO_REGFLD(pi, RFP, PLL_VCOCAL14, rfpll_vcocal_done_cal);
		if (done == 1)
			break;
		OSL_DELAY(10);
	}

	/* Need to wait extra time after vcocal done bit is high for it to settle */
	if (set_delay == TRUE)
	  OSL_DELAY(120);

	ASSERT(done & 0x1);

	PHY_INFORM(("wl%d: %s vcocal done\n", pi->sh->unit, __FUNCTION__));
}

static void
wlc_phy_radio20691_afecal(phy_info_t *pi)
{
	tiny_adc_tuning_array_t gvalues;

	/* enable ?? wlc_phy_radio20691_rccal(pi); */
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* set gvalues [20691_sigdel_fast_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_fast_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues);
		/* 20691_adc_setup_fast $gvalues */
		wlc_20691_adc_setup_fast(pi, &gvalues);
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		/* set gvalues [20691_sigdel_slow1g2_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_slow1g2_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues);
		/* 20691_adc_setup_slow1g2 $gvalues */
		wlc_20691_adc_setup_slow1g2(pi, &gvalues);
	} else {
		/* set gvalues [20691_sigdel_slow0g6_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_slow0g6_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues, 4096);
		/* 20691_adc_setup_slow0g6 $gvalues */
		wlc_20691_adc_setup_slow0g6(pi, &gvalues);
	}

	wlc_20691_tia_config(pi);
}

#define MAX_2069_AFECAL_WAITLOOPS 10
static void
wlc_phy_radio2069_afecal(phy_info_t *pi)
{
	uint8 core, itr, done_i, done_q;
	uint16 adc_cfg4, *afe_cfg_arr;

	if (ISSIM_ENAB(pi->sh->sih))
		return;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* Used to latch (clk register) rcal, rccal, ADC cal code */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 1);

	/* Allocate storage to save current config registers */
	/* 3 registers per AFE core: RfctrlCoreAfeCfg1, RfctrlCoreAfeCfg2, RfctrlOverrideAfeCfg */
	afe_cfg_arr = MALLOC(pi->sh->osh, 3 * PHYCORENUM((pi)->pubpi.phy_corenum) * sizeof(uint16));

	/* Proceed only if allocation successful */
	if (afe_cfg_arr == NULL) {
		PHY_ERROR(("wl%d: %s: MALLOC failure\n", pi->sh->unit, __FUNCTION__));
		return;
	}
	/* Save config registers and issue reset */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Cfg1  in 0 to PHYCORENUM-1 */
		afe_cfg_arr[core] = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
		/* Cfg2 in PHYCORENUM to 2*PHYCORENUM -1 */
		afe_cfg_arr[core + PHYCORENUM(pi->pubpi.phy_corenum)] =
		  READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
		/* Overrides in 2*PHYCORENUM to 3*PHYCORENUM - 1 */
		afe_cfg_arr[core + 2*PHYCORENUM(pi->pubpi.phy_corenum)] =
		  READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_iqadc_reset, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_reset, 1);
		MOD_RADIO_REGC(pi, ADC_CFG3, core, flash_calrstb, 0); /* reset */
	}

	OSL_DELAY(100);

	/* Bring each AFE core back from reset and perform cal */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		MOD_RADIO_REGC(pi, ADC_CFG3, core, flash_calrstb, 1);
		adc_cfg4 = READ_RADIO_REGC(pi, RF, ADC_CFG4, core);
		write_radio_reg(pi, RF_2069_ADC_CFG4(core), adc_cfg4 | 0xf);

		done_i = 0; done_q = 0;
		for (itr = 0; itr < MAX_2069_AFECAL_WAITLOOPS; itr++) {
			OSL_DELAY(10);
			done_i = READ_RADIO_REGFLDC(pi, RF_2069_ADC_STATUS(core), ADC_STATUS,
				i_wrf_jtag_afe_iqadc_Ich_cal_state);
			done_q = READ_RADIO_REGFLDC(pi, RF_2069_ADC_STATUS(core), ADC_STATUS,
				i_wrf_jtag_afe_iqadc_Qch_cal_state);
			if ((done_i == 1) && (done_q == 1)) {
				PHY_INFORM(("wl%d: %s afecal(%d) done\n",
					pi->sh->unit, __FUNCTION__, core));
				break;
			}
		}
		/* Don't assert for QT */
		if (!ISSIM_ENAB(pi->sh->sih)) {
			ASSERT((done_i == 1) && (done_q == 1));
		}
		write_radio_reg(pi, RF_2069_ADC_CFG4(core), (adc_cfg4 & 0xfff0));  /* calMode = 0 */
		/* Restore AFE config registers for that core with saved values */
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_cfg_arr[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core,
			afe_cfg_arr[core + PHYCORENUM(pi->pubpi.phy_corenum)]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core,
			afe_cfg_arr[core + 2 * PHYCORENUM(pi->pubpi.phy_corenum)]);
	}

	/* Turn off clock */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 0);
	if (RADIOREV(pi->pubpi.radiorev) < 4) {
	  /* JIRA (CRDOT11ACPHY-153) calCodes are inverted for 4360a0 */
	  wlc_phy_radio2069_afecal_invert(pi);
	}
	/* Free allocated memory */
	MFREE(pi->sh->osh, afe_cfg_arr, 3 * sizeof(uint16) * PHYCORENUM(pi->pubpi.phy_corenum));

}

static void
wlc_phy_radio2069_afecal_invert(phy_info_t *pi)
{
	uint8 core;
	uint16 calcode;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* Switch on the clk */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 1);

	/* Output calCode = 1:14, latched = 15:28 */

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Use calCodes 1:14 instead of 15:28 */
		MOD_RADIO_REGC(pi, OVR3, core, ovr_afe_iqadc_flash_calcode_Ich, 1);
		MOD_RADIO_REGC(pi, OVR3, core, ovr_afe_iqadc_flash_calcode_Qch, 1);

		/* Invert the CalCodes */
		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE28, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE14(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE27, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE13(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE26, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE12(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE25, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE11(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE24, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE10(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE23, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE9(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE22, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE8(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE21, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE7(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE20, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE6(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE19, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE5(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE18, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE4(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE17, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE3(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE16, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE2(core), ~calcode & 0xffff);

		calcode = READ_RADIO_REGC(pi, RF, ADC_CALCODE15, core);
		write_radio_reg(pi, RF_2069_ADC_CALCODE1(core), ~calcode & 0xffff);
	}

	/* Turn off the clk */
	MOD_RADIO_REG(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL, 0);
}

/*
************************   PHY procs **************************
*/

void
wlc_phy_table_write_acphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset, uint32 width,
                          const void *data)
{
	acphytbl_info_t tbl;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	uint16 SAVE_dac_clk_pu = 0, SAVE_ovr_dac_clk_pu = 0, dacpwr, dacclk_saved;

	if (stall_val == 0)
		ACPHY_DISABLE_STALL(pi);

	ASSERT(READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls) == 1);

	/*
	 * PHY_TRACE(("wlc_phy_table_write_acphy, id %d, len %d, offset %d, width %d\n",
	 * 	id, len, offset, width));
	*/
	tbl.tbl_id = id;
	tbl.tbl_len = len;
	tbl.tbl_offset = offset;
	tbl.tbl_width = width;
	tbl.tbl_ptr = data;

	dacclk_saved = 0;

	if (TINY_RADIO(pi) && (id == ACPHY_TBL_ID_EPSILON0)) {
		dacpwr = READ_RADIO_REGFLD_20691(pi, TX_DAC_CFG1, 0, DAC_pwrup);
		if  (dacpwr == 0) {
			SAVE_dac_clk_pu = READ_RADIO_REGFLD_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu);
			SAVE_ovr_dac_clk_pu = READ_RADIO_REGFLD_20691(pi, CLK_DIV_OVR1, 0,
			                                              ovr_dac_clk_pu);
			MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu, 1);
			MOD_RADIO_REG_20691(pi, CLK_DIV_OVR1, 0, ovr_dac_clk_pu, 1);
			dacclk_saved = 1;
		}
	}

	wlc_phy_write_table_ext(pi, &tbl, ACPHY_TableID(pi->pubpi.phy_rev),
		ACPHY_TableOffset(pi->pubpi.phy_rev), ACPHY_TableDataWide(pi->pubpi.phy_rev),
		ACPHY_TableDataHi(pi->pubpi.phy_rev), ACPHY_TableDataLo(pi->pubpi.phy_rev));

	if (dacclk_saved == 1) {
		MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu, SAVE_dac_clk_pu);
		MOD_RADIO_REG_20691(pi, CLK_DIV_OVR1, 0, ovr_dac_clk_pu, SAVE_ovr_dac_clk_pu);
	}

	if (stall_val == 0)
		ACPHY_ENABLE_STALL(pi, stall_val);
}

void
wlc_phy_table_read_acphy(phy_info_t *pi, uint32 id, uint32 len, uint32 offset, uint32 width,
                         void *data)
{
	acphytbl_info_t tbl;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	uint16 SAVE_dac_clk_pu = 0, SAVE_ovr_dac_clk_pu = 0, dacpwr, dacclk_saved;

	if (stall_val == 0)
		ACPHY_DISABLE_STALL(pi);

	ASSERT(READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls) == 1);

	/*	PHY_TRACE(("wlc_phy_table_read_acphy, id %d, len %d, offset %d, width %d\n",
	 *	id, len, offset, width));
	 */
	tbl.tbl_id = id;
	tbl.tbl_len = len;
	tbl.tbl_offset = offset;
	tbl.tbl_width = width;
	tbl.tbl_ptr = data;

	dacclk_saved = 0;

	if (TINY_RADIO(pi) && (id == ACPHY_TBL_ID_EPSILON0)) {
		dacpwr = READ_RADIO_REGFLD_20691(pi, TX_DAC_CFG1, 0, DAC_pwrup);
		if  (dacpwr == 0) {
			SAVE_dac_clk_pu = READ_RADIO_REGFLD_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu);
			SAVE_ovr_dac_clk_pu = READ_RADIO_REGFLD_20691(pi, CLK_DIV_OVR1, 0,
			                                              ovr_dac_clk_pu);
			MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu, 1);
			MOD_RADIO_REG_20691(pi, CLK_DIV_OVR1, 0, ovr_dac_clk_pu, 1);
			dacclk_saved = 1;
		}
	}

	wlc_phy_read_table_ext(pi, &tbl, ACPHY_TableID(pi->pubpi.phy_rev),
		ACPHY_TableOffset(pi->pubpi.phy_rev), ACPHY_TableDataWide(pi->pubpi.phy_rev),
		ACPHY_TableDataHi(pi->pubpi.phy_rev), ACPHY_TableDataLo(pi->pubpi.phy_rev));

	if (dacclk_saved == 1) {
		MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, dac_clk_pu, SAVE_dac_clk_pu);
		MOD_RADIO_REG_20691(pi, CLK_DIV_OVR1, 0, ovr_dac_clk_pu, SAVE_ovr_dac_clk_pu);
	}

	if (stall_val == 0)
		ACPHY_ENABLE_STALL(pi, stall_val);
}

/** Returns TRUE if PHY is capable of VHT Proprietary Rates */
static bool
wlc_phy_ac_proprietary_rates(phy_info_t *pi)
{
	return ((ACREV_IS(pi->pubpi.phy_rev, 1)) ||
		(ACREV_IS(pi->pubpi.phy_rev, 3)) ||
		(ACREV_GE(pi->pubpi.phy_rev, 6)));
}

/** Returns TRUE if PHY is capable of 11n Proprietary Rates */
static bool
wlc_phy_ac_ht_proprietary_rates(phy_info_t *pi)
{
	return BCM43602_CHIP(pi->sh->chip); /* 43602 has no capability register */
}

/** Returns True if PHY is capable of STBC */
/* currently returns 1 for all ACPHY except 4335A0/B0 */
static bool
wlc_phy_ac_stbc_capable(phy_info_t *pi)
{
	return !(ACMAJORREV_1(pi->pubpi.phy_rev) &&
		(ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev)));
}

uint32
wlc_phy_ac_caps(phy_info_t *pi)
{
	uint32 cap = (PHY_CAP_40MHZ | PHY_CAP_SGI | PHY_CAP_LDPC);
	uint32 cap_256QAM_en = 0;

	cap_256QAM_en = CHSPEC_IS2G(pi->radio_chanspec) ? (pi->phycap & PHY_CAP_QAM256_24G) :
		(pi->phycap & PHY_CAP_QAM256_5G);

	cap |= pi->phycap & PHY_CAP_80MHZ;
	cap |= (wlc_phy_ac_proprietary_rates(pi) && cap_256QAM_en) ? PHY_CAP_VHT_PROP_RATES : 0;
	cap |= wlc_phy_ac_ht_proprietary_rates(pi) ? PHY_CAP_HT_PROP_RATES : 0;
	cap |= wlc_phy_ac_stbc_capable(pi) ? PHY_CAP_STBC : 0;

	return cap;
}

/**
 * initialize the static tables defined in auto-generated wlc_phytbl_ac.c,
 * see acphyprocs.tcl, proc acphy_init_tbls
 * After called in the attach stage, all the static phy tables are reclaimed.
 */
static void
WLBANDINITFN(wlc_phy_static_table_download_acphy)(phy_info_t *pi)
{
	uint idx;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	if (pi->phy_init_por) {
		/* these tables are not affected by phy reset, only power down */
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			for (idx = 0; idx < acphytbl_info_sz_rev9; idx++) {
				wlc_phy_write_table_ext(pi, &acphytbl_info_rev9[idx],
					ACPHY_TableID(pi->pubpi.phy_rev),
					ACPHY_TableOffset(pi->pubpi.phy_rev),
					ACPHY_TableDataWide(pi->pubpi.phy_rev),
					ACPHY_TableDataHi(pi->pubpi.phy_rev),
					ACPHY_TableDataLo(pi->pubpi.phy_rev));
			}
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			for (idx = 0; idx < acphytbl_info_sz_rev3; idx++) {
				wlc_phy_write_table_ext(pi, &acphytbl_info_rev3[idx],
					ACPHY_TableID(pi->pubpi.phy_rev),
					ACPHY_TableOffset(pi->pubpi.phy_rev),
					ACPHY_TableDataWide(pi->pubpi.phy_rev),
					ACPHY_TableDataHi(pi->pubpi.phy_rev),
					ACPHY_TableDataLo(pi->pubpi.phy_rev));
			}
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			if (ACREV_IS(pi->pubpi.phy_rev, 6))	{
				for (idx = 0; idx < acphytbl_info_sz_rev6; idx++) {
					wlc_phy_write_table_ext(pi, &acphytbl_info_rev6[idx],
						ACPHY_TableID(pi->pubpi.phy_rev),
						ACPHY_TableOffset(pi->pubpi.phy_rev),
						ACPHY_TableDataWide(pi->pubpi.phy_rev),
						ACPHY_TableDataHi(pi->pubpi.phy_rev),
						ACPHY_TableDataLo(pi->pubpi.phy_rev));
				}
			} else {
				for (idx = 0; idx < acphytbl_info_sz_rev2; idx++) {
					wlc_phy_write_table_ext(pi, &acphytbl_info_rev2[idx],
						ACPHY_TableID(pi->pubpi.phy_rev),
						ACPHY_TableOffset(pi->pubpi.phy_rev),
						ACPHY_TableDataWide(pi->pubpi.phy_rev),
						ACPHY_TableDataHi(pi->pubpi.phy_rev),
						ACPHY_TableDataLo(pi->pubpi.phy_rev));
				}
			}
		} else if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
			for (idx = 0; idx < acphytbl_info_sz_rev0; idx++) {
				wlc_phy_write_table_ext(pi, &acphytbl_info_rev0[idx],
					ACPHY_TableID(pi->pubpi.phy_rev),
					ACPHY_TableOffset(pi->pubpi.phy_rev),
					ACPHY_TableDataWide(pi->pubpi.phy_rev),
					ACPHY_TableDataHi(pi->pubpi.phy_rev),
					ACPHY_TableDataLo(pi->pubpi.phy_rev));
			}
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_detach_acphy(phy_info_t *pi)
{
	int num_bw;
	int core;
#ifdef ACPHY_1X1_ONLY
	num_bw = 1;
#else
	num_bw = ACPHY_NUM_BW;
#endif // endif

	wlc_phy_ac_delete_gain_tbl(pi);

	if (pi->u.pi_acphy->cal_tempcomp != NULL)
		MFREE(pi->sh->osh, pi->u.pi_acphy->cal_tempcomp,
		      sizeof(acphy_cal_tempcomp_t));

	if (pi->u.pi_acphy->fectrl_idx != NULL)
		MFREE(pi->sh->osh, pi->u.pi_acphy->fectrl_idx,
		      pi->u.pi_acphy->fectrl_sparse_table_len * sizeof(uint16));
	if (pi->u.pi_acphy->fectrl_val != NULL)
		MFREE(pi->sh->osh, pi->u.pi_acphy->fectrl_val,
		      pi->u.pi_acphy->fectrl_sparse_table_len * sizeof(uint16));

	FOREACH_CORE(pi, core) {
		if (pi->u.pi_acphy->fectrl_c[core].subtable != NULL)
			MFREE(pi->sh->osh, pi->u.pi_acphy->fectrl_c[core].subtable,
				pi->u.pi_acphy->fectrl_c[core].n_entries * sizeof(uint8));
	}

	if (pi->u.pi_acphy->tx_farrow != NULL)
		MFREE(pi->sh->osh, pi->u.pi_acphy->tx_farrow,
		      num_bw * sizeof(*(pi->u.pi_acphy->tx_farrow)));
	if (pi->u.pi_acphy->rx_farrow != NULL)
		MFREE(pi->sh->osh, pi->u.pi_acphy->rx_farrow,
		      num_bw * sizeof(*(pi->u.pi_acphy->rx_farrow)));

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			if (PHY_XTAL_IS52M(pi)) {
				if (pi->u.pi_acphy->chan_tuning != NULL) {
					MFREE(pi->sh->osh, pi->u.pi_acphy->chan_tuning,
						NUM_ROWS_CHAN_TUNING_2069 *
						sizeof(chan_info_radio2069revGE25_52MHz_t));
				}
			}

		} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			if (pi->u.pi_acphy->chan_tuning != NULL) {
				MFREE(pi->sh->osh, pi->u.pi_acphy->chan_tuning,
				      NUM_ROWS_CHAN_TUNING_2069 *
				      sizeof(chan_info_radio2069revGE32_t));
			}
		}
	}
#ifndef WLC_DISABLE_ACI
	if (ACHWACIREV(pi)) {
		MFREE(pi->sh->osh, pi->u.pi_acphy->def_gains,
			sizeof(acphy_hwaci_defgain_settings_t));
	}
#endif // endif
	MFREE(pi->sh->osh, pi->u.pi_acphy, sizeof(phy_info_acphy_t));

}
void
wlc_phy_resetcca_acphy(phy_info_t *pi)
{
	/* MAC should be suspended before calling this function */
	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);

	/* bilge count sequence fix */
	if ((ACMAJORREV_1(pi->pubpi.phy_rev) &&
	     (ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev))) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);

		MOD_PHYREG(pi, BBConfig, resetCCA, 1);
		OSL_DELAY(1);
		if (!TINY_RADIO(pi)) {
			MOD_PHYREG(pi, RxFeCtrl1, rxfe_bilge_cnt, 0);
			OSL_DELAY(1);
		}
		MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 1);
		OSL_DELAY(1);
		wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
		OSL_DELAY(1);
		MOD_PHYREG(pi, BBConfig, resetCCA, 0);
		OSL_DELAY(1);
		MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 0);
	} else {
		wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);

		/* # force gated clock on */
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, 0x6); /* set reg(PHY_CTL) 0x6 */
		MOD_PHYREG(pi, BBConfig, resetCCA, 1);
		OSL_DELAY(1);
		MOD_PHYREG(pi, BBConfig, resetCCA, 0);
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, 0x2); /* set reg(PHY_CTL) 0x2 */

		wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
	}

	if (AC4354REV(pi) && (PHY_XTAL_IS37M4(pi))) {
		OSL_DELAY(15);
	}
	/* wait for reset2rx finish, which is triggered by resetcca in hw */
	OSL_DELAY(15);
}

static void
BCMATTACHFN(wlc_phy_rfldo_trim_value)(phy_info_t *pi)
{

	uint8 otp_select;
	uint16 otp = 0;

	uint32 sromctl;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	sromctl = si_get_sromctl(pi->sh->sih);
	otp_select = (sromctl >> 4) & 0x1;
	if (otp_select == 0)
		si_set_sromctl(pi->sh->sih, sromctl | (1 << 4));
	otp_read_word(pi->sh->sih, 16, &otp);
	if (otp_select == 0)
		si_set_sromctl(pi->sh->sih, sromctl);
	otp = (otp >> 8) & 0x1f;

	pi->u.pi_acphy->rfldo = otp;
}

static void
WLBANDINITFN(wlc_phy_init_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint32 rfldo = 0;
	uint8 phyver, core;
#ifdef ENABLE_FCBS
	int chanidx;
	uint32 tmp_val[160];
	uint8 stall_val;
	chanidx = 0;
	tmp_val[0] = 0;
	stall_val = 0;
#endif // endif

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

#ifdef WL_PROXDETECT
	wlc_phy_tof_reset_acphy(pi);
#endif // endif

	if (ACMAJORREV_5(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev))) {
		ACPHY_ENABLE_STALL(pi, 0);
	}

	/* Enable VHT prorietary rates if the PHY supports it */
	if (wlc_phy_ac_proprietary_rates(pi)) {
		MOD_PHYREG(pi, HTSigTones, ldpc_proprietary_mcs_vht, 1);
	}

	phyver = READ_PHYREGFLD(pi, Version, version);
	if (ACMAJORREV_5(pi->pubpi.phy_rev) ||
		ACMAJORREV_0(pi->pubpi.phy_rev)) {
		if (phyver == 0) {
			/* 4360a0 */
			if (pi_ac->rfldo == 0) {
				/* Use rfldo = 1.26 V for phyver = 0 by default */
				rfldo = 5;
			} else {
				rfldo = pi_ac->rfldo;
			}
		} else {
			/* 4360b0 and 43602 */
			if (pi_ac->rfldo <= 3) {
				rfldo = 0;
			} else {
				rfldo = pi_ac->rfldo - 3;
			}
		}
		if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
			rfldo = rfldo << 20;
			si_pmu_regcontrol(pi->sh->sih, 0, 0x1f00000, rfldo);
		} else {
			rfldo = rfldo << 17;
			si_pmu_regcontrol(pi->sh->sih, 0, 0x3E0000, rfldo);
		}
	}

#ifdef PREASSOC_PWRCTRL
	FOREACH_CORE(pi, core) {
		pi_ac->pwr_ctrl_save.status_idx_carry_2g[core] = FALSE;
		pi_ac->pwr_ctrl_save.status_idx_carry_5g[core] = FALSE;
	}
#endif // endif
	/* Check if board uses internal 3.3V LDOs to supply the iPAs
	 * and enable the LDOs if used
	 */
	if ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_PALDO) != 0) {
		if (BCM4350_CHIP(pi->sh->chip)) {
			si_pmu_regcontrol(pi->sh->sih, 0x7, 0x100, 0x100);
		}
	}

	/* Start with PHY not controlling any gpio's */
	si_gpiocontrol(pi->sh->sih, 0xffff, 0, GPIO_DRV_PRIORITY);

	if (!ACMAJORREV_3(pi->pubpi.phy_rev)) {
		/* Only supported in ucode for mac revid 40 and 42 */
		/* ucode hirssi detect - bypass lna1 to save it */
		wlc_phy_hirssi_elnabypass_init_acphy(pi);
	}

	if (BCM43602_CHIP(pi->sh->chip)) {
		/* JIRA:HW43602-197 WAR:
		 * start with disabling PAVREF programming by ucode;
		 * it will be enabled for MCH2/MCH5 boards later on
		 */
		W_REG(pi->sh->osh, &pi->regs->psm_int_sel_1, 0x0);
	}
	/* Initialize deaf_count */
	pi_ac->deaf_count = 0;

	/* Init regs/tables only once that do not get reset on phy_reset */
	wlc_phy_set_regtbl_on_pwron_acphy(pi);

	/* Call chan_change with default chan */
	pi_ac->init = TRUE;
	pi_ac->bt_sw_state = AUTO;

	if (pi->phy_init_por) {
		pi_ac->mdgain_trtx_allowed = FALSE;
	}

	FOREACH_CORE(pi, core) {
		pi_ac->txpwr_idx_band_cache[core] = TXPWR_INDEX_INVALID;
		pi_ac->txpwr_idx_band_cck_cache[core] = TXPWR_INDEX_INVALID;
	}
	wlc_phy_chanspec_set_acphy(pi, pi->radio_chanspec);

#if defined(AP) && defined(RADAR)
	/* Initialze Radar detect, on or off */
	wlc_phy_radar_detect_init(pi, pi->sh->radar);
#endif /* defined(AP) && defined(RADAR) */

	pi_ac->init = FALSE;
	pi_ac->init_done = TRUE;
	/* Sets Assert and Deassert thresholds for all 20MHz subbands for EDCRS */

	/* edcrs phyreg is shdowed.
	 * For shadowed reg/table, initialed values have to be put on both sets.
	 */
#ifdef ENABLE_FCBS
	if (IS_FCBS(pi)) {
		for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
			wlc_phy_prefcbsinit_acphy(pi, chanidx);
			wlc_phy_edcrs_thresh_acphy(pi);
		}
		wlc_phy_prefcbsinit_acphy(pi, 0);
	} else {
		wlc_phy_edcrs_thresh_acphy(pi);
	}
#else
	wlc_phy_edcrs_thresh_acphy(pi);
#endif // endif
	if (pi->region_group ==  REGION_EU)
		wlc_phy_set_srom_eu_edthresh_acphy(pi);

#if defined(WLTEST)
	/* Consider not to enable PHY timeout in non-customer builds so that the hang is seen
	 * and appropriate actions can be taken to diagnose the hang
	 */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev)) {
#else /* defined(BCMINTERNAL) || defined(WLTEST) */
	/* For customer builds we like to enable PHY timeouts that will catch when
	 * pktproc is hanging and reset the PHY
	 */
	{ /* unconditionally enable timeouts for production images */
#endif // endif
		/* PR 108090 / Jira SW4345-255 SWWLAN-58194
		 * Reset the PHY if we are too long in CCK/OFDM payload decode state
		 */
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, timeoutEn, cckpaydecodetimeoutEn, 1)
			MOD_PHYREG_ENTRY(pi, timeoutEn, ofdmpaydecodetimeoutEn, 1)
			MOD_PHYREG_ENTRY(pi, timeoutEn, resetRxontimeout, 1)
			WRITE_PHYREG_ENTRY(pi, ofdmpaydecodetimeoutlen, 0x7d0)
			WRITE_PHYREG_ENTRY(pi, cckpaydecodetimeoutlen, 0x7d0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	if (pi->phy_init_por)
		pi->interf.curr_home_channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (TINY_RADIO(pi)) {
		wlc_phy_tiny_rfseq_mode_set(pi, 1);
	}
	wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
	if (TINY_RADIO(pi)) {
		wlc_phy_tiny_rfseq_mode_set(pi, 0);
	}

#ifdef ENABLE_FCBS
	/* For shadowed reg/table, initialed values have to be put on both sets.
	 * Here I copy initialed values from setA to setB
	 */
	if (IS_FCBS(pi)) {
		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		ACPHY_DISABLE_STALL(pi);

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL,
			160, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL,
			160, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_PAPR,
			68, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR,
			68, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS0,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS0,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN0,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN0,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS1,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS1,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN1,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN1,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS2,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS2,
			128, 0, 16, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN2,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RSSICLIPGAIN2,
			19, 0, 32, &tmp_val);
		wlc_phy_prefcbsinit_acphy(pi, 0);
		ACPHY_ENABLE_STALL(pi, stall_val);
	}
#endif /* ENABLE_FCBS */
	/* SW4345-273 Add TXBF support for 4345 */
#if defined(WL_BEAMFORMING)
	if ((ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_3(pi->pubpi.phy_rev)))
		MOD_PHYREG(pi, FrontEndDebug, txbfReportReadEn, 0x01);
#endif // endif

#ifdef WLC_SW_DIVERSITY
	wlc_phy_swdiv_init_acphy(pi);
#if defined(WLC_TXPWRCAP)
	/* Reset Cell Status at init */
	wlc_phy_txpwrcap_set_cellstatus_acphy(pi, TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK,
		TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK);
#endif /* WLC_TXPWRCAP */
#endif /* WLC_SW_DIVERSITY */

	/* simultaneous RX for all 4350 chips with shared LNA, under hybrid mode */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
		(BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_FEM_BT)) {

		wlc_phy_btcx_hybrid_mode_simul_rx_acphy(pi, pi_ac->btcx_hybrid_mode_simul_rx.mode);
	}

#if defined(ACMAJORREV2_THROUGHPUT_OPT)
	if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) && (RADIOREV(pi->pubpi.radiorev) != 45) &&
	        (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
		(pi->u.pi_acphy->en_xtalldowar_2069)) {
		pi->pubpi.xtalldo_war_2069 = 1;
	} else {
		pi->pubpi.xtalldo_war_2069 = 0;
	}
#endif /* ACMAJORREV2_THROUGHPUT_OPT */

}

/* enable/disable receiving of LDPC frame */
void
wlc_phy_update_rxldpc_acphy(phy_info_t *pi, bool ldpc)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (ldpc != pi_ac->ac_rxldpc_override) {
		pi_ac->ac_rxldpc_override = ldpc;

		MOD_PHYREG(pi, HTSigTones, support_ldpc, (ldpc) ? 1 : 0);
	}
}

static void
WLBANDINITFN(wlc_phy_edcrs_thresh_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	int32 ed_thresh;
	int32 assert_dBm;

	pi_ac->srom.ed_thresh_default = -69;	/* To pass EU Adaptivity */

	ed_thresh = CHSPEC_IS2G(pi->radio_chanspec) ?
		pi_ac->srom.ed_thresh2g : pi_ac->srom.ed_thresh5g;

	assert_dBm = (ed_thresh != 0) ?
		ed_thresh : pi_ac->srom.ed_thresh_default;

	wlc_phy_adjust_ed_thres_acphy(pi, &assert_dBm, TRUE);
}

void wlc_phy_adjust_ed_thres_acphy(phy_info_t *pi, int32 *assert_thresh_dbm, bool set_threshold)
{
	/* Set the EDCRS Assert and De-assert Threshold
	The de-assert threshold is set to 6dB lower then the assert threshold
	Accurate Formula:64*log2(round((10.^((THRESHOLD_dBm +65-30)./10).*50).*(2^9./0.4).^2))
	Simplified Accurate Formula: 64*(THRESHOLD_dBm + 75)/(10*log10(2)) + 832;
	Implemented Approximate Formula: 640000*(THRESHOLD_dBm + 75)/30103 + 832;
	*/
	int32 assert_thres_val, de_assert_thresh_val;

	if (set_threshold == TRUE) {
		assert_thres_val = (640000*(*assert_thresh_dbm + 75) + 25045696)/30103;
		de_assert_thresh_val = (640000*(*assert_thresh_dbm + 69) + 25045696)/30103;
		/* Set the EDCRS Assert Threshold */
		WRITE_PHYREG(pi, ed_crs20LAssertThresh0, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20LAssertThresh1, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20UAssertThresh0, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20UAssertThresh1, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20Lsub1AssertThresh0, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20Lsub1AssertThresh1, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20Usub1AssertThresh0, (uint16)assert_thres_val);
		WRITE_PHYREG(pi, ed_crs20Usub1AssertThresh1, (uint16)assert_thres_val);

		/* Set the EDCRS De-assert Threshold */
		WRITE_PHYREG(pi, ed_crs20LDeassertThresh0, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20LDeassertThresh1, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20UDeassertThresh0, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20UDeassertThresh1, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20Lsub1DeassertThresh0, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20Lsub1DeassertThresh1, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20Usub1DeassertThresh0, (uint16)de_assert_thresh_val);
		WRITE_PHYREG(pi, ed_crs20Usub1DeassertThresh1, (uint16)de_assert_thresh_val);
	}
	else {
		assert_thres_val = READ_PHYREG(pi, ed_crs20LAssertThresh0);
		*assert_thresh_dbm = ((((assert_thres_val - 832)*30103)) - 48000000)/640000;
	}
}

static void
wlc_phy_set_srom_eu_edthresh_acphy(phy_info_t *pi)
{
	int32 eu_edthresh;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	eu_edthresh = CHSPEC_IS2G(pi->radio_chanspec) ?
		pi->srom_eu_edthresh2g : pi->srom_eu_edthresh5g;
	if (eu_edthresh < -10) /* 0 & 0xff(-1) are invalid values */
		wlc_phy_adjust_ed_thres_acphy(pi, &eu_edthresh, TRUE);
	else
		wlc_phy_adjust_ed_thres_acphy(pi, &pi_ac->srom.ed_thresh_default, TRUE);
}

/* return status of energy-detect(ED)/carrier-sense(CRS) */
bool
wlc_phy_eu_edcrs_detect_acphy(phy_info_t *pi)
{
	bool suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	bool edcrs = FALSE;

	uint loop_count = 50, percentage = 75, edcrs_high_count = 0;
	uint16 reg_val;
	uint8 j = 0;

	/* ETSI 50mS backoff requirement is for EU region only */
	if (pi->region_group != REGION_EU)
		return edcrs;

	/* suspend mac if haven't done so */
	if (!suspend)
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Check EDCRS a few times to decide if the medium is busy */
	/* If medium is busy, skip phy cal this time around */
	for (j = 0; j < loop_count; j++) {
		reg_val = phy_reg_read(pi, ACPHY_ed_crs(rev));
		if ((reg_val & 0xfff) > 0) {
			edcrs_high_count++;
		}
	}
	if (100*edcrs_high_count > (loop_count*percentage))
		edcrs = TRUE;

	wlc_phyreg_exit((wlc_phy_t *)pi);

	if (!suspend)
		wlapi_enable_mac(pi->sh->physhim);

	return edcrs;
}

static void
WLBANDINITFN(wlc_phy_cal_init_acphy)(phy_info_t *pi)
{
	PHY_TRACE(("%s: NOT Implemented\n", __FUNCTION__));
}

static void
wlc_phy_chanspec_set_acphy(phy_info_t *pi, chanspec_t chanspec)
{
	int freq;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	const void *chan_info = NULL;
	bool band_changed = FALSE, bw_changed = FALSE, phy_init = pi_ac->init;
	uint8 max_rxchain, lpf_gain, lpf_bw, biq_bw_ofdm, biq_bw_cck;
	uint8 ch = CHSPEC_CHANNEL(chanspec);
	uint8 orig_rxfectrl1, core;
	uint8 tx_pwr_ctrl_state = PHY_TPC_HW_OFF;

	bool papr_enable = !(pi->u.pi_acphy->srom_paprdis);
#ifdef BBPLL_PARR
	uint32 min_res_mask = 0, max_res_mask = 0, clk_ctl_st = 0;
#endif /* BBPLL_PARR */
#ifdef ENABLE_FCBS
	int chanidx, chanidx_current;
	chanidx = 0;
	chanidx_current = 0;
#endif // endif
	/* If olpc_thresh is present from nvram but olpc_thresh2g/5g is not,
	 * use olpc_thresh value;
	 * If olpc_thresh2g/5g is present from nvram, then use it
	 * the IOVAR olpc_thresh can still be used to override nvram value
	 */
	if (pi->olpc_thresh_iovar_ovr != 1) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (pi->olpc_thresh2g != 0) {
				pi->olpc_thresh = pi->olpc_thresh2g;
			}
		} else {
			if (pi->olpc_thresh5g != 0) {
				pi->olpc_thresh = pi->olpc_thresh5g;
			}
		}
	}

	wlapi_bmac_mhf(pi->sh->physhim, MHF5, MHF5_AFE_WAR, 0, WLC_BAND_ALL);
	pi->open_loop_pwrctrl_init = 1;
	PHY_TRACE(("wl%d: %s chan = %d\n", pi->sh->unit, __FUNCTION__, ch));

	if (CHSPEC_IS5G(chanspec)) {
		wlapi_bmac_write_shm(pi->sh->physhim, M_PAPDOFF_MCS, -1);
	} else {
		wlapi_bmac_write_shm(pi->sh->physhim, M_PAPDOFF_MCS, pi->u.pi_acphy->srom_papdwar);
	}

	/* Disable any ongoing ACI/FCBS if in progress */
	if (ACPHY_ENABLE_FCBS_HWACI(pi))
	    wlc_phy_hwaci_mitigation_enable_acphy_tiny(pi, 0,  FALSE);

	/* 4335: low power mode selection based on 2G or 5G  */
	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS2G(pi->radio_chanspec))
		{
			pi_ac->acphy_lp_mode = 2;
		} else {
			pi_ac->acphy_lp_mode = 1;
		}
		pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
		pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
		(void) wlc_phy_chan2freq_acphy(pi, ch, &freq, &chan_info);
	} else {
		(void) wlc_phy_chan2freq_20691(pi, ch, &freq, &chan_info);
	}

	if (pi_ac->init)
	{
		if (!ACMAJORREV_0(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, BT_SwControl, inv_btcx_prisel, 0x1);
		}
	}

	/* BAND CHANGED */
	if (phy_init || (pi_ac->curr_band2g != CHSPEC_IS2G(chanspec))) {
		/* Before changing chan, store/clear the hirssi(shmem) info of previous channel */
		if (PHY_SW_HIRSSI_UCODE_CAP(pi)) {
			if (wlc_phy_hirssi_elnabypass_shmem_read_clear_acphy(pi)) {
				/* Check for previous channel */
				if (pi_ac->curr_band2g) {
					if (pi_ac->hirssi_elnabyp2g_en)
						pi_ac->hirssi_timer2g = pi_ac->hirssi_period;
				} else {
					if (pi_ac->hirssi_elnabyp5g_en)
						pi_ac->hirssi_timer5g = pi_ac->hirssi_period;
				}
			}
		}

		pi_ac->curr_band2g = CHSPEC_IS2G(chanspec);
		band_changed = TRUE;
	}
	if (band_changed) {
		FOREACH_CORE(pi, core) {
			if (pi_ac->txpwr_idx_band_cache[core] != TXPWR_INDEX_INVALID) {
				pi->base_index_init[core] = pi_ac->txpwr_idx_band_cache[core];
				pi_ac->txpwr_idx_band_cache[core] =
					READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, baseIndex);
				if (TINY_RADIO(pi)) {
					pi->base_index_cck_init[core] =
						pi_ac->txpwr_idx_band_cck_cache[core];
					pi_ac->txpwr_idx_band_cck_cache[core] =
						READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_cck_path, core,
							baseIndex_cck);
	            }
	        } else {
				pi->base_index_init[core] =
					CHSPEC_IS2G(pi->radio_chanspec) ?
					pi->init_tx_idx_2g : pi->init_tx_idx_5g;

				/* Note the inversion on the band test: the cache is holding the
				* latest value for the other band, restored when we switch back.
				*/
				pi_ac->txpwr_idx_band_cache[core] =
					!CHSPEC_IS2G(pi->radio_chanspec) ?
					pi->init_tx_idx_2g : pi->init_tx_idx_5g;

				if (TINY_RADIO(pi)) {
					pi->base_index_cck_init[core] =
						CHSPEC_IS2G(pi->radio_chanspec) ?
						pi->init_tx_idx_2g + pi->sh->cckPwrIdxCorr
						: pi->init_tx_idx_5g;

					pi_ac->txpwr_idx_band_cck_cache[core] =
						!CHSPEC_IS2G(pi->radio_chanspec) ?
						pi->init_tx_idx_2g + pi->sh->cckPwrIdxCorr
						: pi->init_tx_idx_5g;
				}
			}

			wlc_phy_txpwrctrl_set_baseindex(pi, core,
				pi->base_index_init[core], ACPHY_ENC_OFDM);

			if (TINY_RADIO(pi)) {
				wlc_phy_txpwrctrl_set_baseindex(pi, core,
					pi->base_index_cck_init[core], ACPHY_ENC_CCK);
			}
	    }

		wlc_phy_update_ed_thres_acphy(pi, chanspec);
	}

#ifdef WLC_SW_DIVERSITY
	wlc_phy_swdiv_ovr_set_acphy(pi);
#endif // endif

	/* Hold FIFOs in reset before changing channels */
	orig_rxfectrl1 = READ_PHYREGFLD(pi, RxFeCtrl1, soft_sdfeFifoReset);
	MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 1);

	if (phy_init || (pi_ac->curr_bw != CHSPEC_BW(chanspec))) {
		pi_ac->curr_bw = CHSPEC_BW(chanspec);
		bw_changed = TRUE;

		/* If called from init, don't call this, as this is called before init */
		if (!pi_ac->init) {

			/* Set the phy BW as dictated by the chanspec (also calls phy_reset) */
			wlapi_bmac_bw_set(pi->sh->physhim, CHSPEC_BW(chanspec));

			/* bw change  do not need a phy_reset when BW_RESET == 1 */
			if (BW_RESET == 0) {
				phy_init = TRUE;
			} else {
				if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
				    CHSPEC_IS80(chanspec)) {
				        WRITE_PHYREG(pi, SpareReg, 0xfe);
					wlc_phy_resetcca_acphy(pi);
					WRITE_PHYREG(pi, SpareReg, 0xff);
				}
			}
		}

		OSL_DELAY(2);
	}

	/* Change the band bit. Do this after phy_reset */
	if (CHSPEC_IS2G(chanspec)) {
		MOD_PHYREG(pi, ChannelControl, currentBand, 0);
	} else {
		MOD_PHYREG(pi, ChannelControl, currentBand, 1);
	}

	/* JIRA(CRDOT11ACPHY-143) : Turn off receiver duing channel change */
	pi_ac->deaf_count = 0;    /* First, reset the deaf_count */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* channel specifi PLL frequency only for 4335/4345 WLBGA */
#ifdef BBPLL_PARR
	if ((pi->sh->chippkg == BCM4335_WLBGA_PKG_ID &&
	    (((CHIPID(pi->sh->chip) == BCM4345_CHIP_ID ||
#ifdef UNRELEASEDCHIP
		CHIPID(pi->sh->chip) == BCM43457_CHIP_ID ||
#endif /* UNRELEASEDCHIP */
		FALSE) && !CST4345_CHIPMODE_USB20D(pi->sh->sih->chipst)))) ||
		(CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
	     pi->sh->chippkg == BCM4335_FCBGA_PKG_ID)) {
	        wlc_phy_get_spurmode(pi, (uint16)freq);
		if ((pi_ac->curr_spurmode != pi->acphy_spuravoid_mode)) {
		  si_pmu_pll_off_PARR(pi->sh->sih, pi->sh->osh, &min_res_mask,
		  &max_res_mask, &clk_ctl_st);
		}
	}
#else
	if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
	     pi->sh->chippkg == BCM4335_FCBGA_PKG_ID)
			wlc_phy_set_spurmode(pi, (uint16)freq);
#endif /* BBPLL_PARR */

#if defined(WLOLPC) || defined(BCMDBG) || defined(WLTEST)
	pi_ac->olpc_dbg_mode = FALSE; /* Clearing the olpc cal done only during dbg mode */
#endif /* WLOLPC || BCMDBG || WLTEST */
	/* Change the channel, and then load registers, in the meantime vco_cal should settle */
	/* logen_reset needs to be toggled whnenever bandsel bit is changed */
	/* On a bw change, phy_reset is issued which causes currentBand to toggle */
	/* So, issue logen_reset on both band & bw change */
	wlc_phy_chanspec_radio_set((wlc_phy_t *)pi, chanspec);
	if (chan_info != NULL) {
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
			wlc_phy_chanspec_radio20691_setup(pi, chan_info, band_changed | bw_changed);
		else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
			wlc_phy_chanspec_radio20693_setup(pi, chan_info, band_changed | bw_changed);
		else
			wlc_phy_chanspec_radio2069_setup(pi, chan_info, band_changed | bw_changed);
	}

	/* Restore FIFO reset and Stalls */
	MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, orig_rxfectrl1);

	if (phy_init) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (pi_ac->srom.nvram_femctrl.txswctrlmap_2g) {
				pi_ac->pa_mode = (pi_ac->srom.nvram_femctrl.txswctrlmap_2g_mask >>
					(CHSPEC_CHANNEL(pi->radio_chanspec) - 1)) & 1;
			} else {
				pi_ac->pa_mode = 0;
			}
		} else {
			pi_ac->pa_mode = pi_ac->srom.nvram_femctrl.txswctrlmap_5g;
		}

		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		    PHY_ILNA(pi)) {
			si_gci_chipcontrol(pi->sh->sih, CC_GCI_CHIPCTRL_06,
			                   CC_GCI_XTAL_BUFSTRG_NFC, (0x1 << 12));
		}

		if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev) &&
		    PHY_ILNA(pi)) {
			si_gci_chipcontrol(pi->sh->sih, CC_GCI_CHIPCTRL_06,
			                   CC_GCI_XTAL_BUFSTRG_NFC, (0x1 << 12));
		}

		wlc_phy_set_reg_on_reset_acphy(pi);
		wlc_phy_set_tbl_on_reset_acphy(pi);
#ifdef ENABLE_FCBS
		if (IS_FCBS(pi)) {
			chanidx_current = wlc_phy_channelindicator_obtain_acphy(pi);
			for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
				if (chanidx != chanidx_current) {
					wlc_phy_prefcbsinit_acphy(pi, chanidx);
					wlc_phy_set_reg_on_reset_acphy(pi);
					wlc_phy_set_tbl_on_reset_acphy(pi);
				}
			}
			wlc_phy_prefcbsinit_acphy(pi, chanidx_current);
		}
#endif /* ENABLE_FCBS */

		/* If any rx cores were disabled before phy_init,
		 * disable them again since phy_init enables all rx cores
		 * Also make RfseqCoreActv2059.EnTx = hw_txchain & rxchain
		 */
		max_rxchain =  (1 << READ_PHYREGFLD(pi, PhyCapability0, NumberOfStreams)) - 1;
		if ((pi->sh->phyrxchain != max_rxchain) || (pi->sh->hw_phytxchain != max_rxchain)) {
			wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		}
	}

	if (!phy_init && CHSPEC_IS2G(pi->radio_chanspec) &&
		pi_ac->srom.nvram_femctrl.txswctrlmap_2g &&
		(pi_ac->pa_mode ^ ((pi_ac->srom.nvram_femctrl.txswctrlmap_2g_mask >>
		(CHSPEC_CHANNEL(pi->radio_chanspec) - 1)) & 1)) &&
		!ACPHY_FEMCTRL_ACTIVE(pi)) {

		pi_ac->pa_mode = (pi_ac->srom.nvram_femctrl.txswctrlmap_2g_mask >>
		(CHSPEC_CHANNEL(pi->radio_chanspec) - 1)) & 1;
		wlc_phy_write_regtbl_fc_from_nvram(pi);
	}

	if (phy_init || band_changed) {
		wlc_phy_set_regtbl_on_band_change_acphy(pi);
#ifdef ENABLE_FCBS
		if (IS_FCBS(pi)) {
			chanidx_current = wlc_phy_channelindicator_obtain_acphy(pi);
			for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
				if ((chanidx != chanidx_current) &&
					(!(pi->phy_fcbs.initialized[chanidx]))) {
					wlc_phy_prefcbsinit_acphy(pi, chanidx);
					wlc_phy_set_regtbl_on_band_change_acphy(pi);
				}
			}
			wlc_phy_prefcbsinit_acphy(pi, chanidx_current);
		}
#endif /* ENABLE_FCBS */
	}
	if (phy_init || bw_changed) {
		wlc_phy_set_regtbl_on_bw_change_acphy(pi);
#ifdef ENABLE_FCBS
		if (IS_FCBS(pi)) {
			chanidx_current = wlc_phy_channelindicator_obtain_acphy(pi);
			for (chanidx = 0; chanidx < MAX_FCBS_CHANS; chanidx++) {
				if ((chanidx != chanidx_current) &&
					(!(pi->phy_fcbs.initialized[chanidx]))) {
					wlc_phy_prefcbsinit_acphy(pi, chanidx);
					wlc_phy_set_regtbl_on_bw_change_acphy(pi);
				}
			}
			wlc_phy_prefcbsinit_acphy(pi, chanidx_current);
		}
#endif /* ENABLE_FCBS */
	}
	if (TINY_RADIO(pi)) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			pi_ac->dac_mode = CHSPEC_IS2G(pi->radio_chanspec)
			? pi->dacratemode2g[0] : pi->dacratemode5g[0];
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			pi_ac->dac_mode = CHSPEC_IS2G(pi->radio_chanspec)
			? pi->dacratemode2g[1] : pi->dacratemode5g[1];
			if (CHSPEC_IS5G(pi->radio_chanspec) && (pi->u.pi_acphy->logenmode43 == 1))
				pi->u.pi_acphy->dac_mode = 1;
		} else {
			pi_ac->dac_mode = 1;
		}
		wlc_phy_dac_rate_mode_acphy(pi, pi_ac->dac_mode);
	}
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !PHY_IPA(pi)) {
		pi_ac->dac_mode = 1;
	}
	if (chan_info != NULL)
		wlc_phy_set_regtbl_on_chan_change_acphy(pi, chan_info);

	if (PHY_SW_HIRSSI_UCODE_CAP(pi)) {
		/* Update ucode settings based on current band/bw */
		if (phy_init || band_changed || bw_changed) {
			wlc_phy_hirssi_elnabypass_set_ucode_params_acphy(pi);
		}
	}

	/* Rx gainctrl (if not QT) */
	if (!ISSIM_ENAB(pi->sh->sih)) {
		pi_ac->aci = NULL;
		if (!wlc_phy_is_scan_chan_acphy(pi)) {
			pi->interf.curr_home_channel = CHSPEC_CHANNEL(pi->radio_chanspec);

#ifndef WLC_DISABLE_ACI
			if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
				/* Get pointer to current aci channel list */
				pi_ac->aci = wlc_phy_desense_aci_getset_chanidx_acphy(pi, chanspec,
				                                                      TRUE);
				if (pi_ac->aci->engine_called == FALSE)
					wlc_phy_desense_aci_engine_acphy(pi, FALSE);
			}
#endif /* !WLC_DISABLE_ACI */
		}

#ifndef WLC_DISABLE_ACI
		if (!ACPHY_ENABLE_FCBS_HWACI(pi))
			/* Merge ACI & BT params into one */
			wlc_phy_desense_calc_total_acphy(pi);
#endif /* !WLC_DISABLE_ACI */

		wlc_phy_rxgainctrl_set_gaintbls_acphy(pi, phy_init, band_changed, bw_changed);

		if (TINY_RADIO(pi)) {
			wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);

			if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACREV_GE(pi->pubpi.phy_rev, 11))
				wlc_enable_lna_dcc_comp_20691(pi, 0);
		} else {
			/* Set INIT, Clip gains, clip thresh (srom based) */
			wlc_phy_rxgainctrl_gainctrl_acphy(pi);
		}

#ifndef WLC_DISABLE_ACI
		if (!ACPHY_ENABLE_FCBS_HWACI(pi))
		/* Desense on top of default gainctrl, if desense on (otherwise restore defaults) */
			wlc_phy_desense_apply_acphy(pi, pi_ac->total_desense.on);
#endif /* !WLC_DISABLE_ACI */
	}

	/* bw_change requires afe cal */
	if (pi_ac->init || bw_changed) {
		/* so that all the afe_iqadc signals are correctly set */
		wlc_phy_resetcca_acphy(pi);
		OSL_DELAY(1);
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
			wlc_phy_radio20691_afecal(pi);
		else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
			wlc_phy_radio20693_afecal(pi);
		else
			wlc_phy_radio2069_afecal(pi);
	}

	if (TINY_RADIO(pi)) {
		/* tune lpf settings for tiny */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			lpf_bw = 6;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			lpf_bw = 3;
		} else {
			lpf_bw = 5;
		}

		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			lpf_gain = 2;
		} else {
			lpf_gain = 0;
		}

		biq_bw_ofdm = lpf_bw;
		biq_bw_cck = lpf_bw - 5;
		if (!PHY_PAPDEN(pi) && !PHY_IPA(pi) && CHSPEC_IS2G(chanspec) &&
			CHSPEC_IS20(pi->radio_chanspec)) {
				/* WAR for FDIQI when bq_bw = 9, 25 MHz */
				biq_bw_ofdm = lpf_bw - 5;
		}

		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
			wlc_phy_radio20691_lpf_tx_set(pi, lpf_bw,
				lpf_gain, biq_bw_ofdm, biq_bw_cck);
		else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
			wlc_phy_radio20693_lpf_tx_set(pi, lpf_bw,
				lpf_gain, biq_bw_ofdm, biq_bw_cck);
	}

	if (TINY_RADIO(pi)) {
		/* ## dac swap */
		MOD_PHYREG(pi, Core1TxControl, iqSwapEnable, 1);
		/* ### adc swap */
		if (ACMINORREV_0(pi->pubpi.phy_rev)) {
			if (CHSPEC_IS5G(pi->radio_chanspec) && !ISSIM_ENAB(pi->sh->sih)) {
				MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, 1);
			} else {
				MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, 0);
			}
		} else {
			/* REV7 fixed adc swap */
			MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, 1);
		}
	}

	if (!ACMAJORREV_0(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, BT_SwControl, inv_btcx_prisel, 0x1);
	}

#ifdef WLC_TXCAL
	if (pi->olpc_idx_in_use)
		wlc_phy_set_olpc_anchor_acphy(pi);
#endif // endif

	/* set txgain in case txpwrctrl is disabled */
	wlc_phy_txpwr_fixpower_acphy(pi);
	tx_pwr_ctrl_state = pi->txpwrctrl;
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);

	/* Set the TSSI visibility limits for 4360 A0/B0, 4350 */
	wlc_phy_set_tssisens_lim_acphy(pi, pi->txpwroverride);

	wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);

	if (chan_info != NULL)
		wlc_phy_radio2069x_vcocal_isdone(pi, FALSE);

	/* The VCO Calibration clock driver cannot be off until after VCO Cal is done */
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		MOD_RADIO_REG_20691(pi, PLL_XTAL2, 0, xtal_pu_caldrv, 0x0);

	/* update BBPLL and power up BBPLL */
#ifdef BBPLL_PARR
	if ((pi->sh->chippkg == BCM4335_WLBGA_PKG_ID &&
	    (((CHIPID(pi->sh->chip) == BCM4345_CHIP_ID ||
#ifdef UNRELEASEDCHIP
		CHIPID(pi->sh->chip) == BCM43457_CHIP_ID ||
#endif /* UNRELEASEDCHIP */
		FALSE) && !CST4345_CHIPMODE_USB20D(pi->sh->sih->chipst)))) ||
		(CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
	     pi->sh->chippkg == BCM4335_FCBGA_PKG_ID)) {
		if (pi_ac->curr_spurmode != pi->acphy_spuravoid_mode) {
		    pi_ac->curr_spurmode =  pi->acphy_spuravoid_mode;
		    si_pmu_spuravoid_isdone(pi->sh->sih, pi->sh->osh,
		    min_res_mask, max_res_mask, clk_ctl_st, pi->acphy_spuravoid_mode);
		    wlapi_switch_macfreq(pi->sh->physhim, pi->acphy_spuravoid_mode);
		}
	  }
#endif /* BBPLL_PARR */

	/* DSSF for 4335C0 & 4345 */
	if (PHY_ILNA(pi) && ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    (ACMAJORREV_3(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec))) &&
	    DSSF_ENABLE) {
	  wlc_phy_dssf_acphy(pi, TRUE);
	}

	/* setup DCC parameters */
	if ((pi_ac->init || bw_changed || band_changed) &&
	    ACMAJORREV_3(pi->pubpi.phy_rev) &&
	    (CHSPEC_IS5G(pi->radio_chanspec) || (!ACMINORREV_1(pi->pubpi.phy_rev))))
		wlc_20691_setup_coarse_dcc(pi);

	/* Clean up */
	wlc_phy_resetcca_acphy(pi);

	if (TINY_RADIO(pi))
		OSL_DELAY(20);

	wlc_phy_compute_rssi_gainerror_acphy(pi);

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID && (RADIOREV(pi->pubpi.radiorev) == 0x2C) &&
	    (PHY_XTAL_IS40M(pi)) && PHY_ILNA(pi)) {
		/* Spur war for 43569/43570a2 is replaced by wlc_acphy_cal_xtal_spur */
		PHY_INFORM(("%s: No spurwar for 43569/43570a2", __FUNCTION__));
	}
	/* Spur war for 4350 */
	else if (ACMAJORREV_2(pi->pubpi.phy_rev) && (pi->u.pi_acphy->srom.spur_war_enb_2g == 1)) {

		/* Noisevar shaping */
		wlc_phy_spurwar_nvshp_acphy(pi, bw_changed, TRUE, FALSE);

		/* Bphy DSSFB for 4350 >= c0 and 4354 >= a0 */
		if (!ACMINORREV_0(pi->pubpi.phy_rev) && !ACMINORREV_2(pi->pubpi.phy_rev) &&
		    DSSFB_ENABLE) {
			wlc_phy_dssfB_acphy(pi, TRUE);
		}
	}

	/* Spur war for 4335 Ax/Bx IPA */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && PHY_ILNA(pi) &&
	   (ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev))) {
		if ((pi->u.pi_acphy->srom.spur_war_enb_2g == 1) &&
		    CHSPEC_IS2G(pi->radio_chanspec)) {
			wlc_phy_spurwar_nvshp_acphy(pi, bw_changed, TRUE, FALSE);
			MOD_RADIO_REG(pi, RFP, PLL_XTAL5, xtal_bufstrg_BT, 3);
			PHY_TRACE(("BT buffer 3 for Spur WAR; %s \n", __FUNCTION__));
		}
		if ((pi->u.pi_acphy->srom.spur_war_enb_5g == 1) &&
		    CHSPEC_IS5G(pi->radio_chanspec)) {
			wlc_phy_spurwar_nvshp_acphy(pi, bw_changed, TRUE, FALSE);
		}
	}

	/* Spur war for 4339iLNA */
	if (PHY_ILNA(pi) && ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev))) {
		wlc_phy_spurwar_nvshp_acphy(pi, bw_changed, TRUE, FALSE);
	}

	/* Nvshp for 4335 C0 ELNA, 80 MHz since tight filter is being used */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		(!(PHY_ILNA(pi)))) {
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			wlc_phy_spurwar_nvshp_acphy(pi, bw_changed, FALSE, TRUE);
		} else {
		/* Restoring default for 20/40 mhz by reseting it */
			if (bw_changed)
				wlc_phy_reset_noise_var_shaping_acphy(pi);
		}
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev))
		MOD_PHYREG(pi, RfseqMode, CoreActv_override, 0);

	if ((phy_init || bw_changed || band_changed) &&
	    ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	     (ACMAJORREV_3(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)))) {
		wlc_phy_smth(pi, pi_ac->acphy_enable_smth, pi_ac->acphy_smth_dump_mode);
	}

	if (papr_enable) {
		if (PHY_IPA(pi) && (ACMAJORREV_1(pi->pubpi.phy_rev) ||
		    (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)))) {
			wlc_phy_papr_acphy(pi, TRUE, phy_init, band_changed);
		} else if (!PHY_IPA(pi) && ACMAJORREV_2(pi->pubpi.phy_rev)) {
			if (freq == 2472) {
				wlc_phy_papr_acphy(pi, FALSE, FALSE, FALSE);
			} else {
				wlc_phy_papr_acphy(pi, TRUE, phy_init, band_changed);
			}
		}
	}

	if (ISACPHY(pi) && wlc_phy_check_antdiv_enable_acphy((wlc_phy_t *)pi)) {
		if ((phy_init || bw_changed || band_changed) && pi->sh->rx_antdiv) {
			wlc_phy_antdiv_acphy(pi, pi->sh->rx_antdiv);
		}
	}

	if (pi_ac->srom.vlin_en_from_nvram) {
		uint16 txidxval, txgaintemp1[3], txgaintemp1a[3];
		uint16 tempmask;
		uint16 vlinmask;
		if (pi_ac->prev_subband != 15) {
			for (txidxval = pi_ac->vlin_txidx; txidxval < 128; txidxval++) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1,
					txidxval, 48, &txgaintemp1);
				txgaintemp1a[0] = (txgaintemp1[0] & 0x7FFF) -
					(pi_ac->bbmult_comp);
				txgaintemp1a[1] = txgaintemp1[1];
				txgaintemp1a[2] = txgaintemp1[2];
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1,
					txidxval, 48, txgaintemp1a);
				}
			}
		tempmask = READ_PHYREGFLD(pi, FemCtrl, femCtrlMask);
		if (CHSPEC_IS2G (chanspec))
			vlinmask = 1<<(pi_ac->vlinmask2g_from_nvram);
		else
			vlinmask = 1<<(pi_ac->vlinmask5g_from_nvram);
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, (tempmask|vlinmask));
		wlc_phy_vlin_en_acphy(pi);
		}
	pi_ac->prev_subband = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	/* return from Deaf */

	/*
	 * XXX FIXME If hwaci fcbs enabled for 5G and sub band nvram
	 * used need to re-init on each channel
	 */
	if ((phy_init || band_changed) && ACPHY_ENABLE_FCBS_HWACI(pi))
		wlc_phy_hwaci_mitigation_enable_acphy_tiny(pi,
			((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) > 0)
			? 1 : 0, TRUE);

	/* 43602 China Spur WAR Gain Boosting for PAD */
	if (CHSPEC_IS5G(pi->radio_chanspec) && ACMAJORREV_5(pi->pubpi.phy_rev) &&
		(pi_ac->srom.dBpad)) {
		/* Boost Core 2 radio gain */
		ACPHY_REG_LIST_START
			MOD_RADIO_REGC_ENTRY(pi, TXMIX5G_CFG1, 2, gainboost, 0x4)
			MOD_RADIO_REGC_ENTRY(pi, PGA5G_CFG1, 2, gainboost, 0x5)
		ACPHY_REG_LIST_EXECUTE(pi);
		MOD_RADIO_REG(pi, RF2, PAD5G_IDAC, idac_main, 0x3d);
		MOD_RADIO_REG(pi, RF2, PAD5G_TUNE, idac_aux, 0x3d);
	}

	if (ACMAJORREV_3(pi->pubpi.phy_rev) && CHSPEC_IS40(pi->radio_chanspec) && pi->afewar40) {
		int freq;
		const void *chan_info = NULL;
		uint8 ch = CHSPEC_CHANNEL(pi->radio_chanspec);
		(void) wlc_phy_chan2freq_20691(pi, ch, &freq, &chan_info);
		if (freq >= 5500)
			wlc_phy_afe_war_setup_acphy(pi);
	}

	/* Redo DCOC for 4345A0 */
	if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_1(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS2G(pi->radio_chanspec))
			wlc_20691_coarse_dcoc(pi);
		wlc_phy_resetcca_acphy(pi);
	}

	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
#ifndef WLC_DISABLE_ACI
	if (ACHWACIREV(pi)) {
		wlc_phy_save_def_gain_settings_acphy(pi);
		wlc_phy_hwaci_mitigate_acphy(pi, 0);
	}
#endif // endif
}

/* 20691_lpf_tx_set is the top Tx LPF function and should be the usual */
/* function called from acphyprocs or used from the REPL in the lab */
static void
wlc_phy_radio20691_lpf_tx_set(phy_info_t *pi, int8 bq_bw, int8 bq_gain,
	int8 rc_bw_ofdm, int8 rc_bw_cck)
{
	uint8 i;
	uint16 gmult;
	uint16 gmult_rc;
	uint16 g10_tuned, g11_tuned, g12_tuned, g21_tuned, bias;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	gmult = pi_ac->rccal_gmult;
	gmult_rc = pi_ac->rccal_gmult_rc;

	/* search for given bq_gain */
	for (i = 0; i < ARRAYSIZE(g_index1); i++) {
		if (bq_gain == g_index1[i])
			break;
	}

	if (i < ARRAYSIZE(g_index1)) {
		uint16 g_passive_rc_tx_tuned_ofdm, g_passive_rc_tx_tuned_cck;
		g10_tuned = (lpf_g10[bq_bw][i] * gmult) >> 15;
		g11_tuned = (lpf_g11[bq_bw] * gmult) >> 15;
		g12_tuned = (lpf_g12[bq_bw][i] * gmult) >> 15;
		g21_tuned = (lpf_g21[bq_bw][i] * gmult) >> 15;
		g_passive_rc_tx_tuned_ofdm = (g_passive_rc_tx[rc_bw_ofdm] * gmult_rc) >> 15;
		g_passive_rc_tx_tuned_cck = (g_passive_rc_tx[rc_bw_cck] * gmult_rc) >> 15;
		g10_tuned = (g10_tuned > 8191) ? 8191 : g10_tuned;
		g11_tuned = (g11_tuned > 8191) ? 8191 : g11_tuned;
		g12_tuned = (g12_tuned > 8191) ? 8191 : g12_tuned;
		g21_tuned = (g21_tuned > 8191) ? 8191 : g21_tuned;
		g_passive_rc_tx_tuned_ofdm = (g_passive_rc_tx_tuned_ofdm > 511)
			? 511 : g_passive_rc_tx_tuned_ofdm;
		g_passive_rc_tx_tuned_cck = (g_passive_rc_tx_tuned_cck > 511)
			? 511 : g_passive_rc_tx_tuned_cck;
		bias = biases[bq_bw];

		MOD_RADIO_REG_20691(pi, TX_LPF_CFG3, 0, lpf_g10, g10_tuned);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG7, 0, lpf_g11, g11_tuned);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG4, 0, lpf_g12, g12_tuned);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG5, 0, lpf_g21, g21_tuned);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG6, 0, lpf_g_passive_rc_tx,
			g_passive_rc_tx_tuned_ofdm);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG8, 0, lpf_bias_bq, bias);

		/* Note down the values of the passive_rc for OFDM and CCK in Shmem */
		wlapi_bmac_write_shm(pi->sh->physhim, M_LPF_PASSIVE_RC_OFDM,
			g_passive_rc_tx_tuned_ofdm);
		wlapi_bmac_write_shm(pi->sh->physhim, M_LPF_PASSIVE_RC_CCK,
			g_passive_rc_tx_tuned_cck);
	} else {
		PHY_ERROR(("wl%d: %s: Invalid bq_gain %d\n", pi->sh->unit, __FUNCTION__, bq_gain));
	}
}

void
wlc_phy_set_spurmode(phy_info_t *pi, uint16 freq)
{
	wlc_phy_get_spurmode(pi, freq);
	if (pi->u.pi_acphy->curr_spurmode != pi->acphy_spuravoid_mode) {
		wlc_phy_setup_spurmode(pi);
		pi->u.pi_acphy->curr_spurmode = pi->acphy_spuravoid_mode;
	}
}

void
wlc_phy_get_spurmode(phy_info_t *pi, uint16 freq)
{
	if (ISSIM_ENAB(pi->sh->sih))
		return;

	if (pi->block_for_slowcal) {
		pi->blocked_freq_for_slowcal = freq;
		return;
	}

	if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID) {
		if (pi->sh->chippkg == BCM4335_WLBGA_PKG_ID)
			pi->acphy_spuravoid_mode = 8;
		else {
			/* for WLCSP packages */
			if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
				/* for 4335 Cx Chips */
				if (pi->sh->chippkg == BCM4335_FCBGA_PKG_ID &&
					CHSPEC_IS2G(pi->radio_chanspec) &&
					CHSPEC_CHANNEL(pi->radio_chanspec) <= 7)
					pi->acphy_spuravoid_mode = 2;
				else
					pi->acphy_spuravoid_mode = 8;
			} else {
				/* for 4335 Ax/Bx Chips */
				pi->acphy_spuravoid_mode = 2;
			}
		}
	} else {
		pi->acphy_spuravoid_mode = 0;
	}
}

void
wlc_phy_setup_spurmode(phy_info_t *pi)
{
	si_pmu_spuravoid(pi->sh->sih, pi->sh->osh, pi->acphy_spuravoid_mode);
	wlapi_switch_macfreq(pi->sh->physhim, pi->acphy_spuravoid_mode);
}
/*
Initialize chip regs(RWP) & tables with init vals that do not get reset with phy_reset
*/
static void
wlc_phy_set_regtbl_on_pwron_acphy(phy_info_t *pi)
{
	uint16 val;
	bool flag2rangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi5g)) &&
	        PHY_IPA(pi);

	/* force afediv(core 0, 1, 2) always high */
	if (!(ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)))
		WRITE_PHYREG(pi, AfeClkDivOverrideCtrl, 0x77);

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		WRITE_PHYREG(pi, AfeClkDivOverrideCtrlN0, 0x3);
	}
	/* Remove RFCTRL signal overrides for all cores */
	ACPHY_REG_LIST_START
		ACPHYREG_BCAST_ENTRY(pi, RfctrlIntc0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideAfeCfg0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideGains0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideLpfCT0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideLpfSwtch0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideAfeCfg0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideLowPwrCfg0, 0)
		ACPHYREG_BCAST_ENTRY(pi, RfctrlOverrideAuxTssi0, 0)
		ACPHYREG_BCAST_ENTRY(pi, AfectrlOverride0, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (ACMAJORREV_5(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev))) {
		ACPHYREG_BCAST(pi, AfeClkDivOverrideCtrlN0, 0);
		WRITE_PHYREG(pi, AfeClkDivOverrideCtrl, 0);
	}

	/* logen_pwrup = 1, logen_reset = 0 */
	ACPHYREG_BCAST(pi, RfctrlCoreTxPus0, 0x80);
	ACPHYREG_BCAST(pi, RfctrlOverrideTxPus0, 0x180);

	/* Force LOGENs on both cores in the 5G to be powered up for 4350C0 */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RfctrlOverrideTxPus0, logen5g_lob_pwrup, 1)
			MOD_PHYREG_ENTRY(pi, RfctrlCoreTxPus0, logen5g_lob_pwrup, 1)
			MOD_PHYREG_ENTRY(pi, RfctrlOverrideTxPus1, logen5g_lob_pwrup, 1)
			MOD_PHYREG_ENTRY(pi, RfctrlCoreTxPus1, logen5g_lob_pwrup, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* Switch off rssi2 & rssi3 as they are not used in normal operation */
	ACPHYREG_BCAST(pi, RfctrlCoreRxPus0, 0);
	ACPHYREG_BCAST(pi, RfctrlOverrideRxPus0, 0x5000);

	/* Disable the SD-ADC's overdrive detect feature */
	val = READ_PHYREG(pi, RfctrlCoreAfeCfg20) |
	      ACPHY_RfctrlCoreAfeCfg20_afe_iqadc_reset_ov_det_MASK(pi->pubpi.phy_rev);
	/* val |= ACPHY_RfctrlCoreAfeCfg20_afe_iqadc_clamp_en_MASK; */
	ACPHYREG_BCAST(pi, RfctrlCoreAfeCfg20, val);
	val = READ_PHYREG(pi, RfctrlOverrideAfeCfg0) |
	      ACPHY_RfctrlOverrideAfeCfg0_afe_iqadc_reset_ov_det_MASK(pi->pubpi.phy_rev);
	/* val |= ACPHY_RfctrlOverrideAfeCfg0_afe_iqadc_clamp_en_MASK(pi->pubpi.phy_rev); */
	ACPHYREG_BCAST(pi, RfctrlOverrideAfeCfg0, val);

	/* initialize all the tables defined in auto-generated wlc_phytbl_ac.c,
	 * see acphyprocs.tcl, proc acphy_init_tbls
	 *  skip static one after first up
	 */
	PHY_TRACE(("wl%d: %s, dnld tables = %d\n", pi->sh->unit,
	           __FUNCTION__, pi->phy_init_por));

	/* these tables are not affected by phy reset, only power down */
	if (!TINY_RADIO(pi))
		wlc_phy_static_table_download_acphy(pi);

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		/* wihr 0x15a 0x8000 */

		/* acphy_rfctrl_override bg_pulse 1 */
		/* Override is not required now ..bg pulsing is enabled along with tssi sleep */
		/* val  = READ_PHYREG(pi, RfctrlCoreTxPus0); */
		/* val |= (1 << 14); */
		/* WRITE_PHYREG(pi, ACPHY_RfctrlCoreTxPus0, val); */
		/* val = READ_PHYREG(pi, RfctrlOverrideTxPus0); */
		/* val |= (1 << 9); */
		/* WRITE_PHYREG(pi, ACPHY_RfctrlOverrideTxPus0, val); */

	}

	/* Initialize idle-tssi to be -420 before doing idle-tssi cal */
	ACPHYREG_BCAST(pi, TxPwrCtrlIdleTssi_path0, 0x25C);

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) || (ACMAJORREV_2(pi->pubpi.phy_rev))) &&
	    pi->u.pi_acphy->srom.tssi_div_war) {
		ACPHYREG_BCAST(pi, TxPwrCtrlIdleTssi_second_path0, 0x25C);
	}

	if (flag2rangeon) {
		ACPHYREG_BCAST(pi, TxPwrCtrlIdleTssi_second_path0, 0x25C);
	}

	/* Enable the Ucode TSSI_DIV WAR */
	if ((ACMAJORREV_1(pi->pubpi.phy_rev) || (ACMAJORREV_2(pi->pubpi.phy_rev))) &&
	    pi->u.pi_acphy->srom.tssi_div_war) {
		wlapi_bmac_mhf(pi->sh->physhim, MHF2, MHF2_PPR_HWPWRCTL, MHF2_PPR_HWPWRCTL,
		               WLC_BAND_ALL);
	}

	/* #FIXME: this is to force direct_nap radio ctrl to 0 for now. Proper fix is through
	 * rfseq tbls.
	 */
	if (TINY_RADIO(pi)) {
		MOD_PHYREG(pi, RfctrlCoreRxPus0, fast_nap_bias_pu, 0);
		MOD_PHYREG(pi, RfctrlOverrideRxPus0, fast_nap_bias_pu, 1);
	}

	/* Temp 4345 register poweron default updates - */
	/* These need to be farmed out to correct locations */
	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
	    ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, RxSdFeConfig5, rx_farow_scale_value, 7)
		MOD_PHYREG_ENTRY(pi, FSTRHiPwrTh, finestr_hiPwrSm_th, 77)
		MOD_PHYREG_ENTRY(pi, FSTRHiPwrTh, finestr_hiPwr_th, 63)
		MOD_PHYREG_ENTRY(pi, crsThreshold2l, peakThresh, 77)
		MOD_PHYREG_ENTRY(pi, crsminpoweruSub10, crsminpower0, 54)
		MOD_PHYREG_ENTRY(pi, crsminpoweruSub10, crsminpower0, 54)
		MOD_PHYREG_ENTRY(pi, crsminpoweru0, crsminpower0, 54)
		MOD_PHYREG_ENTRY(pi, bphyaciThresh0, bphyaciThresh0, 0)
		MOD_PHYREG_ENTRY(pi, bphyaciPwrThresh2, bphyaciPwrThresh2, 0)
		MOD_PHYREG_ENTRY(pi, RxSdFeSampCap, capture_both, 0)
		/* MOD_PHYREG_ENTRY(pi, TxMacDelay, macdelay, 680); */
		MOD_PHYREG_ENTRY(pi, AfeseqRx2TxPwrUpDownDly20M, delayPwrUpDownRx2Tx20M, 3)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideTxPus0, bg_pulse, 1)
		MOD_PHYREG_ENTRY(pi, PapdEnable0, gain_dac_rf_override0, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreTxPus0, bg_pulse, 1)
		MOD_PHYREG_ENTRY(pi, PapdEnable0, gain_dac_rf_reg0, 0)
		MOD_PHYREG_ENTRY(pi, RfseqMode, CoreActv_override, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLowPwrCfg0, rxrf_lna2_gm_size, 0)
		MOD_PHYREG_ENTRY(pi, Rfpll_resetCtrl, rfpll_reset_dur, 64)
		MOD_PHYREG_ENTRY(pi, CoreConfig, NumRxAnt, 1)
		MOD_PHYREG_ENTRY(pi, Pllldo_resetCtrl, pllldo_reset_dur, 8000)
		MOD_PHYREG_ENTRY(pi, bphyaciPwrThresh0, bphyaciPwrThresh0, 0)
		MOD_PHYREG_ENTRY(pi, bphyaciThresh1, bphyaciThresh1, 0)
		MOD_PHYREG_ENTRY(pi, HTSigTones, support_gf, 1)
		MOD_PHYREG_ENTRY(pi, ViterbiControl0, CacheHitEn, 1)
		MOD_PHYREG_ENTRY(pi, sampleDepthCount, DepthCount, 19)
		MOD_PHYREG_ENTRY(pi, bphyaciPwrThresh1, bphyaciPwrThresh1, 0)
		MOD_PHYREG_ENTRY(pi, Core0cliploGainCodeB, clip1loTrTxIndex, 0)
		MOD_PHYREG_ENTRY(pi, clip2carrierDetLen, clip2carrierDetLen, 64)
		MOD_PHYREG_ENTRY(pi, Core0clip2GainCodeA, clip2LnaIndex, 1)
		MOD_PHYREG_ENTRY(pi, Core0clipmdGainCodeB, clip1mdBiQ0Index, 0)
		MOD_PHYREG_ENTRY(pi, Core0clip2GainCodeB, clip2BiQ1Index, 2)
		MOD_PHYREG_ENTRY(pi, Core0cliploGainCodeA, clip1loLnaIndex, 1)
		MOD_PHYREG_ENTRY(pi, Core0cliploGainCodeB, clip1loBiQ0Index, 0)
		MOD_PHYREG_ENTRY(pi, Core0clipHiGainCodeB, clip1hiBiQ0Index, 0)
		MOD_PHYREG_ENTRY(pi, Core0clipmdGainCodeA, clip1mdmixergainIndex, 3)
		MOD_PHYREG_ENTRY(pi, Core0cliploGainCodeB, clip1loTrRxIndex, 1)
		WRITE_PHYREG_ENTRY(pi, Core0InitGainCodeB, 0x2204)
		MOD_PHYREG_ENTRY(pi, AfectrlCore10, adc_pd, 1)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		uint8 zeroval[4] = { 0 };
		uint16 x;
		uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);

		ACPHY_DISABLE_STALL(pi);

		for (x = 0; x < 256; x++) {
			/* Zero out the NV Noise Shaping Table for 4345A0 */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVNOISESHAPINGTBL,
			                          1, x, 32, zeroval);

			/* Zero out the NV Rx EVM Table for 4345A0 */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVRXEVMSHAPINGTBL,
			                          1, x, 8, zeroval);
		}
		ACPHY_ENABLE_STALL(pi, stall_val);

		/* Disable scram dyn en for 4345A0 */
		wlc_acphy_set_scramb_dyn_bw_en((wlc_phy_t *)pi, 0);
	}

	/* 4335C0: This force clk is needed for proper read/write of RfseqBundle table.
	This change is inaccordance with JIRA CRDOT11ACPHY-436
	Dated Mar-08 : Removing force clks for low current
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, fineclockgatecontrol, forceRfSeqgatedClksOn, 1);
	}
	*/

	if (TINY_RADIO(pi) && (PHY_IPA(pi) || pi->epacal2g || pi->epacal5g)) {
		/* Zero out paplutselect table used in txpwrctrl */
		uint8 initvalue = 0;
		uint16 j;
		for (j = 0; j < 128; j++) {
			wlc_phy_table_write_acphy(pi,
				ACPHY_TBL_ID_PAPDLUTSELECT0, 1, j, 8, &initvalue);
		}
	}
}

/* Load pdet related Rfseq on reset */
static void
wlc_phy_set_pdet_on_reset_acphy(phy_info_t *pi)
{
	uint8 core, pdet_range_id, subband_idx;
	uint16 offset, tmp_val, val_av, val_vmid;
	uint8 chan_freq_range;
	uint8 av[3] = {0, 0, 0};
	uint8 vmid[3] = {0, 0, 0};
	uint8 stall_val;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool flag2rangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi5g)) &&
		PHY_IPA(pi);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		pdet_range_id = pi->u.pi_acphy->srom_2g_pdrange_id;
	} else {
		pdet_range_id = pi->u.pi_acphy->srom_5g_pdrange_id;
	}

	chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	switch (chan_freq_range) {
	case WL_CHAN_FREQ_RANGE_2G:
		subband_idx = 0;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND0:
		subband_idx = 1;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND1:
		subband_idx = 2;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND2:
		subband_idx = 3;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND3:
		subband_idx = 4;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Invalid chan_freq_range %d\n",
		           pi->sh->unit, __FUNCTION__, chan_freq_range));
		subband_idx = 0;
		break;
	}

	FOREACH_CORE(pi, core) {
		if (pi_ac->srom.avvmid_from_nvram) {
			av[core] = avvmid_set_from_nvram[core][subband_idx][0];
			vmid[core] = avvmid_set_from_nvram[core][subband_idx][1];
		} else {
			if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
				av[core] = avvmid_set[pdet_range_id][subband_idx][core];
				vmid[core] =
				        avvmid_set[pdet_range_id][subband_idx][core+3];
			} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				if (core == 0) {
					av[core] = avvmid_set1[pdet_range_id][subband_idx][core];
				vmid[core] = avvmid_set1[pdet_range_id][subband_idx][core+1];
				}
			} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
				av[core] = avvmid_set2[pdet_range_id][subband_idx][core];
				vmid[core] = avvmid_set2[pdet_range_id][subband_idx][core+2];
			} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
				if (core == 0) {
					av[core] = avvmid_set3[pdet_range_id][subband_idx][core];
					vmid[core] =
					        avvmid_set3[pdet_range_id][subband_idx][core+1];
				}
			} else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* Pick Av/Vmid from 4360 pdet range bins for 43602A0 */
				av[core] = avvmid_set[pdet_range_id][subband_idx][core];
				vmid[core] = avvmid_set[pdet_range_id][subband_idx][core+3];
			}
		}
	}
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		if ((ACMAJORREV_1(pi->pubpi.phy_rev) && (core == 0)) ||
		    !(ACMAJORREV_1(pi->pubpi.phy_rev))) {
			offset = 0x3c0 + 0xd + core*0x10;
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
			                         1, offset, 16, &tmp_val);
			val_av = (tmp_val & 0x1ff8) | (av[core]&0x7);
			val_vmid = (val_av & 0x7) | ((vmid[core]&0x3ff)<<3);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
			                          1, offset, 16, &val_vmid);

			if (((ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
				TINY_RADIO(pi)) && pi->u.pi_acphy->srom.tssi_div_war) ||
				flag2rangeon) {
				offset = 0x3c0 + 0xe + core*0x10;
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
				                          1, offset, 16, &val_vmid);
			}
		}
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

/* Initialize chip regs(RW) that get reset with phy_reset */
static void
wlc_phy_set_reg_on_reset_acphy(phy_info_t *pi)
{
	uint8 core;

	/* IQ Swap (revert swap happening in the radio) */
	if (RADIOID(pi->pubpi.radioid) != BCM20691_ID) {
		phy_reg_or(pi, ACPHY_RxFeCtrl1(pi->pubpi.phy_rev), 7 <<
			ACPHY_RxFeCtrl1_swap_iq0_SHIFT(pi->pubpi.phy_rev));
	}

	/* kimmer - add change from 0x667 to x668 very slight improvement */
	if (CHSPEC_IS2G(pi->radio_chanspec))
	     WRITE_PHYREG(pi, DsssStep, 0x668);

	/* Avoid underflow trigger for loopback Farrow */
	MOD_PHYREG(pi, RxFeCtrl1, en_txrx_sdfeFifoReset, 1);

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) {
		MOD_PHYREG(pi, RxFeCtrl1, rxfe_bilge_cnt, 0);
	} else {
		MOD_PHYREG(pi, RxFeCtrl1, rxfe_bilge_cnt, 4);
	}

	MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 1);
	MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 0);

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		/* Write 0x0 to RfseqMode to turn off both CoreActv_override */
		WRITE_PHYREG(pi, RfseqMode, 0);
	}

	/* Enable 6-bit Carrier Sense Match Filter Mode for 4335C0 and 43602A0 */
	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev) || TINY_RADIO(pi)) {
		MOD_PHYREG(pi, CRSMiscellaneousParam, crsMfMode, 1);
	}

	/* Turn on TxCRS extension.
	 * (Need to eventually make the 1.0 be native TxCRSOff (1.0us))
	 */
	WRITE_PHYREG(pi, dot11acphycrsTxExtension, 200);

	/* Currently PA turns on 1us before first DAC sample. Decrease that gap to 0.5us */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
	        WRITE_PHYREG(pi, TxRealFrameDelay, 146);
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev) &&
		(pi->u.pi_acphy->srom.reduce_pa_turnontime == 1)) {
	        WRITE_PHYREG(pi, TxRealFrameDelay, 106);
	}

	/* This number combined with MAC RIFS results in 2.0us RIFS air time */
	WRITE_PHYREG(pi, TxRifsFrameDelay, 48);

	si_core_cflags(pi->sh->sih, SICF_MPCLKE, SICF_MPCLKE);

	/* allow TSSI loopback path to turn off */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi))) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (((CHSPEC_IS20(pi->radio_chanspec)) &&
			  (pi->u.pi_acphy->srom_tssisleep_en & 0x1)) ||
			  ((CHSPEC_IS40(pi->radio_chanspec)) &&
			  (pi->u.pi_acphy->srom_tssisleep_en & 0x2))) {
				MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 1);
			} else {
				MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);
			}
		} else {
			if (((CHSPEC_IS20(pi->radio_chanspec)) &&
			  (pi->u.pi_acphy->srom_tssisleep_en & 0x4)) ||
			  ((CHSPEC_IS40(pi->radio_chanspec)) &&
			  (pi->u.pi_acphy->srom_tssisleep_en & 0x8)) ||
			  ((CHSPEC_IS80(pi->radio_chanspec)) &&
			  (pi->u.pi_acphy->srom_tssisleep_en & 0x10))) {
				MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 1);
			} else {
				MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);
			}
		}
	} else {
		MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);
	}

	/* In event of high power spurs/interference that causes crs-glitches,
	   stay in WAIT_ENERGY_DROP for 1 clk20 instead of default 1 ms.
	   This way, we get back to CARRIER_SEARCH quickly and will less likely to miss
	   actual packets. PS: this is actually one settings for ACI
	*/
	/* WRITE_PHYREG(pi, ACPHY_energydroptimeoutLen, 0x2); */

	/* Upon Reception of a High Tone/Tx Spur, the default 40MHz MF settings causes ton of
	   glitches. Set the MF settings similar to 20MHz uniformly. Provides Robustness for
	   tones (on-chip, on-platform, accidential loft coming from other devices)
	*/
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, crsControll, mfLessAve, 0)
		MOD_PHYREG_ENTRY(pi, crsControlu, mfLessAve, 0)
		MOD_PHYREG_ENTRY(pi, crsControllSub1, mfLessAve, 0)
		MOD_PHYREG_ENTRY(pi, crsControluSub1, mfLessAve, 0)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (!(ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, crsThreshold2l, peakThresh, 85)
			MOD_PHYREG_ENTRY(pi, crsThreshold2u, peakThresh, 85)
			MOD_PHYREG_ENTRY(pi, crsThreshold2lSub1, peakThresh, 85)
			MOD_PHYREG_ENTRY(pi, crsThreshold2uSub1, peakThresh, 85)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		if (ACMAJORREV_5(pi->pubpi.phy_rev) && CHSPEC_IS20(pi->radio_chanspec)) {
			WRITE_PHYREG(pi, crsThreshold2u, 0x204d);
			WRITE_PHYREG(pi, crsThreshold2l, 0x204d);
		} else {
			WRITE_PHYREG(pi, crsThreshold2u, 0x204d);
			WRITE_PHYREG(pi, crsThreshold2l, 0x204d);
		}
		WRITE_PHYREG(pi, crsThreshold2lSub1, 0x204d);
		WRITE_PHYREG(pi, crsThreshold2uSub1, 0x204d);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, crsThreshold2l, peakThresh, 77)
			MOD_PHYREG_ENTRY(pi, crsThreshold2u, peakThresh, 77)
			MOD_PHYREG_ENTRY(pi, crsThreshold2lSub1, peakThresh, 77)
			MOD_PHYREG_ENTRY(pi, crsThreshold2uSub1, peakThresh, 77)

			MOD_PHYREG_ENTRY(pi, crsacidetectThreshl, acidetectThresh, 0x80)
			MOD_PHYREG_ENTRY(pi, crsacidetectThreshlSub1, acidetectThresh, 0x80)
			MOD_PHYREG_ENTRY(pi, crsacidetectThreshu, acidetectThresh, 0x80)
			MOD_PHYREG_ENTRY(pi, crsacidetectThreshuSub1, acidetectThresh, 0x80)
			WRITE_PHYREG_ENTRY(pi, initcarrierDetLen,  0x40)
			WRITE_PHYREG_ENTRY(pi, clip1carrierDetLen, 0x5c)
		ACPHY_REG_LIST_EXECUTE(pi);

		if ((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg_2g) ||
			(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg_5g)) {
			WRITE_PHYREG(pi, clip2carrierDetLen, 0x3a);
			WRITE_PHYREG(pi, defer_setClip1_CtrLen, 20);
		} else {
		        WRITE_PHYREG(pi, clip2carrierDetLen, 0x48);
			WRITE_PHYREG(pi, defer_setClip1_CtrLen, 24);
		}
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, clip_detect_normpwr_var_mux,
				use_norm_var_for_clip_detect, 0)
			MOD_PHYREG_ENTRY(pi, norm_var_hyst_th_pt8us, cck_gain_pt8us_en, 1)
			MOD_PHYREG_ENTRY(pi, CRSMiscellaneousParam, mf_crs_initgain_only, 1)
			/* disable bphyacidetEn as it is causing random rxper humps */
			MOD_PHYREG_ENTRY(pi, RxControl, bphyacidetEn, 0)

			WRITE_PHYREG_ENTRY(pi, RfseqCoreActv2059, 0x7717)
		ACPHY_REG_LIST_EXECUTE(pi);

		if (!ACMAJORREV_3(pi->pubpi.phy_rev) &&
			(ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev))) {
			ACPHY_REG_LIST_START
			    WRITE_PHYREG_ENTRY(pi, HTSigTones, 0x9ee1)
			    MOD_PHYREG_ENTRY(pi, CRSMiscellaneousParam, bphy_pre_det_en, 0)
			    MOD_PHYREG_ENTRY(pi, bOverAGParams, bOverAGlog2RhoSqrth, 0)
			    MOD_PHYREG_ENTRY(pi, CRSMiscellaneousParam, b_over_ag_falsedet_en, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
		} else {
			ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, HTSigTones, 0x9ee9)
				MOD_PHYREG_ENTRY(pi, CRSMiscellaneousParam, bphy_pre_det_en,
					(ACMAJORREV_3(pi->pubpi.phy_rev)) ? 0 : 0)
				MOD_PHYREG_ENTRY(pi, dot11acConfig, bphyPreDetTmOutEn, 0)
			ACPHY_REG_LIST_EXECUTE(pi);
			/* digigain is not proper for low power bphy signals */
			/* causes kink near sensitivity region of 11mbps */
			/* fix is to increase cckshiftbitsRefVar by 1.5dB */
			/* WRITE_PHYREG_ENTRY(pi, cckshiftbitsRefVar, 46422); */
		}
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, FSTRCtrl, fineStrSgiVldCntVal,  0xb)
			MOD_PHYREG_ENTRY(pi, FSTRCtrl, fineStrVldCntVal, 0xa)

			MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs9, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs8, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs7, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs6, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs5, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs4, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs3, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs2, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs1, 0x3)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs0, 0x2)
		ACPHY_REG_LIST_EXECUTE(pi);

	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		if ((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg2_2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg2_5g)) {
			/* reduce c1 settle counter as large value is causing hump in c9s1 rate */
			WRITE_PHYREG(pi, clip1gainSettleLen, 0x28);

			/* increase c2 thresh by 1db to take care of sgi humps */
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				WRITE_PHYREGC(pi, Clip2Threshold, core, 0xa186);
			}
		}
	}
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		wlc_phy_set_lowpwr_phy_reg_rev3(pi);

		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, CRSMiscellaneousParam, bphy_pre_det_en, 0);
		} else {
			ACPHY_REG_LIST_START
				/* Enable BPHY pre-detect */
				MOD_PHYREG_ENTRY(pi, RxControl, preDetOnlyinCS, 1)
				MOD_PHYREG_ENTRY(pi, dot11acConfig, bphyPreDetTmOutEn, 1)
				/* Disable BPHY pre-detect JIRA:SWWLAN-45198 jammer/ACI performance
				 * takes a hit with predetector enabled
				 */
				MOD_PHYREG_ENTRY(pi, CRSMiscellaneousParam, bphy_pre_det_en, 0)
				MOD_PHYREG_ENTRY(pi, bphyPreDetectThreshold0, ac_det_1us_min_pwr_0,
					350)
				WRITE_PHYREG_ENTRY(pi, cckshiftbitsRefVar, 46422)
			ACPHY_REG_LIST_EXECUTE(pi);
		}

		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs6, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs5, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs4, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs3, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs2, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs1, 0x3)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs0, 0x2)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/*  Write 0x0 to RfseqMode to turn off both CoreActv_override
	 * (to give control to Tx control word) and Trigger_override (to give
	 * control to rfseq)
	 *
	 * Now we are done with all rfseq INIT.
	 * PR109510 : don't need to touch rfpll, pllldo in reset2rx (bit 2, powerOnReset2RxSeq)
	*/
	WRITE_PHYREG(pi, RfseqMode, 0);

	/* Disable Viterbi cache-hit low power featre for 4360
	 * since it is hard to meet 320 MHz timing
	 */
	MOD_PHYREG(pi, ViterbiControl0, CacheHitEn, ACMAJORREV_0(pi->pubpi.phy_rev) ? 0 : 1);

	/* Reset pktproc state and force RESET2RX sequence */
	wlc_phy_resetcca_acphy(pi);

	/* Try to fix the Tx2RX turnaround issue */
	if (0) {
		MOD_PHYREG(pi, RxFeStatus, sdfeFifoResetCntVal, 0xF);
		MOD_PHYREG(pi, RxFeCtrl1, resetsdFeInNonActvSt, 0x1);
	}

	/* Make TSSI to select Q-rail */
	if (ACREV_IS(pi->pubpi.phy_rev, 4) && CHSPEC_IS2G(pi->radio_chanspec))
		MOD_PHYREG(pi, TSSIMode, tssiADCSel, 0);
	else
		MOD_PHYREG(pi, TSSIMode, tssiADCSel, 1);

	/* Increase this by 10 ticks helps in getting rid of humps at high SNR, single core runs */
	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		WRITE_PHYREG(pi, defer_setClip2_CtrLen, 16);
	}

	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, HTSigTones, support_gf, 0)

		/* JIRA-CRDOT11ACPHY-273: SIG errror check For number of VHT symbols calculated */
		MOD_PHYREG_ENTRY(pi, partialAIDCountDown, check_vht_siga_length, 1)

		MOD_PHYREG_ENTRY(pi, DmdCtrlConfig, check_vhtsiga_rsvd_bit, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	FOREACH_CORE(pi, core) {
		MOD_PHYREGCE(pi, forceFront, core, freqCor, 1);
		MOD_PHYREGCE(pi, forceFront, core, freqEst, 1);
	}

	/* PR108248 : 1.6us pktgainSettleLen causes late/missed STR and pkt end in glitches (esp
	   for 20in80, 40in 80, single core), 1 us should be enough time for pktgain to settle
	 */
	WRITE_PHYREG(pi, pktgainSettleLen, 48);

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
		WRITE_PHYREG(pi, CoreConfig, 0x29);
		/* XXX: The following write has been removed during 20691 code intro
		 * WRITE_PHYREG(pi, ACPHY_RfseqMode, 0x111);
		 */
		WRITE_PHYREG(pi, RfseqCoreActv2059, 0x1111);

		if (ACMAJORREV_1(pi->pubpi.phy_rev))
			wlc_phy_set_lowpwr_phy_reg(pi);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (pi->u.pi_acphy->srom.reduce_pa_turnontime == 1)) {
		/* 4335:tkip macdelay & mac holdoff for reduced PA trun on time */
		WRITE_PHYREG(pi, TxMacIfHoldOff, TXMAC_IFHOLDOFF_DEFAULT_MAJREV1);
		WRITE_PHYREG(pi, TxMacDelay, TXMAC_MACDELAY_DEFAULT_MAJREV1);
	} else if (!ACMAJORREV_0(pi->pubpi.phy_rev)) {
		/* 4335:tkip macdelay & mac holdoff */
		WRITE_PHYREG(pi, TxMacIfHoldOff, TXMAC_IFHOLDOFF_DEFAULT);
		WRITE_PHYREG(pi, TxMacDelay, TXMAC_MACDELAY_DEFAULT);
	}

	/* tiny radio specific processing */
	if (TINY_RADIO(pi)) {
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
			wlc_phy_set_reg_on_reset_acphy_20691(pi);
		else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
			wlc_phy_set_reg_on_reset_acphy_20693(pi);
	}

	wlc_phy_mlua_adjust_acphy(pi, pi->bt_active);
#ifndef WLC_DISABLE_ACI
	/* Setup HW_ACI block */
	if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
		if (((pi->sh->interference_mode_2G & ACPHY_ACI_HWACI_PKTGAINLMT) != 0) ||
		    ((pi->sh->interference_mode_5G & ACPHY_ACI_HWACI_PKTGAINLMT) != 0) ||
		    ((pi->sh->interference_mode_2G & ACPHY_HWACI_MITIGATION) != 0) ||
		    ((pi->sh->interference_mode_5G & ACPHY_HWACI_MITIGATION) != 0))
			wlc_phy_hwaci_setup_acphy(pi, FALSE, TRUE);
		else
			wlc_phy_hwaci_setup_acphy(pi, FALSE, FALSE);
	}
#endif /* !WLC_DISABLE_ACI */

	/* 4335C0: Current optimization */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		ACPHY_REG_LIST_START
			WRITE_PHYREG_ENTRY(pi, FFTSoftReset, 0x2)
			WRITE_PHYREG_ENTRY(pi, fineclockgatecontrol, 0x0)
			WRITE_PHYREG_ENTRY(pi, RxFeTesMmuxCtrl, 0x60)
			MOD_PHYREG_ENTRY(pi, forceFront0, freqEst, 0)
			MOD_PHYREG_ENTRY(pi, forceFront0, freqCor, 0)
			MOD_PHYREG_ENTRY(pi, fineRxclockgatecontrol, forcedigigaingatedClksOn, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* 43602: C-Model Parameters setting */
	if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		ACPHY_REG_LIST_START
			/* Turn ON 11n 256 QAM in 2.4G */
			WRITE_PHYREG_ENTRY(pi, miscSigCtrl, 0x203)
			WRITE_PHYREG_ENTRY(pi, HTAGCWaitCounters, 0x1028)

			/* WRITE_PHYREG_ENTRY(pi, bfeConfigReg1, 0x8) */

			WRITE_PHYREG_ENTRY(pi, crsThreshold2lSub1, 0x204d)
			WRITE_PHYREG_ENTRY(pi, crsThreshold2uSub1, 0x204d)

			/* Fine timing optimization for linear filter */
			WRITE_PHYREG_ENTRY(pi, FSTRCtrl, 0x7aa)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Low_power settings */
		WRITE_PHYREG(pi, RxFeTesMmuxCtrl, 0x60);
		/* Commenting out this low-power feature. Seen performance hit because of it.  */
		/* FOREACH_CORE(pi, core) { */
		/* 	MOD_PHYREGCE(pi, forceFront, core, freqCor, 0); */
		/* 	MOD_PHYREGCE(pi, forceFront, core, freqEst, 0); */
		/* } */
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		/* Helps for OFDM high-end hump due to W1 clamping */
		/* WRITE_PHYREG(pi, pktgainSettleLen, 0x33); */
		/* WRITE_PHYREG(pi, defer_setClip2_CtrLen, 13); */
		WRITE_PHYREG(pi, dssscckgainSettleLen, 0x65);
	}

	/* enable fix for bphy loft calibration issue CRDOT11ACPHY-378 */
	if (ACREV_GE(pi->pubpi.phy_rev, 6))
		MOD_PHYREG(pi, bphyTest, bphyTxfiltTrunc, 0);

	ACPHY_REG_LIST_START
		/* for: http://jira.broadcom.com/browse/SWWFA-10  */
		WRITE_PHYREG_ENTRY(pi, drop20sCtrl1, 0xc07f)

		/* phyrcs20S drop threshold -110 dBm */
		WRITE_PHYREG_ENTRY(pi, drop20sCtrl2, 0x64)

		/* phyrcs40S drop threshold -110 dBm */
		WRITE_PHYREG_ENTRY(pi, drop20sCtrl3, 0x64)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* 4360 & 43602 */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Increase timing search timeout to reduce number of glitches under 64k,
		 * if glitches > 64k, they are wrapped around to a low number.  12 us --> 13 us
		 */
		WRITE_PHYREG(pi, timingsearchtimeoutLen, 520);   /* 13 / 0.025 */
	}
}

/** tiny radio specific */
static void
wlc_phy_set_reg_on_reset_acphy_20691(phy_info_t *pi)
{
	uint16 temp_reg;
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	if (RADIO20691_MAJORREV(pi->pubpi.radiorev) > 1 ||
	    RADIO20691_MINORREV(pi->pubpi.radiorev) != 0) {
		MOD_RADIO_REG_20691(pi, SPARE_CFG1, 0, spare_0, 0xfc00);
		MOD_RADIO_REG_20691(pi, SPARE_CFG2, 0, spare_1, 0x003f);
	}

	/* CRDOT11ACPHY-566: rx fix for dac rate mode 2 & 3 for >= rev1
	 * i.e. clear the top bit of the work_around_ctrl ACPHY register
	 */
	_PHY_REG_MOD(pi, ACPHY_work_around_ctrl(pi->pubpi.phy_rev), 0x8000, 0);

	MOD_PHYREG(pi, RxStatPwrOffset0, use_gainVar_for_rssi0, 1);

	if (ACMINORREV_1(pi->pubpi.phy_rev)) {
		/* CRDOTACPHY-542: disable fixed DC */
		MOD_PHYREG(pi, ForcePktAbort, dcblk_hpf_bw_en, 0);
		MOD_PHYREG(pi, HTAGCWaitCounters, HTAgcPktgainWait, 12);
	} else {
		MOD_PHYREG(pi, ForcePktAbort, dcblk_hpf_bw_en, 1);
		MOD_PHYREG(pi, HTAGCWaitCounters, HTAgcPktgainWait, 34);
	}

	ACPHY_REG_LIST_START
		/* maximum drive strength */
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG8, 0, tia_offset_comp_drive_strength, 1)

		/* DCC FSM Defaults */
		MOD_PHYREG_ENTRY(pi, BBConfig, dcc_wakeup_restart_en, 0)
		MOD_PHYREG_ENTRY(pi, BBConfig, dcc_wakeup_restart_delay, 10)
		MOD_PHYREG_ENTRY(pi, dcc_ctrl_restart_length_grp, dcc_ctrl_restart_length, 0xffff)

		/* Set DCC FSM to run and then stop - i, e,  do not idle, */
		MOD_PHYREG_ENTRY(pi, rx_tia_dc_loop_0, en_lock, 1)

		/* Correct sign of loop gain */
		MOD_PHYREG_ENTRY(pi, rx_tia_dc_loop_0, dac_sign, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	if (ACMINORREV_0(pi->pubpi.phy_rev)) {
		ACPHY_REG_LIST_START
			/* WAR override dcc idacs and use 20691_coarse_dcc to do off-line nulling */
			MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG8, 0, tia_offset_dac_sign_i, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG8, 0, tia_offset_dac_sign_q, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG11, 0, tia_offset_dac_d_i, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG11, 0, tia_offset_dac_d_q, 0)
			/* 4345SOCTC */
			MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_offset_dac, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		/* disable DVG2 to avoid bphy resampler saturation */
		MOD_PHYREG(pi, RxSdFeConfig5, tiny_bphy20_ADC10_sel, 0);

	}

	/* digital-packet gain only */
	MOD_PHYREG(pi, singleShotAgcCtrl, singleShotPktGainElement, 96);

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		/* SWWLAN-42666  : 0x454b ==> SW4345-514 : 0x424b */
		ACPHY_REG_LIST_START
			WRITE_PHYREG_ENTRY(pi, crshighlowpowThresholdl, 0x424b)
			WRITE_PHYREG_ENTRY(pi, crshighlowpowThresholdu, 0x424b)
			WRITE_PHYREG_ENTRY(pi, crshighlowpowThresholdlSub1, 0x424b)
			WRITE_PHYREG_ENTRY(pi, crshighlowpowThresholduSub1, 0x424b)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* BPHY-20in20:Tap main-DC-Filter,DVGA2=ON,dvga2maxgain limit disabled(i.e. gain=12dB) */
	if ((!ACMINORREV_0(pi->pubpi.phy_rev)) && (!ACMINORREV_1(pi->pubpi.phy_rev))) {
	  uint32 datapath = pi->u.pi_acphy->srom.dot11b_opts;

	  /*
	    A0 = 001000 = 0x8 (11bhpf on,adc10 off )
	    B0 = 000001 = 0x1 (adc10off,dvga tap)
	    B0mod = 110111 = 0x37(targetvar, adc10+6dB, 11bhpf-off, adc10 on, dcnotchtap )
	  */

	  MOD_PHYREG(pi, RxFeCtrl1, swap_iq1, datapath & 1);
	  MOD_PHYREG(pi, RxFeCtrl1, swap_iq2, (datapath>>1) & 1);
	  MOD_PHYREG(pi, RxSdFeConfig5, tiny_bphy20_ADC10_sel, (datapath>>2)&1);
	  MOD_PHYREG(pi, bphyTest, dccomp, (datapath>>3)&1);

	  if ((datapath >> 4)&1) {
	    temp_reg = READ_PHYREG(pi, work_around_ctrl);
	    temp_reg |= (0x1 << 7);
	    WRITE_PHYREG(pi, work_around_ctrl, temp_reg);
	  }

	  if ((datapath >> 5)&1)
	    {
	      MOD_PHYREG(pi, Core0_BPHY_TargetVar_log2_pt8us, bphy_targetVar_log2_pt8us, 479);

	    }

	  if ((datapath >> 6)&7)
	    {
	      MOD_PHYREG(pi, DigiGainLimit0, minCckDigiGainShift, (datapath >> 6)&7);

	    }

	  if ((datapath >> 9)&0x3ff)
	      MOD_PHYREG(pi, Core0_BPHY_TargetVar_log2_pt8us, bphy_targetVar_log2_pt8us,
	      (datapath >> 9)&0x3ff);

	}

	MOD_PHYREG(pi, overideDigiGain1, cckdigigainEnCntValue, 119);
}

static CONST uint16 acphy_Smth_tbl_tiny[] = {
	0x5fd2,	0x16fc,	0x0ce0,
	0x60ce,	0xc501,	0xfd2f,
	0xefe0,	0x09fc,	0x09e0,
	0x90eb,	0xc802,	0xfc5f,
	0xcfed,	0x01fd,	0x0690,
	0xf0ed,	0xd903,	0xfc0f,
	0xcff7,	0xfefe,	0x037f,
	0x30d2,	0xf605,	0xfc7f,
	0xbfd8,	0x4b00,	0x0860,
	0xb052,	0xf501,	0xfe6f,
	0xbfda,	0x33ff,	0x0750,
	0x3075,	0xfb03,	0xfdaf,
	0xefe8,	0x3500,	0x0530,
	0x4fe0,	0xe8f9,	0x119f,
	0x8119,	0x94fe,	0xfe0f,
	0x5fea,	0xe6fa,	0x0e5f,
	0x1142,	0x8aff,	0xfd4f,
	0xaff1,	0xe9fb,	0x0acf,
	0x2156,	0x8d00,	0xfc8f,
	0xfff7,	0xeefc,	0x075f,
	0xa151,	0x9d01,	0xfbef,
	0x2ffb,	0xf4fe,	0x045f,
	0x612f,	0xbd03,	0xfbbf,
	0x1ffe,	0xfaff,	0x021f,
	0xe0f4,	0xe704,	0xfc5f,
	0xafd8,	0x4b00,	0x0880,
	0xa052,	0xf401,	0xfe7f,
	0xafda,	0x33ff,	0x0770,
	0x3077,	0xfa03,	0xfdaf,
	0xdfe8,	0x3500,	0x0540,
	0x30a5,	0xc5f2,	0x1f1e,
	0x51f1,	0x23ec,	0x0a5f,
	0x607c,	0x06f6,	0x167f,
	0xb236,	0xffec,	0x0ade,
	0xc049,	0x67fa,	0x0cdf,
	0x4214,	0x13f2,	0x089f,
	0x001d,	0xc0fe,	0x051f,
	0x2191,	0x68fb,	0x044f,
	0x100f,	0x12fb,	0x0ef0,
	0xe07f,	0xc2fd,	0x01cf,
	0x2021,	0xe6fa,	0x0d5f,
	0x60d5,	0xa2fe,	0x021f,
	0x4ffc,	0x22fe,	0x07b0,
	0x2125,	0x2cf0,	0x32bd,
	0xc32b,	0x02d2,	0x125f,
	0x50e8,	0xb0f4,	0x27ed,
	0xe3a0,	0xc7ce,	0x14be,
	0x40a3,	0x57f8,	0x1bee,
	0x43bd,	0xa3d1,	0x14ce,
	0x8062,	0xf9fb,	0x10ee,
	0x3370,	0xa7da,	0x11fe,
	0xe030,	0x7cfd,	0x085f,
	0x12c1,	0xe2e8,	0x0c9e,
	0x4010,	0xd1ff,	0x02ef,
	0x41d4,	0x54f7,	0x05df,
	0xf011,	0x10fa,	0x0f10,
	0xd07f,	0xc2fd,	0x01cf,
	0x1023,	0xe4fa,	0x0d7f,
	0x40d7,	0xa1fe,	0x023f,
	0x3ffd,	0x22fe,	0x07c0,
	0x3ffb,	0xf6fe,	0x044f,
	0x912a,	0xc103,	0xfbaf,
	0x2ffd,	0xfaff,	0x021f,
	0xf0f1,	0xe904,	0xfc4f,
};

static void
wlc_phy_papd_smooth_acphy(phy_info_t *pi, uint8 core, uint32 winsz, uint32 start, uint32 end)
{
	uint32 *buf, *src, *dst, sz;
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};

	PHY_CAL(("Smoothing papd cal on core: %d\n", core));

	sz = end - start + 1;
	ASSERT(end > start);
	ASSERT(end < ACPHY_PAPD_EPS_TBL_SIZE);

	/* Allocate storage for both source & destination tables */
	if ((buf = MALLOC(pi->sh->osh, 2 * sizeof(uint32) * ACPHY_PAPD_EPS_TBL_SIZE)) == NULL) {
		PHY_ERROR(("wl%d: %s: MALLOC failure\n", pi->sh->unit, __FUNCTION__));
		return;
	}

	/* Setup source & destination pointers */
	src = buf;
	dst = buf + ACPHY_PAPD_EPS_TBL_SIZE;

	/* Read original table */
	wlc_phy_table_read_acphy(pi, epsilon_table_ids[core], ACPHY_PAPD_EPS_TBL_SIZE, 0, 32, src);

	/* Average coeffs across window */
	do {
		uint32 win_start, win_end;
		int32 nAvr, eps_r, eps_i, eps_real, eps_imag;

		win_start = end - MIN(end, (winsz >> 1));
		win_end = MIN(ACPHY_PAPD_EPS_TBL_SIZE - 1, end + (winsz >> 1));
		nAvr = win_end - win_start + 1;
		eps_real = 0;
		eps_imag = 0;

		do {
			wlc_phy_papd_decode_epsilon(src[win_end], &eps_r, &eps_i);
			eps_real += eps_r;
			eps_imag += eps_i;
		} while (win_end-- != win_start);

		eps_real /= nAvr;
		eps_imag /= nAvr;
		dst[end] = ((uint32)eps_imag << 13) | ((uint32)eps_real & 0x1fff);
	} while (end-- != start);

	/* Write updated table */
	wlc_phy_table_write_acphy(pi, epsilon_table_ids[core], sz, start, 32, dst);

	/* Free allocated buffer */
	MFREE(pi->sh->osh, buf, 2 * sizeof(uint32) * ACPHY_PAPD_EPS_TBL_SIZE);
}

static void wlc_phy_load_channel_smoothing_tiny(phy_info_t *pi)
{
	const uint16 zero_table[3] = { 0, 0, 0 };
	acphytbl_info_t tbl;

	tbl.tbl_id = ACPHY_TBL_ID_CHANNELSMOOTHING_1x1;
	tbl.tbl_ptr = zero_table;
	tbl.tbl_len = 1;
	tbl.tbl_offset = 0;
	tbl.tbl_width = 48;

	/* clear 1st 128 48-bit entries */
	for (tbl.tbl_offset = 0; tbl.tbl_offset < 128; tbl.tbl_offset++) {
		wlc_phy_write_table_ext(pi, &tbl, ACPHY_TableID(pi->pubpi.phy_rev),
		                        ACPHY_TableOffset(pi->pubpi.phy_rev),
		                        ACPHY_TableDataWide(pi->pubpi.phy_rev),
		                        ACPHY_TableDataHi(pi->pubpi.phy_rev),
		                        ACPHY_TableDataLo(pi->pubpi.phy_rev));
	}

	/* set next 64 48-bit entries */
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_CHANNELSMOOTHING_1x1,
	                          ARRAYSIZE(acphy_Smth_tbl_tiny), 128,
	                          tbl.tbl_width, acphy_Smth_tbl_tiny);

	/* clear next 64 48-bit entries */
	for (tbl.tbl_offset = 128 + (ARRAYSIZE(acphy_Smth_tbl_tiny) / 3);
	     tbl.tbl_offset < 256;
	     tbl.tbl_offset++) {
		wlc_phy_write_table_ext(pi, &tbl, ACPHY_TableID(pi->pubpi.phy_rev),
		                        ACPHY_TableOffset(pi->pubpi.phy_rev),
		                        ACPHY_TableDataWide(pi->pubpi.phy_rev),
		                        ACPHY_TableDataHi(pi->pubpi.phy_rev),
		                        ACPHY_TableDataLo(pi->pubpi.phy_rev));
	}
}

/** Initialize chip tbls(reg-based) that get reset with phy_reset */
static void
wlc_phy_set_tbl_on_reset_acphy(phy_info_t *pi)
{
	uint8 stall_val;
	phy_info_acphy_t *pi_ac;
	uint16 adc_war_val = 0x20, pablowup_war_val = 120;
	uint8 core;
	uint16 gmult20, gmult40, gmult80;
	uint16 rfseq_bundle_tssisleep48[3];
	uint16 rfseq_bundle_48[3];
	/* uint16 AFEdiv_read_val = 0x0000; */

	bool ext_pa_ana_2g =  ((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_ANAPACTRL_2G) != 0);
	bool ext_pa_ana_5g =  ((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_ANAPACTRL_5G) != 0);

	/* DEBUG: TEST CODE FOR SS PTW70 DEBUG */
	uint32 war_val = 0x7ffffff;
	uint8 offset;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	pi_ac = pi->u.pi_acphy;

	/* Load settings related to antswctrl if not on QT */
	if (!ISSIM_ENAB(pi->sh->sih)) {
		wlc_phy_set_regtbl_on_femctrl(pi);
	}

	/* Quickturn only init */
	if (ISSIM_ENAB(pi->sh->sih)) {
		uint8 core_idx;
		uint16 val = 64;

		FOREACH_CORE(pi, core_idx) {
			wlc_phy_set_tx_bbmult_acphy(pi, &val, core_idx);
		}

		/* dummy call to satisfy compiler */
		wlc_phy_get_tx_bbmult_acphy(pi, &val, 0);

		/* on QT: force the init gain to allow noise_var not limiting 256QAM performance */
		ACPHYREG_BCAST(pi, Core0InitGainCodeA, 0x16a);
		ACPHYREG_BCAST(pi, Core0InitGainCodeB, 0x24);

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
				0xf9 + core, 16, &qt_rfseq_val1[core]);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
				0xf6 + core, 16, &qt_rfseq_val2[core]);
		}
	}

	/* Update gmult, dacbuf after radio init */
	/* Tx Filters */
	wlc_phy_set_analog_tx_lpf(pi, 0x1ff, -1, -1, -1, pi_ac->rccal_gmult,
	                          pi_ac->rccal_gmult_rc, -1);
	wlc_phy_set_tx_afe_dacbuf_cap(pi, 0x1ff, pi_ac->rccal_dacbuf, -1, -1);

	/* Rx Filters */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* 4360 (tighten rx analog filters). Note than 80mhz filter cutoff
		   was speced at 39mhz (should have been 38.5)
		   C-model desired bw : {9, 18.5, 38.5}  @ 3dB cutoff
		   lab-desired (freq offset + 5%PVT): {9.5, 20, 41}
		   with gmult = 193 (in 2069_procs.tcl), we get {11, 23.9, 48.857}
		   Reduce bw by factor : {9.5/11, 20/23.9, 41/48.857} = {0.863, 0.837, 0.839}
		*/
		gmult20 = (pi_ac->rccal_gmult * 221) >> 8;     /* gmult * 0.863 */
		gmult40 = (pi_ac->rccal_gmult * 215) >> 8;     /* gmult * 0.839 (~ 0.837) */
		gmult80 = (pi_ac->rccal_gmult * 215) >> 8;     /* gmult * 0.839 */
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		/* 4335C0 (tighten rx analog filter for 80mhz only).
		   This is needed to take away
		   hump which comes because of ACI causing false clip_hi
		*/
		gmult20 = pi_ac->rccal_gmult;
		gmult40 = pi_ac->rccal_gmult;
		if (!(PHY_ILNA(pi))) {
			gmult80 = (pi_ac->rccal_gmult * 225) >> 8;     /* gmult * 0.879 */
		} else {
			gmult80 = pi_ac->rccal_gmult;
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		/* 4354/4350C0 widening analog filter BW
		This is needed to take care of Edge tones IRR across PVT
		9  --> 9.36 for 20Mhz
		18 --> 18.54 for 40mhz
		38 --> 39.5 for 80mhz
		*/
		if (pi->u.pi_acphy->srom.phy4350_ss_opt) {
			gmult20 = (pi_ac->rccal_gmult * 266) >> 8;     /* gmult * 1.04 */
			gmult40 = (pi_ac->rccal_gmult * 263) >> 8;     /* gmult * 1.03 */
			gmult80 = (pi_ac->rccal_gmult * 266) >> 8;     /* gmult * 1.04 */
		} else {
			gmult20 = pi_ac->rccal_gmult;
			gmult40 = pi_ac->rccal_gmult;
			gmult80 = pi_ac->rccal_gmult;
		}
	} else {
		gmult20 = pi_ac->rccal_gmult;
		gmult40 = pi_ac->rccal_gmult;
		gmult80 = pi_ac->rccal_gmult;
	}
	wlc_phy_set_analog_rx_lpf(pi, 1, -1, -1, -1, gmult20, pi_ac->rccal_gmult_rc, -1);
	wlc_phy_set_analog_rx_lpf(pi, 2, -1, -1, -1, gmult40, pi_ac->rccal_gmult_rc, -1);
	wlc_phy_set_analog_rx_lpf(pi, 4, -1, -1, -1, gmult80, pi_ac->rccal_gmult_rc, -1);

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x20, 16, rfseq_reset2rx_cmd);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x90, 16, rfseq_reset2rx_dly);

	/* during updateGainL make sure the lpf/tia hpc corner is set properly to optimum setting */
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 2, 0x121, 16, rfseq_updl_lpf_hpc_ml);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 2, 0x131, 16, rfseq_updl_lpf_hpc_ml);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 2, 0x124, 16, rfseq_updl_tia_hpc_ml);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 2, 0x137, 16, rfseq_updl_tia_hpc_ml);

	/* tx2rx/rx2tx: Remove SELECT_RFPLL_AFE_CLKDIV/RESUME as we are not in boost mode */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi))) {
		if ((CHSPEC_IS2G(pi->radio_chanspec) &&
			(((CHSPEC_IS20(pi->radio_chanspec)) &&
			(pi->u.pi_acphy->srom_tssisleep_en & 0x1)) ||
			((CHSPEC_IS40(pi->radio_chanspec)) &&
			(pi->u.pi_acphy->srom_tssisleep_en & 0x2)))) ||
			(CHSPEC_IS5G(pi->radio_chanspec) &&
			(((CHSPEC_IS20(pi->radio_chanspec)) &&
			(pi->u.pi_acphy->srom_tssisleep_en & 0x4)) ||
			((CHSPEC_IS40(pi->radio_chanspec)) &&
			(pi->u.pi_acphy->srom_tssisleep_en & 0x8)) ||
			((CHSPEC_IS80(pi->radio_chanspec)) &&
			(pi->u.pi_acphy->srom_tssisleep_en & 0x10))))) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
					16, rfseq_rx2tx_cmd_withtssisleep);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
					16, rfseq_rx2tx_dly_withtssisleep);
				MOD_PHYREG(pi, RfBiasControl, tssi_sleep_bg_pulse_val, 1);
				MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 1);
				rfseq_bundle_tssisleep48[0] = 0x0000;
				rfseq_bundle_tssisleep48[1] = 0x20;
				rfseq_bundle_tssisleep48[2] = 0x0;
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 0, 48,
					rfseq_bundle_tssisleep48);
		} else {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
				16, rfseq_rx2tx_cmd);
		}
	} else if (TINY_RADIO(pi)) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00, 16,
		                          tiny_rfseq_rx2tx_cmd);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 112, 16,
		                          tiny_rfseq_rx2tx_dly);
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && !(PHY_IPA(pi))) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
			16, rfseq_rx2tx_cmd_dacmode);
	} else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
			16, rfseq_rx2tx_cmd);
	}

	if (TINY_RADIO(pi)) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x10, 16,
		                          tiny_rfseq_tx2rx_cmd);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 128, 16,
		                          tiny_rfseq_tx2rx_dly);
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && !(PHY_IPA(pi))) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x10,
			16, rfseq_tx2rx_cmd_dacmode);
	} else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x10, 16, rfseq_tx2rx_cmd);
	}

	if (1) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3c6, 16, &adc_war_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3c7, 16, &adc_war_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3d6, 16, &adc_war_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3d7, 16, &adc_war_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3e6, 16, &adc_war_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x3e7, 16, &adc_war_val);
	}

	/* do this during fem table load for 43602a0 */
	if (((CHSPEC_IS2G(pi->radio_chanspec) && ext_pa_ana_2g) ||
	    (CHSPEC_IS5G(pi->radio_chanspec) && ext_pa_ana_5g)) &&
	    !(ACMAJORREV_5(pi->pubpi.phy_rev) && ACMINORREV_0(pi->pubpi.phy_rev))) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x80, 16, &pablowup_war_val);
	}

	/* 4360 and 43602 */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* load the txv for spatial expansion */
		acphy_load_txv_for_spexp(pi);
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	    RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
		/* 11n_20 */
		wlc_phy_set_analog_tx_lpf(pi, 0x2, -1, 5, 5, -1, -1, -1);
		/* 11ag_11ac_20 */
		wlc_phy_set_analog_tx_lpf(pi, 0x4, -1, 5, 5, -1, -1, -1);
		/* 11n_40 */
		wlc_phy_set_analog_tx_lpf(pi, 0x10, -1, 5, 5, -1, -1, -1);
		/* 11ag_11ac_40 */
		wlc_phy_set_analog_tx_lpf(pi, 0x20, -1, 5, 5, -1, -1, -1);
		/* 11n_11ag_11ac_80 */
		wlc_phy_set_analog_tx_lpf(pi, 0x80, -1, 6, 6, -1, -1, -1);
	}

	/* tiny radio specific processing */
	if (TINY_RADIO(pi)) {
		uint16 regval;
		const uint32 NvAdjTbl[64] = { 0x000000, 0x400844, 0x300633, 0x200422,
			0x100211, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
			0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
			0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000100,
			0x000200, 0x000311, 0x000422, 0x100533, 0x200644, 0x300700,
			0x400800, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
			0x000000, 0x000000, 0x400800, 0x300700, 0x200644, 0x100533,
			0x000422, 0x000311, 0x000200, 0x000100, 0x000000, 0x000000,
			0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
			0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000,
			0x000000, 0x000000, 0x100211, 0x200422, 0x300633, 0x400844};

		const uint32 phasetracktbl[22] = { 0x06af56cd, 0x059acc7b,
			0x04ce6652, 0x02b15819, 0x02b15819, 0x02b15819, 0x02b15819,
			0x02b15819, 0x02b15819, 0x02b15819, 0x02b15819, 0x06af56cd,
			0x059acc7b, 0x04ce6652, 0x02b15819, 0x02b15819, 0x02b15819,
			0x02b15819, 0x02b15819, 0x02b15819, 0x02b15819, 0x02b15819};

		/* Tiny NvAdjTbl */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVADJTBL, 64, 0, 32, NvAdjTbl);

		/* Tiny phasetrack */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PHASETRACKTBL_1X1, 22, 0, 32,
		                          phasetracktbl);

		/* Channels Smoothing */
		if (!ACMINORREV_0(pi->pubpi.phy_rev))
			wlc_phy_load_channel_smoothing_tiny(pi);

		/* program tx, rx bias reset to avoid clock stalls */
		regval = 0x2b;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0xe8, 16, &regval);
		regval = 0x28;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0xe7, 16, &regval);

		/* #Keep lpf_pu @ 0 for rx since lpf_pu controls tx lpf exclusively */
		regval = 0x82c0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x14b, 16, &regval);

		/* Magic rfseqbundle writes to make TX->Rx turnaround work */
		/* set rfseq_bundle_tbl {0x4000 0x0000 } */
		/* acphy_write_table RfseqBundle $rfseq_bundle_tbl 4 */
		rfseq_bundle_48[0] = 0x4000;
		rfseq_bundle_48[1] = 0x0;
		rfseq_bundle_48[2] = 0x0;

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 4, 48,
		                          rfseq_bundle_48);
		rfseq_bundle_48[0] = 0x0000;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 5, 48,
		                          rfseq_bundle_48);

		/* set rfseq_bundle_tbl {0x3000C 0x20000 0x30034 0x20000} */
		/* acphy_write_table RfseqBundle $rfseq_bundle_tbl 0 */
		rfseq_bundle_48[0] = 0x0000;
		rfseq_bundle_48[1] = 0x2;
		rfseq_bundle_48[2] = 0x0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 0, 48,
		                          rfseq_bundle_48);
		rfseq_bundle_48[0] = 0x0034;
		rfseq_bundle_48[1] = 0x3;
		rfseq_bundle_48[2] = 0x0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 1, 48,
		                          rfseq_bundle_48);
		rfseq_bundle_48[0] = 0x0000;
		rfseq_bundle_48[1] = 0x2;
		rfseq_bundle_48[2] = 0x0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 2, 48,
		                          rfseq_bundle_48);
		rfseq_bundle_48[0] = 0x000c;
		rfseq_bundle_48[1] = 0x3;
		rfseq_bundle_48[2] = 0x0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 3, 48,
		                          rfseq_bundle_48);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
		uint8 txevmtbl[40] = {0x09, 0x0E, 0x11, 0x14, 0x17, 0x1A, 0x1D, 0x20, 0x09,
			0x0E, 0x11, 0x14, 0x17, 0x1A, 0x1D, 0x20, 0x22, 0x24, 0x09, 0x0E,
			0x11, 0x14, 0x17, 0x1A, 0x1D, 0x20, 0x22, 0x24, 0x09, 0x0E, 0x11,
			0x14, 0x17, 0x1A, 0x1D, 0x20, 0x22, 0x24, 0x0, 0x0};
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_TXEVMTBL, 40, 0, 8, txevmtbl);
	}

	/* 4335: Running phase track loop faster */
	/* Fix for ping issue caused by high phase imbalance */
	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		uint32 phasetracktbl_1x1[22] = { 0x6AF5700, 0x59ACC9A,
			0x4CE6666, 0x4422064, 0x4422064, 0x4422064,	0x4422064,
			0x4422064, 0x4422064, 0x4422064, 0x4422064, 0x6AF5700,
			0x59ACC9A, 0x4CE6666, 0x4422064, 0x4422064, 0x4422064,
			0x4422064, 0x4422064, 0x4422064, 0x4422064, 0x4422064};
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PHASETRACKTBL_1X1, 22, 0, 32,
		                          phasetracktbl_1x1);
	}
	/* Increase phase track loop BW to improve PER floor, */
	/*   Phase noise  seems higher. Needs further investigation */
	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		uint32 phasetracktbl[22] = { 0x6AF5700, 0x59ACC9A,
			0x4CE6666, 0x4422064, 0x4422064, 0x4422064,	0x4422064,
			0x4422064, 0x4422064, 0x4422064, 0x4422064, 0x6AF5700,
			0x59ACC9A, 0x4CE6666, 0x4422064, 0x4422064, 0x4422064,
			0x4422064, 0x4422064, 0x4422064, 0x4422064, 0x4422064};
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PHASETRACKTBL, 22, 0, 32,
		                          phasetracktbl);
	}
	/* DEBUG: TEST CODE FOR SS PTW70 DEBUG */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && pi->u.pi_acphy->srom.phasetrack_max_alphabeta) {
		for (offset = 0; offset < 22; offset++) {
			wlc_phy_table_write_acphy(pi, 0x1a, 1, offset, 32, &war_val);
		}
	}

	/* To save current, turn off AFEDiv for the unused core, */
	/* Below forces AFEDiv_pu_repeater2_disRX to be 0 when doing TX2RX || reset2RX */
	/* if (ACMAJORREV_2(pi->pubpi.phy_rev)) { */
	/* 	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0xe9, 16, &AFEdiv_read_val); */
	/* 	AFEdiv_read_val = (AFEdiv_read_val & 0xfdff); */
	/* 	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0xe9, 16, &AFEdiv_read_val); */
	/* } */

	ACPHY_ENABLE_STALL(pi, stall_val);

}

static void
wlc_enable_lna_dcc_comp_20691(phy_info_t *pi, bool on)
{
	uint16 sparereg = READ_PHYREG(pi, SpareReg);

	if (on)
		WRITE_PHYREG(pi, SpareReg,  sparereg & 0xfffe);
	else
		WRITE_PHYREG(pi, SpareReg,  sparereg | 1);

}

static void
wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(phy_info_t *pi, uint8 core,
                                            uint16 gain_tblid, uint16 gainbits_tblid)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 farrow_shift = 2;

	/* TIA */
	/* 2g & 5g settings */
	uint8 tia[]     = {10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43};
	uint8 tiabits[] = { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11};
	int8  lna1_gain[] = { -6, 0, 6, 12, 18, 24};	/* interim measure only
							 * this may change on band basis
							 */
	uint8 lna1_gainbits[] = {0, 1, 2, 3, 4, 5};
	int8 elna_gain = pi_ac->rxgainctrl_params[core].gaintbl[0][0];
	uint8 i;
	bool elna_present = CHSPEC_IS2G(pi->radio_chanspec) ? pi_ac->srom.elna2g_present
	                                                    : pi_ac->srom.elna5g_present;
	uint8 lna1_min_indx; /* default ilna parameters */
	uint8 lna1_max_indx;
	int8 lna1_max_gain = lna1_gain[5];
	uint8 max_analog_gain = 55; /* eventually we may move into lna_present clause below */
	const uint8 unused = 127;
	const uint8 used = 0;

	if (IS20MHZ(pi))
	  i = 0;
	else if (IS40MHZ(pi))
	  i = 1;
	else
	  i = 2;

	if (pi_ac->srom.tiny_maxrxgain[i] > 0)
	    max_analog_gain = pi_ac->srom.tiny_maxrxgain[i];

	wlc_phy_table_write_acphy(pi, gainbits_tblid, 1, 115, 8, &farrow_shift);
	wlc_phy_table_write_acphy(pi, gain_tblid, 12, 32, 8, tia);
	wlc_phy_table_write_acphy(pi, gainbits_tblid, 12, 32, 8, tiabits);

	/* copying values into gaintbl arrays to avoid reading from table */
	memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], tia,
	       sizeof(uint8) * pi_ac->rxgainctrl_stage_len[3]);

	memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[3], tiabits,
	       sizeof(uint8) * pi_ac->rxgainctrl_stage_len[3]);

	/* backoff LNA1 for ELNA/iLNA(ACI) operation */
	if (elna_present) {
		lna1_min_indx = 4;

		if (ACPHY_ENABLE_FCBS_HWACI(pi)) {
			if (pi_ac->curr_desense.lna1_tbl_desense < lna1_min_indx)
				lna1_min_indx -= pi_ac->curr_desense.lna1_tbl_desense;
			else
				lna1_min_indx = 0;
		}

		lna1_max_indx = 5;

		/* find maximum gain */
		for (i = lna1_min_indx;
		     i <= lna1_max_indx && elna_gain + lna1_gain[i] < lna1_max_gain;
		     i++);

		lna1_max_indx = (i > lna1_max_indx) ? lna1_max_indx : i;
	} else {
		/* iLNA LNA1 configuration
		 * eg. set lna1_max_lna=4 to reduce LNA1 gain by 6 dB.
		 * The algorithm will allocate more gain to tia.
		 * Further changes in gain distribution can be tuned by setting max_analog_gain.
		 */
		lna1_min_indx = 0; /* unused */
		lna1_max_indx = 5;
	}

	lna1_max_gain = lna1_gain[lna1_max_indx];

	/* limit LNA1 appropriately */
	for (i = 0; i < 6; i++) {
	  if (i >= lna1_max_indx + 1) {
		lna1_gain[i]     = lna1_gain[lna1_max_indx];
		lna1_gainbits[i] = lna1_max_indx;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 1, 8 + i, 8, &unused);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 1, 72 + i, 8, &unused);
	  } else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 1, 8 + i, 8, &used);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 1, 72 + i, 8, &used);

	  }
	}
	/* need this for encode gain to work correctly */
	wlc_phy_table_write_acphy(pi, gain_tblid, 6, 8, 8, lna1_gain);
	wlc_phy_table_write_acphy(pi, gainbits_tblid, 6, 8, 8, lna1_gainbits);

	/* copying values into gaintbl arrays to avoid reading from hw */
	memcpy(pi_ac->rxgainctrl_params[core].gaintbl[1], lna1_gain,
	       sizeof(int8) * pi_ac->rxgainctrl_stage_len[1]);

	memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[1], lna1_gainbits,
	       sizeof(int8) * pi_ac->rxgainctrl_stage_len[1]);

	/* write max analog gain */
	if (ACPHY_ENABLE_FCBS_HWACI(pi)) {
		if (max_analog_gain >= pi_ac->curr_desense.ofdm_desense)
			MOD_PHYREG(pi, Core0HpFBw, maxAnalogGaindb,
				max_analog_gain - pi_ac->curr_desense.ofdm_desense);
		else
			MOD_PHYREG(pi, Core0HpFBw, maxAnalogGaindb, 0);
		if (max_analog_gain >= pi_ac->curr_desense.bphy_desense)
			MOD_PHYREG(pi, Core0DSSScckPktGain, dsss_cck_maxAnalogGaindb,
				max_analog_gain - pi_ac->curr_desense.bphy_desense);
		else
			MOD_PHYREG(pi, Core0DSSScckPktGain, dsss_cck_maxAnalogGaindb, 0);
	} else {
		MOD_PHYREG(pi, Core0HpFBw, maxAnalogGaindb,
			max_analog_gain);
		MOD_PHYREG(pi, Core0DSSScckPktGain, dsss_cck_maxAnalogGaindb,
			max_analog_gain);
		}
}

static void
wlc_phy_rxgainctrl_set_gaintbls_acphy_2069(phy_info_t *pi, uint8 core,
                                           uint16 gain_tblid, uint16 gainbits_tblid)
{
	uint16 gmsz;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->total_desense;

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		uint8 mixbits_2g[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
		uint8 mix_2g_43352_ilna[] = {0x9, 0x9, 0x9, 0x9, 0x9,
		                       0x9, 0x9, 0x9, 0x9, 0x9};
		uint8 mix_2g[]  = {0x3, 0x3, 0x3, 0x3, 0x3,
		                       0x3, 0x3, 0x3, 0x3, 0x3};

		if (desense->mixer_setting_desense && (ACMAJORREV_2(pi->pubpi.phy_rev) &&
		    (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev)) &&
		    PHY_XTAL_IS40M(pi))) {
			/* Only one setting implemented for now */

			/* Limit mixer gain */
			/* TODO MVe: Should be 0 */
			uint8 mix_gains[] = {6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
			uint8 mix_bits[]  = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};

			/* Use lna2_gm_sz = 2 (for ACI), mix/tia_gm_sz = 1 */
			gmsz = desense->elna_bypass ? 0x2c : 0x28;
			ACPHYREG_BCAST(pi, RfctrlCoreLowPwr0, gmsz);

			wlc_phy_table_write_acphy(pi, gain_tblid,     10, 32, 8, mix_gains);
			wlc_phy_table_write_acphy(pi, gainbits_tblid, 10, 32, 8, mix_bits);

			/* copying values into gaintbl arrays */
			/* to avoid reading from table */
			memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], mix_gains,
				sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
			memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[3], mix_bits,
				sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
		} else if (PHY_ILNA(pi)) {
			/* Use lna2_gm_sz = 3 (for ACI), mix/tia_gm_sz = 2 */
			ACPHYREG_BCAST(pi, RfctrlCoreLowPwr0, 0x2c);
			ACPHYREG_BCAST(pi, RfctrlOverrideLowPwrCfg0, 0xc);

			wlc_phy_table_write_acphy(pi, gain_tblid, 10, 32, 8, mix_2g_43352_ilna);
			wlc_phy_table_write_acphy(pi, gainbits_tblid, 10, 32, 8, mixbits_2g);

			/* copying values into gaintbl arrays
				to avoid reading from table
			*/
			memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], mix_2g_43352_ilna,
				sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
			memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[3], mixbits_2g,
			       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
		} else {
			if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
			    RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
				/* Use lna2_gm_sz = 2 (for ACI), mix/tia_gm_sz = 1 */
				gmsz = desense->elna_bypass ? 0x2c : 0x28;
				wlc_phy_table_write_acphy(pi, gain_tblid, 10, 32, 8,
				                          mix_2g_43352_ilna);
				/* copying values into gaintbl arrays
				   to avoid reading from table
				*/
				memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], mix_2g_43352_ilna,
				       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
			} else {
				/* Use lna2_gm_sz = 2 (for ACI), mix/tia_gm_sz = 1 */
				gmsz = desense->elna_bypass ? 0x1c : 0x18;
				wlc_phy_table_write_acphy(pi, gain_tblid, 10, 32, 8, mix_2g);

				/* copying values into gaintbl arrays to avoid reading from table */
				memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], mix_2g,
				       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
			}
			ACPHYREG_BCAST(pi, RfctrlCoreLowPwr0, gmsz);
			ACPHYREG_BCAST(pi, RfctrlOverrideLowPwrCfg0, 0xc);
			wlc_phy_table_write_acphy(pi, gainbits_tblid, 10, 32, 8, mixbits_2g);
			memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[3], mixbits_2g,
			       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
		}
	} else {
		/* 5g settings */
		uint8 mix5g_elna[]  = {0x7, 0x7, 0x7, 0x7, 0x7,
		                       0x7, 0x7, 0x7, 0x7, 0x7};
		uint8 mixbits5g_elna[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2};
		uint8 mix5g_ilna[]  = {16, 16, 16, 16, 16, 16, 16, 16, 16, 16};
		uint8 mixbits5g_ilna[] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
		uint8 *mix_5g;
		uint8 *mixbits_5g;

		/* Mixer tables based on elna/ilna */
		if (pi_ac->srom.elna5g_present) {
			mix_5g = mix5g_elna;
			mixbits_5g = mixbits5g_elna;
		} else {
			mix_5g = mix5g_ilna;
			mixbits_5g = mixbits5g_ilna;
		}

		/* Use lna2_gm_sz = 3, mix/tia_gm_sz = 2 */
		ACPHYREG_BCAST(pi, RfctrlCoreLowPwr0, 0x2c);
		ACPHYREG_BCAST(pi, RfctrlOverrideLowPwrCfg0, 0xc);

		wlc_phy_table_write_acphy(pi, gain_tblid, 10, 32, 8, mix_5g);
		wlc_phy_table_write_acphy(pi, gainbits_tblid, 10, 32, 8, mixbits_5g);

		/* copying values into gaintbl arrays to avoid reading from table */
		memcpy(pi_ac->rxgainctrl_params[core].gaintbl[3], mix_5g,
		       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
		memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[3], mixbits_5g,
		       sizeof(uint8)*pi_ac->rxgainctrl_stage_len[3]);
	}

	if (CHSPEC_IS2G(pi->radio_chanspec) && ACMAJORREV_2(pi->pubpi.phy_rev) &&
	    (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev)) &&
	    PHY_XTAL_IS40M(pi)) {
		uint8 biq0_gains[8];
		uint8 biq0_bits[8];
		uint8 limit, i;

		/* Limit the maximum gain in BiQ0. */
		/* BiQ0 has no gainlimit table so limit the tables */
		limit = MAX(0, 7 - desense->biq0_tbl_desense);
		for (i = 0; i < 8; i++) {
			uint8 val = i < limit ? i : limit;
			biq0_gains[i] = 3 * val;
			biq0_bits[i] = val;
		}

		wlc_phy_table_write_acphy(pi, gain_tblid,     8, 96, 8, biq0_gains);
		wlc_phy_table_write_acphy(pi, gainbits_tblid, 8, 96, 8, biq0_bits);

		memcpy(pi_ac->rxgainctrl_params[core].gaintbl[4], biq0_gains, 8);
		memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[4], biq0_bits, 8);

		/* Allow more than the 24 dB default gain for the sum of the two BiQ gains */
		if (desense->biqs_maxgain) {
			WRITE_PHYREG(pi, Core0_BiQuad_MaxGain, desense->biqs_maxgain);
			WRITE_PHYREG(pi, Core1_BiQuad_MaxGain, desense->biqs_maxgain);
		} else {
			WRITE_PHYREG(pi, Core0_BiQuad_MaxGain, 24);
			WRITE_PHYREG(pi, Core1_BiQuad_MaxGain, 24);
		}
		/* Update pi_ac->curr_desense (used in interf_mitigation) */
		pi_ac->curr_desense.mixer_setting_desense = desense->mixer_setting_desense;
		pi_ac->curr_desense.biq0_tbl_desense = desense->biq0_tbl_desense;
		pi_ac->curr_desense.biqs_maxgain = desense->biqs_maxgain;
	}
}

static void
wlc_phy_rxgainctrl_set_gaintbls_acphy(phy_info_t *pi, bool init, bool band_change,
                                             bool bw_change)
{
	uint8 elna[2];

	/* lna1 GainLimit */
	uint8 stall_val, core, i;
	uint16 save_forclks, gain_tblid, gainbits_tblid;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool suspend;

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
	}

	/* Read configuration values */
	FOREACH_CORE(pi, core) {
		/* FEM - elna, trloss (from srom) */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			elna[0] = elna[1] = pi_ac->srom.femrx_2g[core].elna;
			pi_ac->fem_rxgains[core].elna = elna[0];
			pi_ac->fem_rxgains[core].trloss = pi_ac->srom.femrx_2g[core].trloss;
			pi_ac->fem_rxgains[core].elna_bypass_tr =
			        pi_ac->srom.femrx_2g[core].elna_bypass_tr;
			pi_ac->fem_rxgains[core].lna1byp =
				((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2)
				& BFL2_LNA1BYPFORTR2G) != 0);
		} else if (CHSPEC_CHANNEL(pi->radio_chanspec) < 100) {
			elna[0] = elna[1] = pi_ac->srom.femrx_5g[core].elna;
			pi_ac->fem_rxgains[core].elna = elna[0];
			pi_ac->fem_rxgains[core].trloss = pi_ac->srom.femrx_5g[core].trloss;
			pi_ac->fem_rxgains[core].elna_bypass_tr =
			        pi_ac->srom.femrx_5g[core].elna_bypass_tr;
			pi_ac->fem_rxgains[core].lna1byp =
				((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2)
				& BFL2_LNA1BYPFORTR5G) != 0);
		} else {
			elna[0] = elna[1] = pi_ac->srom.femrx_5gh[core].elna;
			pi_ac->fem_rxgains[core].elna = elna[0];
			pi_ac->fem_rxgains[core].trloss = pi_ac->srom.femrx_5gh[core].trloss;
			pi_ac->fem_rxgains[core].elna_bypass_tr =
			        pi_ac->srom.femrx_5gh[core].elna_bypass_tr;
			pi_ac->fem_rxgains[core].lna1byp =
				((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2)
				& BFL2_LNA1BYPFORTR5G) != 0);
		}
	}

	/* Disable stall before writing tables */
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	/* If receiver is in active demod, it will NOT update the Gain tables */
	save_forclks = READ_PHYREG(pi, fineRxclockgatecontrol);
	MOD_PHYREG(pi, fineRxclockgatecontrol, forcegaingatedClksOn, 1);

	/* LNA1/2 (always do this, as the previous channel could have been in ACI mitigation) */
	wlc_phy_upd_lna1_lna2_gains_acphy(pi);

	FOREACH_CORE(pi, core) {
		gain_tblid = (core == 0) ? ACPHY_TBL_ID_GAIN0 :
		        ((core == 1) ? ACPHY_TBL_ID_GAIN1 : ACPHY_TBL_ID_GAIN2);
		gainbits_tblid = (core == 0) ? ACPHY_TBL_ID_GAINBITS0 :
		        ((core == 1) ? ACPHY_TBL_ID_GAINBITS1 : ACPHY_TBL_ID_GAINBITS2);

		wlc_phy_set_trloss_reg_acphy(pi, core);

		/* eLNA settings */
		wlc_phy_table_write_acphy(pi, gain_tblid, 2, 0, 8, elna);
		memcpy(pi_ac->rxgainctrl_params[core].gaintbl[0],
		       elna, sizeof(uint8)*pi_ac->rxgainctrl_stage_len[0]);

		/* MIX, LPF / TIA */
		if (TINY_RADIO(pi)) {
			/* always update - XXX FIXME:
			 * current lna1/lna2 settings reset a lot of the state
			 */
			wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(pi, core, gain_tblid,
			                                            gainbits_tblid);
		} else if (init || band_change) {
			wlc_phy_rxgainctrl_set_gaintbls_acphy_2069(pi, core, gain_tblid,
			                                           gainbits_tblid);
		}

		if (init) {
			/* Store gainctrl info (to be used for Auto-Gainctrl)
			 * lna1,2 taken care in wlc_phy_upd_lna1_lna2_gaintbls_acphy()
			 */
			wlc_phy_table_read_acphy(pi, gainbits_tblid, 1, 0, 8,
			                         pi_ac->rxgainctrl_params[core].gainbitstbl[0]);
			wlc_phy_table_read_acphy(pi, gainbits_tblid, 10, 32, 8,
			                         pi_ac->rxgainctrl_params[core].gainbitstbl[3]);
			wlc_phy_table_read_acphy(pi, gain_tblid, 8, 96, 8,
			                         pi_ac->rxgainctrl_params[core].gaintbl[4]);
			wlc_phy_table_read_acphy(pi, gain_tblid, 8, 112, 8,
			                         pi_ac->rxgainctrl_params[core].gaintbl[5]);
			wlc_phy_table_read_acphy(pi, gainbits_tblid, 8, 96, 8,
			                         pi_ac->rxgainctrl_params[core].gainbitstbl[4]);
			wlc_phy_table_read_acphy(pi, gainbits_tblid, 8, 112, 8,
			                         pi_ac->rxgainctrl_params[core].gainbitstbl[5]);

			if (TINY_RADIO(pi)) {
				/* initialise DVGA table */
				for (i = 0; i < pi_ac->rxgainctrl_stage_len[6]; i++) {
					pi_ac->rxgainctrl_params[core].gaintbl[6][i] = 3 * i;
					pi_ac->rxgainctrl_params[core].gainbitstbl[6][i] = i;
				}
			}
		}
	}

	/* Restore */
	WRITE_PHYREG(pi, fineRxclockgatecontrol, save_forclks);
	ACPHY_ENABLE_STALL(pi, stall_val);

	if (!suspend) {
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
	}
}

/* Enable/disable LNA1 bypass using radio overrides. */
/* See TCL proc acphy_lna1bypass_en */
static void
wlc_phy_lna1bypass_acphy(phy_info_t *pi, uint8 enable)
{
	ASSERT(enable <= 1);

	if (CHSPEC_IS2G(pi->radio_chanspec) || (enable == 0)) {
		MOD_RADIO_REG(pi, RFX, LNA2G_CFG1, lna1_bypass, enable);
		MOD_RADIO_REG(pi, RFX, OVR6, ovr_lna2g_lna1_bypass, enable);
		MOD_RADIO_REG(pi, RFX, LNA2G_CFG1, lna1_pu, 1 - enable);
		MOD_RADIO_REG(pi, RFX, OVR6, ovr_lna2g_lna1_pu, enable);
	}
	if (CHSPEC_IS5G(pi->radio_chanspec) || (enable == 0)) {
		MOD_RADIO_REG(pi, RFX, LNA5G_CFG1, lna1_bypass, enable);
		MOD_RADIO_REG(pi, RFX, OVR4, ovr_lna5g_lna1_bypass, enable);
		MOD_RADIO_REG(pi, RFX, LNA5G_CFG1, lna1_pu, 1 - enable);
		MOD_RADIO_REG(pi, RFX, OVR7, ovr_lna5g_lna1_pu, enable);
	}
}

static void
wlc_phy_cfg_energydrop_timeout(phy_info_t *pi)
{
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		/* Fine timing mod to have more overlap(~10dB) between low and high SNR regimes
		 * change to 0x8 to prevent the radar to trigger the fine timing
		 */
		MOD_PHYREG(pi, FSTRMetricTh, hiPwr_min_metric_th, 0x8);
		/* change it to 40000 for radar detection */
		WRITE_PHYREG(pi, energydroptimeoutLen, 0x9c40);
		/* Setting ed timeout to be 1 clk20 for 5G also as fix for
		 * preemption not working in wait_ed_drop for 4350
		 */
		if ((ACMAJORREV_2(pi->pubpi.phy_rev)) || ((ACMAJORREV_3(pi->pubpi.phy_rev)) &&
			(pi->u.pi_acphy->LTEJ_WAR_en == TRUE))) {
			WRITE_PHYREG(pi, energydroptimeoutLen, 0x2);
		}
	} else {
		/* Fine timing mod to have more overlap(~10dB) between low and high SNR regimes */
		MOD_PHYREG(pi, FSTRMetricTh, hiPwr_min_metric_th, 0xf);
		/* In event of high power spurs/interference that causes crs-glitches,
		 * stay in WAIT_ENERGY_DROP for 1 clk20 instead of default 1 ms.
		 * This way, we get back to CARRIER_SEARCH quickly and will less likely to miss
		 * actual packets. PS: this is actually one settings for ACI
		 */
		WRITE_PHYREG(pi, energydroptimeoutLen, 0x2);
	}
}

void
wlc_phy_radar_detect_on_off_cfg_acphy(phy_info_t *pi, bool radar_on)
{
	if (radar_on) {
		/* Fine timing mod to have more overlap(~10dB) between low and high SNR regimes
		 * change to 0x8 to prevent the radar to trigger the fine timing
		 */
		MOD_PHYREG(pi, FSTRMetricTh, hiPwr_min_metric_th, 0x8);
	} else {
		/* Fine timing mod to have more overlap(~10dB) between low and high SNR regimes */
		MOD_PHYREG(pi, FSTRMetricTh, hiPwr_min_metric_th, 0xf);
	}
}

static void
wlc_phy_set_regtbl_on_band_change_acphy(phy_info_t *pi)
{
	uint8 stall_val, core;
	uint16 bq1_gain_core1 = 0x49;
	uint8 pdet_range_id;
#ifdef WLPAPDPARAMS_CACHE
	ch_calcache_t *ctx;
	bool Cache_valid = FALSE;
#endif /* WLPAPDPARAMS_CACHE */
#ifndef WLC_DISABLE_ACI
	bool hwaci_on;
#endif /* !WLC_DISABLE_ACI */
	bool w2_on;
	txcal_coeffs_t txcal_cache[PHY_CORE_MAX];
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	wlc_phy_cfg_energydrop_timeout(pi);

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_PHYREG(pi, fineRxclockgatecontrol, forcedigigaingatedClksOn, 1);
		} else {
			MOD_PHYREG(pi, fineRxclockgatecontrol, forcedigigaingatedClksOn, 0);
		}

		/* 4335C0: Current optimization */
		if (ACMINORREV_2(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, fineRxclockgatecontrol, forcedigigaingatedClksOn, 0);
		}
	}

	if (ACMAJORREV_5(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_1(pi->pubpi.phy_rev) &&
	     !(ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev)))) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_PHYREG(pi, bOverAGParams, bOverAGlog2RhoSqrth, 120);
			MOD_PHYREG(pi, CRSMiscellaneousParam, b_over_ag_falsedet_en, 1);
		} else {
			MOD_PHYREG(pi, bOverAGParams, bOverAGlog2RhoSqrth, 255);
			MOD_PHYREG(pi, CRSMiscellaneousParam, b_over_ag_falsedet_en, 0);
		}
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		FOREACH_CORE(pi, core) {
			/* Reduces 20in80 humps in 5G */
			WRITE_PHYREGC(pi, Clip2Threshold, core, 0xa04e);
		}
	}

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS2G(pi->radio_chanspec) && ACMINORREV_1(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, clip_detect_normpwr_var_mux, use_norm_var_for_clip_detect,
			           0);
		} else {
			MOD_PHYREG(pi, clip_detect_normpwr_var_mux, use_norm_var_for_clip_detect,
			           1);
		}
	}

	/* Load tx gain table */
	wlc_phy_ac_gains_load(pi);

	if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
		wlc_phy_tx_gm_gain_boost(pi);
	}

	pdet_range_id = pi->u.pi_acphy->srom_5g_pdrange_id;
	if (pdet_range_id == 9 || pdet_range_id == 16) {
		bq1_gain_core1 = (CHSPEC_IS5G(pi->radio_chanspec))? 0x49 : 0;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x18e, 16, &bq1_gain_core1);
	}

	if (!ACMAJORREV_0(pi->pubpi.phy_rev)) {
		/* When WLAN is in 5G, WLAN table should control the FEM lines */
		/* and BT should not have any access permissions */
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			/* disable BT Fem control table accesses */
			MOD_PHYREG(pi, FemCtrl, enBtSignalsToFEMLut, 0x0);
			if (!ACPHY_FEMCTRL_ACTIVE(pi)) {
				MOD_PHYREG(pi, FemCtrl, femCtrlMask,
				           pi->u.pi_acphy->srom.femctrlmask_5g);
			} else {
				if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
					if (pi->u.pi_acphy->srom.femctrl == 4) {
						if (pi->u.pi_acphy->srom.femctrl_sub == 1) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x23c);
						} else if (pi->u.pi_acphy->srom.femctrl_sub == 2) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x297);
						} else if (pi->u.pi_acphy->srom.femctrl_sub == 3) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x058);
						} else if (pi->u.pi_acphy->srom.femctrl_sub == 4) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x058);
						} else if (pi->u.pi_acphy->srom.femctrl_sub == 6) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0xe);
						} else if (pi->u.pi_acphy->srom.femctrl_sub == 7) {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x2e);
						} else {
							MOD_PHYREG(pi, FemCtrl, femCtrlMask,
							           0x3ff);
						}
					}
				} else if (ACMAJORREV_2(pi->pubpi.phy_rev) ||
				           ACMAJORREV_5(pi->pubpi.phy_rev)) {
					if (pi->u.pi_acphy->srom.femctrl == 10) {
						wlc_phy_set_mask_for_femctrl10(pi);
					} else {
						MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3ff);
					}
				} else if (TINY_RADIO(pi)) {
					MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3ff);
				}
			}
			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				write_radio_reg(pi, RF_2069_TXGM_LOFT_SCALE(0), 0x0);
				if (pi->u.pi_acphy->srom.dac_spur_improve == 1) {
					write_radio_reg(pi, RFX_2069_ADC_CFG5, 0x83e3);
				}
			}
		} else { /* When WLAN is in 2G, BT controls should be allowed to go through */
			/* BT should also be able to control FEM Control Table */
			if (!BCM43602_CHIP(pi->sh->chip) || pi_ac->srom.bt_coex) {
				if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
					BFL2_BT_SHARE_ANT0) {
					MOD_PHYREG(pi, FemCtrl, enBtSignalsToFEMLut, 0x1);
				} else {
					MOD_PHYREG(pi, FemCtrl, enBtSignalsToFEMLut, 0x0);
				}
			}
			if (pi->u.pi_acphy->srom.femctrlmask_2g == 0) {
				MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3ff);
			} else {
				MOD_PHYREG(pi, FemCtrl, femCtrlMask,
					pi->u.pi_acphy->srom.femctrlmask_2g);
			}
			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				write_radio_reg(pi, RF_2069_TXGM_LOFT_SCALE(0), 0xa);
				if (pi->u.pi_acphy->srom.dac_spur_improve == 1) {
					write_radio_reg(pi, RFX_2069_ADC_CFG5, 0x83e0);
				}
			}
		}
	}

	/* 20691 specific processing, if needed */
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_set_regtbl_on_band_change_acphy_20691(pi);
	else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
		wlc_phy_set_regtbl_on_band_change_acphy_20693(pi);

	/* set up tssi loopback path */
	wlc_phy_tssi_phy_setup_acphy(pi, 0);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 0);
	else
		wlc_phy_tssi_radio_setup_acphy(pi, pi->sh->hw_phyrxchain, 0);

	/* 2g/5g band can have different aci modes */
	if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
#ifndef WLC_DISABLE_ACI
		hwaci_on = ((pi->sh->interference_mode & ACPHY_ACI_HWACI_PKTGAINLMT) != 0) ||
			((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0);
		wlc_phy_hwaci_setup_acphy(pi, hwaci_on, FALSE);
#endif /* !WLC_DISABLE_ACI  */
		w2_on = ((pi->sh->interference_mode & ACPHY_ACI_W2NB_PKTGAINLMT) != 0) ||
			((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0);
		wlc_phy_aci_w2nb_setup_acphy(pi, w2_on);
	}
	/* PAPD State copy */
	if (PHY_PAPDEN(pi)) {
#ifdef WLPAPDPARAMS_CACHE
		ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
		if (ctx)
			Cache_valid = ctx->valid;
		if (!Cache_valid) {
#endif /* WLPAPDPARAMS_CACHE */
			OSL_DELAY(100);
			if (TINY_RADIO(pi)) {
					wlc_phy_papd_set_rfpwrlut_tiny(pi);
				} else {
					wlc_phy_papd_set_rfpwrlut(pi);
				}
#ifdef WLPAPDPARAMS_CACHE
			}
#endif /* WLPAPDPARAMS_CACHE */
	}

	/* For 4350C0, bphy is turned off when in 5G. Need to disable the predetector. */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			MOD_PHYREG(pi, CRSMiscellaneousParam, bphy_pre_det_en, 0);
		} else {
		  /* Disable BPHY pre-detect JIRA:SWWLAN-45198 jammer/ACI performance
		   * takes a hit with predetector enabled
		   */
			MOD_PHYREG(pi, CRSMiscellaneousParam, bphy_pre_det_en, 0);
		}
	}

	/* need to zero out cal coeffs on band change */
	bzero(txcal_cache, sizeof(txcal_cache));
	wlc_phy_cal_coeffs_upd(pi, txcal_cache);

	if (pi_ac->ldo3p3_2g || pi_ac->ldo3p3_5g)
		wlc_acphy_paldo_change(pi);

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_set_mask_for_femctrl10(phy_info_t *pi)
{
	if (pi->u.pi_acphy->srom.femctrl_sub == 0) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x317);
	} else if (pi->u.pi_acphy->srom.femctrl_sub == 1) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x347);
	} else if (pi->u.pi_acphy->srom.femctrl_sub == 2) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x303);
	} else if (pi->u.pi_acphy->srom.femctrl_sub == 3) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x307);
	} else if (pi->u.pi_acphy->srom.femctrl_sub == 4) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x309);
	} else if (pi->u.pi_acphy->srom.femctrl_sub == 5) {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3c7);
	} else {
		MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3ff);
	}
}

static void
wlc_phy_set_regtbl_on_band_change_acphy_20691(phy_info_t *pi)
{
	tiny_adc_tuning_array_t gvalues;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* ### 20691_band_set(pi); */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		/* # Restore PHY control for Gband blocks which may have been switched
		 * off in Aband
		 */
		MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_biasadj, 4);
		MOD_RADIO_REG_20691(pi, LOGEN_OVR1, 0, ovr_logencore_2g_pu, 0);
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
		    ACPHY_REG_LIST_START
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_2G_OVR1, 0), 0)
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_2G_OVR2, 0), 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_gm2g_auxgm_pwrup, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_gm2g_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_rxmix2g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_lna2g_dig_wrssi1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_lna2g_lna1_pu, 0)
		    ACPHY_REG_LIST_EXECUTE(pi);
		} else {
		    ACPHY_REG_LIST_START
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_2G_OVR_EAST, 0), 0)
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0), 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0, ovr_gm2g_auxgm_pwrup,
				1)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0, ovr_gm2g_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0,
				ovr_lna2g_dig_wrssi1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_rxmix2g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_lna1_pu, 0)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}

		if (RADIO20691_MAJORREV(radio_rev) == 0) {
		    ACPHY_REG_LIST_START
			/* # missing bandsel in radio direct control */
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_gm2g_auxgm_pwrup, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG2, 0, gm2g_auxgm_pwrup, 0)

			/* # 5G LOgen */
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_5g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_5g_pu, 1)

			/* # force off 5g Tx */
			MOD_RADIO_REG_20691_ENTRY(pi, TX5G_CFG1, 0, tx5g_bias_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_tx5g_bias_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG4, 0, mx5g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_mx5g_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG4, 0, mx5g_pu_lodc_loop, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR2, 0, ovr_mx5g_pu_lodc_loop, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG1, 0, pa5g_bias_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_pa5g_bias_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG1, 0, pa5g_bias_cas_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR2, 0, ovr_pa5g_bias_cas_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG4, 0, pa5g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_pa5g_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, TRSW5G_CFG1, 0, trsw5g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_trsw5g_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0, logen5g_tx_enable_5g, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_logen5g_tx_enable_5g,
				1)

			MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0,
			                    logen5g_tx_enable_5g_low_band, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR2, 0,
			                    ovr_logen5g_tx_enable_5g_low_band, 1)

			/* # force off 5g Rx */
			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG1, 0, lna5g_lna1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_lna1_pu, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG2, 0, lna5g_pu_lna2, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_gm5g_pwrup, 1)

			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_RSSI1, 0, lna5g_dig_wrssi1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_dig_wrssi1_pu,
				1)

			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG2, 0, lna5g_pu_auxlna2, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_pu_auxlna2, 1)

			/* mixer pu */
			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG3, 0, mix5g_en, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_mix5g_en, 1)
		    ACPHY_REG_LIST_EXECUTE(pi);
	        } else {
			/* lna5g_pu_lna2 seems to get switched on during 5G band switch */
			MOD_RADIO_REG_20691(pi, LNA5G_CFG2, 0, lna5g_pu_lna2, 0);
		}

		/* # Misc */
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG2, 0, lpf_sel_5g_out_gm, 0);
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG3, 0, lpf_sel_2g_5g_cmref_gm, 0);

		if ((RADIO20691_MAJORREV(radio_rev) != 0) && !(PHY_IPA(pi))) {
			MOD_RADIO_REG_20691(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0x20);
		}

	} else {
		ACPHY_REG_LIST_START
			/* # clear 5g overrides */
			MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG8, 0, tia_offset_dac_biasadj, 12)
			/* MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_5g_pu, 0) */
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_5G_OVR1, 0), 0)
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, TX_TOP_5G_OVR2, 0), 0)
		ACPHY_REG_LIST_EXECUTE(pi);
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
		    ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_lna1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_gm5g_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_dig_wrssi1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_pu_auxlna2, 0)
		    ACPHY_REG_LIST_EXECUTE(pi);
		} else {
		    ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_gm5g_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_dig_wrssi1_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_pu_auxlna2, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG2, 0, lna5g_pu_auxlna2, 0)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}

		if (RADIO20691_MAJORREV(radio_rev) == 0) {
		    ACPHY_REG_LIST_START
			/* # missing bandsel in radio direct control */
			/* # force off 2g Tx */
			/* # 2G LOgen */
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_2g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG2, 0, gm2g_auxgm_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_gm2g_auxgm_pwrup, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG2, 0, gm2g_pwrup, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_gm2g_pwrup, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX2G_CFG1, 0, tx2g_bias_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_tx2g_bias_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG2, 0, mx2g_bias_en, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_mx2g_bias_en, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, PA2G_CFG1, 0, pa2g_bias_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_pa2g_bias_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, PA2G_CFG1, 0, pa2g_2gtx_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_pa2g_2gtx_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, PA2G_IDAC2, 0, pa2g_bias_cas_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_pa2g_bias_cas_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_trsw2g_bias_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_trsw2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN2G_CFG1, 0, logen2g_tx_pu_bias, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_logen2g_tx_pu_bias, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN2G_CFG1, 0, logen2g_tx_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR1, 0, ovr_logen2g_tx_pu, 1)

			/* # force off 2g Rx */
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_rxmix2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, RXMIX2G_CFG1, 0, rxmix2g_pu, 0)

			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_lna2g_dig_wrssi1_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_RSSI1, 0, lna2g_dig_wrssi1_pu, 0)

			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR1, 0, ovr_lna2g_lna1_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG1, 0, lna2g_lna1_pu, 0)
			/* # TC PU is incorrectly on lna1 - fixed in A0 */
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_lna5g_pu_auxlna2, 1)
			/* 20691_pad_gain 0xff 	# no pad gain direct control for rev 4 */
			WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, SPARE_CFG6, 0), 0xff)
			/* mixer pu */
			MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG3, 0, mix5g_en, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR1, 0, ovr_mix5g_en, 1)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}

		ACPHY_REG_LIST_START
		    /* to power up/down logen appropriately */
		    MOD_RADIO_REG_20691_ENTRY(pi, TX_LOGEN5G_CFG1, 0,
		        logen5g_tx_enable_5g_low_band, 0)
		    MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR2, 0,
		        ovr_logen5g_tx_enable_5g_low_band, 1)

		    /* # Restore PHY control for Gband blocks which may have been switched
		     * off in Aband
		     */
		    /* MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_5g_pu, 0) */

		    /* # Misc */
		    /* # There is no direct control for this */
		    MOD_RADIO_REG_20691_ENTRY(pi, TX_LPF_CFG2, 0, lpf_sel_5g_out_gm, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
		/* # There is no direct control for this */
		MOD_RADIO_REG_20691(pi, TX_LPF_CFG3, 0, lpf_sel_2g_5g_cmref_gm,
		                    (PHY_IPA(pi)) ? 1 : 0);

		if ((RADIO20691_MAJORREV(radio_rev) != 0) && !(PHY_IPA(pi))) {
		    ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0xb)
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG8, 0, pad5g_idac_gm, 0x18)
			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pad5g_idac_pmos, 0x34)
			MOD_RADIO_REG_20691_ENTRY(pi, TX5G_CFG1, 0, pad5g_slope_gm, 0xf)
			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_CFG3, 0, pa5g_ptat_slope_main, 0xf)
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG6, 0, mx5g_ptat_slope_lodc, 0x7)
			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pa5g_idac_incap_compen_main,
				0x2f)
		    ACPHY_REG_LIST_EXECUTE(pi);
		} else {
		    ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, TX5G_CFG1, 0, pad5g_slope_gm, 0x2)
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX5G_CFG6, 0, mx5g_ptat_slope_lodc, 0x3)
			MOD_RADIO_REG_20691_ENTRY(pi, TXGM5G_CFG1, 0, pad5g_idac_cascode, 0xf)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_EAST, 0, ovr_tx2g_bias_pu, 0x1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX2G_CFG1, 0, tx2g_bias_pu, 0x1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_LPF_CFG3, 0, lpf_sel_2g_5g_cmref_gm, 0x0)
			MOD_RADIO_REG_20691_ENTRY(pi, TXMIX2G_CFG6, 0, mx2g_idac_bbdc, 0xb)
			MOD_RADIO_REG_20691_ENTRY(pi, PA5G_INCAP, 0, pa5g_idac_incap_compen_main,
				0x1a)
			MOD_RADIO_REG_20691_ENTRY(pi, TXGM5G_CFG1, 0, pad5g_idac_cascode, 0x8)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}
	}
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* set gvalues [20691_sigdel_fast_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_fast_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues);
		/* 20691_adc_setup_fast $gvalues */
		wlc_20691_adc_setup_fast(pi, &gvalues);
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		/* set gvalues [20691_sigdel_slow1g2_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_slow1g2_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues);
		/* 20691_adc_setup_slow1g2 $gvalues */
		wlc_20691_adc_setup_slow1g2(pi, &gvalues);
	} else {
		/* set gvalues [20691_sigdel_slow0g6_tune $def(radio_rccal_adc_gmult)] */
		wlc_20691_sigdel_slow0g6_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues, 4096);
		/* 20691_adc_setup_slow0g6 $gvalues */
		wlc_20691_adc_setup_slow0g6(pi, &gvalues);
	}

	wlc_20691_tia_config(pi);

}

static void
wlc_phy_set_regtbl_on_bw_change_acphy(phy_info_t *pi)
{
	int sp_tx_bw = 0;
	uint8 stall_val, core, nbclip_cnt_4360 = 15;
	uint16 rfseq_bundle_adcrst48[3];
	uint16 rfseq_bundle_adcrst49[3];
	uint16 rfseq_bundle_adcrst50[3];
	uint32 epa_turnon_time;

	uint16 rfseq_bundle_adcdacoff51[3];

	uint8 rxevm20p[] = {8, 6, 4}, rxevm20n[] = {4, 6, 8};
	uint8 rxevm0[] = {0, 0, 0}, rxevm_len = 3;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (BW_RESET == 1)
		wlc_phy_set_reg_on_bw_change_acphy(pi);

	if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
		pi->sh->chippkg == BCM4335_FCBGA_PKG_ID)
		nbclip_cnt_4360 = 12;

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* 80mhz */
		if (ACMAJORREV_0(pi->pubpi.phy_rev))
			sp_tx_bw = 5;
		else
			sp_tx_bw = 6;

		nbclip_cnt_4360 *= 4;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		/* 40mhz */
		if (ACMAJORREV_0(pi->pubpi.phy_rev))
			sp_tx_bw = 4;
		else
			sp_tx_bw = 5;

		nbclip_cnt_4360 *= 2;
	} else if (CHSPEC_IS20(pi->radio_chanspec)) {
		/* 20mhz */
		if (ACMAJORREV_0(pi->pubpi.phy_rev))
			sp_tx_bw = 3;
		else
			sp_tx_bw = 5;
	} else {
		PHY_ERROR(("%s: No primary channel settings for bw=%d\n",
		           __FUNCTION__, CHSPEC_BW(pi->radio_chanspec)));
	}

	/* reduce NB clip CNT thresholds */
	FOREACH_CORE(pi, core) {
		if (!ACMAJORREV_1(pi->pubpi.phy_rev) ||
			(CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg_2g) ||
			(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom.agc_cfg_5g)) {
			MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh,
				nbclip_cnt_4360);
		} else {
			MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh, 23);
		}
	}

	wlc_phy_set_analog_tx_lpf(pi, 0x100, -1, sp_tx_bw, sp_tx_bw, -1, -1, -1);
	/* change the barelyclipgainbackoff to 6 for 80Mhz due to some PER issue for 4360A0 CHIP */
	if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
	  if (CHSPEC_IS80(pi->radio_chanspec)) {
	      ACPHYREG_BCAST(pi, Core0computeGainInfo, 0xcc0);
	  } else {
	      ACPHYREG_BCAST(pi, Core0computeGainInfo, 0xc60);
	  }
	}

	/* Enable FDSS */
	if (TINY_RADIO(pi) && ((CHSPEC_IS2G(pi->radio_chanspec) && (pi->fdss_level_2g[0] != -1)) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && (pi->fdss_level_5g[0] != -1))))  {
		wlc_phy_fdss_init(pi);
		wlc_phy_set_fdss_table(pi);
	}

	/* SWWLAN-28943 */
	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		MOD_PHYREGC(pi, computeGainInfo, 0, gainBackoffValue, 1);
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		FOREACH_CORE(pi, core) {
			/* Reduces 54Mbps humps */
			MOD_PHYREGC(pi, computeGainInfo, core, gainBackoffValue, 1);
		}
	}

	/* Shape rxevm table due to hit on near DC_tones */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			/* Freq Bins {1 2 3} = {8 6 4} dB */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVRXEVMSHAPINGTBL,
			                          rxevm_len, 1, 8, rxevm20p);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVRXEVMSHAPINGTBL,
			                          rxevm_len, 64 - rxevm_len, 8, rxevm20n);
		} else {
			/* Reset the 20mhz entries to 0 */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVRXEVMSHAPINGTBL,
			                          rxevm_len, 1, 8, rxevm0);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVRXEVMSHAPINGTBL,
			                          rxevm_len, 64 - rxevm_len, 8, rxevm0);
		}
	}

	/* JIRA (HW11ACRADIO-30) - clamp_en needs to be high for ~1us for clipped pkts (80mhz) */
	if (CHSPEC_IS80(pi->radio_chanspec) && !TINY_RADIO(pi)) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_clamp_en, 1);
			MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_clamp_en, 1);}

		/* FIXME: For now only 80mhz. Later enable it for 20/40 also. Issue iqadc reset
		   along with clamp_en as clamp_en is not enough to take adc out of oscillation
		   Replace sd_adc_assert/deassert with this bundle command for reseting the adc
		*/
		rfseq_bundle_adcrst48[2]  = 0;
		rfseq_bundle_adcrst49[2]  = 0;
		rfseq_bundle_adcrst50[2]  = 0;
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			rfseq_bundle_adcrst48[0] = 0xef52;
			rfseq_bundle_adcrst48[1] = 0x94;
			rfseq_bundle_adcrst49[0] = 0xef42;
			rfseq_bundle_adcrst49[1] = 0x84;
			rfseq_bundle_adcrst50[0] = 0xef52;
			rfseq_bundle_adcrst50[1] = 0x84;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			rfseq_bundle_adcrst48[0] = 0x4f52;
			rfseq_bundle_adcrst48[1] = 0x94;
			rfseq_bundle_adcrst49[0] = 0x4f42;
			rfseq_bundle_adcrst49[1] = 0x84;
			rfseq_bundle_adcrst50[0] = 0x4f52;
			rfseq_bundle_adcrst50[1] = 0x84;
		} else {
			rfseq_bundle_adcrst48[0] = 0x0fd2;
			rfseq_bundle_adcrst48[1] = 0x96;
			rfseq_bundle_adcrst49[0] = 0x0fc2;
			rfseq_bundle_adcrst49[1] = 0x86;
			rfseq_bundle_adcrst50[0] = 0x0fd2;
			rfseq_bundle_adcrst50[1] = 0x86;
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 48, 48,
		                          rfseq_bundle_adcrst48);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 49, 48,
		                          rfseq_bundle_adcrst49);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 50, 48,
		                          rfseq_bundle_adcrst50);
		/* reduce the adc reset time from 250ns to 50ns for 43602 as it caused CSTR failure
		* when ADC clips during clip gain
		*/
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			rf_updh_dly_adcrst[4] = 0x4;
			rf_updl_dly_adcrst[4] = 0x4;
		}
		/* updategainH : issue adc reset for 250ns */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x30, 16, rf_updh_cmd_adcrst);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xa0, 16, rf_updh_dly_adcrst);

		/* updategainL : issue adc reset for 250ns */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x40, 16, rf_updl_cmd_adcrst);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xb0, 16, rf_updl_dly_adcrst);

		/* updategainU : issue adc reset for 250n */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x50, 16, rf_updu_cmd_adcrst);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xc0, 16, rf_updu_dly_adcrst);
	} else {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			/* 4360A0 : SD-ADC was not monotonic for 1st revision, but is fixed now */
			if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
				MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_clamp_en, 0);
			} else {
				MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_clamp_en, 1);
			}
			MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_clamp_en, 1);
		}

		/* updategainH : increase clamp_en off delay to 16 */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x30, 16, rf_updh_cmd_clamp);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xa0, 16, rf_updh_dly_clamp);

		/* updategainL : increase clamp_en off delay to 16 */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x40, 16, rf_updl_cmd_clamp);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xb0, 16, rf_updl_dly_clamp);

		/* updategainU : increase clamp_en off delay to 16 */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0x50, 16, rf_updu_cmd_clamp);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 8, 0xc0, 16, rf_updu_dly_clamp);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi)) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
			    ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, nonpaydecodetimeoutlen, 1)
				MOD_PHYREG_ENTRY(pi, timeoutEn, resetCCAontimeout, 1)
				MOD_PHYREG_ENTRY(pi, timeoutEn, nonpaydecodetimeoutEn, 1)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else {
			    ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, nonpaydecodetimeoutlen, 32)
				MOD_PHYREG_ENTRY(pi, timeoutEn, resetCCAontimeout, 0)
				MOD_PHYREG_ENTRY(pi, timeoutEn, nonpaydecodetimeoutEn, 0)
			    ACPHY_REG_LIST_EXECUTE(pi);
			}
	}

	if (IS_X51A_BOARDTYPE(pi)) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			rfseq_bundle_adcdacoff51[0] = 0xe800;
			rfseq_bundle_adcdacoff51[1] = 0x84;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			rfseq_bundle_adcdacoff51[0] = 0x4800;
			rfseq_bundle_adcdacoff51[1] = 0x84;
		} else {
			rfseq_bundle_adcdacoff51[0] = 0x0800;
			rfseq_bundle_adcdacoff51[1] = 0x86;
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE, 1, 51, 48,
		                          rfseq_bundle_adcdacoff51);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x10, 16, rfseq_tx2rx_cmd);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x80, 16, rfseq_tx2rx_dly);
	}

	/* 4360, 4350. 4335 does its own stuff */
	if (!ACMAJORREV_1(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			/* reduce clip2 len, helps with humps due to late clip2 */
			WRITE_PHYREG(pi, defer_setClip1_CtrLen, 20);
			WRITE_PHYREG(pi, defer_setClip2_CtrLen, 16);
		} else {
			/* increase clip1 len. Needed for 20in80, 40in80 cases */
			WRITE_PHYREG(pi, defer_setClip1_CtrLen, 30);
			WRITE_PHYREG(pi, defer_setClip2_CtrLen, 20);
		}
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		(!(PHY_ILNA(pi))) && pi->sh->chippkg != BCM4335_FCBGA_PKG_ID) {
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			/* increase clip1 defer  len to make clip gain more accurate */
			/* decrease clip1 carrier blanking length to speedup crs */
			/* this is okay fror 80MHz as the settling is very fast for wider BW */
			ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, defer_setClip1_CtrLen, 36)
				WRITE_PHYREG_ENTRY(pi, defer_setClip2_CtrLen, 16)
				WRITE_PHYREG_ENTRY(pi, clip1carrierDetLen, 77)
				WRITE_PHYREG_ENTRY(pi, clip2carrierDetLen, 72)
			ACPHY_REG_LIST_EXECUTE(pi);
		} else {
		  /* increase defer setclip Gain by 0.1usec */
		  /* reduce clip1 carrier detect blanking by same amount */
		  /* reduce clip2 carrier detect blanking to speedup carrier detect */
		  /* this helps in cleaning the small floor in 4335C0 epa boards */
			ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, defer_setClip1_CtrLen, 28)
				WRITE_PHYREG_ENTRY(pi, defer_setClip2_CtrLen, 16)
				WRITE_PHYREG_ENTRY(pi, clip1carrierDetLen, 87)
				WRITE_PHYREG_ENTRY(pi, clip2carrierDetLen, 62)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		WRITE_PHYREG(pi, crsThreshold2u, 0x204d);
		WRITE_PHYREG(pi, crsThreshold2l, 0x204d);
		WRITE_PHYREG(pi, crsThreshold2lSub1, 0x204d);
		WRITE_PHYREG(pi, crsThreshold2uSub1, 0x204d);
	}

	if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* CRS. 6bit MF */
		/* BPHY pre-detect is disabled by default. No writes here. */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			WRITE_PHYREG(pi, crsThreshold2u, 0x2055);
			WRITE_PHYREG(pi, crsThreshold2l, 0x2055);
		} else {
			WRITE_PHYREG(pi, crsThreshold2u, 0x204d);
			WRITE_PHYREG(pi, crsThreshold2l, 0x204d);
		}
		WRITE_PHYREG(pi, crsThreshold2lSub1, 0x204d);
		WRITE_PHYREG(pi, crsThreshold2uSub1, 0x204d);

	}
	if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Spur canceller */
		if (CHSPEC_IS20(pi->radio_chanspec))
			WRITE_PHYREG(pi, spur_can_phy_bw_mhz, 0x14);
		else if (CHSPEC_IS40(pi->radio_chanspec))
			WRITE_PHYREG(pi, spur_can_phy_bw_mhz, 0x280);
		else
			WRITE_PHYREG(pi, spur_can_phy_bw_mhz, 0x50);
	}

	if (PHY_IPA(pi) && ACMAJORREV_2(pi->pubpi.phy_rev) &&
	    (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev))) {
		/* 4354a1_ipa, to decrease LOFT, move TSSI_CONFIG & extra delay before IPA_PU. Need
		   to move in TSSI_CONFIG, otherwise only delaying IPA_PU would delay TSSI_CONFIG
		   ;80MHz alone this change is backed out..
		*/
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			if (((CHSPEC_IS2G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->srom_tssisleep_en & 0x1)) ||
				((CHSPEC_IS5G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->srom_tssisleep_en & 0x4))) {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
						16, rfseq_rx2tx_cmd_rev15_ipa_withtssisleep);
			} else {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
				                 16, rfseq_rx2tx_cmd_rev15_ipa);
			}
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
			                         16, rfseq_rx2tx_dly_rev15_ipa20);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			if (((CHSPEC_IS2G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->srom_tssisleep_en & 0x2)) ||
				((CHSPEC_IS5G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->srom_tssisleep_en & 0x8))) {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
						16, rfseq_rx2tx_cmd_rev15_ipa_withtssisleep);
			} else {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
				                 16, rfseq_rx2tx_cmd_rev15_ipa);
			}
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
			                          16, rfseq_rx2tx_dly_rev15_ipa40);
		}
	}

	/* R8000 - atlas has different PA turn on timing */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		epa_turnon_time = (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		                   BFL_SROM11_EPA_TURNON_TIME) >> BFL_SROM11_EPA_TURNON_TIME_SHIFT;
		if (epa_turnon_time == 1) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
			                          16, rfseq_rx2tx_cmd);
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
				                          16, rfseq_rx2tx_dly_epa1_20);
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
				                          16, rfseq_rx2tx_dly_epa1_40);
			} else {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x70,
				                          16, rfseq_rx2tx_dly_epa1_80);
			}
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_set_aci_regs_acphy(phy_info_t *pi)
{
	uint16 aci_th;

	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Disable aci_absent, as it casues issues SOI pkts
		   to be missed when ACI is playing, eg channel 36 & 40, pwr = -40 dBm
		*/
		aci_th = 0x1ff;
	} else {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			aci_th = 0xbf;	/* 5GHz, 40/20MHz BW */
		} else {
			if (ACMAJORREV_1(pi->pubpi.phy_rev))
				aci_th = 0x80;
			else
				aci_th = 0xff;	/* 2.4GHz */
		}
	}

	WRITE_PHYREG(pi, crsacidetectThreshl, aci_th);
	WRITE_PHYREG(pi, crsacidetectThreshu, aci_th);
	WRITE_PHYREG(pi, crsacidetectThreshlSub1, aci_th);
	WRITE_PHYREG(pi, crsacidetectThreshuSub1, aci_th);

	if (0) {
		/* CRDOT11ACPHY-280 : enabled bphy aci det is causing hangs */
		if (CHSPEC_IS2G(pi->radio_chanspec) && CHSPEC_IS20(pi->radio_chanspec)) {
			/* Enable bphy ACI Detection HW */
			ACPHY_REG_LIST_START
				MOD_PHYREG_ENTRY(pi, RxControl, bphyacidetEn, 1)
				WRITE_PHYREG_ENTRY(pi, bphyaciThresh0, 0)
				WRITE_PHYREG_ENTRY(pi, bphyaciThresh1, 0)
				WRITE_PHYREG_ENTRY(pi, bphyaciThresh2, 0)
				WRITE_PHYREG_ENTRY(pi, bphyaciThresh3, 0x9F)
				WRITE_PHYREG_ENTRY(pi, bphyaciPwrThresh0, 0)
				WRITE_PHYREG_ENTRY(pi, bphyaciPwrThresh1, 0)
				WRITE_PHYREG_ENTRY(pi, bphyaciPwrThresh2, 0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}
}

/**
 * Tx IIR filter setup for 20MHz and CCK.
 */
static void
wlc_phy_set_tx_iir_coeffs(phy_info_t *pi, bool cck, uint8 filter_type)
{
	if (cck == FALSE) {
		if (filter_type == 0) {
			ACPHY_REG_LIST_START
				/* Default Chebyshev ~10.5MHz cutoff */
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0a1, 0x0056)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0a2, 0x02fb)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1a1, 0x0f3d)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1a2, 0x0169)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2a1, 0x0e23)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2a2, 0x0068)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2n, 0x0002)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20finescale, 0x00a6)
			ACPHY_REG_LIST_EXECUTE(pi);
		} else if (filter_type == 1) {
			ACPHY_REG_LIST_START
				 /* Chebyshev ~8.8MHz cutoff (FCC -26dBr BW) */
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0a1, 0x0e73)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0a2, 0x033d)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st0n, 0x0002)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1a1, 0x0d5f)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1a2, 0x0205)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2a1, 0x0c39)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2a2, 0x011e)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20st2n, 0x0002)
				WRITE_PHYREG_ENTRY(pi, txfilt20in20finescale, 0x001a)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	         /* Default filters */
	} else {
		/* Tx filters in PHY REV 3, PHY REV 6 and later operate at 1/2 the sampling
		 * rate of previous revs
		 */
		if ((ACMAJORREV_0(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
		                                         ACMINORREV_1(pi->pubpi.phy_rev))) ||
		    (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
		                                         ACMINORREV_1(pi->pubpi.phy_rev))) ||
		    (ACMAJORREV_3(pi->pubpi.phy_rev))) {
			if (filter_type == 0) {
			    ACPHY_REG_LIST_START
				/* Default filter */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0a94)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x0373)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0005)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0a93)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0298)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0004)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0a52)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x021d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0004)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0080)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 1) {
			    ACPHY_REG_LIST_START
				/* Gaussian  shaping filter */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0b54)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x0290)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0004)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0a40)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0290)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0005)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0a06)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x0240)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0005)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0080)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 4) {
				if (pi->u.pi_acphy->dac_mode == 1) {
				    ACPHY_REG_LIST_START
					/* Gaussian shaping filter for TINY_A0, dac_rate_mode 1 */
					/* peak evm -11dB, 28% */
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, -80)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 369)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, -757)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 369)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, -1007)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 256)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 120)
				    ACPHY_REG_LIST_EXECUTE(pi);
				} else if (pi->u.pi_acphy->dac_mode == 2) {
				    ACPHY_REG_LIST_START
					/* Gaussian shaping filter for TINY_A0, dac_rate_mode 2 */
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st0a1, -1852)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st0a2, 892)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st0n, 7)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st1a1, -1890)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st1a2, 892)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st1n, 7)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st2a1, -1877)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st2a2, 860)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80st2n, 7)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in80finescale, 65)
				    ACPHY_REG_LIST_EXECUTE(pi);
				} else {
				    ACPHY_REG_LIST_START
					/* Gaussian shaping filter for TINY_A0, dac_rate_mode 3 */
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st0a1, -1714)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st0a2, 829)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st0n, 6)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st1a1, -1796)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st1a2, 829)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st1n, 6)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st2a1, -1790)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st2a2, 784)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40st2n, 6)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in40finescale, 54)
				    ACPHY_REG_LIST_EXECUTE(pi);
				}
			} else if (filter_type == 5) {
				if (pi->u.pi_acphy->dac_mode == 1) {
				    ACPHY_REG_LIST_START
					/* Gaussian shaping filter for TINY_B1, dac_rate_mode 1 */
					/* peak evm -12dB, 25% */
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, -184)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 369)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, -600)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 369)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, -1007)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 256)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 3)
					WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 128)
				    ACPHY_REG_LIST_EXECUTE(pi);
				}
			}
		} else if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
			ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			if (filter_type == 0) {
			    ACPHY_REG_LIST_START
				/* Default filter */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0f6b)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x0339)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0e29)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x01e5)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0002)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0cb2)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00f0)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x00b3)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 1) {
			    ACPHY_REG_LIST_START
				/* Gaussian shaping filter (-0.5 dB Tx Power) */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0edb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x01cb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0d1d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0192)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0c33)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00f3)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0076)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 2) {
			    ACPHY_REG_LIST_START
				/* Tweaked Gaussian for 4335 iPA CCk margin */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0edb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x01ab)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0d1d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0172)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0c77)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00a9)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0082)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 3) {
			   ACPHY_REG_LIST_START
				/* Tweaked Gaussian for 4356 iPA CCK EVM margin: */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0edb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x01ab)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0d1d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0172)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0c77)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00df)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0082)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 4) {
			   ACPHY_REG_LIST_START
				/* Tweaked Gaussian for 4356 iPA CCK EVM/ACPR margin: */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0edb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x01ab)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0d1d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0172)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0c77)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00b0)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0082)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 5) {
			   ACPHY_REG_LIST_START
				/* Tweaked Gaussian for 4356 iPA CCK ACPR margin: */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0edb)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x01ab)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0d1d)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x0155)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0c77)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00b0)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x0082)
			    ACPHY_REG_LIST_EXECUTE(pi);
			}
		} else {
			if (filter_type == 0) {
			    ACPHY_REG_LIST_START
				/* Default filter */
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a1, 0x0f6b)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0a2, 0x0339)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st0n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a1, 0x0e29)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1a2, 0x01e5)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st1n, 0x0002)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a1, 0x0cb2)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2a2, 0x00f0)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20st2n, 0x0003)
				WRITE_PHYREG_ENTRY(pi, txfiltbphy20in20finescale, 0x00b3)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (filter_type == 1) {
				/* TBD */
			}
		}
	}
}

#if defined(AP) && defined(RADAR)
/**
 * Tx IIR filter setup for 80MHz.
 */
static void
wlc_phy_set_tx80_iir_coeffs(phy_info_t *pi, uint8 filter_type)
{
	if (filter_type == 0) {
		ACPHY_REG_LIST_START
			/* Default ofdm80 filter (Chebby type I, fc 38.248MHz,
			   ripple 0.5 dB).
			 */
			WRITE_PHYREG_ENTRY(pi, txfilt80st0a1, 0x0f93)
			WRITE_PHYREG_ENTRY(pi, txfilt80st0a2, 0x036e)
			WRITE_PHYREG_ENTRY(pi, txfilt80st0n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1a1, 0x0df7)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1a2, 0x0257)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2a1, 0x0be2)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2a2, 0x016c)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80finescale, 0x008d)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else if (filter_type == 1) {
		ACPHY_REG_LIST_START
			/* Default filter reduced by 1 MHz (fc 37.248MHz, ripple 0.5 dB).
			   Used for reducing occupied Tx bandwidth in 80MHz.
			   Filter is damaging Tx performance, but it needs to be used
			   on DFS channels to detect radar at 99% OBW on chips where
			   listening Rx filter cannot be widened (43569, 43602).
			*/
			WRITE_PHYREG_ENTRY(pi, txfilt80st0a1, 0x0f48)
			WRITE_PHYREG_ENTRY(pi, txfilt80st0a2, 0x036f)
			WRITE_PHYREG_ENTRY(pi, txfilt80st0n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1a1, 0x0dbd)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1a2, 0x025c)
			WRITE_PHYREG_ENTRY(pi, txfilt80st1n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2a1, 0x0bc1)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2a2, 0x0179)
			WRITE_PHYREG_ENTRY(pi, txfilt80st2n,  0x3)
			WRITE_PHYREG_ENTRY(pi, txfilt80finescale, 0x007a)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
}

/**
 * WAR to meet FCC DFS requirement to pass 99% OBW radar detection.
 */
void
wlc_phy_radar_detect_iir_war_acphy(phy_info_t *pi)
{
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* Setup 80MHz Tx IIR filter */
		if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
			RADIOREV(pi->pubpi.radiorev) == 0x2C &&
			PHY_XTAL_IS40M(pi)) ||
			ACMAJORREV_5(pi->pubpi.phy_rev)) {
			/* 43569 / 43570 / 43602 */
			if ((pi->sh->radar) &&
				(CHANNEL_ISRADAR(CHSPEC_CHANNEL(pi->radio_chanspec)))) {
				/* Set narrow Tx IIR filter only if we are on the DFS channel and
				   radar detection is enabled.
				   WAR to meet FCC DFS requirement to pass 99% OBW radar
				   detection.
				 */
				wlc_phy_set_tx80_iir_coeffs(pi, 1);
			} else {
				/* Load default 80MHz IIR filter */
				wlc_phy_set_tx80_iir_coeffs(pi, 0);
			}
		}
	}
}
#endif /* defined(AP) && defined(RADAR) */

static void
wlc_phy_set_regtbl_on_chan_change_acphy(phy_info_t *pi, const void *chan_info)
{
	uint16 fc;
	uint32 rx_afediv_sel, tx_afediv_sel;
	uint32 read_val[2], write_val[2];
	bool suspend;
	uint8 stall_val, orig_rxfectrl1;
	uint8 bphy_testmode_val;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	ASSERT(chan_info != NULL);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !PHY_IPA(pi))
		MOD_PHYREG(pi, Logen_AfeDiv_reset_select, use_hw_afeclk_reset, 0x0);

	/* Setup the Tx/Rx Farrow resampler */
	if (TINY_RADIO(pi))
		wlc_phy_farrow_setup_tiny(pi, pi->radio_chanspec);
	else
		wlc_phy_farrow_setup_acphy(pi, pi->radio_chanspec);

	/* Load Pdet related settings */
	wlc_phy_set_pdet_on_reset_acphy(pi);

	fc = ((const chan_info_common_t *)chan_info)->freq;

	/* 4350A0 radio */
	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	    RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 &&
	    !(ISSIM_ENAB(pi->sh->sih))) {
		suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
		if (!suspend)
			wlapi_suspend_mac_and_wait(pi->sh->physhim);

		/* Disable stalls and hold FIFOs in reset */
		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		orig_rxfectrl1 = READ_PHYREGFLD(pi, RxFeCtrl1, soft_sdfeFifoReset);

		ACPHY_DISABLE_STALL(pi);
		MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 1);

		/* AFE clk and Harmonic of 40 MHz crystal causes a spur at 417 Khz */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			if ((pi_ac->srom_txnospurmod2g == 0) && (CHSPEC_IS2G(pi->radio_chanspec)) &&
				(!PHY_IPA(pi) ||
				/* SWWLAN-50654 */
				(pi->sh->boardtype == BCM94354USICOBRA && fc == 2412))) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 6, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x2 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 0, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x2 << 14);
			} else if ((CHSPEC_IS2G(pi->radio_chanspec) &&
				((fc != 2412 && fc != 2467) || (PHY_XTAL_IS40M(pi)) ||
				(ACMAJORREV_2(pi->pubpi.phy_rev) &&
				(ACMINORREV_1(pi->pubpi.phy_rev) ||
				ACMINORREV_3(pi->pubpi.phy_rev)) &&
				PHY_XTAL_IS37M4(pi) && PHY_ILNA(pi) &&
				(RADIOREV(pi->pubpi.radiorev) == 0x27)))) ||
				(fc == 5745) || (fc == 5765) || (fc == 5825 && !PHY_IPA(pi)) ||
				((fc == 5180) && ((((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
				(pi->sh->chippkg == 2)) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 7) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 9) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 8) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 12) ||
				(RADIOMINORREV(pi->pubpi.radiominorrev) == 14)) &&
				(PHY_XTAL_IS37M4(pi)))) {
			    /* if AFE divider of 8 is used for 20 MHz channel 149,153,
			     * or any channel in 2GHz when xtalfreq=40MHz,
			     * or any 2Ghz channel except 2467 when xtalfreq=37.4MHz
			     * so change divider ratio to 9
			     */
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 6, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x4 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 0, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x4 << 14);
			} else {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 6, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x3 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 0, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x3 << 14);
			}
			if ((((fc == 5180) && (pi->sh->chippkg != 2)) ||
			     ((fc >= 5200) && (fc <= 5320)) ||
			     ((fc >= 5745) && (fc <= 5825))) &&
			    !PHY_IPA(pi)) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 6, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x7 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 0, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x7 << 14);
			}
			/* RX_SD_ADC_PU_VAL bw20 */
			write_val[0] = ((rx_afediv_sel & 0xfff) << 20) | rx_afediv_sel;
			write_val[1] = (rx_afediv_sel << 8) | (rx_afediv_sel >> 12);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 6, 60,
			                          write_val);
			/* bw20_HighspeedMode1 */
			write_val[0] = ((tx_afediv_sel & 0xfff) << 20) | tx_afediv_sel;
			write_val[1] = (tx_afediv_sel << 8) | (tx_afediv_sel >> 12);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 0, 60,
			                          write_val);
			wlc_phy_force_rfseq_noLoleakage_acphy(pi);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			/* if AFE divider of 4 is used for 40 MHz channel 151m,
			 * so change divider ratio to 4.5
			 */
			if (CHSPEC_IS5G(pi->radio_chanspec) &&
			    !PHY_IPA(pi) && (fc != 5190)) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 7, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x7 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 1, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x7 << 14);

			} else if ((CHSPEC_IS2G(pi->radio_chanspec)) || (fc == 5755) ||
				(fc == 5550 && PHY_XTAL_IS40M(pi)) ||
				(fc == 5190 && PHY_XTAL_IS37M4(pi) && !PHY_IPA(pi)) ||
				(fc == 5310 && PHY_XTAL_IS37M4(pi) && PHY_IPA(pi))) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 7, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x2 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 1, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x2 << 14);
			} else {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 7, 60,
				                         &read_val);
				rx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x1 << 14);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 1, 60,
				                         &read_val);
				tx_afediv_sel = (read_val[0] & ~(0x7 << 14) & 0xfffff) |
				        (0x1 << 14);
			}
			/* RX_SD_ADC_PU_VAL bw40 */
			write_val[0] = ((rx_afediv_sel & 0xfff) << 20) | rx_afediv_sel;
			write_val[1] = (rx_afediv_sel << 8) | (rx_afediv_sel >> 12);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 7, 60,
			                          write_val);
			/* bw40_HighspeedMode1 */
			write_val[0] = ((tx_afediv_sel & 0xfff) << 20) | tx_afediv_sel;
			write_val[1] = (tx_afediv_sel << 8) | (tx_afediv_sel >> 12);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQEXT, 1, 1, 60,
			                          write_val);
			wlc_phy_force_rfseq_noLoleakage_acphy(pi);
		}
		if (!suspend)
			wlapi_enable_mac(pi->sh->physhim);

		/* Restore FIFO reset and Stalls */
		ACPHY_ENABLE_STALL(pi, stall_val);
		MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, orig_rxfectrl1);
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		const chan_info_radio2069revGE32_t *ciGE32 = chan_info;

		WRITE_PHYREG(pi, BW1a, ciGE32->PHY_BW1a);
		WRITE_PHYREG(pi, BW2, ciGE32->PHY_BW2);
		WRITE_PHYREG(pi, BW3, ciGE32->PHY_BW3);
		WRITE_PHYREG(pi, BW4, ciGE32->PHY_BW4);
		WRITE_PHYREG(pi, BW5, ciGE32->PHY_BW5);
		WRITE_PHYREG(pi, BW6, ciGE32->PHY_BW6);
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		if ((RADIOREV(pi->pubpi.radiorev) != 25) && (RADIOREV(pi->pubpi.radiorev) != 26)) {
			const chan_info_radio2069revGE16_t *ciGE16 = chan_info;

			WRITE_PHYREG(pi, BW1a, ciGE16->PHY_BW1a);
			WRITE_PHYREG(pi, BW2, ciGE16->PHY_BW2);
			WRITE_PHYREG(pi, BW3, ciGE16->PHY_BW3);
			WRITE_PHYREG(pi, BW4, ciGE16->PHY_BW4);
			WRITE_PHYREG(pi, BW5, ciGE16->PHY_BW5);
			WRITE_PHYREG(pi, BW6, ciGE16->PHY_BW6);
		} else {
			if (!PHY_XTAL_IS52M(pi)) {
				const chan_info_radio2069revGE25_t *ciGE25 = chan_info;

				WRITE_PHYREG(pi, BW1a, ciGE25->PHY_BW1a);
				WRITE_PHYREG(pi, BW2, ciGE25->PHY_BW2);
				WRITE_PHYREG(pi, BW3, ciGE25->PHY_BW3);
				WRITE_PHYREG(pi, BW4, ciGE25->PHY_BW4);
				WRITE_PHYREG(pi, BW5, ciGE25->PHY_BW5);
				WRITE_PHYREG(pi, BW6, ciGE25->PHY_BW6);
			} else {
				const chan_info_radio2069revGE25_52MHz_t *ciGE25 = chan_info;

				WRITE_PHYREG(pi, BW1a, ciGE25->PHY_BW1a);
				WRITE_PHYREG(pi, BW2, ciGE25->PHY_BW2);
				WRITE_PHYREG(pi, BW3, ciGE25->PHY_BW3);
				WRITE_PHYREG(pi, BW4, ciGE25->PHY_BW4);
				WRITE_PHYREG(pi, BW5, ciGE25->PHY_BW5);
				WRITE_PHYREG(pi, BW6, ciGE25->PHY_BW6);
			}
		}
	} else {
		if (TINY_RADIO(pi)) {
			const chan_info_radio20691_t *ci20691 = chan_info;

			/* set SFO parameters */
			WRITE_PHYREG(pi, BW1a, ci20691->PHY_BW1a);
			WRITE_PHYREG(pi, BW2, ci20691->PHY_BW2);
			WRITE_PHYREG(pi, BW3, ci20691->PHY_BW3);
			/* Set sfo_chan_center_factor */
			WRITE_PHYREG(pi, BW4, ci20691->PHY_BW4);
			WRITE_PHYREG(pi, BW5, ci20691->PHY_BW5);
			WRITE_PHYREG(pi, BW6, ci20691->PHY_BW6);
		} else {
			const chan_info_radio2069_t *ci = chan_info;

			/**** set SFO parameters ****
			 * sfo_chan_center_Ts20 = round([fc-10e6 fc fc+10e6] / 20e6 * 8), fc in Hz
			 *                      = round([$channel-10 $channel $channel+10] * 0.4),
			 *                              $channel in MHz
			 */
			WRITE_PHYREG(pi, BW1a, ci->PHY_BW1a);
			WRITE_PHYREG(pi, BW2, ci->PHY_BW2);
			WRITE_PHYREG(pi, BW3, ci->PHY_BW3);

			/* sfo_chan_center_factor = round(2^17./([fc-10e6 fc fc+10e6]/20e6))
			 * fc in Hz
			 *  = round(2621440./[$channel-10 $channel $channel+10]),
			 *    $channel in MHz
			 */
			WRITE_PHYREG(pi, BW4, ci->PHY_BW4);
			WRITE_PHYREG(pi, BW5, ci->PHY_BW5);
			WRITE_PHYREG(pi, BW6, ci->PHY_BW6);
		}
	}
	/* Set the correct primary channel */
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* 80mhz */
		if (CHSPEC_CTL_SB(pi->radio_chanspec) == WL_CHANSPEC_CTL_SB_LL) {
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 0);
		} else if (CHSPEC_CTL_SB(pi->radio_chanspec) == WL_CHANSPEC_CTL_SB_LU) {
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 1);
		} else if (CHSPEC_CTL_SB(pi->radio_chanspec) == WL_CHANSPEC_CTL_SB_UL) {
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 2);
		} else if (CHSPEC_CTL_SB(pi->radio_chanspec) == WL_CHANSPEC_CTL_SB_UU) {
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 3);
		} else {
			PHY_ERROR(("%s: No primary channel settings for CTL_SB=%d\n",
			           __FUNCTION__, CHSPEC_CTL_SB(pi->radio_chanspec)));
		}
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		/* 40mhz */
		if (CHSPEC_SB_UPPER(pi->radio_chanspec)) {
			MOD_PHYREG(pi, RxControl, bphy_band_sel, 1);
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 1);
		} else {
			MOD_PHYREG(pi, RxControl, bphy_band_sel, 0);
			MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 0);
		}
	} else if (CHSPEC_IS20(pi->radio_chanspec)) {
		/* 20mhz */
		MOD_PHYREG(pi, RxControl, bphy_band_sel, 0);
		MOD_PHYREG(pi, ClassifierCtrl2, prim_sel, 0);
	} else {
		PHY_ERROR(("%s: No primary channel settings for bw=%d\n",
		           __FUNCTION__, CHSPEC_BW(pi->radio_chanspec)));
	}

	/* set aci thresholds */
	wlc_phy_set_aci_regs_acphy(pi);

	bzero((uint8 *)pi->u.pi_acphy->phy_noise_all_core,
	      sizeof(pi->u.pi_acphy->phy_noise_all_core));
	bzero((uint8 *)pi->u.pi_acphy->phy_noise_in_crs_min,
	      sizeof(pi->u.pi_acphy->phy_noise_in_crs_min));
	bzero((uint8 *)pi->u.pi_acphy->phy_noise_pwr_array,
	      sizeof(pi->u.pi_acphy->phy_noise_pwr_array));

	/* Debug parameters: printed by 'wl dump phycal' */
	pi->u.pi_acphy->phy_debug_crscal_counter = 0;
	pi->u.pi_acphy->phy_noise_counter = 0;

	/* set the crsmin_th from cache at chan_change */
	wlc_phy_crs_min_pwr_cal_acphy(pi, PHY_CRS_SET_FROM_CACHE);

	/* making IIR filter gaussian like for BPHY to improve ACPR */

	/* set RRC filter alpha
	 FiltSel2 is 11 bit which msb, bphyTest's 6th bit is lsb
	 These 2 bits control alpha
	 bits 11 & 6    Resulting filter
	  -----------    ----------------
	      00         alpha=0.35 - default
	      01         alpha=0.75 - alternate
	      10         alpha=0.2  - for use in Japan on channel 14
	      11         no TX filter
	*/
	if (fc == 2484) {
		bphy_testmode_val = (0x3F & READ_PHYREGFLD(pi, bphyTest, testMode));
		MOD_PHYREG(pi, bphyTest, testMode, bphy_testmode_val);
		MOD_PHYREG(pi, bphyTest, FiltSel2, 1);
		/* Load default CCK filter */
		wlc_phy_set_tx_iir_coeffs(pi, 1, 0);
		/* Load default OFDM filter */
		if (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
			wlc_phy_set_tx_iir_coeffs(pi, 0, 0);
		}

	} else {
		if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, bphyTest, FiltSel2, 0);
			if (PHY_IPA(pi)) {
				/* CCK */
				wlc_phy_set_tx_iir_coeffs(pi, 1,
					(pi->u.pi_acphy->acphy_cck_dig_filt_type & 0x7));

				/* OFDM : FCC -26dBr BW channels */
				if (((RADIOREV(pi->pubpi.radiorev) == 0x2C ||
					RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
					(PHY_XTAL_IS40M(pi)) && (fc == 2472)) ||
					((RADIOREV(pi->pubpi.radiorev) == 0x29) &&
					(PHY_XTAL_IS37M4(pi))&& (fc == 2472) &&
					PHY_ILNA(pi))) {
					/* Narrow IIR filter for bandedge */
					wlc_phy_set_tx_iir_coeffs(pi, 0, 1);
				} else if ((fc == 5240) || (fc == 5260) || (fc == 5580) ||
				    (fc == 5660)) {
					wlc_phy_set_tx_iir_coeffs(pi, 0, pi->sh->ofdmfilttype);
				} else { /* OFDM default */
					wlc_phy_set_tx_iir_coeffs(pi, 0, 0);
				}
			} else {
				wlc_phy_set_tx_iir_coeffs(pi, 1, 1);
			}
		} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, bphyTest, testMode, 0);
			MOD_PHYREG(pi, bphyTest, FiltSel2, 0);
			if (pi->u.pi_acphy->acphy_cck_dig_filt_type == -1) {
				if (RADIO20691_MAJORREV(radio_rev) == 0) {
					wlc_phy_set_tx_iir_coeffs(pi, 1, 1);
				} else {
					wlc_phy_set_tx_iir_coeffs(pi, 1, 5);
				}
			} else {
				/* control through nvram file params */
				wlc_phy_set_tx_iir_coeffs(pi, 1,
					pi->u.pi_acphy->acphy_cck_dig_filt_type);
			}
		} else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, bphyTest, FiltSel2, 0);
			if (PHY_IPA(pi)) {
				wlc_phy_set_tx_iir_coeffs(pi, 1, 2);
			} else {
				wlc_phy_set_tx_iir_coeffs(pi, 1, 1);
			}
		} else {
			bphy_testmode_val = (0x3F & READ_PHYREGFLD(pi, bphyTest, testMode));
			bphy_testmode_val = bphy_testmode_val |
				((pi->u.pi_acphy->acphy_cck_dig_filt_type & 0x2)  << 5);
			MOD_PHYREG(pi, bphyTest, testMode, bphy_testmode_val);
			MOD_PHYREG(pi, bphyTest, FiltSel2,
				((pi->u.pi_acphy->acphy_cck_dig_filt_type & 0x4) >> 2));
			/* Load filter with Gaussian shaping */
			wlc_phy_set_tx_iir_coeffs(pi, 1,
				(pi->u.pi_acphy->acphy_cck_dig_filt_type & 0x1));
		}
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
			MOD_PHYREG(pi, bphyTest, testMode, 0);
			MOD_PHYREG(pi, bphyTest, FiltSel2, 0);
			wlc_phy_set_tx_iir_coeffs(pi, 1,
				(pi->u.pi_acphy->acphy_cck_dig_filt_type & 0xF));
		}
	}

#if defined(AP) && defined(RADAR)
	/* WAR to meet FCC DFS requirement to pass 99% OBW radar detection. */
	wlc_phy_radar_detect_iir_war_acphy(pi);
#endif // endif

	/* if it's 2x2 or 3x3 design, populate the reciprocity compensation coeff */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))
		wlc_phy_populate_recipcoeffs_acphy(pi);
#ifndef MACOSX
	/* XXX FIXME: SWWLAN-31395 causes long channel switch times for 4360
	 * So disable implicit TXBF for 4360 for Macos for now
	 */
	if (ACMAJORREV_0(pi->pubpi.phy_rev))
		wlc_phy_populate_recipcoeffs_acphy(pi);
#endif /* MACOSX */

	/* 4335c0 wlipa 2GHz xtal spur war */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		PHY_ILNA(pi) && !PHY_XTAL_IS40M(pi)) {
	    ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_outbufBBstrg, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufBBstrg, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufcalstrg, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_bufstrg_BT, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_xtbufstrg, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_xtbufstrg, 7)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_outbufstrg, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufstrg, 3)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* 4354 wlipa 2GHz xtal spur war */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev) &&
		PHY_ILNA(pi) && (!PHY_XTAL_IS40M(pi))) {
	    ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL2, xtal_pu_RCCAL1, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_outbufBBstrg, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufBBstrg, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufcalstrg, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_outbufstrg, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufstrg, 2)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_sel_BT, 1)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_bufstrg_BT, 2)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* 43602 XTAL SPUR 2G WAR */
	if (ACMAJORREV_5(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_xtbufstrg, 0x3);
		MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_outbufstrg, 0x2);
	}

	if (pi_ac->srom.femctrl == 3) {
		if (fc == 5180 || fc == 5190 || fc == 5310 ||
				fc == 5320 || fc == 5500 || fc == 5510) {
			MOD_RADIO_REG(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xA0);
		}
		if (ACMAJORREV_5(pi->pubpi.phy_rev) && fc == 5220) {
			MOD_RADIO_REG(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xC0);
		}
	}
	if (pi_ac->srom.xtal_spur_suppress) {
		if (fc == 5765 || fc == 5785 || fc == 5805 || fc == 5825 || fc == 5795) {
			MOD_RADIO_REG(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xE0);
		} else if (fc == 5755) {
			MOD_RADIO_REG(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xC0);
		}
	}

}

static void
wlc_phy_write_femctrl_table(phy_info_t *pi)
{
	int core;
	acphy_fe_ctrl_table_t *p;

	FOREACH_CORE(pi, core) {
		p = &pi->u.pi_acphy->fectrl_c[core];
		if (p->subtable != NULL) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, p->n_entries,
				p->hw_offset, 8, p->subtable);
		} else {
			PHY_ERROR(("wl%d: %s: Undefined FEM Control table C%d. Radio revision %d\n",
				pi->sh->unit, __FUNCTION__, core, RADIOREV(pi->pubpi.radiorev)));
			ASSERT(0);
		}
	}
}

static INLINE void
wlc_phy_write_sparse_femctrl_table(phy_info_t *pi)
{
	uint16 fectrl_zeroval[] = {0};
	uint16 fectrl_fourval[] = {4};
	uint16 fectrl_nineval[] = {9};
	uint kk, fem_idx = 0;
	for (kk = 0; kk < pi->u.pi_acphy->fectrl_table_len; kk++) {
		if (fem_idx < pi->u.pi_acphy->fectrl_sparse_table_len &&
			kk == pi->u.pi_acphy->fectrl_idx[fem_idx]) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, kk, 16,
			&(pi->u.pi_acphy->fectrl_val[fem_idx]));
			fem_idx++;
		} else if (pi->u.pi_acphy->fectrl_spl_entry_flag) {
			/* 43162: Fix to avoid all zero output from femctrl during */
			/* tx2rx/rx2tx in 5G which causes popping-sound in BT */
			/* tx2rx/rx2tx in 2G also cause zero state on FEM, add lines for safety */
			if (kk & 0x10) {
				/* 5G */
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, kk, 16,
					fectrl_fourval);
			} else {
				/* 2G */
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, kk, 16,
					fectrl_nineval);
			}
		} else {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, kk, 16,
				fectrl_zeroval);
		}
	}

}

static bool
BCMATTACHFN(wlc_phy_attach_femctrl_table)(phy_info_t *pi)
{
	const uint16 *fectrl_idx = NULL, *fectrl_val = NULL;
	const uint8 *fectrl_c[3] = {NULL, NULL, NULL};
	uint16 table_len = 0, sparse_table_len = 0;
	const sparse_array_entry_t *fe_ctrl_tbl;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint16 kk;
	int core;
	acphy_fe_ctrl_table_t *p_core; /* FEM control data per core for non-sparse tables */

	pi->u.pi_acphy->fectrl_idx = NULL;
	pi->u.pi_acphy->fectrl_val = NULL;
	pi->u.pi_acphy->fectrl_table_len = 0;
	pi->u.pi_acphy->fectrl_sparse_table_len = 0;
	pi->u.pi_acphy->fectrl_spl_entry_flag = 0;

	/* majorrev0 chips don't use sparse tables: they have their entire femctrl table */
	FOREACH_CORE(pi, core) {
		pi->u.pi_acphy->fectrl_c[core].subtable = NULL;
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		table_len = 256;
	} else if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		const uint32 n_entries_4360[] =  {32, 32, 32};
		const uint32 hw_offset_4360[] =  {0,  32, 64};
		const uint32 n_entries_43602[] = {256, 64, 64};
		const uint32 hw_offset_43602[] = {0, 256, 512};
		const uint32 *n_entries;
		const uint32 *hw_offset;

		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			n_entries = n_entries_43602;
			hw_offset = hw_offset_43602;
		} else {
			n_entries = n_entries_4360;
			hw_offset = hw_offset_4360;
		}

		FOREACH_CORE(pi, core) {
			p_core = &pi->u.pi_acphy->fectrl_c[core];
			p_core->n_entries = n_entries[core];
			p_core->hw_offset = hw_offset[core];
			if ((p_core->subtable =
			     MALLOC(pi->sh->osh, p_core->n_entries * sizeof(uint8))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
					pi->sh->unit,
					__FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		table_len = 320;
	}

	if (ACPHY_FEMCTRL_ACTIVE(pi)) {
		switch (pi_ac->srom.femctrl) {
		case 0:
			/* Chip default, do nothing */
			break;
		default:
			/* same as 1 */
		case 1:
				fectrl_c[0] = fectrl_fem5516_fc1;
				fectrl_c[1] = fectrl_fem5516_fc1;
				fectrl_c[2] = fectrl_fem5516_fc1;
				break;
		case 2:	/* 4360 + 43602 chips */
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				fectrl_c[0] = fectrl_fem5516_fc1;
				fectrl_c[1] = fectrl_x29c_c1_fc2_sub0;
				fectrl_c[2] = fectrl_fem5516_fc1;
				break;
			case 1:
				fectrl_c[0] = fectrl_fem5516_fc1;
				fectrl_c[1] = fectrl_x29c_c1_fc2_sub1;
				fectrl_c[2] = fectrl_fem5516_fc1;
				break;
			case 2:
				fectrl_c[0] = fectrl_femctrl2_sub2_c0;
				fectrl_c[1] = fectrl_femctrl2_sub2_c12;
				fectrl_c[2] = fectrl_femctrl2_sub2_c12;
				break;
			case 3: /* 43602bu and 43602cd (X238) femctrl */
			case 4: /* 43602cs (X87)  femctrl (bt on gpio7) */
				fectrl_c[0] = fectrl_fem5517_c0; /* 256 entries */
				fectrl_c[1] = fectrl_fem5517_c1; /* 64 entries */
				fectrl_c[2] = fectrl_fem5517_c2; /* 64 entries */
				break;
			}
			break;
		case 3:
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				if (BCM43602_CHIP(pi->sh->chip)) {
					fectrl_c[0] = fectrl_43602_mch5_c0;
					fectrl_c[1] = fectrl_43602_mch5_c1;
					fectrl_c[2] = fectrl_43602_mch5_c2;
				} else {
					fectrl_c[0] = fectrl_mch5_c0_p200_p400_fc3_sub0;
					fectrl_c[1] = fectrl_mch5_c1_p200_p400_fc3_sub0;
					fectrl_c[2] = fectrl_mch5_c2_p200_p400_fc3_sub0;
				}
				break;
			case 1:
				fectrl_c[0] = fectrl_mch5_c0_fc3_sub1;
				fectrl_c[1] = fectrl_mch5_c1_fc3_sub1;
				fectrl_c[2] = fectrl_mch5_c2_fc3_sub1;
				break;
			case 2:
				fectrl_c[0] = fectrl_j28_fc3_sub2;
				fectrl_c[1] = fectrl_j28_fc3_sub2;
				fectrl_c[2] = fectrl_j28_fc3_sub2;
				break;
			case 3:
				if (BCM43602_CHIP(pi->sh->chip)) {
					fectrl_c[0] = fectrl_43602_mch2_c0;
					fectrl_c[1] = fectrl_43602_mch2_c1;
					fectrl_c[2] = fectrl_43602_mch2_c2;
				} else {
					fectrl_c[0] = fectrl3_sub3_c0;
					fectrl_c[1] = fectrl3_sub3_c1;
					fectrl_c[2] = fectrl3_sub3_c2;
				}
				break;
			case 5:
				fectrl_c[0] = fectrl_43602_mch2_1_c0;
				fectrl_c[1] = fectrl_43602_mch2_1_c1;
				fectrl_c[2] = fectrl_43602_mch2_1_c2;
				break;
			case 6:
				fectrl_c[0] = fectrl3_sub6_43602;
				fectrl_c[1] = fectrl3_sub6_43602;
				fectrl_c[2] = fectrl3_sub6_43602;
				break;
			}
			break;
		case 5:
			fectrl_c[0] = fectrl_fem5516_fc1;
			fectrl_c[1] = fectrl_femctrl5_c1;
			fectrl_c[2] = fectrl_zeros;
			break;
		case 6:
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0: /* MC2, MC5 medium power boards */
				if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
					/* 43602 has same FEM controls on MC5 */
					fectrl_c[0] = fectrl_rfmd4591;
					fectrl_c[1] = fectrl_rfmd4591;
					fectrl_c[2] = fectrl_rfmd4591;
				} else {
					fectrl_c[0] = fectrl_femctrl6;
					fectrl_c[1] = fectrl_femctrl6;
					fectrl_c[2] = fectrl_femctrl6;
				}
				break;
			case 1: /* R8000 (2g & high 5g) */
				fectrl_c[0] = fectrl1_sub1_43602;
				fectrl_c[1] = fectrl1_sub1_43602;
				fectrl_c[2] = fectrl1_sub1_43602;
				break;
			case 2: /* R8000 low 5G */
				fectrl_c[0] = fectrl1_sub2_43602;
				fectrl_c[1] = fectrl1_sub2_43602;
				fectrl_c[2] = fectrl1_sub2_43602;
				break;
			}
			break;
		case 4:
			/* 4335 epa elna boards */
			/* get table size */
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				sparse_table_len =
					ARRAYSIZE(fectrl_fcbga_epa_elna_fc4_sub0);
				break;
			case 1:
				sparse_table_len =
					ARRAYSIZE(fectrl_wlbga_epa_elna_fc4_sub1);
				break;
			case 2:
				sparse_table_len =
					ARRAYSIZE(fectrl_fchm_epa_elna_fc4_sub2);
				break;
			case 3:
			case 4:
				sparse_table_len =
					ARRAYSIZE(fectrl_wlcsp_epa_elna_fc4_sub34);
				break;
			case 5:
				sparse_table_len =
					ARRAYSIZE(fectrl_fp_dpdt_epa_elna_fc4_sub5);
				break;
			case 6:
				sparse_table_len =
					ARRAYSIZE(fectrl_43162_fcbga_ipa_ilna_fc4_sub6);
				pi->u.pi_acphy->fectrl_spl_entry_flag = 1;
				break;
			case 7:
				sparse_table_len =
					ARRAYSIZE(fectrl_43162_fcbga_ipa_elna_fc4_sub7);
				pi->u.pi_acphy->fectrl_spl_entry_flag = 1;
				break;
			}
			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}

			/* pick proper table */
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				fe_ctrl_tbl = fectrl_fcbga_epa_elna_fc4_sub0;
				break;
			case 1:
				fe_ctrl_tbl = fectrl_wlbga_epa_elna_fc4_sub1;
				break;
			case 2:
				fe_ctrl_tbl = fectrl_fchm_epa_elna_fc4_sub2;
				break;
			case 3:
			case 4:
				fe_ctrl_tbl = fectrl_wlcsp_epa_elna_fc4_sub34;
				break;
			case 5:
				fe_ctrl_tbl = fectrl_fp_dpdt_epa_elna_fc4_sub5;
				break;
			case 6:
				fe_ctrl_tbl = fectrl_43162_fcbga_ipa_ilna_fc4_sub6;
				break;
			case 7:
				fe_ctrl_tbl = fectrl_43162_fcbga_ipa_elna_fc4_sub7;
				break;
			}

			/* copy table */
			for (kk = 0; kk < sparse_table_len; kk++) {
				pi->u.pi_acphy->fectrl_idx[kk] = fe_ctrl_tbl[kk].idx;
				pi->u.pi_acphy->fectrl_val[kk] = fe_ctrl_tbl[kk].val;
			}
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
		case 7:
			/* pick size */
			if (!PHY_IPA(pi)) {
				sparse_table_len = ARRAYSIZE(fectrl_femctrl_4335_WLBGA_add_fc7);
			}
			else {
				sparse_table_len = ARRAYSIZE(fectrl_femctrl_4335_WLBGA_iPa_add_fc7);
			}
			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			/* pick table */
			if (PHY_IPA(pi)) {
				fectrl_idx = fectrl_femctrl_4335_WLBGA_iPa_add_fc7;
				fectrl_val = fectrl_femctrl_4335_WLBGA_iPa_fc7;
			}
			else {
				fectrl_idx = fectrl_femctrl_4335_WLBGA_add_fc7;
				fectrl_val = fectrl_femctrl_4335_WLBGA_fc7;
			}
			memcpy(pi->u.pi_acphy->fectrl_idx, fectrl_idx,
			       sparse_table_len* sizeof(uint16));
			memcpy(pi->u.pi_acphy->fectrl_val, fectrl_val,
			       sparse_table_len* sizeof(uint16));
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
		case 8:
			sparse_table_len = ARRAYSIZE(fectrl_femctrl_4335_FCBGA_add_fc8);
			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			/* pick table */

			fectrl_idx = fectrl_femctrl_4335_FCBGA_add_fc8;
			fectrl_val = fectrl_femctrl_4335_FCBGA_fc8;

			memcpy(pi->u.pi_acphy->fectrl_idx, fectrl_idx,
			       sparse_table_len* sizeof(uint16));
			memcpy(pi->u.pi_acphy->fectrl_val, fectrl_val,
			       sparse_table_len* sizeof(uint16));
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
		case 9:
			sparse_table_len = ARRAYSIZE(fectrl_fcbgabu_epa_elna_idx_fc9);

			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			/* pick table */

			fectrl_idx = fectrl_fcbgabu_epa_elna_idx_fc9;
			fectrl_val = fectrl_fcbgabu_epa_elna_val_fc9;

			memcpy(pi->u.pi_acphy->fectrl_idx, fectrl_idx,
			       sparse_table_len * sizeof(uint16));
			memcpy(pi->u.pi_acphy->fectrl_val, fectrl_val,
			       sparse_table_len * sizeof(uint16));
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
		case 10:
			/* 4350 chips have a 320-element fem ctrl table */

			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				sparse_table_len =
					ARRAYSIZE(fectrl_fcbga_epa_elna_idx_fc10_sub0);
				break;
			case 1:
				sparse_table_len =
					ARRAYSIZE(fectrl_wlbga_epa_elna_idx_fc10_sub1);
				break;
			case 2:
				sparse_table_len =
					ARRAYSIZE(fectrl_wlbga_ipa_ilna_idx_fc10_sub2);
				break;
			case 3:
				sparse_table_len =
					ARRAYSIZE(fectrl_43556usb_epa_elna_idx_fc10_sub3);
				break;
			case 4:
				sparse_table_len =
					ARRAYSIZE(fectrl_fcbga_ipa_ilna_idx_fc10_sub4);
				break;
			case 5:
				sparse_table_len =
					ARRAYSIZE(fectrl_idx_fc10_sub5);
				break;
			}
			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			switch (pi_ac->srom.femctrl_sub) {
			default:
			case 0:
				fectrl_idx = fectrl_fcbga_epa_elna_idx_fc10_sub0;
				fectrl_val = fectrl_fcbga_epa_elna_val_fc10_sub0;
				break;
			case 1:
				fectrl_idx = fectrl_wlbga_epa_elna_idx_fc10_sub1;
				fectrl_val = fectrl_wlbga_epa_elna_val_fc10_sub1;
				break;
			case 2:
				fectrl_idx = fectrl_wlbga_ipa_ilna_idx_fc10_sub2;
				fectrl_val = fectrl_wlbga_ipa_ilna_val_fc10_sub2;
				break;
			case 3:
				fectrl_idx = fectrl_43556usb_epa_elna_idx_fc10_sub3;
				fectrl_val = fectrl_43556usb_epa_elna_val_fc10_sub3;
				break;
			case 4:
				fectrl_idx = fectrl_fcbga_ipa_ilna_idx_fc10_sub4;
				fectrl_val = fectrl_fcbga_ipa_ilna_val_fc10_sub4;
				break;
			case 5:
				fectrl_idx = fectrl_idx_fc10_sub5;
				fectrl_val = fectrl_val_fc10_sub5;
				break;
			}
			memcpy(pi->u.pi_acphy->fectrl_idx, fectrl_idx,
			       sparse_table_len* sizeof(uint16));
			memcpy(pi->u.pi_acphy->fectrl_val, fectrl_val,
			       sparse_table_len* sizeof(uint16));
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
			/* LOOK: when adding new cases, follow above pattern to
			 * minimize stack/memory usage!
			 */
		case 11:
			sparse_table_len =
				ARRAYSIZE(fectrl_fcbu_epa_idx_fc11);
			table_len = 3*256;
			/* malloc table */
			if ((pi->u.pi_acphy->fectrl_idx =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			if ((pi->u.pi_acphy->fectrl_val =
			     MALLOC(pi->sh->osh,
			            sparse_table_len * sizeof(uint16))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit,
				           __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			fectrl_idx = fectrl_fcbu_epa_idx_fc11;
			fectrl_val = fectrl_fcbu_epa_val_fc11;

			memcpy(pi->u.pi_acphy->fectrl_idx, fectrl_idx,
			       sparse_table_len* sizeof(uint16));
			memcpy(pi->u.pi_acphy->fectrl_val, fectrl_val,
			       sparse_table_len* sizeof(uint16));
			pi->u.pi_acphy->fectrl_sparse_table_len = sparse_table_len;
			pi->u.pi_acphy->fectrl_table_len = table_len;
			break;
		case 18:
			if (pi_ac->srom.femctrl_sub == 1) {
				/* FEMCTRL LUT for SKY 85806 on 43602 */
				fectrl_c[0] = fectrl_fem85806_c0;
				fectrl_c[1] = fectrl_fem85806_c1;
				fectrl_c[2] = fectrl_fem85806_c1;
			} else {
				/* FEMCTRL LUT for SKY 85806 */
				fectrl_c[0] = fectrl_fem85806;
				fectrl_c[1] = fectrl_fem85806;
				fectrl_c[2] = fectrl_fem85806;
			}
			break;
		}

		/* 4360 / 43602 specific */
		if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			FOREACH_CORE(pi, core) {
				p_core = &pi->u.pi_acphy->fectrl_c[core];
				ASSERT(p_core->subtable != NULL);
				if (p_core->subtable != NULL)
					memcpy(p_core->subtable, fectrl_c[core],
						p_core->n_entries * sizeof(uint8));
			}
		}
	}
	return TRUE;
} /* wlc_phy_attach_femctrl_table */

static void
wlc_phy_enable_pavref_war(phy_info_t *pi)
{
	/* 43602a0: power on PARLDO and update RFSeq table */
	const uint16 tx2rx_delay = 0x130;
	const uint16 lna_trsw_timing[] = {0x1, 0x2, 0x2, 0x2, 0x4};
	si_pmu_switch_on_PARLDO(pi->sh->sih, pi->sh->osh);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
		1, 0x80, 16, &tx2rx_delay);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
		ARRAYSIZE(lna_trsw_timing), 0x70, 16, &lna_trsw_timing);

	WRITE_PHYREG(pi, dot11acphycrsTxExtension, 0x1);
	W_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_SIFS_RX_TX_TX, 0x7676);
	W_REG(pi->sh->osh, &pi->regs->PHYREF_IFS_SIFS_NAV_TX, 0x0276);
	W_REG(pi->sh->osh, &pi->regs->psm_int_sel_1, 0x5);
}

static void
wlc_phy_set_regtbl_on_femctrl(phy_info_t *pi)
{
	uint8 stall_val;
	uint8 bt_fem;	/* bitfield in PHY register BT_FemControl */
	uint8 gpio_en;	/* set which gpio pins are controlled by the PHY and which by ucode */
	bool bt_on_gpio4;
	uint32 chipcontrol_mask; /* chipcommon core chipcontrol register */
	uint32 chipcontrol_val;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (!ACPHY_FEMCTRL_ACTIVE(pi)) {
		wlc_phy_write_regtbl_fc_from_nvram(pi);
	} else {
		switch (pi_ac->srom.femctrl) {
		case 0:
			/* Chip default, do nothing */
			break;
		case 1:
			/* MC & MCI
			   FIXME: Condition this on femctrl
			   5516fem, no BT, same fe_ctrl on all three cores
			   12x12 - bcm94360bu, bcm94360mc
			   12x9  - bcm94360s9bu, bcm94360mci
			*/
			/* chip_bandsel = bandsel */
			MOD_PHYREG(pi, BT_SwControl, bt_sharing_en, 1);
			wlc_phy_write_femctrl_table(pi);
			break;
		case 2:
			/*  X29c & 4352hmb(wiht B0)
			    Cores {0, 2} have 5516 fem. Core 1 has separate 2g/5g fems
			*/
			bt_fem = 0; bt_on_gpio4 = FALSE;
			wlc_phy_write_femctrl_table(pi);
			gpio_en = 0xa0;
			chipcontrol_mask = CCTRL4360_SECI_MODE | CCTRL4360_SECI_ON_GPIO01 |
				CCTRL4360_BTSWCTRL_MODE;
			chipcontrol_val = 0;

			if (pi_ac->srom.femctrl_sub == 0) {
				bt_on_gpio4 = TRUE;  /* fem_bt = gpio4 */
			} else if (pi_ac->srom.femctrl_sub == 3) {
				/*
				 * For 5517. In 43602 turn off VLIN override mux, and always keep
				 * VLIN high through FEM CTRL * table.
				 * bcm943602bu : 3 antenna board, no BT support
				 * bcm943602cd (X238) : 3 Wifi + 1 BT antenna board
				 */
				MOD_PHYREG(pi, RfctrlCoreGlobalPus,
				           muxTxVlinOnFemCtrl, 0x0);
				chipcontrol_val = (CCTRL4360_SECI_MODE | CCTRL4360_SECI_ON_GPIO01);
				gpio_en = 0;  /* no shared antenna */
			} else if (pi_ac->srom.femctrl_sub == 4) {
				/*
				 * For 5517. In 43602 turn off VLIN override mux, and
				 * always keep VLIN high through FEM CTRL * table.
				 * bcm943602cs (X87) : 3 antenna, middle antenna is shared BT/Wifi.
				 *                     gpio7 flows towards FEM BT_EN pin.
				 */
				MOD_PHYREG(pi, RfctrlCoreGlobalPus,
				           muxTxVlinOnFemCtrl, 0x0);
				chipcontrol_val = (CCTRL4360_SECI_MODE | CCTRL4360_SECI_ON_GPIO01 |
					CCTRL4360_BTSWCTRL_MODE);
				bt_fem = 2;      /* fem_bt = bt_fem[1] */
				gpio_en = 0x60; /* d[7]=0 -> allows ucode to control gpio7 */
			} else {
				bt_fem = 4;      /* fem_bt = bt_fem[2] */
			}

			if (chipcontrol_val != 0) {
				si_corereg(pi->sh->sih, SI_CC_IDX,
					OFFSETOF(chipcregs_t, chipcontrol),
					chipcontrol_mask, chipcontrol_val);
			}

			if (gpio_en != 0) {
				/* Setup middle core for BT */
				wlc_phy_set_bt_on_core1_acphy(pi, bt_fem, gpio_en);
			}

			/* Release control of gpio4 if required */
			if (bt_on_gpio4)
				wlc_phy_bt_on_gpio4_acphy(pi);
			break;
		case 3:
			/*  Routers (MCH5, J28) */
			MOD_PHYREG(pi, BT_SwControl, bt_sharing_en, 0);
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* all 43602 chips */
				if (pi_ac->srom.femctrl_sub == 0 || pi_ac->srom.femctrl_sub == 3 ||
					pi_ac->srom.femctrl_sub == 6) {
					if (ACMINORREV_0(pi->pubpi.phy_rev)) {
						/* 43602a0: enable PAVREF WAR for boards
						 * that enable PA with PAVREF
						 */
						wlc_phy_enable_pavref_war(pi);
					} else {
						/* 43602a1 and later: power on PAVREF LDO
						 * for boards that enable PA with PAVREF
						 */
						si_pmu_switch_on_PARLDO(pi->sh->sih, pi->sh->osh);
					}
				}
			} else {
				si_pmu_regcontrol(pi->sh->sih, 0, 0x4, 4);   /* pwron pavref ldo */
			}
			wlc_phy_write_femctrl_table(pi);

			if (pi_ac->srom.femctrl_sub == 5) {
				/* MCH2 with digital PA control */
				chipcontrol_val = chipcontrol_mask =
					(CCTRL4360_DISCRETE_FEMCTRL_MODE |
					CCTRL4360_DIGITAL_PACTRL_MODE);
				si_corereg(pi->sh->sih, SI_CC_IDX,
					OFFSETOF(chipcregs_t, chipcontrol), chipcontrol_mask,
					chipcontrol_val);
			} else if (pi_ac->srom.femctrl_sub < 2 || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* MCH5 and 43602MHC2: leave bit1 untouched for uart */
				si_corereg(pi->sh->sih, SI_CC_IDX,
					OFFSETOF(chipcregs_t, chipcontrol), 0xfffffd,
					CCTRL4360_DISCRETE_FEMCTRL_MODE);
			}
			/* STB (USBH5) */
			if ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags2) &
				BFL2_SROM11_ANAPACTRL_5G) &&
				(BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardtype) ==
				BCM94360USBH5_D11AC5G)) {
				/* power on PA(bit 2) & RF(bit 1) LDO */
				wlapi_bmac_write_shm(pi->sh->physhim, M_RFLDO_ON_L, 0x4);
				wlapi_bmac_write_shm(pi->sh->physhim, M_RFLDO_ON_H, 0x20);
			}
			break;
		case 5:
			wlc_phy_write_femctrl_table(pi);
			/* Setup middle core for BT */
			wlc_phy_set_bt_on_core1_acphy(pi, 8, 0xc0);
			break;
		case 6:
			wlc_phy_write_femctrl_table(pi);
			break;
		case 18:
			/* SKY85806 chip_bandsel = bandsel */
			MOD_PHYREG(pi, BT_SwControl, bt_sharing_en, 1);
			wlc_phy_write_femctrl_table(pi);
			break;

		case 4:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			wlc_phy_write_sparse_femctrl_table(pi);
			break;
			/* LOOK: when adding new cases, follow above pattern to
			 * minimize stack/memory usage!
			 */
		default:
			/* 5516 on all cores */
			/* chip_bandsel = bandsel */
			MOD_PHYREG(pi, BT_SwControl, bt_sharing_en, 1);
			wlc_phy_write_femctrl_table(pi);
			break;
		}
	}
	if (pi_ac->srom.bt_coex) {
		if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
			if (ACMINORREV_0(pi->pubpi.phy_rev)) {
				si_corereg(pi->sh->sih, SI_CC_IDX,
					OFFSETOF(chipcregs_t, chipcontrol),
					CCTRL4360_SECI_MODE, CCTRL4360_SECI_MODE);
			} else if (ACMINORREV_1(pi->pubpi.phy_rev)) {
				if (pi->sh->sih->bSeciOnSprom) {
					si_corereg(pi->sh->sih, SI_CC_IDX,
						OFFSETOF(chipcregs_t, chipcontrol),
						CCTRL4360_SECI_MODE, CCTRL4360_SECI_MODE);
				} else {
					si_corereg(pi->sh->sih, SI_CC_IDX,
						OFFSETOF(chipcregs_t, chipcontrol),
						CCTRL4360_SECI_ON_GPIO01,
						CCTRL4360_SECI_ON_GPIO01);
				}
			} else {
				ASSERT(0);
			}
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
		           ACMAJORREV_3(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			PHY_ERROR(("wl%d: %s: FIXME bt_coex\n", pi->sh->unit, __FUNCTION__));
		} else {
			ASSERT(0);
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_txpower_recalc_target_acphy(phy_info_t *pi)
{
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 chan_freq_range, core;
	int16 tssifloor;

	if (ACREV_IS(pi->pubpi.phy_rev, 2)) {
		chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);

		FOREACH_CORE(pi, core) {
			tssifloor = (int16)pwrdet->tssifloor[core][chan_freq_range];
			if (tssifloor != 0) {
				wlc_phy_set_txpwr_clamp_acphy(pi, core);
			}
		}
	}
	wlapi_high_update_txppr_offset(pi->sh->physhim, pi->tx_power_offset);

	/* recalc targets -- turns hwpwrctrl off */

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		wlc_phy_txpwrctrl_pwr_setup_srom12_acphy(pi);
	}
#endif /* SROM12 */
	if (pi->sh->sromrev < 12) {
		wlc_phy_txpwrctrl_pwr_setup_acphy(pi);
	}

	/* restore power control */
	wlc_phy_txpwrctrl_enable_acphy(pi, pi->txpwrctrl);
}

static void
wlc_phy_watchdog_acphy(phy_info_t *pi)
{
	uint8 idx;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	/* Local copy of rxchains */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx */
	uint8 save_EnTx = 0;
	/* Flag to remember force turn-on */
	uint8 force_turnon = 0;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);

#if (defined(WLTEST) || defined(BCMDBG))
	/* Check for hanging PHY CAL status*/
	wlc_phy_iqlocal_state_check_acphy(pi);
#endif // endif

	/* Enabling crsmin_cal from watchdog */
	/* crsmin phyregs are only updated if the  */
	/* (current noise power - prev value from cache) is above a threshold */
	if (pi->u.pi_acphy->crsmincal_enable) {
		/* Force turn-on rxchains if necessary */
		if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
			save_active_rxchains = pi->sh->phyrxchain;
			pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
			save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
			wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
			force_turnon = 1;
		}
		wlc_phy_noise_sample_request_crsmincal((wlc_phy_t*)pi);

		/* Restore rxchains to original state */
		if (force_turnon) {
			pi->sh->phyrxchain = save_active_rxchains;
			wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
			/* Restore original value of EnTx */
			MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
		}
	}
	/* Change cores for RSSI reporting every sec to get an idea of all cores */
	while (((PHYCOREMASK(pi->sh->phyrxchain) >> pi_ac->rssi_coresel) & 0x1) == 0) {
	  pi_ac->rssi_coresel = (pi_ac->rssi_coresel + 1) % PHYCORENUM(pi->pubpi.phy_corenum);
	}
	MOD_PHYREG(pi, RssiStatusControl, coreSel, pi_ac->rssi_coresel);
	pi_ac->rssi_coresel = (pi_ac->rssi_coresel + 1) % PHYCORENUM(pi->pubpi.phy_corenum);
	wlapi_enable_mac(pi->sh->physhim);

	for (idx = 0; idx < ACPHY_ACI_CHAN_LIST_SZ; idx++) {
		pi_ac->aci_list2g[idx].engine_called = FALSE;
		pi_ac->aci_list5g[idx].engine_called = FALSE;
	}
}

/*  lookup radio-chip-specific channel code */
static bool
wlc_phy_chan2freq_acphy(phy_info_t *pi, uint channel, int *f, const void **chan_info)
{
	uint i;
	CONST chan_info_radio2069_t *chan_info_tbl = NULL;
	chan_info_radio2069revGE16_t *chan_info_tbl_GE16 = NULL;
	chan_info_radio2069revGE25_t *chan_info_tbl_GE25 = NULL;
	chan_info_radio2069revGE32_t *chan_info_tbl_GE32 = NULL;
	chan_info_radio2069revGE25_52MHz_t *chan_info_tbl_GE25_52MHz = NULL;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint32 tbl_len = 0;
	int freq = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));
	switch (RADIOMAJORREV(pi->pubpi.radiomajorrev)) {
	case 0:
		switch (RADIOREV(pi->pubpi.radiorev)) {
		case 3:
			chan_info_tbl = chan_tuning_2069rev3;
			tbl_len = ARRAYSIZE(chan_tuning_2069rev3);
		break;

		case 4:
		case 8:
			chan_info_tbl = chan_tuning_2069rev4;
			tbl_len = ARRAYSIZE(chan_tuning_2069rev4);
			break;
		case 10:
		case 11:
		case 7: /* e.g. 43602a0 */
			chan_info_tbl = chan_tuning_2069rev7;
			tbl_len = ARRAYSIZE(chan_tuning_2069rev7);
			break;
		default:

			PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
			           pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
			ASSERT(0);
		}
		break;

	case 1:
		switch (RADIOREV(pi->pubpi.radiorev)) {
			case 16:
				if (PHY_XTAL_IS40M(pi)) {
#ifndef ACPHY_1X1_37P4
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure the LP mode settings */
						/* For Rev16/17/18 using the same LP setting TBD */
						chan_info_tbl_GE16 = chan_tuning_2069rev_GE16_40_lp;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_GE16_40_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_16_17_40;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_16_17_40);
					}
#else
					ASSERT(0);
#endif /* ACPHY_1X1_37P4 */
				} else {
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure the LP mode settings */
						/* For Rev16/17/18 using the same LP setting TBD */
						chan_info_tbl_GE16 = chan_tuning_2069rev_GE16_lp;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_GE16_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_16_17;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_16_17);
					}
				}
				pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
				break;
			case 17:
			case 23:
				if (PHY_XTAL_IS40M(pi)) {
#ifndef ACPHY_1X1_37P4
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure the LP mode settings */
						/* For Rev16/17/18 using the same LP setting TBD */
						chan_info_tbl_GE16 =
						       chan_tuning_2069rev_GE16_40_lp;
						tbl_len =
						       ARRAYSIZE(chan_tuning_2069rev_GE16_40_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_16_17_40;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_16_17_40);
					}
#else
					ASSERT(0);
#endif /* ACPHY_1X1_37P4 */
				} else {
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
#ifndef ACPHY_1X1_37P4
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure the LP mode settings */
						/* For Rev16/17/18 using the same LP setting TBD */
						chan_info_tbl_GE16 = chan_tuning_2069rev_GE16_lp;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_GE16_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_16_17;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_16_17);
					}
#else
					if ((RADIOREV(pi->pubpi.radiorev)) == 23) {
						chan_info_tbl_GE16 =
						 chan_tuning_2069rev_23_2Glp_5Gnonlp;
						tbl_len =
						 ARRAYSIZE(chan_tuning_2069rev_23_2Glp_5Gnonlp);

					} else {
						chan_info_tbl_GE16 =
						 chan_tuning_2069rev_GE16_2Glp_5Gnonlp;
						tbl_len =
						 ARRAYSIZE(chan_tuning_2069rev_GE16_2Glp_5Gnonlp);
					}
#endif /* ACPHY_1X1_37P4 */
				}
				pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
				break;
			case 18:
			case 24:
				if (PHY_XTAL_IS40M(pi)) {
#ifndef ACPHY_1X1_37P4
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure the LP mode settings */
						/* For Rev16/17/18 using the same LP setting TBD */
						chan_info_tbl_GE16 =
						    chan_tuning_2069rev_GE16_40_lp;
						tbl_len =
						    ARRAYSIZE(chan_tuning_2069rev_GE16_40_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_18_40;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_18_40);
					}
#else
					ASSERT(0);
#endif /* ACPHY_1X1_37P4 */
				} else {
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
					        (pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						/* In this configure LP mode settings */
						/* For Rev16/17/18 using same LP setting TBD */
						chan_info_tbl_GE16 =
						       chan_tuning_2069rev_GE16_lp;
						tbl_len =
						       ARRAYSIZE(chan_tuning_2069rev_GE16_lp);
					} else {
						chan_info_tbl_GE16 = chan_tuning_2069rev_18;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_18);
					}
				}
				pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
				break;
			case 25:
			case 26:
				if (PHY_XTAL_IS40M(pi)) {
#ifndef ACPHY_1X1_37P4
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;

					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						chan_info_tbl_GE25 =
							chan_tuning_2069rev_GE_25_40MHz_lp;
						tbl_len =
						ARRAYSIZE(chan_tuning_2069rev_GE_25_40MHz_lp);
					} else {
						chan_info_tbl_GE25 =
						     chan_tuning_2069rev_GE_25_40MHz;
						tbl_len =
						     ARRAYSIZE(chan_tuning_2069rev_GE_25_40MHz);
					}
#else
					ASSERT(0);
#endif /* ACPHY_1X1_37P4 */
				} else if (PHY_XTAL_IS52M(pi)) {
					chan_info_tbl_GE25_52MHz = pi->u.pi_acphy->chan_tuning;
					tbl_len = pi->u.pi_acphy->chan_tuning_tbl_len;
				} else {
					pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
					if ((pi_ac->acphy_lp_mode == 2) ||
						(pi_ac->acphy_lp_mode == 3) ||
						(pi_ac->acphy_force_lpvco_2G == 1 &&
						CHSPEC_IS2G(pi->radio_chanspec))) {
						chan_info_tbl_GE25 = chan_tuning_2069rev_GE_25_lp;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_GE_25_lp);
					} else {
						chan_info_tbl_GE25 = chan_tuning_2069rev_GE_25;
						tbl_len = ARRAYSIZE(chan_tuning_2069rev_GE_25);
					}
				}
				pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
				break;
			default:
				PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
				   pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
				ASSERT(0);
		}

		break;

	case 2:
		switch (RADIOREV(pi->pubpi.radiorev)) {
		case 32:
		case 33:
		case 34:
		case 35:
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
		case 43:
		case 44:
		case 45:
		case 46:
			/* can have more conditions based on different radio revs */
			/*  RADIOREV(pi->pubpi.radiorev) =32/33/34 */
			/* currently tuning tbls for these are all same */
			chan_info_tbl_GE32 = pi->u.pi_acphy->chan_tuning;
			tbl_len = pi->u.pi_acphy->chan_tuning_tbl_len;
			break;

		default:

			PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
			           pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
			ASSERT(0);
		}
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unsupported radio major revision %d\n",
		           pi->sh->unit, __FUNCTION__, RADIOMAJORREV(pi->pubpi.radiomajorrev)));
		ASSERT(0);
	}

	for (i = 0; i < tbl_len; i++) {

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			if (chan_info_tbl_GE32[i].chan == channel)
				break;
		} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			if ((RADIOREV(pi->pubpi.radiorev) == 25) ||
			   (RADIOREV(pi->pubpi.radiorev) == 26))  {
			    if (!PHY_XTAL_IS52M(pi)) {
					if (chan_info_tbl_GE25[i].chan == channel)
						break;
				} else {
					if (chan_info_tbl_GE25_52MHz[i].chan == channel)
						break;
				}
			}
			else if (chan_info_tbl_GE16[i].chan == channel)
				break;
		} else {
			if (chan_info_tbl[i].chan == channel)
				break;
		}
	}

	if (i >= tbl_len) {
		PHY_ERROR(("wl%d: %s: channel %d not found in channel table\n",
		           pi->sh->unit, __FUNCTION__, channel));
		ASSERT(i < tbl_len);
		goto fail;
	}

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		*chan_info = &chan_info_tbl_GE32[i];
		freq = chan_info_tbl_GE32[i].freq;
	} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
		if ((RADIOREV(pi->pubpi.radiorev) == 25) ||
			(RADIOREV(pi->pubpi.radiorev) == 26)) {
				if (!PHY_XTAL_IS52M(pi)) {
					*chan_info = &chan_info_tbl_GE25[i];
					freq = chan_info_tbl_GE25[i].freq;
				} else {
					*chan_info = &chan_info_tbl_GE25_52MHz[i];
					freq = chan_info_tbl_GE25_52MHz[i].freq;
				}
		} else {
			*chan_info = &chan_info_tbl_GE16[i];
			freq = chan_info_tbl_GE16[i].freq;
		}
	} else {
		*chan_info = &chan_info_tbl[i];
		freq = chan_info_tbl[i].freq;
	}

	*f = freq;
	return TRUE;

fail:
	*f = WL_CHAN_FREQ_RANGE_2G;
	return FALSE;
}
static bool
BCMATTACHFN(wlc_phy_attach_chan_tuning_tbl)(phy_info_t *pi)
{
	chan_info_radio2069revGE32_t *chan_info_tbl_GE32 = NULL;
	chan_info_radio2069revGE25_52MHz_t *chan_info_tbl_GE25_52MHz = NULL;

	uint32 tbl_len = 0;
	pi->u.pi_acphy->chan_tuning = NULL;
	pi->u.pi_acphy->chan_tuning_tbl_len = 0;

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			if (PHY_XTAL_IS52M(pi)) {
				if ((pi->u.pi_acphy->chan_tuning =
				     MALLOC(pi->sh->osh,
				            NUM_ROWS_CHAN_TUNING_2069 *
				            sizeof(chan_info_radio2069revGE25_52MHz_t))) == NULL) {
					PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes",
						pi->sh->unit, __FUNCTION__, MALLOCED(pi->sh->osh)));
					return FALSE;
				}
				switch (RADIOREV(pi->pubpi.radiorev)) {
				case 25:
				case 26:
					chan_info_tbl_GE25_52MHz =
					     chan_tuning_2069rev_GE_25_52MHz;
					tbl_len =
					ARRAYSIZE(chan_tuning_2069rev_GE_25_52MHz);
					break;
				default:

					PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
						pi->sh->unit,
						__FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
					ASSERT(0);
					return FALSE;
				}
				pi->u.pi_acphy->chan_tuning_tbl_len = tbl_len;
				memcpy(pi->u.pi_acphy->chan_tuning, chan_info_tbl_GE25_52MHz,
					NUM_ROWS_CHAN_TUNING_2069 *
					sizeof(chan_info_radio2069revGE25_52MHz_t));
			}

		} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			/* malloc chan tuning */
			if ((pi->u.pi_acphy->chan_tuning =
			     MALLOC(pi->sh->osh,
			            NUM_ROWS_CHAN_TUNING_2069 *
			            sizeof(chan_info_radio2069revGE32_t))) == NULL) {
				PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
				           pi->sh->unit, __FUNCTION__, MALLOCED(pi->sh->osh)));
				return FALSE;
			}
			switch (RADIOREV(pi->pubpi.radiorev)) {
			case 32:
			case 33:
			case 34:
			case 35:
			case 37:
			case 38:
				/* can have more conditions based on different radio revs */
				/*  RADIOREV(pi->pubpi.radiorev) =32/33/34 */
				/* currently tuning tbls for these are all same */
				if (PHY_XTAL_IS40M(pi)) {
					chan_info_tbl_GE32 = chan_tuning_2069_rev33_37_40;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev33_37_40);
				} else {
					chan_info_tbl_GE32 = chan_tuning_2069_rev33_37;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev33_37);
				}
				break;
			case 39:
			case 40:
			case 41:
			case 44:
			case 46:
				if (PHY_XTAL_IS40M(pi)) {
					 /* rev39 and rev40 use the same tuning tables */
					chan_info_tbl_GE32 = chan_tuning_2069_rev39_40;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev39_40);
				} else {
					chan_info_tbl_GE32 = chan_tuning_2069_rev39;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev39);
				}
				break;
			case 36:
			case 42:
			case 43:
			case 45:
				if (PHY_XTAL_IS40M(pi)) {
					chan_info_tbl_GE32 = chan_tuning_2069_rev36_40;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev36_40);
				} else {
					chan_info_tbl_GE32 = chan_tuning_2069_rev36;
					tbl_len = ARRAYSIZE(chan_tuning_2069_rev36);
				}
				break;
			default:

				PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
				           pi->sh->unit,
				           __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
				ASSERT(0);
				return FALSE;
			}
			pi->u.pi_acphy->chan_tuning_tbl_len = tbl_len;
			memcpy(pi->u.pi_acphy->chan_tuning, chan_info_tbl_GE32,
			        NUM_ROWS_CHAN_TUNING_2069 * sizeof(chan_info_radio2069revGE32_t));
		}
	}
	return TRUE;
}
static bool
wlc_phy_chan2freq_20691(phy_info_t *pi, uint channel, int *f, const void **chan_info)
{
	uint i;
	chan_info_radio20691_t *chan_info_tbl = NULL;
	uint32 tbl_len = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* Choose the right table to use */
	switch (RADIOREV(pi->pubpi.radiorev)) {
	case 18:
		chan_info_tbl = chan_tuning_20691_rev18;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev18);
		break;
	case 27:
		chan_info_tbl = chan_tuning_20691_rev27;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev27);
		break;
	case 30:
		chan_info_tbl = chan_tuning_20691_rev30;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev30);
		break;
	case 31:
		chan_info_tbl = chan_tuning_20691_rev31;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev31);
		break;
	case 32:
		chan_info_tbl = chan_tuning_20691_rev32;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev32);
		break;
	case 48:
		chan_info_tbl = chan_tuning_20691_rev48;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev48);
		break;
	case 50:
		chan_info_tbl = chan_tuning_20691_rev50;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev50);
		break;
	case 60:
	case 68:
		chan_info_tbl = chan_tuning_20691_rev68;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev68);
		break;
	case 75:
		chan_info_tbl = chan_tuning_20691_rev75;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev75);
		break;
	case 79:
		chan_info_tbl = chan_tuning_20691_rev79;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev79);
		break;
	case 74:
	case 82:
		chan_info_tbl = chan_tuning_20691_rev82;
		tbl_len = ARRAYSIZE(chan_tuning_20691_rev82);
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unsupported radio revision %d\n",
			pi->sh->unit, __FUNCTION__, RADIOREV(pi->pubpi.radiorev)));
		ASSERT(FALSE);
		goto fail;
	}

	for (i = 0; i < tbl_len && chan_info_tbl[i].chan != channel; i++);

	if (i >= tbl_len) {
		PHY_ERROR(("wl%d: %s: channel %d not found in channel table\n",
		           pi->sh->unit, __FUNCTION__, channel));
		ASSERT(i < tbl_len);
		goto fail;
	}

	*chan_info = &chan_info_tbl[i];
	*f = chan_info_tbl[i].freq;

	return TRUE;

fail:
	*f = WL_CHAN_FREQ_RANGE_2G;

	return FALSE;
}

static void
wlc_phy_2069_4335_set_ovrds(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	ACPHY_REG_LIST_START
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR30, 0x1df3)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR31, 0x1ffc)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR32, 0x0078)
	ACPHY_REG_LIST_EXECUTE(pi);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		write_radio_reg(pi, RF0_2069_GE16_OVR28, 0x0);
		write_radio_reg(pi, RFP_2069_GE16_OVR29, 0x0);
	} else {
		write_radio_reg(pi, RF0_2069_GE16_OVR28, 0xffff);
		write_radio_reg(pi, RFP_2069_GE16_OVR29, 0xffff);
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1)
			if (PHY_IPA(pi))
			    write_radio_reg(pi, RFP_2069_GE16_OVR29, 0x6900);
	}
}

static void
wlc_phy_2069_4350_set_ovrds(phy_info_t *pi)
{
	uint8 core, afediv_size, afeldo1;
	uint32 fc = wf_channel2mhz(CHSPEC_CHANNEL(pi->radio_chanspec),
		CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
		: WF_CHAN_FACTOR_5_G);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	ACPHY_REG_LIST_START
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR30, 0x1df3)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR31, 0x1ffc)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR32, 0x0078)

		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_CP, 0x1)
		MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_VCO, 0x1)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (PHY_IPA(pi)&&(PHY_XTAL_IS37M4(pi))&&CHSPEC_IS2G(pi->radio_chanspec)) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_RADIO_REGC(pi, PA2G_CFG1, core, pa2g_bias_reset, 1);
			MOD_RADIO_REGC(pi, GE16_OVR13, core, ovr_pa2g_bias_reset, 1);
			}
	}
	if ((RADIOREV(pi->pubpi.radiorev) == 36) || (RADIOREV(pi->pubpi.radiorev) >= 39)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_qb, 0x2)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_itx, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_irx, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2gN5g, idac_qrx, 0x3)
			MOD_PHYREG_ENTRY(pi, radio_logen2g, idac_qtx, 0x3)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CFG4, rfpll_spare2, 0x6)
			MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CFG4, rfpll_spare3, 0x34)

			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_TOP_SPARE7, 0x1)
			WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF1, 0x48)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	if ((RADIOREV(pi->pubpi.radiorev) >= 39) && (PHY_IPA(pi)) &&
		(PHY_XTAL_IS40M(pi))) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			/*	Turn ON lna5g kill switch when WLAN is in g mode in order
				to reduce Tx 2G_HD2 (FCC cert).
				NVRAM should take care that 5G-TR is already flipped to Rx state
				when WLAN runs g mode.
			*/
			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RFX, GE16_OVR22,
					ovr_rxrf5g_pwrsw_lna5g_en, 0x1)
				MOD_RADIO_REG_ENTRY(pi, RFX, LNA5G_CFG1, pwrsw_en, 0x1)
				MOD_RADIO_REG_ENTRY(pi, RFX, GE16_OVR7,
					ovr_lna5g_tr_rx_en, 0x1)
				MOD_RADIO_REG_ENTRY(pi, RFX, LNA5G_CFG1, tr_rx_en, 0x0)
			ACPHY_REG_LIST_EXECUTE(pi);
		} else {
			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RFX, GE16_OVR22,
					ovr_rxrf5g_pwrsw_lna5g_en, 0x0)
				MOD_RADIO_REG_ENTRY(pi, RFX, GE16_OVR7, ovr_lna5g_tr_rx_en, 0x0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	if ((RADIOREV(pi->pubpi.radiorev) >= 39) && (!PHY_IPA(pi)) &&
		(PHY_XTAL_IS40M(pi))) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RFX, GE16_OVR7, ovr_lna5g_tr_rx_en, 0x0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	if (!PHY_IPA(pi)) {
		if (PHY_XTAL_IS37M4(pi)) {
#ifdef ACMAJORREV2_THROUGHPUT_OPT
			if (pi->u.pi_acphy->xtalldo) {
				MOD_RADIO_REG(pi, RFP, PLL_XTALLDO1,
					ldo_1p2_xtalldo1p2_ctl, 0xf);
			} else {
				MOD_RADIO_REG(pi, RFP, PLL_XTALLDO1,
					ldo_1p2_xtalldo1p2_ctl, 0xb);
			}
#else
			MOD_RADIO_REG(pi, RFP, PLL_XTALLDO1,
				ldo_1p2_xtalldo1p2_ctl, 0xb);
#endif // endif
		}
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (CHSPEC_IS80(pi->radio_chanspec)) {
				switch (fc) {
				case 5690:
					afediv_size = 0xf;
					afeldo1 = 0x7;
					break;
				case 5775:
					afediv_size = 0xf;
					afeldo1 = 0x0;
					break;
				case 5210:
				case 5290:
					afediv_size = 0x8;
					afeldo1 = 0x0;
					break;
				default:
					afediv_size = 0xB;
					afeldo1 = 0x7;
				}
				MOD_RADIO_REG(pi, RFP, GE16_AFEDIV1,
				    afediv_main_driver_size, afediv_size);
				MOD_RADIO_REG(pi, RF1, GE32_PMU_CFG2, AFEldo_adj, afeldo1);
			} else {
				MOD_RADIO_REG(pi, RFP, GE16_AFEDIV1, afediv_main_driver_size,
				     (fc == 5190) ? 0xa : 0x8);
				MOD_RADIO_REG(pi, RF1, GE32_PMU_CFG2, AFEldo_adj, 0x7);
			}
			/* Override PAD gain for core 0 to be 255 */
			MOD_RADIO_REG(pi, RF0, GE16_OVR14, ovr_pad5g_gc, 0x1);
			MOD_RADIO_REG(pi, RF0, PAD5G_CFG1, gc, 0x7F);
			if (pi->u.pi_acphy->srom_txnospurmod5g == 1) {
				/* Override PAD gain for core 1 to be 255 */
				MOD_RADIO_REG(pi, RF1, GE16_OVR14, ovr_pad5g_gc, 0x1);
				MOD_RADIO_REG(pi, RF1, PAD5G_CFG1, gc, 0x7F);
			} else {
				ACPHY_REG_LIST_START
					MOD_RADIO_REG_ENTRY(pi, RF1, PAD5G_IDAC, idac_main, 0x28)
					MOD_RADIO_REG_ENTRY(pi, RF1, PAD5G_TUNE, idac_aux, 0x28)
					MOD_RADIO_REGC_ENTRY(pi, PAD5G_INCAP, 1,
						idac_incap_compen_main, 0x8)
					MOD_RADIO_REGC_ENTRY(pi, PAD5G_INCAP, 1,
						idac_incap_compen_aux, 0x8)
				ACPHY_REG_LIST_EXECUTE(pi);
			}
		} else {
			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_AFEDIV1,
					afediv_main_driver_size, 0x8)
				MOD_RADIO_REG_ENTRY(pi, RF1, GE32_PMU_CFG2, AFEldo_adj, 0x0)
			ACPHY_REG_LIST_EXECUTE(pi);
			if ((pi->u.pi_acphy->srom_txnospurmod2g == 0) &&
			    (PHY_XTAL_IS37M4(pi))) {
				if (fc == 2412) {
				    ACPHY_REG_LIST_START
					/* setting 200khz loopbw */
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_CP4, 0xBC28)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF2, 0xFFD4)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF3, 0xF3F9)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF4, 0xA)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF5, 0xA)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF7, 0xC65)
				    ACPHY_REG_LIST_EXECUTE(pi);
				}
				if (fc == 2467) {
				    ACPHY_REG_LIST_START
					/* setting 200khz loopbw */
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_CP4, 0xBC28)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF2, 0xFDCF)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF3, 0xEDF3)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF4, 0xB)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF5, 0xB)
					WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF7, 0xC68)
				    ACPHY_REG_LIST_EXECUTE(pi);
				}
			}
		}
	} else if ((PHY_IPA(pi)) && (CHSPEC_IS80(pi->radio_chanspec))) {
		MOD_RADIO_REG(pi, RFP, GE16_AFEDIV1,
		    afediv_main_driver_size, 0xb);
	}

}
static void
wlc_phy_chanspec_radio2069_setup(phy_info_t *pi, const void *chan_info, uint8 toggle_logen_reset)
{
	uint8 core;
	uint32 fc = wf_channel2mhz(CHSPEC_CHANNEL(pi->radio_chanspec),
		CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
		: WF_CHAN_FACTOR_5_G);

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	ASSERT(chan_info != NULL);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* logen_reset needs to be toggled whnenever bandsel bit if changed */
	/* On a bw change, phy_reset is issued which causes currentBand getting reset to 0 */
	/* So, issue this on both band & bw change */
	if (toggle_logen_reset == 1) {
		MOD_PHYREG(pi, RfctrlCoreTxPus0, logen_reset, 1);
		OSL_DELAY(1);
		MOD_PHYREG(pi, RfctrlCoreTxPus0, logen_reset, 0);
	}

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		const chan_info_radio2069revGE32_t *ciGE32 = chan_info;

		write_radio_reg(pi, RFP_2069_PLL_VCOCAL5, ciGE32->RFP_pll_vcocal5);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL6, ciGE32->RFP_pll_vcocal6);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL2, ciGE32->RFP_pll_vcocal2);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL1, ciGE32->RFP_pll_vcocal1);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL11, ciGE32->RFP_pll_vcocal11);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL12, ciGE32->RFP_pll_vcocal12);
		write_radio_reg(pi, RFP_2069_PLL_FRCT2, ciGE32->RFP_pll_frct2);
		write_radio_reg(pi, RFP_2069_PLL_FRCT3, ciGE32->RFP_pll_frct3);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL10, ciGE32->RFP_pll_vcocal10);
		write_radio_reg(pi, RFP_2069_PLL_XTAL3, ciGE32->RFP_pll_xtal3);
		write_radio_reg(pi, RFP_2069_PLL_VCO2, ciGE32->RFP_pll_vco2);
		write_radio_reg(pi, RF0_2069_LOGEN5G_CFG1, ciGE32->RFP_logen5g_cfg1);
		write_radio_reg(pi, RFP_2069_PLL_VCO8, ciGE32->RFP_pll_vco8);
		write_radio_reg(pi, RFP_2069_PLL_VCO6, ciGE32->RFP_pll_vco6);
		write_radio_reg(pi, RFP_2069_PLL_VCO3, ciGE32->RFP_pll_vco3);
		write_radio_reg(pi, RFP_2069_PLL_XTALLDO1, ciGE32->RFP_pll_xtalldo1);
		write_radio_reg(pi, RFP_2069_PLL_HVLDO1, ciGE32->RFP_pll_hvldo1);
		write_radio_reg(pi, RFP_2069_PLL_HVLDO2, ciGE32->RFP_pll_hvldo2);
		write_radio_reg(pi, RFP_2069_PLL_VCO5, ciGE32->RFP_pll_vco5);
		write_radio_reg(pi, RFP_2069_PLL_VCO4, ciGE32->RFP_pll_vco4);
		write_radio_reg(pi, RFP_2069_PLL_LF4, ciGE32->RFP_pll_lf4);
		write_radio_reg(pi, RFP_2069_PLL_LF5, ciGE32->RFP_pll_lf5);
		write_radio_reg(pi, RFP_2069_PLL_LF7, ciGE32->RFP_pll_lf7);
		write_radio_reg(pi, RFP_2069_PLL_LF2, ciGE32->RFP_pll_lf2);
		write_radio_reg(pi, RFP_2069_PLL_LF3, ciGE32->RFP_pll_lf3);
		write_radio_reg(pi, RFP_2069_PLL_CP4, ciGE32->RFP_pll_cp4);
		write_radio_reg(pi, RFP_2069_PLL_LF6, ciGE32->RFP_pll_lf6);
		write_radio_reg(pi, RFP_2069_PLL_XTAL4, ciGE32->RFP_pll_xtal4);
		write_radio_reg(pi, RF0_2069_LOGEN2G_TUNE, ciGE32->RFP_logen2g_tune);
		write_radio_reg(pi, RFX_2069_LNA2G_TUNE, ciGE32->RFX_lna2g_tune);
		write_radio_reg(pi, RFX_2069_TXMIX2G_CFG1, ciGE32->RFX_txmix2g_cfg1);
		write_radio_reg(pi, RFX_2069_PGA2G_CFG2, ciGE32->RFX_pga2g_cfg2);
		write_radio_reg(pi, RFX_2069_PAD2G_TUNE, ciGE32->RFX_pad2g_tune);
		write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE1, ciGE32->RFP_logen5g_tune1);
		write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE2, ciGE32->RFP_logen5g_tune2);
		write_radio_reg(pi, RF0_2069_LOGEN5G_IDAC1, ciGE32->RFP_logen5g_idac1);
		write_radio_reg(pi, RFX_2069_LNA5G_TUNE, ciGE32->RFX_lna5g_tune);
		write_radio_reg(pi, RFX_2069_TXMIX5G_CFG1, ciGE32->RFX_txmix5g_cfg1);
		write_radio_reg(pi, RFX_2069_PGA5G_CFG2, ciGE32->RFX_pga5g_cfg2);
		write_radio_reg(pi, RFX_2069_PAD5G_TUNE, ciGE32->RFX_pad5g_tune);

		if (((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
		     (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
		     (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
		     (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
		    (pi->sh->chippkg == 2) && PHY_XTAL_IS37M4(pi)) {
			if (fc == 5290) {
			    ACPHY_REG_LIST_START
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL5, 0X5)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL6, 0x1C)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL2, 0xA09)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL1, 0xF89)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL11, 0xD4)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL12, 0x2A70)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_FRCT2, 0x350)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_FRCT3, 0xA9C1)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL10, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTAL3, 0x488)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO2, 0xCE8)
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_LOGEN5G_CFG1, 0x40)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO8, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO6, 0x1D6f)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO3, 0x1F00)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTALLDO1, 0x780)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_HVLDO1, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_HVLDO2, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO5, 0x49C)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO4, 0x3504)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF4, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF5, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF7, 0xD6F)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF2, 0xECBE)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF3, 0xDDE2)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_CP4, 0xBC28)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF6, 0x1)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTAL4, 0x36FF)
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_LOGEN5G_TUNE1, 0x80)
			    ACPHY_REG_LIST_EXECUTE(pi);
			} else if (fc == 5180) {
			    ACPHY_REG_LIST_START
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL5, 0x5)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL6, 0x1C)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL2, 0xA09)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL1, 0xF37)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL11, 0xCF)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL12, 0xC106)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_FRCT2, 0x33F)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_FRCT3, 0x41B)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCOCAL10, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTAL3, 0x488)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO2, 0xCE8)
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_LOGEN5G_CFG1, 0x40)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO8, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO6, 0x1D6F)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO3, 0x1F00)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTALLDO1, 0x780)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_HVLDO1, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_HVLDO2, 0x0)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO5, 0x49C)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_VCO4, 0x3505)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF4, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF5, 0xB)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF7, 0xD6D)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF2, 0xF1C3)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF3, 0xE2E7)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_CP4, 0xBC28)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF6, 0x1)
				WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_XTAL4, 0x36CF)
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_LOGEN5G_TUNE1, 0xA0)
			    ACPHY_REG_LIST_EXECUTE(pi);
			}
		}

		/* Move nbclip by 2dBs to the right */
		FOREACH_CORE(pi, core) {
			MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_ib_Refladder, 7);
			MOD_RADIO_REGC(pi, DAC_CFG1, core, DAC_invclk, 1);
		}

		/* Fix drift/unlock behavior */
		MOD_RADIO_REG(pi, RFP, PLL_CFG3, rfpll_spare1, 0x8);

	} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
		if ((RADIOREV(pi->pubpi.radiorev) != 25) && (RADIOREV(pi->pubpi.radiorev) != 26)) {
			const chan_info_radio2069revGE16_t *ciGE16 = chan_info;

			write_radio_reg(pi, RFP_2069_PLL_VCOCAL5, ciGE16->RFP_pll_vcocal5);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL6, ciGE16->RFP_pll_vcocal6);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL2, ciGE16->RFP_pll_vcocal2);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL1, ciGE16->RFP_pll_vcocal1);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL11, ciGE16->RFP_pll_vcocal11);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL12, ciGE16->RFP_pll_vcocal12);
			write_radio_reg(pi, RFP_2069_PLL_FRCT2, ciGE16->RFP_pll_frct2);
			write_radio_reg(pi, RFP_2069_PLL_FRCT3, ciGE16->RFP_pll_frct3);
			write_radio_reg(pi, RFP_2069_PLL_VCOCAL10, ciGE16->RFP_pll_vcocal10);
			write_radio_reg(pi, RFP_2069_PLL_XTAL3, ciGE16->RFP_pll_xtal3);
			write_radio_reg(pi, RFP_2069_PLL_VCO2, ciGE16->RFP_pll_vco2);
			write_radio_reg(pi, RF0_2069_LOGEN5G_CFG1, ciGE16->RFP_logen5g_cfg1);
			write_radio_reg(pi, RFP_2069_PLL_VCO8, ciGE16->RFP_pll_vco8);
			write_radio_reg(pi, RFP_2069_PLL_VCO6, ciGE16->RFP_pll_vco6);
			write_radio_reg(pi, RFP_2069_PLL_VCO3, ciGE16->RFP_pll_vco3);
			write_radio_reg(pi, RFP_2069_PLL_XTALLDO1, ciGE16->RFP_pll_xtalldo1);
			write_radio_reg(pi, RFP_2069_PLL_HVLDO1, ciGE16->RFP_pll_hvldo1);
			write_radio_reg(pi, RFP_2069_PLL_HVLDO2, ciGE16->RFP_pll_hvldo2);
			write_radio_reg(pi, RFP_2069_PLL_VCO5, ciGE16->RFP_pll_vco5);
			write_radio_reg(pi, RFP_2069_PLL_VCO4, ciGE16->RFP_pll_vco4);

			write_radio_reg(pi, RFP_2069_PLL_LF4, ciGE16->RFP_pll_lf4);
			write_radio_reg(pi, RFP_2069_PLL_LF5, ciGE16->RFP_pll_lf5);
			write_radio_reg(pi, RFP_2069_PLL_LF7, ciGE16->RFP_pll_lf7);
			write_radio_reg(pi, RFP_2069_PLL_LF2, ciGE16->RFP_pll_lf2);
			write_radio_reg(pi, RFP_2069_PLL_LF3, ciGE16->RFP_pll_lf3);
			write_radio_reg(pi, RFP_2069_PLL_CP4, ciGE16->RFP_pll_cp4);
			write_radio_reg(pi, RFP_2069_PLL_LF6, ciGE16->RFP_pll_lf6);

			write_radio_reg(pi, RF0_2069_LOGEN2G_TUNE, ciGE16->RFP_logen2g_tune);
			write_radio_reg(pi, RF0_2069_LNA2G_TUNE, ciGE16->RF0_lna2g_tune);
			write_radio_reg(pi, RF0_2069_TXMIX2G_CFG1, ciGE16->RF0_txmix2g_cfg1);
			write_radio_reg(pi, RF0_2069_PGA2G_CFG2, ciGE16->RF0_pga2g_cfg2);
			write_radio_reg(pi, RF0_2069_PAD2G_TUNE, ciGE16->RF0_pad2g_tune);
			write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE1, ciGE16->RFP_logen5g_tune1);
			write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE2, ciGE16->RFP_logen5g_tune2);
			write_radio_reg(pi, RF0_2069_LOGEN5G_RCCR, ciGE16->RF0_logen5g_rccr);
			write_radio_reg(pi, RF0_2069_LNA5G_TUNE, ciGE16->RF0_lna5g_tune);
			write_radio_reg(pi, RF0_2069_TXMIX5G_CFG1, ciGE16->RF0_txmix5g_cfg1);
			write_radio_reg(pi, RF0_2069_PGA5G_CFG2, ciGE16->RF0_pga5g_cfg2);
			write_radio_reg(pi, RF0_2069_PAD5G_TUNE, ciGE16->RF0_pad5g_tune);
			/*
			* write_radio_reg(pi, RFP_2069_PLL_CP5, ciGE16->RFP_pll_cp5);
			* write_radio_reg(pi, RF0_2069_AFEDIV1, ciGE16->RF0_afediv1);
			* write_radio_reg(pi, RF0_2069_AFEDIV2, ciGE16->RF0_afediv2);
			* write_radio_reg(pi, RF0_2069_ADC_CFG5, ciGE16->RF0_adc_cfg5);
			*/

		} else {
			if (!PHY_XTAL_IS52M(pi)) {
				const chan_info_radio2069revGE25_t *ciGE25 = chan_info;
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL5, ciGE25->RFP_pll_vcocal5);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL6, ciGE25->RFP_pll_vcocal6);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL2, ciGE25->RFP_pll_vcocal2);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL1, ciGE25->RFP_pll_vcocal1);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL11,
					ciGE25->RFP_pll_vcocal11);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL12,
					ciGE25->RFP_pll_vcocal12);
				write_radio_reg(pi, RFP_2069_PLL_FRCT2, ciGE25->RFP_pll_frct2);
				write_radio_reg(pi, RFP_2069_PLL_FRCT3, ciGE25->RFP_pll_frct3);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL10,
					ciGE25->RFP_pll_vcocal10);
				write_radio_reg(pi, RFP_2069_PLL_XTAL3, ciGE25->RFP_pll_xtal3);
				write_radio_reg(pi, RFP_2069_PLL_CFG3, ciGE25->RFP_pll_cfg3);
				write_radio_reg(pi, RFP_2069_PLL_VCO2, ciGE25->RFP_pll_vco2);
				write_radio_reg(pi, RF0_2069_LOGEN5G_CFG1,
					ciGE25->RFP_logen5g_cfg1);
				write_radio_reg(pi, RFP_2069_PLL_VCO8, ciGE25->RFP_pll_vco8);
				write_radio_reg(pi, RFP_2069_PLL_VCO6, ciGE25->RFP_pll_vco6);
				write_radio_reg(pi, RFP_2069_PLL_VCO3, ciGE25->RFP_pll_vco3);
				write_radio_reg(pi, RFP_2069_PLL_XTALLDO1,
					ciGE25->RFP_pll_xtalldo1);
				write_radio_reg(pi, RFP_2069_PLL_HVLDO1, ciGE25->RFP_pll_hvldo1);
				write_radio_reg(pi, RFP_2069_PLL_HVLDO2, ciGE25->RFP_pll_hvldo2);
				write_radio_reg(pi, RFP_2069_PLL_VCO5, ciGE25->RFP_pll_vco5);
				write_radio_reg(pi, RFP_2069_PLL_VCO4, ciGE25->RFP_pll_vco4);

				write_radio_reg(pi, RFP_2069_PLL_LF4, ciGE25->RFP_pll_lf4);
				write_radio_reg(pi, RFP_2069_PLL_LF5, ciGE25->RFP_pll_lf5);
				write_radio_reg(pi, RFP_2069_PLL_LF7, ciGE25->RFP_pll_lf7);
				write_radio_reg(pi, RFP_2069_PLL_LF2, ciGE25->RFP_pll_lf2);
				write_radio_reg(pi, RFP_2069_PLL_LF3, ciGE25->RFP_pll_lf3);
				write_radio_reg(pi, RFP_2069_PLL_CP4, ciGE25->RFP_pll_cp4);
				write_radio_reg(pi, RFP_2069_PLL_LF6, ciGE25->RFP_pll_lf6);

				write_radio_reg(pi, RF0_2069_LOGEN2G_TUNE,
					ciGE25->RFP_logen2g_tune);
				write_radio_reg(pi, RF0_2069_LNA2G_TUNE, ciGE25->RF0_lna2g_tune);
				write_radio_reg(pi, RF0_2069_TXMIX2G_CFG1,
					ciGE25->RF0_txmix2g_cfg1);
				write_radio_reg(pi, RF0_2069_PGA2G_CFG2, ciGE25->RF0_pga2g_cfg2);
				write_radio_reg(pi, RF0_2069_PAD2G_TUNE, ciGE25->RF0_pad2g_tune);
				write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE1,
					ciGE25->RFP_logen5g_tune1);
				write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE2,
					ciGE25->RFP_logen5g_tune2);
				write_radio_reg(pi, RF0_2069_LOGEN5G_RCCR,
					ciGE25->RF0_logen5g_rccr);
				write_radio_reg(pi, RF0_2069_LNA5G_TUNE, ciGE25->RF0_lna5g_tune);
				write_radio_reg(pi, RF0_2069_TXMIX5G_CFG1,
					ciGE25->RF0_txmix5g_cfg1);
				write_radio_reg(pi, RF0_2069_PGA5G_CFG2, ciGE25->RF0_pga5g_cfg2);
				write_radio_reg(pi, RF0_2069_PAD5G_TUNE, ciGE25->RF0_pad5g_tune);

				/*
				* write_radio_reg(pi, RFP_2069_PLL_CP5, ciGE25->RFP_pll_cp5);
				* write_radio_reg(pi, RF0_2069_AFEDIV1, ciGE25->RF0_afediv1);
				* write_radio_reg(pi, RF0_2069_AFEDIV2, ciGE25->RF0_afediv2);
				* write_radio_reg(pi, RF0_2069_ADC_CFG5, ciGE25->RF0_adc_cfg5);
				*/

			} else {
				const chan_info_radio2069revGE25_52MHz_t *ciGE25 = chan_info;

				write_radio_reg(pi, RFP_2069_PLL_VCOCAL5, ciGE25->RFP_pll_vcocal5);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL6, ciGE25->RFP_pll_vcocal6);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL2, ciGE25->RFP_pll_vcocal2);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL1, ciGE25->RFP_pll_vcocal1);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL11,
					ciGE25->RFP_pll_vcocal11);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL12,
					ciGE25->RFP_pll_vcocal12);
				write_radio_reg(pi, RFP_2069_PLL_FRCT2, ciGE25->RFP_pll_frct2);
				write_radio_reg(pi, RFP_2069_PLL_FRCT3, ciGE25->RFP_pll_frct3);
				write_radio_reg(pi, RFP_2069_PLL_VCOCAL10,
					ciGE25->RFP_pll_vcocal10);
				write_radio_reg(pi, RFP_2069_PLL_XTAL3, ciGE25->RFP_pll_xtal3);
				write_radio_reg(pi, RFP_2069_PLL_VCO2, ciGE25->RFP_pll_vco2);
				write_radio_reg(pi, RF0_2069_LOGEN5G_CFG1,
					ciGE25->RFP_logen5g_cfg1);
				write_radio_reg(pi, RFP_2069_PLL_VCO8, ciGE25->RFP_pll_vco8);
				write_radio_reg(pi, RFP_2069_PLL_VCO6, ciGE25->RFP_pll_vco6);
				write_radio_reg(pi, RFP_2069_PLL_VCO3, ciGE25->RFP_pll_vco3);
				write_radio_reg(pi, RFP_2069_PLL_XTALLDO1,
					ciGE25->RFP_pll_xtalldo1);
				write_radio_reg(pi, RFP_2069_PLL_HVLDO1, ciGE25->RFP_pll_hvldo1);
				write_radio_reg(pi, RFP_2069_PLL_HVLDO2, ciGE25->RFP_pll_hvldo2);
				write_radio_reg(pi, RFP_2069_PLL_VCO5, ciGE25->RFP_pll_vco5);
				write_radio_reg(pi, RFP_2069_PLL_VCO4, ciGE25->RFP_pll_vco4);
				write_radio_reg(pi, RFP_2069_PLL_LF4, ciGE25->RFP_pll_lf4);
				write_radio_reg(pi, RFP_2069_PLL_LF5, ciGE25->RFP_pll_lf5);
				write_radio_reg(pi, RFP_2069_PLL_LF7, ciGE25->RFP_pll_lf7);
				write_radio_reg(pi, RFP_2069_PLL_LF2, ciGE25->RFP_pll_lf2);
				write_radio_reg(pi, RFP_2069_PLL_LF3, ciGE25->RFP_pll_lf3);
				write_radio_reg(pi, RFP_2069_PLL_CP4, ciGE25->RFP_pll_cp4);
				write_radio_reg(pi, RFP_2069_PLL_LF6, ciGE25->RFP_pll_lf6);
				write_radio_reg(pi, RF0_2069_LOGEN2G_TUNE,
					ciGE25->RFP_logen2g_tune);
				write_radio_reg(pi, RF0_2069_LNA2G_TUNE, ciGE25->RF0_lna2g_tune);
				write_radio_reg(pi, RF0_2069_TXMIX2G_CFG1,
					ciGE25->RF0_txmix2g_cfg1);
				write_radio_reg(pi, RF0_2069_PGA2G_CFG2, ciGE25->RF0_pga2g_cfg2);
				write_radio_reg(pi, RF0_2069_PAD2G_TUNE, ciGE25->RF0_pad2g_tune);
				write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE1,
					ciGE25->RFP_logen5g_tune1);
				write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE2,
					ciGE25->RFP_logen5g_tune2);
				write_radio_reg(pi, RF0_2069_LOGEN5G_RCCR,
					ciGE25->RF0_logen5g_rccr);
				write_radio_reg(pi, RF0_2069_LNA5G_TUNE, ciGE25->RF0_lna5g_tune);
				write_radio_reg(pi, RF0_2069_TXMIX5G_CFG1,
					ciGE25->RF0_txmix5g_cfg1);
				write_radio_reg(pi, RF0_2069_PGA5G_CFG2, ciGE25->RF0_pga5g_cfg2);
				write_radio_reg(pi, RF0_2069_PAD5G_TUNE, ciGE25->RF0_pad5g_tune);
			}

			/* 43162 FCBGA Settings improving Tx EVM */
			/* (1) ch4/ch4m settings to reduce 500k xtal spur */
			/* (2) Rreducing 2440/2480 RX spur */
			if (RADIOREV(pi->pubpi.radiorev) == 25 && PHY_XTAL_IS40M(pi)) {
				/* 14:10 xtal_coresize_pmos<4:0> during normal operation */
				si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL0, (0x1f << 10),
					(0x8 << 10));

				/* 19:15  xtal_coresize_nmos<4:0> during normal operation */
				si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL0, (0x1f << 15),
					(0x8 << 15));

				if (CHSPEC_IS2G(pi->radio_chanspec))
					MOD_RADIO_REG(pi, RF0, PGA2G_CFG2, pga2g_tune, 0x3);

				ACPHY_REG_LIST_START
				    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_outbufBBstrg,
				        1)
				    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufBBstrg, 0)
				    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufcalstrg, 0)

				    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL5, xtal_bufstrg_BT, 0)
				    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27, ovr_xtal_xtbufstrg,
				        0x1)
				ACPHY_REG_LIST_EXECUTE(pi);

				if (CHSPEC_IS2G(pi->radio_chanspec) &&
				    CHSPEC_CHANNEL(pi->radio_chanspec) >= 12) {
				    ACPHY_REG_LIST_START
					MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_xtbufstrg, 0x0)
					MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR27,
						ovr_xtal_outbufstrg, 0x1)
					MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTAL4, xtal_outbufstrg,
						0x1)
				    ACPHY_REG_LIST_EXECUTE(pi);
				} else {
				MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_xtbufstrg, 0x7);
				MOD_RADIO_REG(pi, RFP, GE16_OVR27, ovr_xtal_outbufstrg, 0x1);

				if (CHSPEC_IS2G(pi->radio_chanspec) &&
					(CHSPEC_CHANNEL(pi->radio_chanspec) == 6 ||
					CHSPEC_CHANNEL(pi->radio_chanspec) == 7))
					MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_outbufstrg, 0x1);
				else
					MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_outbufstrg, 0x3);

				if (CHSPEC_IS2G(pi->radio_chanspec) &&
					CHSPEC_CHANNEL(pi->radio_chanspec) == 4)
					write_radio_reg(pi, RFP_2069_PLL_VCO2, 0xce4);
				}
			}
		}
	} else {
		const chan_info_radio2069_t *ci = chan_info;

		/* Write chan specific tuning register */
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL5, ci->RFP_pll_vcocal5);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL6, ci->RFP_pll_vcocal6);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL2, ci->RFP_pll_vcocal2);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL1, ci->RFP_pll_vcocal1);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL11, ci->RFP_pll_vcocal11);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL12, ci->RFP_pll_vcocal12);
		write_radio_reg(pi, RFP_2069_PLL_FRCT2, ci->RFP_pll_frct2);
		write_radio_reg(pi, RFP_2069_PLL_FRCT3, ci->RFP_pll_frct3);
		write_radio_reg(pi, RFP_2069_PLL_VCOCAL10, ci->RFP_pll_vcocal10);
		write_radio_reg(pi, RFP_2069_PLL_XTAL3, ci->RFP_pll_xtal3);
		write_radio_reg(pi, RFP_2069_PLL_VCO2, ci->RFP_pll_vco2);
		write_radio_reg(pi, RF0_2069_LOGEN5G_CFG1, ci->RF0_logen5g_cfg1);
		write_radio_reg(pi, RFP_2069_PLL_VCO8, ci->RFP_pll_vco8);
		write_radio_reg(pi, RFP_2069_PLL_VCO6, ci->RFP_pll_vco6);
		write_radio_reg(pi, RFP_2069_PLL_VCO3, ci->RFP_pll_vco3);
		write_radio_reg(pi, RFP_2069_PLL_XTALLDO1, ci->RFP_pll_xtalldo1);
		write_radio_reg(pi, RFP_2069_PLL_HVLDO1, ci->RFP_pll_hvldo1);
		write_radio_reg(pi, RFP_2069_PLL_HVLDO2, ci->RFP_pll_hvldo2);
		write_radio_reg(pi, RFP_2069_PLL_VCO5, ci->RFP_pll_vco5);
		write_radio_reg(pi, RFP_2069_PLL_VCO4, ci->RFP_pll_vco4);
		write_radio_reg(pi, RFP_2069_PLL_LF4, ci->RFP_pll_lf4);
		write_radio_reg(pi, RFP_2069_PLL_LF5, ci->RFP_pll_lf5);
		write_radio_reg(pi, RFP_2069_PLL_LF7, ci->RFP_pll_lf7);
		write_radio_reg(pi, RFP_2069_PLL_LF2, ci->RFP_pll_lf2);
		write_radio_reg(pi, RFP_2069_PLL_LF3, ci->RFP_pll_lf3);
		write_radio_reg(pi, RFP_2069_PLL_CP4, ci->RFP_pll_cp4);
		write_radio_reg(pi, RFP_2069_PLL_DSP1, ci->RFP_pll_dsp1);
		write_radio_reg(pi, RFP_2069_PLL_DSP2, ci->RFP_pll_dsp2);
		write_radio_reg(pi, RFP_2069_PLL_DSP3, ci->RFP_pll_dsp3);
		write_radio_reg(pi, RFP_2069_PLL_DSP4, ci->RFP_pll_dsp4);
		write_radio_reg(pi, RFP_2069_PLL_DSP6, ci->RFP_pll_dsp6);
		write_radio_reg(pi, RFP_2069_PLL_DSP7, ci->RFP_pll_dsp7);
		write_radio_reg(pi, RFP_2069_PLL_DSP8, ci->RFP_pll_dsp8);
		write_radio_reg(pi, RFP_2069_PLL_DSP9, ci->RFP_pll_dsp9);
		write_radio_reg(pi, RF0_2069_LOGEN2G_TUNE, ci->RF0_logen2g_tune);
		write_radio_reg(pi, RFX_2069_LNA2G_TUNE, ci->RFX_lna2g_tune);
		write_radio_reg(pi, RFX_2069_TXMIX2G_CFG1, ci->RFX_txmix2g_cfg1);
		write_radio_reg(pi, RFX_2069_PGA2G_CFG2, ci->RFX_pga2g_cfg2);
		write_radio_reg(pi, RFX_2069_PAD2G_TUNE, ci->RFX_pad2g_tune);
		write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE1, ci->RF0_logen5g_tune1);
		write_radio_reg(pi, RF0_2069_LOGEN5G_TUNE2, ci->RF0_logen5g_tune2);
		write_radio_reg(pi, RFX_2069_LOGEN5G_RCCR, ci->RFX_logen5g_rccr);
		write_radio_reg(pi, RFX_2069_LNA5G_TUNE, ci->RFX_lna5g_tune);
		write_radio_reg(pi, RFX_2069_TXMIX5G_CFG1, ci->RFX_txmix5g_cfg1);
		write_radio_reg(pi, RFX_2069_PGA5G_CFG2, ci->RFX_pga5g_cfg2);
		write_radio_reg(pi, RFX_2069_PAD5G_TUNE, ci->RFX_pad5g_tune);
		write_radio_reg(pi, RFP_2069_PLL_CP5, ci->RFP_pll_cp5);
		write_radio_reg(pi, RF0_2069_AFEDIV1, ci->RF0_afediv1);
		write_radio_reg(pi, RF0_2069_AFEDIV2, ci->RF0_afediv2);
		write_radio_reg(pi, RFX_2069_ADC_CFG5, ci->RFX_adc_cfg5);

		/* We need different values for ADC_CFG5 for cores 1 and 2
		 * in order to get the best reduction of spurs from the AFE clk
		 */
		if (RADIOREV(pi->pubpi.radiorev) < 4) {
			ACPHY_REG_LIST_START
				WRITE_RADIO_REG_ENTRY(pi, RF1_2069_ADC_CFG5, 0x3e9)
				WRITE_RADIO_REG_ENTRY(pi, RF2_2069_ADC_CFG5, 0x3e9)
				MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xa0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}

		/* Reduce 500 KHz spur at fc=2427 MHz for both 4360 A0 and B0 */
		if (CHSPEC_CHANNEL(pi->radio_chanspec) == 4) {
			write_radio_reg(pi, RFP_2069_PLL_VCO2, 0xce4);
			MOD_RADIO_REG(pi, RFP, PLL_XTAL4, xtal_xtbufstrg, 0x5);
		}

		/* Move nbclip by 2dBs to the right */
		MOD_RADIO_REG(pi, RFX, NBRSSI_CONFG, nbrssi_ib_Refladder, 7);

		/* 5g only: Changing RFPLL bandwidth to be 150MHz */
		if (CHSPEC_IS5G(pi->radio_chanspec))
			wlc_2069_rfpll_150khz(pi);

		if ((pi->u.pi_acphy->srom.gainboosta01 == 1) && !(ACREV_IS(pi->pubpi.phy_rev, 0))) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				ACPHY_REG_LIST_START
				    /* 2,4GHz: offtune to win back linear output power */
				    MOD_RADIO_REG_ENTRY(pi, RFX, PAD2G_TUNE, pad2g_tune, 0x1)
				    /* increase gain */
				    MOD_RADIO_REG_ENTRY(pi, RFX, PGA2G_CFG1, pga2g_gainboost, 0x2)
				    WRITE_RADIO_REG_ENTRY(pi, RFX_2069_PAD2G_INCAP, 0x7e7e)
				    MOD_RADIO_REG_ENTRY(pi, RFX, PAD2G_IDAC, pad2g_idac_main, 0x38)
				    MOD_RADIO_REG_ENTRY(pi, RFX, PGA2G_INCAP, pad2g_idac_aux, 0x38)
				ACPHY_REG_LIST_EXECUTE(pi);
			} else if (CHSPEC_IS5G(pi->radio_chanspec)) {
				/* increase linear output power */
				MOD_RADIO_REG(pi, RFX, PAD5G_IDAC, idac_main, 0x3d);
				MOD_RADIO_REG(pi, RFX, PAD5G_TUNE, idac_aux, 0x3d);
			}
		}
		if (pi->u.pi_acphy->srom.gainboost_core2 == 1) {
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				/* Additional boost on core 2 */
				MOD_RADIO_REGC(pi, TXMIX5G_CFG1, 2, gainboost, 0x4);
				MOD_RADIO_REGC(pi, PGA5G_CFG1, 2, gainboost, 0x4);
			}
		}
	}

	if (RADIOREV(pi->pubpi.radiorev) >= 4) {
		/* Make clamping stronger */
		write_radio_reg(pi, RFX_2069_ADC_CFG5, 0x83e0);
	}

	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) &&
	    (!(PHY_IPA(pi)))) {
	    MOD_RADIO_REG(pi, RFP, PLL_CP4, rfpll_cp_ioff, 0xe0);
	}

	/* increasing pabias to get good evm with pagain3 */
	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) &&
	    !(ACRADIO_2069_EPA_IS(pi->pubpi.radiorev))) {
		write_radio_reg(pi, RF0_2069_PA5G_IDAC2, 0x8484);

		if (PHY_IPA(pi)) {
			ACPHY_REG_LIST_START
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_LOGEN5G_IDAC1, 0x3F37)
				WRITE_RADIO_REG_ENTRY(pi, RF0_2069_PGA5G_IDAC, 0x3838)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_OVR2, ovr_bg_pulse, 1)
				MOD_RADIO_REG_ENTRY(pi, RFP, GE16_BG_CFG1, bg_pulse, 1)
			ACPHY_REG_LIST_EXECUTE(pi);

			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				MOD_RADIO_REGC(pi, PAD5G_IDAC, core, idac_main, 0x20);
				MOD_RADIO_REGC(pi, PAD5G_TUNE, core, idac_aux, 0x20);

				MOD_RADIO_REGC(pi, PA5G_INCAP, core,
					pa5g_idac_incap_compen_main, 0x8);
				MOD_RADIO_REGC(pi, PA5G_INCAP, core,
					pa5g_idac_incap_compen_aux, 0x8);
				MOD_RADIO_REGC(pi, PA2G_INCAP, core,
					pa2g_ptat_slope_incap_compen_main, 0x0);
				MOD_RADIO_REGC(pi, PA2G_INCAP, core,
					pa2g_ptat_slope_incap_compen_aux, 0x0);

				if (pi->sh->chippkg == BCM4335_FCBGA_PKG_ID) {
					MOD_RADIO_REGC(pi, PA2G_CFG2, core,
						pa2g_bias_filter_main, 0x1);
					MOD_RADIO_REGC(pi, PA2G_CFG2, core,
						pa2g_bias_filter_aux, 0x1);
				} else {
					MOD_RADIO_REGC(pi, PA2G_CFG2, core,
						pa2g_bias_filter_main, 0x3);
					MOD_RADIO_REGC(pi, PA2G_CFG2, core,
						pa2g_bias_filter_aux, 0x3);
				}

				MOD_RADIO_REGC(pi, PAD5G_INCAP, core, idac_incap_compen_main, 0xc);
				MOD_RADIO_REGC(pi, PAD5G_INCAP, core, idac_incap_compen_aux, 0xc);
				MOD_RADIO_REGC(pi, PGA5G_INCAP, core, idac_incap_compen, 0x8);
				MOD_RADIO_REGC(pi, PA5G_CFG2, core, pa5g_bias_cas, 0x58);
				MOD_RADIO_REGC(pi, PA5G_IDAC2, core, pa5g_biasa_main, 0x84);
				MOD_RADIO_REGC(pi, PA5G_IDAC2, core, pa5g_biasa_aux, 0x84);
				MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_mix5g_gainboost, 0x1);
				MOD_RADIO_REGC(pi, TXMIX5G_CFG1, core, gainboost, 0x0);
				MOD_RADIO_REGC(pi, TXGM_CFG1, core, gc_res, 0x0);
				MOD_RADIO_REGC(pi, PA2G_CFG3, core, pa2g_ptat_slope_main, 0x7);
				MOD_RADIO_REGC(pi, PAD2G_SLOPE, core, pad2g_ptat_slope_main, 0x7);
				MOD_RADIO_REGC(pi, PGA2G_CFG2, core, pga2g_ptat_slope_main, 0x7);
				MOD_RADIO_REGC(pi, PGA2G_IDAC, core, pga2g_idac_main, 0x15);
				MOD_RADIO_REGC(pi, PAD2G_TUNE, core, pad2g_idac_tuning_bias, 0xc);
				MOD_RADIO_REGC(pi, TXMIX2G_CFG1, core, lodc, 0x3);
			}
		}
	}
	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
	    PHY_IPA(pi) && (PHY_XTAL_IS37M4(pi)) &&
	    CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_RADIO_REG(pi, RF0, LOGEN2G_TUNE, logen2g_buftune, 0x7);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_RADIO_REGC(pi, TXGM_CFG1, core, gc_res, 0x0);
			MOD_RADIO_REGC(pi, PGA2G_CFG2, core, pga2g_tune, 0x3);
			MOD_RADIO_REGC(pi, PAD2G_TUNE, core, pad2g_tune, 0x7);
			MOD_RADIO_REGC(pi, PA2G_INCAP, core,
				pa2g_ptat_slope_incap_compen_main, 0x7);
			MOD_RADIO_REGC(pi, PA2G_INCAP, core,
				pa2g_ptat_slope_incap_compen_aux, 0x7);
			MOD_RADIO_REGC(pi, PA2G_CFG2, core,
				pa2g_bias_filter_main, 0x3);
			MOD_RADIO_REGC(pi, PA2G_CFG2, core,
				pa2g_bias_filter_aux, 0x3);
		}
	}
	if ((RADIOREV(pi->pubpi.radiorev) == 0x27 ||
	  RADIOREV(pi->pubpi.radiorev) == 0x29 ||
	  RADIOREV(pi->pubpi.radiorev) == 0x28 ||
	  RADIOREV(pi->pubpi.radiorev) == 0x2C ||
	  RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
	  (PHY_XTAL_IS40M(pi))) {
		ACPHY_REG_LIST_START
			/* 2G */
			MOD_RADIO_REG_ENTRY(pi, RFX, TXMIX2G_CFG1, tune, 0x1)
			MOD_RADIO_REG_ENTRY(pi, RF0, PGA2G_CFG2, pga2g_tune, 0x0)
			MOD_RADIO_REG_ENTRY(pi, RF1, PGA2G_CFG2, pga2g_tune, 0x0)
			MOD_RADIO_REG_ENTRY(pi, RFX, PAD2G_TUNE, pad2g_tune, 0x1)
			WRITE_RADIO_REG_ENTRY(pi, RF0_2069_PAD2G_INCAP, 0x7808)
			WRITE_RADIO_REG_ENTRY(pi, RF1_2069_PAD2G_INCAP, 0x7a0a)
			MOD_RADIO_REG_ENTRY(pi, RFX, PA2G_CFG2, pa2g_bias_filter_main, 0xf)
			MOD_RADIO_REG_ENTRY(pi, RFX, PA2G_CFG2, pa2g_bias_filter_aux, 0xf)
			/* 5G */
			MOD_RADIO_REG_ENTRY(pi, RF0, PGA5G_CFG2, tune, 0xa)
			MOD_RADIO_REG_ENTRY(pi, RF1, PGA5G_CFG2, tune, 0x8)
		ACPHY_REG_LIST_EXECUTE(pi);

		/* 43570 only */
		if (CST4350_IFC_MODE(pi->sh->sih->chipst) == CST4350_IFC_MODE_PCIE) {
			ACPHY_REG_LIST_START
				WRITE_RADIO_REG_ENTRY(pi, RFX_2069_PGA5G_IDAC, 0x3030)
				MOD_RADIO_REG_ENTRY(pi, RFX, PAD5G_IDAC, idac_main, 0x36)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
		wlc_phy_2069_4335_set_ovrds(pi);
	} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		wlc_phy_2069_4350_set_ovrds(pi);
	}

	/* 4335C0: Current optimization */
	acphy_set_lpmode(pi, ACPHY_LP_RADIO_LVL_OPT);

	/* Do a VCO cal after writing the tuning table regs */
	wlc_phy_radio2069_vcocal(pi);
}

static void
wlc_phy_radio_vco_opt(phy_info_t *pi, uint8 vco_mode)
{
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		wlc_phy_radio2069_4335C0_vco_opt(pi, vco_mode);
	} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		wlc_phy_radio20691_4345_vco_opt(pi, vco_mode);
	} else if (ACMAJORREV_4(pi->pubpi.phy_rev)) {
		wlc_phy_radio20693_vco_opt(pi, vco_mode);
	}
}

static void
wlc_phy_radio20691_4345_vco_opt(phy_info_t *pi, uint8 vco_mode)
{

	if (vco_mode == ACPHY_VCO_2P5V) {
		ACPHY_REG_LIST_START
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO3, 0, rfpll_vco_cvar_extra, 0xa)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO2, 0, rfpll_vco_cvar, 0xf)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO6, 0, rfpll_vco_bias_mode, 0x0)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO6, 0, rfpll_vco_ALC_ref_ctrl, 0x0)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_CP4, 0, rfpll_cp_kpd_scale, 0x21)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTALLDO1, 0,
		        ldo_1p2_xtalldo1p2_lowquiescenten, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO2, 0, ldo_2p5_lowquiescenten_VCO, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO2, 0, ldo_2p5_lowquiescenten_CP, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO4, 0, ldo_2p5_static_load_CP, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO4, 0, ldo_2p5_static_load_VCO, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);
		if (RADIO20691_MAJORREV(pi->pubpi.radiorev) != 0) {
			MOD_RADIO_REG_20691(pi, PLL_CFG3, 0, rfpll_spare1, 0x3);
		}

	} else if (vco_mode == ACPHY_VCO_1P35V) {
		ACPHY_REG_LIST_START
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO3, 0, rfpll_vco_cvar_extra, 0xf)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO2, 0, rfpll_vco_cvar, 0xf)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO6, 0, rfpll_vco_bias_mode, 0x0)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO6, 0, rfpll_vco_ALC_ref_ctrl, 0x3)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_CP4, 0, rfpll_cp_kpd_scale, 0x21)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTALLDO1, 0,
		        ldo_1p2_xtalldo1p2_lowquiescenten, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO2, 0, ldo_2p5_lowquiescenten_VCO, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO2, 0, ldo_2p5_lowquiescenten_CP, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO4, 0, ldo_2p5_static_load_CP, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO4, 0, ldo_2p5_static_load_VCO, 0x1)
		    MOD_RADIO_REG_20691_ENTRY(pi, PLL_CFG3, 0, rfpll_spare0, 0xb4)
		ACPHY_REG_LIST_EXECUTE(pi);

		MOD_RADIO_REG_20691(pi, PLL_CFG3, 0, rfpll_spare1, 0x3);
	}
}

static void
wlc_phy_radio2069_4335C0_vco_opt(phy_info_t *pi, uint8 vco_mode)
{
	uint16 temp_reg;

	if (vco_mode == ACPHY_VCO_2P5V) {
		ACPHY_REG_LIST_START
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR27, 0xfff8)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO8, rfpll_vco_vctrl_buf_ical, 0x0)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO6, rfpll_vco_bypass_vctrl_buf, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO3, rfpll_vco_cvar_extra, 0xa)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO2, rfpll_vco_cvar, 0xf)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO6, rfpll_vco_bias_mode, 0x0)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO6, rfpll_vco_ALC_ref_ctrl, 0x0)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CP4, rfpll_cp_kpd_scale, 0x21)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_HVLDO2, ldo_2p5_lowquiescenten_VCO, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_HVLDO2, ldo_2p5_lowquiescenten_CP, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_CP, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_VCO, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);

		temp_reg = read_radio_reg(pi, RFP_2069_GE16_PLL_CFG3);
		temp_reg |= (0x3 << 10);
		write_radio_reg(pi, RFP_2069_GE16_PLL_CFG3, temp_reg);

		temp_reg = read_radio_reg(pi, RFP_2069_GE16_TOP_SPARE3);
		temp_reg |= (0x3 << 11);
		write_radio_reg(pi, RFP_2069_GE16_TOP_SPARE3, temp_reg);

	} else if (vco_mode == ACPHY_VCO_1P35V) {
		ACPHY_REG_LIST_START
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_OVR27, 0xfff8)

		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO3, rfpll_vco_cvar_extra, 0xf)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO2, rfpll_vco_cvar, 0xf)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO6, rfpll_vco_bias_mode, 0x0)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_VCO6, rfpll_vco_ALC_ref_ctrl, 0x0)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_CP4, rfpll_cp_kpd_scale, 0x21)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_XTALLDO1, ldo_1p2_xtalldo1p2_lowquiescenten,
		        0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_HVLDO2, ldo_2p5_lowquiescenten_VCO, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, PLL_HVLDO2, ldo_2p5_lowquiescenten_CP, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_CP, 0x1)
		    MOD_RADIO_REG_ENTRY(pi, RFP, GE16_PLL_HVLDO4, ldo_2p5_static_load_VCO, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);

		temp_reg = read_radio_reg(pi, RFP_2069_GE16_PLL_CFG4);
		temp_reg |= (0x3 << 12);
		write_radio_reg(pi, RFP_2069_GE16_PLL_CFG4, temp_reg);

		MOD_RADIO_REG(pi, RFP, PLL_VCO2, rfpll_vco_USE_2p5V, 0x0);

		temp_reg = read_radio_reg(pi, RFP_2069_GE16_PLL_CFG3);
		temp_reg |= (0x3 << 10);
		write_radio_reg(pi, RFP_2069_GE16_PLL_CFG3, temp_reg);

		temp_reg = read_radio_reg(pi, RFP_2069_GE16_TOP_SPARE3);
		temp_reg |= (0x3 << 11);
		write_radio_reg(pi, RFP_2069_GE16_TOP_SPARE3, temp_reg);

		ACPHY_REG_LIST_START
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_PLL_LF2, 0x5555)
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_PLL_LF3, 0x5555)
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_PLL_LF4, 0xe)
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_PLL_LF5, 0xe)
		    WRITE_RADIO_REG_ENTRY(pi, RFP_2069_GE16_PLL_LF7, 0x1085)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

}

static void
wlc_phy_radio20691_xtal_tune_prep(phy_info_t *pi)
{
	/* Enable before changing channel */
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL1, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_caldrv, 0x1)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_radio20691_xtal_tune(phy_info_t *pi)
{
	/* Channel has changed */

	ACPHY_REG_LIST_START
	    /*
	     * These will only work with BT held in reset.
	     * Write the BT CLB register equivalent to 0x0 through backplane to get this to work
	     * in BT+WLAN mode
	     */
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL_OVR1, 0, ovr_xtal_pu_corebuf_pfd, 0x1)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_corebuf_pfd, 0x0)

	/* This will only work if BT is held at reset. CANNOT use it in either BT or BT+WLAN mode */
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_BT, 0x0)

	    /* To reduce a few of the output strengths a bit */
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL6, 0, xtal_bufstrg_HSIC, 0x4)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL6, 0, xtal_bufstrg_gci, 0x4)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL4, 0, xtal_outbufstrg, 0x4)

	    /* !!! Seb's changes !!! */
	    WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, PLL_XTALLDO1, 0), 0x01ce)
	    WRITE_RADIO_REG_ENTRY(pi, RADIO_REG_20691(pi, PLL_XTAL3, 0), 0x488)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_HSIC, 0x0)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL4, 0, xtal_outbufBBstrg, 0x0)

	    /* Return the following to zero after channel change */
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL, 0x0)
	    MOD_RADIO_REG_20691_ENTRY(pi, PLL_XTAL2, 0, xtal_pu_RCCAL1, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_chanspec_radio20691_setup(phy_info_t *pi, const void *chan_info, uint8 toggle_logen_reset)
{
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	const chan_info_radio20691_t *ci20691 = chan_info;
	uint8 itr = 0;
	uint8 ovr_rxdiv2g_rs = 0;
	uint8 ovr_rxdiv2g_pu_bias = 0;

	ASSERT(chan_info != NULL);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (CHSPEC_IS2G(pi->radio_chanspec))
	{
		/* save the ovr_rxdiv2g radio registers */
		ovr_rxdiv2g_rs = READ_RADIO_REGFLD_20691(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_rs);
		ovr_rxdiv2g_pu_bias = READ_RADIO_REGFLD_20691(pi, RX_TOP_2G_OVR_EAST, 0,
		                                              ovr_rxdiv2g_pu_bias);

		/* disable trimodal DC WAR */
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_rs, 0);
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_pu_bias, 0);
	}

	wlc_phy_radio20691_xtal_tune_prep(pi);

	/* logen_reset needs to be toggled whenever bandsel bit if changed */
	/* On a bw change, phy_reset is issued which causes currentBand getting reset to 0 */
	/* So, issue this on both band & bw change */
	if (toggle_logen_reset == 1) {
		MOD_PHYREG(pi, RfctrlCoreTxPus0, logen_reset, 1);
		OSL_DELAY(1);
		MOD_PHYREG(pi, RfctrlCoreTxPus0, logen_reset, 0);
	}
	/* 20691_radio_tune() */
	/* Write chan specific tuning register */
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL4, 0), ci20691->RF_pll_vcocal4);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL6, 0), ci20691->RF_pll_vcocal6);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL2, 0), ci20691->RF_pll_vcocal2);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL1, 0), ci20691->RF_pll_vcocal1);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL11, 0), ci20691->RF_pll_vcocal11);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL12, 0), ci20691->RF_pll_vcocal12);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_FRCT2, 0), ci20691->RF_pll_frct2);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_FRCT3, 0), ci20691->RF_pll_frct3);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCOCAL10, 0), ci20691->RF_pll_vcocal10);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_XTAL3, 0), ci20691->RF_pll_xtal3);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCO2, 0), ci20691->RF_pll_vco2);
	write_radio_reg(pi, RADIO_REG_20691(pi, LOGEN_CFG2, 0), ci20691->RF_logen_cfg2);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCO3, 0), ci20691->RF_pll_vco3);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_XTALLDO1, 0), ci20691->RF_pll_xtalldo1);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_HVLDO1, 0), ci20691->RF_pll_hvldo1);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_HVLDO2, 0), ci20691->RF_pll_hvldo2);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCO6, 0), ci20691->RF_pll_vco6);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCO5, 0), ci20691->RF_pll_vco5);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_VCO4, 0), ci20691->RF_pll_vco4);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF4, 0), ci20691->RF_pll_lf4);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF5, 0), ci20691->RF_pll_lf5);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF7, 0), ci20691->RF_pll_lf7);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF2, 0), ci20691->RF_pll_lf2);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF3, 0), ci20691->RF_pll_lf3);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_CP4, 0), ci20691->RF_pll_cp4);
	write_radio_reg(pi, RADIO_REG_20691(pi, PLL_LF6, 0), ci20691->RF_pll_lf6);
	write_radio_reg(pi, RADIO_REG_20691(pi, LOGEN_CFG1, 0), ci20691->RF_logen_cfg1);
	write_radio_reg(pi, RADIO_REG_20691(pi, LNA2G_TUNE, 0), ci20691->RF_lna2g_tune);
	write_radio_reg(pi, RADIO_REG_20691(pi, TXMIX2G_CFG5, 0), ci20691->RF_txmix2g_cfg5);
	write_radio_reg(pi, RADIO_REG_20691(pi, PA2G_CFG2, 0), ci20691->RF_pa2g_cfg2);
	write_radio_reg(pi, RADIO_REG_20691(pi, LNA5G_TUNE, 0), ci20691->RF_lna5g_tune);
	write_radio_reg(pi, RADIO_REG_20691(pi, TXMIX5G_CFG6, 0), ci20691->RF_txmix5g_cfg6);
	write_radio_reg(pi, RADIO_REG_20691(pi, PA5G_CFG4, 0), ci20691->RF_pa5g_cfg4);

	/* # The reset/preferred value for ldo_vco and ldo_cp is 0 which is correct
	 * # The above tuning function writes to the whole hvldo register, instead of
	 * read-modify-write (easy for driver guys) and puts back the ldo_vco and ldo_cp
	 * registers to 0 (i.e. to their preferred values)
	 * # The problem is that PHY is not using direct control to turn on ldo_VCO and
	 * ldo_CP and hence it is important to make sure that the radio jtag value for
	 * these is 1 and not 0
	 */

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO1, 0, ldo_2p5_pu_ldo_VCO, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_HVLDO1, 0, ldo_2p5_pu_ldo_CP, 1)

		/* 4345a0: Current optimization */
		/* Value for normal power mode, moved out of wlc_phy_radio20691_vcocal(). */
		MOD_RADIO_REG_20691_ENTRY(pi, PLL_VCO6, 0, rfpll_vco_ALC_ref_ctrl, 0xf)
	ACPHY_REG_LIST_EXECUTE(pi);
	acphy_set_lpmode(pi, ACPHY_LP_RADIO_LVL_OPT);

	/* Do a VCO cal after writing the tuning table regs */
	do {
		wlc_phy_radio20691_vcocal(pi);
		itr++;
		if (itr > 2)
			break;
	} while (READ_RADIO_REGFLD_20691(pi, PLL_DSPR27, 0, rfpll_monitor_need_refresh) == 1);

	wlc_phy_radio20691_xtal_tune(pi);

	if ((RADIO20691_MAJORREV(radio_rev) != 0) && !(PHY_IPA(pi))) {
		uint8	ch = CHSPEC_CHANNEL(pi->radio_chanspec);
		uint32	fc = wf_channel2mhz(ch, CHSPEC_IS2G(pi->radio_chanspec) ?
			WF_CHAN_FACTOR_2_4_G : WF_CHAN_FACTOR_5_G);
		if (CHSPEC_IS40(pi->radio_chanspec) && (fc <= 5320) && (fc >= 4920)) {
			/* logen in 4/3 mode, for 4345 chip. this mode is to fix spurs */
			ACPHY_REG_LIST_START
			    MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_5g_pu, 1)
			    MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_5g_pu, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_5g_en_lowband, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
			pi->u.pi_acphy->logenmode43 = 1;
		} else {
			MOD_RADIO_REG_20691(pi, LOGEN_OVR1, 0, ovr_logencore_5g_pu, 0);
			MOD_RADIO_REG_20691(pi, LOGEN_CFG2, 0, logencore_5g_en_lowband, 0);
			pi->u.pi_acphy->logenmode43 = 0;
		}
	}

	/* restore the ovr_rxdiv2g radio registers */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_rs, ovr_rxdiv2g_rs);
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_pu_bias,
		                    ovr_rxdiv2g_pu_bias);
	}
}

void
wlc_2069_rfpll_150khz(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_LF4, rfpll_lf_lf_r1, 0)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_LF4, rfpll_lf_lf_r2, 2)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF5, 2)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_LF7, rfpll_lf_lf_rs_cm, 2)
		MOD_RADIO_REG_ENTRY(pi, RFP, PLL_LF7, rfpll_lf_lf_rf_cm, 0xff)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF2, 0xffff)
		WRITE_RADIO_REG_ENTRY(pi, RFP_2069_PLL_LF3, 0xffff)
	ACPHY_REG_LIST_EXECUTE(pi);
}
void
wlc_phy_force_femreset_acphy(phy_info_t *pi, bool ovr)
{
	uint8 core;
	if (ovr) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			/* Force reset state by zeroing out the FEM ctrl inputs */
			WRITE_PHYREGCE(pi, RfctrlIntc, core, 0x1c00);
		}
		MOD_PHYREG(pi, AntSelConfig, AntCfg_OverrideEn, 1);
		MOD_PHYREG(pi, AntSelConfig, AntCfg_Override, 0);
	} else {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			/* Remove overrides */
			WRITE_PHYREGCE(pi, RfctrlIntc, core, 0x0000);
		}
		MOD_PHYREG(pi, AntSelConfig, AntCfg_OverrideEn, 0);
	}
}

void
wlc_phy_force_rfseq_noLoleakage_acphy(phy_info_t *pi)
{
	uint8 core;
	if (PHY_IPA(pi)) {
		/* Turn Off iPA in override mode */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, pa_pwrup, 1);
			MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, pa_pwrup, 0);
		}
	}
	wlc_phy_force_femreset_acphy(pi, TRUE);

	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RX2TX);
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_TX2RX);

	if (PHY_IPA(pi)) {
		/* Remove override for iPA power up */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, pa_pwrup, 0);
		}
	}
	wlc_phy_force_femreset_acphy(pi, FALSE);
}

void
wlc_phy_force_rfseq_acphy(phy_info_t *pi, uint8 cmd)
{
	uint16 trigger_mask, status_mask;
	uint16 orig_RfseqCoreActv, orig_rxfectrl1;

	switch (cmd) {
	case ACPHY_RFSEQ_RX2TX:
		trigger_mask = ACPHY_RfseqTrigger_rx2tx_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_rx2tx_MASK(pi->pubpi.phy_rev);
		break;
	case ACPHY_RFSEQ_TX2RX:
		trigger_mask = ACPHY_RfseqTrigger_tx2rx_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_tx2rx_MASK(pi->pubpi.phy_rev);
		break;
	case ACPHY_RFSEQ_RESET2RX:
		trigger_mask = ACPHY_RfseqTrigger_reset2rx_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_reset2rx_MASK(pi->pubpi.phy_rev);
		break;
	case ACPHY_RFSEQ_UPDATEGAINH:
		trigger_mask = ACPHY_RfseqTrigger_updategainh_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_updategainh_MASK(pi->pubpi.phy_rev);
		break;
	case ACPHY_RFSEQ_UPDATEGAINL:
		trigger_mask = ACPHY_RfseqTrigger_updategainl_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_updategainl_MASK(pi->pubpi.phy_rev);
		break;
	case ACPHY_RFSEQ_UPDATEGAINU:
		trigger_mask = ACPHY_RfseqTrigger_updategainu_MASK(pi->pubpi.phy_rev);
		status_mask = ACPHY_RfseqStatus0_updategainu_MASK(pi->pubpi.phy_rev);
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unknown cmd %d\n", pi->sh->unit, __FUNCTION__, cmd));
		return;
	}

	/* Save */
	orig_RfseqCoreActv = READ_PHYREG(pi, RfseqMode);
	orig_rxfectrl1 = READ_PHYREG(pi, RxFeCtrl1);

	MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, 1);

	/* Trigger */
	phy_reg_or(pi, ACPHY_RfseqMode(pi->pubpi.phy_rev),
		(ACPHY_RfseqMode_CoreActv_override_MASK(pi->pubpi.phy_rev) |
		ACPHY_RfseqMode_Trigger_override_MASK(pi->pubpi.phy_rev)));
	phy_reg_or(pi, ACPHY_RfseqTrigger(pi->pubpi.phy_rev), trigger_mask);
	SPINWAIT((READ_PHYREG(pi, RfseqStatus0) & status_mask), ACPHY_SPINWAIT_RFSEQ_FORCE);
	ASSERT((READ_PHYREG(pi, RfseqStatus0) & status_mask) == 0);

	/* Restore */
	WRITE_PHYREG(pi, RfseqMode, orig_RfseqCoreActv);
	WRITE_PHYREG(pi, RxFeCtrl1, orig_rxfectrl1);

	if (ACMAJORREV_1(pi->pubpi.phy_rev))
		return;

	ASSERT((READ_PHYREG(pi, RfseqStatus0) & status_mask) == 0);
}

/*
gmult_rc (24:17), gmult(16:9), bq1_bw(8:6), rc_bw(5:3), bq0_bw(2:0)
LO: (15:0), HI (24:16)
mode_mask = bits[0:8] = 11b_20, 11n_20, 11ag_11ac_20, 11b_40, 11n_40, 11ag_11ac_40, 11b_80,
11n_11ag_11ac_80, samp_play
*/
void wlc_phy_set_analog_tx_lpf(phy_info_t *pi, uint16 mode_mask, int bq0_bw, int bq1_bw,
                               int rc_bw, int gmult, int gmult_rc, int core_num)
{
	uint8 ctr, core, max_modes = 9;
	uint16 addr_lo_offs[] = {0x142, 0x152, 0x162};
	uint16 addr_hi_offs[] = {0x362, 0x372, 0x382};
	uint16 addr_lo_base, addr_hi_base, addr_lo, addr_hi;
	uint16 val_lo, val_hi;
	uint32 val;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	/* core_num = -1 ==> all cores */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if ((core_num == -1) || (core_num == core)) {
			addr_lo_base = addr_lo_offs[core];
			addr_hi_base = addr_hi_offs[core];
			for (ctr = 0; ctr < max_modes; ctr++) {
				if ((mode_mask >> ctr) & 1) {
					addr_lo = addr_lo_base + ctr;
					addr_hi = addr_hi_base + ctr;
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                         1, addr_lo, 16, &val_lo);
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                         1, addr_hi, 16, &val_hi);
					val = (val_hi << 16) | val_lo;

					if (bq0_bw >= 0) {
						val = (val & 0x1fffff8) | (bq0_bw << 0);
						}
					if (rc_bw >= 0) {
						val = (val & 0x1ffffc7) | (rc_bw << 3);
					}
					if (bq1_bw >= 0) {
						val = (val & 0x1fffe3f) | (bq1_bw << 6);
					}
					if (gmult >= 0) {
						val = (val & 0x1fe01ff) | (gmult << 9);
					}
					if (gmult_rc >= 0) {
						val = (val & 0x001ffff) | (gmult_rc << 17);
					}

					val_lo = val & 0xffff;
					val_hi = (val >> 16) & 0x1ff;
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                          1, addr_lo, 16, &val_lo);
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                          1, addr_hi, 16, &val_hi);
				}
			}
		}
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

/*
gmult_rc (24:17), rc_bw(16:14), gmult(13:6), bq1_bw(5:3), bq0_bw(2:0)
LO: (15:0), HI (24:16)
mode_mask = bits[0:2] = 20, 40, 80
*/
void
wlc_phy_set_analog_rx_lpf(phy_info_t *pi, uint8 mode_mask, int bq0_bw, int bq1_bw,
                          int rc_bw, int gmult, int gmult_rc, int core_num)
{
	uint8 ctr, core, max_modes = 3;
	uint16 addr20_lo_offs[] = {0x140, 0x150, 0x160};
	uint16 addr20_hi_offs[] = {0x360, 0x370, 0x380};
	uint16 addr40_lo_offs[] = {0x141, 0x151, 0x161};
	uint16 addr40_hi_offs[] = {0x361, 0x371, 0x381};
	uint16 addr80_lo_offs[] = {0x441, 0x443, 0x445};
	uint16 addr80_hi_offs[] = {0x440, 0x442, 0x444};
	uint16 addr_lo, addr_hi;
	uint16 val_lo, val_hi;
	uint32 val;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	/* core_num = -1 ==> all cores */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if ((core_num == -1) || (core_num == core)) {
			for (ctr = 0; ctr < max_modes; ctr++) {
				if ((mode_mask >> ctr) & 1) {
					if (ctr == 0) {
						addr_lo = addr20_lo_offs[core];
						addr_hi = addr20_hi_offs[core];
					}
					else if (ctr == 1) {
						addr_lo = addr40_lo_offs[core];
						addr_hi = addr40_hi_offs[core];
					} else {
						addr_lo = addr80_lo_offs[core];
						addr_hi = addr80_hi_offs[core];
					}

					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                         1, addr_lo, 16, &val_lo);
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                         1, addr_hi, 16, &val_hi);
					val = (val_hi << 16) | val_lo;

					if (bq0_bw >= 0) {
						val = (val & 0x1fffff8) | (bq0_bw << 0);
					}
					if (bq1_bw >= 0) {
						val = (val & 0x1ffffc7) | (bq1_bw << 3);
					}
					if (gmult >= 0) {
						val = (val & 0x1ffc03f) | (gmult << 6);
					}
					if (rc_bw >= 0) {
						val = (val & 0x1fe3fff) | (rc_bw << 14);
					}
					if (gmult_rc >= 0) {
						val = (val & 0x001ffff) | (gmult_rc << 17);
					}

					val_lo = val & 0xffff;
					val_hi = (val >> 16) & 0x1ff;
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
					                          addr_lo, 16, &val_lo);
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
					                          addr_hi, 16, &val_hi);
				}
			}
		}
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

/*
dacbuf_fixed_cap[5], dacbuf_cap[4:0]
mode_mask = bits[0:8] = 11b_20, 11n_20, 11ag_11ac_20, 11b_40, 11n_40, 11ag_11ac_40, 11b_80,
11n_11ag_11ac_80, samp_play
*/
void wlc_phy_set_tx_afe_dacbuf_cap(phy_info_t *pi, uint16 mode_mask, int dacbuf_cap,
                                   int dacbuf_fixed_cap, int core_num)
{
	uint8 ctr, core, max_modes = 9;
	uint16 core_base[] = {0x3f0, 0x60, 0xd0};
	uint8 offset[] = {0xb, 0xb, 0xc, 0xc, 0xe, 0xe, 0xf, 0xf, 0xa};
	uint8 shift[] = {0, 6, 0, 6, 0, 6, 0, 6, 0};
	uint16 addr, read_val, val;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	/* core_num = -1 ==> all cores */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if ((core_num == -1) || (core_num == core)) {
			for (ctr = 0; ctr < max_modes; ctr++) {
				if ((mode_mask >> ctr) & 1) {
					addr = core_base[core] + offset[ctr];
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                         1, addr, 16, &read_val);
					val = (read_val >> shift[ctr]) & 0x3f;

					if (dacbuf_cap >= 0) {
							val = (val & 0x20) | dacbuf_cap;
					}
					if (dacbuf_fixed_cap >= 0) {
						val = (val & 0x1f) |
						        (dacbuf_fixed_cap << 5);
					}

					if (shift[ctr] == 0) {
						val = (read_val & 0xfc0) | val;
					} else {
						val = (read_val & 0x3f) | (val << 6);
					}

					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ,
					                          1, addr, 16, &val);
				}
			}
		}
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_get_tx_bbmult_acphy(phy_info_t *pi, uint16 *bb_mult, uint16 core)
{
	uint16 tbl_ofdm_offset[] = { 99, 103, 107, 111};
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
	                         tbl_ofdm_offset[core], 16,
	                         bb_mult);
}

static void
wlc_phy_set_tx_bbmult_acphy(phy_info_t *pi, uint16 *bb_mult, uint16 core)
{
	uint16 tbl_ofdm_offset[] = { 99, 103, 107, 111};
	uint16 tbl_bphy_offset[] = {115, 119, 123, 127};
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
	                          tbl_ofdm_offset[core], 16,
	                          bb_mult);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
	                          tbl_bphy_offset[core], 16,
	                          bb_mult);
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_write_rx_farrow_pre_tiny(phy_info_t *pi, chan_info_rx_farrow *rx_farrow,
	chanspec_t chanspec)
{
	uint16 deltaphase_lo, deltaphase_hi;
	uint16 drift_period, farrow_ctrl;

#ifdef ACPHY_1X1_ONLY
	uint8 channel = CHSPEC_CHANNEL(chanspec);
	uint32 deltaphase;

	if (channel <= 14) {
		if (CHSPEC_IS20(chanspec))
			drift_period = 5120; /* 40x32x4 */
		else if (CHSPEC_IS40(chanspec))
			drift_period = 5120; /* 40x32x4 */
		else
			drift_period = 1280; /* 160x4x2 */
	} else {
		if (CHSPEC_IS20(chanspec))
			drift_period = 3840; /* 40x24x4 */
		else if (CHSPEC_IS40(chanspec))
			drift_period = 3840; /* 40x24x4 */
		else
			drift_period = 2880; /* 160x9x2 */
	}

	if (CHSPEC_IS80(chanspec)) {
		deltaphase = rx_farrow->deltaphase_80;
		farrow_ctrl = rx_farrow->farrow_ctrl_80;
	} else {
		deltaphase = rx_farrow->deltaphase_20_40;
		farrow_ctrl = rx_farrow->farrow_ctrl_20_40;
	}
	if (ACMAJORREV_1(pi->pubpi.phy_rev) &&
		!(ACMINORREV_0(pi->pubpi.phy_rev) || ACMINORREV_1(pi->pubpi.phy_rev))) {
		farrow_ctrl = (farrow_ctrl &
			~ACPHY_rxFarrowCtrl_rx_farrow_outShift_MASK(pi->pubpi.phy_rev));
	}
	deltaphase_lo = deltaphase & 0xffff;
	deltaphase_hi = (deltaphase >> 16) & 0xff;

#else  /* ACPHY_1X1_ONLY */
	UNUSED_PARAMETER(chanspec);

	/* Setup the Rx Farrow */
	deltaphase_lo = rx_farrow->deltaphase_lo;
	deltaphase_hi = rx_farrow->deltaphase_hi;
	drift_period = rx_farrow->drift_period;
	farrow_ctrl = rx_farrow->farrow_ctrl;

#endif  /* ACPHY_1X1_ONLY */
	/* Setup the Rx Farrow */
	WRITE_PHYREG(pi, rxFarrowDeltaPhase_lo, deltaphase_lo);
	WRITE_PHYREG(pi, rxFarrowDeltaPhase_hi, deltaphase_hi);
	WRITE_PHYREG(pi, rxFarrowDriftPeriod, drift_period);
	WRITE_PHYREG(pi, rxFarrowCtrl, farrow_ctrl);

	/* Use the same settings for the loopback Farrow */
	WRITE_PHYREG(pi, lbFarrowDeltaPhase_lo, deltaphase_lo);
	WRITE_PHYREG(pi, lbFarrowDeltaPhase_hi, deltaphase_hi);
	WRITE_PHYREG(pi, lbFarrowDriftPeriod, drift_period);
	WRITE_PHYREG(pi, lbFarrowCtrl, farrow_ctrl);
}

static void
wlc_phy_tx_farrow_mu_setup(phy_info_t *pi, uint16 MuDelta_l, uint16 MuDelta_u, uint16 MuDeltaInit_l,
	uint16 MuDeltaInit_u)
{
	ACPHYREG_BCAST(pi, TxResamplerMuDelta0l, MuDelta_l);
	ACPHYREG_BCAST(pi, TxResamplerMuDelta0u, MuDelta_u);
	ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0l, MuDeltaInit_l);
	ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0u, MuDeltaInit_u);
}
#ifndef ACPHY_1X1_ONLY
static void
wlc_phy_write_tx_farrow_acphy(phy_info_t *pi, chanspec_t chanspec)
{
	uint8	ch = CHSPEC_CHANNEL(chanspec), afe_clk_num, afe_clk_den;
	uint16	a, b, lb_b = 0;
	uint32	fcw, lb_fcw, tmp_low = 0, tmp_high = 0;
	uint32  deltaphase;
	uint16  deltaphase_lo, deltaphase_hi;
	uint16  farrow_downsamp;
	uint32	fc = wf_channel2mhz(ch, CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
	                                                               : WF_CHAN_FACTOR_5_G);

	if (pi->u.pi_acphy->dac_mode == 1) {
		if (CHSPEC_IS20(chanspec)) {
			if (CHSPEC_IS5G(chanspec)) {
				if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				    !(ISSIM_ENAB(pi->sh->sih)) &&
				    (((((fc == 5180) && (pi->sh->chippkg != 2)) ||
				       ((fc >= 5200) && (fc <= 5320)) ||
				       ((fc >= 5745) && (fc <= 5825))) && !PHY_IPA(pi)))) {
					a = 10;
				} else if (((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				            ((fc == 5745) || (fc == 5765) || (fc == 5825 &&
				        !PHY_IPA(pi)))) && !(ISSIM_ENAB(pi->sh->sih))) {
					a = 18;
				} else {
					a = 16;
				}
			} else {
				if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				    !(ISSIM_ENAB(pi->sh->sih))) {
					if ((pi->u.pi_acphy->srom_txnospurmod2g == 0) &&
						(!PHY_IPA(pi) ||
						/* SWWLAN-50654 */
						(pi->sh->boardtype == BCM94354USICOBRA &&
						fc == 2412))) {
						a = 9;
				} else if (((fc != 2412) && (fc != 2467)) ||
					(PHY_XTAL_IS40M(pi)) ||
					(ACMAJORREV_2(pi->pubpi.phy_rev) &&
					(ACMINORREV_1(pi->pubpi.phy_rev) ||
					ACMINORREV_3(pi->pubpi.phy_rev)) &&
					PHY_XTAL_IS37M4(pi) && PHY_ILNA(pi) &&
					(RADIOREV(pi->pubpi.radiorev) == 0x27))) {
						a = 18;
					} else {
						a = 16;
					}
				} else {
					a = 16;
				}
			}
			b = 160;
		} else if (CHSPEC_IS40(chanspec)) {
			if (CHSPEC_IS5G(chanspec)) {
				if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				    !PHY_IPA(pi) && (fc != 5190)) {
					a = 10;
				} else if (((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				     ((fc == 5755) || (fc == 5550 && PHY_XTAL_IS40M(pi)) ||
				      (fc == 5310 && PHY_XTAL_IS37M4(pi) && PHY_IPA(pi)) ||
				      (fc == 5190 && PHY_XTAL_IS37M4(pi) && !PHY_IPA(pi)))) &&
				    !(ISSIM_ENAB(pi->sh->sih))) {
					a = 9;
				} else {
					a = 8;
				}
			} else {
				if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				    !(ISSIM_ENAB(pi->sh->sih))) {
					a = 9;
				} else {
					a = 8;
				}
			}
			b = 320;
		} else {
			a = 6;
			b = 640;
		}
	} else if (pi->u.pi_acphy->dac_mode == 2) {
		a = 6;
		b = 640;
		lb_b = 320;
	} else {
		    a = 8;
		b = 320;
		lb_b = 320;
	}

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		afe_clk_num = 2;
		afe_clk_den = 3;
	} else {
		afe_clk_num = 3;
		afe_clk_den = 2;
		if (fc == 5290 && (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
		    ((((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
		      (pi->sh->chippkg == 2)) ||
		     (RADIOMINORREV(pi->pubpi.radiominorrev) == 7 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 9 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 8 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 12 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 14)) &&
		    (PHY_XTAL_IS37M4(pi))) {
			afe_clk_num = 4;
			afe_clk_den = 3;
		}
	}

	bcm_uint64_multiple_add(&tmp_high, &tmp_low, a * afe_clk_num * b,
		1 << 23, (fc * afe_clk_den) >> 1);
	bcm_uint64_divide(&fcw, tmp_high, tmp_low, fc * afe_clk_den);
	wlc_phy_tx_farrow_mu_setup(pi, fcw & 0xffff, (fcw & 0xff0000) >> 16, fcw & 0xffff,
		(fcw & 0xff0000) >> 16);
	/* DAC MODE 1 lbfarrow setup in rx_farrow_acphy */
	if (pi->u.pi_acphy->dac_mode != 1) {
		bcm_uint64_multiple_add(&tmp_high, &tmp_low, fc * afe_clk_den,
		        1 << 25, 0);
		bcm_uint64_divide(&lb_fcw, tmp_high, tmp_low, a * afe_clk_num * lb_b);
		deltaphase = (lb_fcw - 33554431) >> 1;
		deltaphase_lo = deltaphase & 0xffff;
		deltaphase_hi = (deltaphase >> 16) & 0xff;
		farrow_downsamp = fc * afe_clk_den / (a * afe_clk_num * lb_b);
		WRITE_PHYREG(pi, lbFarrowDeltaPhase_lo, deltaphase_lo);
		WRITE_PHYREG(pi, lbFarrowDeltaPhase_hi, deltaphase_hi);
		WRITE_PHYREG(pi, lbFarrowDriftPeriod, 5120);
		MOD_PHYREG(pi, lbFarrowCtrl, lb_farrow_downsampfactor, farrow_downsamp);
	}
}
#endif /* ACPHY_1X1_ONLY */

static void
wlc_phy_write_tx_farrow_tiny(phy_info_t *pi, chanspec_t chanspec)
{
	uint8	ch = CHSPEC_CHANNEL(chanspec), afe_clk_num, afe_clk_den;
	uint16	a = 18, b = 640;
	uint32	fcw, tmp_low = 0, tmp_high = 0;
	uint32	fc = wf_channel2mhz(ch, CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
	                                                               : WF_CHAN_FACTOR_5_G);
	switch (pi->u.pi_acphy->dac_rate) {
		case 200:
			if (((pi->vcodivmode & 0x1) && (CHSPEC_IS2G(pi->radio_chanspec))) ||
			    ((pi->vcodivmode & 0x2) && (CHSPEC_IS5G(pi->radio_chanspec))))
				a = 16;
			else
				a = 18;
			b = 160;
			break;
		case 400:
			if ((pi->vcodivmode & 0x4) && (CHSPEC_IS5G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->logenmode43 == 0))
				a = 8;
			else
				a = 9;
			b = 320;
			break;
		case 600:
			a = 6;
			b = 640;
			break;
		default:
			PHY_ERROR(("Unsupported dac_rate %d\n", pi->u.pi_acphy->dac_rate));
			ASSERT(0);
	}
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		afe_clk_num = 2;
		afe_clk_den = 3;
	} else {
		afe_clk_num = 3;
		afe_clk_den = 2;
		if ((pi->u.pi_acphy->logenmode43 == 1)) {
			afe_clk_num = 4;
			afe_clk_den = 3;
		}
	}
	/* bits_in_mu = 23 */
	bcm_uint64_multiple_add(&tmp_high, &tmp_low, a * afe_clk_num * b,
		1 << 23, (fc * afe_clk_den) >> 1);
	bcm_uint64_divide(&fcw, tmp_high, tmp_low, fc * afe_clk_den);

	wlc_phy_tx_farrow_mu_setup(pi, fcw & 0xffff, (fcw & 0xff0000) >> 16, fcw & 0xffff,
		(fcw & 0xff0000) >> 16);
	ACPHYREG_BCAST(pi, TxResamplerMuDelta0l, fcw & 0xffff);
	ACPHYREG_BCAST(pi, TxResamplerMuDelta0u, (fcw & 0xff0000) >> 16);
	ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0l, fcw & 0xffff);
	ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0u, (fcw & 0xff0000) >> 16);
}

static void
wlc_phy_write_rx_farrow_acphy(phy_info_t *pi, chanspec_t chanspec)
{
	uint16 deltaphase_lo, deltaphase_hi;
	uint8 ch = CHSPEC_CHANNEL(chanspec), num, den, bw, M, vco_div;
	uint32 deltaphase, farrow_in_out_ratio, fcw, tmp_low = 0, tmp_high = 0;
	uint16 drift_period, farrow_ctrl;
	uint8 farrow_outsft_reg, dec_outsft_reg, farrow_outscale_reg = 1;
	uint32 fc = wf_channel2mhz(ch, CHSPEC_IS2G(pi->radio_chanspec) ?
	        WF_CHAN_FACTOR_2_4_G : WF_CHAN_FACTOR_5_G);
	if (CHSPEC_IS80(chanspec)) {
		farrow_outsft_reg = 0;
		dec_outsft_reg = 0;
	} else {
		if (((ACMAJORREV_0(pi->pubpi.phy_rev)) && ((ACMINORREV_1(pi->pubpi.phy_rev)) ||
		    (ACMINORREV_0(pi->pubpi.phy_rev)))) || ((ACMAJORREV_1(pi->pubpi.phy_rev)) &&
		    ((ACMINORREV_1(pi->pubpi.phy_rev)) || (ACMINORREV_0(pi->pubpi.phy_rev)))) ||
		    ((ACMAJORREV_3(pi->pubpi.phy_rev)) && (ACMINORREV_0(pi->pubpi.phy_rev)))) {
			farrow_outsft_reg = 2;
		} else {
			farrow_outsft_reg = 0;
		}
		dec_outsft_reg = 3;
	}

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		num = 3;
		den = 2;
	} else {
		num = 2;
		den = 3;
		if (CHSPEC_IS80(chanspec) && (fc == 5290) &&
		    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
		    ((((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
		       (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
		      (pi->sh->chippkg == 2)) ||
		     (RADIOMINORREV(pi->pubpi.radiominorrev) == 7 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 9 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 8 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 12 ||
		     RADIOMINORREV(pi->pubpi.radiominorrev) == 14)) &&
		    (PHY_XTAL_IS37M4(pi))) {
			num = 3;
			den = 4;
		}
	}

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) && !(ISSIM_ENAB(pi->sh->sih))) {
			if (CHSPEC_IS40(chanspec)) {
				bw = 40;
				M = 4;
				vco_div = 18;
				drift_period = 1920;
			} else {
				if ((pi->u.pi_acphy->srom_txnospurmod2g == 0) &&
				    (!PHY_IPA(pi) ||
					/* SWWLAN-50654 */
					(pi->sh->boardtype == BCM94354USICOBRA && fc == 2412))) {
					bw = 20;
					M = 8;
					vco_div = 9;
					drift_period = 2880;
				} else if ((fc != 2412 && fc != 2467) ||
					(PHY_XTAL_IS40M(pi)) ||
					(ACMAJORREV_2(pi->pubpi.phy_rev) &&
					(ACMINORREV_1(pi->pubpi.phy_rev) ||
					ACMINORREV_3(pi->pubpi.phy_rev)) &&
					PHY_XTAL_IS37M4(pi) && PHY_ILNA(pi) &&
					(RADIOREV(pi->pubpi.radiorev) == 0x27))) {
					bw = 20;
					M = 8;
					vco_div = 18;
					drift_period = 5760;
				} else {
					bw = 20;
					M = 8;
					vco_div = 16;
					drift_period = 5120;
				}
			}
		} else {
			bw = 20;
			M = 8;
			vco_div = 16;
			drift_period = 5120;
		}
	} else {
		if (CHSPEC_IS80(chanspec)) {
			bw = 80;
			M = 4;
			vco_div = 6;
			drift_period = 2880;
			if (fc == 5290 && (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
			    ((((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
			       (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
			       (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
			       (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
			      (pi->sh->chippkg == 2)) ||
			     ((RADIOMINORREV(pi->pubpi.radiominorrev) == 7) ||
			     (RADIOMINORREV(pi->pubpi.radiominorrev) == 9) ||
			     (RADIOMINORREV(pi->pubpi.radiominorrev) == 8) ||
			     (RADIOMINORREV(pi->pubpi.radiominorrev) == 12) ||
			     (RADIOMINORREV(pi->pubpi.radiominorrev) == 14))) &&
			    (PHY_XTAL_IS37M4(pi))) {
				drift_period = 2560;
			}
		} else {
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
				if (CHSPEC_IS20(chanspec) &&
				    (((fc == 5180) && (pi->sh->chippkg != 2)) ||
				     ((fc >= 5200) && (fc <= 5320)) ||
				     ((fc >= 5745) && (fc <= 5825))) &&
				    !PHY_IPA(pi)) {
					bw = 20;
					M = 8;
					vco_div = 10;
					drift_period = 2400;
				} else if (CHSPEC_IS40(chanspec) && !PHY_IPA(pi) && (fc != 5190)) {
					bw = 20;
					M = 8;
					vco_div = 20;
					drift_period = 4800;
				} else if ((((fc == 5755 || (fc == 5550 &&
					PHY_XTAL_IS40M(pi)) || (fc == 5190 &&
					PHY_XTAL_IS37M4(pi) && !PHY_IPA(pi)) ||
					(fc == 5310 && PHY_XTAL_IS37M4(pi) &&
					PHY_IPA(pi))) && (CHSPEC_IS40(chanspec))) ||
					((fc == 5745 || fc == 5765 ||
					(fc == 5825 && !PHY_IPA(pi))) &&
					(CHSPEC_IS20(chanspec)))) && !(ISSIM_ENAB(pi->sh->sih))) {
					bw = 20;
					M = 8;
					vco_div = 18;
					drift_period = 4320;
				} else {
					bw = 20;
					M = 8;
					vco_div = 16;
					drift_period = 3840;
				}
			} else {
				bw = 20;
				M = 8;
				vco_div = 16;
				drift_period = 3840;
			}
		}
	}
	bcm_uint64_multiple_add(&tmp_high, &tmp_low, fc * num, 1 << 25, 0);
	bcm_uint64_divide(&fcw, tmp_high, tmp_low, (uint32) (den * vco_div * M * bw));

	farrow_in_out_ratio = (fcw >> 25);
	deltaphase = (fcw - 33554431)>>1;
	deltaphase_lo = deltaphase & 0xffff;
	deltaphase_hi = (deltaphase >> 16) & 0xff;
	farrow_ctrl = (dec_outsft_reg & 0x3) | ((farrow_outscale_reg & 0x3) << 2) |
		((farrow_outsft_reg & 0x7) << 4) | ((farrow_in_out_ratio & 0x3) <<7);

	WRITE_PHYREG(pi, rxFarrowDeltaPhase_lo, deltaphase_lo);
	WRITE_PHYREG(pi, rxFarrowDeltaPhase_hi, deltaphase_hi);
	WRITE_PHYREG(pi, rxFarrowDriftPeriod, drift_period);
	WRITE_PHYREG(pi, rxFarrowCtrl, farrow_ctrl);
	MOD_PHYREG(pi, lbFarrowCtrl, lb_farrow_outShift, farrow_outsft_reg);
	MOD_PHYREG(pi, lbFarrowCtrl, lb_decimator_output_shift, dec_outsft_reg);
	MOD_PHYREG(pi, lbFarrowCtrl, lb_farrow_outScale, farrow_outscale_reg);
	/* Use the same settings for the loopback Farrow */
	if (pi->u.pi_acphy->dac_mode == 1) {
		WRITE_PHYREG(pi, lbFarrowDeltaPhase_lo, deltaphase_lo);
		WRITE_PHYREG(pi, lbFarrowDeltaPhase_hi, deltaphase_hi);
		WRITE_PHYREG(pi, lbFarrowDriftPeriod, drift_period);
		MOD_PHYREG(pi, lbFarrowCtrl, lb_farrow_downsampfactor, farrow_in_out_ratio);
	}
}

static void
wlc_phy_write_rx_farrow_tiny(phy_info_t *pi, chanspec_t chanspec)
{
	uint8 ch = CHSPEC_CHANNEL(chanspec), num, den, bw, M, vco_div;
	uint32 fcw, tmp_low = 0, tmp_high = 0;
	uint32 fc = wf_channel2mhz(ch, CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
	                                                               : WF_CHAN_FACTOR_5_G);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		num = 3;
		den = 2;
	} else {
		num = 2;
		den = 3;
		if ((pi->u.pi_acphy->logenmode43 == 1)) {
			num = 3;
			den = 4;
		}
	}
	if (CHSPEC_IS20(chanspec)) {
		bw = 20;
		M = 8;
		vco_div = 6;
	} else if (CHSPEC_IS40(chanspec)) {
		bw = 40;
		M = 8;
		vco_div = 3;
	} else {
		bw = 80;
		M = 12;
		vco_div = 1;
	}
	/* bits_in_mu = 24 */
	/*
	fcw = (num * wlc_phy_channel2freq(ch) * (((uint32)(1<<31))/
		(den * vco_div * 2 * M * bw)))>> 7;
	*/
	bcm_uint64_multiple_add(&tmp_high, &tmp_low, fc * num, 1 << 24, 0);
	bcm_uint64_divide(&fcw, tmp_high, tmp_low, (uint32) (den * vco_div * 2 * M * bw));

	PHY_INFORM(("%s: fcw 0x%0x ch %d freq %d vco_div %d bw %d\n",
	            __FUNCTION__, fcw, ch, wlc_phy_channel2freq(ch), vco_div, bw));

	MOD_PHYREG(pi, RxSdFeConfig2, fcw_value_lo, fcw & 0xffff);
	MOD_PHYREG(pi, RxSdFeConfig3, fcw_value_hi, (fcw >> 16) & 0xffff);
}

static bool
BCMATTACHFN(wlc_phy_attach_farrow)(phy_info_t *pi)
{
	int num_bw;
#ifndef ACPHY_1X1_ONLY
	phy_info_acphy_t *pi_ht = (phy_info_acphy_t *)pi->u.pi_acphy;
#endif // endif
	chan_info_tx_farrow(*tx_farrow) [ACPHY_NUM_CHANS];
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));
	pi->u.pi_acphy->tx_farrow = NULL;
	pi->u.pi_acphy->rx_farrow = NULL;
#ifdef ACPHY_1X1_ONLY
	num_bw = 1;
#else
	num_bw = ACPHY_NUM_BW;
#endif // endif

	if ((pi->u.pi_acphy->tx_farrow =
	     MALLOC(pi->sh->osh,
	            num_bw * sizeof(chan_info_tx_farrow[ACPHY_NUM_CHANS]))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		           __FUNCTION__, MALLOCED(pi->sh->osh)));
		return FALSE;
	}

	if (!TINY_RADIO(pi)) {
		chan_info_rx_farrow(*rx_farrow) [ACPHY_NUM_CHANS];
		/* TINY RADIO does not have an rx farrow table */
		if ((pi->u.pi_acphy->rx_farrow =
		     MALLOC(pi->sh->osh,
		            num_bw * sizeof(chan_info_rx_farrow[ACPHY_NUM_CHANS]))) == NULL) {
			PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
			           __FUNCTION__, MALLOCED(pi->sh->osh)));
			return FALSE;
		}

		rx_farrow = rx_farrow_tbl;
		memcpy(pi->u.pi_acphy->rx_farrow, rx_farrow,
		       ACPHY_NUM_CHANS * num_bw * sizeof(chan_info_rx_farrow));
	}

#ifdef ACPHY_1X1_ONLY
	ASSERT(((phy_info_acphy_t *)pi->u.pi_acphy)->dac_mode == 1);
	tx_farrow = tx_farrow_dac1_tbl;
#else /* ACPHY_1X1_ONLY */
	switch (pi_ht->dac_mode) {
	case 2:
		tx_farrow = tx_farrow_dac2_tbl;
		break;
	case 3:
		tx_farrow = tx_farrow_dac3_tbl;
		break;
	case 1:
	default:
		/* default to dac_mode 1 */
		tx_farrow = tx_farrow_dac1_tbl;
		break;
	}
#endif /* ACPHY_1X1_ONLY */
	memcpy(pi->u.pi_acphy->tx_farrow, tx_farrow,
	       ACPHY_NUM_CHANS * num_bw * sizeof(chan_info_tx_farrow));
	return TRUE;
}

static void
wlc_phy_farrow_setup_tiny(phy_info_t *pi, chanspec_t chanspec)
{
	wlc_phy_write_tx_farrow_tiny(pi, chanspec);
	wlc_phy_write_rx_farrow_tiny(pi, chanspec);

	/* Enable the Tx resampler on all cores */
	MOD_PHYREG(pi, TxResamplerEnable0, enable_tx, 1);
}

static void
wlc_phy_farrow_setup_acphy(phy_info_t *pi, chanspec_t chanspec)
{
#ifdef ACPHY_1X1_ONLY
	uint32 dac_resamp_fcw;
	uint16 MuDelta_l, MuDelta_u;
	uint16 MuDeltaInit_l, MuDeltaInit_u;
#endif // endif
	uint16 channel = CHSPEC_CHANNEL(chanspec);
	uint16 *resamp_set = NULL;
	chan_info_tx_farrow *tx_farrow = NULL;
	chan_info_rx_farrow *rx_farrow;
	uint16 regval;
	int bw_idx = 0;
	int tbl_idx = 0;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));
	if (ISSIM_ENAB(pi->sh->sih)) {
		/* Use channel 7(2g)/151(5g) settings for Quickturn */
		if (CHSPEC_IS2G(chanspec)) {
			channel = 7;
		} else {
			channel = 155;
		}
	}

	/* China 40M Spur WAR */
	if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
		uint8 core;
		/* Cleanup Overrides */
		MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div_ovr, 0);
		MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div, 0x0);
		pi->sdadc_config_override = FALSE;

		FOREACH_CORE(pi, core) {
			MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd, 0);
			MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_flashhspd, 0);
			MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl, 0);
			MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_ctrl_flash17lvl, 0);
			MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, 0);
			MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 0);
		}
	}

#ifdef ACPHY_1X1_ONLY
	bw_idx = 0;
#else /* ACPHY_1X1_ONLY */
	bw_idx = CHSPEC_IS20(chanspec)? 0 : (CHSPEC_IS40(chanspec)? 1 : 2);
#endif /* ACPHY_1X1_ONLY */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Compute rx farrow setup */
		wlc_phy_write_rx_farrow_acphy(pi, chanspec);
	} else {
		/* Find the Rx Farrow settings in the table for the specific b/w and channel */
		for (tbl_idx = 0; tbl_idx < ACPHY_NUM_CHANS; tbl_idx++) {
			rx_farrow = &pi->u.pi_acphy->rx_farrow[bw_idx][tbl_idx];
			if (rx_farrow->chan == channel) {
				wlc_phy_write_rx_farrow_pre_tiny(pi, rx_farrow, chanspec);
				break;
			}
		}

		/*
		 * No need to iterate through the Tx Farrow table, since the channels have the same
		 * order as the Rx Farrow table.
		 */

		if (tbl_idx == ACPHY_NUM_CHANS) {
			PHY_ERROR(("wl%d: %s: Failed to find Farrow settings"
				   " for bw=%d, channel=%d\n",
				   pi->sh->unit, __FUNCTION__, CHSPEC_BW(chanspec), channel));
			return;
		}
	}

#ifdef ACPHY_1X1_ONLY
	ASSERT(((phy_info_acphy_t *)pi->u.pi_acphy)->dac_mode == 1);
	tx_farrow = &pi->u.pi_acphy->tx_farrow[0][tbl_idx];
	dac_resamp_fcw = tx_farrow->dac_resamp_fcw;

	if (CHSPEC_IS80(chanspec))
	{
		dac_resamp_fcw += (dac_resamp_fcw >> 1);
	}

	dac_resamp_fcw = (dac_resamp_fcw + 32) >> 6;

	MuDelta_l = (dac_resamp_fcw & 0xFFFF);
	MuDelta_u = (dac_resamp_fcw & 0xFF0000) >> 16;
	MuDeltaInit_l = (dac_resamp_fcw & 0xFFFF);
	MuDeltaInit_u = (dac_resamp_fcw & 0xFF0000) >> 16;

	wlc_phy_tx_farrow_mu_setup(pi, MuDelta_l, MuDelta_u, MuDeltaInit_l, MuDeltaInit_u);
#else /* ACPHY_1X1_ONLY */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Compute tx farrow setup */
		wlc_phy_write_tx_farrow_acphy(pi, chanspec);
	} else {
		tx_farrow = &pi->u.pi_acphy->tx_farrow[bw_idx][tbl_idx];
		wlc_phy_tx_farrow_mu_setup(pi, tx_farrow->MuDelta_l, tx_farrow->MuDelta_u,
			tx_farrow->MuDeltaInit_l, tx_farrow->MuDeltaInit_u);
	}
#endif /* ACPHY_1X1_ONLY */

	/* China 40M Spur WAR */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) &&
	    (pi->afe_override) && CHSPEC_IS40(pi->radio_chanspec)) {
		uint16 fc;
		if (CHSPEC_CHANNEL(pi->radio_chanspec) > 14)
			fc = CHAN5G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));
		else
			fc = CHAN2G_FREQ(CHSPEC_CHANNEL(pi->radio_chanspec));

		/* AFE Settings */
		if (fc == 5310) {
			uint8 core;
			MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div_ovr, 0x1);
			MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div, 0x0);

			FOREACH_CORE(pi, core) {
				MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd, 1);
				MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core,
				             afe_iqadc_flashhspd, 1);
				MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl, 0);
				MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core,
				             afe_ctrl_flash17lvl, 1);
				MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, 1);
				MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 1);
			}

			ACPHY_REG_LIST_START
				MOD_RADIO_REG_ENTRY(pi, RF0, AFEDIV1, afediv_main_driver_size, 8)
				MOD_RADIO_REG_ENTRY(pi, RF0, AFEDIV2, afediv_repeater1_dsize, 8)
				MOD_RADIO_REG_ENTRY(pi, RF0, AFEDIV2, afediv_repeater2_dsize, 8)
			ACPHY_REG_LIST_EXECUTE(pi);

			/* Set Override variable to pick up correct settings during cals */
			pi->sdadc_config_override = TRUE;
		} else if (fc == 5270) {
			MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div_ovr, 0x1);
			MOD_PHYREG(pi, AfeClkDivOverrideCtrl, afediv_sel_div, 0x2);
		}

		/* Resampler Settings */
		if (fc == 5270)
			resamp_set = resamp_cnwar_5270;
		else if (fc == 5310)
			resamp_set = resamp_cnwar_5310;

		if (resamp_set != NULL) {
			WRITE_PHYREG(pi, rxFarrowDeltaPhase_lo, resamp_set[0]);
			WRITE_PHYREG(pi, rxFarrowDeltaPhase_hi, resamp_set[1]);
			WRITE_PHYREG(pi, rxFarrowDriftPeriod, resamp_set[2]);
			WRITE_PHYREG(pi, lbFarrowDeltaPhase_lo, resamp_set[3]);
			WRITE_PHYREG(pi, lbFarrowDeltaPhase_hi, resamp_set[4]);
			WRITE_PHYREG(pi, lbFarrowDriftPeriod, resamp_set[5]);
			ACPHYREG_BCAST(pi, TxResamplerMuDelta0l, resamp_set[6]);
			ACPHYREG_BCAST(pi, TxResamplerMuDelta0u, resamp_set[7]);
			ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0l, resamp_set[8]);
			ACPHYREG_BCAST(pi, TxResamplerMuDeltaInit0u, resamp_set[9]);
		}
	}

	/* Enable the Tx resampler on all cores */
	regval = READ_PHYREG(pi, TxResamplerEnable0);
	regval |= (1 < ACPHY_TxResamplerEnable0_enable_tx_SHIFT(pi->pubpi.phy_rev));
	ACPHYREG_BCAST(pi, TxResamplerEnable0,  regval);
}

uint16
wlc_phy_classifier_acphy(phy_info_t *pi, uint16 mask, uint16 val)
{
	uint16 curr_ctl, new_ctl;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* Turn on/off classification (bphy, ofdm, and wait_ed), mask and
	 * val are bit fields, bit 0: bphy, bit 1: ofdm, bit 2: wait_ed;
	 * for types corresponding to bits set in mask, apply on/off state
	 * from bits set in val; if no bits set in mask, simply returns
	 * current on/off state.
	 */
	curr_ctl = READ_PHYREG(pi, ClassifierCtrl);

	new_ctl = (curr_ctl & (~mask)) | (val & mask);

	WRITE_PHYREG(pi, ClassifierCtrl, new_ctl);

	return new_ctl;
}

/* see acphyproc.tcl acphy_tx_idx */
void
wlc_phy_txpwr_by_index_acphy(phy_info_t *pi, uint8 core_mask, int8 txpwrindex)
{
	uint8 core;
	uint8 stall_val;
	uint32 coeffs;
	uint16 coeffs_ab[2];

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	(void) wlc_phy_set_txpwr_by_index_acphy(pi, core_mask, txpwrindex);

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	FOREACH_ACTV_CORE(pi, core_mask, core) {
		if (PHY_PAPDEN(pi)) {
			if (pi->acphy_txpwrctrl == PHY_TPC_HW_OFF)  {
				int16 rfPwrLutVal;
				uint32 rfpwrlut_table_ids[] = { ACPHY_TBL_ID_RFPWRLUTS0,
					ACPHY_TBL_ID_RFPWRLUTS1, ACPHY_TBL_ID_RFPWRLUTS2};

				if (!TINY_RADIO(pi)) {
					MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonOffset,
					0);
				}
				MOD_PHYREGCEE(pi, PapdEnable, core, gain_dac_rf_override,
					1);
				wlc_phy_table_read_acphy(pi, rfpwrlut_table_ids[core],
					1, txpwrindex, 16, &rfPwrLutVal);
				MOD_PHYREGCEE(pi, PapdEnable, core, gain_dac_rf_reg,
					rfPwrLutVal);
			}
		}

		/* Update the per-core state of power index */
		pi->u.pi_acphy->txpwrindex[core] = txpwrindex;
	}

	if (TINY_RADIO(pi) && PHY_PAPDEN(pi)) {
			uint32 tmp_val;
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS0,
				1, pi->u.pi_acphy->txpwrindex[0], 16, &tmp_val);
			MOD_PHYREG(pi, PapdEnable0, gain_dac_rf_reg0, tmp_val);
	}
	if (ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi) &&
		CHSPEC_IS5G(pi->radio_chanspec) &&
		(READ_PHYREGFLD(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsIQ) ==
		1) && (READ_PHYREGFLD(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO) ==
		1)) {

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQCOEFFLUTS0, 1,
			txpwrindex, 32, &coeffs);
		coeffs_ab[0] = ((coeffs >> 10) & 0x3ff);
		coeffs_ab[1] = (coeffs & 0x3ff);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			coeffs_ab, TB_OFDM_COEFFS_AB,  0);

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LOFTCOEFFLUTS0, 1,
			txpwrindex, 16, &coeffs);
		coeffs_ab[0] = (uint16)(((coeffs >> 8) & 0xff) + ((coeffs & 0xff)<<8));
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			&coeffs_ab[0], TB_OFDM_COEFFS_D,  0);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static uint16
wlc_phy_set_txpwr_by_index_acphy(phy_info_t *pi, uint8 core_mask, int8 txpwrindex)
{
	uint8 core;
	txgain_setting_t txgain_settings;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(core_mask != 0);
	ASSERT(txpwrindex >= 0);	/* negative index not supported */

	ACPHY_DISABLE_STALL(pi);

	/* Set tx power based on an input "index"
	 * (Emulate what HW power control would use for a given table index)
	 */

	FOREACH_ACTV_CORE(pi, core_mask, core) {
		/* Read tx gain table */
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &txgain_settings, txpwrindex);

		/* Override gains: DAC, Radio and BBmult */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
		                          (0x100 + core), 16, &(txgain_settings.rad_gain));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
		                          (0x103 + core), 16, &(txgain_settings.rad_gain_mi));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
		                          (0x106 + core), 16, &(txgain_settings.rad_gain_hi));

		wlc_phy_set_tx_bbmult_acphy(pi, &txgain_settings.bbmult, core);

		PHY_TXPWR(("wl%d: %s: Fixed txpwrindex for core%d is %d\n",
		          pi->sh->unit, __FUNCTION__, core, txpwrindex));
	}
	ACPHY_ENABLE_STALL(pi, stall_val);

	return txgain_settings.bbmult;
}

void
wlc_phy_get_tx_gain_acphy(phy_info_t *pi, uint8 core_no, acphy_txgains_t *target_gain)
{
	uint16 curr_gains_0 = 0, curr_gains_1 = 0, curr_gains_2 = 0;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (pi->acphy_txpwrctrl == PHY_TPC_HW_OFF) {
		/* read current tx gain from RFSeq table and use as target_gain */

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core_no), 16,
			&curr_gains_0);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core_no), 16,
			&curr_gains_1);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core_no), 16,
			&curr_gains_2);

		/* extract gain values */
		target_gain->txlpf = (uint16) ((curr_gains_0 & 0xFF));
		target_gain->ipa  = (uint16) ((curr_gains_0 & 0xFF00) >> 8);
		target_gain->pad  = (uint16) ((curr_gains_1 & 0xFF)   >> 0);
		target_gain->pga  = (uint16) ((curr_gains_1 & 0xFF00) >> 8);
		target_gain->txgm = (uint16) ((curr_gains_2 & 0xFF)   >> 0);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_get_txgain_settings_by_index_acphy(phy_info_t *pi, txgain_setting_t *txgain_settings,
                                     int8 txpwrindex)
{
	uint16 txgain[3];

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1, txpwrindex, 48, &txgain);

	txgain_settings->rad_gain    = ((txgain[0] >> 8) & 0xff) + ((txgain[1] & 0xff) << 8);
	txgain_settings->rad_gain_mi = ((txgain[1] >> 8) & 0xff) + ((txgain[2] & 0xff) << 8);
	txgain_settings->rad_gain_hi = ((txgain[2] >> 8) & 0xff);
	txgain_settings->bbmult      = (txgain[0] & 0xff);
}

void
wlc_phy_read_txgain_acphy(phy_info_t *pi)
{
	uint8 core;
	uint8 stall_val;
	txgain_setting_t txcal_txgain[3];

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* store off orig tx radio gain */
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		                         &(txcal_txgain[core].rad_gain));
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		                         &(txcal_txgain[core].rad_gain_mi));
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		                         &(txcal_txgain[core].rad_gain_hi));
		wlc_phy_get_tx_bbmult_acphy(pi, &(txcal_txgain[core].bbmult),  core);
		PHY_NONE(("\n radio gain = 0x%x%x%x, bbm=%d  \n",
			txcal_txgain[core].rad_gain_hi,
			txcal_txgain[core].rad_gain_mi,
			txcal_txgain[core].rad_gain,
			txcal_txgain[core].bbmult));
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_txcal_txgain_setup_acphy(phy_info_t *pi, txgain_setting_t *txcal_txgain,
	txgain_setting_t *orig_txgain)
{
	uint8 core;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* store off orig and set new tx radio gain */
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		                         &(orig_txgain[core].rad_gain));
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		                         &(orig_txgain[core].rad_gain_mi));
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		                         &(orig_txgain[core].rad_gain_hi));

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		                          &(txcal_txgain[core].rad_gain));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		                          &(txcal_txgain[core].rad_gain_mi));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		                          &(txcal_txgain[core].rad_gain_hi));

		PHY_NONE(("\n radio gain = 0x%x%x%x, bbm=%d, dacgn = %d  \n",
			txcal_txgain[core].rad_gain_hi,
			txcal_txgain[core].rad_gain_mi,
			txcal_txgain[core].rad_gain,
			txcal_txgain[core].bbmult,
			txcal_txgain[core].dac_gain));

		/* store off orig and set new bbmult gain */
		wlc_phy_get_tx_bbmult_acphy(pi, &(orig_txgain[core].bbmult),  core);
		wlc_phy_set_tx_bbmult_acphy(pi, &(txcal_txgain[core].bbmult), core);
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_txcal_txgain_cleanup_acphy(phy_info_t *pi, txgain_setting_t *orig_txgain)
{
	uint8 core;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* restore gains: DAC, Radio and BBmult */

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		                          &(orig_txgain[core].rad_gain));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		                          &(orig_txgain[core].rad_gain_mi));
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		                          &(orig_txgain[core].rad_gain_hi));

		wlc_phy_set_tx_bbmult_acphy(pi, &(orig_txgain[core].bbmult), core);
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_precal_target_tssi_search(phy_info_t *pi, txgain_setting_t *target_gains)
{
	int8  gain_code_found, delta_threshold, dont_alter_step;
	int16  target_tssi, min_delta, prev_delta, delta_tssi;
	int16  idle_tssi[PHY_CORE_MAX] = {0};
	uint8  tx_idx;
	int16  tone_tssi[PHY_CORE_MAX] = {0};
	int16  tssi[PHY_CORE_MAX] = {0};

	int16  pad_gain_step, curr_pad_gain, pad_gain;

	txgain_setting_t orig_txgain[PHY_CORE_MAX];
	int16  sat_count, sat_threshold, sat_delta, ct;
	int16 temp_val;
	int16 tx_idx_step, pad_step_size, pad_iteration_count;

	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* Set the target TSSIs for different bands/Bandwidth cases.
	 * These numbers are arrived by running the TCL proc:
	 * "get_target_tssi_for_iqlocal" for a representative channel
	 * by sending a tone at a chosen Tx gain which gives best
	 * Image/LO rejection at room temp
	 */

	if (CHSPEC_IS5G(pi->radio_chanspec) == 1) {
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			target_tssi = 900;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			target_tssi = 900;
		} else {
			target_tssi = 950;
		}
	} else {
		if (CHSPEC_IS40(pi->radio_chanspec)) {
			target_tssi = 913;
		} else {
			target_tssi = 950;
		}

	}

	wlc_phy_tssi_phy_setup_acphy(pi, 0);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 0);
	else
		wlc_phy_tssi_radio_setup_acphy(pi, pi->sh->hw_phyrxchain, 0);

	gain_code_found = 0;

	/* delta_threshold is the minimum tolerable difference between
	 * target tssi and the measured tssi. This was determined by experimental
	 * observations. delta_tssi ( target_tssi - measured_tssi ) values upto
	 * 15 are found to give identical performance in terms of Tx EVM floor
	 * when compared to delta_tssi values upto 10. Threshold value of 15 instead
	 * of 10 will cut down the algo time as the algo need not search for
	 * index to meet delta of 10.
	 */
	delta_threshold = 15;

	min_delta = 1024;
	prev_delta = 1024;

	/* Measure the Idle TSSI */
	wlc_phy_poll_samps_WAR_acphy(pi, idle_tssi, TRUE, TRUE, target_gains, FALSE, TRUE, 0, 0);

	/* Measure the tone TSSI before start searching */
	tx_idx = 0;
	wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);

	wlc_phy_get_txgain_settings_by_index_acphy(
				pi, target_gains, tx_idx);

	/* Save the original Gain code */
	wlc_phy_txcal_txgain_setup_acphy(pi, target_gains, &orig_txgain[0]);

	PHY_TRACE(("radio gain = 0x%x%x%x, bbm=%d, dacgn = %d  \n",
		target_gains->rad_gain_hi,
		target_gains->rad_gain_mi,
		target_gains->rad_gain,
		target_gains->bbmult,
		target_gains->dac_gain));

	wlc_phy_poll_samps_WAR_acphy(pi, tssi, TRUE, FALSE, target_gains, FALSE, TRUE, 0, 0);

	tone_tssi[0] = tssi[0] - idle_tssi[0];

	delta_tssi = target_tssi - tone_tssi[0];

	PHY_TRACE(("Index = %3d target_TSSI = %4i tone_TSSI = %4i"
			"delta_TSSI = %4i min_delta = %4i\n",
			tx_idx, target_tssi, tone_tssi[0], delta_tssi, min_delta));

	PHY_TRACE(("*********** Search Control loop begins now ***********\n"));

	/* When the measured tssi saturates and is unable to meet
	 * the target tssi, there is no point in continuing search
	 * for the next higher PAD gain. The variable 'sat_count'
	 * is the threshold which will control when to stop the search.
	 * change in PAD gain code by "10" ticks should atleast translate
	 * to 1dBm of power level change when not saturated. When the
	 * measured tssi is saturated, this doesnt hold good and we
	 * need to break out.
	 */
	sat_count = 10;
	sat_threshold = 20;

	/* delta_tssi > 0 ==> target_tssi is greater than tone tssi and
	 * hence we have to increase the PAD gain as the inference was
	 * drawn by measuring the tone tssi at index 0
	 */

	if (delta_tssi > 0) {
		PHY_TRACE(("delta_tssi > 0 ==> target_tssi is greater than tone tssi and\n"));
		PHY_TRACE(("hence we have to increase the PAD gain as the inference was\n"));
		PHY_TRACE(("drawn by measuring the tone tssi at index 0\n"));

		tx_idx = 0;
		wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);

		wlc_phy_get_txgain_settings_by_index_acphy(
				pi, target_gains, tx_idx);

		min_delta = 1024;
		prev_delta = 1024;

		sat_delta = 0;
		ct = 0;

		curr_pad_gain = target_gains->rad_gain_mi & 0x00ff;

		PHY_TRACE(("Current PAD Gain (Before Search) is %d\n", curr_pad_gain));
		pad_gain_step = 1;

		for (pad_gain = curr_pad_gain; pad_gain <= MAX_PAD_GAIN; pad_gain += pad_gain_step)
		{
			target_gains->rad_gain_mi = target_gains->rad_gain_mi & 0xff00;
			target_gains->rad_gain_mi |= pad_gain;

			PHY_TRACE(("Current PAD Gain is %d\n", pad_gain));

			wlc_phy_poll_samps_WAR_acphy(pi, tssi, TRUE, FALSE,
			                             target_gains, FALSE, TRUE, 0, 0);
			tone_tssi[0] = tssi[0] - idle_tssi[0];

			delta_tssi = target_tssi - tone_tssi[0];

			/* Manipulate the step size to cut down the search time */
			if (delta_tssi > 50) {
				pad_gain_step = 10;
			} else if (delta_tssi > 30) {
				pad_gain_step = 5;
			} else if (delta_tssi > 15) {
				pad_gain_step = 2;
			} else {
				pad_gain_step = 1;
			}

			/* Check for TSSI Saturation */
			if (ct == 0) {
				sat_delta = delta_tssi;
			} else {
				sat_delta = delta_tssi - prev_delta;
				sat_delta = ABS(sat_delta);

				PHY_TRACE(("Ct=%d sat_delta=%d delta_tssi=%d sat_delta=%d\n",
					ct, sat_delta, delta_tssi, sat_delta));
			}

			if (sat_delta > sat_threshold) {
				ct = 0;
			}

			if ((ct == sat_count) && (sat_delta < sat_threshold)) {

				PHY_TRACE(("Ct = %d\t sat_delta = %d \t "
						"sat_threshold = %d\n",
						ct, sat_delta, sat_threshold));

				gain_code_found = 0;

				PHY_TRACE(("Breaking out of search as TSSI "
						" seems to have saturated\n"));
				WLC_PHY_PRECAL_TRACE(tx_idx, target_gains);

				break;
			}

			ct = ct + 1;

			PHY_TRACE(("Index = %3d target_TSSI = %4i tone_TSSI = %4i"
					"delta_TSSI = %4i min_delta = %4i radio gain = 0x%x%x%x, "
					"bbm=%d, dacgn = %d\n", tx_idx,
					target_tssi, tone_tssi[0], delta_tssi, min_delta,
					target_gains->rad_gain_hi, target_gains->rad_gain_mi,
					target_gains->rad_gain, target_gains->bbmult,
					target_gains->dac_gain));

			temp_val = ABS(delta_tssi);
			if (temp_val <= min_delta) {
				min_delta = ABS(delta_tssi);

				if (min_delta <= delta_threshold) {
					gain_code_found	= 1;

					PHY_TRACE(("Breaking out of search as min delta"
							" tssi threshold conditions are met\n"));

					WLC_PHY_PRECAL_TRACE(tx_idx, target_gains);

					break;
				}
			}
			prev_delta = delta_tssi;
		}

		if (gain_code_found == 0) {
			PHY_TRACE(("*** Search failed Again ***\n"));
		}

	/* delta_tssi < 0 ==> target tssi is less than tone tssi and we have to reduce the gain */
	} else {

		PHY_TRACE(("delta_tssi < 0 ==> target tssi is less than"
				"tone tssi and we have to reduce the gain\n"));

		tx_idx_step = 1;
		dont_alter_step = 0;
		pad_step_size = 0;
		pad_iteration_count = 0;

		sat_delta = 0;
		ct = 0;

		for (tx_idx = 0; tx_idx <= MAX_TX_IDX; tx_idx +=  tx_idx_step) {
			wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);

			wlc_phy_get_txgain_settings_by_index_acphy(
					pi, &(target_gains[0]), tx_idx);

			if (pad_step_size != 0) {
				curr_pad_gain = target_gains->rad_gain_mi & 0x00ff;
				curr_pad_gain = curr_pad_gain -
				(pad_iteration_count * pad_step_size);

				target_gains->rad_gain_mi =
				target_gains->rad_gain_mi & 0xff00;

				target_gains->rad_gain_mi |= curr_pad_gain;
			}

			wlc_phy_poll_samps_WAR_acphy(pi, tssi, TRUE,
			                             FALSE, &(target_gains[0]), FALSE, TRUE, 0, 0);
			tone_tssi[0] = tssi[0] - idle_tssi[0];

			delta_tssi = target_tssi - tone_tssi[0];

			PHY_TRACE(("Index = %3d target_TSSI = %4i "
					"tone_TSSI = %4i delta_TSSI = %4i min_delta = %4i "
					"radio gain = 0x%x%x%x, bbm=%d, dacgn = %d\n", tx_idx,
					target_tssi, tone_tssi[0], delta_tssi, min_delta,
					target_gains->rad_gain_hi, target_gains->rad_gain_mi,
					target_gains->rad_gain,
					target_gains->bbmult, target_gains->dac_gain));

			/* Check for TSSI Saturation */
			if (ct == 0) {
				sat_delta = delta_tssi;
			} else {
				sat_delta = delta_tssi - prev_delta;
				sat_delta = ABS(sat_delta);

				PHY_TRACE(("Ct=%d sat_delta=%d delta_tssi=%d sat_delta=%d\n",
					ct, sat_delta, delta_tssi, sat_delta));
			}

			if (sat_delta > sat_threshold) {
				ct = 0;
			}

			if ((ct == sat_count) && (sat_delta < sat_threshold) &&
				(ABS(delta_tssi) < sat_threshold)) {

				PHY_TRACE(("Ct = %d\t sat_delta = %d \t sat_threshold = %d\n",
					ct, sat_delta, sat_threshold));

				gain_code_found	= 0;

				PHY_TRACE(("Breaking out of search as TSSI "
						" seems to have saturated\n"));

				WLC_PHY_PRECAL_TRACE(tx_idx, target_gains);

				break;
			}

			ct = ct + 1;

			temp_val = ABS(delta_tssi);
			if (temp_val <= min_delta) {
				min_delta = ABS(delta_tssi);

				if (min_delta <= delta_threshold) {
					gain_code_found	= 1;

					PHY_TRACE(("Breaking out of search "
							"as min delta tssi threshold "
							"conditions are met\n"));

					WLC_PHY_PRECAL_TRACE(tx_idx, target_gains);

					PHY_TRACE(("===== IQLOCAL PreCalGainControl: END =====\n"));
					break;
				}
			}

			/* Change of sign in delta tssi => increase
			 * the step size with smaller resolution
			 */

			if ((prev_delta < 0) && (delta_tssi > 0)&& (tx_idx != 0))
			{
				PHY_TRACE(("Scenario 2 -- BELOW TARGET\n"));
				/* Now that tx idx is sufficiently dropped ,
				 * there is change in sign of the delta tssi.
				 * implies, now target tssi is more than tone tssi.
				 * So increase the gain in very small steps
				 * by decrementing the index
				 */
				tx_idx_step = -1;
				dont_alter_step = 1;
			} else if ((prev_delta < 0) && (delta_tssi < 0) && (dont_alter_step == 1)) {
				PHY_TRACE(("Scenario 3 --  OSCILLATORY\n"));

				/* this case is to take care of the oscillatory
				 * behaviour of the tone tssi about the target
				 * tssi. Here tone tssi has again
				 * overshot the target tssi. So donot change the
				 * tx gain index, but reduce the PAD gain
				 */
				tx_idx_step = 0;
				pad_step_size = 1;
				pad_iteration_count += 1;

			} else {
				PHY_TRACE(("Scenario 1 -- NORMAL\n"));
				/* tone tssi is more than target tssi.
				 * So increase the index and hence reduce the gain
				 */
				if (dont_alter_step == 0) {
					/* Manipulate the step size to cut down the search time */
					if (delta_tssi >= 50) {
						tx_idx_step = 5;
					} else if (delta_tssi >= 25) {
						tx_idx_step = 3;
					} else if (delta_tssi >= 10) {
						tx_idx_step = 2;
					} else {
						tx_idx_step = 1;
					}
				}
			}
			prev_delta = delta_tssi;
		}

	}

	/* Search found the right gain code meeting required tssi conditions */
	if (gain_code_found == 1) {

		PHY_TRACE(("******* SUMMARY *******\n"));
		WLC_PHY_PRECAL_TRACE(tx_idx, target_gains);

		PHY_TRACE(("Measured TSSI Value is %d\n", tone_tssi[0]));
		PHY_TRACE(("***********************\n"));
	}
	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	PHY_TRACE(("======= IQLOCAL PreCalGainControl : END =======\n"));

	/* Restore the original Gain code */
	wlc_phy_txcal_txgain_cleanup_acphy(pi, &orig_txgain[0]);

	return;
}

static void
wlc_phy_precal_txgain_control(phy_info_t *pi, txgain_setting_t *target_gains)
{
	int16  avvmid_set_local[2][2]     = {{1, 145}, {1,  145}};
	int16  target_tssi_set[3][5]   = {
		{710, 720, 425, 340, 370},
		{350, 350, 350, 350, 350},
		{700, 700, 700, 700, 700}
	};
	int16 delta_tssi_error = 25;
	uint8  start_gain_idx[3][5][2] = {
		{{5, 31}, {5, 31}, {16, 31}, {16, 21}, {16, 24}},
		{{8, 31}, {8, 31}, {10, 31}, {14, 21}, {14, 24}},
		{{5, 31}, {5, 31}, {16, 31}, {16, 21}, {16, 24}}
	};
	uint8  gain_ladder[32] =
		{0x07, 0x0F, 0x17, 0x1F, 0x27, 0x2F, 0x37, 0x3F,
	0x47, 0x4F, 0x57, 0x5F, 0x67, 0x6F, 0x77, 0x7F,
	0x87, 0x8F, 0x97, 0x9F, 0xA7, 0xAF, 0xB7, 0xBF,
	0xC7, 0xCF, 0xD7, 0xDF, 0xE7, 0xEF, 0xF7, 0xFF};

	uint8  band_idx, majorrev_idx, band_bw_idx, pad_gain, pga_gain, core;
	uint8  idx_min = 0, idx_max = 31, idx_curr = 0, idx_curr1 = 0, stall_val;
	uint8  need_more_gain, reduce_gain, adjust_pga, final_step;
	int16  idle_tssi[PHY_CORE_MAX], tone_tssi[PHY_CORE_MAX];
	int16  target_tssi, delta_tssi, delta_tssi1;

	struct _orig_reg_vals {
		uint8 core;
		uint16 orig_OVR3;
		uint16 orig_auxpga_cfg1;
		uint16 orig_auxpga_vmid;
		uint16 orig_iqcal_cfg1;
		uint16 orig_tx5g_tssi;
		uint16 orig_pa2g_tssi;
		uint16 orig_RfctrlIntc;
		uint16 orig_RfctrlOverrideRxPus;
		uint16 orig_RfctrlCoreRxPu;
		uint16 orig_RfctrlOverrideAuxTssi;
		uint16 orig_RfctrlCoreAuxTssi1;
		uint16 orig_RfctrlOverrideTxPus;
		uint16 orig_RfctrlCoreTxPus;
	} orig_reg_vals[PHY_CORE_MAX];

	uint core_count = 0;
	uint8 max_pad_idx = 31;

	txgain_setting_t curr_gain, curr_gain1;
	bool init_adc_inside = FALSE;
	uint16 save_afePuCtrl, save_gpio, save_gpioHiOutEn;
	uint16 fval2g_orig, fval5g_orig, fval2g, fval5g;
	uint32 save_chipc = 0;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	band_idx = CHSPEC_IS5G(pi->radio_chanspec);

	if (band_idx == 0 && ACMAJORREV_1(pi->pubpi.phy_rev)) {
			max_pad_idx = 19;
	}

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		band_bw_idx = band_idx * 2 + 2;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		band_bw_idx = band_idx * 2 + 1;
	} else {
		band_bw_idx = band_idx * 2 + 0;
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		majorrev_idx = 0;
	} else if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) &&
		(RADIOREV(pi->pubpi.radiorev) == 0x2C ||
		RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
		(PHY_XTAL_IS40M(pi))) {
		majorrev_idx = 2;
	} else {
		majorrev_idx = 1;
	}

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	/* Turn off epa/ipa and unused rxrf part to prevent energy go into air */
	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {

		/* save phy/radio regs going to be touched */
		orig_reg_vals[core_count].orig_RfctrlIntc = READ_PHYREGCE(pi, RfctrlIntc, core);
		orig_reg_vals[core_count].orig_RfctrlOverrideRxPus
			= READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
		orig_reg_vals[core_count].orig_RfctrlCoreRxPu
			= READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
		orig_reg_vals[core_count].orig_RfctrlOverrideAuxTssi
			= READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
		orig_reg_vals[core_count].orig_RfctrlCoreAuxTssi1
			= READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);

		orig_reg_vals[core_count].orig_OVR3 = READ_RADIO_REGC(pi, RF, OVR3, core);
		orig_reg_vals[core_count].orig_auxpga_cfg1 =
			READ_RADIO_REGC(pi, RF, AUXPGA_CFG1, core);
		orig_reg_vals[core_count].orig_auxpga_vmid =
			READ_RADIO_REGC(pi, RF, AUXPGA_VMID, core);
		orig_reg_vals[core_count].orig_iqcal_cfg1 =
			READ_RADIO_REGC(pi, RF, IQCAL_CFG1, core);
		orig_reg_vals[core_count].orig_tx5g_tssi = READ_RADIO_REGC(pi, RF, TX5G_TSSI, core);
		orig_reg_vals[core_count].orig_pa2g_tssi = READ_RADIO_REGC(pi, RF, PA2G_TSSI, core);
		orig_reg_vals[core_count].orig_RfctrlOverrideTxPus =
			READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
		orig_reg_vals[core_count].orig_RfctrlCoreTxPus =
			READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
		orig_reg_vals[core_count].core = core;

		/* set proper Av/Vmid */
		MOD_RADIO_REGC(pi, OVR3, core, ovr_auxpga_i_sel_gain, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_CFG1, core,
		               auxpga_i_sel_gain, avvmid_set_local[band_idx][0]);
		MOD_RADIO_REGC(pi, OVR3, core, ovr_afe_auxpga_i_sel_vmid, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_VMID, core,
		               auxpga_i_sel_vmid, avvmid_set_local[band_idx][1]);

		/* turn off ext-pa and put ext-trsw in r position */
		WRITE_PHYREGCE(pi, RfctrlIntc, core, 0x1400);
		/* 20691 iTR trsw */
		if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
			ACPHY_REG_LIST_START
			    MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_pu, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu, 1)
			    MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0,
			        ovr_trsw2g_bias_pu, 1)
			    MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu, 0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}

		/* turn off iPA */
		if (PHY_IPA(pi)) {
			MOD_PHYREGCE(pi, RfctrlOverrideTxPus,  core, pa_pwrup, 1);
			MOD_PHYREGCE(pi, RfctrlCoreTxPus,  core, pa_pwrup, 0);
		}
		/* set tssi_range = 0 (it suppose to bypass 10dB attenuation before pdet) */
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_range, 0);

		/* turn off lna and other unsed rxrf components */
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, 0x7CE0);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus,     core, 0x0);

		++core_count;
	}
	ACPHY_ENABLE_STALL(pi, stall_val);

	/* tssi loopback setup */
	wlc_phy_tssi_phy_setup_acphy(pi, 1);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 1);
	else
		wlc_phy_tssi_radio_setup_acphy(pi,  pi->sh->hw_phyrxchain, 1);

	if (!init_adc_inside) {
		wlc_phy_init_adc_read(pi, &save_afePuCtrl, &save_gpio,
		                      &save_chipc, &fval2g_orig, &fval5g_orig,
		                      &fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
	}

	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		if (!init_adc_inside)
			wlc_phy_gpiosel_acphy(pi, 16+core, 1);
		/* Measure the Idle TSSI */
		wlc_phy_poll_samps_WAR_acphy(pi, idle_tssi, TRUE, TRUE, NULL,
		                             TRUE, init_adc_inside, core, 0);
		/* Adjust Target TSSI based on Idle TSSI */
		target_tssi = target_tssi_set[majorrev_idx][band_bw_idx] + idle_tssi[core];

		/* set the initial txgain */
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain, 0);
		pad_gain = gain_ladder[start_gain_idx[majorrev_idx][band_bw_idx][0]];
		pga_gain = gain_ladder[start_gain_idx[majorrev_idx][band_bw_idx][1]];
		curr_gain.rad_gain_mi = (pad_gain & 0xFF) | ((pga_gain & 0xFF) << 8);
		curr_gain.bbmult = 64;

		/* Measure the tone TSSI */
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi, TRUE, FALSE,
		                             &curr_gain, TRUE, init_adc_inside, core, 0);
		delta_tssi  = target_tssi - tone_tssi[core];
		need_more_gain = (delta_tssi >= delta_tssi_error);
		reduce_gain = (delta_tssi < -delta_tssi_error);
		if (need_more_gain || reduce_gain) {
			/* if need more gain, try first max pad gain; otherwise, try min pga gain */
			curr_gain1 = curr_gain;
			curr_gain1.rad_gain_mi = (need_more_gain)
				? (
				   (curr_gain.rad_gain_mi & 0xFF00)
				   |((gain_ladder[max_pad_idx] & 0xFF) << 0))
				: (
				   (curr_gain.rad_gain_mi & 0x00FF)
				   |((gain_ladder[0]  & 0xFF) << 8));

			wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi, TRUE, FALSE,
			                             &curr_gain1, TRUE, init_adc_inside, core, 0);
			delta_tssi1 = target_tssi - tone_tssi[core];
			adjust_pga = (delta_tssi1 >= 0);

			if (need_more_gain) {
				idx_min = start_gain_idx[majorrev_idx][band_bw_idx][adjust_pga];
				idx_max = max_pad_idx;
				curr_gain.rad_gain_mi = (adjust_pga)?
					curr_gain1.rad_gain_mi : curr_gain.rad_gain_mi;
				curr_gain1  = curr_gain;
				delta_tssi1 = (adjust_pga)? delta_tssi1: delta_tssi;
			} else if (reduce_gain) {
				idx_min = 0;
				idx_max = start_gain_idx[majorrev_idx][band_bw_idx][adjust_pga];
				curr_gain.rad_gain_mi = (adjust_pga)?
					curr_gain.rad_gain_mi : curr_gain1.rad_gain_mi;
				curr_gain1  = curr_gain;
				delta_tssi1 = (adjust_pga)? delta_tssi: delta_tssi1;
			}

			final_step = 0;
			do {
				if (idx_min >= idx_max-1) {
					final_step = 1;
					idx_curr = (idx_curr == idx_min)? idx_max: idx_min;
				} else {
					idx_curr = (idx_min + idx_max) >> 1;
				}

				if (adjust_pga) {
					curr_gain.rad_gain_mi =
						(curr_gain.rad_gain_mi & 0x00FF) |
						((gain_ladder[idx_curr] & 0xFF) << 8);
				} else {
					curr_gain.rad_gain_mi =
						(curr_gain.rad_gain_mi & 0xFF00) |
						((gain_ladder[idx_curr] & 0xFF) << 0);
				}

				wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi, TRUE, FALSE,
				                             &curr_gain, TRUE,
				                             init_adc_inside, core, 0);
				delta_tssi  = target_tssi - tone_tssi[core];

				if (final_step) {
					if (ABS(delta_tssi) > ABS(delta_tssi1)) {
						idx_min  = idx_curr1;
						idx_max  = idx_curr1;
						idx_curr = idx_curr1;
						delta_tssi = delta_tssi1;
						curr_gain  = curr_gain1;
					} else {
						idx_min  = idx_curr;
						idx_max  = idx_curr;
					}
				} else {
					if (delta_tssi >= delta_tssi_error) {
						idx_min = idx_curr;
					} else if (delta_tssi < -delta_tssi_error) {
						idx_max = idx_curr;
					} else {
						idx_min = idx_curr;
						idx_max = idx_curr;
					}

					/* always log the current tssi & gain */
					delta_tssi1 = delta_tssi;
					curr_gain1  = curr_gain;
					idx_curr1   = idx_curr;
				}

				/* only used for debugging print */
				if (0) {
					if (adjust_pga) {
						printf("PGA-idx = (%d,%d,%d), dtssi = (%d, %d)\n",
						       idx_min, idx_curr, idx_max,
						       delta_tssi, delta_tssi1);
					} else {
						printf("PAD-idx = (%d,%d,%d), dtssi = (%d, %d)\n",
						       idx_min, idx_curr, idx_max,
						       delta_tssi, delta_tssi1);
					}
				}

			} while (idx_min < idx_max);
		}
		/* assign the best found gain */
		target_gains[core] = curr_gain;

		PHY_TRACE(("Best txgain found for Core%d: (%2x %2x %2x %2x %2x %2x)\n",
		           core, (target_gains[core].rad_gain & 0xF),
		           (target_gains[core].rad_gain >> 4) & 0xF,
		           (target_gains[core].rad_gain >> 8) & 0xFF,
		           (target_gains[core].rad_gain_mi >> 0) & 0xFF,
		           (target_gains[core].rad_gain_mi >> 8) & 0xFF,
		           (target_gains[core].rad_gain_hi >> 0) & 0xFF));
	}

	if (!init_adc_inside)
		wlc_phy_restore_after_adc_read(pi, &save_afePuCtrl, &save_gpio,
		                               &save_chipc,  &fval2g_orig,  &fval5g_orig,
		                               &fval2g,  &fval5g, &stall_val, &save_gpioHiOutEn);

	/* restore phy/radio regs */
	while (core_count > 0) {
		--core_count;
		write_radio_reg(pi, RF_2069_OVR3(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_OVR3);
		write_radio_reg(pi, RF_2069_AUXPGA_CFG1(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_auxpga_cfg1);
		write_radio_reg(pi, RF_2069_AUXPGA_VMID(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_auxpga_vmid);
		write_radio_reg(pi, RF_2069_IQCAL_CFG1(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_iqcal_cfg1);
		write_radio_reg(pi, RF_2069_TX5G_TSSI(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_tx5g_tssi);
		write_radio_reg(pi, RF_2069_PA2G_TSSI(orig_reg_vals[core_count].core),
			orig_reg_vals[core_count].orig_pa2g_tssi);
		WRITE_PHYREGCE(pi, RfctrlIntc, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlIntc);
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlOverrideRxPus);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlCoreRxPu);
		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlOverrideAuxTssi);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlCoreAuxTssi1);
		if (PHY_IPA(pi)) {
			WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlOverrideTxPus);
			WRITE_PHYREGCE(pi, RfctrlCoreTxPus, orig_reg_vals[core_count].core,
			orig_reg_vals[core_count].orig_RfctrlCoreTxPus);
		}
	}

	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	PHY_TRACE(("======= IQLOCAL PreCalGainControl : END =======\n"));

	return;
}

static void
wlc_phy_precal_txgain_acphy(phy_info_t *pi, txgain_setting_t *target_gains)
{
	/*   This function determines the tx gain settings to be
	 *   used during tx iqlo calibration; that is, it sends back
	 *   the following settings for each core:
	 *       - radio gain
	 *       - dac gain
	 *       - bbmult
	 *   This is accomplished by choosing a predefined power-index, or by
	 *   setting gain elements explicitly to predefined values, or by
	 *   doing actual "pre-cal gain control". Either way, the idea is
	 *   to get a stable setting for which the swing going into the
	 *   envelope detectors is large enough for good "envelope ripple"
	 *   while avoiding distortion or EnvDet overdrive during the cal.
	 *
	 *   Note:
	 *       - this function and the calling infrastructure is set up
	 *         in a way not to leave behind any modified state; this
	 *         is in contrast to mimophy ("nphy"); in acphy, only the
	 *         desired gain quantities are set/found and set back
	 */

	uint8 core;
	uint8 subband;
	uint8 phy_bw;
	acphy_cal_result_t *accal = &pi->cal_info->u.accal;

	uint8 en_precal_gain_control = 0;
	int8 tx_pwr_idx[3] = {20, 30, 20};
	const int8 tx_pwr_idx_5g[4][3] = {{20, 30, 30}, {20, 23, 20}, {20, 25, 20}, {20, 30, 20}};

	/* reset ladder_updated flags so tx-iqlo-cal ensures appropriate recalculation */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		accal->txiqlocal_ladder_updated[core] = 0;
	}
	/* phy_bw */
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		phy_bw = 80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		phy_bw = 40;
	} else {
		phy_bw = 20;
	}

	/* Enable Precal gain control only for 4335 */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev)) {
		en_precal_gain_control = 2;
	}

	if (en_precal_gain_control == 0) {
		/* get target tx gain settings */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			/* specify tx gain by index (reads from tx power table) */
			int8 target_pwr_idx;
			if (ACREV_IS(pi->pubpi.phy_rev, 1)|| ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* for 4360B0 and 43602 using 0.5dB-step, idx is lower */
				subband = wlc_phy_get_chan_freq_range_acphy(pi, 0);
				if ((pi->u.pi_acphy->srom.precal_tx_idx) &&
				    CHSPEC_IS5G(pi->radio_chanspec) && (subband >= 1)) {
					--subband;
					target_pwr_idx = tx_pwr_idx_5g[subband][core];
				} else {
					target_pwr_idx = (core != 0) ? 30 : 20;
					if (wlc_phy_get_chan_freq_range_acphy(pi, 0) ==
					  WL_CHAN_FREQ_RANGE_5G_BAND3) {
						target_pwr_idx = tx_pwr_idx[core];
					}
				}
			} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
			           RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1 &&
			           !(ACRADIO_2069_EPA_IS(pi->pubpi.radiorev))) {
				if (CHSPEC_IS2G(pi->radio_chanspec) == 1) {
					target_pwr_idx = 1;
				} else {
					if (phy_bw == 20)
						target_pwr_idx = 0;
					else if (phy_bw == 40)
						target_pwr_idx = 15;
					else
						target_pwr_idx = 10;
				}
			} else if (TINY_RADIO(pi)) {
				if (PHY_IPA(pi)) {
					if (CHSPEC_IS5G(pi->radio_chanspec)) {
						target_pwr_idx = 62;
					} else {
						target_pwr_idx = 50;
						if (ACREV_IS(pi->pubpi.phy_rev, 13)) {
							target_pwr_idx = (pi->sh->extpagain2g == 0)
								? 10:32;
							/* iTR - different target_pwr_idx */
							if ((RADIOID(pi->pubpi.radioid)
								== BCM20691_ID) &&
								(pi->itrsw == 1)) {
								target_pwr_idx = 50;
							}
						}
					}
				} else {
					if (CHSPEC_IS5G(pi->radio_chanspec)) {
						if (pi->txgaintbl5g == 1) {
#ifndef WLC_POINT5_DB_TX_GAIN_STEP /* Disable 0.5 dB gain step */
							target_pwr_idx = 60;
						} else {
							target_pwr_idx = 62;
						}
					} else {
						target_pwr_idx = 50;
					}
#else
							target_pwr_idx = 30;
						} else {
							target_pwr_idx = 31;
						}
					} else {
						target_pwr_idx = 25;
					}
#endif /* Disable 0.5 dB gain step */
				}
				if (CHSPEC_IS2G(pi->radio_chanspec) && (pi->txiqcalidx2g != -1)) {
					target_pwr_idx = pi->txiqcalidx2g;
				} else if (CHSPEC_IS5G(pi->radio_chanspec) &&
					(pi->txiqcalidx5g != -1)) {
					target_pwr_idx = pi->txiqcalidx5g;
				}
			} else {
				target_pwr_idx = 30;
			}

			wlc_phy_get_txgain_settings_by_index_acphy(
				pi, &(target_gains[core]), target_pwr_idx);

			if ((CHSPEC_IS5G(pi->radio_chanspec) == 1) &&
			    (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
			     RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1)) {
				/* use PAD gain 255 for TXIQLOCAL */
				target_gains[core].rad_gain_mi |= 0xff;
			}
		}

	} else if (en_precal_gain_control == 1) {
		PHY_TRACE(("========= Calling precal gain control =========\n"));
		wlc_phy_precal_target_tssi_search(pi, &(target_gains[0]));
	} else if (en_precal_gain_control == 2) {
		PHY_TRACE(("========= Calling precal gain control =========\n"));
		wlc_phy_precal_txgain_control(pi, &(target_gains[0]));
	}
}

static void
wlc_phy_loadsampletable_acphy(phy_info_t *pi, cint32 *tone_buf, uint16 num_samps,
                              bool alloc, bool conj)
{
	uint16 t;
	uint32* data_buf = NULL;
	int32 sgn = 1;

	if (alloc) {
	  /* allocate buffer */
	  if ((data_buf = (uint32 *)MALLOC(pi->sh->osh, sizeof(uint32) * num_samps)) == NULL) {
	    PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
	               __FUNCTION__, MALLOCED(pi->sh->osh)));
	    return;
	  }
	} else {
	  data_buf = (uint32*)tone_buf;
	}

	if (conj)
	  sgn = -1;

	/* load samples into sample play buffer */
	for (t = 0; t < num_samps; t++) {
		data_buf[t] = ((((unsigned int)tone_buf[t].i) & 0x3ff) << 10) |
		               (((unsigned int)(sgn * tone_buf[t].q)) & 0x3ff);
	}
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_SAMPLEPLAY, num_samps, 0, 32, data_buf);

	if (alloc && (data_buf != NULL))
		MFREE(pi->sh->osh, data_buf, sizeof(uint32) * num_samps);
}

static uint16
wlc_phy_gen_load_samples_acphy(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 mac_based)
{
	uint8 fs_spb;
	uint16 num_samps, t;
	fixed theta = 0, rot = 0;
	uint32 tbl_len;
	cint32* tone_buf = NULL;

	/* check phy_bw */
	if (pi->u.pi_acphy->dac_mode == 1) {
		if (CHSPEC_IS80(pi->radio_chanspec))
			fs_spb = 80;
		else if (CHSPEC_IS40(pi->radio_chanspec))
			fs_spb = 40;
		else
			fs_spb = 20;
	} else if (pi->u.pi_acphy->dac_mode == 2) {
		fs_spb = 80;
	} else { /* dac mode 3 */
		fs_spb = 40;
	}
	tbl_len = fs_spb << 1;

	/* allocate buffer */
	if ((tone_buf = (cint32 *)MALLOC(pi->sh->osh, sizeof(cint32) * tbl_len)) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		          __FUNCTION__, MALLOCED(pi->sh->osh)));
		return 0;
	}

	/* set up params to generate tone */
	num_samps  = (uint16)tbl_len;
	rot = FIXED((f_kHz * 36)/fs_spb) / 100; /* 2*pi*f/bw/1000  Note: f in KHz */
	theta = 0; /* start angle 0 */

	/* tone freq = f_c MHz ; phy_bw = phy_bw MHz ; # samples = phy_bw (1us) */
	for (t = 0; t < num_samps; t++) {
		/* compute phasor */
		wlc_phy_cordic(theta, &tone_buf[t]);
		/* update rotation angle */
		theta += rot;
		/* produce sample values for play buffer */
		tone_buf[t].q = (int32)FLOAT(tone_buf[t].q * max_val);
		tone_buf[t].i = (int32)FLOAT(tone_buf[t].i * max_val);
	}

	/* load sample table */
	wlc_phy_loadsampletable_acphy(pi, tone_buf, num_samps, TRUE, FALSE);

	if (tone_buf != NULL)
		MFREE(pi->sh->osh, tone_buf, sizeof(cint32) * tbl_len);

	return num_samps;
}

static void
assign_sample80_buffer(cint32 *tone_buf, int16 t)
{
	int16 imSamp80[80] = {186, 185, 184, 181, 177, 172, 166, 159, 150, 141,
		132,  121,  109,   97,   84,   71,   57,   43,   29,   15,
		0,  -15,  -29,  -43,  -57,  -71,  -84,  -97, -109, -121,
		-132, -141, -150, -159, -166, -172, -177, -181, -184, -185,
		-186, -185, -184, -181, -177, -172, -166, -159, -150, -141,
		-132, -121, -109,  -97,  -84,  -71,  -57,  -43,  -29,  -15,
		0,   15,   29,   43,   57,   71,   84,   97,  109,  121,
		132,  141,  150,  159,  166,  172,  177,  181,  184,  185};

	int16 realSamp80[80] = {0, 15, 29, 43, 57, 71, 84, 97, 109, 121,
		132,  141,  150,  159,  166,  172,  177,  181,  184,  185,
		186,  185,  184,  181,  177,  172,  166,  159,  150,  141,
		132,  121,  109,   97,   84,   71,   57,   43,   29,   15,
		0,  -15,  -29,  -43,  -57,  -71,  -84,  -97, -109, -121,
		-132, -141, -150, -159, -166, -172, -177, -181, -184, -185,
		-186, -185, -184, -181, -177, -172, -166, -159, -150, -141,
		-132, -121, -109,  -97,  -84,  -71,  -57,  -43,  -29,  -15};

	ASSERT(tone_buf);
	ASSERT(t < (int)ARRAYSIZE(imSamp80) && t < (int)ARRAYSIZE(realSamp80));

	tone_buf[t].q = (imSamp80[t]);
	tone_buf[t].i = (realSamp80[t]);
}

static void
assign_sample40_buffer(cint32 *tone_buf, int16 t)
{
	int16 realSamp40[40] = {0, 29, 57, 84, 109, 132, 150, 166, 177, 184,
		186,  184,  177,  166,  150,  132,  109,   84,   57,   29,
		0,  -29,  -57,  -84, -109, -132, -150, -166, -177, -184,
		-186, -184, -177, -166, -150, -132, -109,  -84,  -57,  -29};

	int16 imSamp40[40] = {186, 184, 177, 166, 150, 132, 109, 84, 57, 29,
		0,  -29,  -57,  -84, -109, -132, -150, -166, -177, -184,
		-186, -184, -177, -166, -150, -132, -109,  -84,  -57,  -29,
		0,   29,   57,   84,  109,  132,  150,  166,  177,  184};

	ASSERT(tone_buf);
	ASSERT(t < (int)ARRAYSIZE(imSamp40) && t < (int)ARRAYSIZE(realSamp40));

	tone_buf[t].q = (imSamp40[t]);
	tone_buf[t].i = (realSamp40[t]);
}

static void
assign_sample20_buffer(cint32 *tone_buf, int16 t)
{
	int16 realSamp20[20] = {0,  57,  109,  150,  177,  186,  177,  150,  109,  57,
		0, -57, -109, -150, -177, -186, -177, -150, -109, -57};

	int16 imSamp20[20] = {186,  177,  150,  109,  57, 0, -57, -109, -150, -177,
		-186, -177, -150, -109, -57, 0, 57, 109,  150,  177};

	ASSERT(tone_buf);
	ASSERT(t < (int)ARRAYSIZE(imSamp20) && t < (int)ARRAYSIZE(realSamp20));

	tone_buf[t].q = (imSamp20[t]);
	tone_buf[t].i = (realSamp20[t]);
}

static uint16
wlc_phy_gen_load_samples_acphy_papd(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 mac_based)
{
	uint8 phy_bw;
	uint16 num_samps, t;
	cint32* tone_buf = NULL;

	/* check phy_bw */
	if (CHSPEC_IS80(pi->radio_chanspec))
		phy_bw = 80;
	else if (CHSPEC_IS40(pi->radio_chanspec))
		phy_bw = 40;
	else
		phy_bw = 20;

	/* allocate buffer */
	if ((tone_buf = (cint32 *)MALLOC(pi->sh->osh, sizeof(cint32) * phy_bw)) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n", pi->sh->unit,
		          __FUNCTION__, MALLOCED(pi->sh->osh)));
		return 0;
	}

	/* set up params to generate tone */
	num_samps  = (uint16)phy_bw;

	/* tone freq = f_c MHz ; phy_bw = phy_bw MHz ; # samples = phy_bw (1us) */
	for (t = 0; t < num_samps; t++) {
		/* produce sample values for play buffer */
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			assign_sample80_buffer(tone_buf, t);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			assign_sample40_buffer(tone_buf, t);
		} else {
			assign_sample20_buffer(tone_buf, t);
		}
		if (TINY_RADIO(pi)) {
			int32 swap = tone_buf[t].i;
			tone_buf[t].i = tone_buf[t].q;
			tone_buf[t].q = swap;
		}
	}

	/* load sample table */
	wlc_phy_loadsampletable_acphy(pi, tone_buf, num_samps, TRUE, FALSE);

	if (tone_buf != NULL)
		MFREE(pi->sh->osh, tone_buf, sizeof(cint32) * phy_bw);

	return num_samps;
}

int
wlc_phy_tx_tone_acphy(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 iqmode,
                      uint8 mac_based, bool modify_bbmult)
{
	uint8 core;
	uint16 num_samps;
	uint16 bb_mult;
	uint16 loops = 0xffff;
	uint16 wait = 0;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (max_val == 0) {
		/* XXX PR90390: For a zero ampltitude signal, bypass loading samples
		 * and set bbmult = 0
		 */
		num_samps = 1;
	} else if ((num_samps = wlc_phy_gen_load_samples_acphy(pi, f_kHz, max_val, mac_based))
	           == 0) {
		return BCME_ERROR;
	}

	if (pi_ac->bb_mult_save_valid == 0) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_get_tx_bbmult_acphy(pi, &pi_ac->bb_mult_save[core], core);
		}
		pi_ac->bb_mult_save_valid = 1;
	}

	/* XXX  max_val = 0, set bbmult = 0
	 * elseif modify_bbmult = 1,
	 * set samp_play (default mag 186) power @ DAC = OFDM packet power @ DAC (9.5-bit RMS)
	 * by setting bb_mult (2.6 format) to
	 * 64/64 for bw = 20, 40, 80MHz
	 */
	if (max_val == 0 || modify_bbmult) {
		if (max_val == 0) {
			bb_mult = 0;
		} else {
			if (CHSPEC_IS80(pi->radio_chanspec))
				bb_mult = 64;
			else if (CHSPEC_IS40(pi->radio_chanspec))
				bb_mult = 64;
			else
				bb_mult = 64;
		}
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_set_tx_bbmult_acphy(pi, &bb_mult, core);
		}
	}

	if (ACMAJORREV_5(pi->pubpi.phy_rev) && ACMINORREV_0(pi->pubpi.phy_rev) &&
	    pi_ac->srom.femctrl == 3 &&
	    (pi_ac->srom.femctrl_sub == 0 || pi_ac->srom.femctrl_sub == 3)) {
		/* 43602a0 router boards with PAVREF WAR: turn on PA */
		si_pmu_regcontrol(pi->sh->sih, 0, 0x7, 7);
	}

	wlc_phy_runsamples_acphy(pi, num_samps, loops, wait, iqmode, mac_based);

	return BCME_OK;
}

int
wlc_phy_tx_tone_acphy_papd(phy_info_t *pi, int32 f_kHz, uint16 max_val, uint8 iqmode,
                      uint8 mac_based, bool modify_bbmult)
{
	uint8 core;
	uint16 num_samps;
	uint16 bb_mult;
	uint16 loops = 0xffff;
	uint16 wait = 0;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (max_val == 0) {
		/* XXX PR90390: For a zero ampltitude signal, bypass loading samples
		 * and set bbmult = 0
		 */
		num_samps = 1;
	} else if ((num_samps = wlc_phy_gen_load_samples_acphy_papd(pi, f_kHz, max_val, mac_based))
	           == 0) {
		return BCME_ERROR;
	}

	if (pi_ac->bb_mult_save_valid == 0) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_get_tx_bbmult_acphy(pi, &pi_ac->bb_mult_save[core], core);
		}
		pi_ac->bb_mult_save_valid = 1;
	}

	/* XXX  max_val = 0, set bbmult = 0
	 * elseif modify_bbmult = 1,
	 * set samp_play (default mag 186) power @ DAC = OFDM packet power @ DAC (9.5-bit RMS)
	 * by setting bb_mult (2.6 format) to
	 * 64/64 for bw = 20, 40, 80MHz
	 */
	if (max_val == 0 || modify_bbmult) {
		if (max_val == 0) {
			bb_mult = 0;
		} else {
			if (CHSPEC_IS80(pi->radio_chanspec))
				bb_mult = 64;
			else if (CHSPEC_IS40(pi->radio_chanspec))
				bb_mult = 64;
			else
				bb_mult = 64;
		}
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_set_tx_bbmult_acphy(pi, &bb_mult, core);
		}
	}

	wlc_phy_runsamples_acphy(pi, num_samps, loops, wait, iqmode, mac_based);

	return BCME_OK;
}

void
wlc_phy_stopplayback_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint16 playback_status;
	uint8 stall_val;

	if (ACMAJORREV_5(pi->pubpi.phy_rev) && ACMINORREV_0(pi->pubpi.phy_rev) &&
	    pi_ac->srom.femctrl == 3 &&
	    (pi_ac->srom.femctrl_sub == 0 || pi_ac->srom.femctrl_sub == 3)) {
		/* 43602a0 router boards with PAVREF WAR: turn off PA */
		si_pmu_regcontrol(pi->sh->sih, 0, 0x7, 0);
	}

	/* check status register */
	playback_status = READ_PHYREG(pi, sampleStatus);
	if (playback_status & 0x1) {
		/* Disable stall before issue the sample play stop
			as the stall can cause it to miss the trigger
			JIRA:CRDOT11ACPHY-1099
			*/
		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		ACPHY_DISABLE_STALL(pi);
		phy_reg_or(pi, ACPHY_sampleCmd(pi->pubpi.phy_rev),
			ACPHY_sampleCmd_stop_MASK(pi->pubpi.phy_rev));
		ACPHY_ENABLE_STALL(pi, stall_val);
	} else if (playback_status & 0x2) {
		phy_reg_and(pi, ACPHY_iqloCalCmdGctl(pi->pubpi.phy_rev),
			(uint16)~ACPHY_iqloCalCmdGctl_iqlo_cal_en_MASK(pi->pubpi.phy_rev));
	} else {
		PHY_CAL(("wlc_phy_stopplayback_acphy: already disabled\n"));
	}
	/* disable the dac_test mode */
	phy_reg_and(pi, ACPHY_sampleCmd(pi->pubpi.phy_rev),
		~ACPHY_sampleCmd_DacTestMode_MASK(pi->pubpi.phy_rev));

	/* if bb_mult_save does exist, restore bb_mult and undef bb_mult_save */
	if (pi_ac->bb_mult_save_valid != 0) {
		uint8 core;

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_set_tx_bbmult_acphy(pi, &pi_ac->bb_mult_save[core], core);
		}
		pi_ac->bb_mult_save_valid = 0;
	}

	wlc_phy_resetcca_acphy(pi);
}

static void
wlc_phy_runsamples_acphy(phy_info_t *pi, uint16 num_samps, uint16 loops, uint16 wait, uint8 iqmode,
                         uint8 mac_based)
{
	uint8  sample_cmd;
	uint16 orig_RfseqCoreActv;
	uint8  dac_test_mode = 0;
	const uint phy_rev = pi->pubpi.phy_rev;
	uint8 stall_val;

	/* The phy_rev parameter is unused in embedded builds as the compiler optimises it away.
	 * Mark the param as unused to avoid compiler warnings.
	 */
	UNUSED_PARAMETER(phy_rev);

	if (!(iqmode))
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	/* Delay for proper RX2TX in sample play ow spurious emissions,radar FD */
	OSL_DELAY(15);

	if (mac_based == 1) {
		phy_reg_or(pi, ACPHY_macbasedDACPlay(phy_rev),
			ACPHY_macbasedDACPlay_macBasedDACPlayEn_MASK(phy_rev));

		if (CHSPEC_IS80(pi->radio_chanspec)) {
			phy_reg_or(pi, ACPHY_macbasedDACPlay(phy_rev),
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_MASK(phy_rev) & (0x3 <<
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_SHIFT(phy_rev)));
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			phy_reg_or(pi, ACPHY_macbasedDACPlay(phy_rev),
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_MASK(phy_rev) & (0x2 <<
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_SHIFT(phy_rev)));
		} else {
			phy_reg_or(pi, ACPHY_macbasedDACPlay(phy_rev),
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_MASK(phy_rev) & (0x1 <<
				ACPHY_macbasedDACPlay_macBasedDACPlayMode_SHIFT(phy_rev)));
		}

		PHY_TRACE(("Starting MAC based Sample Play"));
		wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RX2TX);
	} else {
		phy_reg_and(pi, ACPHY_macbasedDACPlay(phy_rev),
			~ACPHY_macbasedDACPlay_macBasedDACPlayEn_MASK(phy_rev));

		/* configure sample play buffer */
		WRITE_PHYREG(pi, sampleDepthCount, num_samps-1);

		if (loops != 0xffff) { /* 0xffff means: keep looping forever */
			WRITE_PHYREG(pi, sampleLoopCount, loops - 1);
		} else {
			WRITE_PHYREG(pi, sampleLoopCount, loops);
		}

		/* Wait time should be atleast 60 for farrow FIFO depth to settle
		 * 60 is to support 80mhz mode.
		 * Though 20 is even for 20mhz mode, and 40 for 80mhz mode,
		 * but just giving some extra wait time
		 */
		WRITE_PHYREG(pi, sampleInitWaitCount, (wait > 60) ? wait : 60);

		/* start sample play buffer (in regular mode or iqcal mode) */
		orig_RfseqCoreActv = READ_PHYREG(pi, RfseqMode);
		phy_reg_or(pi, ACPHY_RfseqMode(phy_rev),
			ACPHY_RfseqMode_CoreActv_override_MASK(phy_rev));
		phy_reg_and(pi, ACPHY_sampleCmd(phy_rev),
			~ACPHY_sampleCmd_DacTestMode_MASK(phy_rev));
		phy_reg_and(pi, ACPHY_sampleCmd(phy_rev), ~ACPHY_sampleCmd_start_MASK(phy_rev));
		phy_reg_and(pi, ACPHY_iqloCalCmdGctl(phy_rev), 0x3FFF);
		if (iqmode) {
			phy_reg_or(pi, ACPHY_iqloCalCmdGctl(phy_rev), 0x8000);
		} else {
			sample_cmd = ACPHY_sampleCmd_start_MASK(phy_rev);
			sample_cmd |= (dac_test_mode == 1 ?
				ACPHY_sampleCmd_DacTestMode_MASK(phy_rev) : 0);
			/* Disable stall before issue the sample play start
			as the stall can cause it to miss the start
			*/
			stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
			ACPHY_DISABLE_STALL(pi);
			phy_reg_or(pi, ACPHY_sampleCmd(phy_rev), sample_cmd);
			ACPHY_ENABLE_STALL(pi, stall_val);
		}

		/* Wait till the Rx2Tx sequencing is done */
		SPINWAIT(((READ_PHYREG(pi, RfseqStatus0) & 0x1) == 1),
		         ACPHY_SPINWAIT_RUNSAMPLE);

		/* restore mimophyreg(RfseqMode.CoreActv_override) */
		WRITE_PHYREG(pi, RfseqMode, orig_RfseqCoreActv);
	}

	if (!(iqmode))
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
}

static void
wlc_phy_cal_txiqlo_coeffs_acphy(phy_info_t *pi, uint8 rd_wr, uint16 *coeff_vals,
                                uint8 select, uint8 core) {

	/* handles IQLOCAL coefficients access (read/write from/to
	 * iqloCaltbl and pi State)
	 *
	 * not sure if reading/writing the pi state coeffs via this appraoch
	 * is a bit of an overkill
	 */

	/* {num of 16b words to r/w, start offset (ie address), core-to-core block offset} */
	acphy_coeff_access_t coeff_access_info[] = {
		{2, 64, 8},  /* TB_START_COEFFS_AB   */
		{1, 67, 8},  /* TB_START_COEFFS_D    */
		{1, 68, 8},  /* TB_START_COEFFS_E    */
		{1, 69, 8},  /* TB_START_COEFFS_F    */
		{2, 128, 7}, /*   TB_BEST_COEFFS_AB  */
		{1, 131, 7}, /*   TB_BEST_COEFFS_D   */
		{1, 132, 7}, /*   TB_BEST_COEFFS_E   */
		{1, 133, 7}, /*   TB_BEST_COEFFS_F   */
		{2, 96,  4}, /* TB_OFDM_COEFFS_AB    */
		{1, 98,  4}, /* TB_OFDM_COEFFS_D     */
		{2, 112, 4}, /* TB_BPHY_COEFFS_AB    */
		{1, 114, 4}, /* TB_BPHY_COEFFS_D     */
		{2, 0, 5},   /*   PI_INTER_COEFFS_AB */
		{1, 2, 5},   /*   PI_INTER_COEFFS_D  */
		{1, 3, 5},   /*   PI_INTER_COEFFS_E  */
		{1, 4, 5},   /*   PI_INTER_COEFFS_F  */
		{2, 0, 5},   /* PI_FINAL_COEFFS_AB   */
		{1, 2, 5},   /* PI_FINAL_COEFFS_D    */
		{1, 3, 5},   /* PI_FINAL_COEFFS_E    */
		{1, 4, 5}    /* PI_FINAL_COEFFS_F    */
	};
	acphy_cal_result_t *accal = &pi->cal_info->u.accal;

	uint8 nwords, offs, boffs, k;

	/* get access info for desired choice */
	nwords = coeff_access_info[select].nwords;
	offs   = coeff_access_info[select].offs;
	boffs  = coeff_access_info[select].boffs;

	/* read or write given coeffs */
	if (select <= TB_BPHY_COEFFS_D) { /* START and BEST coeffs in Table */
		if (rd_wr == CAL_COEFF_READ) { /* READ */
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL, nwords,
				offs + boffs*core, 16, coeff_vals);
		} else { /* WRITE */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, nwords,
				offs + boffs*core, 16, coeff_vals);
		}
	} else if (select <= PI_INTER_COEFFS_F) { /* PI state intermediate coeffs */
		for (k = 0; k < nwords; k++) {
			if (rd_wr == CAL_COEFF_READ) { /* READ */
				coeff_vals[k] = accal->txiqlocal_interm_coeffs[offs +
				                                               boffs*core + k];
			} else if (rd_wr == CAL_COEFF_WRITE_BIQ2BYP) { /* store for rx cal */
				accal->txiqlocal_biq2byp_coeffs[nwords*core + k] = coeff_vals[k];
			} else { /* WRITE */
				accal->txiqlocal_interm_coeffs[offs +
				                               boffs*core + k] = coeff_vals[k];
			}
		}
	} else { /* PI state final coeffs */
		for (k = 0; k < nwords; k++) { /* PI state final coeffs */
			if (rd_wr == CAL_COEFF_READ) { /* READ */
				coeff_vals[k] = accal->txiqlocal_coeffs[offs + boffs*core + k];
			} else { /* WRITE */
				accal->txiqlocal_coeffs[offs + boffs*core + k] = coeff_vals[k];
			}
		}
	}
}

static void
wlc_phy_cal_txiqlo_update_ladder_acphy(phy_info_t *pi, uint16 bbmult)
{
	uint8  indx;
	uint32 bbmult_scaled;
	uint16 tblentry;
	uint8 stall_val;

	acphy_txiqcal_ladder_t ladder_iqlo_4350_80mhz[] = {
		{75, 0}, {75, 1}, {75, 2}, {75, 3}, {75, 4}, {75, 5},
		{75, 6}, {75, 7}};

	acphy_txiqcal_ladder_t ladder_lo[] = {
		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
		{25, 0}, {25, 1}, {25, 2}, {25, 3}, {25, 4}, {25, 5},
		{25, 6}, {25, 7}, {35, 7}, {50, 7}, {71, 7}, {100, 7}};

	acphy_txiqcal_ladder_t ladder_iq[] = {
		{3, 0}, {4, 0}, {6, 0}, {9, 0}, {13, 0}, {18, 0},
		{25, 0}, {35, 0}, {50, 0}, {71, 0}, {100, 0}, {100, 1},
		{100, 2}, {100, 3}, {100, 4}, {100, 5}, {100, 6}, {100, 7}};
	acphy_txiqcal_ladder_t *ladder_lo_pt;
	acphy_txiqcal_ladder_t *ladder_iq_pt;
	uint8 lad_len = 0;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && CHSPEC_IS80(pi->radio_chanspec)) {
		lad_len = 8;
		ladder_lo_pt = &(ladder_iqlo_4350_80mhz[0]);
		ladder_iq_pt = &(ladder_iqlo_4350_80mhz[0]);
	} else {
		lad_len = 18;
		ladder_lo_pt = &(ladder_lo[0]);
		ladder_iq_pt = &(ladder_iq[0]);
	}

	for (indx = 0; indx < lad_len; indx++) {

		/* calculate and write LO cal gain ladder */
		bbmult_scaled = ladder_lo_pt[indx].percent * bbmult;
		bbmult_scaled /= 100;
		tblentry = ((bbmult_scaled & 0xff) << 8) | ladder_lo_pt[indx].g_env;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, indx, 16, &tblentry);

		/* calculate and write IQ cal gain ladder */
		bbmult_scaled = ladder_iq_pt[indx].percent * bbmult;
		bbmult_scaled /= 100;
		tblentry = ((bbmult_scaled & 0xff) << 8) | ladder_iq_pt[indx].g_env;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, indx+32, 16, &tblentry);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_txcal_radio_setup_acphy(phy_info_t *pi)
{
	/* This stores off and sets Radio-Registers for Tx-iqlo-Calibration;
	 *
	 * Note that Radio Behavior controlled via RFCtrl is handled in the
	 * phy_setup routine, not here; also note that we use the "shotgun"
	 * approach here ("coreAll" suffix to write to all jtag cores at the
	 * same time)
	 */

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* SETUP: set 2059 into iq/lo cal state while saving off orig state */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* save off orig */
		porig->iqcal_cfg1[core]  = READ_RADIO_REGC(pi, RF, IQCAL_CFG1, core);
		porig->iqcal_cfg2[core]  = READ_RADIO_REGC(pi, RF, IQCAL_CFG2, core);
		porig->iqcal_cfg3[core]  = READ_RADIO_REGC(pi, RF, IQCAL_CFG3, core);
		porig->pa2g_tssi[core]   = READ_RADIO_REGC(pi, RF, PA2G_TSSI, core);
		porig->tx5g_tssi[core]   = READ_RADIO_REGC(pi, RF, TX5G_TSSI, core);
		porig->auxpga_cfg1[core] = READ_RADIO_REGC(pi, RF, AUXPGA_CFG1, core);
		porig->OVR14[core]       = READ_RADIO_REGC(pi, RF, GE16_OVR14, core);
		porig->pa5g_cfg1[core]   = READ_RADIO_REGC(pi, RF, PA5G_CFG1, core);

		/* Reg conflict with 2069 rev 16 */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0)
			porig->OVR20[core] = READ_RADIO_REGC(pi, RF, OVR20, core);
		else
			porig->OVR21[core] = READ_RADIO_REGC(pi, RF, GE16_OVR21, core);

		/* now write desired values */

		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0xb);
			MOD_RADIO_REGC(pi, TX5G_TSSI, core, pa5g_ctrl_tssi_sel, 0x1);

			/* Reg conflict with 2069 rev 16 */
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
				MOD_RADIO_REGC(pi, OVR20, core, ovr_pa5g_ctrl_tssi_sel, 0x1);
				MOD_RADIO_REGC(pi, OVR20, core, ovr_pa2g_ctrl_tssi_sel, 0x0);
			} else {
				MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa5g_ctrl_tssi_sel, 0x1);
				MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa2g_ctrl_tssi_sel, 0x0);
			}
			MOD_RADIO_REGC(pi, PA2G_TSSI, core, pa2g_ctrl_tssi_sel, 0x0);
		} else {
			MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0x8);
			MOD_RADIO_REGC(pi, TX5G_TSSI, core, pa5g_ctrl_tssi_sel, 0x0);
			/* Reg conflict with 2069 rev 16 */
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
				MOD_RADIO_REGC(pi, OVR20, core, ovr_pa5g_ctrl_tssi_sel, 0x0);
				MOD_RADIO_REGC(pi, OVR20, core, ovr_pa2g_ctrl_tssi_sel, 0x1);
			} else {
				MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa5g_ctrl_tssi_sel, 0x0);
				MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa2g_ctrl_tssi_sel, 0x1);
			}
			MOD_RADIO_REGC(pi, PA2G_TSSI, core, pa2g_ctrl_tssi_sel, 0x1);
		}
		MOD_RADIO_REGC(pi, IQCAL_CFG1, core, tssi_GPIO_ctrl, 0x0);

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_vcm_ctrl, 0x0);
			/* This bit is supposed to be controlled by phy direct control line.
			 * Please check: http://jira.broadcom.com/browse/HW11ACRADIO-45
			 */
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_sel_input, 0x0);
		}
	} /* for core */
}

static void
wlc_phy_txcal_radio_setup_acphy_20691(phy_info_t *pi)
{
	/* This stores off and sets Radio-Registers for Tx-iqlo-Calibration;
	 *
	 * Note that Radio Behavior controlled via RFCtrl is handled in the
	 * phy_setup routine, not here; also note that we use the "shotgun"
	 * approach here ("coreAll" suffix to write to all jtag cores at the
	 * same time)
	 */
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);
	uint8 core;

#ifndef BCMRADIOREV
	uint8 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* SETUP: set 2059 into iq/lo cal state while saving off orig state */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* save off orig */
		porig->iqcal_cfg1[core] = READ_RADIO_REG_20691(pi, IQCAL_CFG1, core);
		porig->iqcal_ovr1[core] = READ_RADIO_REG_20691(pi, IQCAL_OVR1, core);
		porig->auxpga_cfg1[core] = READ_RADIO_REG_20691(pi, AUXPGA_CFG1, core);
		porig->iqcal_cfg3[core] = READ_RADIO_REG_20691(pi, IQCAL_CFG3, core);
		porig->tx_top_5g_ovr1[core] = READ_RADIO_REG_20691(pi, TX_TOP_5G_OVR1, core);
		porig->adc_cfg10[core] = READ_RADIO_REG_20691(pi, ADC_CFG10, core);
		porig->auxpga_ovr1[core] = READ_RADIO_REG_20691(pi, AUXPGA_OVR1, core);
		porig->testbuf_ovr1[core] = READ_RADIO_REG_20691(pi, TESTBUF_OVR1, core);
		if (RADIO20691_MAJORREV(radio_rev) == 0)
			porig->spare_cfg6[core] = READ_RADIO_REG_20691(pi, SPARE_CFG6, core);
		porig->pa2g_cfg1[core] = READ_RADIO_REG_20691(pi, PA2G_CFG1, core);
	}
	/* # Enabling and Muxing per band */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_RADIO_REG_20691(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x8);
		if (RADIO20691_MAJORREV(radio_rev) == 0) /* 4345 TC0 */
			MOD_RADIO_REG_20691(pi, PA2G_CFG1, 0, pa2g_tssi_ctrl_sel, 1);
		else /* 4345 A0 */
			MOD_RADIO_REG_20691(pi, PA2G_CFG1, 0, pa2g_tssi_ctrl_sel, 0);
	} else {
		ACPHY_REG_LIST_START
		    MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x0a)
		    /* #tap from PA output */
		    MOD_RADIO_REG_20691_ENTRY(pi, TX5G_MISC_CFG1, 0, pa5g_tssi_ctrl_sel, 0)
		    MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0, ovr_pa5g_tssi_ctrl_sel, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_tssi_GPIO_ctrl, 0x0)

		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_OVR1, 0, ovr_iqcal_PU_iqcal, 1)
		/* # power up iqlocal */
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_PU_iqcal, 0x1)
		/* # power off tssi */
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_PU_tssi, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_OVR1, 0, ovr_iqcal_PU_tssi, 1)

		/* ### JV: May be there is a  direct control for this, could'nt find it */
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_pu, 0x1)
		/* # power up auxpga */
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, 0, auxpga_i_pu, 0x1)

		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_sel_input, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, 0, auxpga_i_sel_input, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
		MOD_RADIO_REG_20691(pi, ADC_CFG10, 0, adc_in_test, 0xF);
	}
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_OVR1, 0, ovr_testbuf_sel_test_port, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_CFG1, 0, testbuf_sel_test_port, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_OVR1, 0, ovr_testbuf_PU, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_CFG1, 0, testbuf_PU, 0x1)

		/* #pwr up adc and set auxpga gain */
		MOD_RADIO_REG_20691_ENTRY(pi, PMU_CFG4, 0, wlpmu_ADCldo_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_sel_gain, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, 0, auxpga_i_sel_gain, 0x3)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_sel_vmid, 1)
	ACPHY_REG_LIST_EXECUTE(pi);
	if (RADIO20691_MAJORREV(radio_rev) == 0) {
		/* 4345 TC0 */
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_VMID, 0), 0x9a);
	} else if (RADIO20691_MAJORREV(radio_rev) == 1) {
		/* 4345 A0 */
		MOD_RADIO_REG_20691(pi, AUXPGA_CFG1, 0, auxpga_i_sel_gain, 0x7);
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_VMID, 0), 0x7a);
	} else if (ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi) &&
		CHSPEC_IS5G(pi->radio_chanspec)) {
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_VMID, 0), 0x8c);
	} else {
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_VMID, 0), 0x9c);
	}

	ACPHY_REG_LIST_START
	    /* #ensure that the dac mux is OFF because it shares a line with the auxpga output */
	    MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG9, 0, txbb_dac2adc, 0x0)
	    /* #these two lines disable the TIA gpaio mux and enable the */
	    MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG5, 0, tia_out_test, 0x0)
	    MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_in_test, 0x3)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_txcal_radio_cleanup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* CLEANUP: restore reg values */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		write_radio_reg(pi, RF_2069_IQCAL_CFG1(core), porig->iqcal_cfg1[core]);
		write_radio_reg(pi, RF_2069_IQCAL_CFG2(core), porig->iqcal_cfg2[core]);
		write_radio_reg(pi, RF_2069_IQCAL_CFG3(core), porig->iqcal_cfg3[core]);
		write_radio_reg(pi, RF_2069_PA2G_TSSI(core),  porig->pa2g_tssi[core]);
		write_radio_reg(pi, RF_2069_TX5G_TSSI(core),  porig->tx5g_tssi[core]);
		write_radio_reg(pi, RF_2069_AUXPGA_CFG1(core),  porig->auxpga_cfg1[core]);
		write_radio_reg(pi, RF_2069_GE16_OVR14(core), porig->OVR14[core]);
		write_radio_reg(pi, RF_2069_PA5G_CFG1(core),  porig->pa5g_cfg1[core]);

		/* Reg conflict with 2069 rev 16 */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0)
			write_radio_reg(pi, RF_2069_OVR20(core),      porig->OVR20[core]);
		else
			write_radio_reg(pi, RF_2069_GE16_OVR21(core),      porig->OVR21[core]);
	} /* for core */
}

static void
wlc_phy_txcal_radio_cleanup_acphy_20691(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);
	uint8 core;
#ifndef BCMRADIOREV
	uint8 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* CLEANUP: restore reg values */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		write_radio_reg(pi, RADIO_REG_20691(pi, IQCAL_CFG1, core), porig->iqcal_cfg1[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, IQCAL_OVR1, core), porig->iqcal_ovr1[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_CFG1, core),
		                porig->auxpga_cfg1[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, IQCAL_CFG3, core), porig->iqcal_cfg3[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, TX_TOP_5G_OVR1, core),
		                porig->tx_top_5g_ovr1[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, ADC_CFG10, core), porig->adc_cfg10[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_OVR1, core),
		                porig->auxpga_ovr1[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, TESTBUF_OVR1, core),
		                porig->testbuf_ovr1[core]);
		if (RADIO20691_MAJORREV(radio_rev) == core)
			write_radio_reg(pi, RADIO_REG_20691(pi, SPARE_CFG6, core),
			                porig->spare_cfg6[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, PA2G_CFG1, core), porig->pa2g_cfg1[core]);
	} /* for core */
}

static void
wlc_phy_txcal_phy_setup_acphy_core_disable_rf(phy_info_t *pi, uint8 core)
{
	if (TINY_RADIO(pi)) {
		if ((CHSPEC_IS2G(pi->radio_chanspec) &&
			(READ_RADIO_REGFLD_20691(pi, PA2G_CFG1, core, pa2g_tssi_ctrl_sel) == 0)) ||
			(CHSPEC_IS5G(pi->radio_chanspec) &&
			(READ_RADIO_REGFLD_20691(pi, TX5G_MISC_CFG1, core,
			pa5g_tssi_ctrl_sel) == 0))) {
			MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, pa_pwrup,       1);
		}
	} else {
		MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, pa_pwrup,       0);
	}

	MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, pa_pwrup,               1);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna1_pwrup,        1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rxrf_lna1_pwrup,        0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna1_5G_pwrup,     1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rxrf_lna1_5G_pwrup,     0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_pwrup,        1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rxrf_lna2_pwrup,        0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_nrssi_pwrup,        1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, lpf_nrssi_pwrup,        0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1g_pu,           1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rssi_wb1g_pu,           0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1a_pu,           1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rssi_wb1a_pu,           0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_wrssi3_pwrup,       1);
	MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, lpf_wrssi3_pwrup,       0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_wrssi2_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, rxrf_lna2_wrssi2_pwrup, 0);
}

static void
wlc_phy_txcal_phy_setup_acphy_core_loopback_path(phy_info_t *pi, uint8 core, uint8 lpf_config)
{
	MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, lpf_bq1_pu,             1);
	MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, lpf_bq1_pu,             1);
	MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, lpf_bq2_pu,             1);
	MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, lpf_bq2_pu,             1);
	MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, lpf_pu,                 1);
	MOD_PHYREGCE(pi, RfctrlCoreTxPus,     core, lpf_pu,                 1);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_pu_dc,              1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus,     core, lpf_pu_dc,              1);
	MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_pu,             1);
	MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_pu,             1);

	WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,     0x3ff);
	if (lpf_config == LPFCONF_TXIQ_RX2) {
	  WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core,         0x152);
	} else {
	  WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core,         0x22a);
	}

	/* Using strong TSSI coupling improves TXIQ cal result */
	if (CHSPEC_IS5G(pi->radio_chanspec) &&
		(RADIOID(pi->pubpi.radioid) == BCM2069_ID) &&
		(RADIOREV(pi->pubpi.radiorev) == 0x2C ||
		RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
		(PHY_XTAL_IS40M(pi))) {
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_range, 0);
	}
}

static void
wlc_phy_txcal_phy_setup_acphy_core_sd_adc(phy_info_t *pi, uint8 core, uint16 sdadc_config)
{
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, sdadc_config & 0x7);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_iqadc_pwrup, (sdadc_config >> 3) & 0x3f);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd, (sdadc_config >> 9) & 0x1);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_flashhspd, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl, (sdadc_config >> 10) & 0x1);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_ctrl_flash17lvl, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_adc_bias, (sdadc_config >> 11) & 0x3);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_adc_bias,  1);
}

static void
wlc_phy_txcal_phy_setup_acphy_core_lpf(phy_info_t *pi, uint8 core, uint16 bw_idx)
{
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_bq1_bw,    1);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_bq2_bw,    1);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_rc_bw,     1);

	MOD_PHYREGCE(pi, RfctrlCoreLpfCT,        core, lpf_bq1_bw,    3+bw_idx);

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
		(ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi))) {
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT,     core, lpf_bq2_bw,  6);
			MOD_PHYREGCE(pi, RfctrlCoreRCDACBuf,  core, lpf_rc_bw,   6);
		} else {
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT,     core, lpf_bq2_bw,  5);
			MOD_PHYREGCE(pi, RfctrlCoreRCDACBuf,  core, lpf_rc_bw,   5);
		}
	} else if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		MOD_PHYREGCE(pi, RfctrlCoreLpfCT,     core, lpf_bq2_bw,  3+bw_idx);
		MOD_PHYREGCE(pi, RfctrlCoreRCDACBuf,  core, lpf_rc_bw,   3+bw_idx);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		/* Ideally, tssi_range should not impact IQcal at all.
		 * However, we found IQ cal performance improved with tssi_range = 0
		 */
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, tssi_range, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,    core, tssi_range, 0);
	} else if (TINY_RADIO(pi) && PHY_IPA(pi) && CHSPEC_IS5G(pi->radio_chanspec)) {
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, tssi_range, 0);
	}

	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_q_biq2,    1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfCT,        core, lpf_q_biq2,    0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_dc_bypass, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfCT,        core, lpf_dc_bypass, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT,    core, lpf_dc_bw,     1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfCT,        core, lpf_dc_bw,     4);  /* 133KHz */

	if (!(ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, amux_sel_port, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, amux_sel_port, 2);
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, afe_iqadc_aux_en, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, afe_iqadc_aux_en, 1);
	}
}

static void
wlc_phy_txcal_phy_setup_acphy_core(phy_info_t *pi, acphy_txcal_phyregs_t *porig, uint8 core,
	uint16 bw_idx, uint16 sdadc_config, uint8 Biq2byp)
{
	/* Power Down External PA (simply always do 2G & 5G),
	 * and set T/R to T (double check TR position)
	 */
	porig->RfctrlIntc[core] = READ_PHYREGCE(pi, RfctrlIntc, core);
	WRITE_PHYREGCE(pi, RfctrlIntc, core, 0);
	if ((CHSPEC_IS5G(pi->radio_chanspec) && (pi->u.pi_acphy->srom.epa_on_during_txiqlocal)) ||
		(pi->sh->boardtype == BCM94360MCM5)) {
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_5g_papu, 1);
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_2g_papu, 0);
	} else {
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_2g_papu, 0);
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_5g_papu, 0);
	}
	MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 0);
	MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
	MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_pa, 1);
	MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
	/* 20691 iTR trsw */
	if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_pu, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_bias_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* Core Activate/Deactivate */
	/* MOD_PHYREG(pi, RfseqCoreActv2059, DisRx, 0);
	   MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, (1 << core));
	 */

	/* Internal RFCtrl: save and adjust state of internal PA override */
	/* save state of Rfctrl override */
	porig->RfctrlOverrideAfeCfg[core]   = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
	porig->RfctrlCoreAfeCfg1[core]      = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
	porig->RfctrlCoreAfeCfg2[core]      = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
	porig->RfctrlOverrideRxPus[core]    = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
	porig->RfctrlCoreRxPus[core]        = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
	porig->RfctrlOverrideTxPus[core]    = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
	porig->RfctrlCoreTxPus[core]        = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
	porig->RfctrlOverrideLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core);
	porig->RfctrlCoreLpfSwtch[core]     = READ_PHYREGCE(pi, RfctrlCoreLpfSwtch, core);
	porig->RfctrlOverrideLpfCT[core]    = READ_PHYREGCE(pi, RfctrlOverrideLpfCT, core);
	porig->RfctrlCoreLpfCT[core]        = READ_PHYREGCE(pi, RfctrlCoreLpfCT, core);
	porig->RfctrlCoreLpfGmult[core]     = READ_PHYREGCE(pi, RfctrlCoreLpfGmult, core);
	porig->RfctrlCoreRCDACBuf[core]     = READ_PHYREGCE(pi, RfctrlCoreRCDACBuf, core);
	porig->RfctrlOverrideAuxTssi[core]  = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
	porig->RfctrlCoreAuxTssi1[core]     = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);

	/* Turning off all the RF component that are not needed */
	wlc_phy_txcal_phy_setup_acphy_core_disable_rf(pi, core);

	/* Setting the loopback path */
	if (Biq2byp == 0) {
	  wlc_phy_txcal_phy_setup_acphy_core_loopback_path(pi, core, LPFCONF_TXIQ_RX2);
	} else {
	  /* select biq2 byp path */
	  wlc_phy_txcal_phy_setup_acphy_core_loopback_path(pi, core, LPFCONF_TXIQ_RX4);
	}

	/* Setting the SD-ADC related stuff */
	wlc_phy_txcal_phy_setup_acphy_core_sd_adc(pi, core, sdadc_config);

	/* Setting the LPF related stuff */
	wlc_phy_txcal_phy_setup_acphy_core_lpf(pi, core, bw_idx);

	/* disable PAPD (if enabled)
	 * FIXME: not supported (and not needed) yet
	 * porig->PapdEnable[core] = READ_PHYREGCE(pi, PapdEnable, core);
	 * MOD_PHYREGCE(pi, PapdEnable, core, compEnable, 0);
	 */
}

static void
wlc_phy_txcal_phy_setup_acphy(phy_info_t *pi, uint8 Biq2byp)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_phyregs_t *porig = &(pi_ac->ac_txcal_phyregs_orig);
	uint16 sdadc_config;
	uint8  core, bw_idx;

	porig->RxFeCtrl1 = READ_PHYREG(pi, RxFeCtrl1);
	porig->AfePuCtrl = READ_PHYREG(pi, AfePuCtrl);

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		bw_idx = 2;
		sdadc_config = sdadc_cfg80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		bw_idx = 1;
		if (pi->sdadc_config_override)
			sdadc_config = sdadc_cfg40hs;
		else
			sdadc_config = sdadc_cfg40;
	} else {
		bw_idx = 0;
		sdadc_config = sdadc_cfg20;
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 4)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	if (TINY_RADIO(pi)) {
		ACPHY_REG_LIST_START
			/* #set sd adc full scale */
			MOD_PHYREG_ENTRY(pi, RxSdFeConfig1, farrow_rshift_force, 1)
			MOD_PHYREG_ENTRY(pi, RxSdFeConfig6, rx_farrow_rshift_0, 2)
			MOD_PHYREG_ENTRY(pi, TSSIMode, tssiADCSel, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* turn off tssi sleep feature during cal */
	MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);

	/*  SETUP: save off orig reg values and configure for cal  */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_txcal_phy_setup_acphy_core(pi, porig, core, bw_idx, sdadc_config, Biq2byp);
	} /* for core */
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, swap_iq0, 1)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, swap_iq1, 1)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, swap_iq2, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* ADC pulse clamp en fix */
	wlc_phy_pulse_adc_reset_acphy(pi);

	/* we should not need spur avoidance anymore
	porig->BBConfig = READ_PHYREG(pi, BBConfig);
	MOD_PHYREG(pi, BBConfig, resample_clk160, 0);
	*/
}

static void
wlc_phy_txcal_phy_cleanup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_phyregs_t *porig = &(pi_ac->ac_txcal_phyregs_orig);
	uint8 core;

	if (TINY_RADIO(pi)) {
		MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 0);
		MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 0);
	}

	/*  CLEANUP: Restore Original Values  */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* restore ExtPA PU & TR */
		WRITE_PHYREGCE(pi, RfctrlIntc, core, porig->RfctrlIntc[core]);
		/* 20691 iTR trsw */
		if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
		}

		/* restore Rfctrloverride setting */
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, porig->RfctrlOverrideRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, porig->RfctrlCoreRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, porig->RfctrlOverrideTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, porig->RfctrlCoreTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,
			porig->RfctrlOverrideLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, porig->RfctrlCoreLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfCT, core, porig->RfctrlOverrideLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfCT, core, porig->RfctrlCoreLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGmult, core, porig->RfctrlCoreLpfGmult[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRCDACBuf, core, porig->RfctrlCoreRCDACBuf[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, porig->RfctrlOverrideAuxTssi[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, porig->RfctrlCoreAuxTssi1[core]);

		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, porig->RfctrlOverrideAfeCfg[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, porig->RfctrlCoreAfeCfg1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, porig->RfctrlCoreAfeCfg2[core]);

		/* restore PAPD Enable
		 * FIXME: not supported (and not needed) yet
		 * phy_reg_write(pi, NPHY_PapdEnable(core), porig->PapdEnable[core]);
		 */

	} /* for core */

	WRITE_PHYREG(pi, RxFeCtrl1, porig->RxFeCtrl1);
	WRITE_PHYREG(pi, AfePuCtrl, porig->AfePuCtrl);

	/* WRITE_PHYREG(pi, RfseqCoreActv2059, porig->RfseqCoreActv2059); */

	/* we should not need spur avoidance anymore
	WRITE_PHYREG(pi, BBConfig, porig->BBConfig);
	*/

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 0)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
	wlc_phy_resetcca_acphy(pi);
}

void
wlc_phy_deaf_acphy(phy_info_t *pi, bool mode)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	if (mode) {
	  if (pi_ac->deaf_count == 0)
			wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
		else
			PHY_ERROR(("%s: Deafness already set\n", __FUNCTION__));
	}
	else {
		if (pi_ac->deaf_count > 0)
			wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		else
			PHY_ERROR(("%s: Deafness already cleared\n", __FUNCTION__));
	}
	wlapi_enable_mac(pi->sh->physhim);
}

bool
wlc_phy_get_deaf_acphy(phy_info_t *pi)
{
	uint8 core;
	uint16 curr_classifctl, val;
	bool isDeaf = TRUE;
	/* Get current classifier and clip_detect settings */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	curr_classifctl = READ_PHYREG(pi, ClassifierCtrl) & ACPHY_ClassifierCtrl_classifierSel_MASK;
	/* XXX
	 * For deafness to be set, ofdm and cck classifiers must be disabled,
	 * AND adc_clip thresholds must be set to max (0xffff)
	 */
	if (curr_classifctl != 4) {
		isDeaf = FALSE;
	} else {
		if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			FOREACH_CORE(pi, core) {
				val = READ_PHYREGC(pi, Clip1Threshold, core);
				if (val != 0xffff) {
					isDeaf = FALSE;
					break;
				}
			}
		}
		else {
			FOREACH_CORE(pi, core) {
				val = READ_PHYREGFLDC(pi, computeGainInfo, core,
				                      disableClip1detect);
				if (val != 1) {
					isDeaf = FALSE;
					break;
				}
			}
	        }
	}

	wlapi_enable_mac(pi->sh->physhim);
	return isDeaf;
}

void
wlc_phy_stay_in_carriersearch_acphy(phy_info_t *pi, bool enable)
{
	uint8 class_mask;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* MAC should be suspended before calling this function */
	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);

	if (enable) {
		if (pi_ac->deaf_count == 0) {
			wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK, 4);
			wlc_phy_ofdm_crs_acphy(pi, FALSE);
			wlc_phy_clip_det_acphy(pi, FALSE);
			WRITE_PHYREG(pi, ed_crsEn, 0);
			wlc_phy_resetcca_acphy(pi);
		}

		pi_ac->deaf_count++;
	} else {
	  ASSERT(pi_ac->deaf_count > 0);

		pi_ac->deaf_count--;
		if (pi_ac->deaf_count == 0) {
			class_mask = CHSPEC_IS2G(pi->radio_chanspec) ? 7 : 6;   /* No bphy in 5g */
			wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK,
			                         class_mask);
			wlc_phy_ofdm_crs_acphy(pi, TRUE);
			wlc_phy_clip_det_acphy(pi, TRUE);
			WRITE_PHYREG(pi, ed_crsEn, pi_ac->edcrs_en);
		}
	}
}

void
wlc_phy_ofdm_crs_acphy(phy_info_t *pi, bool enable)
{
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* MAC should be suspended before calling this function */
	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) == 0);

	if (enable) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, crsControlu, totEnable, 1)
			MOD_PHYREG_ENTRY(pi, crsControll, totEnable, 1)
			MOD_PHYREG_ENTRY(pi, crsControluSub1, totEnable, 1)
			MOD_PHYREG_ENTRY(pi, crsControllSub1, totEnable, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, crsControlu, totEnable, 0)
			MOD_PHYREG_ENTRY(pi, crsControll, totEnable, 0)
			MOD_PHYREG_ENTRY(pi, crsControluSub1, totEnable, 0)
			MOD_PHYREG_ENTRY(pi, crsControllSub1, totEnable, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
}

void
wlc_phy_populate_tx_loft_comp_tbl_acphy(phy_info_t *pi, uint16 *loft_coeffs)
{
	/* There are 2 implementations: */
	/* 1) 4360Bx fix, with two subbands and two power steps per core. */
	/* 2) 43602 fix, with four subbands and three power steps per core. Tuned for 43602MCH5. */
	/* Controlled by boardflag "precal_tx_idx". This turns on IDX change during cal. */
	uint8  core, tbl_idx;
	uint8  nwords;
	uint8  txidx_thresh[2][3] = {{128, 128, 32}, {128, 26, 28}};
	uint8  txidx_thresh2[4][2][3] = {{{128, 17, 12}, {128, 27, 22}}, /* Ch36 */
	                                 {{128, 17, 12}, {128, 27, 22}}, /* Low band */
	                                 {{128, 19, 16}, {128, 29, 26}}, /* Mid Band */
	                                 {{128, 22, 21}, {128, 32, 31}}}; /* High Band */
	/* core, band, pwridx (low then hi) */
	uint8  di_bias_tbl[3][2][2] = {{{0x00, 0x00}, {0x00, 0x00}},
	                               {{0x00, 0x00}, {0xec, 0xf6}},
	                               {{0xf6, 0xf8}, {0xf6, 0xfa}}};
	uint8  dq_bias_tbl[3][2][2] = {{{0x00, 0x00}, {0x00, 0x00}},
	                               {{0x00, 0x00}, {0x00, 0xfb}},
	                               {{0xf2, 0xfc}, {0xf6, 0xfb}}};
	/* Core (0 1 2), Band (Ch36, low, mid, high), Power IDX (low, mid, high) */
	uint8  di_bias_tbl2[3][4][3] = {{{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
	                                {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}},
	                                {{0xfc, 0xfc, 0xfc}, {0xfa, 0x00, 0x06},
	                                {0xfa, 0x00, 0x04}, {0xf8, 0xff, 0x04}},
	                                {{0xfd, 0xfd, 0xfd}, {0xfe, 0xfd, 0xf9},
	                                {0xfa, 0xfd, 0xfb}, {0xf8, 0xfe, 0x02}}};
	uint8  dq_bias_tbl2[3][4][3] = {{{0x00, 0x00, 0x00}, {0x00, 0x00, 0x00},
	                                {0x00, 0x00, 0x00}, {0x00, 0x00, 0x00}},
	                                {{0x03, 0x03, 0x03}, {0x05, 0x01, 0x01},
	                                {0x05, 0x00, 0xfc}, {0x04, 0x01, 0xfa}},
	                                {{0xfd, 0xfd, 0xfd}, {0xfa, 0x02, 0x08},
	                                {0xf9, 0x00, 0x08}, {0xf9, 0xff, 0x05}}};
	uint8  i_bias, q_bias, lowrange, highrange, pwr_idx, pwr_idx_alt, delta1, delta2;
	uint8  tmp1, tmp2, idxp, idxs, i_bias_pri, i_bias_sec, q_bias_pri, q_bias_sec;
	uint8  band_idx[3] = {0, 0, 0};
	uint8  ch_num_thresh[3] = {200, 149, 100};
	/* dividing in 4 bands for each core */
	uint8  ch_num_thresh_alt[3][3] = {{52, 52, 52}, {200, 100, 100}, {200, 149, 149}};
	int16  delta, i_bias_delta, q_bias_delta;
	uint16 coeffs, di, dq, di_adj, dq_adj, channel;
	const uint8 lo = 0;
	const uint8 hi = 1;
	int8 i;

	/* no radio loft comp for tiny radio */
	if (TINY_RADIO(pi))
		return;

	nwords = 1;
	channel = CHSPEC_CHANNEL(pi->radio_chanspec);
	FOREACH_CORE(pi, core) {
		if (!(pi->u.pi_acphy->srom.precal_tx_idx)) {
			band_idx[core] = channel >= ch_num_thresh[core];
		} else {
			for (i = 0; i < ARRAYSIZE(ch_num_thresh_alt); i++) {
				if (channel >= ch_num_thresh_alt[i][core]) {
					band_idx[core]++;
				} else {
					break;
				}
			}
		}
	}

	for (tbl_idx = 0; tbl_idx < 128; tbl_idx ++) {
		FOREACH_CORE(pi, core) {

			switch (core) {
			case 0:
				coeffs = loft_coeffs[core];
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LOFTCOEFFLUTS0, nwords,
				    tbl_idx, 16, &coeffs);
				break;
			case 1:
			case 2:
				if (CHSPEC_IS2G(pi->radio_chanspec) == 1) {
					coeffs = loft_coeffs[core];
				} else {
					if (pi->u.pi_acphy->srom.precal_tx_idx) {
						/* Interpolation: */
						/* bias = bias_pri + dY/dX * delta, where: */
						/* dY = delta between closest table elements */
						/* dX = 10 (#IDX ticks between 2 table elements) */
						/* bias_pri = table element to start from */
						/* delta = idx delta from bias_pri to target idx */
						tmp1 = tbl_idx <=
							txidx_thresh2[band_idx[core]][lo][core];
						tmp2 = tbl_idx <=
							txidx_thresh2[band_idx[core]][hi][core];
						pwr_idx_alt = (tmp1) ? 2 : ((tmp2) ? 1 : 0);
						delta1 = tbl_idx -
							txidx_thresh2[band_idx[core]][lo][core];
						delta2 = tbl_idx -
							txidx_thresh2[band_idx[core]][hi][core];
						if ((delta1 <= 5) || (delta1 > 251)) {
							lowrange = 1;
							highrange = 0;
						} else if ((delta2 <= 5) || (delta2 > 251)) {
							highrange = 1;
							lowrange = 0;
						} else {
							highrange = 0;
							lowrange = 0;
						}
						if (lowrange) {
							idxp = 2;
							idxs = 1;
							delta = (int16) (delta1 + 5);
						} else if (highrange) {
							idxp = 1;
							idxs = 0;
							delta = (int16) (delta2 + 5);
						} else {
							/* Outside table range, bias = constant */
							idxp = pwr_idx_alt;
							idxs = pwr_idx_alt;
							delta = 0;
						}
						/* starting interpolation from -primary- element */
						i_bias_pri =
						    di_bias_tbl2[core][band_idx[core]][idxp];
						q_bias_pri =
						    dq_bias_tbl2[core][band_idx[core]][idxp];
						/* towards this -secondary- element */
						i_bias_sec =
						    di_bias_tbl2[core][band_idx[core]][idxs];
						q_bias_sec =
						    dq_bias_tbl2[core][band_idx[core]][idxs];
						/* Computing dY */
						i_bias_delta = (uint8) (i_bias_sec - i_bias_pri);
						q_bias_delta = (uint8) (q_bias_sec - q_bias_pri);
						/* converting to int */
						i_bias_delta = (i_bias_delta > 127) ? i_bias_delta -
						    256 : i_bias_delta;
						q_bias_delta = (q_bias_delta > 127) ? q_bias_delta -
						    256 : q_bias_delta;
						/* Delta is distance from primary */
						delta = (delta > 127)? delta - 256:delta;
						/* Interpolation: integer divison is good enough */
						i_bias_delta = (i_bias_delta * delta) / 10;
						q_bias_delta = (q_bias_delta * delta) / 10;
						i_bias = (uint8) (i_bias_pri + i_bias_delta);
						q_bias = (uint8) (q_bias_pri + q_bias_delta);
					} else {
						pwr_idx = tbl_idx <=
						    txidx_thresh[band_idx[core]][core];
						i_bias = di_bias_tbl[core][band_idx[core]][pwr_idx];
						q_bias = dq_bias_tbl[core][band_idx[core]][pwr_idx];
					}

					dq = loft_coeffs[core] & 0xff;
					di = (loft_coeffs[core] >> 8) & 0xff;
					di_adj = (di + i_bias) & 0xff;
					dq_adj = (dq + q_bias) & 0xff;

					/* for overflow protection */
					if ((di_adj & 0x80) && (i_bias & 0x80) &&
					            ((di_adj & 0x80) == 0)) {
						di_adj = 0x80;
					} else if (((di_adj & 0x80) == 0) &&
					            ((i_bias & 0x80) == 0) && (di_adj & 0x80)) {
						di_adj = 0x7f;
					}

					if ((dq_adj & 0x80) && (q_bias & 0x80) &&
					            ((dq_adj & 0x80) == 0)) {
						dq_adj = 0x80;
					} else if (((dq_adj & 0x80) == 0) &&
					            ((q_bias & 0x80) == 0) && (dq_adj & 0x80)) {
						dq_adj = 0x7f;
					}
					/* dq: 8LSB & di: 8MSB */
					coeffs = dq_adj + (di_adj << 8);
				}

				if (core == 1) {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LOFTCOEFFLUTS1,
					      nwords, tbl_idx, 16, &coeffs);
				} else {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LOFTCOEFFLUTS2,
					      nwords, tbl_idx, 16, &coeffs);
				}
				break;
			}
		}
	}
}

static int
wlc_phy_cal_txiqlo_acphy(phy_info_t *pi, uint8 searchmode, uint8 mphase, uint8 Biq2byp)
{
	uint8  bw_idx, rd_select = 0, wr_select1 = 0, wr_select2 = 0;
	uint16 tone_ampl;
	uint16 tone_freq;
	int    bcmerror = BCME_OK;
	uint8  num_cmds_total, num_cmds_per_core;
	uint8  cmd_idx, cmd_stop_idx, core, cal_type;
	uint16 *cmds;
	uint16 cmd;
	uint16 coeffs[2];
	uint16 *coeff_ptr;
	uint16 zero = 0;
	uint8  cr, k, num_cores, thidx;
	uint16 classifier_state;
	txgain_setting_t orig_txgain[4];
	acphy_cal_result_t *accal = &pi->cal_info->u.accal;
	uint8 last_phase; /* To update cal tables in the final phase of mphase cal */

	/* structure for saving txpu_ovrd, txpu_val
	 * 2 register values for each core
	 */
	struct _save_regs {
		uint16 reg_val;
		uint16 reg_addr;
	} savereg[PHY_CORE_MAX*2];

	uint core_count = 0;
	uint core_off = 0;

	/* -----------
	 *  Constants
	 * -----------
	 */

	/* Table of commands for RESTART & REFINE search-modes
	 *
	 *     This uses the following format (three hex nibbles left to right)
	 *      1. cal_type: 0 = IQ (a/b),   1 = deprecated
	 *                   2 = LOFT digital (di/dq)
	 *                   3 = LOFT analog, fine,   injected at mixer      (ei/eq)
	 *                   4 = LOFT analog, coarse, injected at mixer, too (fi/fq)
	 *      2. initial stepsize (in log2)
	 *      3. number of cal precision "levels"
	 *
	 *     Notes: - functions assumes that order of LOFT cal cmds will be f => e => d,
	 *              where it's ok to have multiple cmds (say interrupted by IQ) of
	 *              the same type; this is due to zeroing out of e and/or d that happens
	 *              even during REFINE cal to avoid a coefficient "divergence" (increasing
	 *              LOFT comp over time of different types that cancel each other)
	 *            - final cal cmd should NOT be analog LOFT cal (otherwise have to manually
	 *              pick up analog LOFT settings from best_coeffs and write to radio)
	 */
	uint16 cmds_RESTART[] = { 0x434, 0x334, 0x084, 0x267, 0x056, 0x234};
	uint16 cmds_REFINE[] = { 0x423, 0x334, 0x073, 0x267, 0x045, 0x234};

	/* if the LOFT digi coeff is negative , DAC output stays at random value for */
	/* one clock cycle after pkt ends (after tx reset) */

	/* so WAR for this is after IQ cal is finished, force digi coeff to 8,8 and then do */
	/* analog fine cal and then do digi cal with grid size of 8 , which will make sure */
	/* digi coeff is always non negative */

	uint16 cmds_RESTART_majrev1[] = { 0x434, 0x334, 0x084, 0x267, 0x056, 0x334, 0x234};
	uint16 cmds_REFINE_majrev1[] = { 0x423, 0x334, 0x073, 0x267, 0x045, 0x334, 0x234};

	/* txidx dependent digital loft comp table */
	uint16 cmds_RESTART_TDDLC[] = { 0x434, 0x334, 0x084, 0x267, 0x056, 0x234};
	uint16 cmds_REFINE_TDDLC[] = { 0x423, 0x334, 0x073, 0x267, 0x045, 0x234};

	/* Pre RX IQ cal coeffs */
	uint16 cmds_RESTART_PRERX[] = { 0x084, 0x056};
	uint16 cmds_REFINE_PRERX[] = { 0x073, 0x045};
	/* zeros start coeffs (a,b,di/dq,ei/eq,fi/fq for each core) */
	uint16 start_coeffs_RESTART[] = {0, 0, 0, 0, 0,  0, 0, 0, 0, 0,  0, 0, 0, 0, 0};

	/* interval lengths for gain control and correlation segments
	 *   (top/bottom nibbles are for guard and measurement intlvs, resp., in log 2 # samples)
	 */
	uint8 nsamp_gctrl[3];
	uint8 nsamp_corrs[3];
	uint8 thres_ladder[7];

	uint16 loft_coeffs[] = {0, 0, 0};
	uint16 *loft_coeffs_ptr = loft_coeffs;
	uint16 idx_for_loft_comp_tbl = 5;

	uint16 papdState[PHY_CORE_MAX];
	/* Local copy of phyrxchains before overwrite */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx bits from RfseqCoreActv.EnTx */
	uint8 save_EnTx = 0;
	/* Flag to remember */
	uint8 force_turnon = 0;

	/* ------- Inits ------ */
	bzero(papdState, sizeof(papdState));
	/* Force turn-on cores if necessary */
	if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	}
	/* Disable PAPD */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		papdState[core] = READ_PHYREGCE(pi, PapdEnable, core);
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);
	}

	num_cores = PHYCORENUM(pi->pubpi.phy_corenum);
	/* X52c should run cal only on the 2 active core
	 * Cal on 3rd core corrupts the LO/IQ ladder in
	 * IQLOCAL TBL
	 */
	if (IS_X52C_BOARDTYPE(pi)) {
	  num_cores = 2;
	}

	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	/* phy_bw */
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		bw_idx = 2;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		bw_idx = 1;
	} else {
		bw_idx = 0;
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	    RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1 &&
	    !(ACRADIO_2069_EPA_IS(pi->pubpi.radiorev))) {
		if (CHSPEC_IS2G(pi->radio_chanspec) == 1) {
			nsamp_gctrl[0] = 0x87; nsamp_gctrl[1] = 0x77; nsamp_gctrl[2] = 0x77;
			nsamp_corrs[0] = 0x79; nsamp_corrs[1] = 0x79; nsamp_corrs[2] = 0x79;
		} else {
			nsamp_gctrl[0] = 0x78; nsamp_gctrl[1] = 0x88; nsamp_gctrl[2] = 0x98;
			nsamp_corrs[0] = 0x89; nsamp_corrs[1] = 0x79; nsamp_corrs[2] = 0x79;
		}

		cmds_REFINE_majrev1[0] =  0x434; cmds_REFINE_majrev1[1] = 0x334;
		cmds_REFINE_majrev1[2] = 0x084;
		cmds_REFINE_majrev1[3] =  0x267; cmds_REFINE_majrev1[4] = 0x056;
		cmds_REFINE_majrev1[5] = 0x334;
		cmds_REFINE_majrev1[6] = 0x234;

		thres_ladder[0] = 0x3d; thres_ladder[1] = 0x2d; thres_ladder[2] = 0x1d;
		thres_ladder[3] = 0x0d; thres_ladder[4] = 0x07; thres_ladder[5] = 0x03;
		thres_ladder[6] = 0x01;
	} else {
		nsamp_gctrl[0] = 0x76; nsamp_gctrl[1] = 0x87; nsamp_gctrl[2] = 0x98;
		nsamp_corrs[0] = 0x79; nsamp_corrs[1] = 0x79; nsamp_corrs[2] = 0x79;

		if (TINY_RADIO(pi)) {
			thres_ladder[0] = 0x3d; thres_ladder[1] = 0x2d; thres_ladder[2] = 0x1d;
			thres_ladder[3] = 0x0d; thres_ladder[4] = 0x07;
			thres_ladder[5] = 0x03; thres_ladder[6] = 0x01;

			if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
				cmds_RESTART[0] = 0x265; cmds_RESTART[1] = 0x084;
				cmds_RESTART[2] = 0x234; cmds_RESTART[3] = 0x056;
				cmds_RESTART[4] = 0x223;

				cmds_REFINE[0] = 0x265; cmds_REFINE[1] = 0x084;
				cmds_REFINE[2] = 0x234; cmds_REFINE[3] = 0x056;
				cmds_REFINE[4] = 0x223;
			} else {
				cmds_RESTART[0] = 0x265; cmds_RESTART[1] = 0x234;
				cmds_RESTART[2] = 0x084; cmds_RESTART[3] = 0x074;
				cmds_RESTART[4] = 0x056;

				cmds_REFINE[0] = 0x265; cmds_REFINE[1] = 0x234;
				cmds_REFINE[2] = 0x084; cmds_REFINE[3] = 0x074;
				cmds_REFINE[4] = 0x056;
			}
		} else {
			thres_ladder[0] = 0x3d; thres_ladder[1] = 0x1e; thres_ladder[2] = 0xf;
			thres_ladder[3] = 0x07; thres_ladder[4] = 0x03;
			thres_ladder[5] = 0x01;

			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				cmds_REFINE_majrev1[0] =  0x423; cmds_REFINE_majrev1[1] = 0x334;
				cmds_REFINE_majrev1[2] = 0x073;
				cmds_REFINE_majrev1[3] =  0x267; cmds_REFINE_majrev1[4] = 0x045;
				cmds_REFINE_majrev1[5] = 0x334;
				cmds_REFINE_majrev1[6] = 0x234;
			} else {
				cmds_REFINE[0] =  0x423; cmds_REFINE[1] = 0x334;
				cmds_REFINE[2] = 0x073;
				cmds_REFINE[3] =  0x267; cmds_REFINE[4] = 0x045;
				cmds_REFINE[5] = 0x234;
			}
		}
	}

	/* Put the radio and phy into TX iqlo cal state, including tx gains */
	classifier_state = READ_PHYREG(pi, ClassifierCtrl);
	wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK, 4);

	if (TINY_RADIO(pi))
		wlc_phy_txcal_radio_setup_acphy_20691(pi);
	else
		wlc_phy_txcal_radio_setup_acphy(pi);

	wlc_phy_txcal_phy_setup_acphy(pi, Biq2byp);
	wlc_phy_txcal_txgain_setup_acphy(pi, &accal->txcal_txgain[0], &orig_txgain[0]);

	/* 4350A0 FIXME: Add Jira
	 * Need to force gated clks on to allow iqcal_done to be cleared
	 * only needed for 80 MHz but enable for 20 and 40 MHz anyway
	 */
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);

	if (TINY_RADIO(pi)) {
		ACPHY_REG_LIST_START
			/* # no radio LOFT or programmable radio gain for tiny */
			WRITE_PHYREG_ENTRY(pi, TX_iqcal_gain_bwAddress, 0)
			WRITE_PHYREG_ENTRY(pi, TX_loft_fine_iAddress, 0)
			WRITE_PHYREG_ENTRY(pi, TX_loft_fine_qAddress, 0)
			WRITE_PHYREG_ENTRY(pi, TX_loft_coarse_iAddress, 0)
			WRITE_PHYREG_ENTRY(pi, TX_loft_coarse_qAddress, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* Set IQLO Cal Engine Gain Control Parameters including engine Enable
	 * Format: iqlocal_en<15> / gain start_index / NOP / ladder_length_d2)
	 */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) && CHSPEC_IS80(pi->radio_chanspec)) {
		WRITE_PHYREG(pi, iqloCalCmdGctl, 0x8304);
	} else {
		WRITE_PHYREG(pi, iqloCalCmdGctl, 0x8a09);
	}

	/*
	 *   Retrieve and set Start Coeffs
	 */
	if (pi->cal_info->cal_phase_id > ACPHY_CAL_PHASE_TX0) {
		/* mphase cal and have done at least 1 Tx phase already */
		coeff_ptr = accal->txiqlocal_interm_coeffs; /* use results from previous phase */
	} else {
		/* single-phase cal or first phase of mphase cal */
		if (searchmode == PHY_CAL_SEARCHMODE_REFINE) {
			/* recal ("refine") */
			coeff_ptr = accal->txiqlocal_coeffs; /* use previous cal's final results */
		} else {
			/* start from zero coeffs ("restart") */
			coeff_ptr = start_coeffs_RESTART; /* zero coeffs */
		}
		/* copy start coeffs to intermediate coeffs, for pairwise update from here on
		 *    (after all cmds/phases have filled this with latest values, this
		 *    will be copied to OFDM/BPHY coeffs and to accal->txiqlocal_coeffs
		 *    for use by possible REFINE cal next time around)
		 */
		for (k = 0; k < 5*num_cores; k++) {
			accal->txiqlocal_interm_coeffs[k] = coeff_ptr[k];
		}
	}
	FOREACH_CORE(pi, core) {
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE, coeff_ptr + 5*core + 0,
		                                TB_START_COEFFS_AB, core);
		/* Restart or refine with Biq2byp option should not touch
		 * d,e,f coeffs
		 */

		if (Biq2byp == 0) {
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE, coeff_ptr + 5*core + 2,
		                                TB_START_COEFFS_D,  core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE, coeff_ptr + 5*core + 3,
		                                TB_START_COEFFS_E,  core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE, coeff_ptr + 5*core + 4,
		                                TB_START_COEFFS_F,  core);
		}
	}

	/*
	 *   Choose Cal Commands for this Phase
	 */
	if (searchmode == PHY_CAL_SEARCHMODE_RESTART) {
		if (Biq2byp) {
			cmds = cmds_RESTART_PRERX;
			num_cmds_per_core = ARRAYSIZE(cmds_RESTART_PRERX);
		} else if (ACREV_IS(pi->pubpi.phy_rev, 1) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			cmds = cmds_RESTART_TDDLC;
			num_cmds_per_core = ARRAYSIZE(cmds_RESTART_TDDLC);
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			cmds = cmds_RESTART_majrev1;
			num_cmds_per_core = ARRAYSIZE(cmds_RESTART_majrev1);
		} else {
			cmds = cmds_RESTART;
			num_cmds_per_core = ARRAYSIZE(cmds_RESTART);
		}
		num_cmds_total    = num_cores * num_cmds_per_core;
	} else {
		if (Biq2byp) {
			cmds = cmds_REFINE_PRERX;
			num_cmds_per_core = ARRAYSIZE(cmds_REFINE_PRERX);
		} else if (ACREV_IS(pi->pubpi.phy_rev, 1) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			cmds = cmds_REFINE_TDDLC;
			num_cmds_per_core = ARRAYSIZE(cmds_REFINE_TDDLC);
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			cmds = cmds_REFINE_majrev1;
			num_cmds_per_core = ARRAYSIZE(cmds_REFINE_majrev1);
		} else {
			cmds = cmds_REFINE;
			num_cmds_per_core = ARRAYSIZE(cmds_REFINE);
		}
		num_cmds_total    = num_cores * num_cmds_per_core;
	}

	if (mphase) {
		/* multi-phase: get next subset of commands (first & last index) */
	  if (Biq2byp) {
		cmd_idx = (pi->cal_info->cal_phase_id - ACPHY_CAL_PHASE_TXPRERXCAL0) *
			MPHASE_TXCAL_CMDS_PER_PHASE; /* first cmd index in this phase */
	  } else {
		cmd_idx = (pi->cal_info->cal_phase_id - ACPHY_CAL_PHASE_TX0) *
			MPHASE_TXCAL_CMDS_PER_PHASE; /* first cmd index in this phase */
	  }
		if ((cmd_idx + MPHASE_TXCAL_CMDS_PER_PHASE - 1) < num_cmds_total) {
			cmd_stop_idx = cmd_idx + MPHASE_TXCAL_CMDS_PER_PHASE - 1;
		} else {
			cmd_stop_idx = num_cmds_total - 1;
		}
	} else {
		/* single-phase: execute all commands for all cores */
		cmd_idx = 0;
		cmd_stop_idx = num_cmds_total - 1;
	}

	/* turn on test tone */
	tone_ampl = 250;
	/* fixme: wlc_phy_tx_tone_acphy is playing 2x frequency.
	 * once that's fixed, we should use 4/8/12 mHz for iqlocal
	 */
	tone_freq = CHSPEC_IS80(pi->radio_chanspec) ? ACPHY_IQCAL_TONEFREQ_80MHz :
		CHSPEC_IS40(pi->radio_chanspec) ? ACPHY_IQCAL_TONEFREQ_40MHz :
		ACPHY_IQCAL_TONEFREQ_20MHz;
	tone_freq = tone_freq >> 1;

	bcmerror = wlc_phy_tx_tone_acphy(pi, (int32)tone_freq, tone_ampl, 1, 0, FALSE);

	OSL_DELAY(5);

	if (TINY_RADIO(pi)) {
		/* #restore bbmult overwritten by tone */
		core = 0;
		wlc_phy_ipa_set_bbmult_acphy(pi,
			&(accal->txcal_txgain[core].bbmult), NULL, NULL, (1 << core));
	}

	FOREACH_CORE(pi, core) {
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2,    core, afe_iqadc_reset_ov_det, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_reset_ov_det, 1);
	}
	PHY_NONE(("wlc_phy_cal_txiqlo_acphy (after inits): SearchMd=%d, MPhase=%d,"
		" CmdIds=(%d to %d), Biq2byp=%d\n",
		searchmode, mphase, cmd_idx, cmd_stop_idx, Biq2byp));

	if (TINY_RADIO(pi) && IBOARD(pi)) {
		OSL_DELAY(10000);
	}
	/* ---------------
	 *  Cmd Execution
	 * ---------------
	 */

	if (bcmerror == BCME_OK) { /* in case tone doesn't start (still needed?) */

		/* 43569/43570 and 5G */
		bool ipa_on_during_cal = (RADIOID(pi->pubpi.radioid) == BCM2069_ID) &&
			(RADIOREV(pi->pubpi.radiorev) == 0x2C ||
			RADIOREV(pi->pubpi.radiorev) == 0x2E) && (PHY_XTAL_IS40M(pi)) &&
			CHSPEC_IS5G(pi->radio_chanspec);

		/* loop over commands in this cal phase */
		for (; cmd_idx <= cmd_stop_idx; cmd_idx++) {

			/* get command, cal_type, and core */
			core = cmd_idx / num_cmds_per_core; /* integer divide */

			/* Turning on iPA during TXIQ cal improves cal result due to heating */
			if (ipa_on_during_cal) {
				MOD_RADIO_REGC(pi, GE16_OVR14, core, ovr_pa5g_5gtx_pu, 0x1);
				MOD_RADIO_REGC(pi, PA5G_CFG1, core, pa5g_5gtx_pu, 0x1);
			}

			/* only execute commands when the current core is active
			 * if ((pi->sh->phytxchain >> core) & 0x1) {
			 */
			/* Turn Off Inactive cores for 43602 to improve IQ cal */
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core_off) {
					if (core != core_off) {
						savereg[core_count].reg_val =
							READ_PHYREGCE
							(pi, RfctrlOverrideTxPus, core_off);
						savereg[core_count].reg_addr =
							ACPHYREGCE
							(pi, RfctrlOverrideTxPus, core_off);
						++core_count;
						savereg[core_count].reg_val =
							READ_PHYREGCE
							(pi, RfctrlCoreTxPus, core_off);
						savereg[core_count].reg_addr =
							ACPHYREGCE
							(pi, RfctrlCoreTxPus, core_off);
						++core_count;
						MOD_PHYREGCE
							(pi, RfctrlOverrideTxPus, core_off,
							     txrf_pwrup, 1);
						MOD_PHYREGCE
							(pi, RfctrlCoreTxPus, core_off,
							 txrf_pwrup, 0);
					}
				}
			}

			cmd = cmds[cmd_idx % num_cmds_per_core] | 0x8000 | (core << 12);
			cal_type = ((cmd & 0x0F00) >> 8);

			/* PHY_CAL(("wlc_phy_cal_txiqlo_acphy:
			 *  Cmds => cmd_idx=%2d, Cmd=0x%04x,	\
			 *  cal_type=%d, core=%d\n", cmd_idx, cmd, cal_type, core));
			 */

			/* set up scaled ladders for desired bbmult of current core */
			if (!accal->txiqlocal_ladder_updated[core]) {
				wlc_phy_cal_txiqlo_update_ladder_acphy(pi,
					accal->txcal_txgain[core].bbmult);
				accal->txiqlocal_ladder_updated[core] = TRUE;
			}

			/* set intervals settling and measurement intervals */
			WRITE_PHYREG(pi, iqloCalCmdNnum,
				(nsamp_corrs[bw_idx] << 8) | nsamp_gctrl[bw_idx]);

			/* if coarse-analog-LOFT cal (fi/fq),
			 *     always zero out ei/eq and di/dq;
			 * if fine-analog-LOFT   cal (ei/dq),
			 *     always zero out di/dq
			 *   - even do this with search-type REFINE, to prevent a "drift"
			 *   - assumes that order of LOFT cal cmds will be f => e => d,
			 *     where it's ok to have multiple cmds (say interrupted by
			 *     IQ cal) of the same type
			 */
			if ((cal_type == CAL_TYPE_LOFT_ANA_COARSE) ||
			    (cal_type == CAL_TYPE_LOFT_ANA_FINE)) {

				if (!(ACMAJORREV_1(pi->pubpi.phy_rev) && (cmd_idx >= 5))) {
					wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
						&zero, TB_START_COEFFS_D, core);
				}
			}

			if (cal_type == CAL_TYPE_LOFT_ANA_COARSE) {
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					&zero, TB_START_COEFFS_E, core);
			}

			for (thidx = 0; thidx < 6; thidx++) {

				/* Set thresh_d2 */
				WRITE_PHYREG(pi, iqloCalgtlthres, thres_ladder[thidx]);

				/* now execute this command and wait max of ~20ms */
				WRITE_PHYREG(pi, iqloCalCmd, cmd);
				SPINWAIT(((READ_PHYREG(pi, iqloCalCmd)
					   & 0xc000) != 0), ACPHY_SPINWAIT_TXIQLO);
				ASSERT((READ_PHYREG(pi, iqloCalCmd) & 0xc000) == 0);

				if (wlc_poll_adc_clamp_status(pi, core, 1) == 0) {
					break;
				}
				PHY_CAL(("wlc_phy_cal_txiqlo_acphy: Cmds => cmd_idx=%2d,",
				          cmd_idx));
				PHY_CAL(("Cmd=0x%04x, cal_type=%d, core=%d, ",
				          cmd, cal_type, core));
				PHY_CAL(("thresh_idx = %d\n", thidx));
			}

			/* Turn off iPA */
			if (ipa_on_during_cal) {
				MOD_RADIO_REGC(pi, GE16_OVR14, core, ovr_pa5g_5gtx_pu, 0x0);
			}

			/* copy coeffs best-to-start and to
			 * "intermediate" coeffs in pi state; in mphase,
			 * the latter is also used as starting point
			 * when coming back for next phase, and
			 * we always use the "intermediate" coeffs at
			 * the very end to apply to OFDM/BPHY,
			 * see below;
			 * (copy step only done for coeff pair that
			 * changed, thereby also covering ei/eq swap
			 * per PR 79353)
			 */
			switch (cal_type) {
			case CAL_TYPE_IQ:
				rd_select  = TB_BEST_COEFFS_AB;
				wr_select1 = TB_START_COEFFS_AB;
				wr_select2 = PI_INTER_COEFFS_AB;
				break;
			case CAL_TYPE_LOFT_DIG:
				rd_select  = TB_BEST_COEFFS_D;
				wr_select1 = TB_START_COEFFS_D;
				wr_select2 = PI_INTER_COEFFS_D;
				break;
			case CAL_TYPE_LOFT_ANA_FINE:
				rd_select  = TB_BEST_COEFFS_E;
				wr_select1 = TB_START_COEFFS_E;
				wr_select2 = PI_INTER_COEFFS_E;
				break;
			case CAL_TYPE_LOFT_ANA_COARSE:
				rd_select  = TB_BEST_COEFFS_F;
				wr_select1 = TB_START_COEFFS_F;
				wr_select2 = PI_INTER_COEFFS_F;
				break;
			default:
				ASSERT(0);
			}
			wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
			                                coeffs, rd_select,  core);
			wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			                                coeffs, wr_select1, core);
			if ((ACREV_IS(pi->pubpi.phy_rev, 1) ||
			     ACMAJORREV_5(pi->pubpi.phy_rev)) &&
			    ((cmd_idx % num_cmds_per_core) >= idx_for_loft_comp_tbl)) {
				/* write to the txpwrctrl tbls */
				*loft_coeffs_ptr++ = coeffs[0];
			}
			wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			                                coeffs, wr_select2, core);

			/* WAR for random spur issue in 1x1 which */
			/* happens when LOFT coeff is negative */
			if ((ACMAJORREV_1(pi->pubpi.phy_rev) ||
			     ACMAJORREV_2(pi->pubpi.phy_rev)) &&
			    (cmd_idx == 4)) {
				uint16 coeffs_digi[2];
				coeffs_digi[0] = 0x0808;
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs_digi, TB_BEST_COEFFS_D, core);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs_digi, TB_START_COEFFS_D, core);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs_digi, PI_INTER_COEFFS_D, core);
			}
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* Restore */
				while (core_count > 0) {
					--core_count;
					phy_reg_write(pi, savereg[core_count].reg_addr,
					              savereg[core_count].reg_val);
				}
			}
			/* }  txchain loop */
		} /* command loop */

		/* single phase or last tx stage in multiphase cal: apply & store overall results */
		if (Biq2byp == 0) {
		last_phase = !ACREV_IS(pi->pubpi.phy_rev, 1) ?
			ACPHY_CAL_PHASE_TX8 : ACPHY_CAL_PHASE_TX_LAST;
		if ((mphase == 0) || (pi->cal_info->cal_phase_id == last_phase)) {

			PHY_CAL(("wlc_phy_cal_txiqlo_acphy (mphase = %d, refine = %d):\n",
			         mphase, searchmode == PHY_CAL_SEARCHMODE_REFINE));
			for (cr = 0; cr < num_cores; cr++) {
				/* Save and Apply IQ Cal Results */
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
					coeffs, PI_INTER_COEFFS_AB, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, PI_FINAL_COEFFS_AB, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, TB_OFDM_COEFFS_AB,  cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, TB_BPHY_COEFFS_AB,  cr);

				/* Save and Apply Dig LOFT Cal Results */
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
					coeffs, PI_INTER_COEFFS_D, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, PI_FINAL_COEFFS_D, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, TB_OFDM_COEFFS_D,  cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, TB_BPHY_COEFFS_D,  cr);

				/* Apply Analog LOFT Comp
				 * - unncessary if final command on each core is digital
				 * LOFT-cal or IQ-cal
				 * - then the loft comp coeffs were applied to radio
				 * at the beginning of final command per core
				 * - this is assumed to be the case, so nothing done here
				 */

				/* Save Analog LOFT Comp in PI State */
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
					coeffs, PI_INTER_COEFFS_E, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, PI_FINAL_COEFFS_E, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
					coeffs, PI_INTER_COEFFS_F, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
					coeffs, PI_FINAL_COEFFS_F, cr);

				/* Print out Results */
				PHY_CAL(("\tcore-%d: a/b = (%4d,%4d), d = (%4d,%4d),"
					" e = (%4d,%4d), f = (%4d,%4d)\n", cr,
					accal->txiqlocal_coeffs[cr*5+0],  /* a */
					accal->txiqlocal_coeffs[cr*5+1],  /* b */
					(accal->txiqlocal_coeffs[cr*5+2] & 0xFF00) >> 8, /* di */
					(accal->txiqlocal_coeffs[cr*5+2] & 0x00FF),      /* dq */
					(accal->txiqlocal_coeffs[cr*5+3] & 0xFF00) >> 8, /* ei */
					(accal->txiqlocal_coeffs[cr*5+3] & 0x00FF),      /* eq */
					(accal->txiqlocal_coeffs[cr*5+4] & 0xFF00) >> 8, /* fi */
					(accal->txiqlocal_coeffs[cr*5+4] & 0x00FF)));   /* fq */
			} /* for cr */

			/* validate availability of results and store off channel */
			accal->txiqlocal_coeffsvalid = TRUE;
			accal->chanspec = pi->radio_chanspec;
		} /* writing of results */
		    } else {
		last_phase = ACPHY_CAL_PHASE_TXPRERXCAL2;
		if ((mphase == 0) || (pi->cal_info->cal_phase_id == last_phase)) {

			PHY_CAL(("wlc_phy_cal_txiqlo_acphy (Biq2byp = %d, mphase = %d,"
			    " refine = %d):\n", Biq2byp, mphase,
			    searchmode == PHY_CAL_SEARCHMODE_REFINE));
			for (cr = 0; cr < num_cores; cr++) {
				/* Save IQ Cal coeffs for RX-cal */
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
					coeffs, PI_INTER_COEFFS_AB, cr);
				wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE_BIQ2BYP,
					coeffs, PI_INTER_COEFFS_AB, cr);

				/* Print out Results */
				PHY_CAL(("\tcore-%d: a/b = (%4d,%4d),\n", cr,
					accal->txiqlocal_biq2byp_coeffs[cr*2+0],   /* a */
					accal->txiqlocal_biq2byp_coeffs[cr*2+1])); /* b */
			} /* for cr */

			/* validate availability of results and store off channel */
			accal->txiqlocal_coeffsvalid = TRUE;
			accal->chanspec = pi->radio_chanspec;
		} /* writing of results */
		    }

		/* Switch off test tone */
		wlc_phy_stopplayback_acphy(pi);	/* mimophy_stop_playback */

	} /* if BCME_OK */

	/* disable IQ/LO cal */
	WRITE_PHYREG(pi, iqloCalCmdGctl, 0x0000);

	/* 4350A0 FIXME: Add Jira
	 * Remove forcing of gated clks
	 */
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);

	/* LOFT WAR for 4360 and 43602 */
	if ((ACREV_IS(pi->pubpi.phy_rev, 1) || ACMAJORREV_5(pi->pubpi.phy_rev)) &&
	    !(Biq2byp && (pi->u.pi_acphy->srom.precal_tx_idx))) {
		/* Skipping for 43602 when Biq2byp = 0, ie, cal is RX. */
		/* Calling for 43602 when srom.precal_tx_idx is not set. */
		wlc_phy_populate_tx_loft_comp_tbl_acphy(pi, loft_coeffs);
	}

	/* clean Up PHY and radio */
	wlc_phy_txcal_txgain_cleanup_acphy(pi, &orig_txgain[0]);
	wlc_phy_txcal_phy_cleanup_acphy(pi);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_txcal_radio_cleanup_acphy_20691(pi);
	else
		wlc_phy_txcal_radio_cleanup_acphy(pi);
	WRITE_PHYREG(pi, ClassifierCtrl, classifier_state);

	/* XXX FIXME: May consider saving off LOFT comp before 1st phase and
	 *  restoring LOFT comp  after each phase except for last phase
	 */

	/*
	 *-----------*
	 *  Cleanup  *
	 *-----------
	*/
	/* Restore original rxchains */
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}
	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	/* Restore PAPD state */
	FOREACH_CORE(pi, core) {
		WRITE_PHYREGCE(pi, PapdEnable, core, papdState[core]);
	}
	return bcmerror;
}

/* see also: proc acphy_rx_iq_est { {num_samps 2000} {wait_time ""} } */
void
wlc_phy_rx_iq_est_acphy(phy_info_t *pi, phy_iq_est_t *est, uint16 num_samps,
                        uint8 wait_time, uint8 wait_for_crs, bool rxiq_cal)
{
	uint8 core;
	bool percore = rxiq_cal;

	/* structure for saving txpu_ovrd, txpu_val, rxpu_ovrd and rxpu_val
	 * 4 register values for each core
	 */
	struct _save_regs {
		uint16 reg_val;
		uint16 reg_addr;
	} savereg[PHY_CORE_MAX*4];

	uint core_count = 0;

	percore &= CHSPEC_IS2G(pi->radio_chanspec) ? pi->u.pi_acphy->rxiqcal_percore_2g :
	        pi->u.pi_acphy->rxiqcal_percore_5g;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* Skip this function for QT but provide dummy initialisation */
	if (ISSIM_ENAB(pi->sh->sih)) {
		est[0].i_pwr = 0;
		est[0].q_pwr = 0;
		return;
	}

	/* XXX FIXME(clamp): Make sure ADC is not oscillating
	 */
	wlc_phy_pulse_adc_reset_acphy(pi);

	/* Get Rx IQ Imbalance Estimate from modem */
	WRITE_PHYREG(pi, IqestSampleCount, num_samps);
	MOD_PHYREG(pi, IqestWaitTime, waitTime, wait_time);
	MOD_PHYREG(pi, IqestCmd, iqMode, wait_for_crs);

	if (!percore) {
		MOD_PHYREG(pi, IqestCmd, iqstart, 1);

		/* wait for estimate */
		SPINWAIT((READ_PHYREGFLD(pi, IqestCmd, iqstart) != 0),
			ACPHY_SPINWAIT_IQEST);

		if (READ_PHYREGFLD(pi, IqestCmd, iqstart) == 0) {
			ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				est[core].i_pwr = (READ_PHYREGCE(pi, IqestipwrAccHi, core) << 16) |
				                  READ_PHYREGCE(pi, IqestipwrAccLo, core);
				est[core].q_pwr = (READ_PHYREGCE(pi, IqestqpwrAccHi, core) << 16) |
				                  READ_PHYREGCE(pi, IqestqpwrAccLo, core);
				est[core].iq_prod = (READ_PHYREGCE(pi, IqestIqAccHi, core) << 16) |
				                    READ_PHYREGCE(pi, IqestIqAccLo, core);
				PHY_NONE(("wlc_phy_rx_iq_est_acphy: core%d "
				          "i_pwr = %u, q_pwr = %u, iq_prod = %d\n",
				          core, est[core].i_pwr, est[core].q_pwr,
				          est[core].iq_prod));
			}
		} else {
			PHY_ERROR(("wl%d: %s: IQ measurement timed out\n",
			          pi->sh->unit, __FUNCTION__));
			if (!ACMAJORREV_2(pi->pubpi.phy_rev))
				ASSERT(READ_PHYREGFLD(pi, IqestCmd, iqstart) == 0);
		}
	} else {
		uint8 core_off;

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			/* SAVE and turn off all cores except one */
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core_off) {
				if (core != core_off) {
					savereg[core_count].reg_val =
						READ_PHYREGCE(pi, RfctrlOverrideTxPus, core_off);
					savereg[core_count].reg_addr =
						ACPHYREGCE(pi, RfctrlOverrideTxPus, core_off);
					++core_count;

					savereg[core_count].reg_val =
						READ_PHYREGCE(pi, RfctrlCoreTxPus, core_off);
					savereg[core_count].reg_addr =
						ACPHYREGCE(pi, RfctrlCoreTxPus, core_off);
					++core_count;

					savereg[core_count].reg_val =
						READ_PHYREGCE(pi, RfctrlOverrideRxPus, core_off);
					savereg[core_count].reg_addr =
						ACPHYREGCE(pi, RfctrlOverrideRxPus, core_off);
					++core_count;

					savereg[core_count].reg_val =
						READ_PHYREGCE(pi, RfctrlCoreRxPus, core_off);
					savereg[core_count].reg_addr =
						ACPHYREGCE(pi, RfctrlCoreRxPus, core_off);
					++core_count;

					MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core_off,
					             txrf_pwrup, 1);
					MOD_PHYREGCE(pi, RfctrlCoreTxPus, core_off, txrf_pwrup, 0);
					MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core_off,
					             logen_rx_pwrup, 1);
					MOD_PHYREGCE(pi, RfctrlCoreRxPus, core_off,
					             logen_rx_pwrup, 0);
				}
			}

			OSL_DELAY(1);
			MOD_PHYREG(pi, IqestCmd, iqstart, 1);

			/* wait for estimate */
			SPINWAIT((READ_PHYREGFLD(pi, IqestCmd, iqstart) != 0),
				ACPHY_SPINWAIT_IQEST);
			if (!ACMAJORREV_2(pi->pubpi.phy_rev))
				ASSERT(READ_PHYREGFLD(pi, IqestCmd, iqstart) == 0);

			/* Restore */
			while (core_count > 0) {
				--core_count;
				phy_reg_write(pi, savereg[core_count].reg_addr,
					savereg[core_count].reg_val);
			}

			if (READ_PHYREGFLD(pi, IqestCmd, iqstart) == 0) {
				ASSERT(PHYCORENUM(pi->pubpi.phy_corenum) <= PHY_CORE_MAX);
				est[core].i_pwr = (READ_PHYREGCE(pi, IqestipwrAccHi, core) << 16) |
				                  READ_PHYREGCE(pi, IqestipwrAccLo, core);
				est[core].q_pwr = (READ_PHYREGCE(pi, IqestqpwrAccHi, core) << 16) |
				                  READ_PHYREGCE(pi, IqestqpwrAccLo, core);
				est[core].iq_prod = (READ_PHYREGCE(pi, IqestIqAccHi, core) << 16) |
				                    READ_PHYREGCE(pi, IqestIqAccLo, core);
				PHY_NONE(("wlc_phy_rx_iq_est_acphy: core%d "
				          "i_pwr = %u, q_pwr = %u, iq_prod = %d\n",
				          core, est[core].i_pwr, est[core].q_pwr,
				          est[core].iq_prod));
			} else {
				PHY_ERROR(("wl%d: %s: IQ measurement timed out\n",
				          pi->sh->unit, __FUNCTION__));
			}
		}
	}
}

static void
wlc_phy_clip_det_acphy(phy_info_t *pi, bool enable)
{
	uint8 core;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	/* Make clip detection difficult (impossible?) */
	/* don't change this loop to active core loop, gives 100% per, why? */
	FOREACH_CORE(pi, core) {
		if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			if (enable) {
				WRITE_PHYREGC(pi, Clip1Threshold, core,
					pi_ac->clip1_th);
			} else {
				WRITE_PHYREGC(pi, Clip1Threshold, core, 0xffff);
			}
		} else {
			if (enable) {
				phy_reg_and(pi, ACPHYREGC(pi, computeGainInfo, core),
					(uint16)~ACPHY_REG_FIELD_MASK(pi, computeGainInfo, core,
					disableClip1detect));
			} else {
				phy_reg_or(pi, ACPHYREGC(pi, computeGainInfo, core),
					ACPHY_REG_FIELD_MASK(pi, computeGainInfo, core,
					disableClip1detect));
			}
		}
	}

}

void wlc_phy_force_crsmin_acphy(phy_info_t *pi, void *p)
{
	int8 *set_crs_thr = p;
	/* Local copy of phyrxchains before overwrite */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx bits from RfseqCoreActv.EnTx */
	uint8 save_EnTx = 0;
	/* Force turn-on flag */
	uint8 force_turnon = 0;

	/* Prepare Mac and Phregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Force turn on if needed */
	if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	}

	if (set_crs_thr[0] == -1) {
		/* Auto crsmin power mode */
		PHY_CAL(("Setting auto crsmin power mode\n"));
		wlc_phy_noise_sample_request_crsmincal((wlc_phy_t*)pi);
		pi->u.pi_acphy->crsmincal_enable = TRUE;
	} else if (set_crs_thr[0] == 0) {
		/* Default crsmin value */
		PHY_CAL(("Setting default crsmin: %d\n", ACPHY_CRSMIN_DEFAULT));
		wlc_phy_set_crs_min_pwr_acphy(pi, ACPHY_CRSMIN_DEFAULT, 0, 0);
		pi->u.pi_acphy->crsmincal_enable = FALSE;
	} else {
		/* Set the crsmin power value to be 'set_crs_thr' */
		PHY_CAL(("Setting crsmin: %d %d %d\n",
		         set_crs_thr[0], set_crs_thr[1], set_crs_thr[2]));
		wlc_phy_set_crs_min_pwr_acphy(pi, set_crs_thr[0], set_crs_thr[1], set_crs_thr[2]);
		pi->u.pi_acphy->crsmincal_enable = FALSE;
	}

	/* Restore */
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}
	/* Enable mac */
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}

void wlc_phy_lp_mode(phy_info_t *pi, int8 lp_mode)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev))	{
		if (lp_mode == 1) {
			/* AC MODE (Full Pwr mode) */
			pi_ac->acphy_lp_mode = 1;
		} else if (lp_mode == 2) {
			/* 11n MODE (VCO in 11n Mode) */
			pi_ac->acphy_lp_mode = 2;
		} else if (lp_mode == 3) {
			/* Low pwr MODE */
			pi_ac->acphy_lp_mode = 3;
		} else {
			return;
		}
	} else {
		return;
	}
}
void wlc_phy_force_lpvco_2G(phy_info_t *pi, int8 force_lpvco_2G)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	if ACMAJORREV_1(pi->pubpi.phy_rev)	{
		pi_ac->acphy_force_lpvco_2G = force_lpvco_2G;
	} else {
		return;
	}
}

void wlc_ant_div_sw_control(phy_info_t *pi, int8 divOvrride, int core)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	/* pin position 255 implies the NVRAM does not have antdiv_rfswctrlpin_aX entry */
	/* Diversity override can be 0 or 1 to select the antenna */
	/*  and 2 to restore original FEMCTRL table */
	if (core == 0 && (pi_ac->antdiv_rfswctrlpin_a0 != 255)) {
	  pi_ac->ant_swOvr_state_core0 = divOvrride;
	} else if (core == 1 && (pi_ac->antdiv_rfswctrlpin_a1 != 255)) {
	  pi_ac->ant_swOvr_state_core1 = divOvrride;
	} else {
	  return;
	}
	/* compute/write the whole femctrl table again for now */
	/* Should be optimized later */
	wlc_phy_write_regtbl_fc_from_nvram(pi);

#if defined(WLC_TXPWRCAP)
	/* Tx Pwr Cap update */
	wlc_phy_txpwrcap_set_acphy(pi);
#endif // endif

}

void
wlc_phy_smth(phy_info_t *pi, int8 enable_smth, int8 dump_mode)
{
#ifdef WL_PROXDETECT
	if (pi->u.pi_acphy->tof_smth_forced)
		return;
#endif // endif

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_3(pi->pubpi.phy_rev) && (!ACMINORREV_0(pi->pubpi.phy_rev)))) {
		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
		uint16 SmthReg0, SmthReg1;
		ACPHY_REG_LIST_START
			/* Set the SigB to the default values */
			MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs9, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs8, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs7, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs6, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs5, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs4, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs3, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs2, 0x7)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs1, 0x3)
			MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs0, 0x2)
		ACPHY_REG_LIST_EXECUTE(pi);

		pi_ac->acphy_smth_dump_mode = SMTH_NODUMP;

		switch (enable_smth) {
		case SMTH_DISABLE:
			/* Disable Smoothing and Enable SigB */
			SmthReg0 = READ_PHYREG(pi, chnsmCtrl0) & 0xFFFE;
			SmthReg1 = READ_PHYREG(pi, chnsmCtrl1);
			break;
		case SMTH_ENABLE:
			/* Enable Smoothing With all modes ON */
			/* This is the default config in which Smth is enabled for */
			/* SISO pkts and HT TxBF case. Use SigB for VHT-TxBF */
			SmthReg0 = 0x33F;
			SmthReg1 = 0x2C0;
			pi_ac->acphy_smth_dump_mode = dump_mode;
			switch (dump_mode)
			{
			case SMTH_FREQDUMP:
			/* Enable Freq-domain dumping (Raw Channel Estimates) */
			SmthReg0 &= ~(
				ACPHY_chnsmCtrl0_nw_whiten_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_group_delay_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_mte_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_window_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev));
			SmthReg1 &= ~(
				ACPHY_chnsmCtrl1_ifft_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev));
			break;

			case SMTH_FREQDUMP_AFTER_NW:
			/* Enable Freq-domain dumping (After NW Filtering) */
			SmthReg0 &= ~(
				ACPHY_chnsmCtrl0_group_delay_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_mte_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_window_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev));
			SmthReg1 &= ~(
				ACPHY_chnsmCtrl1_ifft_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev));
			break;

			case SMTH_FREQDUMP_AFTER_GD:
			/* Enable Freq-domain dumping (After GD Compensation) */
			SmthReg0 &= ~(
				ACPHY_chnsmCtrl0_mte_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_window_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev));
			SmthReg1 &= ~(
				ACPHY_chnsmCtrl1_ifft_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev));
			break;

			case SMTH_FREQDUMP_AFTER_MTE:
			/* Enable Freq-domain dumping (After MTE) */
			SmthReg0 &= ~(
				ACPHY_chnsmCtrl0_window_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev));
			SmthReg1 &= ~(
				ACPHY_chnsmCtrl1_ifft_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev));
			break;

			case SMTH_TIMEDUMP_AFTER_IFFT:
			/* Enable Time-domain dumping (After IFFT) */
			SmthReg0 &= ~(
				ACPHY_chnsmCtrl0_window_enable_MASK(pi->pubpi.phy_rev) |
				ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev));
			SmthReg1 &= ~ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev);
			break;

			case SMTH_TIMEDUMP_AFTER_WIN:
				/* Enable Time-domain dumping (After Windowing) */
			SmthReg0 &= ~ACPHY_chnsmCtrl0_fft_enable_MASK(pi->pubpi.phy_rev);
			SmthReg1 &= ~ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev);
			break;

			case SMTH_FREQDUMP_AFTER_FFT:
			/* Enable Freq-domain dumping (After FFT) */
			SmthReg1 &= ~ACPHY_chnsmCtrl1_output_enable_MASK(pi->pubpi.phy_rev);
			break;
			}
			break;
		case SMTH_ENABLE_NO_NW:
			/* Enable Smoothing With all modes ON Except NW Filter */
			SmthReg0 = 0x337;
			SmthReg1 = 0x2C0;
			break;
		case SMTH_ENABLE_NO_NW_GD:
			/* Enable Smoothing With all modes ON Except NW and GD  */
			SmthReg0 = 0x317;
			SmthReg1 = 0x2C0;
			break;
		case SMTH_ENABLE_NO_NW_GD_MTE:
			/* Enable Smoothing With all modes ON Except NW, GD and  MTE */
			SmthReg0 = 0x307;
			SmthReg1 = 0x2C0;
			break;
		case DISABLE_SIGB_AND_SMTH:
			/* Disable Smoothing and SigB */
			SmthReg0 = 0x33E;
			SmthReg1 = 0x0C0;
			ACPHY_REG_LIST_START
				MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs9, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb2, mu_sigbmcs8, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs7, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs6, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs5, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb1, mu_sigbmcs4, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs3, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs2, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs1, 0x0)
				MOD_PHYREG_ENTRY(pi, musigb0, mu_sigbmcs0, 0x0)
			ACPHY_REG_LIST_EXECUTE(pi);
			break;
		case SMTH_FOR_TXBF:
			/* Enable Smoothing for TxBF using Smth for HT and VHT */
			SmthReg0 = 0x33F;
			SmthReg1 = 0x6C0;
			break;
		default:
			PHY_ERROR(("wl%d: %s: Unrecognized smoothing mode: %d\n",
			          pi->sh->unit, __FUNCTION__, enable_smth));
			return;
		}
		WRITE_PHYREG(pi, chnsmCtrl0, SmthReg0);
		WRITE_PHYREG(pi, chnsmCtrl1, SmthReg1);
		pi_ac->acphy_enable_smth = enable_smth;

		/* set the Tiny specific filter slopes for channel smoothing */
		if (ACMAJORREV_3(pi->pubpi.phy_rev) && (!ACMINORREV_0(pi->pubpi.phy_rev))) {
			ACPHY_REG_LIST_START
				MOD_PHYREG_ENTRY(pi, chnsmCtrl5, filter_slope_20MHz, 0x2)
				MOD_PHYREG_ENTRY(pi, chnsmCtrl6, filter_slope_40MHz, 0x2)
				MOD_PHYREG_ENTRY(pi, chnsmCtrl6, filter_slope_80MHz, 0x1)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}
}

/* Write/init the PAPR table.
 * Values only changes (partly) when the band changes, so set init TRUE if this is the first time
 * this function is called, when the band changed, set band_changed to TRUE.
 * init and band_changed will be ignored when PAPR block was not enabled yet and full init is done.
 * REF: http://confluence.broadcom.com/download/attachments/301029188/PAPRR_feb2014.pptx
 */
static void
WLBANDINITFN(wlc_phy_papr_acphy)(phy_info_t *pi, bool enable, bool init, bool band_changed)
{
	uint32 lowMcsGamma = (600 << 13) | 600;
	uint32 highMcsGamma;
	uint32 highMcsGamma_c8_c9 = (1100 << 13) | 1100;
	uint16 gammaOffset[3] = {0, 0, 0};
	uint32 gain, gamma;
	uint8  i, tableOffset;
	uint32 tableData[32];

	if (enable == FALSE) {
		MOD_PHYREG(pi, papr_ctrl, papr_blk_en, 0);
		return;
	} else {
		/* Was PAPR not yet enabled? If so, force init */
		if (READ_PHYREGFLD(pi, papr_ctrl, papr_blk_en) == 0) {
			init = TRUE;
			band_changed = TRUE;
		}
	}

	if (init) {
		/* Things that only needs to be written once */
		MOD_PHYREG(pi, papr_ctrl, papr_blk_en, 1);
		MOD_PHYREG(pi, papr_ctrl, papr_final_clipping_en, 0);
		MOD_PHYREG(pi, papr_ctrl, papr_final_scaling_en, 0);
		MOD_PHYREG(pi, papr_ctrl, papr_override_enable, 0);

		/* Gain LUT */
		tableOffset = 4; /* Skip CCK entries */
		for (i = 4; i <= 32; i++) {
			if (i <= 29) {
				/* gain entries for different rates */
				gain = 128;
			} else {
				/* gain offsets */
				gain = 0;
			}
			tableData[i - tableOffset] = gain;
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 32 - 4 + 1,
		                          tableOffset, 32, tableData);

		/* Gamma LUT starts at 0x40 */

		/* The lowMcsGamma is band independent */
		tableData[0] = lowMcsGamma;
		tableData[1] = lowMcsGamma;
		tableData[2] = lowMcsGamma;
		tableData[3] = lowMcsGamma;

		tableOffset = 0x44;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 4, tableOffset, 32, tableData);

		tableOffset = 0x4c;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 3, tableOffset, 32, tableData);

		tableOffset = 0x54;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 3, tableOffset, 32, tableData);

		tableData[0] = gammaOffset[0];
		tableData[1] = gammaOffset[1];
		tableData[2] = gammaOffset[2];
		tableOffset = 0x5e;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 3, tableOffset, 32, tableData);
	}

	/* The highMcsGamma is band dependent */
	if (band_changed) {
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
				PHY_XTAL_IS40M(pi))
			highMcsGamma = 8191;
		else if (CHSPEC_IS2G(pi->radio_chanspec))
			highMcsGamma = 950;
		else
			highMcsGamma = 1100;
		highMcsGamma = (highMcsGamma << 13) | highMcsGamma;

		tableData[0] = highMcsGamma;
		tableData[1] = highMcsGamma;
		tableData[2] = highMcsGamma;
		tableData[3] = highMcsGamma;
		tableData[4] = highMcsGamma;

		tableOffset = 0x48;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 4, tableOffset, 32, tableData);

		tableOffset = 0x4f;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 5, tableOffset, 32, tableData);

		if (!PHY_IPA(pi) && ACMAJORREV_2(pi->pubpi.phy_rev) &&
				CHSPEC_IS2G(pi->radio_chanspec)) {
			gamma = (highMcsGamma_c8_c9 << 13) | highMcsGamma_c8_c9;
		} else {
			gamma = highMcsGamma;
		}
		tableData[5] = gamma;
		tableData[6] = gamma;

		tableOffset = 0x57;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_PAPR, 7, tableOffset, 32, tableData);
	}
}

void
wlc_phy_preempt(phy_info_t *pi, bool enable_preempt)
{
	const uint16 clip_detect_cond2_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond2_enable);
	const uint16 low_power_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, low_power_enable);
	uint16 per_pkt_en0 =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond3_enable) |
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_enable);
	uint16 pktabortctl = 0;

#ifdef WLC_DISABLE_PREEMPT
	enable_preempt = FALSE;	/* override flag ... never enable */
#endif /* !WLC_DISABLE_PREEMPT */

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		if (enable_preempt) {
			if (ACMAJORREV_3(pi->pubpi.phy_rev)) {

				WRITE_PHYREG(pi, PktAbortSupportedStates,
				             (ACREV_GE(pi->pubpi.phy_rev, 13)) ? 0x2bbf : 0x2bb7);
			} else {
				WRITE_PHYREG(pi, PktAbortSupportedStates, 0x2bb7);
				WRITE_PHYREG(pi, SpareReg, 0x3f);
			}
			pktabortctl = 0x1841;
			ACPHY_REG_LIST_START
				WRITE_PHYREG_ENTRY(pi, PREMPT_per_pkt_en0, 0x1)
				WRITE_PHYREG_ENTRY(pi, PktAbortCtrl, 0x1841 /* pktabortctl */)
				WRITE_PHYREG_ENTRY(pi, BphyAbortExitCtrl, 0x3840)
				MOD_PHYREG_ENTRY(pi, RxMacifMode, AbortStatusEn, 1)
				WRITE_PHYREG_ENTRY(pi, PREMPT_ofdm_nominal_clip_th0, 0xffff)
				WRITE_PHYREG_ENTRY(pi, PREMPT_ofdm_large_gain_mismatch_th0, 0x1f)
				WRITE_PHYREG_ENTRY(pi, PREMPT_cck_nominal_clip_th0, 0xffff)
				WRITE_PHYREG_ENTRY(pi, PREMPT_cck_large_gain_mismatch_th0, 0x1f)
			ACPHY_REG_LIST_EXECUTE(pi);
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				if (CHSPEC_IS80(pi->radio_chanspec)) {
					WRITE_PHYREG(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0xb0);
				} else if (CHSPEC_IS40(pi->radio_chanspec)) {
					WRITE_PHYREG(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x50);
				} else {
					WRITE_PHYREG(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x28);
				}
				if ((ACMAJORREV_3(pi->pubpi.phy_rev)) &&
					(pi->u.pi_acphy->LTEJ_WAR_en == TRUE)) {
					WRITE_PHYREG(pi, PREMPT_ofdm_large_gain_mismatch_th0, 9);
				}
			} else {
				WRITE_PHYREG(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x28);
				WRITE_PHYREG(pi, PREMPT_cck_nominal_clip_cnt_th0, 0x38);
			}
		} else {
		  /* disable Preempt */
		  ACPHY_REG_LIST_START
			  MOD_PHYREG_ENTRY(pi, RxMacifMode, AbortStatusEn, 0)
			  MOD_PHYREG_ENTRY(pi, PktAbortCtrl, PktAbortEn, 0)
			  WRITE_PHYREG_ENTRY(pi, PREMPT_per_pkt_en0, 0x0)
		  ACPHY_REG_LIST_EXECUTE(pi);
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Enable Preemption */
		if (enable_preempt) {
			pktabortctl = 0x1041;
			WRITE_PHYREG(pi, PktAbortCtrl, pktabortctl);
			WRITE_PHYREG(pi, RxMacifMode, 0x0a00);
			/* 4350 c1 has a HW bug in bphy premption
			 * Turn off bphy premption till c2 comes back
			 * WRITE_PHYREG(pi, PktAbortSupportedStates, 0x283f);
			 */
			if ((ACMAJORREV_2(pi->pubpi.phy_rev) && ACMINORREV_4(pi->pubpi.phy_rev)) ||
					ACMAJORREV_5(pi->pubpi.phy_rev)) {
				if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
					/* with Low Power Detect preemption enabled,
					 * keep PKTABORT_WAIT_NCLKS disabled
					 */
					WRITE_PHYREG(pi, PktAbortSupportedStates, 0x2fbf);
				} else {
					WRITE_PHYREG(pi, PktAbortSupportedStates, 0x2fff);
				}
				ACPHYREG_BCAST(pi, PREMPT_cck_large_gain_mismatch_th0, 0x9);
				/* Lots of jammer signals get falsely classified as
				 * GF frames and end up in chanest_2.
				 * Forcing MM mode with the below setting improves
				 * 5G jammer performance slightly
				*/
				MOD_PHYREG(pi, miscSigCtrl, force_1st_sigqual_bpsk, 1);
				if (ACMAJORREV_5(pi->pubpi.phy_rev))
					ACPHYREG_BCAST(pi, Core0cckcomputeGainInfo, 0x3);
			} else {
				ACPHY_REG_LIST_START
					WRITE_PHYREG_ENTRY(pi, PktAbortSupportedStates,
						((AC4354REV(pi)) ? 0x2ab7 : 0x2ff7))
					ACPHYREG_BCAST_ENTRY(pi,
						PREMPT_cck_large_gain_mismatch_th0, 0x1f)
				ACPHY_REG_LIST_EXECUTE(pi);
			}

			ACPHY_REG_LIST_START
			  WRITE_PHYREG_ENTRY(pi, BphyAbortExitCtrl, 0x3840)
			  /* Bit 6: clip_detect_cond3_enable ==1 and
			     Bit 0: clip_detect_enable == 1
			   */
			  ACPHYREG_BCAST_ENTRY(pi, PREMPT_ofdm_nominal_clip_th0, 0xffff)
			  ACPHYREG_BCAST_ENTRY(pi, PREMPT_ofdm_large_gain_mismatch_th0, 0x1f)
			  ACPHYREG_BCAST_ENTRY(pi, PREMPT_cck_nominal_clip_th0, 0xffff)
			  ACPHYREG_BCAST_ENTRY(pi, PREMPT_cck_nominal_clip_cnt_th0, 0x30)
			ACPHY_REG_LIST_EXECUTE(pi);
			if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
				ACPHY_REG_LIST_START
				        ACPHYREG_BCAST_ENTRY(pi, PREMPT_cck_nominal_clip_cnt_th0,
				                             0x32)
				        ACPHY_REG_LIST_EXECUTE(pi);
			}

			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				if (!PHY_ILNA(pi)) {
					per_pkt_en0 |= clip_detect_cond2_enable;
					ACPHYREG_BCAST(pi, PREMPT_ofdm_large_gain_mismatch_th0,
							0x9);
				}
				if (CHSPEC_IS20(pi->radio_chanspec)) {
					per_pkt_en0 |= clip_detect_cond2_enable;
					if (PHY_ILNA(pi)) {
					  ACPHY_REG_LIST_START
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_large_gain_mismatch_th0, 0xf)
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_nominal_clip_cnt_th0, 0x30)
					  ACPHY_REG_LIST_EXECUTE(pi);
					} else {
					  ACPHY_REG_LIST_START
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_large_gain_mismatch_th0, 0x9)
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_nominal_clip_cnt_th0, 0x24)
					  ACPHY_REG_LIST_EXECUTE(pi);
					}
				} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				        ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x48);
				} else {
					ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0xa0);
				}
			} else {
			        if (CHSPEC_IS20(pi->radio_chanspec)) {
					per_pkt_en0 |= clip_detect_cond2_enable;
					if (PHY_ILNA(pi)) {
					  ACPHY_REG_LIST_START
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_nominal_clip_cnt_th0, 0x30)
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_large_gain_mismatch_th0, 0xf)
					  ACPHY_REG_LIST_EXECUTE(pi);
					} else {
					  ACPHY_REG_LIST_START
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_nominal_clip_cnt_th0, 0x24)
					    ACPHYREG_BCAST_ENTRY(pi,
					      PREMPT_ofdm_large_gain_mismatch_th0, 0x9)
					  ACPHY_REG_LIST_EXECUTE(pi);
					}
				} else {
					ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x48);
				}
			}
			if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
				/* enable low power detect preemption and set thresholds */
				per_pkt_en0 |= low_power_enable;
				ACPHY_REG_LIST_START
					ACPHYREG_BCAST_ENTRY(pi, PREMPT_ofdm_low_power_mismatch_th0,
							0x1f)
					ACPHYREG_BCAST_ENTRY(pi, PREMPT_cck_low_power_mismatch_th0,
							0x1f)
				ACPHY_REG_LIST_EXECUTE(pi);
			}
			ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, per_pkt_en0);
			/* Enable Preemption */
		} else {
			ACPHY_REG_LIST_START
			  /* disable Preempt */
			    MOD_PHYREG_ENTRY(pi, RxMacifMode, AbortStatusEn, 0)
			    MOD_PHYREG_ENTRY(pi, PktAbortCtrl, PktAbortEn, 0)
			    ACPHYREG_BCAST_ENTRY(pi, PREMPT_per_pkt_en0, 0x0)
			    MOD_PHYREG_ENTRY(pi, miscSigCtrl, force_1st_sigqual_bpsk, 0)
			ACPHY_REG_LIST_EXECUTE(pi);
			if (ACMAJORREV_5(pi->pubpi.phy_rev))
				ACPHYREG_BCAST(pi, Core0cckcomputeGainInfo, 0x0);
		}
	}

	pi->u.pi_acphy->pktabortctl = pktabortctl;
	wlc_phy_btc_dyn_preempt(pi);
}

void
wlc_phy_btc_dyn_preempt(phy_info_t *pi)
{
	uint16 bt_shm_addr;
	uint16 pktabortctl = pi->u.pi_acphy->pktabortctl;
	int btc_mode;

	if (!pi->sh->clk || D11REV_LT(pi->sh->corerev, 47)) {
		return;
	}

	bt_shm_addr = 2 * wlapi_bmac_read_shm(pi->sh->physhim, M_BTCX_BLK_PTR);
	btc_mode = wlapi_bmac_btc_mode_get(pi->sh->physhim);

	if (btc_mode == WL_BTC_DISABLE || btc_mode == WL_BTC_DEFAULT) {
	        WRITE_PHYREG(pi, PktAbortCtrl, pktabortctl);
		pktabortctl = 0;
	}
	wlapi_bmac_write_shm(pi->sh->physhim,
	    bt_shm_addr + M_BTCX_PKTABORTCTL_VAL, pktabortctl);
}

void
wlc_phy_crs_min_pwr_cal_acphy(phy_info_t *pi, uint8 crsmin_cal_mode)
{
	int8   cmplx_pwr_dbm[PHY_CORE_MAX], cnt, tmp_diff, cache_up_th = 2;
	int8   offset_1 = 0, offset_2 = 0;
	int8   thresh_20[] = {45, 48, 51, 53, 54, 57, 60, 63, 66, 68,
			      70, 72, 75, 78, 80}; /* idx 0 --> -34 dBm */
	int8   thresh_40[] = {44, 46, 48, 50, 52, 54, 56, 58, 60, 63,
			      66, 69, 71, 74, 76}; /* idx 0 --> -33 dBm */
	int8   thresh_80[] = {41, 44, 46, 48, 50, 52, 55, 57, 60, 63,
			      65, 68, 70, 72, 74}; /* idx 0 --> -30 dBm */
	uint8  thresh_sz = sizeof(thresh_20);
	uint8  i;
	uint8  fp[PHY_CORE_NUM_4];
	uint8  chan_freq_range, run_cal = 0, abs_diff_cache_curr = 0;
	int16  acum_noise_pwr;

	struct Tidxlist {
		int8 idx;
		int8 core;
	} idxlists[PHY_CORE_MAX];

	uint core_count = 0;

	/* Local copy of phyrxchains before overwrite */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx bits from RfseqCoreActv.EnTx */
	uint8 save_EnTx = 0;
	/* Flag set if force turned on */
	uint8 force_turnon = 0;

	bzero((uint8 *)cmplx_pwr_dbm, sizeof(cmplx_pwr_dbm));
	bzero((uint8 *)fp, sizeof(fp));

	/* Increase crsmin by 1.5dB for 4360/43602. Helps with Zero-pkt-loss (less fall triggers) */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		for (i = 0; i < thresh_sz; i++) {
			thresh_20[i] += 4;
			thresh_40[i] += 4;
			thresh_80[i] += 4;
		}
	}

	/* Initialize */
	fp[0] = 0x36;
	if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
	  /* Force turn on radio chains if needed */
	  if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	  }
	}

	/* check the freq range of the current channel */
	/* 2G, 5GL, 5GM, 5GH, 5GX */
	chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	/* upate the noise pwr array with most recent noise pwr */
	if (crsmin_cal_mode == PHY_CRS_RUN_AUTO) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, i)  {
			pi->u.pi_acphy->phy_noise_pwr_array
			        [pi->u.pi_acphy->phy_noise_counter][i]
			        =  pi->u.pi_acphy->phy_noise_all_core[i]+1;
		}
		pi->u.pi_acphy->phy_noise_counter++;
		pi->u.pi_acphy->phy_noise_counter
		        = pi->u.pi_acphy->phy_noise_counter%(PHY_SIZE_NOISE_ARRAY);
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, i)  {
		if (crsmin_cal_mode == PHY_CRS_RUN_AUTO) {
			/* Enter here only from ucode noise interrupt */
			acum_noise_pwr = 0;
			/* average of the most recent noise pwrs */
			for (cnt = 0; cnt < PHY_SIZE_NOISE_ARRAY; cnt++) {
				if (pi->u.pi_acphy->phy_noise_pwr_array[cnt][i] != 0)
				{
					acum_noise_pwr += pi->u.pi_acphy->
					        phy_noise_pwr_array[cnt][i];
				} else {
					break;
				}
			}

			if (cnt != 0) {
				cmplx_pwr_dbm[i] = acum_noise_pwr/cnt;
			} else {
				goto restore_rxchain;
			}

			/* cache_update threshold: 2 4335 and 4350, and 3 for 4360 */
			if (ACMAJORREV_0(pi->pubpi.phy_rev))
				cache_up_th = 3;

			/* update noisecal_cache with valid noise power */
			/* check if the new noise pwr reading is same as cache */
			tmp_diff = 0;
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				tmp_diff = pi->u.pi_acphy->phy_noise_cache_crsmin
				        [chan_freq_range][i] - cmplx_pwr_dbm[i];
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				tmp_diff = (pi->u.pi_acphy->phy_noise_cache_crsmin
				            [chan_freq_range][i] + 3) - cmplx_pwr_dbm[i];
			} else {
				tmp_diff = (pi->u.pi_acphy->phy_noise_cache_crsmin
				            [chan_freq_range][i]+7) - cmplx_pwr_dbm[i];
			}

			abs_diff_cache_curr = tmp_diff < 0 ? (0 - tmp_diff) : tmp_diff;

			/* run crscal with the current noise pwr if the call comes from phy_cals */
			if (abs_diff_cache_curr >= cache_up_th || pi->u.pi_acphy->force_crsmincal) {
				run_cal++;
				if (CHSPEC_IS20(pi->radio_chanspec)) {
					pi->u.pi_acphy->phy_noise_cache_crsmin[chan_freq_range][i]
					        = cmplx_pwr_dbm[i];
				} else if (CHSPEC_IS40(pi->radio_chanspec)) {
					pi->u.pi_acphy->phy_noise_cache_crsmin[chan_freq_range][i] =
					        cmplx_pwr_dbm[i] - 3;
				} else {
					pi->u.pi_acphy->phy_noise_cache_crsmin[chan_freq_range][i]
					        = cmplx_pwr_dbm[i] - 7;
				}
			}
		} else {
			/* Enter here only from chan_change */

			/* During chan_change, read back the noise pwr from cache */
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				cmplx_pwr_dbm[i] = pi->u.pi_acphy->phy_noise_cache_crsmin
				        [chan_freq_range][i];
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				cmplx_pwr_dbm[i] = pi->u.pi_acphy->phy_noise_cache_crsmin
				        [chan_freq_range][i] + 3;
			} else {
				cmplx_pwr_dbm[i] = pi->u.pi_acphy->phy_noise_cache_crsmin
				        [chan_freq_range][i] + 7;
			}
		}

		/* get the index number for crs_th table */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			idxlists[core_count].idx = cmplx_pwr_dbm[i] + 34;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			idxlists[core_count].idx = cmplx_pwr_dbm[i] + 33;
		} else {
			idxlists[core_count].idx = cmplx_pwr_dbm[i] + 30;
		}

		PHY_CAL(("%s: cmplx_pwr (%d) =======  %d\n", __FUNCTION__, i, cmplx_pwr_dbm[i]));

		/* out of bound */
		if ((idxlists[core_count].idx < 0) ||
		    (idxlists[core_count].idx > (thresh_sz - 1))) {
			idxlists[core_count].idx = idxlists[core_count].idx < 0 ?
			        0 : (thresh_sz - 1);
		}

		idxlists[core_count].core = i;

		if (CHSPEC_IS20(pi->radio_chanspec)) {
			fp[idxlists[core_count].core] = thresh_20[idxlists[core_count].idx];
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			fp[idxlists[core_count].core] = thresh_40[idxlists[core_count].idx];
		} else if (CHSPEC_IS80(pi->radio_chanspec)) {
			fp[idxlists[core_count].core] = thresh_80[idxlists[core_count].idx];
		}
		/* GainHi threshold being stuck at 0x36 causes PER humps
		 */

		if (idxlists[core_count].core == 1) {
			offset_1 = fp[1] - fp[0];
		  if ((ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
		        ACMINORREV_1(pi->pubpi.phy_rev) || ACMINORREV_4(pi->pubpi.phy_rev))) ||
		        ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		    /* If the offset is > 6dB assume degenerate RX senario
		     */
		    if (ABS(offset_1) > 16) {
		      fp[0] = MAX(fp[0], fp[1]);
		      offset_1 = 0;
		    }
		  }
		} else if (idxlists[core_count].core == 2) {
			offset_2 = fp[2] - fp[0];
			if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			  /* If the offset is > 6dB assume degenerate RX senario
			   */
			  if (ABS(offset_2) > 16) {
			    fp[0] = MAX(fp[0], fp[2]);
			    offset_1 = 0;
			    offset_2 = 0;
			  }
			}
		}

		++core_count;
	}

	/* check if current noise pwr is different from the one in cache */
	if ((run_cal == 0) && (crsmin_cal_mode == PHY_CRS_RUN_AUTO))
		goto restore_rxchain;

	/* Below flag is set from phy_cals only */
	if (crsmin_cal_mode == PHY_CRS_RUN_AUTO)
		pi->u.pi_acphy->force_crsmincal = FALSE;

	pi->u.pi_acphy->crsmincal_run = 1;

	/* if noise desense is on, then the below variable will be used for comparison */
	pi->u.pi_acphy->phy_crs_th_from_crs_cal = MAX(MAX(fp[0], fp[1]), fp[2]);

	if (!ACPHY_ENABLE_FCBS_HWACI(pi) && !ACHWACIREV(pi)) {
		/* if desense is forced, then reset the variable below to default */
		if (pi->u.pi_acphy->total_desense.forced) {
			pi->u.pi_acphy->phy_crs_th_from_crs_cal = ACPHY_CRSMIN_DEFAULT;
			pi->u.pi_acphy->crsmincal_run = 2;
			goto restore_rxchain;
		}

		/* Don't update the crsmin registers if any desense(aci/bt) is on */
		if (pi->u.pi_acphy->total_desense.on) {
			pi->u.pi_acphy->crsmincal_run = 2;
			goto restore_rxchain;
		}
	}

	/* Debug: keep count of all calls to crsmin_cal  */
	/* Debug: store the channel info  */
	/* Debug: store the noise pwr used for updating crs thresholds */
	pi->u.pi_acphy->phy_debug_crscal_counter++;
	pi->u.pi_acphy->phy_debug_crscal_channel = CHSPEC_CHANNEL(pi->radio_chanspec);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, i)  {
		/* Debug info: for dumping the noise pwr used in crsmin_cal */
		pi->u.pi_acphy->phy_noise_in_crs_min[i] = cmplx_pwr_dbm[i];
	}

	/* since we are touching phy regs mac has to be suspended */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* call for updating the crsmin thresholds */
	wlc_phy_set_crs_min_pwr_acphy(pi, fp[0], offset_1, offset_2);

	/* resume mac */
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
	/* Keep only chains in phyrxchains active after cals are complete */
restore_rxchain:
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}
}

void
wlc_phy_txpwrctrl_set_target_acphy(phy_info_t *pi, uint8 pwr_qtrdbm, uint8 core)
{
	/* set target powers in 6.2 format (in dBs) */
	switch (core) {
	case 0:
		MOD_PHYREG(pi, TxPwrCtrlTargetPwr_path0, targetPwr0, pwr_qtrdbm);
		break;
	case 1:
		MOD_PHYREG(pi, TxPwrCtrlTargetPwr_path1, targetPwr1, pwr_qtrdbm);
		break;
	case 2:
		MOD_PHYREG(pi, TxPwrCtrlTargetPwr_path2, targetPwr2, pwr_qtrdbm);
		break;
	}
}

static bool
wlc_phy_txpwrctrl_ison_acphy(phy_info_t *pi)
{
	uint16 mask = (ACPHY_TxPwrCtrlCmd_txPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
	               ACPHY_TxPwrCtrlCmd_hwtxPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
	               ACPHY_TxPwrCtrlCmd_use_txPwrCtrlCoefs_MASK(pi->pubpi.phy_rev));

	return ((READ_PHYREG(pi, TxPwrCtrlCmd) & mask) == mask);
}

uint32
wlc_phy_txpwr_idx_get_acphy(phy_info_t *pi)
{
	uint8 core;
	uint32 pwr_idx[] = {0, 0, 0, 0};
	uint32 tmp = 0;

	if (wlc_phy_txpwrctrl_ison_acphy(pi)) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			pwr_idx[core] = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, baseIndex);
		}
	} else {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			pwr_idx[core] = (pi->u.pi_acphy->txpwrindex[core] & 0xff);
		}
	}
	tmp = (pwr_idx[3] << 24) | (pwr_idx[2] << 16) | (pwr_idx[1] << 8) | pwr_idx[0];

	return tmp;
}

void
wlc_phy_txpwrctrl_enable_acphy(phy_info_t *pi, uint8 ctrl_type)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint16 mask;
	uint8 core;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* check for recognized commands */
	switch (ctrl_type) {
	case PHY_TPC_HW_OFF:
	case PHY_TPC_HW_ON:
		pi->txpwrctrl = ctrl_type;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unrecognized ctrl_type: %d\n",
			pi->sh->unit, __FUNCTION__, ctrl_type));
		break;
	}

	if (ctrl_type == PHY_TPC_HW_OFF) {
		/* save previous txpwr index if txpwrctl was enabled */
		if (wlc_phy_txpwrctrl_ison_acphy(pi)) {
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				pi_ac->txpwrindex_hw_save[core] =
					READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, baseIndex);
				PHY_TXPWR(("wl%d: %s PWRCTRL: %d Cache Baseindex: %d Core: %d\n",
					pi->sh->unit, __FUNCTION__, ctrl_type,
					pi_ac->txpwrindex_hw_save[core], core));
				if (TINY_RADIO(pi)) {
					pi_ac->txpwrindex_cck_hw_save[core] =
						READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_cck_path, core,
						baseIndex_cck);
					PHY_TXPWR(("wl%d: %s PWRCTRL: %d Cache Baseindex: %d "
						"Core: %d\n", pi->sh->unit, __FUNCTION__, ctrl_type,
						pi_ac->txpwrindex_cck_hw_save[core], core));
				}
			}
		}

		/* Disable hw txpwrctrl */
		mask = ACPHY_TxPwrCtrlCmd_txPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
		       ACPHY_TxPwrCtrlCmd_hwtxPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
		       ACPHY_TxPwrCtrlCmd_use_txPwrCtrlCoefs_MASK(pi->pubpi.phy_rev);
		_PHY_REG_MOD(pi, ACPHY_TxPwrCtrlCmd(pi->pubpi.phy_rev), mask, 0);

	} else {
		/* XXX FIXME: measure idle tssi when txpwrctrl is enabled
		   to be removed when txpwrctrl is turned on by default
		*/
		if (!IBOARD(pi)) {
			/* Enable hw txpwrctrl */
			mask = ACPHY_TxPwrCtrlCmd_txPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
				ACPHY_TxPwrCtrlCmd_hwtxPwrCtrl_en_MASK(pi->pubpi.phy_rev) |
				ACPHY_TxPwrCtrlCmd_use_txPwrCtrlCoefs_MASK(pi->pubpi.phy_rev);
			_PHY_REG_MOD(pi, ACPHY_TxPwrCtrlCmd(pi->pubpi.phy_rev), mask, mask);
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
#ifdef WLC_TXCAL
				if (pi->txpwroverride && pi->olpc_idx_valid &&
				        pi->olpc_idx_in_use) {
					/* If in override mode and table based txcal */
					/* olpc anchor power tx idx is valid, */
					/* set init idx based on anchor power tx idx */
					/* and target power */
					uint8 iidx = 0;

					wlc_phy_olpc_idx_tempsense_comp_acphy(pi, &iidx, core);

					MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core,
						pwrIndex_init_path, iidx);
				} else {
#endif // endif
					if (pi_ac->txpwrindex_hw_save[core] != 128) {
						wlc_phy_txpwrctrl_set_baseindex(pi, core,
							pi_ac->txpwrindex_hw_save[core],
							ACPHY_ENC_OFDM);
						PHY_TXPWR(("wl%d: %s PWRCTRL: %d Restore Baseindex:"
							"%d Core: %d\n", pi->sh->unit, __FUNCTION__,
							ctrl_type, pi_ac->txpwrindex_hw_save[core],
							core));
	                }

					if (TINY_RADIO(pi) &&
						(pi_ac->txpwrindex_cck_hw_save[core] != 128)) {
						wlc_phy_txpwrctrl_set_baseindex(pi, core,
							pi_ac->txpwrindex_cck_hw_save[core],
							ACPHY_ENC_CCK);
						PHY_TXPWR(("wl%d: %s PWRCTRL: %d Restore"
							" Baseindex cck: %d Core: %d\n",
							pi->sh->unit, __FUNCTION__, ctrl_type,
							pi_ac->txpwrindex_cck_hw_save[core], core));
					}
#ifdef WLC_TXCAL
				}
#endif // endif
			}
		}
	}

	if (TINY_RADIO(pi)) {
		uint16 txPwrCtrlCmd = READ_PHYREGFLD(pi, TxPwrCtrlCmd, hwtxPwrCtrl_en);
		/* set phyreg(PapdEnable$core.gain_dac_rf_override$core)
		 * [expr !$phyreg(TxPwrCtrlCmd.hwtxPwrCtrl_en)]
		 */
		MOD_PHYREG(pi, PapdEnable0, gain_dac_rf_override0, (txPwrCtrlCmd ? 0 : 1));
	} else if (ctrl_type == PHY_TPC_HW_ON) {
		FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			MOD_PHYREGCEE(pi, PapdEnable, core, gain_dac_rf_override, 0);
		}
	}
}

/* Set init index and cycle clocks to propagate init index to base index */
static void
wlc_phy_txpwrctrl_set_baseindex(phy_info_t *pi, uint8 core, uint8 baseindex,
	acphy_enc_t frame_type)
{
	uint16 txpwrctrlcmd_SAVE;
	txpwrctrlcmd_SAVE = READ_PHYREG(pi, TxPwrCtrlCmd);
	if (frame_type == ACPHY_ENC_OFDM) {
	        MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core,
	                pwrIndex_init_path, baseindex);
	} else if (TINY_RADIO(pi)) {
	        MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core,
	                pwr_index_init_cck_path, baseindex);
	} else {
		ASSERT(0);
	}

	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
	MOD_PHYREG(pi, TxPwrCtrlCmd, txPwrCtrl_en, 0);
	MOD_PHYREG(pi, TxPwrCtrlCmd, hwtxPwrCtrl_en, 1);
	WRITE_PHYREG(pi, TxPwrCtrlCmd, txpwrctrlcmd_SAVE);
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
}

static void
wlc_phy_txpwrctrl_set_idle_tssi_acphy(phy_info_t *pi, int16 idle_tssi, uint8 core)
{
	bool flag2rangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi5g)) &&
		PHY_IPA(pi);

	/* set idle TSSI in 2s complement format (max is 0x1ff) */
	switch (core) {
	case 0:
		MOD_PHYREG(pi, TxPwrCtrlIdleTssi_path0, idleTssi0, idle_tssi);
		break;
	case 1:
		MOD_PHYREG(pi, TxPwrCtrlIdleTssi_path1, idleTssi1, idle_tssi);
		break;
	case 2:
		MOD_PHYREG(pi, TxPwrCtrlIdleTssi_path2, idleTssi2, idle_tssi);
		break;
	}

	/* Only 4335 and 4350 has 2nd idle-tssi */
	if (((ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
		TINY_RADIO(pi)) && pi->u.pi_acphy->srom.tssi_div_war) ||
		flag2rangeon) {
		switch (core) {
		case 0:
			MOD_PHYREG(pi, TxPwrCtrlIdleTssi_second_path0,
			           idleTssi_second0, idle_tssi);
			break;
		case 1:
			MOD_PHYREG(pi, TxPwrCtrlIdleTssi_second_path1,
			           idleTssi_second1, idle_tssi);
			break;
		}
	}
}
static void
wlc_phy_tssi_radio_setup_acphy(phy_info_t *pi, uint8 core_mask, uint8 for_iqcal)
{
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* 2069_gpaio(clear) to pwr up the GPAIO and clean up al lthe otehr test pins */
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
		FOREACH_ACTV_CORE(pi, core_mask, core) {
			/* first powerup the CGPAIO block */
			MOD_RADIO_REGC(pi, GE32_CGPAIO_CFG1, core, cgpaio_pu, 1);
		}
		ACPHY_REG_LIST_START
		/* turn off all test points in cgpaio block to avoid conflict,disable tp0 to tp15 */
		    WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG2, 0)
		    /* disable tp16 to tp31 */
		    WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG3, 0)
		    /* Disable muxsel0 and muxsel1 test points */
		    WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG4, 0)
		    /* Disable muxsel2 and muxselgpaio test points */
		    WRITE_RADIO_REG_ENTRY(pi, RFX_2069_GE32_CGPAIO_CFG5, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		ACPHY_REG_LIST_START
		    /* first powerup the CGPAIO block */
		    MOD_RADIO_REG_ENTRY(pi, RF2, CGPAIO_CFG1, cgpaio_pu, 1)
		/* turn off all test points in cgpaio block to avoid conflict,disable tp0 to tp15 */
		    WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG2, 0)
		    /* disable tp16 to tp31 */
		    WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG3, 0)
		    /* Disable muxsel0 and muxsel1 test points */
		    WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG4, 0)
		    /* Disable muxsel2 and muxselgpaio test points */
		    WRITE_RADIO_REG_ENTRY(pi, RF2_2069_CGPAIO_CFG5, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
	/* Powerdown rcal. This is one of the enable pins to AND gate in cgpaio block */
	MOD_RADIO_REG(pi, RF2, RCAL_CFG, pu, 0);

	FOREACH_ACTV_CORE(pi, core_mask, core) {

		if (for_iqcal == 0) {
			if (PHY_IPA(pi)) {
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0x2);
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_ext_tssi, 0x0);
					MOD_RADIO_REGC(pi, GE16_OVR21, core,
						ovr_pa5g_ctrl_tssi_sel, 0x1);
					MOD_RADIO_REGC(pi, TX5G_TSSI, core,
						pa5g_ctrl_tssi_sel, 0x0);
				} else {
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0x0);
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_ext_tssi, 0x0);
					MOD_RADIO_REGC(pi, GE16_OVR21, core,
						ovr_pa2g_ctrl_tssi_sel, 0x1);
					MOD_RADIO_REGC(pi, PA2G_TSSI, core,
						pa2g_ctrl_tssi_sel, 0x0);
				}
			} else  {
				if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) &&
				    CHSPEC_IS5G(pi->radio_chanspec)) {
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0x3);
				} else {
					MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw, 0x1);
				}
			}
		} else {
			MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_sw,
			               (CHSPEC_IS5G(pi->radio_chanspec)) ? 0x2 : 0x0);
		}
		if (!PHY_IPA(pi)) {
			MOD_RADIO_REGC(pi, IQCAL_CFG1, core, sel_ext_tssi, for_iqcal == 0);

			switch (core) {
			case 0:
				MOD_RADIO_REG(pi, RF2, CGPAIO_CFG4, cgpaio_tssi_muxsel0, 0x1);
				break;
			case 1:
				MOD_RADIO_REG(pi, RF2, CGPAIO_CFG4, cgpaio_tssi_muxsel1, 0x1);
				break;
			case 2:
				MOD_RADIO_REG(pi, RF2, CGPAIO_CFG5, cgpaio_tssi_muxsel2, 0x1);
				break;
			}
		}

		MOD_RADIO_REGC(pi, IQCAL_CFG1, core, tssi_GPIO_ctrl, 0);
		MOD_RADIO_REGC(pi, TESTBUF_CFG1, core, GPIO_EN, 0);

		/* Reg conflict with 2069 rev 16 */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
			MOD_RADIO_REGC(pi, TX5G_TSSI, core, pa5g_ctrl_tssi_sel, for_iqcal);
			MOD_RADIO_REGC(pi, OVR20, core, ovr_pa5g_ctrl_tssi_sel, 1);
		} else if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) ||
			(RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2)) {
			MOD_RADIO_REGC(pi, TX5G_TSSI, core, pa5g_ctrl_tssi_sel, for_iqcal);
			MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa5g_ctrl_tssi_sel, 1);
			MOD_RADIO_REGC(pi, PA2G_TSSI, core, pa2g_ctrl_tssi_sel, for_iqcal);
			MOD_RADIO_REGC(pi, GE16_OVR21, core, ovr_pa2g_ctrl_tssi_sel, 1);
		}

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_vcm_ctrl, 0x0);
			/* This bit is supposed to be controlled by phy direct control line.
			 * Please check: http://jira.broadcom.com/browse/HW11ACRADIO-45
			 */
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_sel_input, 0x2);
		}

	}
}

static void
wlc_phy_tssi_radio_setup_acphy_20691(phy_info_t *pi, uint8 core_mask, uint8 for_iqcal)
{
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	bool epaflag = ((CHSPEC_IS2G(pi->radio_chanspec) &&
		(pi->sh->extpagain2g == 0)) || (CHSPEC_IS5G(pi->radio_chanspec) &&
		(pi->sh->extpagain5g == 0)));

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* 20691_tssi_radio_setup */

	/* 20691_gpaio # Powerup gpaio block, powerdown rcal, clear all test point selection */
	MOD_RADIO_REG_20691(pi, GPAIO_SEL2, 0, gpaio_pu, 1);
	/* # Powerdown rcal otherwise it won't let any other test point go through */
	if (RADIO20691_MAJORREV(radio_rev) == 0)
		MOD_RADIO_REG_20691(pi, RCAL_CFG, 0, rcal_pu, 0);
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL0, 0, gpaio_sel_0to15_port, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL1, 0, gpaio_sel_16to31_port, 0x0)

		MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL0, 0, gpaio_sel_0to15_port, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, GPAIO_SEL1, 0, gpaio_sel_16to31_port, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);

	if ((PHY_IPA(pi) && !epaflag) || IBOARD(pi)) {
		/* #
		 *  # INT TSSI setup
		 *  #
		 */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REG_20691(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x0);
			/* # B3: (1 = iqcal, 0 = tssi);
			 * # B2: (1 = ext-tssi, 0 = int-tssi)
			 * # B1: (1 = 5g, 0 = 2g)
			 * # B0: (1 = wo filter, 0 = w filter for ext-tssi)
			 */
			 /* # Select PA output (and not PA input) */
			MOD_RADIO_REG_20691(pi, PA2G_CFG1, 0, pa2g_tssi_ctrl_sel, 0);
		} else {
			ACPHY_REG_LIST_START
			    MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x2)
			    /* # Select PA output (and not PA input) */
			    MOD_RADIO_REG_20691_ENTRY(pi, TX5G_MISC_CFG1, 0, pa5g_tssi_ctrl_sel, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_5G_OVR1, 0,
			        ovr_pa5g_tssi_ctrl_sel, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
		}

		/* # int-tssi select */
		MOD_RADIO_REG_20691(pi, IQCAL_CFG1, 0, iqcal_sel_ext_tssi, 0x0);
	} else {
		/* #
		 * # EPA TSSI setup
		 * #
		 */
		/* # Enabling and Muxing per band */
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
		    MOD_RADIO_REG_20691(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x3);
		} else {
			/* ### gband */
		    MOD_RADIO_REG_20691(pi, IQCAL_CFG1, 0, iqcal_sel_sw, 0x1);
		}
		ACPHY_REG_LIST_START
			/* # ext-tssi select */
			MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_sel_ext_tssi, 0x1)
			MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_OVR1, 0, ovr_iqcal_PU_tssi, 0x1)
			/* # power on tssi */
			MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_PU_tssi, 0x1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_OVR1, 0, ovr_iqcal_PU_iqcal, 0x1)
		/* # power off iqlocal */
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_PU_iqcal, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_CFG1, 0, iqcal_PU_tssi, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, IQCAL_OVR1, 0, ovr_iqcal_PU_tssi, 1)

		/* MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_in_test, 0xF) */

		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, 0, auxpga_i_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, 0, ovr_auxpga_i_sel_input, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, 0, auxpga_i_sel_input, 0x2)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_tssi_phy_setup_acphy(phy_info_t *pi, uint8 for_iqcal)
{
	uint8 core;
	bool flag2rangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi5g)) &&
		PHY_IPA(pi);
	bool flaglowrangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_lowpowerrange2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_lowpowerrange5g)) &&
		PHY_IPA(pi);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (ACREV_IS(pi->pubpi.phy_rev, 4) && CHSPEC_IS2G(pi->radio_chanspec))
			MOD_PHYREG(pi, TSSIMode, tssiADCSel, 0);
		else
			MOD_PHYREG(pi, TSSIMode, tssiADCSel, 1);

		if (TINY_RADIO(pi)) {
			if (!PHY_IPA(pi)) {
				if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
					MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_tx, 0x0);
				} else {
					MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_tx, 0x2);
				}
			} else {
				MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_tx,
					(CHSPEC_IS2G(pi->radio_chanspec) &&
					(pi->sh->extpagain2g == 0)) ? 0x1 : 0x0);
			}

			if (IBOARD(pi)) {
				MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_tx, 0x1);
			}
		}

		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, tssi_pu, 1);

		if (!PHY_IPA(pi)) {
			MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, tssi_pu, for_iqcal);
		} else {
			MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, tssi_pu, 1);
			if (flag2rangeon) {
				MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 0);
				MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_range, 0);
			} else if (flaglowrangeon) {
				MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 1);
				MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_range, 0);
			} else {
				MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 1);
				MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, tssi_range,
					~(for_iqcal));
			}
		}
	}
}

static void
wlc_phy_ipa_set_bbmult_acphy(phy_info_t *pi, uint16 *m0, uint16 *m1, uint16 *m2, uint8 coremask)
{
	/* TODO: 4360 */
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (coremask == 1) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 99, 16, m0);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 115, 16, m0);
	} else if (coremask == 2) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 103, 16, m1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 119, 16, m1);
	} else if (coremask == 3) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 99, 16, m0);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 115, 16, m0);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 103, 16, m1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 119, 16, m1);
	} else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 99, 16, m0);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 115, 16, m0);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 103, 16, m1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 119, 16, m1);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 107, 16, m2);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, 123, 16, m2);
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

/* Run PAPD calibration for Tiny */
static void
wlc_phy_tiny_papd_cal_run_acphy(phy_info_t *pi,
	uint8 tx_pre_cal_pwr_ctrl_state)
{
	uint8 j;
	uint8 core = 0;
	uint32 initvalue = 0;
	bool suspend = TRUE;
	uint8 yref = 5, start = 5;
	uint8 tx_atten = 3, rx_atten = 3;
	uint16 numiter = 128;
	uint32 scalar_table_ids[] = { ACPHY_TBL_ID_SCALAR0, ACPHY_TBL_ID_SCALAR1,
		ACPHY_TBL_ID_SCALAR2};

	/* suspend mac if haven't done so */
	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend) {
		printf("MAC was not suspended before calling wlc_phy_txpwr_papd_cal_run_acphy!\n");
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
	}

	wlc_phy_dac_rate_mode_acphy(pi, 1);

	/* clear eps table */
	for (j = 0; j < 64; j++) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1, j, 32, &initvalue);
	}
	pi->phy_pacalstatus = 0;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* initialize scalar table */
		wlc_phy_table_write_acphy(pi, scalar_table_ids[core], 64, 0, 32,
		acphy_papd_scaltbl);

		/* acphy_papd_cal_phy_setup */
		wlc_phy_papd_phy_setup_acphy(pi, core);
	}

	/* 20691_loopback_papd 0 $tx_atten $rx_atten */
	wlc_phy_papd_radio_loopback_setup_acphy_20691(pi, tx_atten, rx_atten);

	if (CHSPEC_IS2G(pi->radio_chanspec) && ACREV_GE(pi->pubpi.phy_rev, 4) && (!PHY_EPAPD(pi))) {
		wlc_phy_papd_rx_gain_ctrl_acphy(pi);
	}

	/* Disable BT as it affects PAPD CAL */
	wlc_btcx_override_enable(pi);
	/* Disable CRS */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* acphy_papd off */
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);

		wlc_phy_papd_cal_acphy(pi, numiter, core, start, yref, 63);

		MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonScalar, 8);
	}

	/* Write the LUT table with 0's for index idx=0 upto idx=start */
	for (j = 0; j < start; j++) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1, j, 32, &initvalue);
	}

	/* acradio papd_cal_cleanup */
	/* wlc_phy_papdcal_radio_cleanup_acphy(pi); */
	wlc_phy_papd_radio_cleanup_acphy_20691(pi);

	/* phy clean up */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_papd_phy_cleanup_acphy(pi, core);
	}

	/* Enable CRS */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	/* Enable BT */
	wlc_phy_btcx_override_disable(pi);

	/* acphy_papd on */
	FOREACH_CORE(pi, core) {
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 1);
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compCckEnb, 0);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papd_calEnb, 0);
	}

}
/* done with papd cal */

#define PAPD_MAX_PHASE_TH 45
void
wlc_phy_papd_phase_check_acphy(phy_info_t *pi)
{
	uint8 j;
	uint32 eps_table[ACPHY_PAPD_EPS_TBL_SIZE];
	int32 eps_re, eps_im;
	cint32 eps;
	int32 angle;
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_EPSILON0,
		ACPHY_PAPD_EPS_TBL_SIZE, 0, 32, eps_table);
	for (j = 0; j < ACPHY_PAPD_EPS_TBL_SIZE; j++) {
		wlc_phy_papd_decode_epsilon(eps_table[j], &eps_re, &eps_im);
		/* convert to S.16 */
		eps.i = ((eps_re + (1 << 12)) << 4);
		eps.q = (eps_im << 4);
		wlc_phy_inv_cordic(eps, &angle);
		if (ABS((angle >> 16)) > PAPD_MAX_PHASE_TH) {
			pi->phy_pacalstatus |= PHY_PACALSTATUS_AMPM_OVERFLOW;
			break;
		}
	}
}

/* Run PAPD calibration for ACPHY */
static void
wlc_phy_txpwr_papd_cal_run_acphy(phy_info_t *pi,
	uint8 tx_pre_cal_pwr_ctrl_state)
{
	phy_info_acphy_t *pi_acphy = NULL;
	bool suspend = TRUE, suspend_flag = FALSE;
	uint8 tx_pwr_ctrl_state;
	int8 tx_idx = 20, tx_idx_pwr[PHY_CORE_MAX] = {0};
	uint8 core;
	int16  tx_atten = 0, rx_atten = 0, i;
	uint32 eps_init_val = 0x0;
	int16 pgagain_offset = 0;
	int16 epsilonoffset = 0;
	uint32 scalar_table_ids[] = { ACPHY_TBL_ID_SCALAR0, ACPHY_TBL_ID_SCALAR1,
		ACPHY_TBL_ID_SCALAR2};
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};
#ifdef PAPD_GAIN_CTRL
	acphy_txgains_t tx_gains;
	txgain_setting_t txgain_settings;
	uint8 PAgain = 0xff;
	uint16 bbmult = 0x3f;
	uint8 Gainoverwrite = 0;
#endif /* PAPD_GAIN_CTRL */
#ifdef BCMDBG
	int16 epsregval;
#endif /* BCMDBG */
	int16 pgag = 0, eps_offset = 0;
	uint16 numIterLMS_papd = 0x10, startindex = 5, yrefindex = 5, stopindex = 63;
	acphy_txgains_t txgains[3];
	uint8 saved_pwr_idx[3] = {0, 0, 0};
	/* Local copy of phyrxchains before overwrite */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx */
	uint8 save_EnTx = 0;
	/* Force turn on flag */
	uint8 force_turnon = 0;
	pi_acphy = pi->u.pi_acphy;

	if (pi_acphy->acphy_papd_skip == 1)
		return;
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		PHY_XTAL_IS40M(pi)) {
		numIterLMS_papd = 0x20;
	} else if (CHSPEC_IS5G(pi->radio_chanspec)) {
		numIterLMS_papd = 0x10;
#ifdef PAPD_GAIN_CTRL
		bbmult = 0x30;
#endif /* PAPD_GAIN_CTRL */
	}
#ifdef PAPD_GAIN_CTRL
	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS2G(pi->radio_chanspec))
			numIterLMS_papd = (PHY_EPAPD(pi)) ? 0x20 : 0x10;
		else
			numIterLMS_papd = (PHY_EPAPD(pi)) ? 0x40 : 0x10;
	}
	tx_gains.txlpf = 0x0;
	tx_gains.txgm = 0xff;
	tx_gains.pga = 0xff;
	tx_gains.pad = 0xff;
	if (PHY_IPA(pi)) {
		Gainoverwrite = (CHSPEC_IS2G(pi->radio_chanspec)) ?
			pi->u.pi_acphy->srom_pagc2g_ovr :
			pi->u.pi_acphy->srom_pagc5g_ovr;
		PAgain = (CHSPEC_IS2G(pi->radio_chanspec)) ?
			pi->u.pi_acphy->srom_pagc2g :
			pi->u.pi_acphy->srom_pagc5g;
	}
	tx_gains.ipa = (Gainoverwrite == 0) ? 0xff : PAgain;
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
		tx_gains.txlpf = 0x0;
		tx_gains.txgm = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0x67 : 0x91;
		tx_gains.pga = 0xff;
		tx_gains.pad = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0xff : 0x7f;
		tx_gains.ipa = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0xc0 : 0x3;
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			startindex = 0;
			yrefindex = 0;
		}
	}
#endif /* PAPD_GAIN_CTRL */

	/* skip cal if phy is muted */
	if (PHY_MUTED(pi) || ISSIM_ENAB(pi->sh->sih))
		return;
	/* Force turn on radio chains if necessary */
	if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	}
	/* suspend mac if haven't done so */
	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend) {
		printf("MAC was not suspended before calling wlc_phy_txpwr_papd_cal_run_acphy!\n");
		suspend_flag = TRUE;
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
	}
	/* Disable BT as it affects PAPD CAL */
	wlc_btcx_override_enable(pi);
	/* Disable CRS */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* Turn off the txpowercontrol and save the txindex */
	tx_pwr_ctrl_state = pi->acphy_txpwrctrl;
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);

	/* Make it work for both 4335 and 4360 */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		saved_pwr_idx[core] = wlc_phy_txpwr_idx_cur_get_acphy(pi, core);
		/* initialize scaler table */
		wlc_phy_table_write_acphy(pi, scalar_table_ids[core], 64, 0, 32,
			acphy_papd_scaltbl);
	/* Fill up epsilon table with eps_init_val = 0 */
		for (i = 0; i < 64; i++) {
			wlc_phy_table_write_acphy(pi, epsilon_table_ids[core], 1, i, 32,
				&eps_init_val);
		}

		if (pi_acphy->cal_tempcomp) {
			pi_acphy->cal_tempcomp->papd_tempcomp[core] = 0;
			pi_acphy->cal_tempcomp->papd_ref_tssi[core] = 0;
		}
	}

	/* Call power control before radio/phy set up to not mess with papd setup */
	if (PHY_EPAPD(pi) && (pi->papdpwrctrl)) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			tx_idx_pwr[core] = wlc_phy_tone_pwrctrl(pi, 20, core);
		}
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	/* acphy_papd_cal_phy_setup */
	wlc_phy_papd_phy_setup_acphy(pi, core);

	/* 2069_papd_cal_setup */
	wlc_phy_papd_radio_loopback_setup_acphy(pi, tx_atten, rx_atten, core);
		pi->u.pi_acphy->txpwrindex[core] = 16;
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papdYrefOverride, 0x0);
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdInitYref, 0x1);
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdEpsilonInit, 0x0);
		MOD_PHYREG(pi, PapdCalCoreSel, papdCoreSel, core); /* Specify the core */
#ifdef PAPD_GAIN_CTRL
		gain_ctrl = 1;
		/* This is needed to put analytic cal, if enabled, in gain control mode */
		if (PHY_EPAPD(pi) && (pi->papdpwrctrl)) {
			if (tx_idx_pwr[core] != -1)
				tx_idx = tx_idx_pwr[core];
			wlc_phy_get_txgain_settings_by_index_acphy(
			        pi, &txgain_settings, tx_idx);
			papd_gainctrl_pga[core] =  (txgain_settings.rad_gain_mi >> 8) & 0xff;
			tx_gains.pga = papd_gainctrl_pga[core];
			wlc_phy_txpwr_by_index_acphy(pi, (1 << core), tx_idx);
		} else {
			papd_gainctrl_pga[core] = wlc_phy_papd_cal_gain_cntl_acphy(pi,
			        numIterLMS_papd, core, startindex, yrefindex, stopindex);
			tx_gains.pga = papd_gainctrl_pga[core];
			wlc_phy_write_tx_gain_acphy(pi, core, &tx_gains, &bbmult);
		}
		gain_ctrl = 0; /* Set analytic cal, if enabled, to normal mode */
#endif  /* PAPD_GAIN_CTRL */

		wlc_phy_papd_cal_acphy(pi, numIterLMS_papd, core, startindex, yrefindex, stopindex);

		for (i = 0; i < startindex; i++) {
			wlc_phy_table_write_acphy(pi, epsilon_table_ids[core], 1, i, 32,
				&eps_init_val);
		}

		wlc_phy_get_tx_gain_acphy(pi, core, &(txgains[core]));
		papd_gainctrl_pga[core] = txgains[core].pga;
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			pgag = txgains[core].pga;
			pgagain_offset = *(rfpwrlut_ptr + pgag);
			eps_offset = -4;

		} else {
			pgag = txgains[core].pga;
			pgagain_offset = *(rfpwrlut_ptr + pgag);
			eps_offset = 0;
		}

		/* papd_index_shift in tcl-- needs to be taken care of */
		epsilonoffset = -66 + pgagain_offset + eps_offset;

		MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonScalar, 8);
		if (tx_pre_cal_pwr_ctrl_state == PHY_TPC_HW_OFF) {
			MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonOffset,
				epsilonoffset);
		} else {
			MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonOffset, 0);
		}
#ifdef BCMDBG
		epsregval = READ_PHYREGFLDCEE(pi, EpsilonTableAdjust, core, epsilonOffset);
		PHY_PAPD((" ------------------ \n"));
		PHY_PAPD(("read epsilonTableAdjust In PAPD is %d\n", epsregval));
		PHY_PAPD((" ------------------ \n"));
#endif /* BCMDBG */

		/* save this value, in case some other pro re-init phyregs */
		pi_acphy->acphy_papd_epsilon_offset[core] = epsilonoffset;

		/* acradio papd_cal_cleanup */
		wlc_phy_papdcal_radio_cleanup_acphy(pi, core);

		/* acphy_papd_cal_phy_cleanup */
		wlc_phy_papd_phy_cleanup_acphy(pi, core);
		/* acphy_rfctrl_override txgain off all */
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, 0);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, 0);
		WRITE_PHYREGCE(pi, Dac_gain, core, 0);
		MOD_PHYREGCE(pi, RfctrlCoreLpfGain, core, lpf_bq2_gain, 0);

		MOD_PHYREGCE(pi, RfctrlOverrideGains, core, txgain, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq2_gain, 0);

		/* acphy_papd_stats-- Some debug related thing. Not done here */
		/* acphy_papd on {0} or {0 1 2} */
	}

	/* restore tx pwr index to original power index */
	/* wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF); */
	wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			pi_acphy->acphy_txpwr_idx_5G[core] = saved_pwr_idx[core];
		} else {
			pi_acphy->acphy_txpwr_idx_2G[core] = saved_pwr_idx[core];
		}
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 1);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papd_calEnb, 0);
	}
	wlc_phy_papd_set_rfpwrlut(pi);
	/* Disabling BTCX Override */
	wlc_phy_btcx_override_disable(pi);
	/* Enable CRS */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	/* If the mac was suspended from this function, enable it */
	if (suspend_flag)
		wlapi_enable_mac(pi->sh->physhim);

	/* Restore original rxchains */
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}

	/* Store reference TSSI for PAPD temperature compensation */
	if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		((RADIOREV(pi->pubpi.radiorev) == 0x2C && PHY_XTAL_IS40M(pi)) ||
		(RADIOREV(pi->pubpi.radiorev) == 0x29 && PHY_XTAL_IS37M4(pi)))) &&
		(pi_acphy->cal_tempcomp)) {
		wlc_phy_papd_tempcomp_acphy(pi, 0);
	}
}

/* ----- PAPD temperature compensation ----- */

/**
 * PAPD temperature compensation setup function
 */
static void wlc_phy_papd_tempcomp_setup_acphy(phy_info_t *pi,
                                              acphy_papdtempcomp_saved_vals_t **vals,
                                              txgain_setting_t *curr_gain)
{
	int16 avvmid_set_local[2] = {1, 145};
	uint8 core;
	acphy_papdtempcomp_coreregs_t *regs;
	if ((*vals = (acphy_papdtempcomp_saved_vals_t*)MALLOC(pi->sh->osh,
		sizeof(acphy_papdtempcomp_saved_vals_t))) == NULL) {
		PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
			pi->sh->unit, __FUNCTION__, MALLOCED(pi->sh->osh)));
		return;
	}
	(*vals)->core_count = 0;
	(*vals)->suspend = TRUE;
	(*vals)->suspend_flag = FALSE;

	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* suspend mac if haven't done so */
	(*vals)->suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!(*vals)->suspend) {
		(*vals)->suspend_flag = TRUE;
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
	}
	/* Disable BT as it affects PAPD CAL */
	wlc_btcx_override_enable(pi);

	/* Turn off the txpowercontrol and save the txindex */
	(*vals)->tx_pwr_ctrl_state = pi->txpwrctrl;
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);

	(*vals)->stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain[0], 0);
	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		curr_gain[core] = curr_gain[0];
		regs = &((*vals)->regs[(*vals)->core_count]);

		/* save phy/radio regs going to be touched */
		regs->RfctrlIntc = READ_PHYREGCE(pi, RfctrlIntc, core);
		regs->RfctrlOverrideRxPus = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
		regs->RfctrlCoreRxPu = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
		regs->RfctrlOverrideAuxTssi = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
		regs->RfctrlCoreAuxTssi1 = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
		regs->OVR3 = READ_RADIO_REGC(pi, RF, OVR3, core);
		regs->auxpga_cfg1 = READ_RADIO_REGC(pi, RF, AUXPGA_CFG1, core);
		regs->auxpga_vmid = READ_RADIO_REGC(pi, RF, AUXPGA_VMID, core);
		regs->iqcal_cfg1 = READ_RADIO_REGC(pi, RF, IQCAL_CFG1, core);
		regs->tx5g_tssi = READ_RADIO_REGC(pi, RF, TX5G_TSSI, core);
		regs->pa2g_tssi = READ_RADIO_REGC(pi, RF, PA2G_TSSI, core);
		regs->RfctrlOverrideTxPus = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
		regs->RfctrlCoreTxPus = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
		regs->PapdEnable = READ_PHYREGCE(pi, PapdEnable, core);
		regs->dacgain_save = READ_PHYREGCE(pi, Dac_gain, core);
		regs->txgain1_save = READ_PHYREGCE(pi, RfctrlCoreTXGAIN1, core);
		regs->txgain2_save = READ_PHYREGCE(pi, RfctrlCoreTXGAIN2, core);
		regs->bq2gain_save = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
		regs->overridegains_save = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
		regs->LPF_MAIN_CONTROLS = READ_RADIO_REGC(pi, RF, LPF_MAIN_CONTROLS, core);
		regs->OVR11 = READ_RADIO_REGC(pi, RF, GE16_OVR11, core);
		regs->core = core;

		/* set proper Av/Vmid */
		MOD_RADIO_REGC(pi, OVR3, core, ovr_auxpga_i_sel_gain, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_sel_gain, avvmid_set_local[0]);
		MOD_RADIO_REGC(pi, OVR3, core, ovr_afe_auxpga_i_sel_vmid, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_VMID, core, auxpga_i_sel_vmid, avvmid_set_local[1]);

		/* turn off lna and other unsed rxrf components */
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, 0x7CE0);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus,     core, 0x0);

		++((*vals)->core_count);

		/* Disable PAPD */
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);
	}

	ACPHY_ENABLE_STALL(pi, (*vals)->stall_val);

	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		wlc_phy_tssi_phy_setup_acphy(pi, 1); /* strong TSSI coupling */
	} else {
		wlc_phy_tssi_phy_setup_acphy(pi, 0); /* weak TSSI coupling */
	}
	wlc_phy_tssi_radio_setup_acphy(pi, pi->sh->hw_phyrxchain, 1);

	wlc_phy_init_adc_read(pi, &((*vals)->save_afePuCtrl), &((*vals)->save_gpio),
		&((*vals)->save_chipc), &((*vals)->fval2g_orig),
		&((*vals)->fval5g_orig), &((*vals)->fval2g),
		&((*vals)->fval5g), &((*vals)->stall_val),
		&((*vals)->save_gpioHiOutEn));
	wlc_phy_txcal_txgain_setup_acphy(pi, &curr_gain[0], &((*vals)->orig_gain[0]));
}

/**
 * PAPD temperature compensation cleanup function
 */
static void wlc_phy_papd_tempcomp_cleanup_acphy(phy_info_t *pi,
                                                acphy_papdtempcomp_saved_vals_t *vals)
{
	uint8 core;
	acphy_papdtempcomp_coreregs_t *regs;
	uint8 core_count = vals->core_count;
	txgain_setting_t foo_gain[PHY_CORE_MAX];

	/* Restore gain */
	wlc_phy_txcal_txgain_setup_acphy(pi, &(vals->orig_gain[0]), &foo_gain[0]);

	wlc_phy_restore_after_adc_read(pi, &(vals->save_afePuCtrl), &(vals->save_gpio),
		&(vals->save_chipc), &(vals->fval2g_orig),
		&(vals->fval5g_orig), &(vals->fval2g),
		&(vals->fval5g), &(vals->stall_val),
		&(vals->save_gpioHiOutEn));

	/* restore phy/radio regs */
	while (core_count > 0) {
		--core_count;
		core = vals->regs[core_count].core;
		regs = &(vals->regs[core_count]);

		write_radio_reg(pi, RF_2069_OVR3(core), regs->OVR3);
		write_radio_reg(pi, RF_2069_AUXPGA_CFG1(core), regs->auxpga_cfg1);
		write_radio_reg(pi, RF_2069_AUXPGA_VMID(core), regs->auxpga_vmid);
		write_radio_reg(pi, RF_2069_IQCAL_CFG1(core), regs->iqcal_cfg1);
		write_radio_reg(pi, RF_2069_TX5G_TSSI(core), regs->tx5g_tssi);
		write_radio_reg(pi, RF_2069_PA2G_TSSI(core), regs->pa2g_tssi);
		WRITE_PHYREGCE(pi, RfctrlIntc, core, regs->RfctrlIntc);
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, regs->RfctrlOverrideRxPus);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, regs->RfctrlCoreRxPu);
		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, regs->RfctrlOverrideAuxTssi);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, regs->RfctrlCoreAuxTssi1);

		if (PHY_IPA(pi)) {
			WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, regs->RfctrlOverrideTxPus);
			WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, regs->RfctrlCoreTxPus);
			WRITE_PHYREGCE(pi, PapdEnable, core, regs->PapdEnable);
		}

		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, regs->txgain1_save);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, regs->txgain2_save);
		WRITE_PHYREGCE(pi, Dac_gain, core, regs->dacgain_save);
		WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, regs->overridegains_save);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, regs->bq2gain_save);
		write_radio_reg(pi, RF_2069_LPF_MAIN_CONTROLS(core), regs->LPF_MAIN_CONTROLS);
		write_radio_reg(pi, RF_2069_GE16_OVR11(core), regs->OVR11);
	}

	/* enable crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	/* restore tx pwr index to original power index */
	wlc_phy_txpwrctrl_enable_acphy(pi, vals->tx_pwr_ctrl_state);
	/* Enable BT */
	wlc_phy_btcx_override_disable(pi);
	/* If the mac was suspended from this function, enable it */
	if (vals->suspend_flag)
		wlapi_enable_mac(pi->sh->physhim);
	MFREE(pi->sh->osh, vals, sizeof(acphy_papdtempcomp_saved_vals_t));
}

/**
 * PAPD temperature compensation main function.
 * PAPD temperature compensation is used instead of full PAPD calibration for low
 * latency requirements, where full calibration would take too much time.
 */
void wlc_phy_papd_tempcomp_acphy(phy_info_t *pi, uint8 mode)
{
	uint8  pga_tempg, pga_midg = 127;
	int16  delta_tssi, curr_tssi[PHY_CORE_MAX];
	txgain_setting_t curr_gain[PHY_CORE_MAX];
	uint8 gain_search[] = {64, 32, 16, 8, 4, 2};
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_cal_tempcomp_t *cal_tempcomp = pi_ac->cal_tempcomp;
	acphy_papdtempcomp_saved_vals_t *vals;
	uint8 core, i;
#ifdef PHY_CAL_TEMPCOMP_DBG
	int16  max_tssi[PHY_CORE_MAX], idle_tssi[PHY_CORE_MAX] = {0};
#endif // endif
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	wlc_phy_papd_tempcomp_setup_acphy(pi, &vals, &curr_gain[0]);
	if (!vals)
		return;
	if (mode == 0) {
		/* Mode 0 samples reference TSSI at PGA127. Use after full PAPD has run. */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_gpiosel_acphy(pi, 16+core, 1);
#ifdef PHY_CAL_TEMPCOMP_DBG
			/* Measure the MAX tone TSSI */
			curr_gain[core].bbmult = 64;
			wlc_phy_poll_samps_WAR_acphy(pi, max_tssi, TRUE, FALSE,
				&curr_gain[core], TRUE, FALSE, core, 0);
			/* Measure idle TSSI */
			wlc_phy_poll_samps_WAR_acphy(pi, idle_tssi, TRUE, TRUE,
				NULL, TRUE, FALSE, core, 0);
			PHY_CAL(("M0 A%d: TSSI IDLE: %d MAX: %d\n", core,
				(int)idle_tssi[core], (int)max_tssi[core]));
#endif // endif
			cal_tempcomp->papd_tempcomp[core] = 0;
			cal_tempcomp->papd_ref_tssi[core] = 0;

			/* Measure the tone TSSI */
			curr_gain[core].rad_gain_mi &= (~(0xFF << 8));
			curr_gain[core].rad_gain_mi |= (pga_midg << 8);
			curr_gain[core].bbmult = 64;
			wlc_phy_poll_samps_WAR_acphy(pi, cal_tempcomp->papd_ref_tssi, TRUE, FALSE,
				&curr_gain[core], TRUE, FALSE, core, 0);
			PHY_CAL(("M0 A%d: TSSI PGA127: %d\n", core,
				(int)(cal_tempcomp->papd_ref_tssi[core])));
		}
		cal_tempcomp->last_tempcomp_temp = pi->cal_info->last_cal_temp;
	} else {
		/* Mode 1 finds new PGA needed to achieve ref TSSI. Run on temperature changes. */
		wlc_phy_tx_tone_acphy(pi, 2000, 181, 0, 0, FALSE);
		OSL_DELAY(100);

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_gpiosel_acphy(pi, 16+core, 1);
			pga_tempg = pga_midg;
			curr_gain[core].rad_gain_mi &= (~(0xFF << 8));
			curr_gain[core].rad_gain_mi |= (pga_tempg << 8);
			curr_gain[core].bbmult = 64;
			/* Measure the initial tone TSSI */
			wlc_phy_poll_tssi_samps_acphy(pi, curr_tssi, &curr_gain[core], core);

			for (i = 0; i < sizeof(gain_search); i++) {
				delta_tssi =
					(curr_tssi[core] - (cal_tempcomp->papd_ref_tssi[core]));
				if ((delta_tssi <= 5) && (delta_tssi >= -5)) {
					PHY_CAL(("M1 A%d: compared %d to %d and decided to"
					" terminate with pga %u\n", core, (int)curr_tssi[core],
					(int)(cal_tempcomp->papd_ref_tssi[core]),
					(unsigned int)pga_tempg));
					break;
				} else if (delta_tssi < 0) {
					pga_tempg += gain_search[i];
				} else {
					pga_tempg -= gain_search[i];
				}
				PHY_CAL(("M1 A%d: compared %d to %d; decided to set pga to %u\n",
					core, (int)curr_tssi[core],
					(int)(cal_tempcomp->papd_ref_tssi[core]),
					(unsigned int)pga_tempg));

				curr_gain[core].rad_gain_mi &= (~(0xFF << 8));
				curr_gain[core].rad_gain_mi |= (pga_tempg << 8);
				curr_gain[core].bbmult = 64;

				/* Measure the tone TSSI */
				wlc_phy_poll_tssi_samps_acphy(pi, curr_tssi, &curr_gain[core],
					core);
				PHY_CAL(("M1 A%d: done iter %d ; new pga %u delivered tssi %d\n",
					core, i + 1, (unsigned int)pga_tempg,
					(int)curr_tssi[core]));
			}
			cal_tempcomp->papd_tempcomp[core] =
				(rfpwrlut_ptr[pga_tempg] - rfpwrlut_ptr[pga_midg]);
			PHY_CAL(("M1 A%d: PGA changed from 127 to %u (gaintbl delta %d)\n",
				core, (unsigned int)pga_tempg, cal_tempcomp->papd_tempcomp[core]));
		}
		wlc_phy_stopplayback_acphy(pi);
		wlc_phy_papd_set_rfpwrlut(pi);
	}
	wlc_phy_papd_tempcomp_cleanup_acphy(pi, vals);
}

/**
 * Trigger function for the PAPD temperature compensation.
 */
void wlc_phy_papd_tempcomp_trigger_acphy(phy_info_t *pi, int16 currtemp)
{
	int16 delta_temp_papd_tempcomp = 0;
	acphy_cal_tempcomp_t *cal_tempcomp;

	/* Check if PAPD tempcomp is enabled */
	if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		((RADIOREV(pi->pubpi.radiorev) == 0x2C && PHY_XTAL_IS40M(pi)) ||
		(RADIOREV(pi->pubpi.radiorev) == 0x29 && PHY_XTAL_IS37M4(pi)))) &&
		(pi->u.pi_acphy->cal_tempcomp)) {
		cal_tempcomp = pi->u.pi_acphy->cal_tempcomp;

		/* Check if PAPD tempcomp has to be done */
		delta_temp_papd_tempcomp =
			(currtemp > cal_tempcomp->last_tempcomp_temp)?
			currtemp - cal_tempcomp->last_tempcomp_temp :
			cal_tempcomp->last_tempcomp_temp - currtemp;

		PHY_CAL(("Cal tempcomp delta %d, threshold %d\n",
			delta_temp_papd_tempcomp,
			cal_tempcomp->papdtempcomp_tempdelta));

		/* Run the PAPD tempcomp if temp delta is sufficient */
		if (delta_temp_papd_tempcomp >=
				cal_tempcomp->papdtempcomp_tempdelta) {
			cal_tempcomp->last_tempcomp_temp = currtemp;
			PHY_CAL(("Running PAPD tempcomp.\n"));
			wlc_phy_papd_tempcomp_acphy(pi, 1);
		}
	}
}

static void wlc_phy_papd_set_rfpwrlut(phy_info_t *pi)
{
	int16 epsilonoffset, pga_gain;
#ifdef BCMDBG
	int16 epsregval;
#endif /* BCMDBG */
	uint8 idx, core = 0;
	txgain_setting_t txgain_settings;
	uint16 channel = 5180;
	int8 epscaldelta = 0, eps_offset = 0, delta = 0, tempcomp = 0;
	uint8 papdmode = pi->u.pi_acphy->papdmode;
	uint32 rfpwrlut_table_ids[] = { ACPHY_TBL_ID_RFPWRLUTS0,
		ACPHY_TBL_ID_RFPWRLUTS1, ACPHY_TBL_ID_RFPWRLUTS2};
	PHY_PAPD((" ------- In RFPWRLUT ------- \n"));

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Use temperature compensation eps offset, if available */
		if (ISACPHY(pi) && (pi->u.pi_acphy) && (pi->u.pi_acphy->cal_tempcomp)) {
			tempcomp = pi->u.pi_acphy->cal_tempcomp->papd_tempcomp[core];
		}
		if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			/* 4354A0 */
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				rfpwrlut_ptr = pga_gain_array_2g_4354;
				if ((RADIOREV(pi->pubpi.radiorev) == 0x27 ||
				     RADIOREV(pi->pubpi.radiorev) == 0x29 ||
				     RADIOREV(pi->pubpi.radiorev) == 0x28 ||
				     RADIOREV(pi->pubpi.radiorev) == 0x2C ||
				     RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
				    (PHY_XTAL_IS40M(pi))) {
					eps_offset = 24; /* 43569 */
				} else {
					eps_offset = 25;
				}
			} else {
				if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
				    RADIOREV(pi->pubpi.radiorev) == 0x28 &&
				    PHY_XTAL_IS40M(pi)) {
					/* 43566/43567/43569/43570 A0 */
					rfpwrlut_ptr = pga_gain_array_5g_435x_radiorev40;
					eps_offset = 3;
				} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
				           (RADIOREV(pi->pubpi.radiorev) == 0x2C ||
				           RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
				           PHY_XTAL_IS40M(pi)) {
					channel = CHSPEC_CHANNEL(pi->radio_chanspec);

					/* 43567/43570 A2 */
					if (CST4350_IFC_MODE(pi->sh->sih->chipst) ==
					    CST4350_IFC_MODE_PCIE) {
						rfpwrlut_ptr = pga_gain_array_5g_435x_radiorev40;
						if (CHSPEC_IS40(pi->radio_chanspec)) {
							eps_offset = 3;
						} else {
							eps_offset = 4;
						}
					} else {
						/* 43566/43569 A2 */
						rfpwrlut_ptr = pga_gain_array_5g_435x_radiorev44;
						if (CHSPEC_IS80(pi->radio_chanspec)) {
							if (core == 0) {
								eps_offset = 4;
							} else {
								eps_offset = 5;
							}
						} else {
							if (core == 0) {
								eps_offset = 3;
							} else {
								eps_offset = 4;
							}
						}
					}
				} else {
					rfpwrlut_ptr = pga_gain_array_5g_4354;
					eps_offset = 3;
				}
			}
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
				/* 4350EPAPD */
				if (CHSPEC_IS2G(pi->radio_chanspec)) {
					rfpwrlut_ptr = pga_gain_array_2g_epapd[core];
					if (core == 0)
						eps_offset = -3;
					else
						eps_offset = -6;
				} else {
					rfpwrlut_ptr = pga_gain_array_5g_epapd_0;
					eps_offset = 3;
				}
			}
			eps_offset += wlc_phy_set_eps_from_nvram(pi, core);
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			/* 4335-4339 */
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				rfpwrlut_ptr  =  pga_gain_array_2g;
				if (pi->sh->chippkg == BCM4335_FCBGA_PKG_ID) {
					delta = 1;
					eps_offset = -3;
				} else {
					if ((papdmode == PAPD_ANALYTIC) ||
						(papdmode == PAPD_ANALYTIC_WO_YREF)) {
						eps_offset = -3;
					} else {
						eps_offset = 0;
					}
				}
			} else {
				channel = CHSPEC_CHANNEL(pi->radio_chanspec);
				channel = 5000 + 5 * channel;

				if (channel >= 5180 && channel <= 5320) {
				    rfpwrlut_ptr  =  pga_gain_array_5g_0;
				} else if (channel >= 5500 && channel <= 5620) {
				    rfpwrlut_ptr  =  pga_gain_array_5g_1;
				} else if (channel >= 5630 && channel <= 5700) {
				    rfpwrlut_ptr  =  pga_gain_array_5g_2;
				} else if (channel >= 5710 && channel <= 5825) {
				    rfpwrlut_ptr  =  pga_gain_array_5g_3;
				}

				if (pi->sh->chippkg == BCM4335_FCBGA_PKG_ID) {
					if (CHSPEC_IS80(pi->radio_chanspec)) {
						eps_offset = 0;
						if (channel >= 5710 && channel <= 5825)
							eps_offset = -1;
					} else {
						eps_offset = -1;
					}
				} else {
					if ((papdmode == PAPD_ANALYTIC) ||
						(papdmode == PAPD_ANALYTIC_WO_YREF)) {
						eps_offset = -5;
						if (channel >= 5710 && channel <= 5825)
							eps_offset = -6;
					} else {
						if (CHSPEC_IS80(pi->radio_chanspec)) {
							eps_offset = -1;
							if (channel == 5775)
								eps_offset = -2;
						} else {
							eps_offset = -2;
						}
					}
				}
			}
		}
		for (idx = 0; idx < 128; idx++)
		{
			wlc_phy_get_txgain_settings_by_index_acphy(pi, &txgain_settings, idx);
			pga_gain =  (txgain_settings.rad_gain_mi >> 8) & 0xff;
			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					epscaldelta = (int8)*(rfpwrlut_ptr+papd_gainctrl_pga[core])
						- (int8)*(rfpwrlut_ptr + 133);
				} else {
					epscaldelta = (int8)*(rfpwrlut_ptr+papd_gainctrl_pga[core])
						- (int8)*(rfpwrlut_ptr + 207);
				}
			} else {
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					epscaldelta = (int8)*(rfpwrlut_ptr+papd_gainctrl_pga[core])
						- (int8)*(rfpwrlut_ptr + 167);
				} else {
					epscaldelta = (int8)*(rfpwrlut_ptr+papd_gainctrl_pga[core])
						- (int8)*(rfpwrlut_ptr + 71);
				}
			}
			epsilonoffset = (-66 + (int8)*(rfpwrlut_ptr + pga_gain)
				- epscaldelta + eps_offset + delta - tempcomp) << 1;

			if (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
			/* 4354A0 */
			/* For ACPR margin http://wlan-rb.sj.broadcom.com/r/19261/ */
				if (CHSPEC_IS2G(pi->radio_chanspec) &&
				 (pi->u.pi_acphy->srom_epsdelta2g[core][1] >= -1)) {
					epsilonoffset = wlc_phy_papd_adjust_rfpwrlut(pi,
					 epsilonoffset, core, idx);
				}
			}
			wlc_phy_table_write_acphy(pi, rfpwrlut_table_ids[core], 1, idx,
				16, &epsilonoffset);
		}
		MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonOffset, 0);
#ifdef BCMDBG
		epsregval = READ_PHYREGFLDCEE(pi, EpsilonTableAdjust, core, epsilonOffset);
		PHY_PAPD((" ------------------ \n"));
		PHY_PAPD(("read epsilonTableAdjust In RF PowerLUT is %d\n", epsregval));
		PHY_PAPD((" ------------------ \n"));
#endif /* BCMDBG */
	}
}
static int8 wlc_phy_set_eps_from_nvram(phy_info_t *pi, uint8 core)
{
/* adjusting epsilon offset from NVRAM */
	uint16 channel = 5180;
	int8 eps_offset = 0;
	channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		eps_offset += (core == 0) ? pi->pacalshift2ga0 :
			pi->pacalshift2ga1;
	} else {
		channel = 5000 + 5 * channel;
		/* pacalshift5gaX=lo,mi,hi,x1,lo,mi,hi,x1,lo,mi,hi,x1  */
		/*                |    20mhz |   40mhz   |   80mhz   | */
		if (channel >= 5180 && channel <= 5320) {
			if (CHSPEC_IS20(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[0] :
					pi->pacalshift5ga1[0];
			else if (CHSPEC_IS40(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[4] :
					pi->pacalshift5ga1[4];
			else if (CHSPEC_IS80(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[8] :
					pi->pacalshift5ga1[8];
		} else if (channel >= 5500 && channel <= 5620) {
			if (CHSPEC_IS20(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[1] :
					pi->pacalshift5ga1[1];
			else if (CHSPEC_IS40(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[5] :
					pi->pacalshift5ga1[5];
			else if (CHSPEC_IS80(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[9] :
					pi->pacalshift5ga1[9];
		} else if (channel >= 5630 && channel <= 5700) {
			if (CHSPEC_IS20(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[2] :
					pi->pacalshift5ga1[2];
			else if (CHSPEC_IS40(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[6] :
					pi->pacalshift5ga1[6];
			else if (CHSPEC_IS80(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[10] :
					pi->pacalshift5ga1[10];
		} else if (channel >= 5710 && channel <= 5825) {
			if (CHSPEC_IS20(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[3] :
					pi->pacalshift5ga1[3];
			else if (CHSPEC_IS40(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[7] :
					pi->pacalshift5ga1[7];
			else if (CHSPEC_IS80(pi->radio_chanspec))
				eps_offset += (core == 0) ?
					pi->pacalshift5ga0[11] :
					pi->pacalshift5ga1[11];
		}
	}
return eps_offset;
}

static void wlc_phy_papd_set_rfpwrlut_tiny(phy_info_t *pi)
{
	int16 radiogainqdb;
	uint8 idx;
	uint16 txgain[1], bbmult;
	int16 temp, temp1, temp2, qQ, qQ1, qQ2, shift;
	uint8 scale_factor = 1;
	int8 papd_rf_pwr_scale = 32; /* Q5 format */
	int32 val = 0;

	if (CHSPEC_IS2G(pi->radio_chanspec) && (pi->parfps2g != -1)) {
		papd_rf_pwr_scale = pi->parfps2g;
	} else if (CHSPEC_IS5G(pi->radio_chanspec) && (pi->parfps5g != -1)) {
		papd_rf_pwr_scale = pi->parfps5g;
	}

	/* acphy_beDeaf??? */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	for (idx = 0; idx < 128; idx++)
	{
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1, idx, 48, &txgain);
		bbmult = (txgain[0] & 0xff);

		qm_log10((int32)(bbmult), 0, &temp1, &qQ1);
		qm_log10((int32)(1<<6), 0, &temp2, &qQ2);

		if (qQ1 < qQ2) {
			temp2 = qm_shr16(temp2, qQ2-qQ1);
			qQ = qQ1;
		} else {
			temp1 = qm_shr16(temp1, qQ1-qQ2);
			qQ = qQ2;
		}
		temp = qm_sub16(temp1, temp2);

		if (qQ >= 4)
			shift = qQ-4;
		else
			shift = 4-qQ;

		val = ((((idx*papd_rf_pwr_scale/32) << shift) + (5*temp) +
			(1<<(scale_factor+shift-3)))>>(scale_factor+shift-2));

		radiogainqdb = -(val)/2;

		/* adding 10us of delay as table_write is throwing assert */
		OSL_DELAY(10);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFPWRLUTS0, 1, idx,
			16, &radiogainqdb);
	}

	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	wlapi_enable_mac(pi->sh->physhim);
}
/* end tiny papd rfpwrlut */

static int16
wlc_phy_papd_adjust_rfpwrlut(phy_info_t *pi, int16 epsilonoffset, uint8 core, uint8 idx)
{
	int16 epsilon_new;
	int16 *eps_array = (pi->u.pi_acphy->srom_epsdelta2g[core]);
	bool bypass = (pi->u.pi_acphy->srom_epsdelta2g[core][1] <= -1) ? 1:0;
	int16 start_idx = eps_array[1] +1;
	int16 first_idxs_offs = eps_array[2];
	int16 fix_offs = eps_array[0];

	if (bypass) {
		return epsilonoffset;
	} else {
		epsilon_new = epsilonoffset + fix_offs;
		if (idx < start_idx) {
			epsilon_new += first_idxs_offs;
		} else if (idx < start_idx +(ACPHY_SIZE_EPSDELTA_ARRAY-3)) {
			epsilon_new += eps_array[3 + (idx - start_idx)];
		}
		if (epsilon_new > 255) {
			epsilon_new = 255;
		} else if (epsilon_new < -256) {
			epsilon_new = -256;
		}
	}
	/*
	OSL_DELAY(100000);
	printf("idx =%d, epsilon old =%d ,epsilon new =%d \n", idx, epsilonoffset, epsilon_new);
	*/
	return epsilon_new;
}

static uint8
wlc_phy_txpwr_idx_cur_get_acphy(phy_info_t *pi, uint8 core)
{
	uint16 pwrCtrlStatus = READ_PHYREGCE(pi, TxPwrCtrlStatus_path, core);
	uint8 pwrIndex = 128;

	if (pwrCtrlStatus & 0xF000) {
		pwrIndex = ((pwrCtrlStatus & 0x07F0)>>8);
	}
	return (pwrIndex);
}

/* Dump the PAPD LUT (eps table) to PHY_CAL trace */
#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP) || \
	defined(WLTEST)
static void
wlc_phy_papd_dump_eps_trace_acphy(phy_info_t *pi, struct bcmstrbuf *b)
{
	uint8 core, j;
	uint32 eps_table[ACPHY_PAPD_EPS_TBL_SIZE];
	int32 eps_re, eps_im;
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};

	FOREACH_CORE(pi, core) {
		wlc_phy_table_read_acphy(pi, epsilon_table_ids[core],
			ACPHY_PAPD_EPS_TBL_SIZE, 0, 32, eps_table);

		PHY_CAL(("core %d\n", core));
		bcm_bprintf(b, "  PAPD Epsilon Table  Real Image CORE %d \n", core);
		for (j = 0; j < ACPHY_PAPD_EPS_TBL_SIZE; j++) {
			wlc_phy_papd_decode_epsilon(eps_table[j], &eps_re, &eps_im);
			PHY_CAL(("{%d %d} ", eps_re, eps_im));
			bcm_bprintf(b, "{%d %d}\n ", eps_re, eps_im);
		}
		PHY_CAL(("\n"));
	}
	PHY_CAL(("\n"));
}
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLEST) */

void
wlc_phy_papd_cal_acphy(phy_info_t *pi, uint16 num_iter, uint8 core, uint16 startindex,
	uint16 yrefindex, uint16 stopindex)
{
	bool calmode;
	uint16 m[3] = {0, 0, 0};
	int8 bbmult, k;
	int16 dac_rf_offset;
	uint32 scalartblval, papdmult0, epsilonscalartemp;
	int16 epsilonoffsettemp;
	int16 cal_tone_mag = 186;
	int16 temp, temp1, qQ1, lut_shift;
	uint8 papdmode = pi->u.pi_acphy->papdmode;
	int8 coremask = 1 << core;
	uint8 edpdcalset = pi->u.pi_acphy->srom_edpdcalset;
	uint8 sub_band;
	int8 lut_shift20[4] = {-2, -2, -3, -3};
	int8 lut_shift40[4] = {-2, -2, -3, -3};
	int8 lut_shift80[4] = {1, 1, -2, -2};
	PHY_PAPD(("\n\nPAPD Main Cal .. "));

	sub_band = wlc_phy_get_chan_freq_range_acphy(pi, 0) - 1;

	if (TINY_RADIO(pi)) {
		calmode = 1; /* Run single index of PAPD table only */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
				bbmult = 32;
			} else {
				bbmult = 64;
			}
		} else {
			if (CHSPEC_IS80(pi->radio_chanspec)) {
				bbmult = 65;
			} else {
				bbmult = 90;
			}
		}
		if (PHY_EPAPD(pi)) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				bbmult = 100;
			} else {
				bbmult = 75;
			}
		}
		if (CHSPEC_IS2G(pi->radio_chanspec) && (pi->papdbbmult2g != -1)) {
			bbmult = pi->papdbbmult2g;
		} else if (CHSPEC_IS5G(pi->radio_chanspec) && (pi->papdbbmult5g != -1)) {
			bbmult = pi->papdbbmult5g;
		}
		if (pi->pacalmode != -1) {
			calmode = pi->pacalmode;
		}
	} else {
		calmode = 0;  /* Run the PAPD automatic machine on all indices */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			bbmult = 0x3f;
			if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
				bbmult = 0x32;
			}
			/* 43569 / 43570 */
			if ((RADIOREV(pi->pubpi.radiorev) == 0x27 ||
			  RADIOREV(pi->pubpi.radiorev) == 0x29 ||
			  RADIOREV(pi->pubpi.radiorev) == 0x28 ||
			  RADIOREV(pi->pubpi.radiorev) == 0x2C ||
			  RADIOREV(pi->pubpi.radiorev) == 0x2E) &&
			  (PHY_XTAL_IS40M(pi))) {
				bbmult = 0x30;
			}
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
				bbmult = (core == 0) ? 100 : 110;
			}
		} else
			bbmult = 0x30;
	}
	switch (core) {
		case 0:
			m[0] = bbmult;
			break;
		case 1:
			m[1] = bbmult;
			break;
		case 2:
			m[2] = bbmult;
			break;
	}
	if ((papdmode == PAPD_ANALYTIC) || (papdmode == PAPD_ANALYTIC_WO_YREF)) {
	        bool   corr_sat = 0;
		uint8  corr_shift = 0x4;
		uint16 index;
		int32  mag_corr_papd_index;
		uint32 dst[64];
		uint32 dst_tmp = 0;
		uint32 dst_limit = 0;
		uint16 next_index_interp = startindex;
		uint16 next_index_write = startindex;
		uint16 next_index_interp_init = startindex;
		int16  abs_c, eps_re_curr = 0, eps_im_curr = 0,
		       eps_re_prev = 0, eps_im_prev = 0,
		       eps_re_interp = 0, eps_im_interp = 0;
		int16  corr_papd_index_I = 0, corr_papd_index_Q = 0,
		       corr_papd_index_I_yref = 0, corr_papd_index_Q_yref = 0;
		uint16 vin_prev = 0, vin_curr = 0, vin_p[64];
		/* When startindex == yrefindex, the hw cal for the startindex takes long time */
		if (startindex == yrefindex)
		        startindex ++;
		/* dst_limit to reduce variation on AMAM/AMPM for last few entries */
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
			        dst_limit = 54358000; /* 1.8 */
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				dst_limit = 54358000; /* 1.8 */
			} else {
				dst_limit = 42928704; /* 1.6 */
			}
		} else {
			dst_limit = 54358000; /* 1.8 */
		}
		for (index = 0; index <= 63; index++) {
			vin_p[index] = (uint16)(acphy_papd_scaltbl[index] & 0xffff);
		}
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 1);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papd_calEnb, 1);
		MOD_PHYREG(pi, PapdEpsilonUpdateIterations, epsilonUpdateIterations, 1);
		MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x80);
		MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x140);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, corr_shift);
		MOD_PHYREG(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x3ff);
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdInitYref, 0x1);
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdEpsilonInit, 0x0);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_I, 0xa);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_Q, 0xa);
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdYrefAddr, yrefindex);
		MOD_PHYREGCE(pi, EpsilonOverrideI_, core, epsilonFixedPoint, 0x1);
		wlc_phy_ipa_set_bbmult_acphy(pi, &m[0], &m[1], &m[2], coremask);
		/* Looping over yrefindex + (startindex -> stopindex); */
		if (gain_ctrl == 0) {
			wlc_phy_tx_tone_acphy_papd(pi, 2000, 186, 0, 0, FALSE);
		}
		for (index = startindex; index <= stopindex+1; corr_sat? index : index++) {
			if (corr_sat) {
				MOD_PHYREGCEE(pi, PapdCalShifts, core,
				        papdCorrShift, ++corr_shift);
			}

			if ((index == yrefindex) || ((index >= startindex) &&
			        (index <= stopindex))) {
				MOD_PHYREG(pi, PapdCalAddress, papdStartAddr, index);
				MOD_PHYREG(pi, PapdCalAddress, papdEndAddr, index);
				MOD_PHYREG(pi, PapdCalYrefEpsilon, papdInitYref,
				(papdmode == PAPD_ANALYTIC_WO_YREF) ?
				((index == startindex) ? 0x1 : 0x0) : 0x1);
				/*
				printf("PAPD_ANALYTIC_WO_YREF= %d,YREF_INIT=%d \n",
				papdmode, (papdmode == PAPD_ANALYTIC_WO_YREF)
				? ((index == startindex) ? 0x1 : 0x0) : 0x1);
				*/
				WRITE_PHYREG(pi, papdCalCorrDebugAddr, index);
				MOD_PHYREG(pi, PapdCalCoreSel, papdCoreSel, core);
				MOD_PHYREG(pi, PapdCalStart, papdStart, 1);
			}

			if (((yrefindex == startindex) && (index > startindex+1)) ||
			    ((yrefindex != startindex) && (index > startindex))) {
				/* 1+eps = c = Yref/Y = Yref*conj(Y)/abs(Y)^2 */
				mag_corr_papd_index =
					(int32)corr_papd_index_I*
					(int32)corr_papd_index_I +
					(int32)corr_papd_index_Q*
					(int32)corr_papd_index_Q;
				eps_re_prev = eps_re_curr;
				eps_im_prev = eps_im_curr;
				if (mag_corr_papd_index >> 12) {
					eps_re_curr = (((int32)corr_papd_index_I*
						(int32)corr_papd_index_I_yref +
						(int32)corr_papd_index_Q*
						(int32)corr_papd_index_Q_yref) /
						(mag_corr_papd_index >> 12)) - 4096;
					eps_im_curr = ((int32)corr_papd_index_Q*
						(int32)corr_papd_index_I_yref -
						(int32)corr_papd_index_I*
						(int32)corr_papd_index_Q_yref) /
						(mag_corr_papd_index >> 12);
				} else {
					eps_re_curr = 0;
					eps_im_curr = 0;
				}
				abs_c = (uint16)wlc_phy_sqrt_int(
					        ((int32)4096 + (int32)eps_re_curr)*
					        ((int32)4096 + (int32)eps_re_curr) +
					        ((int32)eps_im_curr*(int32)eps_im_curr));
				vin_prev = vin_curr;
				if (abs_c) {
					vin_curr = (uint16)(((uint32)vin_p[index-1]<<12)/abs_c);
				} else {
					vin_curr = vin_p[index-1];
				}
				eps_re_curr = (eps_re_curr > 4095) ? 4095 :
					((eps_re_curr < -4096) ? -4096: eps_re_curr);
				eps_im_curr = (eps_im_curr > 4095) ? 4095 :
					((eps_im_curr < -4096) ? -4096: eps_im_curr);
			}
			if (gain_ctrl == 0) {
				/* computing the first index to interpolate for based on
				 * the first vin computed
				 */
				if (((yrefindex != startindex) && (index == startindex+1)) ||
				    ((yrefindex == startindex) && (index == startindex+2))) {
					while ((next_index_interp_init <= 63) &&
					       (vin_curr > vin_p[next_index_interp_init])) {
						dst[next_index_interp_init++] = 0;
					}
					next_index_interp = next_index_interp_init;
					next_index_write = next_index_interp_init;
				}
				while ((next_index_interp <= 63) &&
				       (index > startindex+1) &&
				       (vin_curr >  vin_p[next_index_interp]) &&
				       (vin_prev <= vin_p[next_index_interp]) &&
				       (vin_curr != vin_prev)) {
					eps_re_interp =
						(int16)(((int32)eps_re_curr*(int32)
							 (vin_p[next_index_interp] - vin_prev) +
							 (int32)eps_re_prev*(int32)
							 (vin_curr - vin_p[next_index_interp]))/
							 (int16)(vin_curr - vin_prev));
					eps_im_interp =
						(int16)(((int32)eps_im_curr*(int32)
							 (vin_p[next_index_interp] - vin_prev) +
							 (int32)eps_im_prev*(int32)
							 (vin_curr - vin_p[next_index_interp]))/
							 (int16)(vin_curr - vin_prev));
					dst[next_index_interp] =
						(uint32)((((int32)eps_im_interp & 0x1fff) << 13) |
						((int32)eps_re_interp & 0x1fff));
					next_index_interp++;
				}
				while ((next_index_write < index) &&
				       (next_index_write < next_index_interp) &&
				       (next_index_write <= 63)) {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1,
					        next_index_write, 32, &dst[next_index_write]);
					next_index_write++;
				}
			}
			if (index <= stopindex) {
				SPINWAIT(READ_PHYREG(pi, PapdCalStart), ACPHY_SPINWAIT_PAPDCAL);
				ASSERT(!(READ_PHYREG(pi, PapdCalStart) & 1));
				if (READ_PHYREG(pi, PapdCalStart) & 1)
					pi->phy_pacalstatus |= PHY_PACALSTATUS_CAL_TIMEOUT;
				corr_papd_index_I = READ_PHYREG(pi, papdCalFirstCorr_I0);
				corr_papd_index_Q = READ_PHYREG(pi, papdCalFirstCorr_Q0);
				corr_papd_index_I_yref = READ_PHYREG(pi, PapdCalYref_I0);
				corr_papd_index_Q_yref = READ_PHYREG(pi, PapdCalYref_Q0);
			}
			corr_sat = ((index == startindex) &&
			        ((ABS(corr_papd_index_I_yref) > 32000) ||
				(ABS(corr_papd_index_Q_yref) > 32000)));
		}
		if (gain_ctrl == 0) {
			wlc_phy_stopplayback_acphy(pi);
		}
		/* To cover gctrl only for (the case where startindex <
		 * stopindex is already covered)
		 */
		if (gain_ctrl == 1) {
			dst[stopindex] =
				(uint32)((((int32)eps_im_curr & 0x1fff) << 13) |
				((int32)eps_re_curr & 0x1fff));
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1,
			        stopindex, 32, &dst[stopindex]);
		} else {
			if ((next_index_interp_init > startindex) &&
			    (next_index_interp_init <= 63)) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0,
					next_index_interp_init - startindex,
					startindex, 32, &dst[startindex]);
			}
			/* Fill remaining indices with last result */
			for (index = next_index_interp; index <= stopindex; index++) {
				dst_tmp =
					(uint32)((((int32)eps_im_interp & 0x1fff) << 13) |
					((int32)eps_re_interp & 0x1fff));
				if ((uint32)(((int32)4096 + (int32)eps_re_interp)*
				        ((int32)4096 + (int32)eps_re_interp) +
				        ((int32)eps_im_interp*(int32)eps_im_interp)) > dst_limit) {
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1,
					        next_index_write - 2, 32, &dst[index]);
				} else {
					dst[index] = dst_tmp;
				}
			}
			if (stopindex >= next_index_write) {
				if ((uint32)(((int32)4096 + (int32)eps_re_interp)*
				        ((int32)4096 + (int32)eps_re_interp) +
				        ((int32)eps_im_interp*(int32)eps_im_interp)) > dst_limit) {
					wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_EPSILON0, 1,
					        next_index_write - 2, 32, &dst[next_index_write-1]);
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0,
						stopindex-next_index_write+2, next_index_write-1,
						32, &dst[next_index_write-1]);
				} else {
					wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0,
						stopindex-next_index_write+1, next_index_write,
						32, &dst[next_index_write]);
				}
			}
			for (index = 0; index < startindex; index++) {
				dst[index] = 0x0;
			}
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0,
				startindex, 0, 32, dst);
		}
		if (gain_ctrl == 0) {
			wlc_phy_papd_smooth_acphy(pi, 0, 5, 0, 32);
		}
	} else {
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 1);
		MOD_PHYREGCEE(pi, PapdCalShifts, core, papd_calEnb, 1);
		if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			if (core == 0) {
				MOD_PHYREGCEE(pi, PapdEnable, 1, papd_compEnb, 0);
				MOD_PHYREGCEE(pi, PapdCalShifts, 1, papd_calEnb, 0);
			} else if (core == 1) {
				MOD_PHYREGCEE(pi, PapdEnable, 0, papd_compEnb, 0);
				MOD_PHYREGCEE(pi, PapdCalShifts, 0, papd_calEnb, 0);
			}
		}
		if (TINY_RADIO(pi)) {
			if ((CHSPEC_IS80(pi->radio_chanspec)) && (PHY_EPAPD(pi))) {
				ACPHY_REG_LIST_START
				    MOD_PHYREG_ENTRY(pi, PapdEpsilonUpdateIterations,
				        epsilonUpdateIterations, 256)
				    MOD_PHYREG_ENTRY(pi, PapdCalSettle, papd_calSettleTime, 0x80)
				    MOD_PHYREG_ENTRY(pi, PapdCalCorrelate, papd_calCorrTime, 0x100)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdCorrShift0, 0x7)
				    MOD_PHYREG_ENTRY(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x0)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdLambda_I0, 0x9)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdLambda_Q0, 0x9)
				ACPHY_REG_LIST_EXECUTE(pi);
			} else {
				MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
				        epsilonUpdateIterations, num_iter);
				ACPHY_REG_LIST_START
				    MOD_PHYREG_ENTRY(pi, PapdCalSettle, papd_calSettleTime, 0x80)
				    MOD_PHYREG_ENTRY(pi, PapdCalCorrelate, papd_calCorrTime, 0x40)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdCorrShift0, 0x4)
				    MOD_PHYREG_ENTRY(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x0)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdLambda_I0, 0xa)
				    MOD_PHYREG_ENTRY(pi, PapdCalShifts0, papdLambda_Q0, 0xa)
				ACPHY_REG_LIST_EXECUTE(pi);
				if ((pi->pacalopt == 1) || (pi->pacalopt == 2)) {
					MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x100);
					MOD_PHYREG(pi, PapdCalShifts0, papdCorrShift0, 0x7);
				}
			}
		} else {
			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				/* For One cores */
				MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
				        epsilonUpdateIterations, num_iter);
				/* setup LMS convergence related params */
				if (CHSPEC_IS80(pi->radio_chanspec)) {
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x40);
				} else {
				if (ACMINORREV_2(pi->pubpi.phy_rev) && PHY_XTAL_IS40M(pi))
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x80);
				else
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x20);
				}
				MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x40);
				MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, 0x4);

				if (ACMINORREV_2(pi->pubpi.phy_rev) && PHY_XTAL_IS40M(pi) &&
					CHSPEC_IS2G(pi->radio_chanspec) &&
					CHSPEC_IS40(pi->radio_chanspec)) {
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x40);
					MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x80);
					MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, 0x5);
				}

				MOD_PHYREG(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x0);
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_I, 0x8);
					MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_Q, 0x8);
				} else {
					uint8 var = (ACMINORREV_2(pi->pubpi.phy_rev) &&
						PHY_XTAL_IS40M(pi))?(0xa):(0x9);

					MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_I, var);
					MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_Q, var);
				}
			} else if (ACMAJORREV_2(pi->pubpi.phy_rev) ||
			           ACMAJORREV_5(pi->pubpi.phy_rev)) {
				/* For 4350 */
				MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
				        epsilonUpdateIterations, num_iter);
				/* setup LMS convergence related params */
				if (CHSPEC_IS80(pi->radio_chanspec)) {
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x80);
					MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x100);
				} else if (CHSPEC_IS40(pi->radio_chanspec)) {
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x40);
					MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x80);
				} else {
					MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x20);
					MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x40);
				}
				MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, 0x4);
				MOD_PHYREG(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x0);
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					if (PHY_EPAPD(pi)) {
						if (edpdcalset == 2) {
							/* For MSC 5G FEM */
							if ((CHSPEC_IS20(pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x20);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x100);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x6);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0x8);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0x8);
							} else if ((CHSPEC_IS40
		                               (pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x20);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x100);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x6);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0x8);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0x8);
							} else {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x80);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x100);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x4);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0xa);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0xa);
							}
						} else if (edpdcalset == 1) {
							/* For Triquint 5G FEM */
							if ((CHSPEC_IS20(pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x20);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x40);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x4);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0xa);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0xa);
							} else if ((CHSPEC_IS40
		                               (pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x40);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x80);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x5);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0xa);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0xa);
							} else {
				                MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
				                        epsilonUpdateIterations, 0x80);
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x40);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x80);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdCorrShift, 0x7);
								MOD_PHYREG(pi, PapdIpaOffCorr,
									papd_calIpaOffCorr, 0x40);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_I, 0x9);
								MOD_PHYREGCEE(pi, PapdCalShifts,
									core, papdLambda_Q, 0x9);
							}
						} else if (edpdcalset == 0) {
							/* For Skyworks 5G FEM */
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdCorrShift, 0x4);
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_I, 0x8);
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_Q, 0x8);
							if ((CHSPEC_IS20(pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x20);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x40);
							} else if ((CHSPEC_IS40
		                               (pi->radio_chanspec))) {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x40);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x80);
							} else {
								MOD_PHYREG(pi, PapdCalSettle,
									papd_calSettleTime, 0x80);
								MOD_PHYREG(pi, PapdCalCorrelate,
									papd_calCorrTime, 0x100);
							}
						}
					} else {
						MOD_PHYREGCEE(pi, PapdCalShifts, core,
						        papdLambda_I, 0x7);
						MOD_PHYREGCEE(pi, PapdCalShifts, core,
							papdLambda_Q, 0x7);
					}
				} else {
					if (PHY_EPAPD(pi)) {
						MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
							epsilonUpdateIterations, num_iter);
						MOD_PHYREG(pi, PapdCalSettle,
							papd_calSettleTime, 0x80);
						MOD_PHYREG(pi, PapdCalCorrelate,
							papd_calCorrTime, 0x40);
						MOD_PHYREGCEE(pi, PapdCalShifts, core,
							papdCorrShift, 0x4);
						MOD_PHYREG(pi, PapdIpaOffCorr,
							papd_calIpaOffCorr, 0x0);
						MOD_PHYREGCEE(pi, PapdCalShifts, core,
							papdLambda_I, 0x8);
						MOD_PHYREGCEE(pi, PapdCalShifts, core,
							papdLambda_Q, 0x8);
					} else {
						if (PHY_IPA(pi) &&
						    !ACMAJORREV_5(pi->pubpi.phy_rev)) {
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_I, 0x8);
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_Q, 0x8);
						} else {
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_I, 0x9);
							MOD_PHYREGCEE(pi, PapdCalShifts, core,
								papdLambda_Q, 0x9);
					    }
					}
				}
			} else {
				MOD_PHYREG(pi, PapdEpsilonUpdateIterations,
					epsilonUpdateIterations, num_iter);
				MOD_PHYREG(pi, PapdCalSettle, papd_calSettleTime, 0x80);
				MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x40);
				MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, 0x4);
				MOD_PHYREG(pi, PapdIpaOffCorr, papd_calIpaOffCorr, 0x0);
				MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_I, 0xa);
				MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_Q, 0xa);
			}
		}
		MOD_PHYREG(pi, PapdCalYrefEpsilon, papdYrefAddr, yrefindex);

		/* use s2.10 PAPD epsilon fixed point format */
		MOD_PHYREGCE(pi, EpsilonOverrideI_, core, epsilonFixedPoint, 0x1);

		if (ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
			MOD_PHYREG(pi, PapdCalCorrelate, papd_calCorrTime, 0x100);
			MOD_PHYREGCEE(pi, PapdCalShifts, core, papdCorrShift, 0x7);
			MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_I, 0x9);
			MOD_PHYREGCEE(pi, PapdCalShifts, core, papdLambda_Q, 0x9);
		}
		if (calmode == 0) {
			/* Run the PAPD automatic machine on all indices */
			/* setup iter, Yref, start and end address */
			MOD_PHYREG(pi, PapdCalAddress, papdStartAddr, startindex);
			MOD_PHYREG(pi, PapdCalAddress, papdEndAddr, stopindex);

			wlc_phy_ipa_set_bbmult_acphy(pi, &m[0], &m[1], &m[2], coremask);
			if (gain_ctrl == 0) {
				wlc_phy_tx_tone_acphy_papd(pi, 2000, 186, 0, 0, FALSE);
			}
			if (TINY_RADIO(pi)) { /* will remove both in tcl and driver later */
				OSL_DELAY(100000);
			} else {
				OSL_DELAY(100);
			}

			/* start PAPD calibration */
			MOD_PHYREG(pi, PapdCalCoreSel, papdCoreSel, core);
			MOD_PHYREG(pi, PapdCalStart, papdStart, 1);
			SPINWAIT(READ_PHYREG(pi, PapdCalStart), ACPHY_SPINWAIT_PAPDCAL);
			ASSERT(!(READ_PHYREG(pi, PapdCalStart) & 1));
			SPINWAIT(READ_PHYREG(pi, PapdCalStart), ACPHY_SPINWAIT_PAPDCAL);
			if (READ_PHYREG(pi, PapdCalStart) & 1)
				pi->phy_pacalstatus |= PHY_PACALSTATUS_CAL_TIMEOUT;
			if (gain_ctrl == 0) {
				wlc_phy_stopplayback_acphy(pi);
			}
		} else { /* cal mode 1, hardware cal runs single index at a time */
			uint16 mtable_idx;
			uint32 eps_pre, eps, eps_next;
			int32 epspre_r, epspre_i, eps_r, eps_i, epsnext_r, epsnext_i;
			/* run single index of PAPD table only */
			/* (mode 1 which has been used for debug of 4335 PAPD) */
			/* start the tone */
			if (gain_ctrl == 0) {
				wlc_phy_tx_tone_acphy_papd(pi, 2000, 186, 0, 0, FALSE);
			}

			/* 20691 iTR trsw */
			if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
	            MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_tr_rx_en, 1);
				MOD_RADIO_REG_20691(pi, LNA2G_CFG1, 0, lna2g_tr_rx_en, 0);
			}

			wlc_phy_ipa_set_bbmult_acphy(pi, &m[0], &m[1], &m[2], coremask);
			MOD_PHYREG(pi, PapdCalCoreSel, papdCoreSel, core);
			OSL_DELAY(600);

			for (mtable_idx = startindex; mtable_idx <= stopindex; mtable_idx++) {
				MOD_PHYREG(pi, PapdCalYrefEpsilon, papdInitYref, 0x1);

				MOD_PHYREG(pi, PapdCalYrefEpsilon, papdEpsilonInit,
				           (mtable_idx == startindex) ? 0x0 : 0x1);

				MOD_PHYREG(pi, PapdCalAddress, papdStartAddr, mtable_idx);
				MOD_PHYREG(pi, PapdCalAddress, papdEndAddr, mtable_idx);

				/* start PAPD calibration */
				OSL_DELAY(10);
				MOD_PHYREG(pi, PapdCalStart, papdStart, 1);
				SPINWAIT(READ_PHYREG(pi, PapdCalStart), ACPHY_SPINWAIT_PAPDCAL);
				ASSERT(!(READ_PHYREG(pi, PapdCalStart) & 1));
				SPINWAIT(READ_PHYREG(pi, PapdCalStart), ACPHY_SPINWAIT_PAPDCAL);
				if (READ_PHYREG(pi, PapdCalStart) & 1)
					pi->phy_pacalstatus |= PHY_PACALSTATUS_CAL_TIMEOUT;
				OSL_DELAY(10);

				/* predict the next epsilon point */
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_EPSILON0,
					1, mtable_idx-1, 32, &eps_pre);
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_EPSILON0,
					1, mtable_idx, 32, &eps);

				if (pi->pacalopt == 2) {
					eps_next = eps;
				} else {
					/* linear extrapolation of prev 2 points to set
					starting point for next eps
					*/

					wlc_phy_papd_decode_epsilon(eps_pre, &epspre_r, &epspre_i);
					wlc_phy_papd_decode_epsilon(eps, &eps_r, &eps_i);
					if (mtable_idx == startindex) {
						epsnext_r = eps_r;
						epsnext_i = eps_i;
					} else {
						epsnext_r = 2*eps_r-epspre_r;
						epsnext_i = 2*eps_i-epspre_i;
					}
					if (epsnext_r >= 4095) {
						epsnext_r = 4095;
					}
					if (epsnext_r <= -4095) {
						epsnext_r = -4095;
					}
					if (epsnext_r < 0) {
						epsnext_r = 8192+epsnext_r;
					}
					if (epsnext_i >= 4095) {
						epsnext_i = 4095;
					}
					if (epsnext_i <= -4095) {
						epsnext_i = -4095;
					}
					if (epsnext_i < 0) {
						epsnext_i = 8192+epsnext_i;
					}
					eps_next = ((uint32)epsnext_i << 13) |
						((uint32)epsnext_r & 0x1fff);
				}

				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_EPSILON0,
					1, mtable_idx+1, 32, &eps_next);
				PHY_PAPD(("\n We are in %u M table iteration", mtable_idx));
			}
			/* 20691 iTR trsw */
			if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
	            MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_tr_rx_en, 1);
			}
			if (gain_ctrl == 0) {
				wlc_phy_stopplayback_acphy(pi);
			}
		}
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi) &&
		    CHSPEC_IS2G(pi->radio_chanspec)) {
			wlc_phy_papd_smooth_acphy(pi, core, 5, 0, 32);
		}
	}

	/* Calculate epsilon offset, for tiny */
	if (TINY_RADIO(pi)) {
		int32 dig_gain_dB;

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_SCALAR0, 1, 0, 32, &scalartblval);
		papdmult0 = scalartblval & 0x1fff;

	        temp = (bbmult*cal_tone_mag*papdmult0*1000)/(64*1024*100);
		qm_log10((int32)(temp), 0, &temp1, &qQ1);
		dig_gain_dB = ((20*temp1) - (60 << qQ1)) >> qQ1;

		lut_shift = 0;
		if (ACREV_GE(pi->pubpi.phy_rev, 4)) {
			if (CHSPEC_IS5G(pi->radio_chanspec) && (!PHY_EPAPD(pi))) {
				if (IS20MHZ(pi)) {
					lut_shift = lut_shift20[sub_band];
				} else if (IS40MHZ(pi)) {
					lut_shift = lut_shift40[sub_band];
				} else {
					lut_shift = lut_shift80[sub_band];
				}
			}
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				if (IS20MHZ(pi)) {
					lut_shift += pi->pacalshift5g[0];
				} else if (IS40MHZ(pi)) {
					lut_shift += pi->pacalshift5g[1];
				} else {
					lut_shift += pi->pacalshift5g[2];
				}
			} else {
				if (IS20MHZ(pi)) {
					lut_shift += pi->pacalshift2g[0];
				} else if (IS40MHZ(pi)) {
					lut_shift += pi->pacalshift2g[1];
				} else {
					lut_shift += pi->pacalshift2g[2];
				}
			}
		}
		k = -80;
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			dac_rf_offset = READ_PHYREGFLD(pi, PapdEnable0, gain_dac_rf_reg0);
			if (dac_rf_offset >= 256) {
				dac_rf_offset = dac_rf_offset - 512;
			}
			epsilonscalartemp = READ_PHYREGFLD(pi, EpsilonTableAdjust0, epsilonScalar0);
			epsilonoffsettemp = k - 2*dig_gain_dB + lut_shift -
				dac_rf_offset*epsilonscalartemp/16;
			if (epsilonoffsettemp < 0) {
				epsilonoffsettemp = 512 + epsilonoffsettemp;
			}
			MOD_PHYREG(pi, EpsilonTableAdjust0, epsilonOffset0, epsilonoffsettemp);
		}

	} /* TINY_RADIO */
}

#ifdef PAPD_GAIN_CTRL
static uint16
wlc_phy_papd_cal_gain_cntl_acphy(phy_info_t *pi, uint16 num_iter, uint8 core, uint16 startindex,
	uint16 yrefindex, uint16 stopindex)
{
#define EPS_MAX 4095
#define EPS_MIN -4095
	bool clipping_flag = 0;
	uint8 i = 0, num_gain_itr_max = 8;
	/* Change PRF to avoid radar detection */
	uint16 numidx_array[8] = {4, 5, 6, 7, 4, 5, 6, 7};
	uint8 PAPD_FAST_GAIN_CTRL;
	uint16 pga_u = 255, pga_l = 0, pga_mid = 127;
	uint32 tempclip = 0;
	uint32 clipthresholdl = 47894000, clipthresholdu = 49034000, clipthreshold = 48462000;
	acphy_txgains_t tx_gains;
	int32 eps_re, eps_im;
	uint16 bbmult;
	uint32 eps_complex;
	uint16 numidx;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 papdmode = pi->u.pi_acphy->papdmode;
	uint8 PAgain = 0xff;
	uint8 Gainoverwrite = 0;
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};
	uint8 edpdcalset = pi->u.pi_acphy->srom_edpdcalset;
	PAPD_FAST_GAIN_CTRL = pi_ac->fastpapdgainctrl;
	bbmult = 0x30;
	tx_gains.txlpf = 0x0;
	tx_gains.txgm = 0xff;
	tx_gains.pga = 0xff;
	tx_gains.pad = 0xff;
	if (PHY_IPA(pi)) {
		Gainoverwrite = (CHSPEC_IS2G(pi->radio_chanspec)) ?
			pi->u.pi_acphy->srom_pagc2g_ovr :
			pi->u.pi_acphy->srom_pagc5g_ovr;
		PAgain = (CHSPEC_IS2G(pi->radio_chanspec)) ?
			pi->u.pi_acphy->srom_pagc2g :
			pi->u.pi_acphy->srom_pagc5g;
	}
	tx_gains.ipa = (Gainoverwrite == 0) ? 0xff : PAgain;
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
		/* 4350EPAPD */
		tx_gains.txlpf = 0x0;
		tx_gains.txgm = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0x67 : 0x91;
		tx_gains.pga = 0xff;
		tx_gains.pad = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0xff : 0x7f;
		tx_gains.ipa = (CHSPEC_IS2G(pi->radio_chanspec)) ? 0xc0 : 0x3;
	}

	if (PAPD_FAST_GAIN_CTRL) {
		PHY_CAL(("---------- Using Fast Gain Control ------------"));
		/* Value for numidx is taken from numidx_array */
		/* numidx = 4; */
		if ((papdmode == PAPD_ANALYTIC) || (papdmode == PAPD_ANALYTIC_WO_YREF)) {
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				bbmult = 0x30;
				if (!CHSPEC_IS80(pi->radio_chanspec)) {
					clipthresholdl = 59901000;
					clipthresholdu = 61175000;
					clipthreshold = 60536000;
					/* 1.9 */
				} else {
					clipthresholdl = 47894000;
					clipthresholdu = 49034000;
					clipthreshold = 48462000;
					/* 1.7 */
				}
			}
		} else {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				clipthresholdl = 30110000;
				clipthresholdu = 31016000;
				/* clipthreshold 1.35 */
				clipthreshold = 30562000;
			}
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				bbmult = 0x30;
				if (!CHSPEC_IS80(pi->radio_chanspec)) {
					clipthresholdl = 39255000;
					clipthresholdu = 40288000;
					clipthreshold = 39769000;
				} else {
					clipthresholdl = 32399000;
					clipthresholdu = 33338000;
					clipthreshold = 32867289;
					/* 1.2 */
				}
			}
		}
	} else {
		numidx = 16;
		if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				bbmult = 0x30;
				if (!CHSPEC_IS80(pi->radio_chanspec)) {
					clipthresholdl = 59901000;
					clipthresholdu = 61175000;
					clipthreshold = 60536000;
				}
			}
		}
	}
	if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			clipthresholdl = 13886000;
			clipthresholdu = 14504000;
			clipthreshold = 14193000;
			pga_u = 127;
			pga_l = 40;
			pga_mid = 84;
		} else {
			if (edpdcalset == 1) {
			    if (CHSPEC_IS20(pi->radio_chanspec)) {
				    clipthresholdl = 32399000;
				    clipthresholdu = 33338000;
				    clipthreshold = 32867000;
			    } else if (CHSPEC_IS40(pi->radio_chanspec)) {
				    clipthresholdl = 27905000;
				    clipthresholdu = 28777000;
				    clipthreshold = 28340000;
			    } else {
				    clipthresholdl = 19923000;
				    clipthresholdu = 20661000;
				    clipthreshold = 20291000;
			    }
			}
		}
	}

	/* Binary search */
	/* Continuous tone throughout gain control to avoid radar detection */
	wlc_phy_tx_tone_acphy_papd(pi, 2000, 186, 0, 0, FALSE);
	for (i = 1; i <= num_gain_itr_max; i++) {
		/* For fast papd numidx value is changed per iteration otherwise fixed to 16 */
		if (PAPD_FAST_GAIN_CTRL) {
			numidx = numidx_array[i-1];
		}
		tx_gains.pga = pga_mid;
		wlc_phy_write_tx_gain_acphy(pi, core, &tx_gains, &bbmult);
		/* TODO: check start and stop indexs do we want to check more than the last index */
		wlc_phy_papd_cal_acphy(pi, num_iter, core, stopindex - numidx + 1,
		    yrefindex, stopindex);
		wlc_phy_table_read_acphy(pi, epsilon_table_ids[core], 1, 63, 32, &eps_complex);
		wlc_phy_papd_decode_epsilon(eps_complex, &eps_re, &eps_im);
		tempclip =   ((4095+eps_re)*(4095+eps_re))+  (eps_im*eps_im);
		if (tempclip >= clipthreshold)
		    clipping_flag = 1;
		else
		    clipping_flag = 0;

		if (tempclip >= clipthresholdl && tempclip <= clipthresholdu) {
		    break;
		}

		if (clipping_flag)
			pga_u = pga_mid;
		else
		    pga_l = pga_mid;

		pga_mid = (pga_u + pga_l)/ 2;
	}
	/* Stop Continuous tone after gain control to avoid radar detection */
	wlc_phy_stopplayback_acphy(pi);
	return tx_gains.pga;
}

static void
wlc_phy_write_tx_gain_acphy(phy_info_t *pi, uint8 core, acphy_txgains_t *target_gain,
	uint16 *bbmult)
{
	uint8 stall_val = 0;
	uint16 curr_gains_0, curr_gains_1, curr_gains_2;
	uint16 txgain1, txgain2, lpf_gain, dac_gain;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);

	ACPHY_DISABLE_STALL(pi);
	txgain1  = ((target_gain->ipa & 0x00FF) | ((target_gain->pad  << 8) & 0xFF00));
	txgain2  = ((target_gain->pga & 0x00FF) | ((target_gain->txgm  << 8) & 0xFF00));
	lpf_gain = (target_gain->txlpf & 0xF0) >> 4;
	dac_gain = (target_gain->txlpf & 0x0F) >> 0;

	WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, txgain1);
	WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, txgain2);
	WRITE_PHYREGCE(pi, Dac_gain, core, dac_gain);
	MOD_PHYREGCE(pi, RfctrlCoreLpfGain, core, lpf_bq2_gain, lpf_gain);
	MOD_PHYREGCE(pi, RfctrlOverrideGains, core, txgain, 1);
	MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq2_gain, 1);
	wlc_phy_set_tx_bbmult_acphy(pi, bbmult, core);
	/* emulate RFSEQ GAIN CHANGE */
	curr_gains_0 = (target_gain->txlpf & 0xFF) | ((target_gain->ipa << 8) & 0xFF00);
	curr_gains_1 = (target_gain->pad & 0xFF) | ((target_gain->pga << 8) & 0xFF00);
	curr_gains_2 = (target_gain->txgm & 0xff);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		&curr_gains_0);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		&curr_gains_1);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		&curr_gains_2);

	ACPHY_ENABLE_STALL(pi, stall_val);
}
#endif /* PAPD_GAIN_CTRL */

void
wlc_phy_gpiosel_acphy(phy_info_t *pi, uint16 sel, uint8 word_swap)
{
	uint16 save_gpioHiOutEn;

	save_gpioHiOutEn = READ_PHYREG(pi, gpioHiOutEn);
	save_gpioHiOutEn |= 0x8000;

	/* set up acphy GPIO sel */
	WRITE_PHYREG(pi, gpioSel, (word_swap<<8) | sel);
	WRITE_PHYREG(pi, gpioHiOutEn, save_gpioHiOutEn);
}

static void
wlc_phy_poll_adc_acphy(phy_info_t *pi, int32 *adc_buf, uint8 nsamps,
                       bool switch_gpiosel, uint16 core)
{
	/* Switching gpiosel is time consuming. We move the switch to an outer layer */
	/* and do it less frequently. */
	uint8 samp = 0;
	uint8 word_swap_flag = 1;

	ASSERT(core < PHY_CORE_MAX);
	adc_buf[2*core] = 0;
	adc_buf[2*core+1] = 0;

	if (switch_gpiosel)
		wlc_phy_gpiosel_acphy(pi, 16+core, word_swap_flag);
	for (samp = 0; samp < nsamps; samp++) {
		/* read out the i-value */
		adc_buf[2*core] += READ_PHYREG(pi, gpioHiOut);
		/* read out the q-value */
		adc_buf[2*core+1] += READ_PHYREG(pi, gpioLoOut);
	}
}

static void
wlc_phy_poll_samps_acphy(phy_info_t *pi, int16 *samp, bool is_tssi,
                         uint8 log2_nsamps, bool init_adc_inside,
                         uint16 core)
{
	int32 adc_buf[2*PHY_CORE_MAX];
	int32 k, tmp_samp, samp_accum[PHY_CORE_MAX];
	uint8 iq_swap;

	ASSERT(core < PHY_CORE_MAX);

	/* initialization */
	samp_accum[core] = 0;

	iq_swap = (is_tssi)? 1 : 0;

	wlc_phy_pulse_adc_reset_acphy(pi);
	OSL_DELAY(100);

	/* tssi val is (adc >> 2) */
	for (k = 0; k < (1 << log2_nsamps); k++) {
		wlc_phy_poll_adc_acphy(pi, adc_buf, 1, init_adc_inside, core);
		tmp_samp = adc_buf[2*core+iq_swap] >> 2;
		tmp_samp -= (tmp_samp < 512) ? 0 : 1024;
		samp_accum[core] += tmp_samp;

	}

	samp[core] = (int16) (samp_accum[core] >> log2_nsamps);
}

/**
 * TSSI gain setup helper function.
 */
static void
wlc_phy_tssi_gain_setup_acphy(phy_info_t *pi, bool for_idle, txgain_setting_t *target_gains)
{
	uint8 core;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint16 bbmult, txgain1, txgain2, lpf_gain, dac_gain, vlin_val;
	uint16 bq1_gain_addr[3] = {0x17e, 0x18e, 0x19e}, bq1_gain;

	if (for_idle) {
		/* This is to measure the idle tssi */
		bbmult   = 0;
		txgain1  = 0;
		txgain2  = 0;
		lpf_gain = 0;
		dac_gain = 0;
	} else {
		/* This is to measure the tone tssi */
		bbmult   = target_gains->bbmult;
		txgain1  = ((target_gains->rad_gain & 0xFF00) >> 8) |
			((target_gains->rad_gain_mi & 0x00FF) << 8);
		txgain2  = ((target_gains->rad_gain_mi & 0xFF00) >> 8) |
			((target_gains->rad_gain_hi & 0x00FF) << 8);
		lpf_gain = (target_gains->rad_gain & 0xF0) >> 4;
		dac_gain = (target_gains->rad_gain & 0x0F) >> 0;
		if (pi_ac->srom.vlin_en_from_nvram) {
			vlin_val =  (target_gains->rad_gain & 0x00F0) >> 7;
			FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
				MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, tx_vlin_ovr, 1);
				MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, tx_vlin, vlin_val);
			}
		}
	}

	if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) ||
		(RADIOID(pi->pubpi.radioid) == BCM20691_ID)) {
		/* set same gain for all cores */
		FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, txgain1);
			WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, txgain2);
			WRITE_PHYREGCE(pi, Dac_gain, core, dac_gain);
			MOD_PHYREGCE(pi, RfctrlCoreLpfGain, core, lpf_bq2_gain, lpf_gain);
			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, txgain, 1);
			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq2_gain, 1);
			wlc_phy_set_tx_bbmult_acphy(pi, &bbmult, core);

			if (!TINY_RADIO(pi)) {
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
					bq1_gain_addr[core], 16, &bq1_gain);
				MOD_RADIO_REGC(pi, LPF_MAIN_CONTROLS, core,
					lpf_bq1_gain, bq1_gain);
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
					MOD_RADIO_REGC(pi, GE16_OVR11, core,
						ovr_lpf_bq1_gain, 1);
				} else {
					MOD_RADIO_REGC(pi, OVR10, core,
						ovr_lpf_bq1_gain, 1);
				}
			}
		}
	}
}

static void
wlc_phy_poll_samps_WAR_acphy(phy_info_t *pi, int16 *samp, bool is_tssi,
                             bool for_idle, txgain_setting_t *target_gains,
                             bool for_iqcal, bool init_adc_inside, uint16 ADCcore, bool champ)
{
	uint8 core;
	uint16 save_afePuCtrl = 0, save_gpio = 0, save_gpioHiOutEn = 0;
	uint16 txgain1_save[PHY_CORE_MAX] = {0};
	uint16 txgain2_save[PHY_CORE_MAX] = {0};
	uint16 dacgain_save[PHY_CORE_MAX] = {0};
	uint16 bq2gain_save[PHY_CORE_MAX] = {0};
	uint16 overridegains_save[PHY_CORE_MAX] = {0};
	uint16 overridevlin_save[PHY_CORE_MAX] = {0};
	uint16 overridevlin2_save[PHY_CORE_MAX] = {0};
	uint16 orig_OVR10[PHY_CORE_MAX] = {0};
	uint16 orig_LPF_MAIN_CONTROLS[PHY_CORE_MAX] = {0};
	uint16 fval2g_orig, fval5g_orig, fval2g, fval5g;
	uint32 save_chipc = 0;
	uint8  stall_val = 0, log2_nsamps = 0;
	uint16 bbmult_save[PHY_CORE_MAX];

	if (init_adc_inside) {
		wlc_phy_init_adc_read(pi, &save_afePuCtrl, &save_gpio,
		                      &save_chipc, &fval2g_orig, &fval5g_orig,
		                      &fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
	}

	if (is_tssi) {
		ACPHY_DISABLE_STALL(pi);
		/* Save gain for all Tx cores */
		/* Set TX gain to 0, so that LO leakage does not affect IDLE TSSI */
		FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			wlc_phy_get_tx_bbmult_acphy(pi, &(bbmult_save[core]), core);
			dacgain_save[core] = READ_PHYREGCE(pi, Dac_gain, core);
			txgain1_save[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN1, core);
			txgain2_save[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN2, core);
			bq2gain_save[core] = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
			overridegains_save[core] = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
			overridevlin_save[core] = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
			overridevlin2_save[core] = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
			if (!TINY_RADIO(pi)) {
				/* Enforce lpf_bq1_gain */
				orig_LPF_MAIN_CONTROLS[core] =
					READ_RADIO_REGC(pi, RF, LPF_MAIN_CONTROLS, core);
				if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
					orig_OVR10[core] = READ_RADIO_REGC(pi, RF,
						GE16_OVR11, core);
				} else {
					orig_OVR10[core] = READ_RADIO_REGC(pi, RF,
						OVR10, core);
				}
			}
		}
		wlc_phy_tssi_gain_setup_acphy(pi, for_idle, target_gains);
		ACPHY_ENABLE_STALL(pi, stall_val);

		/* Enable WLAN priority */
		wlc_btcx_override_enable(pi);

		OSL_DELAY(100);
		if (for_idle) {
			wlc_phy_tx_tone_acphy(pi, 2000, 0, 0, 0, FALSE);
		} else {
		if (champ)
			{
			wlc_phy_tx_tone_acphy(pi, 2000, 120, 0, 0, FALSE);
			}
		else
			{
			wlc_phy_tx_tone_acphy(pi, 2000, 181, 0, 0, FALSE);
			}
		}
		OSL_DELAY(100);

		/* Taking a 256-samp average for 80mHz idle-tssi measuring.
		 * Note: ideally, we can apply the same averaging for 20/40mhz also,
		 *       but we don't want to change the existing 20/40mhz behavior to reduce risk.
		 */
		log2_nsamps = (for_iqcal)? 3: (CHSPEC_IS80(pi->radio_chanspec) ? 8 : 0);

		if (champ)
		log2_nsamps = 4;
		wlc_phy_poll_samps_acphy(pi, samp, TRUE, log2_nsamps, init_adc_inside, ADCcore);
		wlc_phy_stopplayback_acphy(pi);

		/* Disable WLAN priority */
		wlc_phy_btcx_override_disable(pi);
	} else {
		wlc_phy_poll_samps_acphy(pi, samp, FALSE, 3, init_adc_inside, ADCcore);
	}

	if (is_tssi) {
		if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) ||
			(RADIOID(pi->pubpi.radioid) == BCM20691_ID)) {
			FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
				/* Remove TX gain & lpf_bq1 gain override */
				WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, txgain1_save[core]);
				WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, txgain2_save[core]);
				WRITE_PHYREGCE(pi, Dac_gain, core, dacgain_save[core]);
				WRITE_PHYREGCE(pi, RfctrlOverrideGains, core,
					overridegains_save[core]);
				WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, bq2gain_save[core]);
				WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core,
					overridevlin_save[core]);
				WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core,
					overridevlin2_save[core]);
				wlc_phy_set_tx_bbmult_acphy(pi, &(bbmult_save[core]), core);
				if (!TINY_RADIO(pi)) {
					write_radio_reg(pi, RF_2069_LPF_MAIN_CONTROLS(core),
						orig_LPF_MAIN_CONTROLS[core]);
					if (RADIOMAJORREV(pi->pubpi.radiomajorrev) > 0) {
						write_radio_reg(pi, RF_2069_GE16_OVR11(core),
							orig_OVR10[core]);
					} else {
						write_radio_reg(pi, RF_2069_OVR10(core),
							orig_OVR10[core]);
					}
				}
			}
		}
	}
	if (init_adc_inside) {
		wlc_phy_restore_after_adc_read(pi,  &save_afePuCtrl, &save_gpio,
		                               &save_chipc,  &fval2g_orig,  &fval5g_orig,
		                               &fval2g,  &fval5g, &stall_val, &save_gpioHiOutEn);
	}

}

/* Fast tone TSSI measurement for PAPD temperature compensation */
static void
wlc_phy_poll_tssi_samps_acphy(phy_info_t *pi, int16 *samp, txgain_setting_t *target_gains,
	uint16 ADCcore)
{
	uint8 stall_val = 0;
	ACPHY_DISABLE_STALL(pi);
	wlc_phy_tssi_gain_setup_acphy(pi, FALSE, target_gains);
	ACPHY_ENABLE_STALL(pi, stall_val);
	wlc_phy_poll_samps_acphy(pi, samp, TRUE, 3, FALSE, ADCcore);
}

#if defined(BCMDBG) || defined(WLTEST)
int
wlc_phy_freq_accuracy_acphy(phy_info_t *pi, int channel)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	int bcmerror = BCME_OK;

	if (channel == 0) {
		wlc_phy_stopplayback_acphy(pi);
		/* restore the old BBconfig, to restore resampler setting */
		WRITE_PHYREG(pi, BBConfig, pi_ac->saved_bbconf);
		WRITE_PHYREG(pi, AfePuCtrl, pi_ac->AfePuCtrl);
		wlc_phy_resetcca_acphy(pi);
	} else {
		/* Disable the re-sampler (in case we are in spur avoidance mode) */
		pi_ac->saved_bbconf = READ_PHYREG(pi, BBConfig);
		pi_ac->AfePuCtrl = READ_PHYREG(pi, AfePuCtrl);

		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, AfePuCtrl, tssiSleepEn, 0)
			MOD_PHYREG_ENTRY(pi, bphyTest, dccomp, 0)
			MOD_PHYREG_ENTRY(pi, BBConfig, resample_clk160, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
		/* use 151 since that should correspond to nominal tx output power */
		bcmerror = wlc_phy_tx_tone_acphy(pi, 0, 151, 0, 0, TRUE);

	}
	return bcmerror;
}
#endif // endif
/* measure idle TSSI by sending 0-magnitude tone */
static void
wlc_phy_txpwrctrl_idle_tssi_meas_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8  core;
	int16  idle_tssi[PHY_CORE_MAX] = {0};
	uint16 orig_RfseqCoreActv2059, orig_RxSdFeConfig6 = 0;

	if ((SCAN_RM_IN_PROGRESS(pi) || PLT_INPROG_PHY(pi) || PHY_MUTED(pi)) && !TINY_RADIO(pi))
		/* skip idle tssi cal */
		return;

	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* we should not need this but just in case */
	wlc_phy_tssi_phy_setup_acphy(pi, 0);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 0);
	else
		wlc_phy_tssi_radio_setup_acphy(pi, pi->sh->hw_phyrxchain, 0);

	if (TINY_RADIO(pi)) {
		MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 1);
		orig_RxSdFeConfig6 = READ_PHYREG(pi, RxSdFeConfig6);
		MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0,
			READ_PHYREGFLD(pi, RxSdFeConfig1, farrow_rshift_tx));
	}
	/* force all TX cores on */
	orig_RfseqCoreActv2059 = READ_PHYREG(pi, RfseqCoreActv2059);
	MOD_PHYREG(pi, RfseqCoreActv2059, EnTx,  pi->sh->hw_phyrxchain);
	MOD_PHYREG(pi, RfseqCoreActv2059, DisRx, pi->sh->hw_phyrxchain);

	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		wlc_phy_poll_samps_WAR_acphy(pi, idle_tssi, TRUE, TRUE, NULL,
		                             FALSE, TRUE, core, 0);
		pi_ac->idle_tssi[core] = idle_tssi[core];
		wlc_phy_txpwrctrl_set_idle_tssi_acphy(pi, idle_tssi[core], core);
		PHY_TRACE(("wl%d: %s: idle_tssi core%d: %d\n",
		           pi->sh->unit, __FUNCTION__, core, pi_ac->idle_tssi[core]));
	}

	WRITE_PHYREG(pi, RfseqCoreActv2059, orig_RfseqCoreActv2059);

	if (TINY_RADIO(pi)) {
		MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 0);
		WRITE_PHYREG(pi, RxSdFeConfig6, orig_RxSdFeConfig6);
	}
	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
}

uint8
wlc_phy_set_txpwr_clamp_acphy(phy_info_t *pi, uint8 core)
{
	uint16 idle_tssi_shift, adj_tssi_min;
	int16 tssi_floor[PHY_CORE_MAX] = {0};
	int16 idleTssi_2C = 0;
	int16 a1[PHY_CORE_MAX];
	int16 b0[PHY_CORE_MAX];
	int16 b1[PHY_CORE_MAX];
	uint8 pwr = 0;

	wlc_phy_get_tssi_floor_acphy(pi, tssi_floor);
	wlc_phy_get_paparams_for_band_acphy(pi, a1, b0, b1);

	idleTssi_2C = READ_PHYREGCE(pi, TxPwrCtrlIdleTssi_path, core) & 0x3ff;
	if (idleTssi_2C >= 512) {
		idle_tssi_shift = idleTssi_2C - 1023 - (-512);
	} else {
		idle_tssi_shift = 1023 + idleTssi_2C - 511;
	}
	idle_tssi_shift = idle_tssi_shift + 4;
	adj_tssi_min = MAX(tssi_floor[core], idle_tssi_shift);

	/* convert to 7 bits */
	adj_tssi_min = adj_tssi_min >> 3;

	pwr = wlc_phy_tssi2dbm_acphy(pi, adj_tssi_min, a1[core], b0[core], b1[core]);

	return pwr;
}

uint8
wlc_phy_tssi2dbm_acphy(phy_info_t *pi, int32 tssi, int32 a1, int32 b0, int32 b1)
{
	int32 num, den;
	int8 pwrest = 0;
	num = 8*(16*b0+b1*tssi);
	den = 32768+a1*tssi;
	if (IBOARD(pi)) {
		pwrest = MAX(((4*num+den/2)/den), -60);
		pwrest = MIN(pwrest, 0x28);
	} else {
		pwrest = MAX(((4*num+den/2)/den), -8);
		pwrest = MIN(pwrest, 0x7f);
	}

	return pwrest;
}

static int8
wlc_phy_tone_pwrctrl(phy_info_t *pi, int8 tx_idx, uint8 core)
{
	int8 pwr;
	int8 targetpwr = -99, tgt_pwr_qdbm;
	int16  idle_tssi[PHY_CORE_MAX], tone_tssi[PHY_CORE_MAX];
	uint16 adjusted_tssi[PHY_CORE_MAX];
	int16 a1[PHY_CORE_MAX];
	int16 b1[PHY_CORE_MAX];
	int16 b0[PHY_CORE_MAX];
	int8 postive_slope = 1;
	int8 targetidx;
	int8 org_tx_idx;
	int8 deltapwr;
	txgain_setting_t txgain_settings;
	uint8 band;
	int8 orig_rxfarrow_shift = 0;
	/* save txidx  that comes as input */
	org_tx_idx = tx_idx;
	/* Get current subband information */
	band = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	switch (band) {
		case WL_CHAN_FREQ_RANGE_2G:
			targetpwr = pi->pacalpwr2g;
			tx_idx = pi->patoneidx2g;
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND0:
			targetpwr = pi->pacalpwr5g[core*4 + 0];
			if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				if (CHSPEC_IS40(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g40[core*4 + 0];
				} else if (CHSPEC_IS80(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g80[core*4 + 0];
				}
			}
			tx_idx = pi->patoneidx5g[0];
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND1:
			targetpwr = pi->pacalpwr5g[core*4 + 1];
			if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				if (CHSPEC_IS40(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g40[core*4 + 1];
				} else if (CHSPEC_IS80(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g80[core*4 + 1];
				}
			}
			tx_idx = pi->patoneidx5g[1];
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND2:
			targetpwr = pi->pacalpwr5g[core*4 + 2];
			if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				if (CHSPEC_IS40(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g40[core*4 + 2];
				} else if (CHSPEC_IS80(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g80[core*4 + 2];
				}
			}
			tx_idx = pi->patoneidx5g[2];
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND3:
			targetpwr = pi->pacalpwr5g[core*4 + 3];
			if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
				if (CHSPEC_IS40(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g40[core*4 + 3];
				} else if (CHSPEC_IS80(pi->radio_chanspec)) {
					targetpwr = pi->pacalpwr5g80[core*4 + 3];
				}
			}
			tx_idx = pi->patoneidx5g[3];
			break;
	}
	if (tx_idx == -1) {
		tx_idx = org_tx_idx;
	}

	if (IBOARD(pi)) {
		tgt_pwr_qdbm = READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path0, targetPwr0);
		targetpwr = tgt_pwr_qdbm / 4;
	} else {
		tgt_pwr_qdbm = targetpwr * 4;
	}

	if (targetpwr == -99) {
		targetidx = -1;
	} else {
		wlc_phy_get_paparams_for_band_acphy(pi, a1, b0, b1);
		/* meas the idle tssi */
		wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
		idle_tssi[core] = READ_PHYREGCE(pi, TxPwrCtrlIdleTssi_path, core) & 0x3ff;
		idle_tssi[core] = idle_tssi[core] - 1023;

		/* prevent crs trigger */
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
		if (!(ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
			orig_rxfarrow_shift = READ_PHYREGFLD(pi, RxSdFeConfig6, rx_farrow_rshift_0);
			MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 2);
		}
		if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
			wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 0);
		else
			wlc_phy_tssi_radio_setup_acphy(pi, pi->sh->hw_phyrxchain, 0);

		wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);
		wlc_phy_get_txgain_settings_by_index_acphy(
			pi, &txgain_settings, tx_idx);
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi,
			TRUE, FALSE, &txgain_settings, FALSE, TRUE, 0, 0);

		adjusted_tssi[core] = 1023 - postive_slope * (tone_tssi[core] - idle_tssi[core]);
		adjusted_tssi[core] = adjusted_tssi[core] >> 3;
		/* prevent crs trigger */
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		if (!(ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
			MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, orig_rxfarrow_shift);
		}
		pwr = wlc_phy_tssi2dbm_acphy(pi, adjusted_tssi[core], a1[core], b0[core], b1[core]);

		/* delta pwr in qdb */
		deltapwr = tgt_pwr_qdbm - pwr;
		if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			/* for 4350 with 0.5dB step size gaintable */
			targetidx = tx_idx - (deltapwr >> 1);
		} else {
#ifndef WLC_POINT5_DB_TX_GAIN_STEP /* Disable 0.5 dB gain step */
			targetidx = tx_idx - deltapwr;
#else
			targetidx = tx_idx - (deltapwr >> 1);
#endif /* Disable 0.5 dB gain step */
		}
	}
	return targetidx;
}

void
wlc_phy_get_paparams_for_band_acphy(phy_info_t *pi, int16 *a1, int16 *b0, int16 *b1)
{

	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 chan_freq_range, core;

	/* Get pwrdet params from SROM for current subband */
	chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	FOREACH_CORE(pi, core) {
		switch (chan_freq_range) {
		case WL_CHAN_FREQ_RANGE_2G:
		case WL_CHAN_FREQ_RANGE_5G_BAND0:
		case WL_CHAN_FREQ_RANGE_5G_BAND1:
		case WL_CHAN_FREQ_RANGE_5G_BAND2:
		case WL_CHAN_FREQ_RANGE_5G_BAND3:
			a1[core] =  (int16)pwrdet->pwrdet_a1[core][chan_freq_range];
			b0[core] =  (int16)pwrdet->pwrdet_b0[core][chan_freq_range];
			b1[core] =  (int16)pwrdet->pwrdet_b1[core][chan_freq_range];
			PHY_TXPWR(("wl%d: %s: pwrdet core%d: a1=%d b0=%d b1=%d\n",
				pi->sh->unit, __FUNCTION__, core,
				a1[core], b0[core], b1[core]));
			break;
		}
	}
}

static
void wlc_phy_get_tssi_floor_acphy(phy_info_t *pi, int16 *floor)
{
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 chan_freq_range, core;

	chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	FOREACH_CORE(pi, core) {
		switch (chan_freq_range) {
		case WL_CHAN_FREQ_RANGE_2G:
		case WL_CHAN_FREQ_RANGE_5G_BAND0:
		case WL_CHAN_FREQ_RANGE_5G_BAND1:
		case WL_CHAN_FREQ_RANGE_5G_BAND2:
		case WL_CHAN_FREQ_RANGE_5G_BAND3:
			floor[core] = pwrdet->tssifloor[core][chan_freq_range];
		break;
		}
	}
}

/* get the complex freq. if chan==0, use default radio channel */
uint8
wlc_phy_get_chan_freq_range_acphy(phy_info_t *pi, uint channel)
{
	int freq = WL_CHAN_FREQ_RANGE_2G;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (channel == 0)
		channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
		const void *chan_info;

		(void) wlc_phy_chan2freq_acphy(pi, channel, &freq, &chan_info);
	} else {
		const void *chan_info;

		(void) wlc_phy_chan2freq_20691(pi, channel, &freq, &chan_info);
	}

	if (channel <= CH_MAX_2G_CHANNEL)
		return WL_CHAN_FREQ_RANGE_2G;
	if ((pi->sh->subband5Gver == PHY_MAXNUM_5GSUBBANDS) ||
	    (pi->sh->subband5Gver == PHY_SUBBAND_4BAND)) {
			if ((freq >= PHY_SUBBAND_4BAND_BAND0) &&
				(freq < PHY_SUBBAND_4BAND_BAND1))
				return WL_CHAN_FREQ_RANGE_5G_BAND0;
			else if ((freq >= PHY_SUBBAND_4BAND_BAND1) &&
				(freq < PHY_SUBBAND_4BAND_BAND2))
				return WL_CHAN_FREQ_RANGE_5G_BAND1;
			else if ((freq >= PHY_SUBBAND_4BAND_BAND2) &&
				(freq < PHY_SUBBAND_4BAND_BAND3))
				return WL_CHAN_FREQ_RANGE_5G_BAND2;
			else
				return WL_CHAN_FREQ_RANGE_5G_BAND3;
		} else if (pi->sh->subband5Gver == PHY_SUBBAND_3BAND_EMBDDED) {
			if ((freq >= EMBEDDED_LOW_5G_CHAN) && (freq < EMBEDDED_MID_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GL;
			} else if ((freq >= EMBEDDED_MID_5G_CHAN) &&
			           (freq < EMBEDDED_HIGH_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GM;
			} else {
				return WL_CHAN_FREQ_RANGE_5GH;
			}
		} else if (pi->sh->subband5Gver == PHY_SUBBAND_3BAND_HIGHPWR) {
			if ((freq >= HIGHPWR_LOW_5G_CHAN) && (freq < HIGHPWR_MID_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GL;
			} else if ((freq >= HIGHPWR_MID_5G_CHAN) && (freq < HIGHPWR_HIGH_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GM;
			} else {
				return WL_CHAN_FREQ_RANGE_5GH;
			}
	} else { /* Default PPR Subband subband5Gver = 7 */
			if ((freq >= JAPAN_LOW_5G_CHAN) && (freq < JAPAN_MID_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GL;
			} else if ((freq >= JAPAN_MID_5G_CHAN) && (freq < JAPAN_HIGH_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GM;
			} else {
				return WL_CHAN_FREQ_RANGE_5GH;
		}
	}
}

#ifdef SROM12
/* get the complex freq. if chan==0, use default radio channel */
uint8
wlc_phy_get_chan_freq_range_srom12_acphy(phy_info_t *pi, uint chanspec)
{
	int freq = WL_CHAN_FREQ_RANGE_2G;
	int channel = chanspec;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	if (channel == 0)
		channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
		const void *chan_info;

		(void) wlc_phy_chan2freq_acphy(pi, channel, &freq, &chan_info);
	} else {
		const void *chan_info;

		(void) wlc_phy_chan2freq_20691(pi, channel, &freq, &chan_info);
	}

	if (channel <= CH_MAX_2G_CHANNEL) {
		if (CHSPEC_IS40(pi->radio_chanspec))
			return WL_CHAN_FREQ_RANGE_2G_40;
		else
			return WL_CHAN_FREQ_RANGE_2G;
	}

		 if (pi->sh->subband5Gver == PHY_MAXNUM_5GSUBBANDS) {
			if ((freq >= PHY_MAXNUM_5GSUBBANDS_BAND0) &&
			    (freq < PHY_MAXNUM_5GSUBBANDS_BAND1)) {
				if (CHSPEC_IS40(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND0_40;
				else if (CHSPEC_IS80(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND0_80;
				else
					return WL_CHAN_FREQ_RANGE_5G_BAND0;
			} else if ((freq >= PHY_MAXNUM_5GSUBBANDS_BAND1) &&
			         (freq < PHY_MAXNUM_5GSUBBANDS_BAND2)) {
				if (CHSPEC_IS40(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND1_40;
				else if (CHSPEC_IS80(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND1_80;
				else
					return WL_CHAN_FREQ_RANGE_5G_BAND1;
			} else if ((freq >= PHY_MAXNUM_5GSUBBANDS_BAND2) &&
			         (freq < PHY_MAXNUM_5GSUBBANDS_BAND3)) {
				if (CHSPEC_IS40(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND2_40;
				else if (CHSPEC_IS80(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND2_80;
				else
					return WL_CHAN_FREQ_RANGE_5G_BAND2;
			} else if ((freq >= PHY_MAXNUM_5GSUBBANDS_BAND3) &&
			         (freq < PHY_MAXNUM_5GSUBBANDS_BAND4)) {
				if (CHSPEC_IS40(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND3_40;
				else if (CHSPEC_IS80(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND3_80;
				else
					return WL_CHAN_FREQ_RANGE_5G_BAND3;
			} else {
				if (CHSPEC_IS40(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND4_40;
				else if (CHSPEC_IS80(pi->radio_chanspec))
					return WL_CHAN_FREQ_RANGE_5G_BAND4_80;
				else
					return WL_CHAN_FREQ_RANGE_5G_BAND4;
			}
		/* Default PPR Subband subband5Gver = 7 */
		} else {
			if ((freq >= JAPAN_LOW_5G_CHAN) && (freq < JAPAN_MID_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GL;
			} else if ((freq >= JAPAN_MID_5G_CHAN) && (freq < JAPAN_HIGH_5G_CHAN)) {
				return WL_CHAN_FREQ_RANGE_5GM;
			} else {
				return WL_CHAN_FREQ_RANGE_5GH;
		}
	}
}
#endif /* SROM12 */

uint8
wlc_phy_rssi_get_chan_freq_range_acphy(phy_info_t *pi, uint channel)
{
	int freq = WL_CHAN_FREQ_RANGE_2G;

	PHY_TRACE(("wl%d: %s | channel = %d \n", pi->sh->unit, __FUNCTION__, channel));

	if (channel == 0)
		channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (channel <= CH_MAX_2G_CHANNEL) {
		return pi->u.pi_acphy->srom.rssi_cal_freq_grp[channel-1] & 0x7;
	} else {
		const void *chan_info;

		if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
			(void) wlc_phy_chan2freq_acphy(pi, channel, &freq, &chan_info);
		} else {
			(void) wlc_phy_chan2freq_20691(pi, channel, &freq, &chan_info);
		}

		if ((freq >= PHY_RSSI_SUBBAND_4BAND_BAND0) &&
			(freq < PHY_RSSI_SUBBAND_4BAND_BAND1))
			return WL_CHAN_FREQ_RANGE_5G_BAND0 - 1;
		else if ((freq >= PHY_RSSI_SUBBAND_4BAND_BAND1) &&
			(freq < PHY_RSSI_SUBBAND_4BAND_BAND2))
			return WL_CHAN_FREQ_RANGE_5G_BAND1 - 1;
		else if ((freq >= PHY_RSSI_SUBBAND_4BAND_BAND2) &&
			(freq < PHY_RSSI_SUBBAND_4BAND_BAND3))
			return WL_CHAN_FREQ_RANGE_5G_BAND2 - 1;
		else
			return WL_CHAN_FREQ_RANGE_5G_BAND3 - 1;
	}
}

static void
BCMATTACHFN(wlc_phy_txpwrctrl_config_acphy)(phy_info_t *pi)
{
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	pi->hwpwrctrl_capable = TRUE;
	pi->txpwrctrl = PHY_TPC_HW_ON;

	pi->phy_5g_pwrgain = TRUE;
}

static void
wlc_phy_txpwrctrl_setminpwr(phy_info_t *pi)
{
	if (ISACPHY(pi)) {
		if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
			if (PHY_IPA(pi)) {
				pi->min_txpower = PHY_TXPWR_MIN_ACPHY2X2IPA;
			} else {
				pi->min_txpower = PHY_TXPWR_MIN_ACPHY2X2EPA;
			}
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
			if (PHY_IPA(pi)) {
				pi->min_txpower = PHY_TXPWR_MIN_ACPHY1X1IPA;
			} else {
				pi->min_txpower = PHY_TXPWR_MIN_ACPHY1X1EPA;
			}
		} else {
			pi->min_txpower = PHY_TXPWR_MIN_ACPHY;
		}
	}
}

int8
wlc_phy_txpwrctrl_update_minpwr_acphy(phy_info_t *pi)
{
	int8 mintxpwr = WL_RATE_DISABLED;
	/* Set min_txpower */
	wlc_phy_txpwrctrl_setminpwr(pi);

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	/* Return value
	 * If WLOLPC defined
	 * - equals tssivisible threshold before OLPC cal done
	 * - equals OLPC ppr thresh after OLPC cal done
	 * Else
	 * - equals WL_RATE_DISABLED
	 */
	mintxpwr = wlc_phy_get_thresh_acphy(pi);
#else
	/* Return value
	 * If WLOLPC defined
	 * - equals tssivisible threshold
	 * Else
	 * - equals WL_RATE_DISABLED
	 */
	mintxpwr = wlc_phy_tssivisible_thresh_acphy(pi);
#endif /* PHYCAL_CACHING || WLMCHAN || WL_MODESW */
	return mintxpwr;
}

#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
void
BCMATTACHFN(wlc_phy_tx_target_pwr_per_channel_limit_acphy)(phy_info_t *pi)
{ /* Limit the max and min offset values */
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 core;
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
	uint32	bw;
#endif /* POWPERCHANNL5G || POWPERBAND5G */
#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G)
	uint8 ch_ind;
#endif /* POWPERCHANNL2G || POWPERCHANNL5G */
#ifdef POWPERBAND5G
	uint8 band_ind = 0;
#endif /* POWPERBAND5G */

	FOREACH_CORE(pi, core) {
#ifdef POWPERCHANNL2G
		uint temp;
		for (temp = PWR_PER_CH_NORM_TEMP; temp < PWR_PER_CH_MAX_TEMP; temp++) {
			for (ch_ind = 0; ch_ind < CH20MHz_NUM_2G; ch_ind++) {
				if (pwrdet->PwrOffsets2GTemp[temp][core][ch_ind] >
					PWR_PER_CH_POS_OFFSET_LIMIT_QDBM) {
					pwrdet->PwrOffsets2GTemp[temp][core][ch_ind] =
						PWR_PER_CH_POS_OFFSET_LIMIT_QDBM;
				} else if (pwrdet->PwrOffsets2GTemp[temp][core][ch_ind] <
						-PWR_PER_CH_NEG_OFFSET_LIMIT_QDBM) {
					pwrdet->PwrOffsets2GTemp[temp][core][ch_ind] =
						-PWR_PER_CH_NEG_OFFSET_LIMIT_QDBM;
				}
			}
		}
#endif /* POWPERCHANNL2G */
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
		for (bw = BW_20M; bw < BW_MAX; bw++) {
#ifdef POWPERCHANNL5G
			uint range;
			switch (bw) {
				case BW_20M:
					range = EDGE_CH20MHz_NUM_5G;
					break;
				case BW_40M:
					range = EDGE_CH40MHz_NUM_5G;
					break;
				case BW_80M:
					range = EDGE_CH80MHz_NUM_5G;
					break;
			}

			for (ch_ind = 0; ch_ind < range; ch_ind++) {
				if (pwrdet->PwrOffsets5GNormTemp[bw][core][ch_ind] >
					PWR_PER_CH_POS_OFFSET_LIMIT_QDBM) {
					pwrdet->PwrOffsets5GNormTemp[bw][core][ch_ind] =
						PWR_PER_CH_POS_OFFSET_LIMIT_QDBM;
				} else if (pwrdet->PwrOffsets5GNormTemp[bw][core][ch_ind] <
						-PWR_PER_CH_NEG_OFFSET_LIMIT_QDBM) {
					pwrdet->PwrOffsets5GNormTemp[bw][core][ch_ind] =
						-PWR_PER_CH_NEG_OFFSET_LIMIT_QDBM;
				}
			}
#endif /* POWPERCHANNL5G */

#ifdef POWPERBAND5G
			for (band_ind = 0; band_ind < CH_5G_4BAND; band_ind++) {
				if (pwrdet->SbPwrOffsets5GNormTemp[bw][core][band_ind] >
					PWR_PER_BAND_POS_OFFSET_LIMIT_QDBM) {
					pwrdet->SbPwrOffsets5GNormTemp[bw][core][band_ind] =
						PWR_PER_BAND_POS_OFFSET_LIMIT_QDBM;
				} else if (pwrdet->SbPwrOffsets5GNormTemp[bw][core][band_ind] <
						-PWR_PER_BAND_NEG_OFFSET_LIMIT_QDBM) {
					pwrdet->SbPwrOffsets5GNormTemp[bw][core][band_ind] =
						-PWR_PER_BAND_NEG_OFFSET_LIMIT_QDBM;
				}
			}
#endif /* POWPERBAND5G */
		}
#endif /* POWPERCHANNL5G || POWPERBAND5G */
	}
}
#endif /* POWPERCHANNL2G || POWPERCHANNL5G || POWPERBAND5G */

#ifdef POWPERCHANNL2G
void
wlc_phy_tx_target_pwr_per_channel_decide_run_acphy(phy_info_t *pi)
{ /* Decide if should recaculate power per channel due to temp diff */
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 ch = CHSPEC_CHANNEL(pi->radio_chanspec);
	int16 temp= pi->u.pi_acphy->current_temperature; /* Copy temperature without measuring */

	if (ch <= CH20MHz_NUM_2G) { /* 2 GHz channels only */
		if ((temp == INVTEMP) || (pwrdet->High2NormTemp == INVTEMP) ||
			(pwrdet->Low2NormTemp == INVTEMP)) {
			/* This temp value or thresholds are invalid.
			 * Do not decide based on temp.
			 */
			return;
		}

		/* Check if temperature measurement is in a different temperature zone, */
		/*	with margin, than the Target power settings. */
		if (((temp < pwrdet->Low2NormTemp - PWR_PER_CH_TEMP_MIN_STEP) &&
			(pwrdet->CurrentTempZone != PWR_PER_CH_LOW_TEMP)) ||
			((temp > pwrdet->High2NormTemp + PWR_PER_CH_TEMP_MIN_STEP) &&
			(pwrdet->CurrentTempZone != PWR_PER_CH_HIGH_TEMP)) ||
			((temp > pwrdet->Low2NormTemp + PWR_PER_CH_TEMP_MIN_STEP) &&
			(temp < pwrdet->High2NormTemp - PWR_PER_CH_TEMP_MIN_STEP) &&
			(pwrdet->CurrentTempZone != PWR_PER_CH_NORM_TEMP))) {
				wlc_phy_txpower_recalc_target_acphy(pi);
#ifdef WLTXPWR_CACHE
				/* Offsets have changed, cache is not valid anymore. */
				wlc_phy_txpwr_cache_invalidate(pi->txpwr_cache);
#endif /* WLTXPWR_CACHE */
		}
	}
}
#endif /* POWPERCHANNL2G */

#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
static void
wlc_phy_tx_target_pwr_per_channel_set_acphy(phy_info_t *pi)
{
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	uint8 core;
	uint8 BW_Band_ind = INVBAND;
	uint8 chan = CHSPEC_CHANNEL(pi->radio_chanspec);
	uint8 band = wlc_phy_get_chan_freq_range_acphy(pi, chan);
#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G)
	int ch_ind = INVCH;
#endif /* POWPERCHANNL2G || POWPERCHANNL5G */
#ifdef POWPERCHANNL2G
	int16 temp= pi->u.pi_acphy->current_temperature; /* Copy temperature without measuring */
#endif /* POWPERCHANNL2G */
#ifdef POWPERBAND5G
	uint8 sub_band = INVBAND;
#endif /* POWPERBAND5G */
#ifdef POWPERCHANNL5G
	uint8 edge_ch_id_5G_20M[EDGE_CH20MHz_NUM_5G] = { 36, 64, 100, 140, 144, 149, 165 };
	uint8 edge_ch_id_5G_40M[EDGE_CH40MHz_NUM_5G] = { 38, 62, 102, 142, 151 };
	uint8 edge_ch_id_5G_80M[EDGE_CH80MHz_NUM_5G] = { 42, 58, 106, 138, 155 };
	int	ArrayInd;
#endif /* POWPERCHANNL5G */

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* Identify the channel */
	if (CHSPEC_IS40(pi->radio_chanspec)) {
		BW_Band_ind = 2;
#ifdef POWPERCHANNL5G
		for (ArrayInd = 0; ArrayInd < EDGE_CH40MHz_NUM_5G; ArrayInd++) {
			if (chan == edge_ch_id_5G_40M[ArrayInd]) {
				ch_ind = ArrayInd;
				break;
			}
		}
#endif /* POWPERCHANNL5G */
	} else if (CHSPEC_IS80(pi->radio_chanspec)) {
		BW_Band_ind = 3;
#ifdef POWPERCHANNL5G
		for (ArrayInd = 0; ArrayInd < EDGE_CH80MHz_NUM_5G; ArrayInd++) {
			if (chan == edge_ch_id_5G_80M[ArrayInd]) {
				ch_ind = ArrayInd;
				break;
			}
		}
#endif /* POWPERCHANNL5G */
	} else {   /* must be 20MHz */
		BW_Band_ind = 1;
#ifdef POWPERCHANNL5G
		for (ArrayInd = 0; ArrayInd < EDGE_CH20MHz_NUM_5G; ArrayInd++) {
			if (chan == edge_ch_id_5G_20M[ArrayInd]) {
				ch_ind = ArrayInd;
				break;
			}
		}
#endif /* POWPERCHANNL5G */
	}

#ifdef POWPERCHANNL2G
	if (band == WL_CHAN_FREQ_RANGE_2G) {
		BW_Band_ind = 0;
		ch_ind = chan-1;
	}
#endif /* POWPERCHANNL2G */

#ifdef POWPERBAND5G
		if (CH_IS_LOW_5G(chan))
			sub_band = 0;
		else if (CH_IS_MID_5G(chan))
			sub_band = 1;
		else if (CH_IS_HIGH_5G(chan))
			sub_band = 2;
		else if (CH_IS_X1_5G(chan))
			sub_band = 3;
		else
			sub_band = INVBAND;
#else /* POWPERBAND5G */

#ifdef POWPERCHANNL5G
	if (ch_ind == INVCH) {
		/* Not an Edge Channel, but might need to revert max power to regular value */
		BW_Band_ind = INVBAND;
	}
#endif /* POWPERCHANNL5G */

#endif /* POWPERBAND5G */

	FOREACH_CORE(pi, core) {
		switch (BW_Band_ind) {
#ifdef POWPERCHANNL2G
		case 0: /* 2GHz */
			if ((pwrdet->Low2NormTemp != 0xff) &&
				(temp < pwrdet->Low2NormTemp) &&
				(temp != INVTEMP)) {
				pwrdet->CurrentTempZone = PWR_PER_CH_LOW_TEMP;
			} else if ((pwrdet->High2NormTemp != 0xff) &&
				(temp > pwrdet->High2NormTemp) &&
				(temp != INVTEMP)) {
				pwrdet->CurrentTempZone = PWR_PER_CH_HIGH_TEMP;
			} else {
				pwrdet->CurrentTempZone = PWR_PER_CH_NORM_TEMP;
			}

			pwrdet->max_pwr[core][0] = pwrdet->max_pwr_SROM2G[core] +
				pwrdet->PwrOffsets2GTemp[pwrdet->CurrentTempZone][core][ch_ind];

			PHY_TXPWR(("wl%d: %s: core = %d  ChannelInd=%d Temprature=%d, ",
				pi->sh->unit, __FUNCTION__,
				core, ch_ind, temp));
			PHY_TXPWR(("Ch max pwr=%d, 2G max pwr =%d, Offset = %d \n",
				pwrdet->max_pwr[core][0],
				pwrdet->max_pwr_SROM2G[core],
				pwrdet->PwrOffsets2GTemp[pwrdet->CurrentTempZone][core][ch_ind]));
			break;
#endif /* POWPERCHANNL2G */
#if defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
		case 1: /* 5GHz 20MHz */
		case 2: /* 5GHz 40MHz */
		case 3: /* 5GHz 80MHz */
			pwrdet->max_pwr[core][band] =
				pwrdet->max_pwr_SROM5G[core][band - CH_2G_GROUP];
#ifdef POWPERCHANNL5G
			if (ch_ind != INVCH) {
				pwrdet->max_pwr[core][band] +=
					pwrdet->PwrOffsets5GNormTemp[BW_Band_ind-1]
						[core][ch_ind];
			}
#endif /* POWPERCHANNL5G */
#ifdef POWPERBAND5G
			if (sub_band != INVBAND) {
				pwrdet->max_pwr[core][band] +=
					pwrdet->SbPwrOffsets5GNormTemp[BW_Band_ind-1]
						[core][sub_band];
			}
#endif /* POWPERBAND5G */
			break;

		case INVBAND:
		default:
			pwrdet->max_pwr[core][band] = pwrdet->max_pwr_SROM5G[core]
				[band - CH_2G_GROUP];
#endif /* POWPERCHANNL5G || POWPERBAND5G */
		}
	}
}
#endif /* POWPERCHANNL2G || POWPERCHANNL5G || POWPERBAND5G */

static void
wlc_phy_txpwrctrl_pwr_setup_acphy(phy_info_t *pi)
{
	uint8 stall_val;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	srom11_pwrdet_t *pwrdet = pi->pwrdet_ac;
	int8   target_min_limit;
	int16  a1[PAPARAM_SET_NUM], b0[PAPARAM_SET_NUM], b1[PAPARAM_SET_NUM];
	uint8  chan_freq_range;
	uint8  core, core2range, idx_set[2], k;
	int32  pwr_est, pwr_est2range;
	uint32 tbl_len, tbl_offset, idx, shfttbl_len;
	uint16 regval[128];
	uint32 shfttblval[24];
	uint8  tssi_delay, tssi_delay_cck = 0;
	uint32 pdoffs = 0;
	int16  tssifloor = 1023;
	uint8  maxpwr = 0;
	bool flag2rangeon;
#ifdef PREASSOC_PWRCTRL
	bool init_idx_carry_from_lastchan;
	uint8 step_size, prev_target_qdbm, iidx;
#endif // endif
	struct _tp_qtrdbm {
		uint8 core;
		int8 target_pwr_qtrdbm;
	} tp_qtrdbm_each_core[PHY_CORE_MAX]; /* TP for each core */
	uint core_count = 0;

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
	BCM_REFERENCE(ctx);
#endif /* PHYCAL || MCHAN */
#ifdef PREASSOC_PWRCTRL
	iidx = 0;
#endif // endif
	tbl_len = 128;
	tbl_offset = 0;
	shfttbl_len = 24;
	pi->txcal_status = 0;
	flag2rangeon =
		((CHSPEC_IS2G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi2g) ||
		(CHSPEC_IS5G(pi->radio_chanspec) && pi->u.pi_acphy->srom_tworangetssi5g)) &&
		PHY_IPA(pi);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_REG_LIST_START
		ACPHY_DISABLE_STALL_ENTRY(pi)
		/* enable TSSI */
		MOD_PHYREG_ENTRY(pi, TSSIMode, tssiEn, 1)
		MOD_PHYREG_ENTRY(pi, TxPwrCtrlCmd, txPwrCtrl_en, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Initialize ALL PA Param arrays a1, b0, b1 to be all zero */
	for (idx = 0; idx < PAPARAM_SET_NUM; idx++) {
		a1[idx] = 0;
		b0[idx] = 0;
		b1[idx] = 0;
	}

	if (TINY_RADIO(pi)) {
#ifndef WLC_POINT5_DB_TX_GAIN_STEP /* Disable 0.5 dB gain step */
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 0);
#ifdef PREASSOC_PWRCTRL
		step_size = 1;
#endif // endif
#else
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 1);
#ifdef PREASSOC_PWRCTRL
		step_size = 2;
#endif // endif
#endif /* Disable 0.5 dB gain step */

	} else if (RADIOREV(pi->pubpi.radiorev) == 4 || RADIOREV(pi->pubpi.radiorev) == 8 ||
	           ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev) ||
	           TINY_RADIO(pi)) {
		/* 4360B0/B1/4350 using 0.5dB-step gaintbl, bbmult interpolation enabled */
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 1);
#ifdef PREASSOC_PWRCTRL
		step_size = 2;
#endif // endif
	} else {
	/* disable bbmult interpolation
	   to work with a 0.25dB step txGainTbl
	*/
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 0);
#ifdef PREASSOC_PWRCTRL
		step_size = 1;
#endif // endif
	}

	/* Get pwrdet params from SROM for current subband */
	chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);
	/* Check if 2 range should be activated for band */

	FOREACH_CORE(pi, core) {
		/* First load PA Param sets for corresponding band/frequemcy range */
		/* for all cores 0 to PHYNUMCORE()-1 */
		switch (chan_freq_range) {
		case WL_CHAN_FREQ_RANGE_2G:
		case WL_CHAN_FREQ_RANGE_5G_BAND0:
		case WL_CHAN_FREQ_RANGE_5G_BAND1:
		case WL_CHAN_FREQ_RANGE_5G_BAND2:
		case WL_CHAN_FREQ_RANGE_5G_BAND3:
			a1[core] =  pwrdet->pwrdet_a1[core][chan_freq_range];
			b0[core] =  pwrdet->pwrdet_b0[core][chan_freq_range];
			b1[core] =  pwrdet->pwrdet_b1[core][chan_freq_range];
			PHY_TXPWR(("wl%d: %s: pwrdet core%d: a1=%d b0=%d b1=%d\n",
				pi->sh->unit, __FUNCTION__, core,
				a1[core], b0[core], b1[core]));
			break;
		}

		/* Set cck pwr offset from nvram */
		if (CHSPEC_IS2G(pi->radio_chanspec) && TINY_RADIO(pi)) {
			if (READ_PHYREGFLD(pi, perPktIdleTssiCtrlcck, base_index_cck_en) == 1) {
				MOD_PHYREGCEE(pi, TxPwrCtrlTargetPwr_path, core,
					cckPwrOffset, pi->cckpwroffset[core]);
			} else {
				MOD_PHYREGCEE(pi, TxPwrCtrlTargetPwr_path, core,
				cckPwrOffset, pi->cckpwroffset[core] - pi->sh->cckPwrIdxCorr);
			}
	    }
		/* Next if special consitions are met, load additional PA Param sets */
		/* for corresponding band/frequemcy range */
		if (flag2rangeon ||
		    (pi->u.pi_acphy->srom.tssi_div_war && ACMAJORREV_2(pi->pubpi.phy_rev))) {
			/* If two-range TSSI scheme is enabled via flag2rangeon, */
			/* or if TSSI divergence WAR is enable for 4350, load PHYCORENUM() */
			/* additional PA Param sets for corresponding band/frequemcy range. */
			/* For 4350, extra PA Params are used for CCK in 2G band or */
			/* for 40/80 MHz bands in 5G band */
			core2range = PHYCORENUM(pi->pubpi.phy_corenum) + core;
			ASSERT(core2range < PAPARAM_SET_NUM);
			a1[core2range] = pi->pwrdet_ac->pwrdet_a1[core2range][chan_freq_range];
			b0[core2range] = pi->pwrdet_ac->pwrdet_b0[core2range][chan_freq_range];
			b1[core2range] = pi->pwrdet_ac->pwrdet_b1[core2range][chan_freq_range];

			PHY_TXPWR(("wl%d: %s: pwrdet %s core%d: a1=%d b0=%d b1=%d\n",
			           pi->sh->unit, __FUNCTION__,
			           (flag2rangeon) ? "2nd-TSSI" : "CCK/40/80MHz",
			           core, a1[core2range], b0[core2range], b1[core2range]));
		} else if (pi->u.pi_acphy->srom.tssi_div_war && (ACMAJORREV_1(pi->pubpi.phy_rev) ||
			TINY_RADIO(pi))) {
			/* If TSSI divergence WAR is enable for 4335, */
			/* use core1 and core2 paparams for 40Mhz and 40/80 paparams. */
			a1[1] =	pwrdet->pwrdet_a1[1][chan_freq_range];
			b0[1] =	pwrdet->pwrdet_b0[1][chan_freq_range];
			b1[1] =	pwrdet->pwrdet_b1[1][chan_freq_range];
			PHY_TXPWR(("wl%d: %s: pwrdet 40mhz case: %d: a1=%d b0=%d b1=%d\n",
				pi->sh->unit, __FUNCTION__, 1,
				a1[1], b0[1], b1[1]));

			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				a1[2] =	pwrdet->pwrdet_a1[2][chan_freq_range];
				b0[2] =	pwrdet->pwrdet_b0[2][chan_freq_range];
				b1[2] =	pwrdet->pwrdet_b1[2][chan_freq_range];
				PHY_TXPWR(("wl%d: %s: pwrdet 80mhz case: %d: a1=%d b0=%d b1=%d\n",
					pi->sh->unit, __FUNCTION__, 2,
					a1[2], b0[2], b1[2]));
			}
		}
	}

	/* target power */
	wlc_phy_txpwrctrl_update_minpwr_acphy(pi);
	target_min_limit = pi->min_txpower * WLC_TXPWR_DB_FACTOR;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		int8 target_pwr_qtrdbm;
		target_pwr_qtrdbm = (int8)pi->tx_power_max_per_core[core];
		/* never target below the min threashold */
		if (target_pwr_qtrdbm < target_min_limit)
			target_pwr_qtrdbm = target_min_limit;

		if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev)) {
			chan_freq_range = wlc_phy_get_chan_freq_range_acphy(pi, 0);
			tssifloor = (int16)pwrdet->tssifloor[core][chan_freq_range];
			if ((tssifloor != 0x3ff) && (tssifloor != 0)) {
				maxpwr = wlc_phy_set_txpwr_clamp_acphy(pi, core);
				if (maxpwr < target_pwr_qtrdbm) {
					target_pwr_qtrdbm = maxpwr;
				}
			}
		}

		tp_qtrdbm_each_core[core_count].core = core;
		tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm = target_pwr_qtrdbm;
		++core_count;
	        /* PHY_ERROR(("####targetPwr: %d#######\n",
	         * tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm));
		 */
	}

	/* determine pos/neg TSSI slope */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_PHYREG(pi, TSSIMode, tssiPosSlope, pi->fem2g.tssipos);
	} else {
		MOD_PHYREG(pi, TSSIMode, tssiPosSlope, pi->fem5g.tssipos);
	}
	MOD_PHYREG(pi, TSSIMode, tssiPosSlope, 1);

	/* disable txpwrctrl during idleTssi measurement, etc */
	MOD_PHYREG(pi, TxPwrCtrlCmd, txPwrCtrl_en, 0);
	if (flag2rangeon) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_PHYREG(pi, TxPwrCtrlPwrRange2, maxPwrRange2, 80);
			MOD_PHYREG(pi, TxPwrCtrlPwrRange2, minPwrRange2, 44);
		} else {
			MOD_PHYREG(pi, TxPwrCtrlPwrRange2, maxPwrRange2, 80);
			MOD_PHYREG(pi, TxPwrCtrlPwrRange2, minPwrRange2, 44);
		}
	} else {
		MOD_PHYREG(pi, TxPwrCtrlPwrRange2, maxPwrRange2, 0);
		MOD_PHYREG(pi, TxPwrCtrlPwrRange2, minPwrRange2, 1);
	}

#ifdef PREASSOC_PWRCTRL
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		init_idx_carry_from_lastchan = (CHSPEC_IS5G(pi->radio_chanspec)) ?
		        pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_5g[core]
		        : pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_2g[core];
		if (!init_idx_carry_from_lastchan) {
			/* 4360B0 using 0.5dB-step gaintbl so start with a lower starting idx */
			if ((RADIOREV(pi->pubpi.radiorev) == 4) ||
			    (RADIOREV(pi->pubpi.radiorev) == 8) ||
			    (RADIOREV(pi->pubpi.radiorev) == 10) ||
			    (RADIOREV(pi->pubpi.radiorev) == 7) ||
			    (RADIOREV(pi->pubpi.radiorev) == 11)) {
				iidx = 20;
			} else if (((RADIOREV(pi->pubpi.radiorev) == 40) ||
			  (RADIOREV(pi->pubpi.radiorev) == 44) ||
			  (RADIOREV(pi->pubpi.radiorev) == 46)) && (PHY_XTAL_IS40M(pi))) {
				/* 43569/43570 */
				iidx = 10;
			} else {
				iidx = 50;
			}
#ifdef WLC_TXCAL
			if (pi->olpc_idx_in_use && pi->olpc_idx_valid) {
				wlc_phy_olpc_idx_tempsense_comp_acphy(pi, &iidx, core);
			}
#endif // endif
			MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core, pwrIndex_init_path, iidx);
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_5g[core] = TRUE;
			} else {
				pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_2g[core] = TRUE;
			}
			/* XXX This is the handshake for te code that
			   is put in for open loop power control
			   128 means do NOT restore the value in the
			   open loop function
			*/
			pi_ac->txpwrindex_hw_save[core] = 128;
		} else {
			/* set power index initial condition */
			int32 new_iidx;
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				iidx = pi->u.pi_acphy->pwr_ctrl_save.status_idx_5g[core];
				prev_target_qdbm = pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_5g[core];
				if ((pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core])) {
					/* XXX This is the handshake for
					   the code that is put in for open loop power control
					   128 means do NOT restore the value in the
					   open loop function
					*/
					pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core]
					        = FALSE;
					pi_ac->txpwrindex_hw_save[core] = 128;

				}
			} else {
				iidx = pi->u.pi_acphy->pwr_ctrl_save.status_idx_2g[core];
				prev_target_qdbm = pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_2g[core];
				if ((pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_2g[core])) {
					/* XXX This is the handshake for
					   the code that is put in for open loop power control
					   128 means do NOT restore the value in the
					   open loop function
					*/
					pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_2g[core] =
					        FALSE;
					pi_ac->txpwrindex_hw_save[core] = 128;

				}
			}
			new_iidx = (int32)iidx + ((int32)tp_qtrdbm_each_core[core].target_pwr_qtrdbm
			          - prev_target_qdbm) / step_size;

			/* XXX Sanity Check
			   XXX make sure iidx is within bounds to be safe
			*/
			if (new_iidx < PWRCTRL_MIN_INIT_IDX) {
				iidx = PWRCTRL_MIN_INIT_IDX;
			} else if (new_iidx > PWRCTRL_MAX_INIT_IDX) {
				iidx = PWRCTRL_MAX_INIT_IDX;
			} else {
				iidx = (uint8)new_iidx;
			}

			MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core, pwrIndex_init_path, iidx);
		}
	}
#else
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	if (!ctx || !ctx->valid) {
#endif /* PHYCAL_CACHING || MCHAN */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
#ifdef WLC_TXCAL
			if (pi->olpc_idx_valid && pi->olpc_idx_in_use) {
				wlc_phy_olpc_idx_tempsense_comp_acphy(pi,
					&pi->base_index_init[core], core);
				if (TINY_RADIO(pi)) {
					wlc_phy_olpc_idx_tempsense_comp_acphy(pi,
						&pi->base_index_cck_init[core], core);
				}
			}
#endif /* WLC_TXCAL */
			wlc_phy_txpwrctrl_set_baseindex(pi, core,
				pi->base_index_init[core], ACPHY_ENC_OFDM);
			if (TINY_RADIO(pi)) {
				wlc_phy_txpwrctrl_set_baseindex(pi, core,
					pi->base_index_cck_init[core], ACPHY_ENC_CCK);
			}
		}
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	}
#endif /* PHYCAL_CACHING || MCHAN */
#endif /* PREASSOC_PWRCTRL */
	/* MOD_PHYREG(pi, TxPwrCtrlIdleTssi, rawTssiOffsetBinFormat, 1); */

	/* sample TSSI at 7.5us */
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_TSSIAVG) {
			tssi_delay = 150;
			ACPHY_REG_LIST_START
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, Ntssi_intg_log2, 4)
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, tssi_accum_en, 1)
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, tssi_filter_pos, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
			MOD_PHYREG(pi, TssiAccumCtrl, Ntssi_accum_delay, tssi_delay);
		} else {
			if (PHY_IPA(pi)) {
				tssi_delay = 170;
			} else {
				if (CHSPEC_IS2G(pi->radio_chanspec)) {
					if (pi->u.pi_acphy->srom_2g_pdrange_id == 21) {
						tssi_delay = 200;
					} else {
						tssi_delay = 150;
					}
				} else {
					if (pi->u.pi_acphy->srom_5g_pdrange_id == 23) {
						tssi_delay = 200;
					} else {
						tssi_delay = 150;
					}
				}
			}
		}
	} else if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
		TINY_RADIO(pi)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			tssi_delay = 150;
		} else {
			tssi_delay = 150;
		}
		if (TINY_RADIO(pi)) {
			tssi_delay = 100;
			if (PHY_IPA(pi)) {
				tssi_delay_cck =  110;
			} else {
				tssi_delay_cck =  115;
			}
		}
		if (PHY_IPA(pi) && !(TINY_RADIO(pi))) {		/* this is for 4335C0 iPA */
			tssi_delay = 170;
		} else {
			/* Enable tssi accum for C0. also change the tssi digi filter position. */
			/* this helps to reduce the tssi noise. */
			MOD_PHYREG(pi, TssiAccumCtrl, Ntssi_accum_delay, tssi_delay);
			ACPHY_REG_LIST_START
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, Ntssi_intg_log2, 4)
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, tssi_accum_en, 1)
				MOD_PHYREG_ENTRY(pi, TssiAccumCtrl, tssi_filter_pos, 1)
			ACPHY_REG_LIST_EXECUTE(pi);
			if (TINY_RADIO(pi)) {
				MOD_PHYREG(pi, TssiAccumCtrlcck, Ntssi_accum_delay_cck,
					tssi_delay_cck);
				MOD_PHYREG(pi, TssiAccumCtrlcck, Ntssi_intg_log2_cck, 1);
				MOD_PHYREG(pi, perPktIdleTssiCtrlcck, base_index_cck_en, 1);
			}
		}
	} else {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (pi->u.pi_acphy->srom_2g_pdrange_id >= 5) {
				tssi_delay = 200;
			} else if (pi->u.pi_acphy->srom_2g_pdrange_id >= 4) {
				tssi_delay = 220;
			} else {
				tssi_delay = 150;
			}
		} else {
			if (pi->u.pi_acphy->srom_5g_pdrange_id >= 5) {
				tssi_delay = 200;
			} else if (pi->u.pi_acphy->srom_5g_pdrange_id >= 4) {
				tssi_delay = 220;
			} else {
				tssi_delay = 150;
			}
		}
	}
	MOD_PHYREG(pi, TxPwrCtrlNnum, Ntssi_delay, tssi_delay);
	if (pi->bphy_scale != 0) {
		MOD_PHYREG(pi, BphyControl3, bphyScale20MHz, pi->bphy_scale);
	}

#if defined(PREASSOC_PWRCTRL) && !defined(WLC_LOW_ONLY)
	/* average over 2 or 16 packets */
	wlc_phy_pwrctrl_shortwindow_upd_acphy(pi, pi->channel_short_window);
#else
	MOD_PHYREG(pi, TxPwrCtrlNnum, Npt_intg_log2, PWRCTRL_LONGW_AVG);
#endif /* PREASSOC_PWRCTRL */

	/* decouple IQ comp and LOFT comp from Power Control */
	MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsIQ, 0);
	if (ACREV_IS(pi->pubpi.phy_rev, 1) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		if ((CHSPEC_IS5G(pi->radio_chanspec) &&
		    (pi->u.pi_acphy->srom.epa_on_during_txiqlocal) &&
		    !(pi->u.pi_acphy->srom.precal_tx_idx)) ||
		    (pi->sh->boardtype == BCM94360MCM5)) {
			MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 0);
		} else {
			MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 1);
		}
	} else if (ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi) &&
		CHSPEC_IS5G(pi->radio_chanspec)) {
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsIQ, 1);
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 1);
	} else {
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 0);
	}

#if defined(WLC_TXPWRCAP)
	wlc_phy_txpwrcap_set_acphy(pi);
#else
#ifdef WL_SARLIMIT
	wlc_phy_set_sarlimit_acphy(pi);
#endif // endif
#endif /* WLC_TXPWRCAP */

	while (core_count > 0) {
		--core_count;
		if (pi_ac->offset_targetpwr) {
			uint8 tgt_pwr_qdbm = tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm;
			tgt_pwr_qdbm -= (pi_ac->offset_targetpwr << 2);
			wlc_phy_txpwrctrl_set_target_acphy(pi, tgt_pwr_qdbm,
				tp_qtrdbm_each_core[core_count].core);
		} else {
			/* set target powers */
			wlc_phy_txpwrctrl_set_target_acphy(pi,
				tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm,
				tp_qtrdbm_each_core[core_count].core);
		}
		PHY_TXPWR(("wl%d: %s: txpwrctl[%d]: %d\n",
			pi->sh->unit, __FUNCTION__, tp_qtrdbm_each_core[core_count].core,
		              tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm));
	}
#ifdef ENABLE_FCBS
	if (IS_FCBS(pi) && pi->phy_fcbs.FCBS_INPROG)
		pi->phy_fcbs.FCBS_INPROG = 0;
	else {
#endif // endif
	/* load estimated power tables (maps TSSI to power in dBm)
	 *    entries in tx power table 0000xxxxxx
	 */
	tbl_len = 128;
	tbl_offset = 0;

	if (pi->u.pi_acphy->srom.tssi_div_war && (ACMAJORREV_1(pi->pubpi.phy_rev) ||
		TINY_RADIO(pi))) {

		if (CHSPEC_IS80(pi->radio_chanspec) && CHSPEC_IS5G(pi->radio_chanspec)) {
			/* core 2 conatins 40-80mhz paparam
			 * core 0 conatins 20mhz paparam
			 */
			idx_set[0] = 2; idx_set[1] = 0;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			/* core 1 conatins 40mhz paparam
			 * core 0 contains 20mhz paparam
			 */
			idx_set[0] = 1; idx_set[1] = 0;
			if (PHY_IPA(pi) && CHSPEC_IS2G(pi->radio_chanspec)) {
			    idx_set[0] = 0; idx_set[1] = 1;
			}
		} else {
			/* core 0 conatins 20mhz OFDM paparam
			 * core 1 contains 20mhz CCK paparam
			 */
			idx_set[0] = 0;
			if (!TINY_RADIO(pi))
				idx_set[1] = 1;
			else
				idx_set[1] = 0;
		}

		for (idx = 0; idx < tbl_len; idx++) {
			for (k = 0, regval[idx] = 0; k < 2; k++) {
				core = idx_set[k];

				pwr_est = wlc_phy_tssi2dbm_acphy(pi, idx,
				                                 a1[core], b0[core], b1[core]);

				regval[idx] |= (uint16)(pwr_est&0xff) << (8*k);
			}
		}

#if defined(WLC_TXCAL)
		if (pi->txcal_pwr_tssi_tbl_in_use == 1)
			wlc_phy_apply_pwr_tssi_tble_chan_acphy(pi);
		else
#endif // endif
			/* Est Pwr Table is 128x16 Table for 4335 */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS0, tbl_len,
			        tbl_offset, 16, regval);

	} else if (pi->u.pi_acphy->srom.tssi_div_war && ACMAJORREV_2(pi->pubpi.phy_rev)) {
		if ((CHSPEC_IS80(pi->radio_chanspec) || CHSPEC_IS40(pi->radio_chanspec)) &&
		    CHSPEC_IS5G(pi->radio_chanspec) && !PHY_IPA(pi)) {
			/* core 2/3 contains 40-80mhz paparam
			 * core 0/1 contains 20mhz paparam
			 */
			idx_set[0] = 2; idx_set[1] = 0;
		} else if (CHSPEC_IS20(pi->radio_chanspec) &&
		    CHSPEC_IS2G(pi->radio_chanspec) && PHY_IPA(pi)) {
			/* core 0,1 conatins 20mhz OFDM paparam
			 * core 2,3 contains 20mhz CCK paparam
			 */
			idx_set[0] = 0;  idx_set[1] = 2;
		} else {
			idx_set[0] = 0; idx_set[1] = 0;
		}

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			uint8 core_off;

			for (idx = 0; idx < tbl_len; idx++) {
				for (k = 0, regval[idx] = 0; k < 2; k++) {
					core_off = core + ((core < 2)  ?
					                   idx_set[k] : 0);

					pwr_est = wlc_phy_tssi2dbm_acphy(pi, idx,
					                                 a1[core_off],
					                                 b0[core_off],
					                                 b1[core_off]);

					regval[idx] |= (uint16)(pwr_est&0xff) << (8*k);
				}
			}
#if defined(WLC_TXCAL)
			if (pi->txcal_pwr_tssi_tbl_in_use == 1)
				wlc_phy_apply_pwr_tssi_tble_chan_acphy(pi);
			else
#endif // endif
				/* Est Pwr Table is 128x8 Table. Limit Write to 8 bits */
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core),
				        tbl_len, tbl_offset, 16, regval);

		}
	} else {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			for (idx = 0; idx < tbl_len; idx++) {
				pwr_est = wlc_phy_tssi2dbm_acphy(pi, idx,
				                                 a1[core], b0[core], b1[core]);
				if (flag2rangeon) {
					/* iPa - ToDo 2 range TSSI */
					core2range = PHYCORENUM(pi->pubpi.phy_corenum) + core;
					ASSERT(core2range < PAPARAM_SET_NUM);

					pwr_est2range = wlc_phy_tssi2dbm_acphy(pi, idx,
					                                       a1[core2range],
					                                       b0[core2range],
					                                       b1[core2range]);

					regval[idx] =
						(uint16)((pwr_est2range&0xff) +
						((pwr_est&0xff)<<8));
				} else {
					regval[idx] = (uint16)(pwr_est&0xff);
				}
			}
#if defined(WLC_TXCAL)
			if (pi->txcal_pwr_tssi_tbl_in_use == 1)
				wlc_phy_apply_pwr_tssi_tble_chan_acphy(pi);
			else
#endif // endif
				/* Est Pwr Table is 128x8 Table. Limit Write to 8 bits */
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core),
				        tbl_len, tbl_offset, 16, regval);
		}
	}

	if (ACMAJORREV_3((pi)->pubpi.phy_rev) && IBOARD(pi)) {
		if (pi->open_loop_pwrctrl_init) {
			MOD_PHYREG(pi, TxPwrCtrlTargetPwr_path0, targetPwr0, 0);
			wlc_phy_tiny_rfseq_mode_set(pi, 1);
			pi->open_loop_targetidx = wlc_phy_tone_pwrctrl(pi, 0, 0);
			pi->open_loop_targetidx = MIN(MAX(pi->open_loop_targetidx, 0), 127);
			wlc_phy_tiny_rfseq_mode_set(pi, 0);
			pi->open_loop_pwrctrl_init = 0;
			wlc_phy_tempsense_acphy_tiny(pi);
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				if ((pi->u.pi_acphy->current_temperature <= 0) ||
					(pi->u.pi_acphy->current_temperature > 200)) {
					pi->open_loop_targetidx += 48;
				} else if ((pi->u.pi_acphy->current_temperature > 0) &&
					(pi->u.pi_acphy->current_temperature < 50)) {
					pi->open_loop_targetidx += 22;
				}
			}
		} else {
			pi->open_loop_targetidx +=
				-((int8)READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path0, targetPwr0) -
				pi->open_loop_old_target);
		}
		wlc_phy_txpwr_by_index_acphy(pi, 1, MIN(MAX(pi->open_loop_targetidx, 0), 127));
		pi->open_loop_old_target =
			READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path0, targetPwr0);
	}

	/* start to populate estPwrShftTbl */
	for (idx = 0; idx < 24; idx++) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if ((idx == 0)||((idx > 1)&&(idx < 5))||((idx > 6)&&(idx < 10))) {
				shfttblval[idx] = 0;
			} else if ((idx == 1) ||((idx > 4)&&(idx < 7)) || (idx == 14)) {
				pdoffs = 0;
				FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
					pdoffs = wlc_phy_pdoffset_cal_acphy(pdoffs,
						pwrdet->pdoffset40[core], chan_freq_range, core);
				}
				shfttblval[idx] = pdoffs & 0xffffff;
				if ((idx == 5) && (pi->u.pi_acphy->srom.tssi_div_war &&
					(ACMAJORREV_1(pi->pubpi.phy_rev)|| TINY_RADIO(pi)))) {
					shfttblval[idx] = 0;
				}
				if ((pi->root_pwr_tssi_lut_5G40.txcal_pwr_tssi.channel != 0) &&
				        (pi->txcal_pwr_tssi_tbl_in_use == 1)) {
					/* If 40mhz txcal table is present */
					/* Do not apply pdoffset */
					shfttblval[idx] = 0;
				}
			} else if (idx == 10) {
				pdoffs = 0;
				FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
					pdoffs = wlc_phy_pdoffset_cal_acphy(pdoffs,
						pwrdet->pdoffset80[core], chan_freq_range, core);
				}
				shfttblval[idx] = pdoffs & 0xffffff;
				if ((pi->root_pwr_tssi_lut_5G80.txcal_pwr_tssi.channel != 0) &&
				        (pi->txcal_pwr_tssi_tbl_in_use == 1)) {
					/* If 80mhz txcal table is present */
					/* Do not apply pdoffset */
					shfttblval[idx] = 0;
				}
			} else {
				shfttblval[idx] = 0;
			}
		} else {
			/* hardcoding for 4335 wlbga for now, will add nvram var later if needed */
			if (CHIPID(pi->sh->chip) == BCM4345_CHIP_ID ||
#ifdef UNRELEASEDCHIP
			    CHIPID(pi->sh->chip) == BCM43457_CHIP_ID ||
#endif /* UNRELEASEDCHIP */
				(CHIPID(pi->sh->chip) == BCM4335_CHIP_ID &&
				CHSPEC_IS2G(pi->radio_chanspec) &&
				CHSPEC_IS20(pi->radio_chanspec))) {
				if (pi->u.pi_acphy->srom.tssi_div_war) {
					/* Note: SROM entry rpcal2g and rpcal5gb0 is redefined for
					 * 4335 to represent the 2G channel-dependent TSSI offset
					 */
					if (idx == 3 || idx == 17) {
						switch (CHSPEC_CHANNEL(pi->radio_chanspec)) {
						case 1:
							pdoffs = ((pi->sh->rpcal2g >> 0)  & 0xF);
							break;
						case 2:
							pdoffs = ((pi->sh->rpcal2g >> 4)  & 0xF);
							break;
						case 3:
							pdoffs = ((pi->sh->rpcal2g >> 8)  & 0xF);
							break;
						case 12:
							pdoffs = ((pi->sh->rpcal2g >> 12) & 0xF);
							break;
						case 13:
							pdoffs = ((pi->sh->rpcal5gb0 >> 0) & 0xF);
							break;
						case 14:
							pdoffs = ((pi->sh->rpcal5gb0 >> 4) & 0xF);
							break;
						case 4:
							pdoffs = ((pi->sh->rpcal5gb0 >> 8) & 0xF);
							break;
						case 5:
							pdoffs = ((pi->sh->rpcal5gb0 >> 12) & 0xF);
							break;
						case 6:
							pdoffs = ((pi->sh->rpcal5gb1 >> 0) & 0xF);
							break;
						case 7:
							pdoffs = ((pi->sh->rpcal5gb1 >> 4) & 0xF);
							break;
						case 8:
							pdoffs = ((pi->sh->rpcal5gb1 >> 8) & 0xF);
							break;
						case 9:
							pdoffs = ((pi->sh->rpcal5gb1 >> 12) & 0xF);
							break;
						case 10:
							pdoffs = ((pi->sh->rpcal5gb2 >> 0) & 0xF);
							break;
						case 11:
							pdoffs = ((pi->sh->rpcal5gb2 >> 4) & 0xF);
							break;

						default:
							pdoffs = 0;
							break;
						}
						pdoffs = (pdoffs > 7) ? (0xf0 | pdoffs) : pdoffs;
						shfttblval[idx] = pdoffs & 0xff;
					} else {
						shfttblval[idx] = 0;
					}
				} else { /* when tssi_div WAR is off, only cck offset is used */
					if (idx == 17) {
						pdoffs = pwrdet->pdoffsetcck[0];
						pdoffs = (pdoffs > 7) ? (0xf0 | pdoffs) : pdoffs;
						shfttblval[idx] = pdoffs & 0xff;
					} else {
						shfttblval[idx] = 0;
					}
				}
			} else {
				if (idx == 17) {
					pdoffs = 0;
					FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
						pdoffs = wlc_phy_pdoffset_cal_acphy(pdoffs,
							pwrdet->pdoffsetcck[core],
							chan_freq_range, core);
					}
					shfttblval[idx] = pdoffs & 0xffffff;
				} else {
					if (pwrdet->pdoffset2g40_flag == 1) {
						shfttblval[idx] = 0;
					} else {
						shfttblval[idx] = 0;
						if (idx == 5) {
							pdoffs = 0;
							FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain,
								core) {
								pdoffs =
								wlc_phy_pdoffset_cal_acphy(pdoffs,
								        pwrdet->pdoffset2g40[core],
								       chan_freq_range, core);
							}
							shfttblval[idx] = pdoffs & 0xffffff;
						}
					}
				}
			}
		}
	}
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRSHFTLUTS, shfttbl_len,
	                          tbl_offset, 32, shfttblval);
#ifdef ENABLE_FCBS
	}
#endif // endif

	ACPHY_ENABLE_STALL(pi, stall_val);
}

#ifdef SROM12
static void
wlc_phy_txpwrctrl_pwr_setup_srom12_acphy(phy_info_t *pi)
{
	uint8 stall_val;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	srom12_pwrdet_t *pwrdet = pi->pwrdet12_ac;
	int16  a[PHY_CORE_MAX], b[PHY_CORE_MAX];
	int16  c[PHY_CORE_MAX], d[PHY_CORE_MAX];
	int32  firstTerm = 0, secondTerm = 0, thirdTerm = 0, fourthTerm = 0;
	int32  ctrSqr[128], idx;
	int8   target_min_limit;
	uint8  chan_freq_range, iidx, chan_freq, poffs = 0;
	uint32 pdoffs = 0;
	uint8  core;
	uint32 shfttbl_len = 24, shfttblval[24], idx1;
	int32  pwr_est, tbl_len, tbl_offset;
	uint16 regval[128];
	uint8  tssi_delay = 0;

#ifdef PREASSOC_PWRCTRL
	bool init_idx_carry_from_lastchan;
	uint8 step_size, prev_target_qdbm;
#endif // endif
	struct _tp_qtrdbm {
		uint8 core;
		int8 target_pwr_qtrdbm;
	} tp_qtrdbm_each_core[PHY_CORE_MAX]; /* TP for each core */
	uint core_count = 0;

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
	BCM_REFERENCE(ctx);
#endif /* PHYCAL || MCHAN */
	iidx = 0;
	tbl_len = 128;
	tbl_offset = 0;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_REG_LIST_START
		ACPHY_DISABLE_STALL_ENTRY(pi)
		/* enable TSSI */
		MOD_PHYREG_ENTRY(pi, TSSIMode, tssiEn, 1)
		MOD_PHYREG_ENTRY(pi, TxPwrCtrlCmd, txPwrCtrl_en, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* initialize a, b, c,d to be all zero */
	for (idx = 0; idx < PHY_CORE_MAX; idx++) {
		a[idx] = 0;
		b[idx] = 0;
		c[idx] = 0;
		d[idx] = 0;
	}

	if (RADIOREV(pi->pubpi.radiorev) == 4 || RADIOREV(pi->pubpi.radiorev) == 8 ||
	    ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* 4360B0/B1/4350 using 0.5dB-step gaintbl, bbmult interpolation enabled */
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 1);
#ifdef PREASSOC_PWRCTRL
		step_size = 2;
#endif // endif
	} else {
		/* disable bbmult interpolation
		   to work with a 0.25dB step txGainTbl
		*/
		MOD_PHYREG(pi, TxPwrCtrlCmd, bbMultInt_en, 0);
#ifdef PREASSOC_PWRCTRL
		step_size = 1;
#endif // endif
	}

	/* Get pwrdet params from SROM for current subband */
	chan_freq_range = wlc_phy_get_chan_freq_range_srom12_acphy(pi, 0);

	FOREACH_CORE(pi, core) {
		switch (chan_freq_range) {
		case WL_CHAN_FREQ_RANGE_2G:
		case WL_CHAN_FREQ_RANGE_5G_BAND0:
		case WL_CHAN_FREQ_RANGE_5G_BAND1:
		case WL_CHAN_FREQ_RANGE_5G_BAND2:
		case WL_CHAN_FREQ_RANGE_5G_BAND3:
		case WL_CHAN_FREQ_RANGE_5G_BAND4:
			a[core] =  pwrdet->pwrdet_a[core][chan_freq_range];
			b[core] =  pwrdet->pwrdet_b[core][chan_freq_range];
			c[core] =  pwrdet->pwrdet_c[core][chan_freq_range];
			d[core] =  pwrdet->pwrdet_d[core][chan_freq_range];
			break;
		case WL_CHAN_FREQ_RANGE_2G_40:
		case WL_CHAN_FREQ_RANGE_5G_BAND0_40:
		case WL_CHAN_FREQ_RANGE_5G_BAND1_40:
		case WL_CHAN_FREQ_RANGE_5G_BAND2_40:
		case WL_CHAN_FREQ_RANGE_5G_BAND3_40:
		case WL_CHAN_FREQ_RANGE_5G_BAND4_40:
			/* Adjust index for 40M */
			a[core] =  pwrdet->pwrdet_a_40[core][chan_freq_range - 6];
			b[core] =  pwrdet->pwrdet_b_40[core][chan_freq_range - 6];
			c[core] =  pwrdet->pwrdet_c_40[core][chan_freq_range - 6];
			d[core] =  pwrdet->pwrdet_d_40[core][chan_freq_range - 6];
			break;
		case WL_CHAN_FREQ_RANGE_5G_BAND0_80:
		case WL_CHAN_FREQ_RANGE_5G_BAND1_80:
		case WL_CHAN_FREQ_RANGE_5G_BAND2_80:
		case WL_CHAN_FREQ_RANGE_5G_BAND3_80:
		case WL_CHAN_FREQ_RANGE_5G_BAND4_80:
			/* Adjust index for 80M */
			a[core] =  pwrdet->pwrdet_a_80[core][chan_freq_range - 12];
			b[core] =  pwrdet->pwrdet_b_80[core][chan_freq_range - 12];
			c[core] =  pwrdet->pwrdet_c_80[core][chan_freq_range - 12];
			d[core] =  pwrdet->pwrdet_d_80[core][chan_freq_range - 12];
			break;
		default:
			PHY_ERROR(("wl%d: %s: pwrdet core%d: a=%d b=%d c=%d d=%d\n",
			           pi->sh->unit, __FUNCTION__, core,
			           a[core], b[core], c[core], d[core]));
			break;
		}

		switch (core) {
		case 0:
			if (a[0] == 0) {
				a[0] = 0x16EE;
				b[0] = 0xC886;
				c[0] = 0x0C9C;
				d[0] = 0x2188;
				PHY_INFORM(("%s: using default pa params for core 0.\n",
				            __FUNCTION__));
			}
			break;
		case 1:
			if (a[1] == 0) {
				a[1] = 0x1659;
				b[1] = 0xC998;
				c[1] = 0x0D7F;
				d[1] = 0x21BF;
				PHY_INFORM(("%s: using default pa params for core 1.\n",
				            __FUNCTION__));
			}
			break;
		case 2:
			if (a[2] == 0) {
				a[2] = 0x1665;
				b[2] = 0xC964;
				c[2] = 0x0DCD;
				d[2] = 0x21D2;
				PHY_INFORM(("%s: using default pa params for core 2.\n",
				            __FUNCTION__));
			}
			break;
		default:
			break;
		}
	}

	/* target power */
	wlc_phy_txpwrctrl_update_minpwr_acphy(pi);
	target_min_limit = pi->min_txpower * WLC_TXPWR_DB_FACTOR;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		int8 target_pwr_qtrdbm;
		target_pwr_qtrdbm = (int8)pi->tx_power_max_per_core[core];
		/* never target below the min threashold */
		if (target_pwr_qtrdbm < target_min_limit)
			target_pwr_qtrdbm = target_min_limit;

		tp_qtrdbm_each_core[core_count].core = core;
		tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm = target_pwr_qtrdbm;
		++core_count;
	        /* PHY_ERROR(("####targetPwr: %d#######\n",
	         * tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm));
		 */
	}

	/* determine pos/neg TSSI slope */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_PHYREG(pi, TSSIMode, tssiPosSlope, pi->fem2g.tssipos);
	} else {
		MOD_PHYREG(pi, TSSIMode, tssiPosSlope, pi->fem5g.tssipos);
	}
	MOD_PHYREG(pi, TSSIMode, tssiPosSlope, 1);

	/* disable txpwrctrl during idleTssi measurement, etc */
	MOD_PHYREG(pi, TxPwrCtrlCmd, txPwrCtrl_en, 0);

#ifdef PREASSOC_PWRCTRL
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		init_idx_carry_from_lastchan = (CHSPEC_IS5G(pi->radio_chanspec)) ?
		        pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_5g[core]
		        : pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_2g[core];
		if (!init_idx_carry_from_lastchan) {
			/* 4360B0 using 0.5dB-step gaintbl so start with a lower starting idx */
			if ((RADIOREV(pi->pubpi.radiorev) == 4) ||
			    (RADIOREV(pi->pubpi.radiorev) == 7) ||
			    (RADIOREV(pi->pubpi.radiorev) == 8) ||
			    (RADIOREV(pi->pubpi.radiorev) == 10) ||
			    (RADIOREV(pi->pubpi.radiorev) == 11)) {
				iidx = 20;
			} else {
				iidx = 50;
			}
			MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core, pwrIndex_init_path, iidx);
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_5g[core] = TRUE;
			} else {
				pi->u.pi_acphy->pwr_ctrl_save.status_idx_carry_2g[core] = TRUE;
			}
			/* XXX This is the handshake for te code that
			   is put in for open loop power control
			   128 means do NOT restore the value in the
			   open loop function
			*/
			pi_ac->txpwrindex_hw_save[core] = 128;
		} else {
			/* set power index initial condition */
			int32 new_iidx;

			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				iidx = pi->u.pi_acphy->pwr_ctrl_save.status_idx_5g[core];
				prev_target_qdbm = pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_5g[core];
				if ((pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core])) {
					/* XXX This is the handshake for
					   the code that is put in for open loop power control
					   128 means do NOT restore the value in the
					   open loop function
					*/
					pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core]
					        = FALSE;
					pi_ac->txpwrindex_hw_save[core] = 128;

				}
			} else {
				iidx = pi->u.pi_acphy->pwr_ctrl_save.status_idx_2g[core];
				prev_target_qdbm = pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_2g[core];
				if ((pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_2g[core])) {
					/* XXX This is the handshake for
					   the code that is put in for open loop power control
					   128 means do NOT restore the value in the
					   open loop function
					*/
					pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_2g[core] =
					        FALSE;
					pi_ac->txpwrindex_hw_save[core] = 128;

				}
			}
			new_iidx = (int32)iidx + ((int32)tp_qtrdbm_each_core[core].target_pwr_qtrdbm
			                          - prev_target_qdbm) / step_size;

			/* XXX Sanity Check
			   XXX make sure iidx is within bounds to be safe
			*/
			if (new_iidx < PWRCTRL_MIN_INIT_IDX) {
				iidx = PWRCTRL_MIN_INIT_IDX;
			} else if (new_iidx > PWRCTRL_MAX_INIT_IDX) {
				iidx = PWRCTRL_MAX_INIT_IDX;
			} else {
				iidx = (uint8)new_iidx;
			}

			MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core, pwrIndex_init_path, iidx);
		}
	}
#else
	if ((RADIOREV(pi->pubpi.radiorev) == 4) || (RADIOREV(pi->pubpi.radiorev) == 7) ||
	    (RADIOREV(pi->pubpi.radiorev) == 8) || (RADIOREV(pi->pubpi.radiorev) == 10) ||
	    (RADIOREV(pi->pubpi.radiorev) == 11)) {
		iidx = 20;
	} else {
		iidx = 50;
	}
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	if (!ctx || !ctx->valid)
#endif /* PHYCAL_CACHING || MCHAN */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_PHYREGCEE(pi, TxPwrCtrlInit_path, core,
			              pwrIndex_init_path, iidx);
		}
#endif /* PREASSOC_PWRCTRL */
	/* MOD_PHYREG(pi, TxPwrCtrlIdleTssi, rawTssiOffsetBinFormat, 1); */

	/* sample TSSI at 7.5us */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		if (pi->u.pi_acphy->srom_2g_pdrange_id >= 5) {
			tssi_delay = 150;
		} else if (pi->u.pi_acphy->srom_2g_pdrange_id >= 4) {
			tssi_delay = 220;
		} else {
			tssi_delay = 150;
		}
	} else {
		if (pi->u.pi_acphy->srom_5g_pdrange_id >= 5) {
			tssi_delay = 150;
		} else if (pi->u.pi_acphy->srom_5g_pdrange_id >= 4) {
			tssi_delay = 220;
		} else {
			tssi_delay = 150;
		}
	}
	MOD_PHYREG(pi, TxPwrCtrlNnum, Ntssi_delay, tssi_delay);

#if defined(PREASSOC_PWRCTRL) && !defined(WLC_LOW_ONLY)
	/* average over 2 or 16 packets */
	wlc_phy_pwrctrl_shortwindow_upd_acphy(pi, pi->channel_short_window);
#else
	MOD_PHYREG(pi, TxPwrCtrlNnum, Npt_intg_log2, PWRCTRL_LONGW_AVG);
#endif /* PREASSOC_PWRCTRL */

	/* decouple IQ comp and LOFT comp from Power Control */
	MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsIQ, 0);
	if (ACREV_IS(pi->pubpi.phy_rev, 1) ||
	    ACREV_IS(pi->pubpi.phy_rev, 9)) {
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 1);
	} else {
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 0);
	}

#ifdef WL_SARLIMIT
	wlc_phy_set_sarlimit_acphy(pi);
#endif // endif
	while (core_count > 0) {
		--core_count;
		if (pi_ac->offset_targetpwr) {
			uint8 tgt_pwr_qdbm = tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm;
			tgt_pwr_qdbm -= (pi_ac->offset_targetpwr << 2);
			wlc_phy_txpwrctrl_set_target_acphy(pi,
			                                   tgt_pwr_qdbm,
			                                   0);
		} else {
			/* set target powers */
			wlc_phy_txpwrctrl_set_target_acphy(pi,
			                                   tp_qtrdbm_each_core[core_count].
			                                   target_pwr_qtrdbm,
			                                   tp_qtrdbm_each_core[core_count].
			                                   core);
		}
		PHY_TXPWR(("wl%d: %s: txpwrctl[%d]: %d\n",
		           pi->sh->unit, __FUNCTION__, tp_qtrdbm_each_core[core_count].core,
		           tp_qtrdbm_each_core[core_count].target_pwr_qtrdbm));
	}
#ifdef ENABLE_FCBS
	if (IS_FCBS(pi) && pi->phy_fcbs.FCBS_INPROG)
		pi->phy_fcbs.FCBS_INPROG = 0;
	else {
#endif // endif
		/* load estimated power tables (maps TSSI to power in dBm)
		 *    entries in tx power table 0000xxxxxx
		 */
		tbl_len = 128;
		tbl_offset = 0;

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			for (idx = 0; idx < tbl_len; idx++) {
				ctrSqr[idx] = idx * idx;
				if (CHSPEC_IS5G(pi->radio_chanspec) ||
				    pi->u.pi_acphy->srom_2g_pdrange_id == 24) {
					firstTerm  = (int32)a[core] * 128;
					secondTerm = ((int32)b[core] * idx) / 2;
					thirdTerm  = ((int32)c[core] * ctrSqr[idx]) / 128;
					fourthTerm = ((int32)d[core] * idx) /
					        (((int32)idx - 128));
					pwr_est = MAX((firstTerm + secondTerm + thirdTerm +
					               fourthTerm) / 8192, 0);
					pwr_est = MIN(pwr_est, 0x7f);
				} else {
					firstTerm = (int32)a[core] * 16;
					secondTerm = (b[core] * ctrSqr[idx]) / 4096;
					if (idx == 0)
						thirdTerm = 0;
					else
						thirdTerm = c[core] * ctrSqr[idx] /
						        (ctrSqr[idx] - ((int32)d[core] * 2));
					pwr_est = MAX((firstTerm + secondTerm + thirdTerm)
					              / 1024, 0);
					pwr_est = MIN(pwr_est, 0x7f);
				}
				regval[idx] = (uint16)(pwr_est&0xff);
				PHY_TXPWR(("%s: EstPower Table (core =%d),(idx = %d),Value = %u \n",
				           __FUNCTION__, core, idx, regval[idx]));
			}
			/* Est Pwr Table is 128x8 Table. Limit Write to 8 bits */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core), tbl_len,
			                          tbl_offset, 16, regval);
		}

		/* start to populate estPwrShftTbl */
		for (idx1 = 0; idx1 < shfttbl_len; idx1++) {
		  if (CHSPEC_IS5G(pi->radio_chanspec)) {
		    if (CHSPEC_IS80(pi->radio_chanspec)) {
		      chan_freq = chan_freq_range - 12;
		    } else if (CHSPEC_IS40(pi->radio_chanspec)) {
		      chan_freq = chan_freq_range - 7;
		    } else {
		      chan_freq = chan_freq_range - 1;
		    }
		    if ((idx1 == 0)||((idx1 > 6)&&(idx1 < 10))) {
		      pdoffs = 0;
		      FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			poffs = (uint8)(pwrdet->pdoffset20in80[core][chan_freq]);
			poffs = (poffs > 15) ? (0xe0 | poffs) : poffs;
			pdoffs = pdoffs | (poffs << core*8);
		      }
		      shfttblval[idx1] = pdoffs & 0xffffff;
		    } else if ((idx1 == 1)||(idx1 == 6)) {
		      pdoffs = 0;
		      FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			poffs = (uint8)(pwrdet->pdoffset40in80[core][chan_freq]);
			poffs = (poffs > 15) ? (0xe0 | poffs) : poffs;
			pdoffs = pdoffs | (poffs << core*8);
		      }
		      shfttblval[idx1] = pdoffs & 0xffffff;
		    } else if ((idx1 == 2) || (idx1 == 4)) {
		      pdoffs = 0;
		      FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			poffs = (uint8)(pwrdet->pdoffset20in40[core][chan_freq]);
			poffs = (poffs > 15) ? (0xe0 | poffs) : poffs;
			pdoffs = pdoffs | (poffs << core*8);
		      }
		      shfttblval[idx1] = pdoffs & 0xffffff;
		    } else {
		      shfttblval[idx1] = 0;
		    }
		  } else {
		    if (idx1 == 17) {
		      pdoffs = 0;
		      FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
			poffs = (uint8)(pwrdet->pdoffsetcck[core]);
			poffs = (poffs > 15) ? (0xe0 | poffs) : poffs;
			pdoffs = pdoffs | (poffs << core*8);
		      }
		      shfttblval[idx1] = pdoffs & 0xffffff;
		    } else {
		      shfttblval[idx1] = 0;
		    }
		  }
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRSHFTLUTS, shfttbl_len,
		                          tbl_offset, 32, shfttblval);

#ifdef ENABLE_FCBS
	}
#endif // endif

	ACPHY_ENABLE_STALL(pi, stall_val);
}
#endif /* SROM12 */

#if defined(WL_SARLIMIT) || defined(BCM_OL_DEV) || defined(WL_SAR_SIMPLE_CONTROL)
void
wlc_phy_set_sarlimit_acphy(phy_info_t *pi)
{
	uint core;
	int16 txpwr_sarcap[3] = { 0, 0, 0 };
	ASSERT(pi->sh->clk);
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		txpwr_sarcap[core] = pi->sarlimit[core];
#ifdef WL_SARLIMIT
		if ((pi->u.pi_acphy->txpwr_offset[core] != 0) &&
		    !CHSPEC_IS5G(pi->radio_chanspec))
			txpwr_sarcap[core] = wlc_phy_calc_adjusted_cap_rgstr_acphy(pi, core);
#endif // endif
	}

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 0)
	        MOD_PHYREG(pi, TxPwrCapping_path0,
	                   maxTxPwrCap_path0, txpwr_sarcap[0]);
	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 1)
	        MOD_PHYREG(pi, TxPwrCapping_path1,
	                   maxTxPwrCap_path1, txpwr_sarcap[1]);
	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 2)
	        MOD_PHYREG(pi, TxPwrCapping_path2,
	                   maxTxPwrCap_path2, txpwr_sarcap[2]);
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}
#endif /* WL_SARLIMIT || BCM_OL_DEV || WL_SAR_SIMPLE_CONTROL */

#ifdef WL_SAR_SIMPLE_CONTROL
void wlc_phy_dynamic_sarctrl_set(wlc_phy_t *pi, bool isctrlon)
{
	phy_info_t *piinfo = (phy_info_t*)pi;
	uint32 sarctrlmap = 0;

	if (isctrlon) {
		switch (wlc_phy_chanspec_bandrange_get(piinfo, piinfo->radio_chanspec)) {
			case WL_CHAN_FREQ_RANGE_2G:
				sarctrlmap = piinfo->dynamic_sarctrl_2g;
				break;
		#ifdef BAND5G
			case WL_CHAN_FREQ_RANGE_5GL:
			case WL_CHAN_FREQ_RANGE_5GM:
			case WL_CHAN_FREQ_RANGE_5GH:
				sarctrlmap = piinfo->dynamic_sarctrl_5g;
				break;
		#endif /* BAND5G */
			default:
				break;
		}
	} else {
		sarctrlmap = 0;
	}
	wlc_phy_sar_limit_set_percore(pi, sarctrlmap);
}
#endif /* WL_SAR_SIMPLE_CONTROL */

#if defined(WLC_TXPWRCAP)
static void
wlc_phy_txpwrcap_attach_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 i;

	/* By default TxPwerCap state has CellOn state */
	pi_ac->txpwrcap_cellstatus = TXPWRCAP_CELLSTATUS_ON;
	for (i = 0; i < TXPWRCAP_MAX_NUM_CORES; i++) {
		pi_ac->txpwrcap_tbl.num_antennas_per_core[i] = 2;
	}
	for (i = 0; i < TXPWRCAP_MAX_NUM_ANTENNAS; i++) {
		pi_ac->txpwrcap_tbl.pwrcap_cell_off[i] = ACPHY_TXPOWERCAP_MAX_QDB;
		pi_ac->txpwrcap_tbl.pwrcap_cell_on[i] = ACPHY_TXPOWERCAP_MAX_QDB;
	}
}

static void
wlc_phy_txpwrcap_set_acphy(phy_info_t *pi)
{
	uint core;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	int8 txpwrcap[WLC_TXCORE_MAX] = {ACPHY_TXPOWERCAP_MAX_QDB,
		ACPHY_TXPOWERCAP_MAX_QDB,
		ACPHY_TXPOWERCAP_MAX_QDB,
		ACPHY_TXPOWERCAP_MAX_QDB};
	int8 *txcap = NULL;

	ASSERT(pi->sh->clk);
	/* Don't suspend for 4350, WAR for Radar 16456610, and Radar 16279351 */
	if (CHIPID(pi->sh->chip) != BCM4350_CHIP_ID)
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

	wlc_phyreg_enter((wlc_phy_t *)pi);

	if (wlc_phy_txpwrcap_get_cellstatus_acphy(pi))
		txcap = pi_ac->txpwrcap_tbl.pwrcap_cell_on;
	else
		txcap = pi_ac->txpwrcap_tbl.pwrcap_cell_off;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (!pi_ac->txpwrcap_tbl.num_antennas_per_core[core]) {
			PHY_ERROR(("%s: Tx Power Caps not provided for core %d antennas\n",
				__FUNCTION__, core));
		  break;
		}
		else if	(pi_ac->txpwrcap_tbl.num_antennas_per_core[core] == 1)
			txpwrcap[core] = txcap[core*2];
		else {
			if (core == 0) {
				/* Based on swOvr, choose either 0 or 1 antennae for core 0 */
				txpwrcap[core] = txcap[pi_ac->ant_swOvr_state_core0 ? 1 : 0];
			} else {
				/* Currently support just one antenna for all cores other than 0 */
				txpwrcap[core] = txcap[core*2];
			}
		}
	}

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 0)
		MOD_PHYREG(pi, TxPwrCapping_path0,
			maxTxPwrCap_path0, txpwrcap[0] - pi->tx_pwr_backoff);
	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 1)
		MOD_PHYREG(pi, TxPwrCapping_path1,
			maxTxPwrCap_path1, txpwrcap[1] - pi->tx_pwr_backoff);
	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 2)
		MOD_PHYREG(pi, TxPwrCapping_path2,
			maxTxPwrCap_path2, txpwrcap[2] - pi->tx_pwr_backoff);
	wlc_phyreg_exit((wlc_phy_t *)pi);

	if (CHIPID(pi->sh->chip) != BCM4350_CHIP_ID)
		wlapi_enable_mac(pi->sh->physhim);
}

uint32
wlc_phy_get_txpwrcap_inuse_acphy(phy_info_t *pi)
{
	uint32 cap_in_use = 0;

	ASSERT(pi->sh->clk);

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 0)
		cap_in_use = READ_PHYREGFLD(pi, TxPwrCapping_path0, maxTxPwrCap_path0);

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 1)
		cap_in_use = cap_in_use | (READ_PHYREGFLD(pi, TxPwrCapping_path1,
			maxTxPwrCap_path1) << 8);

	IF_ACTV_CORE(pi, pi->sh->phyrxchain, 2)
		cap_in_use = cap_in_use | (READ_PHYREGFLD(pi, TxPwrCapping_path2,
			maxTxPwrCap_path2) << 16);

	return cap_in_use;
}

int
wlc_phy_txpwrcap_tbl_get_acphy(phy_info_t *pi, wl_txpwrcap_tbl_t *txpwrcap_tbl)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8 i, j = 0, k;

	for (i = 0; i < TXPWRCAP_MAX_NUM_CORES; i++) {
		txpwrcap_tbl->num_antennas_per_core[i] =
			pi_ac->txpwrcap_tbl.num_antennas_per_core[i];
		for (k = 0; k < pi_ac->txpwrcap_tbl.num_antennas_per_core[i]; k++) {
			txpwrcap_tbl->pwrcap_cell_off[j] =
				pi_ac->txpwrcap_tbl.pwrcap_cell_off[2*i+k];
			txpwrcap_tbl->pwrcap_cell_on[j] =
				pi_ac->txpwrcap_tbl.pwrcap_cell_on[2*i+k];
			j++;
		}
	}

	return BCME_OK;
}

int
wlc_phy_txpwrcap_tbl_set_acphy(phy_info_t *pi, wl_txpwrcap_tbl_t *txpwrcap_tbl)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8 i, j = 0, k;
	int err = 0;
	uint8 num_antennas = 0, max_antennas = 0, min_antennas = 0;
	uint core;

	/* Some Error Checking */
	for (i = 0; i < TXPWRCAP_MAX_NUM_CORES; i++)
		num_antennas += txpwrcap_tbl->num_antennas_per_core[i];
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		max_antennas += 2;
		min_antennas++;
	}
	if ((num_antennas > max_antennas) || (num_antennas < min_antennas))
		return BCME_ERROR;

	for (i = 0; i < TXPWRCAP_MAX_NUM_CORES; i++) {
		pi_ac->txpwrcap_tbl.num_antennas_per_core[i] =
			txpwrcap_tbl->num_antennas_per_core[i];
		for (k = 0; k < pi_ac->txpwrcap_tbl.num_antennas_per_core[i]; k++) {
			pi_ac->txpwrcap_tbl.pwrcap_cell_off[2*i+k] =
				txpwrcap_tbl->pwrcap_cell_off[j];
			pi_ac->txpwrcap_tbl.pwrcap_cell_on[2*i+k] =
				txpwrcap_tbl->pwrcap_cell_on[j];
			j++;
		}
	}

	/* Apply the new caps */
	if (pi->sh->clk)
		wlc_phy_txpwrcap_set_acphy(pi);

	return err;
}

#endif /* WLC_TXPWRCAP */

static uint32
wlc_phy_pdoffset_cal_acphy(uint32 pdoffs, uint16 pdoffset, uint8 band, uint8 core)
{
	uint8 pdoffs_t;
	switch (band) {
	case WL_CHAN_FREQ_RANGE_2G:
		pdoffs_t = pdoffset & 0xf; break;
	case WL_CHAN_FREQ_RANGE_5G_BAND0:
		pdoffs_t = pdoffset & 0xf; break;
	case WL_CHAN_FREQ_RANGE_5G_BAND1:
		pdoffs_t = (pdoffset >> 4) & 0xf; break;
	case WL_CHAN_FREQ_RANGE_5G_BAND2:
		pdoffs_t = (pdoffset >> 8) & 0xf; break;
	case WL_CHAN_FREQ_RANGE_5G_BAND3:
		pdoffs_t = (pdoffset >> 12) & 0xf; break;
	default:
		pdoffs_t = pdoffset & 0xf; break;
	}

	pdoffs_t = (pdoffs_t > 7) ? (0xf0|pdoffs_t) : pdoffs_t;
	pdoffs   = pdoffs | (pdoffs_t << core*8);
	return pdoffs;

}

/* set txgain in case txpwrctrl is disabled (fixed power) */
static void
wlc_phy_txpwr_fixpower_acphy(phy_info_t *pi)
{
	uint8 core;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_txpwr_by_index_acphy(pi, (1 << core), pi->u.pi_acphy->txpwrindex[core]);
	}
}

static void
wlc_phy_rx_iq_comp_acphy(phy_info_t *pi, uint8 write, phy_iq_comp_t *pcomp, uint8 rx_core)
{
	/* write: 0 - fetch values from phyregs into *pcomp
	 *        1 - deposit values from *pcomp into phyregs
	 *        2 - set all coeff phyregs to 0
	 *
	 * rx_core: specify which core to fetch/deposit
	 */

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(write <= 2);

	/* write values */
	if (write == 0) {
		pcomp->a = READ_PHYREGCE(pi, Core1RxIQCompA, rx_core);
		pcomp->a = READ_PHYREGCE(pi, Core1RxIQCompB, rx_core);
	} else if (write == 1) {
		WRITE_PHYREGCE(pi, Core1RxIQCompA, rx_core, pcomp->a);
		WRITE_PHYREGCE(pi, Core1RxIQCompB, rx_core, pcomp->b);
	} else {
		WRITE_PHYREGCE(pi, Core1RxIQCompA, rx_core, 0);
		WRITE_PHYREGCE(pi, Core1RxIQCompB, rx_core, 0);
	}
}

#if defined(BCMDBG_RXCAL)
static void
wlc_phy_rxcal_snr_acphy(phy_info_t *pi, uint16 num_samps, uint8 core_mask)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint16 bbmult_orig[PHY_CORE_MAX], bbmult_zero = 0;
	phy_iq_est_t  noise_vals[PHY_CORE_MAX];
	uint8 core;

	/* take noise measurement (for SNR calc, for information purposes only) */
	FOREACH_ACTV_CORE(pi, core_mask, core) {
		wlc_phy_get_tx_bbmult_acphy(pi, &(bbmult_orig[core]), core);
		wlc_phy_set_tx_bbmult_acphy(pi, &bbmult_zero, core);
	}

	wlc_phy_rx_iq_est_acphy(pi, noise_vals, num_samps, 32, 0, FALSE);

	FOREACH_ACTV_CORE(pi, core_mask, core) {
		/* Store the noise powers for SNR calculations later */
		pi_ac->rxcal_noise[core].i_pwr = noise_vals[core].i_pwr;
		pi_ac->rxcal_noise[core].q_pwr = noise_vals[core].q_pwr;
		pi_ac->rxcal_noise[core].iq_prod = noise_vals[core].iq_prod;
	}

	FOREACH_ACTV_CORE(pi, core_mask, core) {
		wlc_phy_set_tx_bbmult_acphy(pi, &(bbmult_orig[core]), core);
	}
}
#endif /* BCMDBG_RXCAL */

static void
wlc_phy_rxcal_phy_setup_acphy_save_rfctrl(phy_info_t *pi, uint8 core, acphy_rxcal_phyregs_t *porig)
{
	porig->txpwridx[core] = pi->u.pi_acphy->txpwrindex[core];

	porig->RfctrlOverrideTxPus[core] = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
	porig->RfctrlOverrideRxPus[core] = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
	porig->RfctrlOverrideGains[core] = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
	porig->RfctrlOverrideLpfCT[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfCT, core);
	porig->RfctrlOverrideLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfSwtch,
		core);
	porig->RfctrlOverrideAfeCfg[core] = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
	porig->RfctrlOverrideLowPwrCfg[core] = READ_PHYREGCE(pi, RfctrlOverrideLowPwrCfg,
		core);
	porig->RfctrlOverrideAuxTssi[core] = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);

	porig->RfctrlCoreTxPus[core] = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
	porig->RfctrlCoreRxPus[core] = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
	porig->RfctrlCoreTXGAIN1[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN1, core);
	porig->RfctrlCoreTXGAIN2[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN2, core);
	porig->RfctrlCoreRXGAIN1[core] = READ_PHYREGCE(pi, RfctrlCoreRXGAIN1, core);
	porig->RfctrlCoreRXGAIN2[core] = READ_PHYREGCE(pi, RfctrlCoreRXGAIN2, core);
	porig->RfctrlCoreLpfGain[core] = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
	porig->RfctrlCoreLpfCT[core] = READ_PHYREGCE(pi, RfctrlCoreLpfCT, core);
	porig->RfctrlCoreLpfGmult[core] = READ_PHYREGCE(pi, RfctrlCoreLpfGmult, core);
	porig->RfctrlCoreRCDACBuf[core] = READ_PHYREGCE(pi, RfctrlCoreRCDACBuf, core);
	porig->RfctrlCoreLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlCoreLpfSwtch, core);
	porig->RfctrlCoreAfeCfg1[core] = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
	porig->RfctrlCoreAfeCfg2[core] = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
	porig->RfctrlCoreLowPwr[core] = READ_PHYREGCE(pi, RfctrlCoreLowPwr, core);
	porig->RfctrlCoreAuxTssi1[core] = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
	porig->RfctrlCoreAuxTssi2[core] = READ_PHYREGCE(pi, RfctrlCoreAuxTssi2, core);
	porig->Dac_gain[core] = READ_PHYREGCE(pi, Dac_gain, core);

	wlc_phy_get_tx_bbmult_acphy(pi, &(porig->bbmult[core]), core);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		&porig->rfseq_txgain[core+0]);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		&porig->rfseq_txgain[core+3]);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		&porig->rfseq_txgain[core+6]);

	porig->RfctrlIntc[core] = READ_PHYREGCE(pi, RfctrlIntc, core);
}

static void
wlc_phy_rxcal_phy_setup_acphy_core_lpf(phy_info_t *pi, uint8 core, uint8 bw_idx)
{
	uint16 addr_lo, val16;

	if (TINY_RADIO(pi)) {
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_adc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_adc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_rc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_rc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_bq2, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_bq2, 1);
	} else {
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_rc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_adc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_bq2, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_adc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_rc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_bq2, 1);
	}

	MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_adc, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_adc, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_aux_bq1, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_aux_bq1, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_iqcal_bq1, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_iqcal_bq1, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_tia_bq1, 1);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_tia_bq1, 1);

	addr_lo = (bw_idx < 2) ? 0x140 + 0x10 * core + bw_idx :	0x441 + 0x2 * core;
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, addr_lo, 16, &val16);

	MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_bq1_bw, val16 & 7);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_bq1_bw, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_bq2_bw, (val16 >> 3) & 7);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_bq2_bw, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfGmult, core, lpf_g_mult, (val16 >> 6) & 0xff);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_g_mult, 1);

	MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_dc_bypass, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_dc_bypass, 1);
	MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_q_biq2, 1);
	MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_q_biq2, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, lpf_pu_dc, 1);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_pu_dc, 1);
}

static void
wlc_phy_rxcal_phy_setup_acphy_core(phy_info_t *pi, uint8 core, uint8 bw_idx, uint16 sdadc_config)
{
	/* XXX RF External Settings
	 *   - Power Down External PA,
	 *   - T/R on T to protect against interference
	 */

	MOD_PHYREGCE(pi, RfctrlIntc, core, ext_2g_papu, 0);
	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
	    (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
	    (CHSPEC_IS5G(pi->radio_chanspec))) {
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_5g_papu, 1);
	} else {
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_5g_papu, 0);
	}
	MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_pa, 1);

	/* XXX Skip for now.
	   MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 1);
	   MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
	   MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
	   */

	/* XXX Required for loopback to work correctly
	*/
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, fast_nap_bias_pu, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, fast_nap_bias_pu, (TINY_RADIO(pi)) ? 0 : 1);

	if (TINY_RADIO(pi)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_pwrup, 1);
		} else {
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_5G_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_5G_pwrup, 1);
		}

		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, logen_rx_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, logen_rx_pwrup, 1);
	}

	/* XXX RfCtrl
	 *   - turn off Internal PA
	 *   - turn off LNA1 to protect against interference and reduce thermal noise
	 *   - force LPF to Rx Chain
	 *   - force LPF bw
	 *   - NOTE: this also saves off state of possible Tx/Rx gain override states
	 */

	/* Setting the SD-ADC related stuff */
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, sdadc_config & 0x7);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_iqadc_pwrup,
		(sdadc_config >> 3) & 0x3f);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd,
		(sdadc_config >> 9) & 0x1);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_flashhspd, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl,
		(sdadc_config >> 10) & 0x1);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_ctrl_flash17lvl, 1);
	MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_adc_bias,
		(sdadc_config >> 11) & 0x3);
	MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_adc_bias, 1);

	/* Turning off all the RF component that are not needed */
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_pwrup, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna1_pwrup, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna1_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_wrssi2_pwrup, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_wrssi2_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, lpf_nrssi_pwrup, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_nrssi_pwrup, 1);
	MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, lpf_wrssi3_pwrup, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_wrssi3_pwrup, 1);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rssi_wb1g_pu, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1g_pu, 1);
	} else {
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rssi_wb1a_pu, 0);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1a_pu, 1);
	}

	/* Turn on PA for iPA chip, turn off for ePA chip */
	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) {
		MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, pa_pwrup, 0);
	} else {
		MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, pa_pwrup, 1);
	}
	MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, pa_pwrup, 1);

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID && CHSPEC_IS5G(pi->radio_chanspec) &&
		(ISACPHY(pi) && ACREV_GT(pi->pubpi.phy_rev, 0))) {
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_pwrup, 1);
	}
	/* 4335a0/b0 epa : turn on lna2 */
	else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		(RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) &&
		ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) {
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_pwrup, 1);
	}
	else if (RADIOID(pi->pubpi.radioid) == BCM20691_ID && CHSPEC_IS5G(pi->radio_chanspec)) {
		/* Turn on 5G lna's see 'use_lna12' in acphyprocs.tcl and 20691_procs.tcl */
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna1_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_pwrup, 1);
	}
	MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, tia_DC_loop_PU, 1);
	MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, tia_DC_loop_PU, 1);

	wlc_phy_rxcal_phy_setup_acphy_core_lpf(pi, core, bw_idx);
}

static void
wlc_phy_rxcal_phy_setup_acphy(phy_info_t *pi)
{
	/* XXX Notes:
	 *   - also note that in the driver we do a resetCCA after this to be on the safe
	 *     side; may want to revisit this here, too, in case we run into issues
	 */

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_phyregs_t *porig = &(pi_ac->ac_rxcal_phyregs_orig);
	uint8 core;
	uint16 sdadc_config;
	uint8 bw_idx;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		bw_idx = 2;
		sdadc_config = sdadc_cfg80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		bw_idx = 1;
		if (pi->sdadc_config_override)
			sdadc_config = sdadc_cfg40hs;
		else
			sdadc_config = sdadc_cfg40;
	} else {
		bw_idx = 0;
		sdadc_config = sdadc_cfg20;
	}

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(!porig->is_orig);
	porig->is_orig = TRUE;
	porig->AfePuCtrl = READ_PHYREG(pi, AfePuCtrl);

	/* turn off tssi sleep feature during cal */
	MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 4)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_rxcal_phy_setup_acphy_save_rfctrl(pi, core, porig);
	}

	porig->RfseqCoreActv2059 = READ_PHYREG(pi, RfseqCoreActv2059);

	if (TINY_RADIO(pi)) {
		porig->RxSdFeConfig1 = READ_PHYREG(pi, RxSdFeConfig1);
		porig->RxSdFeConfig6 = READ_PHYREG(pi, RxSdFeConfig6);

		MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 1);
	}

	/* XXX Core Activate/Deactivate
	*   - for now, keep all rx's enabled for most realistic rx conditions
	*/
	MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, pi->sh->phyrxchain);
	MOD_PHYREG(pi, RfseqCoreActv2059, DisRx, 0);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_rxcal_phy_setup_acphy_core(pi, core, bw_idx, sdadc_config);

		porig->PapdEnable[core] = READ_PHYREGCE(pi, PapdEnable, core);
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_rxcal_phy_cleanup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_phyregs_t *porig = &(pi_ac->ac_rxcal_phyregs_orig);
	uint8 core;
	uint8 stall_val;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(porig->is_orig);
	porig->is_orig = FALSE;

	WRITE_PHYREG(pi, RfseqCoreActv2059, porig->RfseqCoreActv2059);

	if (TINY_RADIO(pi)) {
	WRITE_PHYREG(pi, RxSdFeConfig1, porig->RxSdFeConfig1);
	WRITE_PHYREG(pi, RxSdFeConfig6, porig->RxSdFeConfig6);
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
		&porig->rfseq_txgain[core + 0]);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
		&porig->rfseq_txgain[core + 3]);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
		&porig->rfseq_txgain[core + 6]);

		wlc_phy_txpwr_by_index_acphy(pi, (1 << core), porig->txpwridx[core]);
		wlc_phy_set_tx_bbmult_acphy(pi, &(porig->bbmult[core]), core);

		WRITE_PHYREGCE(pi, RfctrlIntc, core, porig->RfctrlIntc[core]);
		/* 20691 iTR trsw */
		if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
		}
		WRITE_PHYREGCE(pi, PapdEnable, core, porig->PapdEnable[core]);

		WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, porig->RfctrlOverrideTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, porig->RfctrlOverrideRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, porig->RfctrlOverrideGains[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfCT, core, porig->RfctrlOverrideLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,
			porig->RfctrlOverrideLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, porig->RfctrlOverrideAfeCfg[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, porig->RfctrlOverrideAuxTssi[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLowPwrCfg, core,
			porig->RfctrlOverrideLowPwrCfg[core]);

		WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, porig->RfctrlCoreTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, porig->RfctrlCoreRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, porig->RfctrlCoreTXGAIN1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, porig->RfctrlCoreTXGAIN2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core, porig->RfctrlCoreRXGAIN1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core, porig->RfctrlCoreRXGAIN2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, porig->RfctrlCoreLpfGain[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfCT, core, porig->RfctrlCoreLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGmult, core, porig->RfctrlCoreLpfGmult[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRCDACBuf, core, porig->RfctrlCoreRCDACBuf[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, porig->RfctrlCoreLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, porig->RfctrlCoreAfeCfg1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, porig->RfctrlCoreAfeCfg2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLowPwr, core, porig->RfctrlCoreLowPwr[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, porig->RfctrlCoreAuxTssi1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi2, core, porig->RfctrlCoreAuxTssi2[core]);
		WRITE_PHYREGCE(pi, Dac_gain, core, porig->Dac_gain[core]);
	}
	WRITE_PHYREG(pi, AfePuCtrl, porig->AfePuCtrl);
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RESET2RX);

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_rxcal_radio_setup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_radioregs_t *porig = &(pi_ac->ac_rxcal_radioregs_orig);
	uint16 tx_atten, rx_atten;
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	tx_atten = 0;
	rx_atten = 0;

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(!porig->is_orig);
	porig->is_orig = TRUE;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		porig->RF_2069_TXRX2G_CAL_TX[core] = READ_RADIO_REGC(pi, RF, TXRX2G_CAL_TX, core);
		porig->RF_2069_TXRX5G_CAL_TX[core] = READ_RADIO_REGC(pi, RF, TXRX5G_CAL_TX, core);
		porig->RF_2069_TXRX2G_CAL_RX[core] = READ_RADIO_REGC(pi, RF, TXRX2G_CAL_RX, core);
		porig->RF_2069_TXRX5G_CAL_RX[core] = READ_RADIO_REGC(pi, RF, TXRX5G_CAL_RX, core);
		porig->RF_2069_RXRF2G_CFG2[core] = READ_RADIO_REGC(pi, RF, RXRF2G_CFG2, core);
		porig->RF_2069_RXRF5G_CFG2[core] = READ_RADIO_REGC(pi, RF, RXRF5G_CFG2, core);

		/* Disable all loopback options first */
		write_radio_reg(pi, RF_2069_TXRX2G_CAL_TX(core), 0);
		write_radio_reg(pi, RF_2069_TXRX5G_CAL_TX(core), 0);
		write_radio_reg(pi, RF_2069_TXRX2G_CAL_RX(core), 0);
		write_radio_reg(pi, RF_2069_TXRX5G_CAL_RX(core), 0);
		write_radio_reg(pi, RF_2069_RXRF2G_CFG2(core), 0);
		write_radio_reg(pi, RF_2069_RXRF5G_CFG2(core), 0);

		/* Disable PAPD paths
		 *  - Powerdown the papd loopback path on Rx side
		 *  - Disable the epapd
		 */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_papdcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0);
		} else {
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_papdcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF5G_CFG2, core, lna5g_epapd_en, 0);
		}

		/* Disable RCCR Phase Shifter */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_cr_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_rc_pu, 0);
		} else {
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_cr_pu, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_rc_pu, 0);
		}

		/* Enable Tx Path */
		if (!ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pa2g_pu, 1);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pad2g_pu, 0);
			} else {
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pa_pu_5g, 1);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 0);
			}
		} else {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pa2g_pu, 0);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pad2g_pu, 1);
			} else {
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pa_pu_5g, 0);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 1);

			}
		}

		/* Enable Rx Path
		 *  - Powerup the master cal PU signal on Rx side (common to papd & rxiqcal).
		 *    Not needed for rx/cr rxiqcal PU.
		 *  - Powerup the rxiqcal loopback path on Rx side.
		 */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_cal_pu, 1);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_pu, 1);
		} else {
			if (ISACPHY(pi) && ACREV_IS(pi->pubpi.phy_rev, 0)) {
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 1);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_pu, 1);
				} else {
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_lna12_mux, 1);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 1);
				}
		}

		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_cal_pad_atten_2g, tx_atten);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core,
			               loopback2g_rxiqcal_rx_attn, rx_atten);
		} else {
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_cal_pad_atten_5g, tx_atten);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core,
			               loopback5g_rxiqcal_rx_attn, rx_atten);
		}
		/* additional settings for 4350 epa 5G */
		if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
		    (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
		      (CHSPEC_IS5G(pi->radio_chanspec))) {
		  /* Turn off the loopback path */
		  MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 0);
		  /* turn off kill switch */
		  MOD_RADIO_REGC(pi, LNA5G_CFG1, core, tr_rx_en, 0x1);
		  MOD_RADIO_REGC(pi, OVR7, core, ovr_lna5g_tr_rx_en, 0x1);
		  /* Turn off ext LNA */
		  MOD_PHYREGCE(pi, RfctrlIntc, core, ext_lna_5g_pu, 0);
		  MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_lna, 1);
		  /* Turn off PAD */
		  MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 0);
		}
	}

}

static void
wlc_phy_rxcal_radio_setup_acphy_tiny(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_radioregs_t *porig = &(pi_ac->ac_rxcal_radioregs_orig);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	/* sanity check */
	ASSERT(!porig->is_orig);
	porig->is_orig = TRUE;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {

	/* force off the dac 2 adc switches */
	MOD_RADIO_REG_20691(pi, ADC_OVR1, core, ovr_adc_in_test, 0x1);
	MOD_RADIO_REG_20691(pi, ADC_CFG10, core, adc_in_test, 0x0);
	/* papd loopback path settings for 2G */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		porig->RF_20691_RFRX_TOP_2G_OVR_EAST[core] = READ_RADIO_REG_20691(pi,
			RX_TOP_2G_OVR_EAST, core);

		 /* Enable ipapd */
		MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_pu, 0x1);
		MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, loopback2g_papdcal_pu, 0x1);
		MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0x0);
		/* Set txattn and rxattn */
		 MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_atten, 0x3);
		 MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, rf2g_papdcal_rx_attn, 0x3);
		/* powerdown rxgm2g, powerup auxgm2g */
		MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_auxgm_pwrup, 0x1);
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST,	core, ovr_gm2g_auxgm_pwrup, 0x1);
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST,	core, ovr_gm2g_pwrup, 0x1);
		MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_pwrup, 0x0);
		}

	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		/* leakage path settings */
		uint8 iscore = 0;
		/* use low idx:forcing tx idx to 80 to account for lna blow for YA1 chip variant */
#ifndef WLC_POINT5_DB_TX_GAIN_STEP /* Disable 0.5 dB gain step */
		if (PHY_IPA(pi)) {
			wlc_phy_set_txpwr_by_index_acphy(pi, (1 << iscore), 127);
		} else {
			wlc_phy_set_txpwr_by_index_acphy(pi, (1 << iscore), 116);
		}
#else
		if (PHY_IPA(pi)) {
			wlc_phy_set_txpwr_by_index_acphy(pi, (1 << iscore), 63);
		} else {
			wlc_phy_set_txpwr_by_index_acphy(pi, (1 << iscore), 58);
		}
#endif /* Disable 0.5 dB gain step */

		MOD_RADIO_REG_20691(pi, PA5G_CFG4, core, pa5g_pu,
		                    (PHY_IPA(pi) && !PHY_ILNA(pi)) ? 0 : 1);
		MOD_RADIO_REG_20691(pi, TX_TOP_5G_OVR1, core, ovr_pa5g_pu, 0x1);
		/* force lna1 kill switch to on */
		MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_tr_rx_en, 0x1);
		MOD_RADIO_REG_20691(pi, LNA5G_CFG1, core, lna5g_tr_rx_en, 0x1);
		MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_nap, 0x1);
		MOD_RADIO_REG_20691(pi, LNA5G_CFG2, core, lna5g_nap, 0x0);

		MOD_RADIO_REG_20691(pi, LOGEN_OVR1, core, ovr_logen_en_nap, 0x1);
		MOD_RADIO_REG_20691(pi, LOGEN_CFG3, core, logen_en_nap, 0x0);

		MOD_RADIO_REG_20691(pi, TXMIX5G_CFG4, core, mx5g_bbpdI_en, 0x0);
		MOD_RADIO_REG_20691(pi, TXMIX5G_CFG4, core, mx5g_bbpdQ_en, 0x0);
		MOD_RADIO_REG_20691(pi, PA5G_CFG1, core, rf5g_epapd_en,  0x0);
		MOD_RADIO_REG_20691(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu,  0x0);
		MOD_RADIO_REG_20691(pi, TIA_CFG9, core, tia_tx_lpbck_i, 0x0);
		MOD_RADIO_REG_20691(pi, TIA_CFG9, core, tia_tx_lpbck_q, 0x0);

		/* power up detectors for saturation detection during loopback */
		MOD_RADIO_REG_20691(pi, LNA5G_RSSI1, core, lna5g_dig_wrssi1_pu, 1);
		MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_dig_wrssi1_pu, 1);
		MOD_RADIO_REG_20691(pi, TIA_CFG12, core, rssi_pwrup, 1);
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, core, ovr_tia_offset_rssi_pwrup, 1);
		}
	}
}

static void
wlc_phy_papd_radio_loopback_setup_acphy(phy_info_t *pi, uint16 tx_atten, uint16 rx_atten,
 uint8 core)
{
	uint16 radio_rev_id;
	uint8 edpdcalset = pi->u.pi_acphy->srom_edpdcalset;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	/* CAL PER CORE - FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) */
	{
		radio_rev_id = READ_RADIO_REGC(pi, RF, REV_ID, core);

		MOD_RADIO_REGC(pi, GE16_OVR20, core, ovr_tia_GainI, 1);
		MOD_RADIO_REGC(pi, GE16_OVR20, core, ovr_tia_GainQ, 1);
		MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 2);
		MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 2);

		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (RADIOREV(pi->pubpi.radiorev) == 25) {
				MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 0);
				MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 0);
			}
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pa2g_pu, 1);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pad2g_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_cal_pu, 1);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_papdcal_pu, 1);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_cal_pa_atten_2g, tx_atten);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core,
			               loopback2g_papdcal_rx_attn, rx_atten);

			/* Enable the vdd switch on mixer */
			MOD_RADIO_REGC(pi, RXRF2G_CFG1, core, pwrsw_en, 1);
			if (radio_rev_id == 0 || radio_rev_id == 1 || radio_rev_id == 2 ||
				radio_rev_id == 3 || radio_rev_id == 4) {
				MOD_RADIO_REGC(pi, OVR18, core, ovr_rxrf2g_pwrsw_en, 1);
			} else {
				MOD_RADIO_REGC(pi, OVR19, core, ovr_rxrf2g_pwrsw_en, 1);
			}
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
				/* 4350EPAPD */
				MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 4);
				MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 4);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pa2g_pu, 0);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pad2g_pu, 0);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_cal_pu, 0);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_papdcal_pu, 1);
				MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_pu, 0);
				MOD_RADIO_REGC(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 1);
				MOD_RADIO_REGC(pi, RXRF2G_CFG2, core, lna2g_epapd_attn, 0);
			}
		} else {
			if (RADIOREV(pi->pubpi.radiorev) == 25) {
				if (CHSPEC_IS80(pi->radio_chanspec)) {
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 4);
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 4);
				} else {
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 2);
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 2);
				}
			}
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pa_pu_5g, 1);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 1);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_papdcal_pu, 1);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF5G_CFG2, core, lna5g_epapd_en, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_cal_pa_atten_5g, tx_atten);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core,
				loopback5g_papdcal_rx_attn, rx_atten);
			MOD_RADIO_REGC(pi, RXRF5G_CFG1, core, pwrsw_en, 1);
			if (radio_rev_id == 0 || radio_rev_id == 1 || radio_rev_id == 2 ||
			    radio_rev_id == 3 || radio_rev_id == 4) {
				MOD_RADIO_REGC(pi, OVR18, core, ovr_rxrf5g_pwrsw_en, 1);
			} else {
				MOD_RADIO_REGC(pi, OVR19, core, ovr_rxrf5g_pwrsw_en, 1);
			}
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2 && PHY_EPAPD(pi)) {
				/* 4350EPAPD */
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pa_pu_5g, 0);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 0);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 0);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_papdcal_pu, 1);
				MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_pu, 0);
				MOD_RADIO_REGC(pi, RXRF5G_CFG2, core, lna5g_epapd_en, 1);
				if (edpdcalset == 2) {
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 2);
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 2);
					MOD_RADIO_REGC(pi, RXRF5G_CFG2, core,
					        lna5g_epapd_attn, 0);
				} else if (edpdcalset == 1) {
					if (CHSPEC_IS80(pi->radio_chanspec)) {
						MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 8);
						MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 8);
						MOD_RADIO_REGC(pi, RXRF5G_CFG2, core,
						        lna5g_epapd_attn, 2);
					} else {
						MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 5);
						MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 5);
						MOD_RADIO_REGC(pi, RXRF5G_CFG2, core,
						        lna5g_epapd_attn, 8);
					}
				} else {
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainI, 7);
					MOD_RADIO_REGC(pi, TIA_CFG1, core, GainQ, 7);
					MOD_RADIO_REGC(pi, RXRF5G_CFG2, core,
					        lna5g_epapd_attn, 0);
				}
			}
		}
		/* #Powerdown LNA1, LNA2 */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna1_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna1_pwrup, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_pwrup, 0);

		/* acphy_rfctrl_override lpf_sw rxiq_rx2 $core; */
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_adc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_aux_bq1, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_aux_bq1, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_iqcal_bq1, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_iqcal_bq1, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_adc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_rc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_bq2, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq1_adc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq1_adc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_tia_bq1, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_tia_bq1, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_bq2_rc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_bq2_rc, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, lpf_sw_dac_bq2, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, lpf_sw_dac_bq2, 1);

		/* acphy_rfctrl_override lpf_pu_dc 1 $core */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_pu_dc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, lpf_pu_dc, 1);

		/* acphy_rfctrl_override tia_DC_loop_PU 1 $core */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, tia_DC_loop_PU, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, tia_DC_loop_PU, 1);

		/* acphy_rfctrl_override fast_nap_bias_pu 1 $core */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, fast_nap_bias_pu, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, fast_nap_bias_pu, 1);

		/* acphy_rfctrl_override rxrf_pwrup 1 $core */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_pwrup, 1);

		/* acphy_rfctrl_override logen_rx_pwrup 1 $core */
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, logen_rx_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, logen_rx_pwrup, 1);
	}
}

static void
wlc_phy_papd_radio_loopback_setup_acphy_20691(phy_info_t *pi, uint16 tx_atten, uint16 rx_atten)
{
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {

			if (RADIO20691_MAJORREV(radio_rev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, core, ovr_gm2g_pwrup, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, core,
				                    ovr_gm2g_auxgm_pwrup, 1);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core,
				                    ovr_gm2g_pwrup, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core,
				                    ovr_gm2g_auxgm_pwrup, 1);
			}

			MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_pwrup, 0);
			MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_auxgm_pwrup, 1);

			if (!PHY_EPAPD(pi)) {
				/* Enable ipapd */
				MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_pu, 1);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core,
				                    loopback2g_papdcal_pu, 1);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0);
				MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core,
				                    cal2g_pa_atten, tx_atten);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core,
				                    rf2g_papdcal_rx_attn, rx_atten);
			} else {
				/* Enable epapd */
				MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_pu, 0);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core,
				                    loopback2g_papdcal_pu, 0);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 1);
				MOD_RADIO_REG_20691(pi, LNA2G_CFG1, core, lna2g_lna1_bypass, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, core,
				                    ovr_lna2g_lna1_bypass, 1);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core,
				                    lna2g_epapd_attn, rx_atten);
			}
		} else {
			/* PAPD loopback in a-band */

			/* power down rxgm5g */
			MOD_RADIO_REG_20691(pi, LNA5G_CFG2, core, lna5g_pu_lna2, 0);
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR1, core, ovr_gm5g_pwrup, 1);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_gm5g_pwrup, 1);
			}

			/* powerup auxgm5g */
			MOD_RADIO_REG_20691(pi, LNA5G_CFG2, core, lna5g_pu_auxlna2, 1);
			if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR1, core,
				                    ovr_lna5g_pu_auxlna2, 1);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core,
				                    ovr_lna5g_pu_auxlna2, 1);
			}

			if (!PHY_EPAPD(pi)) {
				/* Enable ipapd */
				MOD_RADIO_REG_20691(pi, TX5G_MISC_CFG1, core, cal5g_pa_pu, 1);
				MOD_RADIO_REG_20691(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 1);
				MOD_RADIO_REG_20691(pi, PA5G_CFG1, core, rf5g_epapd_en, 0);
				MOD_RADIO_REG_20691(pi, TX5G_MISC_CFG1, core,
				                    cal5g_pa_atten, tx_atten);
				MOD_RADIO_REG_20691(pi, RXRF5G_CFG2, core,
				                    loopback5g_papdcel_rx_attn, rx_atten);
			} else {
				/* Enable  */
				MOD_RADIO_REG_20691(pi, TX5G_MISC_CFG1, core, cal5g_pa_pu, 0);
				MOD_RADIO_REG_20691(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 0);
				MOD_RADIO_REG_20691(pi, PA5G_CFG1, core, rf5g_epapd_en, 1);
				MOD_RADIO_REG_20691(pi, LNA5G_CFG1, core, lna5g_lna1_bypass, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core,
				                    ovr_lna5g_lna1_bypass, 1);
				MOD_RADIO_REG_20691(pi, RXRF5G_SPARE, core,
				                    rf5g_epapd_attn, rx_atten);
			}
		}
	}

	/* Farrow */
	MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 1);
	if (CHSPEC_IS5G(pi->radio_chanspec) == 1) {
		MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 0);
	} else {
		if (RADIO20691_MAJORREV(radio_rev) == 0) {
			MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 1);
		} else {
			MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 2);
		}
	}

	ACPHY_REG_LIST_START
		/* #Powerdown LNA1, LNA2 */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, rxrf_lna1_pwrup, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, rxrf_lna1_pwrup, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, rxrf_lna2_pwrup, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, rxrf_lna2_pwrup, 0)

		/* Configure the LPF switches and powerup the DC loop */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq2_adc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq2_adc, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq1_adc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq1_adc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_dac_adc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_dac_adc, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq2_rc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq2_rc, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_dac_rc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_dac_rc, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq1_bq2, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq1_bq2, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_dac_bq2, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_dac_bq2, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_aux_bq1, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_aux_bq1, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_iqcal_bq1, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_iqcal_bq1, 0)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_tia_bq1, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_tia_bq1, 0)

		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_dac_bq2, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_dac_bq2, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq2_rc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq2_rc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_tia_bq1, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_tia_bq1, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideLpfSwtch0, lpf_sw_bq1_adc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreLpfSwtch0, lpf_sw_bq1_adc, 1)

		/* acphy_rfctrl_override lpf_pu_dc 1 $core */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, lpf_pu_dc, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, lpf_pu_dc, 1)

		/* acphy_rfctrl_override tia_DC_loop_PU 1 $core */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, tia_DC_loop_PU, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, tia_DC_loop_PU, 1)

		/* acphy_rfctrl_override fast_nap_bias_pu 1 $core */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, fast_nap_bias_pu, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, fast_nap_bias_pu, 0)

		/* acphy_rfctrl_override rxrf_pwrup 1 $core */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, rxrf_pwrup, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, rxrf_pwrup, 1)

		/* acphy_rfctrl_override logen_rx_pwrup 1 $core */
		MOD_PHYREG_ENTRY(pi, RfctrlOverrideRxPus0, logen_rx_pwrup, 1)
		MOD_PHYREG_ENTRY(pi, RfctrlCoreRxPus0, logen_rx_pwrup, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, core, dac_driver_size, 4);
		if (RADIO20691_MAJORREV(radio_rev) != 0) {
			porig->adc_cfg10[core] = READ_RADIO_REG_20691(pi, ADC_CFG10, core);
			porig->adc_ovr1[core] = READ_RADIO_REG_20691(pi, ADC_OVR1, core);
			MOD_RADIO_REG_20691(pi, ADC_OVR1, core, ovr_adc_in_test, 1);
			MOD_RADIO_REG_20691(pi, ADC_CFG10, core, adc_in_test, 0x0);
		}
	}

	if (CHSPEC_IS2G(pi->radio_chanspec) == 1) {
		wlc_phy_20691_tia_gain(pi, 0x3);
	} else {
		wlc_phy_20691_tia_gain(pi, 0x0);
	}

}

static void
wlc_phy_20691_tia_gain(phy_info_t *pi, uint16 gain)
{
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	/* 20691_tia_gain ????? is this correct */
	if (RADIO20691_MAJORREV(radio_rev) == 0) {
	    ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_C1, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_C2, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_R1, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_R2, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_R3, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR1, 0, ovr_tia_R4, 0)
	    ACPHY_REG_LIST_EXECUTE(pi);
	} else {
	    ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_C1, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_C2, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_R1, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_R2, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_R3, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_R4, 0)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}
	MOD_PHYREG(pi, RfctrlOverrideGains0, rxgain, 1);
	MOD_PHYREG(pi, RfctrlCoreRXGAIN10, rxrf_tia_gain, gain);
}

static void
wlc_phy_rxcal_radio_cleanup_acphy(phy_info_t *pi)
{

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_radioregs_t *porig = &(pi_ac->ac_rxcal_radioregs_orig);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(porig->is_orig);
	porig->is_orig = FALSE;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		write_radio_reg(pi, RF_2069_TXRX2G_CAL_TX(core),
			porig->RF_2069_TXRX2G_CAL_TX[core]);
		write_radio_reg(pi, RF_2069_TXRX5G_CAL_TX(core),
			porig->RF_2069_TXRX5G_CAL_TX[core]);
		write_radio_reg(pi, RF_2069_TXRX2G_CAL_RX(core),
			porig->RF_2069_TXRX2G_CAL_RX[core]);
		write_radio_reg(pi, RF_2069_TXRX5G_CAL_RX(core),
			porig->RF_2069_TXRX5G_CAL_RX[core]);
		write_radio_reg(pi, RF_2069_RXRF2G_CFG2(core),
			porig->RF_2069_RXRF2G_CFG2[core]);
		write_radio_reg(pi, RF_2069_RXRF5G_CFG2(core),
			porig->RF_2069_RXRF5G_CFG2[core]);
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 0)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}
	  if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	      (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
	      (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
	      (CHSPEC_IS5G(pi->radio_chanspec))) {
	    FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	      MOD_RADIO_REGC(pi, OVR7, core, ovr_lna5g_tr_rx_en, 0x0);
	      MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_lna, 0);
	    }
	  }
}

static void
wlc_phy_rxcal_radio_cleanup_acphy_tiny(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_radioregs_t *porig = &(pi_ac->ac_rxcal_radioregs_orig);

	uint8 core;
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));
	/* sanity check */
	ASSERT(porig->is_orig);
	porig->is_orig = FALSE;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* restore the dac 2 adc switches */
		MOD_RADIO_REG_20691(pi, ADC_OVR1, core, ovr_adc_in_test, 0x0);
		MOD_RADIO_REG_20691(pi, ADC_CFG10, core, adc_in_test, 0x0);

		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			/* 5G  leakage path cleanup */
			MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_nap, 0x0);
			MOD_RADIO_REG_20691(pi, LOGEN_OVR1, core, ovr_logen_en_nap, 0x0);
			MOD_RADIO_REG_20691(pi, LOGEN_OVR1, core, ovr_logencore_reset, 0x1);
			MOD_RADIO_REG_20691(pi, LOGEN_CFG2, core, logencore_reset, 0x0);
			MOD_RADIO_REG_20691(pi, LOGEN_CFG2, core, logencore_reset, 0x1);
			OSL_DELAY(1000);
			MOD_RADIO_REG_20691(pi, LOGEN_CFG2, core, logencore_reset, 0x0);
			MOD_RADIO_REG_20691(pi, LOGEN_OVR1, core, ovr_logencore_reset, 0x0);

			MOD_RADIO_REG_20691(pi, TX_TOP_5G_OVR1, core, ovr_pa5g_pu, 0x0);
			MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_gm5g_pwrup, 0x0);
			/* disable override for lna kill switch */
			MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_tr_rx_en, 0x0);
			MOD_RADIO_REG_20691(pi, LNA5G_CFG1, core, lna5g_tr_rx_en, 0x1);
			MOD_RADIO_REG_20691(pi, LNA5G_RSSI1, core, lna5g_dig_wrssi1_pu, 0);
			MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_dig_wrssi1_pu, 0);
			MOD_RADIO_REG_20691(pi, TIA_CFG12, core, rssi_pwrup, 0);
			MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, core, ovr_tia_offset_rssi_pwrup,
			                    0);
		} else {
			/* 2g papd path cleanup */
			MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_pu, 0x0);
			MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, loopback2g_papdcal_pu, 0x0);
			MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_auxgm_pwrup, 0x0);

			write_radio_reg(pi, RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core),
			                porig->RF_20691_RFRX_TOP_2G_OVR_EAST[core]);

			MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_pwrup, 0x1);
			MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core, ovr_gm2g_pwrup, 0x0);
		}
	}
}

/* PAPD Functions */
static void
wlc_phy_papd_phy_setup_acphy(phy_info_t *pi, uint8 core)
{
	/* XXX Notes:
	 *   - also note that in the driver we do a resetCCA after this to be on the safe
	 *     side; may want to revisit this here, too, in case we run into issues
	 */

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_phyregs_t *porig = &(pi_ac->ac_rxcal_phyregs_orig);
	uint16 sdadc_config = 0;
	uint8 bw_idx;
	uint8 stall_val;
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		bw_idx = 2;
		sdadc_config = sdadc_cfg80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		bw_idx = 1;
		if (pi->sdadc_config_override)
			sdadc_config = sdadc_cfg40hs;
		else
			sdadc_config = sdadc_cfg40;
	} else {
		bw_idx = 0;
		sdadc_config = sdadc_cfg20;
	}

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(!porig->is_orig);
	porig->is_orig = TRUE;
	/* 4335 phy_rev is 7. For phy_rev 2, following things are required. */
	if (ACREV_IS(pi->pubpi.phy_rev, 2)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 4)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	porig->RfctrlOverrideGlobalPus = READ_PHYREG(pi, RfctrlOverrideGlobalPus);
	porig->RfctrlCoreGlobalPus = READ_PHYREG(pi, RfctrlCoreGlobalPus);

	/* CAL PER CORE - FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) */
	{
		porig->txpwridx[core] = pi->u.pi_acphy->txpwrindex[core];

		porig->RfctrlOverrideTxPus[core] = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
		porig->RfctrlOverrideRxPus[core] = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
		porig->RfctrlOverrideGains[core] = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
		porig->RfctrlOverrideLpfCT[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfCT, core);
		porig->RfctrlOverrideLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfSwtch,
		                                                    core);
		porig->RfctrlOverrideAfeCfg[core] = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
		porig->RfctrlOverrideLowPwrCfg[core] = READ_PHYREGCE(pi, RfctrlOverrideLowPwrCfg,
		                                                     core);
		porig->RfctrlOverrideAuxTssi[core] = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);

		porig->RfctrlCoreTxPus[core] = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
		porig->RfctrlCoreRxPus[core] = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
		porig->RfctrlCoreTXGAIN1[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN1, core);
		porig->RfctrlCoreTXGAIN2[core] = READ_PHYREGCE(pi, RfctrlCoreTXGAIN2, core);
		porig->RfctrlCoreRXGAIN1[core] = READ_PHYREGCE(pi, RfctrlCoreRXGAIN1, core);
		porig->RfctrlCoreRXGAIN2[core] = READ_PHYREGCE(pi, RfctrlCoreRXGAIN2, core);
		porig->RfctrlCoreLpfGain[core] = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
		porig->RfctrlCoreLpfCT[core] = READ_PHYREGCE(pi, RfctrlCoreLpfCT, core);
		porig->RfctrlCoreLpfGmult[core] = READ_PHYREGCE(pi, RfctrlCoreLpfGmult, core);
		porig->RfctrlCoreRCDACBuf[core] = READ_PHYREGCE(pi, RfctrlCoreRCDACBuf, core);
		porig->RfctrlCoreLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlCoreLpfSwtch, core);
		porig->RfctrlCoreAfeCfg1[core] = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
		porig->RfctrlCoreAfeCfg2[core] = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
		porig->RfctrlCoreLowPwr[core] = READ_PHYREGCE(pi, RfctrlCoreLowPwr, core);
		porig->RfctrlCoreAuxTssi1[core] = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
		porig->RfctrlCoreAuxTssi2[core] = READ_PHYREGCE(pi, RfctrlCoreAuxTssi2, core);
		porig->Dac_gain[core] = READ_PHYREGCE(pi, Dac_gain, core);

		wlc_phy_get_tx_bbmult_acphy(pi, &(porig->bbmult[core]), core);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
			&porig->rfseq_txgain[core+0]);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
			&porig->rfseq_txgain[core+3]);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
			&porig->rfseq_txgain[core+6]);

		porig->RfctrlIntc[core] = READ_PHYREGCE(pi, RfctrlIntc, core);
	}

	porig->RfseqCoreActv2059 = READ_PHYREG(pi, RfseqCoreActv2059);

	/* XXX Core Activate/Deactivate
		for now, keep all rx's enabled for most realistic rx conditions
	 */
	/* MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, pi->sh->phyrxchain); */
	MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, 1 << core);
	MOD_PHYREG(pi, RfseqCoreActv2059, DisRx, ~(1 << core));
	porig->lbFarrowCtrl = READ_PHYREG(pi, lbFarrowCtrl);
	MOD_PHYREG(pi, lbFarrowCtrl, lb_decimator_output_shift, 2);

/* CAL PER CORE - FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) */
	{

		/* XXX RF External Settings
		 *   - Power Down External PA,
		 *   - T/R on T to protect against interference
		 */
		/* acphy_rfctrlintc_override  ext_pa 1  $core */
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_2g_papu, 1);
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_5g_papu, 1);
		MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_pa, 1);

		/* acphy_rfctrlintc_override  ext_lna_pu 0  $core */
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_lna_2g_pu, 0);
		MOD_PHYREGCE(pi, RfctrlIntc, core, ext_lna_5g_pu, 0);
		MOD_PHYREGCE(pi, RfctrlIntc, core, override_ext_lna, 1);

		MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 1);
		MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
		MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
		/* 20691 iTR trsw */
		if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
		    ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_bias_pu, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu, 1)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}

		/* XXX Required for loopback to work correctly
		   acphy_rfctrl_override fast_nap_bias_pu 1 $core
		*/
		/* XXX RfCtrl
		*   - turn off Internal PA
		*   - turn off LNA1 to protect against interference and reduce thermal noise
		*   - force LPF to Rx Chain
		*   - force LPF bw
		*   - NOTE: this also saves off state of possible Tx/Rx gain override states
		*/

		/* Setting the SD-ADC related stuff */
		/* acphy_rfctrl_override iqadc 1 $core */
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, sdadc_config & 0x7);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_iqadc_pwrup,
		             (sdadc_config >> 3) & 0x3f);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd,
		             (sdadc_config >> 9) & 0x1);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_flashhspd, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl,
		             (sdadc_config >> 10) & 0x1);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_ctrl_flash17lvl, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_adc_bias,
		             (sdadc_config >> 11) & 0x3);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_adc_bias, 1);

		/* acphy_rfctrl_override pa_pwrup 1 $core; */
		MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, pa_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideTxPus, core, pa_pwrup, 1);
		/* acphy_rfctrl_override lpf_nrssi_pwrup 0 $core */
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, lpf_nrssi_pwrup, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_nrssi_pwrup, 1);
		/* acphy_rfctrl_override wb1_pu 0 $core */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rssi_wb1g_pu, 0);
			MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1g_pu, 1);
		}
		else {
			MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rssi_wb1a_pu, 0);
			MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rssi_wb1a_pu, 1);
		}

		/* xxx Debug printfs:
		printf("\nRfctrlCoreRxPus = %x", READ_PHYREG(pi, RfctrlCoreRxPus0));
		printf("\nRfctrlCoreTxPus = %x", READ_PHYREG(pi, RfctrlCoreTxPus0));
		*/

		/* xxx This is what is done in tcl:
		acphy_rfctrl_override lpf_bq1_bw [expr $def(phybw) + 0] $core;
		*/
		MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_bq1_bw, 1);
		MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_bq1_bw, bw_idx);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_bq2_bw, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_rc_bw, 1);
		if ((RADIOREV(pi->pubpi.radiorev) == 17) || (RADIOREV(pi->pubpi.radiorev) == 23) ||
		(RADIOREV(pi->pubpi.radiorev) == 25)) {
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_bq2_bw, 7);
			MOD_PHYREGCE(pi, RfctrlCoreRCDACBuf, core, lpf_rc_bw, 7);
		} else {
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT, core, lpf_bq2_bw, bw_idx + 5);
			MOD_PHYREGCE(pi, RfctrlCoreRCDACBuf, core, lpf_rc_bw, bw_idx + 5);
		}

		porig->PapdEnable[core] = READ_PHYREGCE(pi, PapdEnable, core);
		MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);

		porig->forceFront[core] =  READ_PHYREGCE(pi, forceFront, core);
	        if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
			MOD_PHYREGCE(pi, forceFront, core, freqEst, 1);
			MOD_PHYREGCE(pi, forceFront, core, freqCor, 1);
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_papd_rx_gain_ctrl_acphy(phy_info_t *pi)
{

	int8 gain_ctrl_done = 0;
	int16 clip_det_sel, wlc_clip_cnt_regval;
	uint16 bbmult_orig[PHY_CORE_MAX];
	uint8 core;
	int16 SAVE_rx_bb_2g_ovr1, SAVE_tia_cfg12_rssi_pwrup, SAVE_tia_cfg12_wrssi3_ref_high_sel;
	int16 SAVE_tia_cfg12_wrssi3_ref_mid_sel, SAVE_tia_cfg13_wrssi3_ref_low_sel;
	uint8 rx_attn = 0, tx_attn = 0, max_attn = 0;

	ASSERT(ACMAJORREV_3(pi->pubpi.phy_rev));
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	if (PHY_EPAPD(pi)) {
		max_attn = 15;
	} else {
		max_attn = 3;
	}

	clip_det_sel = READ_PHYREGFLD(pi, RxSdFeConfig6, rx_farrow_rshift_0);

	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	/* start tone with full scale at DAC */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_get_tx_bbmult_acphy(pi, &(bbmult_orig[core]), core);
		wlc_phy_tx_tone_acphy(pi, 2000, 450, 0, 0, FALSE);
		wlc_phy_set_tx_bbmult_acphy(pi, &bbmult_orig[core], core);
	}

	/* save register states */
	if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
		SAVE_rx_bb_2g_ovr1 = READ_RADIO_REGFLD_20691(pi, RX_BB_2G_OVR1, 0,
		                                             ovr_tia_offset_rssi_pwrup);
	} else {
		SAVE_rx_bb_2g_ovr1 = READ_RADIO_REGFLD_20691(pi, RX_BB_2G_OVR_EAST, 0,
		                                             ovr_tia_offset_rssi_pwrup);
	}
	SAVE_tia_cfg12_rssi_pwrup = READ_RADIO_REGFLD_20691(pi, TIA_CFG12, 0, rssi_pwrup);
	SAVE_tia_cfg12_wrssi3_ref_high_sel = READ_RADIO_REGFLD_20691(pi, TIA_CFG12, 0,
	                                                             wrssi3_ref_high_sel);
	SAVE_tia_cfg12_wrssi3_ref_mid_sel = READ_RADIO_REGFLD_20691(pi, TIA_CFG12, 0,
	                                                            wrssi3_ref_mid_sel);
	SAVE_tia_cfg13_wrssi3_ref_low_sel = READ_RADIO_REGFLD_20691(pi, TIA_CFG13, 0,
	                                                            wrssi3_ref_low_sel);

	/* Enable rssi clip detectors */
	if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR1, 0, ovr_tia_offset_rssi_pwrup, 1);
	} else {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_rssi_pwrup, 1);
	}
	MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, rssi_pwrup, 1);

	if (clip_det_sel == 3) {
		MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, wrssi3_ref_high_sel, 4);
	} else {
		MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, wrssi3_ref_high_sel, 0);
	}
	MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, wrssi3_ref_mid_sel, 0);
	MOD_RADIO_REG_20691(pi, TIA_CFG13, 0, wrssi3_ref_low_sel, 0);

	for (rx_attn = 0; rx_attn < max_attn; rx_attn++) {
		while (tx_attn <= max_attn) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, 0, cal2g_pa_atten, tx_attn);
				MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, 0,
				                    rf2g_papdcal_rx_attn, rx_attn);
			} else {
				MOD_RADIO_REG_20691(pi, TX5G_MISC_CFG1, 0, cal5g_pa_atten, tx_attn);
				MOD_RADIO_REG_20691(pi, RXRF5G_CFG2, 0,
				                    loopback5g_papdcel_rx_attn, rx_attn);
			}

			if (clip_det_sel == 3) {
				clip_det_sel = clip_det_sel - 1;
			}

			if (clip_det_sel+1 == 1) {
				wlc_clip_cnt_regval = READ_PHYREG(pi, W3ClipCnt1);
			} else if (clip_det_sel+1 == 2) {
				wlc_clip_cnt_regval = READ_PHYREG(pi, W3ClipCnt2);
			} else {
				wlc_clip_cnt_regval = READ_PHYREG(pi, W3ClipCnt3);
			}

			if (wlc_clip_cnt_regval == 0) {
				gain_ctrl_done = 1;
				break;
			}

			if (tx_attn == max_attn) {
				break;
			}
			tx_attn = tx_attn + 1;
		}
		if ((gain_ctrl_done == 1) || (rx_attn == 3)) {
			break;
		}
	}

	/* Restor Registers */
	if (ACREV_IS(pi->pubpi.phy_rev, 4)) {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR1, 0,
		                    ovr_tia_offset_rssi_pwrup, SAVE_rx_bb_2g_ovr1);
	} else {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, 0,
		                    ovr_tia_offset_rssi_pwrup, SAVE_rx_bb_2g_ovr1);
	}

	MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, rssi_pwrup, SAVE_tia_cfg12_rssi_pwrup);
	MOD_RADIO_REG_20691(pi, TIA_CFG12, 0,
		wrssi3_ref_high_sel, SAVE_tia_cfg12_wrssi3_ref_high_sel);
	MOD_RADIO_REG_20691(pi, TIA_CFG12, 0,
		wrssi3_ref_mid_sel, SAVE_tia_cfg12_wrssi3_ref_mid_sel);
	MOD_RADIO_REG_20691(pi, TIA_CFG13, 0,
		wrssi3_ref_low_sel, SAVE_tia_cfg13_wrssi3_ref_low_sel);
	/* Switch off test tone */
	wlc_phy_stopplayback_acphy(pi);

	/* beDeaf */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
}

static void
wlc_phy_papdcal_radio_cleanup_acphy(phy_info_t *pi, uint8 core)
{
	uint16 radio_rev_id;
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

/* CAL PER CORE - FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) */
	{
		radio_rev_id = READ_RADIO_REGC(pi, RF, REV_ID, core);

		MOD_RADIO_REGC(pi, GE16_OVR20, core, ovr_tia_GainI, 0);
		MOD_RADIO_REGC(pi, GE16_OVR20, core, ovr_tia_GainQ, 0);
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pa2g_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_calPath_pad2g_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_cal_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_papdcal_pu, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_rxiqcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_TX, core, i_cal_pa_atten_2g, 0);
			MOD_RADIO_REGC(pi, TXRX2G_CAL_RX, core, loopback2g_papdcal_rx_attn, 0);
			MOD_RADIO_REGC(pi, RXRF2G_CFG1, core, pwrsw_en, 1);
/*
			if (radio_rev_id == 0 || radio_rev_id == 1 || radio_rev_id == 2 ||
				radio_rev_id == 3 || radio_rev_id == 4) {
				MOD_RADIO_REGC(pi, OVR18, core, ovr_rxrf2g_pwrsw_en, 1);
			} else {
				MOD_RADIO_REGC(pi, OVR19, core, ovr_rxrf2g_pwrsw_en, 1);
			}
*/

		} else {
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pa_pu_5g, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_calPath_pad_pu_5g, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_papdcal_pu, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_rxiqcal_pu, 0);
			MOD_RADIO_REGC(pi, RXRF5G_CFG2, core, lna5g_epapd_en, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_TX, core, i_cal_pa_atten_5g, 0);
			MOD_RADIO_REGC(pi, TXRX5G_CAL_RX, core, loopback5g_papdcal_rx_attn, 0);

			if (radio_rev_id == 0 || radio_rev_id == 1 || radio_rev_id == 2 ||
				radio_rev_id == 3 || radio_rev_id == 4) {
				MOD_RADIO_REGC(pi, OVR18, core, ovr_rxrf5g_pwrsw_en, 0);
			} else {
				MOD_RADIO_REGC(pi, OVR19, core, ovr_rxrf5g_pwrsw_en, 0);
			}

		}
	}

/*
	ASSERT(porig->is_orig);
	porig->is_orig = FALSE;
*/

	if (ACREV_IS(pi->pubpi.phy_rev, 2)) {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, rxfe_bilge_cnt, 0)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

}

static void
wlc_phy_papd_phy_cleanup_acphy(phy_info_t *pi, uint8 core)
{

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_rxcal_phyregs_t *porig = &(pi_ac->ac_rxcal_phyregs_orig);
	uint8 stall_val;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	ASSERT(porig->is_orig);
	porig->is_orig = FALSE;

	WRITE_PHYREG(pi, RfseqCoreActv2059, porig->RfseqCoreActv2059);

	WRITE_PHYREG(pi, RfctrlCoreGlobalPus, porig->RfctrlCoreGlobalPus);
	WRITE_PHYREG(pi, RfctrlOverrideGlobalPus, porig->RfctrlOverrideGlobalPus);

/* CAL PER CORE - FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) */
	{

		WRITE_PHYREGCE(pi, RfctrlIntc, core, porig->RfctrlIntc[core]);
		/* 20691 iTR trsw */
		if ((RADIOID(pi->pubpi.radioid) == BCM20691_ID) && (pi->itrsw == 1)) {
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TX_TOP_2G_OVR_NORTH, 0, ovr_trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, override_tr_sw));
			MOD_RADIO_REG_20691(pi, TRSW2G_CFG1, 0, trsw2g_bias_pu,
				READ_PHYREGFLD(pi, RfctrlIntc0, tr_sw_tx_pu));
		}
		WRITE_PHYREGCE(pi, PapdEnable, core, porig->PapdEnable[core]);

		/* Are the following three statements redundant?
			wlc_phy_txpwr_by_index_acphy would overwrite on the following anyway
		*/
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x100 + core), 16,
			&porig->rfseq_txgain[core + 0]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x103 + core), 16,
			&porig->rfseq_txgain[core + 3]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x106 + core), 16,
			&porig->rfseq_txgain[core + 6]);
		wlc_phy_txpwr_by_index_acphy(pi, (1 << core), porig->txpwridx[core]);
		wlc_phy_set_tx_bbmult_acphy(pi, &(porig->bbmult[core]), core);

		WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, porig->RfctrlOverrideTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, porig->RfctrlOverrideRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, porig->RfctrlOverrideGains[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfCT, core, porig->RfctrlOverrideLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,
			porig->RfctrlOverrideLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, porig->RfctrlOverrideAfeCfg[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, porig->RfctrlOverrideAuxTssi[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLowPwrCfg, core,
			porig->RfctrlOverrideLowPwrCfg[core]);

		WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, porig->RfctrlCoreTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, porig->RfctrlCoreRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN1, core, porig->RfctrlCoreTXGAIN1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTXGAIN2, core, porig->RfctrlCoreTXGAIN2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core, porig->RfctrlCoreRXGAIN1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core, porig->RfctrlCoreRXGAIN2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, porig->RfctrlCoreLpfGain[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfCT, core, porig->RfctrlCoreLpfCT[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGmult, core, porig->RfctrlCoreLpfGmult[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRCDACBuf, core, porig->RfctrlCoreRCDACBuf[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, porig->RfctrlCoreLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, porig->RfctrlCoreAfeCfg1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, porig->RfctrlCoreAfeCfg2[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLowPwr, core, porig->RfctrlCoreLowPwr[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, porig->RfctrlCoreAuxTssi1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi2, core, porig->RfctrlCoreAuxTssi2[core]);
		WRITE_PHYREGCE(pi, Dac_gain, core, porig->Dac_gain[core]);
	    WRITE_PHYREGCE(pi, forceFront, core, porig->forceFront[core]);
	}
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RESET2RX);
	WRITE_PHYREG(pi, lbFarrowCtrl, porig->lbFarrowCtrl);

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_papd_radio_cleanup_acphy_20691(phy_info_t *pi)
{
	uint8 core;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_txcal_radioregs_t *porig = &(pi_ac->ac_txcal_radioregs_orig);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* # Enable the loopback path */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			/* # Powerup the 2G iPA attenuation on Tx side (loops back to Rx) */
			MOD_RADIO_REG_20691(pi, TX2G_MISC_CFG1, core, cal2g_pa_pu, 0x0);
			/* # Powerup the papd loopback path on 2G Rx side */
			MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, loopback2g_papdcal_pu, 0x0);

			if (RADIO20691_MAJORREV(radio_rev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, core,
				                    ovr_rf2g_mix1st_en, 0);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, core,
				                    ovr_gm2g_auxgm_pwrup, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, core, ovr_gm2g_pwrup, 0);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, core,
				                    ovr_rf2g_mix1st_en, 0);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core,
				                    ovr_gm2g_auxgm_pwrup, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_EAST, core,
				                    ovr_gm2g_pwrup, 0);
			}
			MOD_RADIO_REG_20691(pi, LNA2G_CFG2, core, gm2g_auxgm_pwrup, 0);
			MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, core,
			                    ovr_lna2g_lna1_bypass, 0);
			MOD_RADIO_REG_20691(pi, RXRF2G_CFG2, core, lna2g_epapd_en, 0);

		} else {
			/* # Powerup the 5G iPA attenuation on Tx side (loops back to Rx) */
			MOD_RADIO_REG_20691(pi, TX5G_MISC_CFG1, core, cal5g_pa_pu, 0x0);
			/* # Powerup the master cal pu signal on 5G Rx side (common to papd &
			 * rxiqcal). Not needed for rc/cr rxiqcal pu.
			 */
			MOD_RADIO_REG_20691(pi, TXRX5G_CAL_RX, core, loopback5g_cal_pu, 0x0);
			if (RADIO20691_MAJORREV(radio_rev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR1,
					core, ovr_lna5g_pu_auxlna2, 0);
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR1, core, ovr_gm5g_pwrup, 0);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core,
				                    ovr_lna5g_pu_auxlna2, 1);
				MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_gm5g_pwrup, 0);
			}

			MOD_RADIO_REG_20691(pi, LNA5G_CFG2, core, lna5g_pu_auxlna2, 0);
			MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, core, ovr_lna5g_lna1_bypass, 0);
			MOD_RADIO_REG_20691(pi, PA5G_CFG1, core, rf5g_epapd_en, 0);
		}
	}
	MOD_PHYREG(pi, RxSdFeConfig1, farrow_rshift_force, 0);
	MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, 0);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		write_radio_reg(pi, RADIO_REG_20691(pi, ADC_CFG10, core), porig->adc_cfg10[core]);
		write_radio_reg(pi, RADIO_REG_20691(pi, ADC_OVR1, core), porig->adc_ovr1[core]);
	}
}

#define ACPHY_RXCAL_NUMGAINS 11
#define ACPHY_RXCAL_TONEAMP 181

typedef struct _acphy_rxcal_txrxgain {
	uint16 lpf_biq1;
	uint16 lpf_biq0;
	int8 txpwrindex;
} acphy_rxcal_txrxgain_t;

enum {
	ACPHY_RXCAL_GAIN_INIT = 0,
	ACPHY_RXCAL_GAIN_UP,
	ACPHY_RXCAL_GAIN_DOWN
};

#define ACPHY_RXCAL_NUMRXGAINS 16

typedef struct _acphy_rxcal_rxgain {
	int8 lna;
	uint8 tia;
	uint8 far;
	uint8 dvga;
} acphy_rxcal_rxgain_t;

/* see also: proc acphy_rx_iq_cal_txrxgain_control_tiny { } */
static void
wlc_phy_rxcal_txrx_gainctrl_acphy_tiny(phy_info_t *pi)
{
	/* table for leakage path 5G : lna,tia,far,dvga */
	acphy_rxcal_rxgain_t gaintbl_5G[ACPHY_RXCAL_NUMRXGAINS] = {
		{ -4, 0, 2, 0 },
		{ -4, 0, 1, 0 },
		{ -4, 0, 0, 0 },
		{ -3, 0, 0, 0 },
		{ -2, 0, 0, 0 },
		{ -1, 0, 0, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 2, 0, 0 },
		{ 0, 3, 0, 0 },
		{ 0, 4, 0, 0 },
		{ 0, 5, 0, 0 },
		{ 0, 6, 0, 0 },
		{ 0, 7, 0, 0 },
		{ 0, 8, 0, 0 },
		{ 0, 9, 0, 0 }
	};

		/* table for papd loopback path 2G : lna,tia,far,dvga */
		acphy_rxcal_rxgain_t gaintbl_2G[ACPHY_RXCAL_NUMRXGAINS] = {
		{ 0, 1, 1, 0 },
		{ 0, 0, 0, 0 },
		{ 0, 1, 0, 0 },
		{ 0, 2, 0, 0 },
		{ 0, 3, 0, 0 },
		{ 0, 4, 0, 0 },
		{ 0, 5, 0, 0 },
		{ 0, 6, 0, 0 },
		{ 0, 7, 0, 0 },
		{ 0, 8, 0, 0 },
		{ 0, 9, 0, 0 },
		{ 0, 10, 0, 0 },
		{ 0, 10, 0, 1 },
		{ 0, 10, 0, 2 },
		{ 0, 10, 0, 3 },
		{ 0, 10, 0, 4 }
	};

	acphy_rxcal_rxgain_t *gaintbl;
	uint8 core;
	uint8 g_index, done, found_ideal, wn, txindex;
	bool txdone;
	uint8 do_max = 10;	/* >= ACPHY_RXCAL_NUMRXGAINS / 2 */
	uint8 tia, far, lna_idx;
	int8 lna;
	uint16 num_samps = 1024;
	uint32 meansq_max = (PHY_ILNA(pi)) ? 4000 : 7000; /* As dictated by iqest / dc offsets */

	/*
	 * Set min power more than max gain step below max power to prevent AGC hunting
	 * set 8 dB below max setting
	 */
	uint32 meansq_min = 1111;	/* -8dB on pwr_max / 6.3  */
	uint32 i_meansq, q_meansq;
	uint8 lna2 = 0;
	uint8 lna2_rout = 0;
	uint8 dvga = 0;
	const uint8 txindx_start = 80;
	const uint8 txindx_stop  = 35;
	const uint8 txindx_step  = 12;
	int p;

	phy_iq_est_t est[PHY_CORE_MAX];

	(void)memset(est, 0, sizeof(est));

	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		gaintbl = gaintbl_5G;
	} else {
		gaintbl = gaintbl_2G;
	}
	FOREACH_CORE(pi, core) {
		g_index = 8;
		done = 0;
		found_ideal = 0;
		txdone = CHSPEC_IS2G(pi->radio_chanspec);	/* only adapt tx in 5G */
		wn = 0;
		txindex = txindx_start;
		lna_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initLnaIndex);

		while ((done != do_max) && (g_index != 0) && (g_index != ACPHY_RXCAL_NUMRXGAINS)) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) { /* papd loopback path */
				 lna = lna_idx;
				 tia = gaintbl[g_index].tia;
				 far = gaintbl[g_index].far;
				 dvga = gaintbl[g_index].dvga;
			} else { /* leakage path for 5G */
				lna = lna_idx + gaintbl[g_index].lna;
				tia = gaintbl[g_index].tia;
				far = gaintbl[g_index].far;
			}

			MOD_PHYREG(pi, RxSdFeConfig6, rx_farrow_rshift_0, far);
			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, rxgain, 1);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core,
			               (dvga << 10) | (tia << 6) | (lna2 << 3) |
			               ac_tiny_a_lna_gain_map[lna]);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core,
			               ((lna2_rout << 4) | (ac_tiny_a_lna_rout_map[lna] & 0xf)));

			MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, 0x7);

			if (!txdone)
				wlc_phy_set_txpwr_by_index_acphy(pi, (1 << core), txindex);

			/* turn on testtone */
			wlc_phy_tx_tone_acphy(pi, (((CHSPEC_IS80(pi->radio_chanspec))
			                          ? ACPHY_IQCAL_TONEFREQ_80MHz
			                          : (CHSPEC_IS40(pi->radio_chanspec))
			                              ? ACPHY_IQCAL_TONEFREQ_40MHz
			                              : ACPHY_IQCAL_TONEFREQ_20MHz) >> 1),
			                              ACPHY_RXCAL_TONEAMP, 0, 0, FALSE);

			/*
			 * Check for RF saturation by (1) power detect or (2) bb power.
			 * See txdone condition.
			 */
			for (p = 0; p < 8; p++) {
				wn +=  READ_RADIO_REGFLD_20691(pi, LNA5G_RSSI2, core,
				                               lna5g_dig_wrssi1_out_low);
				wn +=  READ_RADIO_REGFLD_20691(pi, TIA_CFG14, core, nbrssi_Ich_low);
				wn +=  READ_RADIO_REGFLD_20691(pi, TIA_CFG14, core, nbrssi_Qch_low);
			}

			/* estimate digital power using rx_iq_est */
			wlc_phy_rx_iq_est_acphy(pi, est, num_samps, 32, 0, FALSE);

			/* Turn off the tone */
			wlc_phy_stopplayback_acphy(pi);

			i_meansq = (est[core].i_pwr + num_samps / 2) / num_samps;
			q_meansq = (est[core].q_pwr + num_samps / 2) / num_samps;

#if defined(BCMDBG_RXCAL)
			printf("Rx IQCAL: txindx=%d g_index=%d lna=%d tia=%d far=%d dvga=%d\n",
			       txindex, g_index, lna, tia, far, dvga);
			printf("Rx IQCAL: i_meansq=%d q_meansq=%d meansq_max=%d meansq_min=%d\n",
				i_meansq, q_meansq, meansq_max, meansq_min);
#endif // endif
			txdone = txdone ||
				(txindex < txindx_stop) || (wn > 0) || (i_meansq > meansq_min) ||
				(q_meansq > meansq_min);

			if (!txdone) {
				txindex -= txindx_step;
				continue;
			}

			if ((i_meansq > meansq_max) || (q_meansq > meansq_max)) {
				g_index--;
				done++;
			} else if ((i_meansq < meansq_max) && (q_meansq < meansq_min)) {
				g_index++;
				done++;
			} else {
				done = do_max;
				found_ideal = 1;
			}
		}
		if (found_ideal == 0) {
			PHY_ERROR(("%s: Too much or too little power? (gain_index=%d)\n",
			           __FUNCTION__, g_index));
		}
	}
}

/* see also: proc acphy_rx_iq_cal_txrxgain_control { core } */
static void
wlc_phy_rxcal_loopback_gainctrl_acphy(phy_info_t *pi)
{
	/*
	 * joint tx-rx gain control for Rx IQ calibration
	 */

	/* gain candidates tables,
	 * columns are: B1 B0 L2 Tx-Pwr-Idx
	 * rows are monotonically increasing gain
	 */
	acphy_rxcal_txrxgain_t gaintbl_5G[ACPHY_RXCAL_NUMGAINS] =
		{
		{0, 0, 0},
		{0, 1, 0},
		{0, 2, 0},
		{0, 3, 0},
		{0, 4, 0},
		{1, 4, 0},
		{2, 4, 0},
		{3, 4, 0},
		{4, 4, 0},
		{5, 4, 0},
		{5, 5, 0}
		};
	acphy_rxcal_txrxgain_t gaintbl_2G[ACPHY_RXCAL_NUMGAINS] =
	 {
		{0, 0, 10},
		{0, 1, 10},
		{0, 2, 10},
		{0, 3, 10},
		{0, 4, 10},
		{0, 5, 10},
		{1, 5, 10},
		{2, 5, 10},
		{3, 5, 10},
		{4, 5, 10},
		{5, 5, 10}
	 };
	uint16 num_samps = 1024;
	uint32 thresh_pwr_hi = 5789 /* thresh_pwr (=4100)* 1.412 */;
	uint32 thresh_pwr_lo = 2903 /* thresh_pwr (=4100)/ 1.412 */;
	phy_iq_est_t est[PHY_CORE_MAX];
	/* threshold for "too high power"(313 mVpk, where clip = 400mVpk in 4322) */
	uint32 i_pwr, q_pwr, curr_pwr, optim_pwr = 0;
	uint32 curr_pwr_tmp;

	uint8 gainctrl_dirn[PHY_CORE_MAX];
	bool gainctrl_done[PHY_CORE_MAX];
	bool gainctrl_not_done;
	uint16 mix_tia_gain[PHY_CORE_MAX];
	int8 curr_gaintbl_index[PHY_CORE_MAX];

	acphy_rxcal_txrxgain_t *gaintbl;
	uint16 lpf_biq1_gain, lpf_biq0_gain;

	int8 txpwrindex = 0;

	uint8 core, lna2_gain = 0, lna1_gain = 0;
	uint8 curr_lna2_gain[PHY_CORE_MAX];
	int8 txpwrindex_adj[PHY_CORE_MAX];
	bool txidx_adj_en = TRUE;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		if ((ACREV_GT(pi->pubpi.phy_rev, 0)) &&
			ISACPHY(pi)) {
			lna2_gain = 6;
		}
	}
	/* 4335a0/b0 epa : turn on lna2 */
	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) &&
	    ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) {
		lna2_gain = 6;
	}
	BCM_REFERENCE(optim_pwr);
	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

#if defined(BCMDBG_RXCAL)
	printf("Rx IQCAL : Loopback Gain Control\n");
#endif /* BCMDBG_RXCAL */

	/* gain candidates */
	gaintbl = gaintbl_2G;
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		gaintbl = gaintbl_5G;
	}

	FOREACH_CORE(pi, core) {
		gainctrl_dirn[core] = ACPHY_RXCAL_GAIN_INIT;
		gainctrl_done[core] = FALSE;

		/* retrieve Rx Mixer/TIA gain from InitGain and via GainBits table */
		mix_tia_gain[core] = READ_PHYREGFLDC(pi, InitGainCodeA, core, initmixergainIndex);

		curr_gaintbl_index[core] = 0;
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			curr_gaintbl_index[core] = 4;
		}
		curr_lna2_gain[core] = lna2_gain;
		if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
		    (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
		    (CHSPEC_IS5G(pi->radio_chanspec))) {
			  lna1_gain = 5;
			  curr_lna2_gain[core] = 1;
			}
		txpwrindex_adj[core] = 0;
	}

	do {

		FOREACH_CORE(pi, core) {
			if (!gainctrl_done[core]) {

				lpf_biq1_gain   = gaintbl[curr_gaintbl_index[core]].lpf_biq1;
				lpf_biq0_gain   = gaintbl[curr_gaintbl_index[core]].lpf_biq0;
				txpwrindex      = gaintbl[curr_gaintbl_index[core]].txpwrindex
									+ txpwrindex_adj[core];

				if ((ACMAJORREV_1(pi->pubpi.phy_rev) ||
				     ACMAJORREV_2(pi->pubpi.phy_rev) ||
				     ACMAJORREV_5(pi->pubpi.phy_rev)) && PHY_IPA(pi)) {
					if (CHSPEC_IS5G(pi->radio_chanspec)) {
						txpwrindex = 80;
					} else {
						txpwrindex = 40;
					}
					txidx_adj_en = FALSE;
				}
				/* supply max gain from LNA1,LNA2 */
				if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
				    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
				    (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
				    (CHSPEC_IS5G(pi->radio_chanspec))) {
				  txpwrindex = pi_ac->txpwridx_for_rxiqcal[core];
				  txidx_adj_en = FALSE;
				}

				/* rx */
				/* LNA1 bypass mode */
				WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core,
				              mix_tia_gain[core] << 6
								| curr_lna2_gain[core] << 3
								| lna1_gain);

				if (CHSPEC_IS2G(pi->radio_chanspec)) {
					WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core, 0);
				} else if (CHSPEC_IS5G(pi->radio_chanspec)) {
					WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core, 4);
				}

				WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core,
					(lpf_biq1_gain << 3) | lpf_biq0_gain);

				MOD_PHYREGCE(pi, RfctrlOverrideGains, core, rxgain, 1);
				MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq1_gain, 1);
				MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq2_gain, 1);

				/* tx */
				wlc_phy_txpwr_by_index_acphy(pi, (1 << core), txpwrindex);
			}
		}

		/* turn on testtone (this will override bbmult, but that's ok) */
		wlc_phy_tx_tone_acphy(pi, (((CHSPEC_IS80(pi->radio_chanspec)) ?
			ACPHY_IQCAL_TONEFREQ_80MHz : (CHSPEC_IS40(pi->radio_chanspec)) ?
			ACPHY_IQCAL_TONEFREQ_40MHz : ACPHY_IQCAL_TONEFREQ_20MHz) >> 1),
			ACPHY_RXCAL_TONEAMP, 0, 0, FALSE);

		/* estimate digital power using rx_iq_est
		*/
		wlc_phy_rx_iq_est_acphy(pi, est, num_samps, 32, 0, FALSE);

		/* Turn off the tone */
		wlc_phy_stopplayback_acphy(pi);

		gainctrl_not_done = FALSE;

		FOREACH_CORE(pi, core) {
			if (!gainctrl_done[core]) {

				i_pwr = (est[core].i_pwr + num_samps / 2) / num_samps;
				q_pwr = (est[core].q_pwr + num_samps / 2) / num_samps;
				curr_pwr = i_pwr + q_pwr;
			PHY_NONE(("core %u (gain idx %d): i_pwr = %u, q_pwr = %u, curr_pwr = %d\n",
				core, curr_gaintbl_index[core], i_pwr, q_pwr, curr_pwr));

#if defined(BCMDBG_RXCAL)
			printf("Core-%d : g_id=%d MX:%d LNA2: %d BQ0:%d BQ1:%d tx_id = %d Pwr=%d\n",
				core, curr_gaintbl_index[core], mix_tia_gain[core],
				curr_lna2_gain[core],
				gaintbl[curr_gaintbl_index[core]].lpf_biq0,
				gaintbl[curr_gaintbl_index[core]].lpf_biq1,
				txpwrindex, curr_pwr);
#endif /* BCMDBG_RXCAL */

				switch (gainctrl_dirn[core]) {
				case ACPHY_RXCAL_GAIN_INIT:
					if (curr_pwr > thresh_pwr_hi) {
						gainctrl_dirn[core] = ACPHY_RXCAL_GAIN_DOWN;
						curr_pwr_tmp = curr_pwr;
						while ((curr_pwr_tmp > thresh_pwr_hi) &&
						(curr_gaintbl_index[core] > 1)) {
							curr_gaintbl_index[core]--;
							curr_pwr_tmp /= 2;
						}
					} else if  (curr_pwr < thresh_pwr_lo) {
						gainctrl_dirn[core] = ACPHY_RXCAL_GAIN_UP;
						curr_pwr_tmp = curr_pwr;
						if (curr_pwr_tmp != 0) {
							while ((curr_pwr_tmp < thresh_pwr_lo) &&
								(curr_gaintbl_index[core] <
								ACPHY_RXCAL_NUMGAINS - 3)) {
								curr_gaintbl_index[core]++;
								curr_pwr_tmp *= 2;
							}
						}
					} else {
						gainctrl_done[core] = TRUE;
						optim_pwr = curr_pwr;
					}
					break;

				case ACPHY_RXCAL_GAIN_UP:
					if (curr_pwr > thresh_pwr_lo) {
						gainctrl_done[core] = TRUE;
						optim_pwr = curr_pwr;
					} else {
						curr_gaintbl_index[core]++;
					}
					break;

				case ACPHY_RXCAL_GAIN_DOWN:
					if (curr_pwr > thresh_pwr_hi) {
						curr_gaintbl_index[core]--;
					} else {
						gainctrl_done[core] = TRUE;
						optim_pwr = curr_pwr;
					}
					break;

				default:
					PHY_ERROR(("Invalid gaintable direction id %d\n",
						gainctrl_dirn[core]));
					ASSERT(0);
				}

				if (curr_gaintbl_index[core] < 0) {
					/* Reduce the Txpower first when
					loopback signal too strong
					*/
					if ((txpwrindex < 100) && txidx_adj_en) {
							curr_gaintbl_index[core] = 0;
							txpwrindex_adj[core] += 4;
						} else {
							/* Loopback signal still too strong after
							txpower drop, reduce LNA2 gain next
							*/
							if (curr_lna2_gain[core] > 0) {
								curr_lna2_gain[core]--;
								curr_gaintbl_index[core] = 0;
							} else {
								gainctrl_done[core] = TRUE;
								optim_pwr = curr_pwr;
							}

						 }
				} else if ((curr_gaintbl_index[core] >= ACPHY_RXCAL_NUMGAINS)) {
					gainctrl_done[core] = TRUE;
					optim_pwr = curr_pwr;
				}

				gainctrl_not_done = gainctrl_not_done || (!gainctrl_done[core]);

#if defined(BCMDBG_RXCAL)
				/* Store the signal powers for SNR calculations later */
				pi_ac->rxcal_signal[core].i_pwr = est[core].i_pwr;
				pi_ac->rxcal_signal[core].q_pwr = est[core].q_pwr;
				pi_ac->rxcal_signal[core].iq_prod = est[core].iq_prod;
#endif /* BCMDBG_RXCAL */
			}
		}

	} while (gainctrl_not_done);
}

enum {
	ACPHY_RXCAL_NORMAL = 0,
	ACPHY_RXCAL_LEAKAGE_COMP
};

/* For a given target power, find txidx */
static void
wlc_phy_cal_txgain_control_dBm(phy_info_t *pi, int8 targetpwr_dBm)
{
	uint8 core = 0;
	int16  idle_tssi[PHY_CORE_MAX], tone_tssi[PHY_CORE_MAX];
	uint16 adjusted_tssi[PHY_CORE_MAX];
	int16 a1[PHY_CORE_MAX];
	int16 b0[PHY_CORE_MAX];
	int16 b1[PHY_CORE_MAX];
	int8 curr_txidx;
	int8 currpwr_qdBm, deltapwr_qdBm;
	int8 num_iters = 3, iter;
	txgain_setting_t txgain_settings;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	/* Initialize txidx */
	curr_txidx = 45;

	/* tssi loopback setup */
	wlc_phy_tssi_phy_setup_acphy(pi, 1);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 1);
	else
		wlc_phy_tssi_radio_setup_acphy(pi,  pi->sh->hw_phyrxchain, 1);

	/* Get paparams */
	wlc_phy_get_paparams_for_band_acphy(pi, a1, b0, b1);

	FOREACH_CORE(pi, core) {
		/* Initialization */
		curr_txidx = 45;
		for (iter = 0; iter < num_iters; iter++) {
			PHY_CAL(("wlc_phy_cal_txgain_control_dBm: core = %d, iter = %d, idx = %d\n",
			         core, iter, curr_txidx));

			/* Set txidx and get corresponding gain settings */
			wlc_phy_txpwr_by_index_acphy(pi, 1 << core, curr_txidx);
			wlc_phy_get_txgain_settings_by_index_acphy(
				pi, &txgain_settings, curr_txidx);

			/* Meas the idle and tone tssi */
			wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
			idle_tssi[core] = READ_PHYREGFLD(pi, TxPwrCtrlIdleTssi_path0, idleTssi0);
			idle_tssi[core] = idle_tssi[core] - 1023;
			wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi, TRUE, FALSE, &txgain_settings,
			                             FALSE, TRUE, core, 0);
			adjusted_tssi[core] = 1024+idle_tssi[core] - tone_tssi[core];
			adjusted_tssi[core] = adjusted_tssi[core] >> 3;

			/* Get output power, diff with target (in qdBm) */
			currpwr_qdBm = wlc_phy_tssi2dbm_acphy(pi, adjusted_tssi[core],
			  a1[core], b0[core], b1[core]);
			PHY_CAL(("wlc_phy_cal_txgain_control_dBm: currpwr (qdBm) %d\n",
			         currpwr_qdBm));
			deltapwr_qdBm = (currpwr_qdBm - (targetpwr_dBm << 2));

			/* Update txidx */
			curr_txidx = (deltapwr_qdBm >> 1) + curr_txidx;
			if (curr_txidx < 0)
				curr_txidx = 0;

			PHY_CAL(("wlc_phy_cal_txgain_control_dBm: deltapwr (qdBm) = %d - %d = %d\n",
			         currpwr_qdBm, targetpwr_dBm << 2, deltapwr_qdBm));
			PHY_CAL(("wlc_phy_cal_txgain_control_dBm: new_idx = %d\n", curr_txidx));
		}
		pi_ac->txpwridx_for_rxiqcal[core] = curr_txidx;
	}
}

static void
wlc_phy_calc_iq_mismatch_acphy(phy_iq_est_t *est, acphy_iq_mismatch_t *mismatch)
{

	/* angle = asin (-iq / sqrt( ii*qq ))
	* mag   = sqrt ( qq/ii )
	*/

	int32  iq = est->iq_prod;
	uint32 ii = est->i_pwr;
	uint32 qq = est->q_pwr;

	int16  iq_nbits, qq_nbits, ii_nbits;
	int32  tmp;
	int32  den, num;
	int32  angle;
	cint32 val;

	iq_nbits = wlc_phy_nbits(iq);
	qq_nbits = wlc_phy_nbits(qq);
	ii_nbits = wlc_phy_nbits(ii);
	if (ii_nbits > qq_nbits)
		qq_nbits = ii_nbits;

	if (30 >=  qq_nbits) {
		tmp = ii;
		tmp = tmp << (30 - qq_nbits);
		den = (int32) wlc_phy_sqrt_int((uint32) tmp);
		tmp = qq;
		tmp = tmp << (30 - qq_nbits);
		den *= (int32) wlc_phy_sqrt_int((uint32) tmp);
	} else {
		tmp = ii;
		tmp = tmp >> (qq_nbits - 30);
		den = (int32) wlc_phy_sqrt_int((uint32) tmp);
		tmp = qq;
		tmp = tmp >> (qq_nbits - 30);
		den *= (int32) wlc_phy_sqrt_int((uint32) tmp);
	}
	if (qq_nbits <= iq_nbits + 16) {
		den = den >> (16 + iq_nbits - qq_nbits);
	} else {
		den = den << (qq_nbits - (16 + iq_nbits));
	}

	tmp = -iq;
	num = (tmp << (30 - iq_nbits));
	if (num > 0)
		num += (den >> 1);
	else
		num -= (den >> 1);

	if (den == 0) {
		tmp = 0;
	} else {
		tmp = num / den; /* in X,16 */
	}

	mismatch->sin_angle = tmp;

	tmp = (tmp >> 1);
	tmp *= tmp;
	tmp = (1 << 30) - tmp;
	val.i = (int32) wlc_phy_sqrt_int((uint32) tmp);
	val.i = ( val.i << 1) ;

	val.q = mismatch->sin_angle;
	wlc_phy_inv_cordic(val, &angle);
	mismatch->angle = angle; /* in X,16 */

	iq_nbits = wlc_phy_nbits(qq - ii);
	if (iq_nbits % 2 == 1)
		iq_nbits++;

	den = ii;

	num = qq - ii;
	num = num << (30 - iq_nbits);
	if (iq_nbits > 10)
		den = den >> (iq_nbits - 10);
	else
		den = den << (10 - iq_nbits);
	if (num > 0)
		num += (den >> 1);
	else
		num -= (den >> 1);

	if (den == 0) {
		mismatch->mag = (1 << 10); /* in X,10 */
	} else {
		tmp = num / den + (1 << 20);
		mismatch->mag = (int32) wlc_phy_sqrt_int((uint32) tmp); /* in X,10 */
	}

#if defined(BCMDBG_RXCAL)
	printf("      Mag=%d, Angle=%d, cos(angle)=%d, sin(angle)=%d\n",
	(int)mismatch->mag, (int)mismatch->angle, (int)val.i, (int)val.q);
#endif /* BCMDBG_RXCAL */

}

static int
wlc_phy_cal_rx_fdiqi_acphy(phy_info_t *pi)
{
	acphy_rx_fdiqi_t freq_ang_mag[ACPHY_RXCAL_MAX_NUM_FREQ];
	int8 fdiqi_cal_freqs[ACPHY_RXCAL_MAX_NUM_FREQ];
	uint16 num_data, bbmult = 0;
	uint8 core;
	phy_iq_est_t loopback_rx_iq[PHY_CORE_MAX];
	phy_iq_est_t leakage_rx_iq[PHY_CORE_MAX];
	int32 angle;
	int32 mag;
	uint8 freq_idx;
	int16 tone_freq;
	uint16 *coeff_ptr;
	uint16 coeff_vals_temp[8] = {0}; /* accounting for max 4 core case */
	uint16 start_coeffs_RESTART[] = {0, 0, 0, 0, 0, 0, 0, 0};
	int8 k;
	acphy_cal_result_t *accal = &pi->cal_info->u.accal;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	/* Enable leakage compensation by default */
	/* Disable leakage compensation for selected revisions only */
	/* LNA1 bypass mode */
	pi_ac->fdiqi.leakage_comp_mode = ACPHY_RXCAL_LEAKAGE_COMP;

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		pi_ac->fdiqi.leakage_comp_mode = ACPHY_RXCAL_NORMAL;
	}

	if (ACREV_IS(pi->pubpi.phy_rev, 1) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			pi_ac->fdiqi.leakage_comp_mode = ACPHY_RXCAL_NORMAL;
		}
	}

	if (PHY_ILNA(pi) && ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
			(ACMAJORREV_3(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec))) &&
			DSSF_ENABLE) {
		wlc_phy_dssf_acphy(pi, FALSE);
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && DSSFB_ENABLE &&
	    !ACMINORREV_0(pi->pubpi.phy_rev) && !ACMINORREV_2(pi->pubpi.phy_rev) &&
	    CHSPEC_IS2G(pi->radio_chanspec) && (pi->u.pi_acphy->srom.spur_war_enb_2g == 1)) {
		wlc_phy_dssfB_acphy(pi, FALSE);
	}

	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RESET2RX);

	/* Zero Out coefficients */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_rx_iq_comp_acphy(pi, 2, NULL, core);
	}
	wlc_phy_rx_fdiqi_comp_acphy(pi, FALSE);

	/* Save original TX comp coeffs
	 *  Load the special TX IQ COMP coefficients
	 */
	coeff_ptr = start_coeffs_RESTART;
	if (!TINY_RADIO(pi)) {
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	  wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
	      coeff_ptr + 2*core, TB_OFDM_COEFFS_AB, core);
	  for (k = 0; k < 2; k++) {
	    coeff_vals_temp[k] = accal->txiqlocal_biq2byp_coeffs[2*core + k];
	  }
	  wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
	      coeff_vals_temp, TB_OFDM_COEFFS_AB, core);
	}
	}

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) &&
	    (ACRADIO_2069_EPA_IS(pi->pubpi.radiorev)) &&
	    (CHSPEC_IS5G(pi->radio_chanspec))) {
		/* Find tx_idx for target pwr 10dBm. This txidx will be used for rx iq cal. */
		wlc_phy_cal_txgain_control_dBm(pi, 10);
	}

	wlc_phy_rxcal_phy_setup_acphy(pi);

	if (TINY_RADIO(pi)) {
		wlc_phy_rxcal_radio_setup_acphy_tiny(pi);
		/* turn on testtone */
		wlc_phy_tx_tone_acphy(pi, (((CHSPEC_IS80(pi->radio_chanspec))
			                          ? ACPHY_IQCAL_TONEFREQ_80MHz
			                          : (CHSPEC_IS40(pi->radio_chanspec))
			                              ? ACPHY_IQCAL_TONEFREQ_40MHz
			                              : ACPHY_IQCAL_TONEFREQ_20MHz) >> 1),
			                              ACPHY_RXCAL_TONEAMP, 0, 0, FALSE);
		wlc_phy_set_tx_bbmult_acphy(pi, &bbmult, 0);
		if (ACREV_GE(pi->pubpi.phy_rev, 11)) {
			wlc_dcc_fsm_reset(pi);
		} else {
			MOD_PHYREG(pi, dcc_ctrl_restart_length_grp,
				dcc_ctrl_restart_length, 0x1);
			MOD_PHYREG(pi, rx_tia_dc_loop_0, restart_gear, 0x1);
			OSL_DELAY(10);
			MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl,  0x0);
		}
		wlc_phy_stopplayback_acphy(pi);
		wlc_phy_rxcal_txrx_gainctrl_acphy_tiny(pi);
	} else {
		wlc_phy_rxcal_radio_setup_acphy(pi);
		wlc_phy_rxcal_loopback_gainctrl_acphy(pi);
	}

	wlc_phy_rx_fdiqi_freq_config(pi, fdiqi_cal_freqs, &num_data);

	for (freq_idx = 0; freq_idx < num_data; freq_idx++) {

		tone_freq = (int16)fdiqi_cal_freqs[freq_idx] * 1000;
		tone_freq = tone_freq >> 1;

		freq_ang_mag[freq_idx].freq = (int32)fdiqi_cal_freqs[freq_idx];
		wlc_phy_tx_tone_acphy(pi, (int32)tone_freq, ACPHY_RXCAL_TONEAMP, 0, 0, FALSE);

		/* get iq, ii, qq measurements from iq_est */
		if (pi->u.pi_acphy->fdiqi.enabled) {
			wlc_phy_rx_iq_est_acphy(pi, loopback_rx_iq, 0x3000, 32, 0, TRUE);
		} else {
			wlc_phy_rx_iq_est_acphy(pi, loopback_rx_iq, 0x4000, 32, 0, TRUE);
		}

		if (pi_ac->fdiqi.leakage_comp_mode == ACPHY_RXCAL_LEAKAGE_COMP) {
			if (TINY_RADIO(pi)) {
				wlc_phy_rxcal_radio_cleanup_acphy_tiny(pi);
				wlc_phy_rx_iq_est_acphy(pi, leakage_rx_iq, 0x4000, 32, 0, TRUE);
				wlc_phy_rxcal_radio_setup_acphy_tiny(pi);
			} else {
				wlc_phy_rxcal_radio_cleanup_acphy(pi);
				wlc_phy_rx_iq_est_acphy(pi, leakage_rx_iq, 0x4000, 32, 0, TRUE);
				wlc_phy_rxcal_radio_setup_acphy(pi);
			}
		}
		wlc_phy_stopplayback_acphy(pi);

#if defined(BCMDBG_RXCAL)
		printf("  tone freq  %d ", freq_ang_mag[freq_idx].freq);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			printf(" iq:%d \ti2:%d \tq2: %d\n", loopback_rx_iq[core].iq_prod,
				loopback_rx_iq[core].i_pwr, loopback_rx_iq[core].q_pwr);
		}
		if (pi_ac->fdiqi.leakage_comp_mode == ACPHY_RXCAL_LEAKAGE_COMP) {
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				printf(" %d %d %d ", leakage_rx_iq[core].iq_prod,
					leakage_rx_iq[core].i_pwr, leakage_rx_iq[core].q_pwr);
			}
		}
		printf("\n");
#endif /* BCMDBG_RXCAL */

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_rxcal_leakage_comp_acphy(pi, loopback_rx_iq[core],
				leakage_rx_iq[core], &angle, &mag);
			freq_ang_mag[ freq_idx ].angle[core] = angle;
			freq_ang_mag[ freq_idx ].mag[core] = mag;
		}
	}

	wlc_phy_rx_fdiqi_lin_reg_acphy(pi, freq_ang_mag, num_data);

	if (TINY_RADIO(pi))
		wlc_phy_rxcal_radio_cleanup_acphy_tiny(pi);
	else
		wlc_phy_rxcal_radio_cleanup_acphy(pi);

	wlc_phy_rxcal_phy_cleanup_acphy(pi);
	/* restore the coeffs after RX-cal */
	if (!TINY_RADIO(pi)) {
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	  wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
	      coeff_ptr + 2*core, TB_OFDM_COEFFS_AB, core);
	}
	}

#if defined(BCMDBG_RXCAL)
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Measure the SNR in the Rx IQ cal feedback path */
		wlc_phy_rxcal_snr_acphy(pi, 0x4000, (1 << core));

		PHY_CAL(("wlc_phy_cal_rx_iq_acphy: core%d => "
		    "(S =%9d,  N =%9d,  K =%d)\n",
		    core,
		    pi_ac->rxcal_signal[core].i_pwr + pi_ac->rxcal_signal[core].q_pwr,
		    pi_ac->rxcal_noise[core].i_pwr + pi_ac->rxcal_noise[core].q_pwr,
		    0x4000));
	}
#endif /* BCMDBG_RXCAL */

	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	 /* For 4345 need to calibrate dc offset after cleanup */
	if (TINY_RADIO(pi)) {
	    if (ACREV_GE(pi->pubpi.phy_rev, 11)) {
		wlc_dcc_fsm_reset(pi);
	    } else {
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, dcc_ctrl_restart_length_grp,
				dcc_ctrl_restart_length, 0xffff)
			MOD_PHYREG_ENTRY(pi, rx_tia_dc_loop_0, restart_gear, 0x6)
			MOD_PHYREG_ENTRY(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl,  0x1)
		ACPHY_REG_LIST_EXECUTE(pi);
		OSL_DELAY(10);
	    }
	}

	if (PHY_ILNA(pi) && ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
			(ACMAJORREV_3(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec))) &&
			DSSF_ENABLE) {
		wlc_phy_dssf_acphy(pi, TRUE);
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && DSSFB_ENABLE &&
	    !ACMINORREV_0(pi->pubpi.phy_rev) && !ACMINORREV_2(pi->pubpi.phy_rev) &&
	    CHSPEC_IS2G(pi->radio_chanspec) && (pi->u.pi_acphy->srom.spur_war_enb_2g == 1)) {
		wlc_phy_dssfB_acphy(pi, TRUE);
	}
	return BCME_OK;
}

static void
wlc_phy_rx_fdiqi_freq_config(phy_info_t *pi, int8 *fdiqi_cal_freqs, uint16 *num_data)
{

	uint8 fdiqi_en;
	fdiqi_cal_freqs[0] = (int8)((CHSPEC_IS80(pi->radio_chanspec) ? ACPHY_IQCAL_TONEFREQ_80MHz :
		CHSPEC_IS40(pi->radio_chanspec) ? ACPHY_IQCAL_TONEFREQ_40MHz :
		ACPHY_IQCAL_TONEFREQ_20MHz)/1000);
	fdiqi_cal_freqs[1] = - fdiqi_cal_freqs[0];
	*num_data = 2;

	/* rx_fdiqi is enabled in 80MHz channel by default unless it's forced OFF */
	fdiqi_en = CHSPEC_IS80(pi->radio_chanspec) ||
	           (CHSPEC_IS40(pi->radio_chanspec) &&
	           (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)));

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID) {
	  if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
	    fdiqi_en = 1;
	  }
	}

	if (pi->fdiqi_disable) {
		fdiqi_en = FALSE;
	}

	pi->u.pi_acphy->fdiqi.enabled = fdiqi_en;

#if defined(BCMDBG)
	if (pi->u.pi_acphy->fdiqi.forced) {
		switch (pi->u.pi_acphy->fdiqi.forced_val) {
		case 0:
			pi->u.pi_acphy->fdiqi.enabled = FALSE;
			break;
		case 1:
			pi->u.pi_acphy->fdiqi.enabled = fdiqi_en;
			break;
		case 2:
			pi->u.pi_acphy->fdiqi.enabled = TRUE;
			break;
		}
	} else {
		pi->u.pi_acphy->fdiqi.enabled = fdiqi_en;
	}
#endif /* BCMDBG */

	if (pi->u.pi_acphy->fdiqi.enabled) {
		if (CHSPEC_IS80(pi->radio_chanspec)) {
			fdiqi_cal_freqs[2] = 24;
			fdiqi_cal_freqs[3] = - fdiqi_cal_freqs[2];
			fdiqi_cal_freqs[4] = 32;
			fdiqi_cal_freqs[5] = - fdiqi_cal_freqs[4];
			*num_data = 6;
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			fdiqi_cal_freqs[2] = 15;
			fdiqi_cal_freqs[3] = - fdiqi_cal_freqs[2];
			*num_data = 4;
		} else {
			fdiqi_cal_freqs[2] = 7;
			fdiqi_cal_freqs[3] = - fdiqi_cal_freqs[2];
			*num_data = 4;
		}
	}

}

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP)
void wlc_phy_force_gainlevel_acphy(phy_info_t *pi, int16 int_val)
{
	uint8 core;

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {

		/* disable clip2 */
		MOD_PHYREGC(pi, computeGainInfo, core, disableClip2detect, 1);
		WRITE_PHYREGC(pi, Clip2Threshold, core, 0xffff);
		printf("wlc_phy_force_gainlevel_acphy (%d) : ", int_val);
	switch (int_val) {
	case 0:
		printf("initgain -- adc never clips.\n");
		if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			WRITE_PHYREGC(pi, Clip1Threshold, core, 0xffff);
		} else {
			MOD_PHYREGC(pi, computeGainInfo, core, disableClip1detect, 1);
		}
		break;
	case 1:
		printf("clip hi -- adc always clips, nb never clips.\n");
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh, 0xff);
		break;
	case 2:
		printf("clip md -- adc/nb always clips, w1 never clips.\n");
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh, 0);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcW1ClipCntTh, 0xff);
		break;
	case 3:
		printf("clip lo -- adc/nb/w1 always clips.\n");
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh, 0);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcW1ClipCntTh, 0);
		break;
	case 4:
		printf("adc clip.\n");
		WRITE_PHYREGC(pi, clipHiGainCodeA, core, 0x0);
		WRITE_PHYREGC(pi, clipHiGainCodeB, core, 0x8);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh, 0xff);
		break;
	case 5:
		printf("nb clip.\n");
		WRITE_PHYREGC(pi, clipmdGainCodeA, core, 0xfffe);
		WRITE_PHYREGC(pi, clipmdGainCodeB, core, 0x554);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcW1ClipCntTh, 0xff);
		break;
	case 6:
		printf("w1 clip.\n");
		WRITE_PHYREGC(pi, cliploGainCodeA, core, 0xfffe);
		WRITE_PHYREGC(pi, cliploGainCodeB, core, 0x554);
		MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcNbClipMuxSel, 0);
		ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
		MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_Refctrl_low, 1);
		break;
	}
	}
	printf("wlc_phy_force_gainlevel_acphy (%d)\n", int_val);
}
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) */

#if defined(WLTEST)
void wlc_phy_force_spurmode_acphy(phy_info_t *pi, int16 int_val)
{
	uint16 freq;
	freq = (uint16)wlc_phy_channel2freq(CHSPEC_CHANNEL(pi->radio_chanspec));
	if (pi->block_for_slowcal) {
		pi->blocked_freq_for_slowcal = freq;
		return;
	}

	switch (int_val) {
	case -1:
		PHY_TRACE(("Spurmode override is off; default spurmode restored; %s \n",
		__FUNCTION__));
		wlc_phy_get_spurmode(pi, freq);
		break;
	case 0:
		PHY_TRACE(("Force spurmode to 0; chanfreq %d: PLLfre:963Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 0;
		break;
	case 1:
		PHY_TRACE(("Force spurmode to 1; chanfreq %d: PLLfre:960Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 1;
		break;
	case 2:
		PHY_TRACE(("Force spurmode to 2; chanfreq %d: PLLfre:961Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 2;
		break;
	case 3:
		PHY_TRACE(("Force spurmode to 3; chanfreq %d: PLLfre:964Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 3;
		break;
	case 4:
		PHY_TRACE(("Force spurmode to 4; chanfreq %d: PLLfre:962Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 4;
		break;
	case 5:
		PHY_TRACE(("Force spurmode to 5; chanfreq %d: PLLfre:965Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 5;
		break;
	case 6:
		PHY_TRACE(("Force spurmode to 6; chanfreq %d: PLLfre:966Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 6;
		break;
	case 7:
		PHY_TRACE(("Force spurmode to 7; chanfreq %d: PLLfre:967Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 7;
		break;
	case 8:
		PHY_TRACE(("Force spurmode to 8; chanfreq %d: PLLfre:968Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 8;
		break;
	case 9:
		PHY_TRACE(("Force spurmode to 9; chanfreq %d: PLLfre:969Mhz; %s \n",
			freq, __FUNCTION__));
		pi->acphy_spuravoid_mode = 9;
		break;
	default:
		PHY_ERROR(("wl%d: %s: Unsupported spurmode %d.\n",
			pi->sh->unit, __FUNCTION__, int_val));
		ASSERT(0);
		wlc_phy_get_spurmode(pi, freq);
		return;
	}
	/* Call the bbpll settings related function only if the forced */
	/* spur mode is different from the current spur mode */
	if (pi->u.pi_acphy->curr_spurmode != pi->acphy_spuravoid_mode) {
		wlc_phy_setup_spurmode(pi);
		pi->u.pi_acphy->curr_spurmode =  pi->acphy_spuravoid_mode;
	}

}
#endif /* defined(WLTEST) */

#if defined(BCMDBG)
void wlc_phy_force_fdiqi_acphy(phy_info_t *pi, uint16 int_val)
{

	pi->u.pi_acphy->fdiqi.forced = TRUE;
	pi->u.pi_acphy->fdiqi.forced_val = int_val;
	wlc_phy_cals_acphy(pi, 0);

}
#endif // endif

#if defined(WLTEST) || defined(BCMDBG)
/* Special function to detect hanging IQ Cal PHYREG status and overwrite it if necessary.
   SWWLAN-144335 */
static void
wlc_phy_iqlocal_state_check_acphy(phy_info_t *pi)
{
	uint16 iqlo_cal_en = 0;
	iqlo_cal_en = phy_reg_read(pi,ACPHY_iqloCalCmdGctl(pi->pubpi.phy_rev)) &
			ACPHY_iqloCalCmdGctl_iqlo_cal_en_MASK(pi->pubpi.phy_rev);
	if (iqlo_cal_en) {
		PHY_ERROR(("wlc_phy_iqlocal_state_check_acphy: iqlo cal still on, forcing off.\n"));
		ASSERT(0);
		phy_reg_and(pi, ACPHY_iqloCalCmdGctl(pi->pubpi.phy_rev),
			(uint16)~ACPHY_iqloCalCmdGctl_iqlo_cal_en_MASK(pi->pubpi.phy_rev));
	}
}
#endif // endif

static void
wlc_phy_populate_tx_iqlo_comp_tables_acphy(phy_info_t *pi, uint8 start_idx, uint8 stop_idx)
{
	uint8 i, coeffs_lo[2];
	uint16 coeffs_iq[2], data_lo;
	uint32 data_iq;

	wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		coeffs_iq, TB_OFDM_COEFFS_AB,  0);
	wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		(uint16*) coeffs_lo, TB_OFDM_COEFFS_D, 0);

	data_iq = (((uint32)(coeffs_iq[0]) << 10) & 0xffc00) + (coeffs_iq[1] & 0x3ff);
	data_lo = ((uint16)(coeffs_lo[0]) << 8) + coeffs_lo[1];

	for (i = start_idx; i <= stop_idx; i++) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQCOEFFLUTS0, 1,
			i, 32, &data_iq);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LOFTCOEFFLUTS0, 1,
			i, 16, &data_lo);
	}
}

void
wlc_phy_cals_acphy(phy_info_t *pi, uint8 searchmode)
{
	/* XXX FIXME:
	 * ToDo:
	 *       - CTS-to-self for Rx cal / all cals? see nphy
	 *       - radar protection ? covered already?
	 */

	uint8 core;
	uint8 tx_pwr_ctrl_state;
	uint8 phase_id = pi->cal_info->cal_phase_id;
	acphy_cal_result_t *accal = &pi->cal_info->u.accal;
	uint16 tbl_cookie = TXCAL_CACHE_VALID;
	int8 tx_idx, tx_idx_pwr;
	uint16 cal_exec_time, papd_cal_time;
	uint8 papdmode = pi->u.pi_acphy->papdmode;
	uint8 band;
	/* Local copy of rxchain */
	uint8 save_active_rxchains = 0;
	/* Local copy of EnTx */
	uint8 save_EnTx = 0;
	/* Force turn on flag */
	uint8 force_turnon = 0;
	int16 idac_i = 0, idac_q = 0;
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
	ch_calcache_t *ctx = NULL;
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif

	PHY_CAL(("wl%d: Running ACPHY periodic calibration: Searchmode: %d \n",
	         pi->sh->unit, searchmode));

	/* -----------------
	 *  Initializations
	 * -----------------
	 */

	/* Exit immediately if we are running on Quickturn */
	if (ISSIM_ENAB(pi->sh->sih)) {
		wlc_phy_cal_perical_mphase_reset(pi);
		return;
	}

	/* skip cal if phy is muted */
	if (PHY_MUTED(pi) && !TINY_RADIO(pi)) {
		return;
	}

	/* Get current subband information */
	band = wlc_phy_get_chan_freq_range_acphy(pi, 0);

	/* Force turn on radio chains if necessary */
	if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	}

	if (ACPHY_ENABLE_FCBS_HWACI(pi)) {
		/* Disable HWACI FCBS operation during any cal */
		MOD_PHYREG(pi, aci_detector_reset, aci_detector_hold, 1);
		MOD_PHYREG(pi, aci_detector_reset, aci_detector_reset_mask, 0);
		/* Ensure that ACI/FCBS is disabled before proceeding with cals */
		while ((READ_PHYREG(pi, FastChanSW_Status) & 0xe) != 0x0) {
			OSL_DELAY(1);
		}
	}

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		if (ACREV_GE(pi->pubpi.phy_rev, 13))
			wlc_enable_lna_dcc_comp_20691(pi, 0);

		if (!ACMINORREV_1(pi->pubpi.phy_rev)) {
			wlc_idac_read_20691(pi, &idac_i, &idac_q);
		}
	}
	if (TINY_RADIO(pi)) {
		/* switch back to original rx2tx seq and dly for tiny cal */
		wlc_phy_tiny_rfseq_mode_set(pi, 1);
		if (pi->u.pi_acphy->dac_mode != 1) {
			pi->u.pi_acphy->dac_mode = 1;
			wlc_phy_dac_rate_mode_acphy(pi, pi->u.pi_acphy->dac_mode);
		}
	}

	/* XXX: Do the noise cal as first thing,
	   for some reason doing it at the end casues bad noise value
	*/
	if ((phase_id == MPHASE_CAL_STATE_IDLE) || (phase_id == ACPHY_CAL_PHASE_RXCAL)) {
	  if ((pi->u.pi_acphy->crsmincal_enable)) {
			PHY_CAL(("%s : crsminpwr cal\n", __FUNCTION__));
			pi->u.pi_acphy->force_crsmincal = TRUE;
			wlc_phy_noise_sample_request_crsmincal((wlc_phy_t*)pi);
		}
	}

	/*
	 * Search-Mode Sanity Check for Tx-iqlo-Cal
	 *
	 * Notes: - "RESTART" means: start with 0-coeffs and use large search radius
	 *        - "REFINE"  means: start with latest coeffs and only search
	 *                    around that (faster)
	 *        - here, if channel has changed or no previous valid coefficients
	 *          are available, enforce RESTART search mode (this shouldn't happen
	 *          unless cal driver code is work-in-progress, so this is merely a safety net)
	 */
	if ((pi->radio_chanspec != accal->chanspec) ||
	    (accal->txiqlocal_coeffsvalid == 0)) {
		searchmode = PHY_CAL_SEARCHMODE_RESTART;
	}

	/*
	 * If previous phase of multiphase cal was on different channel,
	 * then restart multiphase cal on current channel (again, safety net)
	 */
	if ((phase_id > MPHASE_CAL_STATE_INIT)) {
		if (accal->chanspec != pi->radio_chanspec) {
			wlc_phy_cal_perical_mphase_restart(pi);
		}
	}

#ifdef WFD_PHY_LL_DEBUG
	uint32 cal_phase_id = pi->cal_info->cal_phase_id;
	uint32 start_time = hndrte_time_us();
#endif // endif

	/* Make the ucode send a CTS-to-self packet with duration set to 10ms. This
	 *  prevents packets from other STAs/AP from interfering with Rx IQcal
	 */
	/* XXX FIXME
	 *	if ((pi->mphase_cal_phase_id == MPHASE_CAL_STATE_RXCAL)) {
	 *		wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, 10000);
	 *	}
	 */
	/* Disable Power control */
	tx_pwr_ctrl_state = pi->txpwrctrl;

	/* If single phase cal send out CTS to self to ensure assoc/join */

	cal_exec_time = 29000;
	if (papdmode == PAPD_ANALYTIC) {
		papd_cal_time = 8000;
	} else if (papdmode == PAPD_ANALYTIC_WO_YREF) {
		papd_cal_time = 5000;
	} else {
		papd_cal_time = 12000;
	}

	if (phase_id == MPHASE_CAL_STATE_IDLE) {
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
			if PHY_PAPDEN(pi) {
				cal_exec_time = cal_exec_time + papd_cal_time;
			}
		}
		wlc_phy_susp2tx_cts2self(pi, cal_exec_time);
	}

	pi->u.pi_acphy->radar_cal_active = TRUE;

	/* -------------------
	 *  Calibration Calls
	 * -------------------
	 */

	PHY_CAL(("wlc_phy_cals_acphy: Time=%d, LastTi=%d, SrchMd=%d, PhIdx=%d,"
		" Chan=%d, LastCh=%d, First=%d, vld=%d\n",
		pi->sh->now, pi->cal_info->last_cal_time, searchmode, phase_id,
		pi->radio_chanspec, accal->chanspec,
		pi->first_cal_after_assoc, accal->txiqlocal_coeffsvalid));

	if (phase_id == MPHASE_CAL_STATE_IDLE) {
		/*
		 * SINGLE-SHOT Calibrations
		 *
		 *    Call all Cals one after another
		 *
		 *    Notes:
		 *    - if this proc is called with the phase state in IDLE,
		 *      we know that this proc was called directly rather
		 *      than via the mphase scheduler (the latter puts us into
		 *      INIT state); under those circumstances, perform immediate
		 *      execution over all cal tasks
		 *    - for better code structure, we would use the below mphase code for
		 *      sphase case, too, by utilizing an appropriate outer for-loop
		 */

		/* TO-DO: Ensure that all inits and cleanups happen here */

#ifdef PHY_XTAL_SPUR_CAL
		/* Xtal spur cal
		 * First cal as you do not want to cal with large spurs
		 */
		wlc_acphy_cal_xtal_spur(pi, TRUE, FALSE);
#endif /* PHY_XTAL_SPUR_CAL */

		/* carry out all phases "en bloc", for comments see the various phases below */
		pi->cal_info->last_cal_time     = pi->sh->now;
		accal->chanspec = pi->radio_chanspec;
		if (!TINY_RADIO(pi)) {
			wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
		}
		if (TINY_RADIO(pi) && (READ_RADIO_REGFLD_20691(pi, PLL_DSPR27, 0,
			rfpll_monitor_need_refresh) == 1)) {
			wlc_phy_radio20691_vcocal(pi);
		}

		if (ACMAJORREV_3(pi->pubpi.phy_rev) && PHY_IPA(pi) &&
			CHSPEC_IS5G(pi->radio_chanspec)) {
			/* reset ladder_updated flags so tx-iqlo-cal ensures appropriate
			 * recalculation
			 */
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				accal->txiqlocal_ladder_updated[core] = 0;
			}
			/* Temperature based iq lo cal */
			wlc_phy_get_txgain_settings_by_index_acphy(
				pi, accal->txcal_txgain, 12);
			wlc_phy_cal_txiqlo_acphy(pi, searchmode, FALSE, 0);
			wlc_phy_populate_tx_iqlo_comp_tables_acphy(pi, 0, 31);

			OSL_DELAY(100);

			/* reset ladder_updated flags so tx-iqlo-cal ensures appropriate
			 * recalculation
			 */
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				accal->txiqlocal_ladder_updated[core] = 0;
			}
			wlc_phy_get_txgain_settings_by_index_acphy(
				pi, accal->txcal_txgain, 75);
			wlc_phy_cal_txiqlo_acphy(pi, searchmode, FALSE, 0);
			wlc_phy_populate_tx_iqlo_comp_tables_acphy(pi, 32, 64);

			OSL_DELAY(100);

			/* reset ladder_updated flags so tx-iqlo-cal ensures appropriate
			 * recalculation
			 */
			FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
				accal->txiqlocal_ladder_updated[core] = 0;
			}
			wlc_phy_get_txgain_settings_by_index_acphy(
				pi, accal->txcal_txgain, 120);
			wlc_phy_cal_txiqlo_acphy(pi, searchmode, FALSE, 0);
			wlc_phy_populate_tx_iqlo_comp_tables_acphy(pi, 65, 127);

			/* Read iqlo coeffs from txpwrctrl tables */
			MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsIQ, 1);
			MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefsLO, 1);
		} else {
			wlc_phy_precal_txgain_acphy(pi, accal->txcal_txgain);
			wlc_phy_cal_txiqlo_acphy(pi, searchmode, FALSE, 0); /* request "Sphase" */
		}
		if (TINY_RADIO(pi)) {
			if (ACMAJORREV_3(pi->pubpi.phy_rev) &&
			    ACMINORREV_1(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec)) {
				wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
				wlc_20691_coarse_dcoc(pi);
				wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
			} else if (ACREV_GE(pi->pubpi.phy_rev, 11)) {
				/* phy revid >= 11  4345b0 & 43457 */
				wlc_phy_tiny_static_dc_offset_cal(pi);
			}
		}
		if (!TINY_RADIO(pi)) {
		wlc_phy_precal_txgain_acphy(pi, accal->txcal_txgain);
		wlc_phy_cal_txiqlo_acphy(pi, searchmode, FALSE, 1); /* request "Sphase" */
		}

		/* fdiq cal causes tx sweep of tones, so disable it upon edcrs detect */
		if (!wlc_phy_eu_edcrs_detect_acphy(pi)) {
			wlc_phy_cal_rx_fdiqi_acphy(pi);
		}

		if (TINY_RADIO(pi)) {
			wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
		}

		if (PHY_ILNA(pi) &&
		    ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
		     (ACMAJORREV_3(pi->pubpi.phy_rev) && CHSPEC_IS2G(pi->radio_chanspec))) &&
		    DSSF_ENABLE) {
			wlc_phy_dssf_acphy(pi, TRUE);
		}

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
		                          IQTBL_CACHE_COOKIE_OFFSET, 16, &tbl_cookie);

		/* Do PAPD cal */
		/* disable PAPD cal if edcrs is high */
		if (PHY_PAPDEN(pi) && (!wlc_phy_eu_edcrs_detect_acphy(pi))) {
			PHY_PAPD(("PAPD : PHY_IPA(pi) = %d", PHY_IPA(pi)));
			if (TINY_RADIO(pi)) {
				/* use for phy_pacalidx0 and phy_pacalidx1 iovar */
				pi->u.pi_acphy->papd_lut0_cal_idx = -1;
				pi->u.pi_acphy->papd_lut1_cal_idx = -1;

				/* 4th priority: default cal index */
				if (CHSPEC_IS2G(pi->radio_chanspec)) {
					tx_idx = 26;
				} else {
					tx_idx = 38;
				}
				if (PHY_EPAPD(pi)) {
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
#ifndef WLC_POINT5_DB_TX_GAIN_STEP /* Disable 0.5 dB gain step */
						tx_idx = 48;
					} else {
						if (band <= WL_CHAN_FREQ_RANGE_5G_BAND1) {
							tx_idx = 56;
						} else {
							tx_idx = 64;
						}
#else
						tx_idx = 24;
					} else {
						if (band <= WL_CHAN_FREQ_RANGE_5G_BAND1) {
							tx_idx = 28;
						} else {
							tx_idx = 32;
						}
#endif /* Disable 0.5 dB gain step */
					}
				}

				/* 3rd priority: pacalindex from nvram */
				if (CHSPEC_IS2G(pi->radio_chanspec) &&
					(pi->pacalindex2g != -1)) {
					tx_idx = pi->pacalindex2g;
				} else {
					if ((band <= WL_CHAN_FREQ_RANGE_5G_BAND1) &&
						(pi->pacalindex5g[0] != -1)) {
						tx_idx = pi->pacalindex5g[0];
					} else if ((band == WL_CHAN_FREQ_RANGE_5G_BAND2) &&
						(pi->pacalindex5g[1] != -1)) {
						tx_idx = pi->pacalindex5g[1];
					} else if ((band == WL_CHAN_FREQ_RANGE_5G_BAND3) &&
						(pi->pacalindex5g[2] != -1)) {
						tx_idx = pi->pacalindex5g[2];
					}
				}

				/* 2nd priority: pacalpwr from nvram */
				tx_idx_pwr = wlc_phy_tone_pwrctrl(pi, 96, 0);
				if (tx_idx_pwr != -1) {
					if ((tx_idx_pwr == 0) ||
						(tx_idx_pwr == 127)) {
						pi->phy_pacalstatus |=
						PHY_PACALSTATUS_POWER_CONTROL_DIVERGED;
					}
					tx_idx = tx_idx_pwr;
				}
				/* 1st priority: force cal index through iovar */
				if (pi->u.pi_acphy->pacalidx_iovar != -1) {
					tx_idx = pi->u.pi_acphy->pacalidx_iovar;
				}

				pi->u.pi_acphy->papd_lut0_cal_idx = tx_idx;
				wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);
				wlc_phy_tiny_papd_cal_run_acphy(pi, tx_pwr_ctrl_state);
			} else {
				wlc_phy_txpwr_papd_cal_run_acphy(pi, tx_pwr_ctrl_state);
			}
		}
		pi->first_cal_after_assoc = FALSE;

#if !defined(PHYCAL_CACHING) && !defined(WLMCHAN)
		pi->u.pi_acphy->txcal_cache_cookie = 0;
		/* cache cals for restore on return to home channel */
		wlc_phy_scanroam_cache_cal_acphy(pi, 1);
#endif /* !defined(PHYCAL_CACHING) && !defined(WLMCHAN) */
#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
		if (ctx)
			wlc_phy_cal_cache_acphy((wlc_phy_t *)pi);
#endif // endif

	} else {
		/*
		 * MULTI-PHASE CAL
		 *
		 *   Carry out next step in multi-phase execution of cal tasks
		 *
		 */

		switch (phase_id) {
#ifdef PHY_XTAL_SPUR_CAL
		case ACPHY_CAL_PHASE_XTAL_SPUR:

			/* Xtal spur cal
			 * First cal as you do not want to cal with large spurs
			 */

			/* move on after the cal */
			pi->cal_info->cal_phase_id++;

			/* Xtal spur cal, force:FALSE, cts2self:TRUE */
			if (wlc_acphy_cal_xtal_spur(pi, FALSE, TRUE)) {
				/* Something done, cts to self called so exit this phase */
				break;
			} else {
				/* Nothing done, skip this phase */
				PHY_CAL(("%s : xtal spur cal skipped\n", __FUNCTION__));
			}

			/* intentional fall through */
#endif /* PHY_XTAL_SPUR_CAL */
		case ACPHY_CAL_PHASE_TX_INIT:

			/*
			 *   Housekeeping & Pre-Txcal Tx Gain Adjustment
			 */

#ifdef WFD_PHY_LL
			/* Single-core on 20MHz channel */
			wlc_phy_susp2tx_cts2self(pi, 2500);
#else
			wlc_phy_susp2tx_cts2self(pi, 4000);
#endif // endif

			/* remember time and channel of this cal event */
			pi->cal_info->last_cal_time     = pi->sh->now;
			accal->chanspec = pi->radio_chanspec;

			wlc_phy_precal_txgain_acphy(pi, accal->txcal_txgain);

			/* move on */
			pi->cal_info->cal_phase_id++;
			break;

		case ACPHY_CAL_PHASE_TX0:
		case ACPHY_CAL_PHASE_TX1:
		case ACPHY_CAL_PHASE_TX2:
		case ACPHY_CAL_PHASE_TX3:
		case ACPHY_CAL_PHASE_TX4:
		case ACPHY_CAL_PHASE_TX5:
		case ACPHY_CAL_PHASE_TX6:
		case ACPHY_CAL_PHASE_TX7:
		case ACPHY_CAL_PHASE_TX8:
		case ACPHY_CAL_PHASE_TX9:
		case ACPHY_CAL_PHASE_TX_LAST:

			/*
			 *   Tx-IQLO-Cal
			 */
		  /* Relevant changes must be ported to ACPHY_CAL_PHASE_TXPRERXCALx as well */
			if (!ACREV_IS(pi->pubpi.phy_rev, 1) && (phase_id > ACPHY_CAL_PHASE_TX8)) {
				wlc_phy_susp2tx_cts2self(pi, 0);
				pi->cal_info->cal_phase_id++;
				break;
			}

#ifdef WFD_PHY_LL
			/* Single-core on 20MHz channel */
			wlc_phy_susp2tx_cts2self(pi, 3000);
#else
			wlc_phy_susp2tx_cts2self(pi, 4400);
#endif // endif

			/* to ensure radar detect is skipped during cals */
			if ((pi->radar_percal_mask & 0x10) != 0) {
				pi->u.pi_acphy->radar_cal_active = TRUE;
			}

			if (wlc_phy_cal_txiqlo_acphy(pi, searchmode, TRUE, 0) != BCME_OK) {
				/* rare case, just reset */
				PHY_ERROR(("wlc_phy_cal_txiqlo_acphy failed\n"));
				wlc_phy_cal_perical_mphase_reset(pi);
				break;
			}

			/* move on */
			pi->cal_info->cal_phase_id++;
			break;

		case ACPHY_CAL_PHASE_PAPDCAL:
			/*
			 *   PAPD Cal -- not supported yet. XXX FIXME
			 */
			if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
				PHY_PAPDEN(pi)) {
				if ((pi->radar_percal_mask & 0x20) != 0) {
					pi->u.pi_acphy->radar_cal_active = TRUE;
				}
			}

#ifdef WFD_PHY_LL
			if (pi->wfd_ll_enable) {
				/* skip the PAPD calibration */
				wlc_phy_susp2tx_cts2self(pi, 0);
				pi->cal_info->cal_phase_id++;
				break;
			}
#endif // endif
			if (PHY_PAPDEN(pi) && (!wlc_phy_eu_edcrs_detect_acphy(pi))) {
			/* disable PAPD cal if edcrs is high */
				wlc_phy_susp2tx_cts2self(pi, papd_cal_time);
				if (TINY_RADIO(pi)) {
					if (CHSPEC_IS2G(pi->radio_chanspec)) {
						tx_idx = 26;
					} else {
						tx_idx = 22;
					}
					if (PHY_EPAPD(pi)) {
						if (CHSPEC_IS2G(pi->radio_chanspec)) {
							tx_idx = 48;
						} else {
							if (band <=
							WL_CHAN_FREQ_RANGE_5G_BAND1) {
								tx_idx = 20;
							} else {
								tx_idx = 28;
							}
						}
				}
				wlc_phy_txpwr_by_index_acphy(pi, 1, tx_idx);
				wlc_phy_tiny_papd_cal_run_acphy(pi,
						tx_pwr_ctrl_state);
				} else {
					wlc_phy_txpwr_papd_cal_run_acphy(pi,
							tx_pwr_ctrl_state);
				}
			} else {
			  /* To make phyreg_enter & mac_suspend in sync for PAPD_EN =0 */
			       wlc_phy_susp2tx_cts2self(pi, 0);
			}
			/* move on */
			pi->cal_info->cal_phase_id++;
			break;

		case ACPHY_CAL_PHASE_TXPRERXCAL0:
		case ACPHY_CAL_PHASE_TXPRERXCAL1:
		case ACPHY_CAL_PHASE_TXPRERXCAL2:

#ifdef WFD_PHY_LL
			/* Single-core on 20MHz channel */
			wlc_phy_susp2tx_cts2self(pi, 3000);
#else
			wlc_phy_susp2tx_cts2self(pi, 4400);
#endif // endif

			/* to ensure radar detect is skipped during cals */
			if ((pi->radar_percal_mask & 0x10) != 0) {
				pi->u.pi_acphy->radar_cal_active = TRUE;
			}
			if (wlc_phy_cal_txiqlo_acphy(pi, searchmode, TRUE, 1) != BCME_OK) {
				/* rare case, just reset */
				PHY_ERROR(("wlc_phy_cal_txiqlo_acphy failed\n"));
				wlc_phy_cal_perical_mphase_reset(pi);
				break;
			}

			/* move on */
			pi->cal_info->cal_phase_id++;
			break;
		case ACPHY_CAL_PHASE_RXCAL:
			/*
			 *   Rx IQ Cal
			 */

#ifdef WFD_PHY_LL
			/* Single-core on 20MHz channel */
			wlc_phy_susp2tx_cts2self(pi, 3000);
#else
			wlc_phy_susp2tx_cts2self(pi, 9500);
#endif // endif

			if ((pi->radar_percal_mask & 0x1) != 0) {
				pi->u.pi_acphy->radar_cal_active = TRUE;
			}

			wlc_phy_cal_rx_fdiqi_acphy(pi);

#if !defined(PHYCAL_CACHING) && !defined(WLMCHAN)
			pi->u.pi_acphy->txcal_cache_cookie = 0;
			/* cache cals for restore on return to home channel */
			wlc_phy_scanroam_cache_cal_acphy(pi, 1);
#endif /* !defined(PHYCAL_CACHING) && !defined(WLMCHAN) */

			/* move on */
			pi->cal_info->cal_phase_id++;
			break;

		case ACPHY_CAL_PHASE_RSSICAL:

			/*
			 *     RSSI Cal & VCO Cal
			 */

#ifdef WFD_PHY_LL
			/* Single-core on 20MHz channel */
			wlc_phy_susp2tx_cts2self(pi, 600);
#else
			wlc_phy_susp2tx_cts2self(pi, 300);
#endif // endif

			if ((pi->radar_percal_mask & 0x4) != 0) {
			    pi->u.pi_acphy->radar_cal_active = TRUE;
			}

			/* RSSI & VCO cal (prevents VCO/PLL from losing lock with temp delta) */

			if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
				/* turn on VCO Calibration clock */
				MOD_RADIO_REG_20691(pi, PLL_XTAL2, 0, xtal_pu_caldrv, 0x1);

				wlc_phy_radio20691_vcocal(pi);
			} else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
				wlc_phy_radio20693_vcocal(pi);
			else
				wlc_phy_radio2069_vcocal(pi);

			wlc_phy_radio2069x_vcocal_isdone(pi, TRUE);

			/* turn off VCO Calibration clock */
			if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
				MOD_RADIO_REG_20691(pi, PLL_XTAL2, 0, xtal_pu_caldrv, 0x0);

			pi->cal_info->last_cal_time = pi->sh->now;
			accal->chanspec = pi->radio_chanspec;

			/* If this is the first calibration after association then we
			 * still have to do calibrate the idle-tssi, otherrwise done
			 */
			if (pi->first_cal_after_assoc) {
				pi->cal_info->cal_phase_id++;
			} else {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
				                          IQTBL_CACHE_COOKIE_OFFSET, 16,
				                          &tbl_cookie);

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
				if (ctx)
					wlc_phy_cal_cache_acphy((wlc_phy_t *)pi);
#endif // endif

				wlc_phy_cal_perical_mphase_reset(pi);
			}
			break;

		case ACPHY_CAL_PHASE_IDLETSSI:

			/*
			 *     Idle TSSI & TSSI-to-dBm Mapping Setup
			 */

			/* XXX FIXME:
			 * shouldn't idle-tssi cal before the other cals? for precal power control
			 * (if using actual gain iterations rather than fixed selection, we need
			 * to know the idle tssi)
			 */

			wlc_phy_susp2tx_cts2self(pi, 1550);
			if ((pi->radar_percal_mask & 0x8) != 0)
				pi->u.pi_acphy->radar_cal_active = TRUE;

			/* Idle TSSI determination once right after join/up/assoc */
			wlc_phy_txpwrctrl_idle_tssi_meas_acphy(pi);
			/* done with multi-phase cal, reset phase */
			pi->first_cal_after_assoc = FALSE;

			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
			  IQTBL_CACHE_COOKIE_OFFSET, 16, &tbl_cookie);

#if defined(PHYCAL_CACHING) || defined(WLMCHAN) || defined(WL_MODESW)
			if (ctx)
				wlc_phy_cal_cache_acphy((wlc_phy_t *)pi);
#endif // endif

			wlc_phy_cal_perical_mphase_reset(pi);
			break;

		default:
			PHY_ERROR(("%s: Invalid calibration phase %d\n", __FUNCTION__, phase_id));
			ASSERT(0);
			wlc_phy_cal_perical_mphase_reset(pi);
			break;
		}
	}

	/* Redo DCOC for 4345A0 */
	if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_1(pi->pubpi.phy_rev) &&
	    CHSPEC_IS2G(pi->radio_chanspec)) {
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
		wlc_20691_coarse_dcoc(pi);
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		wlc_phy_resetcca_acphy(pi);
	}

	/* ----------
	 *  Cleanups
	 * ----------
	 */
	if ((PHY_IPA(pi)) && (tx_pwr_ctrl_state == PHY_TPC_HW_ON) && (!TINY_RADIO(pi))) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_PHYREGCEE(pi, EpsilonTableAdjust, core, epsilonOffset, 0);
		}
	}
	wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);

	if (TINY_RADIO(pi)) {
	/* switch to normal rx2tx seq and dly after tiny cal */
	  wlc_phy_tiny_rfseq_mode_set(pi, 0);
	  if (CHSPEC_IS20(pi->radio_chanspec)) {
	    pi->u.pi_acphy->dac_mode = CHSPEC_IS2G(pi->radio_chanspec)
	      ? pi->dacratemode2g[0] : pi->dacratemode5g[0];
	  } else if (CHSPEC_IS40(pi->radio_chanspec)) {
	    pi->u.pi_acphy->dac_mode = CHSPEC_IS2G(pi->radio_chanspec)
	      ? pi->dacratemode2g[1] : pi->dacratemode5g[1];
	    if (CHSPEC_IS5G(pi->radio_chanspec) && (pi->u.pi_acphy->logenmode43 == 1))
	      pi->u.pi_acphy->dac_mode = 1;
	  } else {
	    pi->u.pi_acphy->dac_mode = 1;
	  }
	  wlc_phy_dac_rate_mode_acphy(pi, pi->u.pi_acphy->dac_mode);

	  if (ACMAJORREV_3(pi->pubpi.phy_rev) && (!ACMINORREV_1(pi->pubpi.phy_rev))) {
		wlc_idac_preload_20691(pi, idac_i, idac_q);

		if (ACREV_GE(pi->pubpi.phy_rev, 13))
			wlc_enable_lna_dcc_comp_20691(pi, PHY_ILNA(pi));
	  }
	}

	/* Restore original rxchains */
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}
	if (ACPHY_ENABLE_FCBS_HWACI(pi)) {
		/* Re-enable HWACI FCBS operation */
		MOD_PHYREG(pi, aci_detector_reset, aci_detector_hold, 0);
		MOD_PHYREG(pi, aci_detector_reset, aci_detector_reset_mask, 1);
	}

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

#ifdef WFD_PHY_LL_DEBUG
	printf("phase_id:%2d usec:%d\n", cal_phase_id, hndrte_time_us() - start_time);
#endif // endif
}

static void
wlc_phy_pulse_adc_reset_acphy(phy_info_t *pi)
{
	uint8 core;

	struct _reg_vals {
		uint16 regval;
		uint16 regaddr;
	} cur_reg_val[PHY_CORE_MAX*3]; /* save 3 register values for each core */

	uint core_count = 0;

	/* Set clamp using rfctrl override */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		cur_reg_val[core_count].regval = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
		cur_reg_val[core_count].regaddr = ACPHYREGCE(pi, RfctrlCoreAfeCfg1, core);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, cur_reg_val[core_count].regval |
			ACPHY_RfctrlCoreAfeCfg10_afe_iqadc_reset_MASK(pi->pubpi.phy_rev));
		++core_count;

		cur_reg_val[core_count].regval = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
		cur_reg_val[core_count].regaddr = ACPHYREGCE(pi, RfctrlCoreAfeCfg2, core);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, cur_reg_val[core_count].regval |
		        ACPHY_RfctrlCoreAfeCfg20_afe_iqadc_clamp_en_MASK(pi->pubpi.phy_rev));
		++core_count;

		cur_reg_val[core_count].regval = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
		cur_reg_val[core_count].regaddr = ACPHYREGCE(pi, RfctrlOverrideAfeCfg, core);
		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, cur_reg_val[core_count].regval |
			ACPHY_RfctrlOverrideAfeCfg0_afe_iqadc_clamp_en_MASK(pi->pubpi.phy_rev) |
			ACPHY_RfctrlOverrideAfeCfg0_afe_iqadc_reset_MASK(pi->pubpi.phy_rev));
		++core_count;
	}

	/* Wait for 1 us */
	OSL_DELAY(1);

	/* Restore values */
	while (core_count > 0) {
		--core_count;
		phy_reg_write(pi, cur_reg_val[core_count].regaddr, cur_reg_val[core_count].regval);
	}
	/* Wait for 1 us */
	OSL_DELAY(1);
}

void
wlc_phy_txpower_sromlimit_get_acphy(phy_info_t *pi, chanspec_t chanspec,
                                        ppr_t *max_pwr, uint8 core)
{
	uint8 band = 0, band_srom = 0;
	uint8 tmp_max_pwr = 0;
	int8 deltaPwr = 0;
	uint8 chan = CHSPEC_CHANNEL(chanspec);

#ifdef SROM12
			srom12_pwrdet_t *pwrdet = pi->pwrdet12_ac;
#endif // endif
			srom11_pwrdet_t *pwrdet11 = pi->pwrdet_ac;

	ASSERT(core < PHY_CORE_MAX);

#ifndef SROM12
	ASSERT(pi->sh->subband5Gver == PHY_SUBBAND_4BAND);
#endif /* SROM12 */

#if defined(POWPERCHANNL2G) || defined(POWPERCHANNL5G) || defined(POWPERBAND5G)
	/* update the board - limits per channel if in 2G Band or 5G Edge channel. */
	wlc_phy_tx_target_pwr_per_channel_set_acphy(pi);
#endif /* POWPERCHANNL2G || POWPERCHANNL5G */

	/* to figure out which subband is in 5G */
	/* in the range of 0, 1, 2, 3, 4 */
#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		band = wlc_phy_get_chan_freq_range_srom12_acphy(pi, chan);
		if (CHSPEC_IS80(chanspec)) {
			band = band - 11;
		} else if (CHSPEC_IS40(chanspec)) {
			band = band - 6;
		}
	}
#endif // endif
	if (pi->sh->sromrev < 12) {
		band = wlc_phy_get_chan_freq_range_acphy(pi, chan);
	}

	PHY_TRACE(("+++++ wl%d: %s: Band:%d Chan: %d +++++\n",
	           pi->sh->unit, __FUNCTION__, band, chan));
#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		tmp_max_pwr = pwrdet->max_pwr[0][band];

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
			tmp_max_pwr = MIN(tmp_max_pwr, pwrdet->max_pwr[1][band]);
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
			tmp_max_pwr = MIN(tmp_max_pwr, pwrdet->max_pwr[2][band]);
	}
#endif // endif
	if (pi->sh->sromrev < 12) {
		tmp_max_pwr = pwrdet11->max_pwr[0][band];

		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
			tmp_max_pwr = MIN(tmp_max_pwr, pwrdet11->max_pwr[1][band]);
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
			tmp_max_pwr = MIN(tmp_max_pwr, pwrdet11->max_pwr[2][band]);
	}

	/*	--------  in 5g_ext case  -----------
	 *	if 5170 <= freq < 5250, then band = 1;
	 *	if 5250 <= freq < 5500, then band = 2;
	 *	if 5500 <= freq < 5745, then band = 3;
	 *	if 5745 <= freq,		then band = 4;

	 *	--------  in 5g case  ---------------
	 *	if 5170 <= freq < 5500, then band = 1;
	 *	if 5500 <= freq < 5745, then band = 2;
	 *	if 5745 <= freq,		then band = 3;
	 */
	/*  -------- 4 subband to 3 subband mapping --------
	 *	subband#0 -> low
	 *	subband#1 -> mid
	 *	subband#2 -> high
	 *	subband#3 -> high
	 */

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		wlc_phy_txpwr_apply_srom12(pi, band, chanspec, tmp_max_pwr, max_pwr);
		deltaPwr = pwrdet->max_pwr[core][band] - tmp_max_pwr;
	}
#endif /* SROM12 */
	if (pi->sh->sromrev < 12) {
		if (band <= WL_CHAN_FREQ_RANGE_5G_BAND2)
			band_srom = band;
		else
			band_srom = band - 1;
		wlc_phy_txpwr_apply_srom11(pi, band_srom, chanspec, tmp_max_pwr, max_pwr);
		deltaPwr = pwrdet11->max_pwr[core][band] - tmp_max_pwr;
	}

	if (deltaPwr > 0)
		ppr_plus_cmn_val(max_pwr, deltaPwr);

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
		ppr_apply_max(max_pwr, pwrdet->max_pwr[core][band]);
	}
#endif // endif
	if (pi->sh->sromrev < 12) {
		ppr_apply_max(max_pwr, pwrdet11->max_pwr[core][band]);
	}

}

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP) || \
	defined(WLTEST)
/* dump calibration regs/info */
void
wlc_phy_cal_dump_acphy(phy_info_t *pi, struct bcmstrbuf *b)
{
	uint8 core;
	int8  ac_reg, mf_reg, off1 = 0, off2 = 0;
	int16  a_reg, b_reg, a_int, b_int;
	int32 slope;
	uint16 ab_int[2], d_reg;

	if (!pi->sh->up) {
		return;
	}

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	bcm_bprintf(b, "Tx-IQ/LOFT-Cal:\n");
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ, ab_int,
			TB_OFDM_COEFFS_AB, core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ, &d_reg,
			TB_OFDM_COEFFS_D, core);
		if (TINY_RADIO(pi)) {
			bcm_bprintf(b, "   core-%d: a/b: (%4d,%4d), d: (%3d,%3d)\n",
				core, (int16) ab_int[0], (int16) ab_int[1],
				(int8)((d_reg & 0xFF00) >> 8), /* di */
				(int8)((d_reg & 0x00FF)));     /* dq */
		} else {
			uint16 eir, eqr, fir, fqr;

			eir = READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_I, core);
			eqr = READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_Q, core);
			fir = READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_I, core);
			fqr = READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_Q, core);
			bcm_bprintf(b, "   core-%d: a/b: (%4d,%4d), d: (%3d,%3d),"
				" e: (%3d,%3d), f: (%3d,%3d)\n",
				core, (int16) ab_int[0], (int16) ab_int[1],
				(int8)((d_reg & 0xFF00) >> 8), /* di */
				(int8)((d_reg & 0x00FF)),      /* dq */
				(int8)(-((eir & 0xF0) >> 4) + ((eir & 0xF))), /* ei */
				(int8)(-((eqr & 0xF0) >> 4) + ((eqr & 0xF))), /* eq */
				(int8)(-((fir & 0xF0) >> 4) + ((fir & 0xF))), /* fi */
				(int8)(-((fqr & 0xF0) >> 4) + ((fqr & 0xF))));  /* fq */
		}
	}
	bcm_bprintf(b, "Rx-IQ-Cal:\n");
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		a_reg = READ_PHYREGCE(pi, Core1RxIQCompA, core);
		b_reg = READ_PHYREGCE(pi, Core1RxIQCompB, core);
		a_int = (a_reg >= 512) ? a_reg - 1024 : a_reg; /* s0.9 format */
		b_int = (b_reg >= 512) ? b_reg - 1024 : b_reg;
		if (pi->u.pi_acphy->fdiqi.enabled) {
			slope = pi->u.pi_acphy->fdiqi.slope[core];
			bcm_bprintf(b, "   core-%d: a/b = (%4d,%4d), S = %2d (%1d)\n",
				core, a_int, b_int, slope,
				READ_PHYREGFLD(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable));
		} else {
			bcm_bprintf(b, "   core-%d: a/b = (%4d,%4d), S = OFF (%1d)\n",
				core, a_int, b_int,
				READ_PHYREGFLD(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable));
		}
	}

	ac_reg =  READ_PHYREGFLD(pi, crsminpoweru0, crsminpower0);
	mf_reg =  READ_PHYREGFLD(pi, crsmfminpoweru0, crsmfminpower0);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (core == 1) {
			off1 =    READ_PHYREGFLD(pi, crsminpoweroffset1, crsminpowerOffsetu);
		} else if (core == 2) {
			off2 =    READ_PHYREGFLD(pi, crsminpoweroffset2, crsminpowerOffsetu);
		}
	}

	bcm_bprintf(b, "crs_min_pwr cal:\n");
	if (pi->u.pi_acphy->crsmincal_run != 1) {
		bcm_bprintf(b, "  ACI desense is on:  crs_min_pwr cal DID NOT run\n");
	} else {
		bcm_bprintf(b, "   crsmin_cal ran %d times for channel %d:\n",
		            pi->u.pi_acphy->phy_debug_crscal_counter,
		            pi->u.pi_acphy->phy_debug_crscal_channel);
	}
	bcm_bprintf(b, "   Noise power used for setting crs_min thresholds : ");
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		bcm_bprintf(b, "Core-%d : %d, ", core, pi->u.pi_acphy->phy_noise_in_crs_min[core]);
	}

	bcm_bprintf(b, "\n");
	bcm_bprintf(b, "   AC-CRS = %d,", ac_reg);
	bcm_bprintf(b, "   MF-CRS = %d,", mf_reg);
	bcm_bprintf(b, "   Offset 1 = %d,", off1);
	bcm_bprintf(b, "   Offset 2 = %d\n", off2);
#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(BCMDBG_PHYDUMP) || \
	defined(WLTEST)
	if (PHY_PAPDEN(pi)) {
		/* Make dump available for both iPA and ePA */
		wlc_phy_papd_dump_eps_trace_acphy(pi, b);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
				bcm_bprintf(b, "papdcalidx%d %d\n", core, papd_gainctrl_pga[core]);
			} else if (ACMAJORREV_2(pi->pubpi.phy_rev) ||
			           ACMAJORREV_5(pi->pubpi.phy_rev)) {
				bcm_bprintf(b, "papdcalidx%d %d\n", core, papd_gainctrl_pga[core]);
			}
		}
	}
#endif  /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) */
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	return;
}
#endif	/*  defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) */

static uint16
wlc_poll_adc_clamp_status(phy_info_t *pi, uint8 core, uint8 do_reset)
{
	uint16 ovr_status;

	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
		ovr_status = READ_RADIO_REGFLD_20691(pi, ADC_CFG14, core, adc_overload_i) |
		             READ_RADIO_REGFLD_20691(pi, ADC_CFG14, core, adc_overload_q);
	} else {
		ovr_status = READ_RADIO_REGFLDC(pi, RF_2069_ADC_STATUS(core), ADC_STATUS,
		                                i_wrf_jtag_afe_iqadc_overload);
	}

	if (ovr_status && do_reset) {
		/* MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, 0, afe_iqadc_reset_ov_det, 1); */
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_reset_ov_det,  1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_reset_ov_det, 0);
	}

	return ovr_status;
}

static void
BCMATTACHFN(wlc_phy_nvram_rssioffset_read)(phy_info_t *pi)
{
	uint8 i, j;
	uint8 core;
	char phy_var_name[40];
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 subband_idx, bw_idx;
	const char *subband_key[4] = {"l", "ml", "mu", "h"};
	const char *bw_key[3] = {"20", "40", "80"};

	FOREACH_CORE(pi, core) {

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff2g);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_2g[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_2g[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff2g_sub);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
				pi_ac->srom.rxgain_tempadj_2g_sub[core][subband_idx] =
					(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name,
					CH_2G_GROUP_NEW * core + subband_idx);
			}
		} else {
			for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
				pi_ac->srom.rxgain_tempadj_2g_sub[core][subband_idx] = 0;
			}
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gl);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gl[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gl[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gml);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gml[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gml[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gmu);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi_ac->srom.rxgain_tempadj_5gmu[core] =
			(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gmu[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gh);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gh[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gh[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff2g_sub_elnaoff);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
				pi_ac->srom.rxgain_tempadj_2g_sub_elnaoff[core][subband_idx] =
					(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name,
					CH_2G_GROUP_NEW * core + subband_idx);
			}
		} else {
			for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
				pi_ac->srom.rxgain_tempadj_2g_sub_elnaoff[core][subband_idx] = 0;
			}
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gl_elnaoff);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gl_elnaoff[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gl_elnaoff[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gml_elnaoff);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gml_elnaoff[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gml_elnaoff[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gmu_elnaoff);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi_ac->srom.rxgain_tempadj_5gmu_elnaoff[core] =
			(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gmu_elnaoff[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name),
		               rstr_rxgaintempcoeff5gh_elnaoff);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			pi_ac->srom.rxgain_tempadj_5gh_elnaoff[core] =
				(int16)PHY_GETINTVAR_ARRAY(pi, phy_var_name, core);
		} else {
			pi_ac->srom.rxgain_tempadj_5gh_elnaoff[core] = 0;
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_rssicorrnorm_cD, core);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (i = 0; i < ACPHY_NUM_BW_2G; i++) {
				pi_ac->srom.rssioffset.rssi_corr_normal[core][i] =
				        (int8)PHY_GETINTVAR_ARRAY(pi, phy_var_name, i);
			}
		} else {
			for (i = 0; i < ACPHY_NUM_BW_2G; i++) {
				pi_ac->srom.rssioffset.rssi_corr_normal[core][i] = 0;
			}
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_rssicorrnorm5g_cD, core);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (i = 0; i < ACPHY_RSSIOFFSET_NVRAM_PARAMS; i++) {
				for (j = 0; j < ACPHY_NUM_BW; j++) {
					pi_ac->srom.rssioffset.rssi_corr_normal_5g[core][i][j]
					        = (int8)PHY_GETINTVAR_ARRAY(pi, phy_var_name,
					                                    (3*i+j));
				}
			}
		} else {
			for (i = 0; i < ACPHY_RSSIOFFSET_NVRAM_PARAMS; i++) {
				for (j = 0; j < ACPHY_NUM_BW; j++) {
					pi_ac->srom.rssioffset.rssi_corr_normal_5g[core][i][j]
					        = 0;
				}
			}
		}

		for (bw_idx = 0; bw_idx < ACPHY_NUM_BW_2G; bw_idx++) {
			(void)snprintf(phy_var_name, sizeof(phy_var_name),
			               rstr_rssi_corr_pchan2g_S_cD, bw_key[bw_idx], core);
			if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
				for (i = 0; i < ACPHY_NUM_CHAN_2G_20; i++) {
					pi_ac->srom.rssioffset.rssi_corr_pchan_2g_chan
					        [core][bw_idx][i] = (int8)
					        PHY_GETINTVAR_ARRAY(pi, phy_var_name,
					                           (2*i));
					pi_ac->srom.rssioffset.rssi_corr_pchan_2g_val
					        [core][bw_idx][i] = (int8)
					        PHY_GETINTVAR_ARRAY(pi, phy_var_name,
					                           (2*i+1));
				}
			} else {
				for (i = 0; i < ACPHY_NUM_CHAN_2G_20; i++) {
					pi_ac->srom.rssioffset.rssi_corr_pchan_2g_chan
					    [core][bw_idx][i] = 0;
					pi_ac->srom.rssioffset.rssi_corr_pchan_2g_val
					    [core][bw_idx][i] = 0;
				}
			}
		}

		for (bw_idx = 0; bw_idx < ACPHY_NUM_BW; bw_idx++) {
			(void)snprintf(phy_var_name, sizeof(phy_var_name),
			               rstr_rssi_corr_pchan5g_S_cD, bw_key[bw_idx], core);
			if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
				for (i = 0; i < ACPHY_NUM_CHAN_5G_20; i++) {
					pi_ac->srom.rssioffset.rssi_corr_pchan_5g_chan
					    [core][bw_idx][i] = (int8)
					    PHY_GETINTVAR_ARRAY(pi, phy_var_name, (2*i));
					pi_ac->srom.rssioffset.rssi_corr_pchan_5g_val
						[core][bw_idx][i] = (int8)
						PHY_GETINTVAR_ARRAY(pi, phy_var_name, (2*i+1));
				}
			} else {
				for (i = 0; i < ACPHY_NUM_CHAN_5G_20; i++) {
					pi_ac->srom.rssioffset.rssi_corr_pchan_5g_chan
					    [core][bw_idx][i] = 0;
					pi_ac->srom.rssioffset.rssi_corr_pchan_5g_val
					    [core][bw_idx][i] = 0;
				}
			}
		}

		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_rssi_delta_2g_cD, core);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
				for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS; i++) {
				pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g[core][i][j] =
				        (int8)PHY_GETINTVAR_ARRAY(pi, phy_var_name, (i+2*j));
				}
			}
		} else {
			for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
				for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS; i++) {
					pi_ac->srom.rssioffset.
					        rssi_corr_gain_delta_2g[core][i][j] = 0;
				}
			}
		}

		for (subband_idx = 0; subband_idx < CH_5G_4BAND; subband_idx++) {
			(void)snprintf(phy_var_name, sizeof(phy_var_name),
			               rstr_rssi_delta_5gS_cD, subband_key[subband_idx], core);

			if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
				for (j = 0; j < ACPHY_NUM_BW; j++) {
					for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS; i++) {
						pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g
						        [core][i][j][subband_idx] = (int8)
						        PHY_GETINTVAR_ARRAY(pi, phy_var_name,
						                            (i+2*j));
					}
				}
			} else {
				for (j = 0; j < ACPHY_NUM_BW; j++) {
					for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS; i++) {
						pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g
							[core][i][j][subband_idx] = 0;
					}
				}
			}
		}

		for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
			for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS; i++) {
				PHY_INFORM(("%d ", pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g
				            [core][i][j]));
			}
		}
		for (subband_idx = 0; subband_idx < CH_5G_4BAND; subband_idx++) {
			for (j = 0; j < ACPHY_NUM_BW; j++) {
				for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS; i++) {
				PHY_INFORM(("%d ", pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g
					            [core][i][j][subband_idx]));
				}
			}
			PHY_INFORM(("\n"));
		}
	}
}

static void
BCMATTACHFN(wlc_phy_nvram_rssioffset_read_sub)(phy_info_t *pi)
{
	uint8 i, j, k;
	uint8 core;
	char phy_var_name[40];
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 subband_idx;
	const char *subband_key[4] = {"l", "ml", "mu", "h"};
	const char *subband_key_2g[5] = {"b0", "b1", "b2", "b3", "b4"};

/* if gain_cal_temp is not set in nvram, set it to 255 by default
 * to disable temperature correction for rssi
 */
	pi->srom_gain_cal_temp = (int16)PHY_GETINTVAR_DEFAULT(pi, rstr_gain_cal_temp, 255);

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_rssi_cal_rev);
	pi->u.pi_acphy->rssi_cal_rev =
		(bool)PHY_GETINTVAR(pi, phy_var_name);

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_rxgaincal_rssical);
	pi->u.pi_acphy->rxgaincal_rssical =
		(bool)PHY_GETINTVAR(pi, phy_var_name);

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_rud_agc_enable);
	pi->u.pi_acphy->rud_agc_enable =
		(bool)PHY_GETINTVAR(pi, phy_var_name);

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_temp_comp_tr_loss);
	pi->u.pi_acphy->temp_comp_tr_loss =
		(bool)PHY_GETINTVAR(pi, phy_var_name);

	pi->u.pi_acphy->srom.trloss_comp_wrt_temp_applied = FALSE;
	pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp = FALSE;
	pi->u.pi_acphy->srom.last_trloss_adj_temp = 255;

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_trloss_adj_time_dur);
	if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi->u.pi_acphy->srom.trloss_adj_time_dur =
			(uint)PHY_GETINTVAR(pi, phy_var_name);
	} else {
		pi->u.pi_acphy->srom.trloss_adj_time_dur = 30;
	}

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_trloss_adj_temp_thresh);
	if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi->u.pi_acphy->srom.trloss_adj_temp_thresh =
			(uint)PHY_GETINTVAR(pi, phy_var_name);
	} else {
		pi->u.pi_acphy->srom.trloss_adj_temp_thresh = 20;
	}
	pi->u.pi_acphy->srom.last_cal_time = 0;

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_rssi_qdB_en);
	pi->u.pi_acphy->rssi_qdB_en =
		(bool)PHY_GETINTVAR(pi, phy_var_name);

	FOREACH_CORE(pi, core) {

		for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
			(void)snprintf(phy_var_name, sizeof(phy_var_name),
			               rstr_rssi_delta_2gS, subband_key_2g[subband_idx]);

			if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			  for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
			    for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS_EXT; i++) {
			      k = core * ACPHY_NUM_BW_2G * ACPHY_GAIN_DELTA_2G_PARAMS_EXT;
			      pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g_sub[core]
			      [i][j][subband_idx] =
			        (int8)PHY_GETINTVAR_ARRAY(pi, phy_var_name, (i+4*j+k));
			    }
			  }
			} else {
			  for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
			    for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS_EXT; i++) {
			      pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g_sub[core]
				  [i][j][subband_idx] = 0;
			    }
			  }
			}
		}
		for (subband_idx = 0; subband_idx < CH_5G_4BAND; subband_idx++) {
			(void)snprintf(phy_var_name, sizeof(phy_var_name),
			               rstr_rssi_delta_5gS, subband_key[subband_idx]);

			if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			  for (j = 0; j < ACPHY_NUM_BW; j++) {
			    for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS_EXT; i++) {
			      k = core * ACPHY_NUM_BW * ACPHY_GAIN_DELTA_5G_PARAMS_EXT;
			      pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g_sub
				[core][i][j][subband_idx] = (int8)
				PHY_GETINTVAR_ARRAY(pi, phy_var_name, (i+4*j+k));
			    }
			  }
			} else {
			  for (j = 0; j < ACPHY_NUM_BW; j++) {
			    for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS_EXT; i++) {
			      pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g_sub
				[core][i][j][subband_idx] = 0;
			    }
			  }
			}
		}
		for (subband_idx = 0; subband_idx < CH_2G_GROUP_NEW; subband_idx++) {
		  for (j = 0; j < ACPHY_NUM_BW_2G; j++) {
		    for (i = 0; i < ACPHY_GAIN_DELTA_2G_PARAMS_EXT; i++) {
		      PHY_INFORM(("%d ", pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g_sub
				  [core][i][j][subband_idx]));
		    }
		  }
		}
		for (subband_idx = 0; subband_idx < CH_5G_4BAND; subband_idx++) {
		  for (j = 0; j < ACPHY_NUM_BW; j++) {
		    for (i = 0; i < ACPHY_GAIN_DELTA_5G_PARAMS_EXT; i++) {
		      PHY_INFORM(("%d ", pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g_sub
				  [core][i][j][subband_idx]));
		    }
		  }
		  PHY_INFORM(("\n"));
		}
	}

	(void)snprintf(phy_var_name, sizeof(phy_var_name),
	               rstr_rssi_cal_freq_grp_2g);
	j = 0;
	for (i = 0; i < 7; i++) {
		k = (uint8)
		        PHY_GETINTVAR_ARRAY(pi, phy_var_name, i);
		pi->u.pi_acphy->srom.rssi_cal_freq_grp[j] = (k >> 4) & 0xf;
		j++;
		pi->u.pi_acphy->srom.rssi_cal_freq_grp[j] = k & 0xf;
		j++;
	}

}

static void
BCMATTACHFN(wlc_phy_nvram_avvmid_read)(phy_info_t *pi)
{
	uint8 i, j;
	uint8 core;
	char phy_var_name[20];
/*	phy_info_acphy_t *pi_ac = pi->u.pi_acphy; */
	FOREACH_CORE(pi, core) 	{
		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_AvVmid_cD, core);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		for (i = 0; i < ACPHY_NUM_BANDS; i++) {
		for (j = 0; j < ACPHY_AVVMID_NVRAM_PARAMS; j++) {
		avvmid_set_from_nvram[core][i][j] = (uint8) PHY_GETINTVAR_ARRAY(pi, phy_var_name,
			(ACPHY_AVVMID_NVRAM_PARAMS*i +j));
			  }
		    }
	      }
		}
}

static void BCMATTACHFN(wlc_phy_nvram_vlin_params_read)(phy_info_t *pi)
{

	char phy_var_name2[20], phy_var_name3[20];
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 core;
	FOREACH_CORE(pi, core) {
		if (pi_ac->srom.vlin_en_from_nvram) {
			(void)snprintf(phy_var_name2, sizeof(phy_var_name2),
				rstr_VlinPwr2g_cD, core);
			if ((PHY_GETVAR(pi, phy_var_name2)) != NULL) {
				pi_ac->vlinpwr2g_from_nvram =
					(uint8) PHY_GETINTVAR(pi, phy_var_name2);
				}
			(void)snprintf(phy_var_name2, sizeof(phy_var_name2),
				rstr_VlinPwr5g_cD, core);
			if ((PHY_GETVAR(pi, phy_var_name2)) != NULL) {
				pi_ac->vlinpwr5g_from_nvram =
					(uint8) PHY_GETINTVAR(pi, phy_var_name2);
				}
			(void)snprintf(phy_var_name3, sizeof(phy_var_name3),
				rstr_Vlinmask2g_cD, core);
			if ((PHY_GETVAR(pi, phy_var_name3)) != NULL) {
				pi_ac->vlinmask2g_from_nvram =
					(uint8) PHY_GETINTVAR(pi, phy_var_name3);
				}
			(void)snprintf(phy_var_name3, sizeof(phy_var_name3),
				rstr_Vlinmask5g_cD, core);
			if ((PHY_GETVAR(pi, phy_var_name3)) != NULL) {
				pi_ac->vlinmask5g_from_nvram =
					(uint8) PHY_GETINTVAR(pi, phy_var_name3);
				}
			}
		}
}

/**
 * Whenever the transmit power is less than a certain value, lower PA power consumption can be
 * achieved by selecting lower PA linearity. The VLIN signal towards the FEM is configured to
 * either be driven by the FEM control table or by a chip internal VLIN signal.
 */
static void wlc_phy_vlin_en_acphy(phy_info_t *pi)
{
	uint8 band2g_idx, core;
	uint8 stall_val;
	int16 idle_tssi[PHY_CORE_MAX];
	uint16 adj_tssi1[PHY_CORE_MAX];
	uint16 adj_tssi2[PHY_CORE_MAX], adj_tssi3[PHY_CORE_MAX];
	int16 tone_tssi1[PHY_CORE_MAX];
	int16 tone_tssi2[PHY_CORE_MAX], tone_tssi3[PHY_CORE_MAX];
	int16 a1[PHY_CORE_MAX];
	int16 b0[PHY_CORE_MAX];
	int16 b1[PHY_CORE_MAX];
	uint8 pwr1, pwr2, pwr3;
	uint8 txidx1 = 40, txidx2 = 90, txidx3;
	struct _orig_reg_vals {
		uint8 core;
		uint16 orig_OVR3;
		uint16 orig_auxpga_cfg1;
		uint16 orig_auxpga_vmid;
		uint16 orig_iqcal_cfg1;
		uint16 orig_tx5g_tssi;
		uint16 orig_pa2g_tssi;
		uint16 orig_RfctrlIntc;
		uint16 orig_RfctrlOverrideRxPus;
		uint16 orig_RfctrlCoreRxPu;
		uint16 orig_RfctrlOverrideAuxTssi;
		uint16 orig_RfctrlCoreAuxTssi1;
		} orig_reg_vals[PHY_CORE_MAX];
	uint core_count = 0;
	txgain_setting_t curr_gain1, curr_gain2, curr_gain3;
	bool init_adc_inside = FALSE;
	uint16 save_afePuCtrl, save_gpio;
	uint16 orig_use_txPwrCtrlCoefs;
	uint16 fval2g_orig, fval5g_orig, fval2g, fval5g;
	uint32 save_chipc = 0;
	uint16 save_gpioHiOutEn;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	txgain_setting_t curr_gain4;
	int16 tone_tssi4[PHY_CORE_MAX];
	uint16 adj_tssi4[PHY_CORE_MAX];
	int bbmultcomp;
	uint16 tempmuxTxVlinOnFemCtrl2;
	uint16 txidxval;
	uint16 txgaintemp1[3], txgaintemp1a[3];
	uint16 tempmuxTxVlinOnFemCtrl, globpusmask;
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	/* prevent crs trigger */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	band2g_idx = CHSPEC_IS2G(pi->radio_chanspec);
	if (band2g_idx)	{
		pwr3 = pi_ac->vlinpwr2g_from_nvram;
		}
	else {
		pwr3 = pi_ac->vlinpwr5g_from_nvram;
		}
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);
	/* Turn off epa/ipa and unused rxrf part to prevent energy go into air */
	orig_use_txPwrCtrlCoefs = READ_PHYREGFLD(pi, TxPwrCtrlCmd,
	use_txPwrCtrlCoefs);
	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		/* save phy/radio regs going to be touched */
		orig_reg_vals[core_count].orig_RfctrlIntc = READ_PHYREGCE(pi,
		RfctrlIntc, core);
		orig_reg_vals[core_count].orig_RfctrlOverrideRxPus =
			READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
		orig_reg_vals[core_count].orig_RfctrlCoreRxPu =
			READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
		orig_reg_vals[core_count].orig_RfctrlOverrideAuxTssi =
			READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
		orig_reg_vals[core_count].orig_RfctrlCoreAuxTssi1 =
			READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
		orig_reg_vals[core_count].orig_OVR3 = READ_RADIO_REGC(pi,
			RF, OVR3, core);
		orig_reg_vals[core_count].orig_auxpga_cfg1 =
			READ_RADIO_REGC(pi, RF, AUXPGA_CFG1, core);
		orig_reg_vals[core_count].orig_auxpga_vmid =
			READ_RADIO_REGC(pi, RF, AUXPGA_VMID, core);
		orig_reg_vals[core_count].orig_iqcal_cfg1 =
			READ_RADIO_REGC(pi, RF, IQCAL_CFG1, core);
		orig_reg_vals[core_count].orig_tx5g_tssi = READ_RADIO_REGC(pi,
			RF, TX5G_TSSI, core);
		orig_reg_vals[core_count].orig_pa2g_tssi = READ_RADIO_REGC(pi,
			RF, PA2G_TSSI, core);
		orig_reg_vals[core_count].core = core;
		/* set tssi_range = 0   (it suppose to bypass 10dB attenuation before pdet) */
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, tssi_range, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,	 core, tssi_range, 0);
		/* turn off lna and other unsed rxrf components */
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, 0x7CE0);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, 	core, 0x0);
		++core_count;
		}
	ACPHY_ENABLE_STALL(pi, stall_val);
	/* tssi loopback setup */
	wlc_phy_tssi_phy_setup_acphy(pi, 0);
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_tssi_radio_setup_acphy_20691(pi, pi->sh->hw_phyrxchain, 1);
	else
		wlc_phy_tssi_radio_setup_acphy(pi,	pi->sh->hw_phyrxchain, 0);
	if (!init_adc_inside) {
		wlc_phy_init_adc_read(pi, &save_afePuCtrl, &save_gpio,
			&save_chipc, &fval2g_orig, &fval5g_orig,
			&fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
		}
	wlc_phy_get_paparams_for_band_acphy(pi, a1, b0, b1);
	FOREACH_ACTV_CORE(pi, pi->sh->hw_phyrxchain, core) {
		if (!init_adc_inside)
			wlc_phy_gpiosel_acphy(pi, 16+core, 1);
		/* Measure the Idle TSSI */
		wlc_phy_poll_samps_WAR_acphy(pi, idle_tssi, TRUE, TRUE, NULL,
		FALSE, init_adc_inside, core, 1);
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefs, 0);
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain1, txidx1);
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi1, TRUE, FALSE,
			&curr_gain1, FALSE, init_adc_inside, core, 1);
		adj_tssi1[core] = 1024+idle_tssi[core]-tone_tssi1[core];
		adj_tssi1[core] = adj_tssi1[core] >> 3;
		pwr1 = wlc_phy_tssi2dbm_acphy(pi, adj_tssi1[core], a1[core], b0[core], b1[core]);
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain2, txidx2);
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi2, TRUE, FALSE,
			&curr_gain2, FALSE, init_adc_inside, core, 1);
		adj_tssi2[core] = 1024+idle_tssi[core]-tone_tssi2[core];
		adj_tssi2[core] = adj_tssi2[core] >> 3;
		pwr2 = wlc_phy_tssi2dbm_acphy(pi, adj_tssi2[core], a1[core], b0[core], b1[core]);
		txidx3 = txidx1+(4*pwr3-pwr1) *(txidx2-txidx1)/(pwr2-pwr1);
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain3, txidx3);
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi3, TRUE, FALSE,
			&curr_gain3, FALSE, init_adc_inside, core, 1);
		adj_tssi3[core] = 1024+idle_tssi[core]-tone_tssi3[core];
		adj_tssi3[core] = adj_tssi3[core] >> 3;
		if (band2g_idx)	{
			globpusmask = 1<<(pi_ac->vlinmask2g_from_nvram);
			}
		else {
			globpusmask = 1<<(pi_ac->vlinmask5g_from_nvram);
			}
		tempmuxTxVlinOnFemCtrl = READ_PHYREGFLD(pi, RfctrlCoreGlobalPus,
			muxTxVlinOnFemCtrl);
		tempmuxTxVlinOnFemCtrl2 = (tempmuxTxVlinOnFemCtrl | globpusmask);
		MOD_PHYREG(pi, RfctrlCoreGlobalPus, muxTxVlinOnFemCtrl, tempmuxTxVlinOnFemCtrl2);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS,
			1, txidx3, 48, &txgaintemp1);
		txgaintemp1a[0] = (txgaintemp1[0]|0x8000);
		txgaintemp1a[1] = txgaintemp1[1];
		txgaintemp1a[2] = txgaintemp1[2];
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1,
			txidx3, 48, txgaintemp1a);
		wlc_phy_get_txgain_settings_by_index_acphy(pi, &curr_gain4, txidx3);
		wlc_phy_poll_samps_WAR_acphy(pi, tone_tssi4, TRUE, FALSE,
			&curr_gain4, FALSE, init_adc_inside, core, 1);
		adj_tssi4[core] = 1024+idle_tssi[core]-tone_tssi4[core];
		adj_tssi4[core] = adj_tssi4[core] >> 3;
		bbmultcomp = (int)((tone_tssi3[core]-tone_tssi4[core])/6);
		pi_ac->vlin_txidx = txidx3;
		pi_ac->bbmult_comp = bbmultcomp;
		for (txidxval = txidx3; txidxval < 128; txidxval++) {
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1,
				txidxval, 48, &txgaintemp1);
			txgaintemp1a[0] = (txgaintemp1[0]|0x8000)+bbmultcomp;
			txgaintemp1a[1] = txgaintemp1[1];
			txgaintemp1a[2] = txgaintemp1[2];
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINCTRLBBMULTLUTS, 1,
				txidxval, 48, txgaintemp1a);
			}
		if (!init_adc_inside)
			wlc_phy_restore_after_adc_read(pi, &save_afePuCtrl, &save_gpio,
			&save_chipc, &fval2g_orig, &fval5g_orig,
			&fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
		/* restore phy/radio regs */
		while (core_count > 0) {
			--core_count;
			write_radio_reg(pi, RF_2069_OVR3(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_OVR3);
			write_radio_reg(pi,
				RF_2069_AUXPGA_CFG1(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_auxpga_cfg1);
			write_radio_reg(pi,
				RF_2069_AUXPGA_VMID(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_auxpga_vmid);
			write_radio_reg(pi,
				RF_2069_IQCAL_CFG1(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_iqcal_cfg1);
			write_radio_reg(pi,
				RF_2069_TX5G_TSSI(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_tx5g_tssi);
			write_radio_reg(pi,
				RF_2069_PA2G_TSSI(orig_reg_vals[core_count].core),
				orig_reg_vals[core_count].orig_pa2g_tssi);
			WRITE_PHYREGCE(pi, RfctrlIntc, orig_reg_vals[core_count].core,
				orig_reg_vals[core_count].orig_RfctrlIntc);
			WRITE_PHYREGCE(pi, RfctrlOverrideRxPus,
				orig_reg_vals[core_count].core,
				orig_reg_vals[core_count].orig_RfctrlOverrideRxPus);
			WRITE_PHYREGCE(pi, RfctrlCoreRxPus, orig_reg_vals[core_count].core,
				orig_reg_vals[core_count].orig_RfctrlCoreRxPu);
			WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi,
				orig_reg_vals[core_count].core,
				orig_reg_vals[core_count].orig_RfctrlOverrideAuxTssi);
			WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1,
				orig_reg_vals[core_count].core,
				orig_reg_vals[core_count].orig_RfctrlCoreAuxTssi1);
			}
		MOD_PHYREG(pi, TxPwrCtrlCmd, use_txPwrCtrlCoefs, orig_use_txPwrCtrlCoefs);
		/* prevent crs trigger */
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		PHY_TRACE(("======= IQLOCAL PreCalGainControl : END =======\n"));
		}
}

int BCMFASTPATH
wlc_phy_rssi_compute_acphy(phy_info_t *pi, wlc_d11rxhdr_t *wlc_rxh)
{
	d11rxhdr_t *rxh = &wlc_rxh->rxhdr;
	int16 rxpwr;
	int16 rxpwr_core[PHY_CORE_MAX];
	int8 int8_rxpwr_core[PHY_CORE_MAX];
	int16 is_status_hacked;
	int core;

	/* mode = 0: rxpwr = max(rxpwr0, rxpwr1)
	 * mode = 1: rxpwr = min(rxpwr0, rxpwr1)
	 * mode = 2: rxpwr = (rxpwr0+rxpwr1)/2
	 */

	bzero(int8_rxpwr_core, sizeof(int8)*PHY_CORE_MAX);
	int8_rxpwr_core[0] = (int8)ACPHY_RXPWR_ANT0(rxh);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		int8_rxpwr_core[1] = (int8)ACPHY_RXPWR_ANT1(rxh);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		int8_rxpwr_core[2] = (int8)ACPHY_RXPWR_ANT2(rxh);
	is_status_hacked = ACPHY_HACK_PWR_STATUS(rxh);

	FOREACH_CORE(pi, core) {
		rxpwr_core[core] = (int16)int8_rxpwr_core[core];
	}

	if ((ACMAJORREV_1(pi->pubpi.phy_rev)) && (is_status_hacked == 1)) {
		FOREACH_CORE(pi, core) {
			rxpwr_core[core] = WLC_RSSI_INVALID;
		}
		rxpwr_core[0] = wlc_phy_11b_rssi_WAR(pi, rxh);
	}

	/* Sign extend */
	FOREACH_CORE(pi, core) {
		if (rxpwr_core[core] > 127)
			rxpwr_core[core] -= 256;
	}

	rxpwr = wlc_phy_rssi_compute_compensation_acphy(pi, rxpwr_core, 0);
	/* only 3 antennas are valid for now */
	FOREACH_CORE(pi, core) {
		/* Cap Max/Min RSSI to -1/-128 */
		rxpwr_core[core] = MAX(-128, rxpwr_core[core]);
		rxpwr_core[core] = MIN(-1, rxpwr_core[core]);
		wlc_rxh->rxpwr[core] = (int8)rxpwr_core[core];
	}
	wlc_rxh->do_rssi_ma = 0;

	/* Apply same Min/Max Cap to single value RSSI reporting */
	rxpwr = MIN(MAX(-128, rxpwr), -1);
	return rxpwr;
}
int16
wlc_phy_rssi_compute_compensation_acphy(phy_info_t *pi, int16 *rxpwr_core, bool db_qdb)
{
	int core;
	int16 rxpwr, rxpwr_qdBm = 0;
	int8  bw_idx, subband_idx, temp[PHY_CORE_MAX];
	uint8 i;
	bool chan_found;
	int16 rxpwr_core_qdBm[PHY_CORE_MAX];

	int16 gain_err_temp_adj_for_rssi;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		bw_idx = (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
	} else {
		bw_idx = (CHSPEC_IS80(pi->radio_chanspec)) ? 2 :
		  (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
	}

	FOREACH_CORE(pi, core) {
		chan_found = FALSE;
		temp[core] = 0;
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			for (i = 0; i < ACPHY_NUM_CHAN_2G_20; i++) {
			  if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi_ac->srom
				  .rssioffset.rssi_corr_pchan_2g_chan[core][bw_idx][i]) {
				  chan_found = TRUE;
				  break;
			  }
			}
			if (chan_found) {
				temp[core] =
				  pi_ac->srom.rssioffset.rssi_corr_pchan_2g_val
				  [core][bw_idx][i];
			}
		} else {
			for (i = 0; i < ACPHY_NUM_CHAN_5G_20; i++) {
			  if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi_ac->srom
				  .rssioffset.rssi_corr_pchan_5g_chan[core][bw_idx][i]) {
				  chan_found = TRUE;
				  break;
			  }
			}
			if (chan_found) {
				temp[core] =
				  pi_ac->srom.rssioffset.rssi_corr_pchan_5g_val
				  [core][bw_idx][i];
			}
		}
	}

	/*
	 * 22nd Oct
	 * if (rxgaincal_rssical == false)
	 * 	include the current implementation
	 *	This does temp comp and ...
	 *	Both rxgain error and rssi_gain_delta offsets are applied.
	 *		Hopefully, one of the 2 offsets are 0's and it would be ok.
	 * else (rxgaincal_rssical == true)
	 * 	have only rssi_gain_cal
	 * 	in true condition
	 * 	if rssi_cal_rev == 0
	 *		use gain_cal_temp
	 *		Use 1 dB steps - rssi_corr_gain_delta_2g[core][0][bw_idx]
	 * 	else
	 * 		use raw_tempsense (as it is currently
	 *              being populated for rssigain delta calibration)
	 *		Use 0.25 dB steps - rssi_corr_gain_delta_2g_sub[core][0][bw_idx][band_idx];
	 * 	fi
	 * fi
	 * Eventually, rssi_cal_rev == 0 condition has to be deprecated.
	 */
	if (pi_ac->rxgaincal_rssical == FALSE) {

		wlc_phy_upd_gain_wrt_temp_phy(pi, &gain_err_temp_adj_for_rssi);

			/* Apply gain-error correction with temperature compensation: */
			FOREACH_CORE(pi, core) {
				if (rxpwr_core[core] != WLC_RSSI_INVALID) {
					int16 tmp;
				if (gain_err_temp_adj_for_rssi != 0) {
					tmp = -1 * gain_err_temp_adj_for_rssi;
					} else {
					tmp = pi->phy_rssi_gain_error[core] * 2;
					}
					tmp = ((tmp >= 0) ? ((tmp + 2) >> 2) : -1 *
						((-1 * tmp + 2) >> 2));
					rxpwr_core[core] -= tmp;
				}
			}

		/* Apply nvram based offset: */
		FOREACH_CORE(pi, core) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				rxpwr_core[core] +=
				  pi_ac->srom.rssioffset.rssi_corr_normal[core][bw_idx];
				rxpwr_core[core] +=
				  pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g[core][0][bw_idx];
			} else {
				subband_idx = wlc_phy_get_chan_freq_range_acphy(pi,
				  CHSPEC_CHANNEL(pi->radio_chanspec))-1;
				rxpwr_core[core] +=
				  pi_ac->srom.rssioffset.rssi_corr_normal_5g[core][subband_idx]
				  [bw_idx];
				rxpwr_core[core] +=
				  pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g
				  [core][0][bw_idx][subband_idx];
			}
			rxpwr_core[core] += temp[core];
			rxpwr_core_qdBm[core] = 0; /* Initializing */
		}
	} else {

		/* Apply nvram based offset: */
		FOREACH_CORE(pi, core) {
			int16 tmp;
			int16 pwr_offset = 0;

			if (pi_ac->rssi_cal_rev == FALSE) {
				/* This offset is in 0.25 dB steps */
				wlc_phy_upd_gain_wrt_temp_phy(pi, &gain_err_temp_adj_for_rssi);
				subband_idx =  wlc_phy_get_chan_freq_range_acphy(pi,
				  CHSPEC_CHANNEL(pi->radio_chanspec)) - 1;
			} else {
				/* This offset is in 0.25 dB steps */
				wlc_phy_upd_gain_wrt_gain_cal_temp_phy(pi,
				  &gain_err_temp_adj_for_rssi, core);
				subband_idx = wlc_phy_rssi_get_chan_freq_range_acphy(pi,
				  CHSPEC_CHANNEL(pi->radio_chanspec));
			}

			if (CHSPEC_IS2G(pi->radio_chanspec)) {
			  int8 rssi_corr_gain_delta_2g;
			  if (pi->u.pi_acphy->rssi_cal_rev == FALSE) {
			    /* This offset is in 1 dB steps. Convert to 0.25 dB steps */
			    rssi_corr_gain_delta_2g = pi_ac->srom.rssioffset
			      .rssi_corr_gain_delta_2g[core][0][bw_idx];
			    rssi_corr_gain_delta_2g = rssi_corr_gain_delta_2g  << 2;
			  } else {
			    /* This offset is in 0.25 dB steps. */
			    rssi_corr_gain_delta_2g = pi_ac->srom.rssioffset
			      .rssi_corr_gain_delta_2g_sub[core][0][bw_idx][subband_idx];
			  }
			  pwr_offset +=
			    pi_ac->srom.rssioffset.rssi_corr_normal[core][bw_idx];
			  pwr_offset += rssi_corr_gain_delta_2g + gain_err_temp_adj_for_rssi;
			} else {
			  int8 rssi_corr_gain_delta_5g;
			  if (pi->u.pi_acphy->rssi_cal_rev == FALSE) {
			    /* This offset is in 1 dB steps. Convert to 0.25 dB steps */
			    rssi_corr_gain_delta_5g = pi_ac->srom.rssioffset
			      .rssi_corr_gain_delta_5g[core][0][bw_idx][subband_idx];
			    rssi_corr_gain_delta_5g = rssi_corr_gain_delta_5g  << 2;
			  } else {
			    /* This offset is in 0.25 dB steps. */
			    rssi_corr_gain_delta_5g = pi_ac->srom.rssioffset
			      .rssi_corr_gain_delta_5g_sub[core][0][bw_idx][subband_idx];
			  }
			  pwr_offset +=
			    pi_ac->srom.rssioffset.rssi_corr_normal_5g[core][subband_idx]
			    [bw_idx];
			  pwr_offset += rssi_corr_gain_delta_5g + gain_err_temp_adj_for_rssi;
			}
			pwr_offset += temp[core] << 2;
			/* By this point, both temp and rssi_corr_gain_delta's are
			* converted into 0.25 dB steps.
			 * So, convert irrespective of conditions to 1 dB steps.
			 */
			if (db_qdb == 0) {
				tmp = 4*rxpwr_core[core] + pwr_offset;
			} else {
				/* Here, rxpwr_core is in qdB, but in a few lines it
				* is converted to dB steps
				*/
				tmp = rxpwr_core[core] + pwr_offset;
			}
			rxpwr_core_qdBm[core] = tmp;
			tmp = ((tmp >= 0) ? ((tmp + 2) >> 2) : -1 *
			       ((-1 * tmp + 2) >> 2));
			rxpwr_core[core] = tmp;

		}
	}

	/* legacy interface */
	if (PHYCORENUM(pi->pubpi.phy_corenum) == 1) {
		rxpwr = rxpwr_core[0];
		rxpwr_qdBm = rxpwr_core_qdBm[0];
	} else {
		uint8 num_activecores = 0;

		rxpwr = 0;
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (num_activecores++ == 0) {
				rxpwr = rxpwr_core[core];
				rxpwr_qdBm = rxpwr_core_qdBm[core];
			} else {
				switch (pi->sh->rssi_mode) {
				case RSSI_ANT_MERGE_MAX:
					rxpwr = MAX(rxpwr, rxpwr_core[core]);
					rxpwr_qdBm = MAX(rxpwr_qdBm, rxpwr_core_qdBm[core]);
					break;
				case RSSI_ANT_MERGE_MIN:
					rxpwr = MIN(rxpwr, rxpwr_core[core]);
					rxpwr_qdBm = MIN(rxpwr_qdBm, rxpwr_core_qdBm[core]);
					break;
				case RSSI_ANT_MERGE_AVG:
					rxpwr += rxpwr_core[core];
					rxpwr_qdBm += rxpwr_core_qdBm[core];
					break;
				default:
					ASSERT(0);
				}
			}
		}

		if (pi->sh->rssi_mode == RSSI_ANT_MERGE_AVG) {
			int16 qrxpwr;

			ASSERT(num_activecores > 0);

			rxpwr = (int8)qm_div16(rxpwr, num_activecores, &qrxpwr);
			rxpwr_qdBm = rxpwr/num_activecores;
		}
	}
	pi->u.pi_acphy->last_rssi = rxpwr_qdBm;
	if (db_qdb == 0) {
	    return rxpwr;
	} else {
	    return rxpwr_qdBm;
	}

}

uint8
wlc_phy_11b_rssi_WAR(phy_info_t *pi, d11rxhdr_t *rxh)
{
	int16 PhyStatsGainInfo0, Auxphystats0;
	int8 lna1, lna2, mixer, biq0, biq1, trpos, dvga;
	int8 elna;
	int8 trloss;
	int8 elna_byp_tr;
	int8 lna1_gain, lna2_gain, rxmix_gain,
		biq0_gain, biq1_gain, dvga_gain, fem_gain, total_rx_gain;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	PhyStatsGainInfo0 = ((ACPHY_RXPWR_ANT2(rxh) << 8) | (ACPHY_RXPWR_ANT1(rxh)));
	Auxphystats0 = ((ACPHY_RXPWR_ANT0(rxh) << 8) | (ACPHY_RXPWR_ANT4(rxh)));

	/* Parsing the gaininfo */
	lna1 = (PhyStatsGainInfo0 >> 0) & 0x7;
	lna2 = (PhyStatsGainInfo0 >> 3) & 0x7;
	mixer = (PhyStatsGainInfo0 >> 6) & 0xf;
	biq0 = (PhyStatsGainInfo0 >> 10) & 0x7;
	biq1 = (PhyStatsGainInfo0 >> 13) & 0x7;

	trpos = (Auxphystats0 >> 0) & 0x1;
	dvga = (Auxphystats0 >> 2) & 0xf;

	elna = pi_ac->fem_rxgains[0].elna;
	trloss = pi_ac->fem_rxgains[0].trloss;
	elna_byp_tr = pi_ac->fem_rxgains[0].elna_bypass_tr;
	ASSERT(pi_ac->fem_rxgains[0].lna1byp == 0); /* Not supported */

	/* get gains of each block */
	dvga_gain  = 3*dvga;
	lna1_gain  = pi_ac->rxgainctrl_params[0].gaintbl[1][lna1];
	lna2_gain  = pi_ac->rxgainctrl_params[0].gaintbl[2][lna2];
	rxmix_gain = pi_ac->rxgainctrl_params[0].gaintbl[3][mixer];
	biq0_gain = pi_ac->rxgainctrl_params[0].gaintbl[4][biq0];
	biq1_gain = pi_ac->rxgainctrl_params[0].gaintbl[5][biq1];

	/* Get fem gain */
	if (elna_byp_tr == 1) {
		if (trpos == 0) {
			fem_gain = elna;
		} else {
			fem_gain = elna - trloss;
		}
	} else {
		if (trpos == 0) {
			fem_gain = 0;
		} else {
			fem_gain = (-1*trloss);
		}
	}

	/* Total Rx gain */
	total_rx_gain = (lna1_gain + lna2_gain + rxmix_gain
		 + biq0_gain + biq1_gain + dvga_gain + fem_gain);

	return (2 - total_rx_gain + 256);
}

static void
BCMATTACHFN(wlc_phy_srom_read_rxgainerr_acphy)(phy_info_t *pi)
{
	/* read and uncompress gain-error values for rx power reporting */

	int8 tmp[PHY_CORE_NUM_3];
	int16 tmp2;

	(void)memset(tmp, -1, sizeof(tmp));

	/* read in temperature at calibration time */
	tmp2 = (int16) (((int16)PHY_GETINTVAR(pi, rstr_rawtempsense))  << 7) >> 7;
	if (tmp2 == -1) {
		/* set to some bogus value, since nothing was written to SROM */
		pi->srom_rawtempsense = 255;
	} else {
		pi->srom_rawtempsense = tmp2;
	}
	pi->u.pi_acphy->current_temperature = pi->srom_rawtempsense;

	/* 2G: */
	/* read and sign-extend */
	tmp[0] = (int8)(((int8)PHY_GETINTVAR(pi, rstr_rxgainerr2ga0)) << 2) >> 2;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp[1] = (int8)(((int8)PHY_GETINTVAR(pi, rstr_rxgainerr2ga1)) << 3) >> 3;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp[2] = (int8)(((int8)PHY_GETINTVAR(pi, rstr_rxgainerr2ga2)) << 3) >> 3;

	if ((tmp[0] == -1) && (tmp[1] == -1) && (tmp[2] == -1) && (tmp2 == -1)) {
		/* If all srom values are -1, then possibly
		 * no gainerror info was written to srom
		 */
		tmp[0] = 0; tmp[1] = 0; tmp[2] = 0;
		pi->rxgainerr2g_isempty = TRUE;
	} else {
		pi->rxgainerr2g_isempty = FALSE;
	}
	/* gain errors for cores 1 and 2 are stored in srom as deltas relative to core 0: */
	pi->rxgainerr_2g[0] = tmp[0];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		pi->rxgainerr_2g[1] = tmp[0] + tmp[1];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		pi->rxgainerr_2g[2] = tmp[0] + tmp[2];

	/* 5G low: */
	/* read and sign-extend */
	tmp[0] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga0, 0)) << 2) >> 2;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp[1] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga1, 0)) << 3) >> 3;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp[2] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga2, 0)) << 3) >> 3;

	if ((tmp[0] == -1) && (tmp[1] == -1) && (tmp[2] == -1) && (tmp2 == -1)) {
		/* If all srom values are -1, then possibly
		 * no gainerror info was written to srom
		 */
		tmp[0] = 0; tmp[1] = 0; tmp[2] = 0;
		pi->rxgainerr5gl_isempty = TRUE;
	} else {
		pi->rxgainerr5gl_isempty = FALSE;
	}
	/* gain errors for cores 1 and 2 are stored in srom as deltas relative to core 0: */
	pi->rxgainerr_5gl[0] = tmp[0];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		pi->rxgainerr_5gl[1] = tmp[0] + tmp[1];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		pi->rxgainerr_5gl[2] = tmp[0] + tmp[2];

	/* 5G mid: */
	/* read and sign-extend */
	tmp[0] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga0, 1)) << 2) >> 2;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp[1] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga1, 1)) << 3) >> 3;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp[2] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga2, 1)) << 3) >> 3;

	if ((tmp[0] == -1) && (tmp[1] == -1) && (tmp[2] == -1) && (tmp2 == -1)) {
		/* If all srom values are -1, then possibly
		 * no gainerror info was written to srom
		 */
		tmp[0] = 0; tmp[1] = 0; tmp[2] = 0;
		pi->rxgainerr5gm_isempty = TRUE;
	} else {
		pi->rxgainerr5gm_isempty = FALSE;
	}
	/* gain errors for cores 1 and 2 are stored in srom as deltas relative to core 0: */
	pi->rxgainerr_5gm[0] = tmp[0];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		pi->rxgainerr_5gm[1] = tmp[0] + tmp[1];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		pi->rxgainerr_5gm[2] = tmp[0] + tmp[2];

	/* 5G high: */
	/* read and sign-extend */
	tmp[0] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga0, 2)) << 2) >> 2;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp[1] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga1, 2)) << 3) >> 3;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp[2] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga2, 2)) << 3) >> 3;

	if ((tmp[0] == -1) && (tmp[1] == -1) && (tmp[2] == -1) && (tmp2 == -1)) {
		/* If all srom values are -1, then possibly
		 * no gainerror info was written to srom
		 */
		tmp[0] = 0; tmp[1] = 0; tmp[2] = 0;
		pi->rxgainerr5gh_isempty = TRUE;
	} else {
		pi->rxgainerr5gh_isempty = FALSE;
	}
	/* gain errors for cores 1 and 2 are stored in srom as deltas relative to core 0: */
	pi->rxgainerr_5gh[0] = tmp[0];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		pi->rxgainerr_5gh[1] = tmp[0] + tmp[1];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		pi->rxgainerr_5gh[2] = tmp[0] + tmp[2];

	/* 5G upper: */
	/* read and sign-extend */
	tmp[0] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga0, 3)) << 2) >> 2;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		tmp[1] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga1, 3)) << 3) >> 3;
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		tmp[2] = (int8)(((int8)getintvararray(pi->vars, rstr_rxgainerr5ga2, 3)) << 3) >> 3;

	if ((tmp[0] == -1) && (tmp[1] == -1) && (tmp[2] == -1) && (tmp2 == -1)) {
		/* If all srom values are -1, then possibly
		 * no gainerror info was written to srom
		 */
		tmp[0] = 0; tmp[1] = 0; tmp[2] = 0;
		pi->rxgainerr5gu_isempty = TRUE;
	} else {
		pi->rxgainerr5gu_isempty = FALSE;
	}
	/* gain errors for cores 1 and 2 are stored in srom as deltas relative to core 0: */
	pi->rxgainerr_5gu[0] = tmp[0];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1)
		pi->rxgainerr_5gu[1] = tmp[0] + tmp[1];
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
		pi->rxgainerr_5gu[2] = tmp[0] + tmp[2];
}

#define ACPHY_SROM_NOISELVL_OFFSET (-70)

static void
BCMATTACHFN(wlc_phy_srom_read_noiselvl_acphy)(phy_info_t *pi)
{
	/* read noise levels from SROM */
	uint8 core;
	char phy_var_name[20];

	FOREACH_CORE(pi, core) {
		/* 2G: */
		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_noiselvl2gaD, core);
		pi->noiselvl_2g[core] = ACPHY_SROM_NOISELVL_OFFSET -
		                             ((uint8)PHY_GETINTVAR(pi, phy_var_name));

		/* 5G low: */
		(void)snprintf(phy_var_name, sizeof(phy_var_name), rstr_noiselvl5gaD, core);
		pi->noiselvl_5gl[core] = ACPHY_SROM_NOISELVL_OFFSET -
		                              ((uint8)getintvararray(pi->vars, phy_var_name, 0));

		/* 5G mid: */
		pi->noiselvl_5gm[core] = ACPHY_SROM_NOISELVL_OFFSET -
		                              ((uint8)getintvararray(pi->vars, phy_var_name, 1));

		/* 5G high: */
		pi->noiselvl_5gh[core] = ACPHY_SROM_NOISELVL_OFFSET -
		                              ((uint8)getintvararray(pi->vars, phy_var_name, 2));

		/* 5G upper: */
		pi->noiselvl_5gu[core] = ACPHY_SROM_NOISELVL_OFFSET -
		                              ((uint8)getintvararray(pi->vars, phy_var_name, 3));
	}
}

static bool
BCMATTACHFN(wlc_phy_srom_read_acphy)(phy_info_t *pi)
{
	/* Read rxgainctrl srom entries - elna gain, trloss */
	wlc_phy_srom_read_gainctrl_acphy(pi);

#ifdef SROM12
	if (pi->sh->sromrev == 12) {
	  if (!wlc_phy_txpwr_srom12_read(pi))
		return FALSE;
	}
#endif /* SROM12 */
	if (pi->sh->sromrev < 12) {
	  if (!wlc_phy_txpwr_srom11_read(pi))
		return FALSE;
	}

	wlc_phy_srom_read_rxgainerr_acphy(pi);

	wlc_phy_srom_read_noiselvl_acphy(pi);

	wlc_phy_nvram_femctrl_read(pi);

	wlc_phy_nvram_rssioffset_read(pi);

	wlc_phy_nvram_rssioffset_read_sub(pi);

	wlc_phy_nvram_vlin_params_read(pi);
	wlc_phy_nvram_avvmid_read(pi);

#ifdef WL_SAR_SIMPLE_CONTROL
	wlc_phy_nvram_dynamicsarctrl_read(pi);
#endif // endif

	return TRUE;
}

static void
wlc_phy_cal_coeffs_upd(phy_info_t *pi, txcal_coeffs_t *txcal_cache)
{
	uint8 core;
	uint16 ab_int[2];

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		ab_int[0] = txcal_cache[core].txa;
		ab_int[1] = txcal_cache[core].txb;
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			ab_int, TB_OFDM_COEFFS_AB, core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
			&txcal_cache[core].txd,	TB_OFDM_COEFFS_D, core);
		if (!TINY_RADIO(pi)) {
			write_radio_reg(pi, RF_2069_TXGM_LOFT_FINE_I(core), txcal_cache[core].txei);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_FINE_Q(core), txcal_cache[core].txeq);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_COARSE_I(core),
			                txcal_cache[core].txfi);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_COARSE_Q(core),
			                txcal_cache[core].txfq);
		}
		WRITE_PHYREGCE(pi, Core1RxIQCompA, core, txcal_cache[core].rxa);
		WRITE_PHYREGCE(pi, Core1RxIQCompB, core, txcal_cache[core].rxb);
	}
}

#if !defined(PHYCAL_CACHING) && !defined(WLMCHAN)
void
wlc_phy_scanroam_cache_cal_acphy(phy_info_t *pi, bool set)
{
	uint16 ab_int[2];
	uint8 core;

	/* Prepare Mac and Phregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	PHY_TRACE(("wl%d: %s: in scan/roam set %d\n", pi->sh->unit, __FUNCTION__, set));

	if (set) {
		PHY_CAL(("wl%d: %s: save the txcal for scan/roam\n",
			pi->sh->unit, __FUNCTION__));
		/* save the txcal to cache */
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
				ab_int, TB_OFDM_COEFFS_AB, core);
			pi->u.pi_acphy->txcal_cache[core].txa = ab_int[0];
			pi->u.pi_acphy->txcal_cache[core].txb = ab_int[1];
			wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
			&pi->u.pi_acphy->txcal_cache[core].txd,
				TB_OFDM_COEFFS_D, core);
			if (!TINY_RADIO(pi)) {
				pi->u.pi_acphy->txcal_cache[core].txei =
					(uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_I, core);
				pi->u.pi_acphy->txcal_cache[core].txeq =
					(uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_Q, core);
				pi->u.pi_acphy->txcal_cache[core].txfi =
					(uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_I, core);
				pi->u.pi_acphy->txcal_cache[core].txfq =
					(uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_Q, core);
			}

			pi->u.pi_acphy->txcal_cache[core].rxa =
				READ_PHYREGCE(pi, Core1RxIQCompA, core);
			pi->u.pi_acphy->txcal_cache[core].rxb =
				READ_PHYREGCE(pi, Core1RxIQCompB, core);
		}

		/* mark the cache as valid */
		pi->u.pi_acphy->txcal_cache_cookie = TXCAL_CACHE_VALID;
	} else {
		if (pi->u.pi_acphy->txcal_cache_cookie == TXCAL_CACHE_VALID) {
			PHY_CAL(("wl%d: %s: restore the txcal after scan/roam\n",
				pi->sh->unit, __FUNCTION__));
			/* restore the txcal from cache */
			wlc_phy_cal_coeffs_upd(pi, pi->u.pi_acphy->txcal_cache);
		}
	}

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);
}
#endif /* !defined(PHYCAL_CACHING) && !defined(WLMCHAN) */

/* report estimated power and adjusted estimated power in quarter dBms */
void
wlc_phy_txpwr_est_pwr_acphy(phy_info_t *pi, uint8 *Pout, uint8 *Pout_adj)
{
	uint8 core;
	int8 val = 0;

	/* Read the est. power registers only if radio is powered up */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		if (pi->radio_is_on)
			val = READ_PHYREGFLDCE(pi, EstPower_path, core, estPowerValid);

		/* Read the Actual Estimated Powers without adjustment */
		if (val) {
			Pout[core] = READ_PHYREGFLDCE(pi, EstPower_path, core, estPower);
		} else {
			Pout[core] = 0;
		}

		if (pi->radio_is_on)
			val = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, estPwrAdjValid);

		if (val) {
			Pout_adj[core] = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core,
			                                  estPwr_adj);
		} else {
			Pout_adj[core] = 0;
		}
	}
}

int16
wlc_phy_tempsense_acphy(phy_info_t *pi)
{
	uint8 core, core_cnt = 0;
	uint8 sel_Vb, swap_amp;
	int8 idx;
	uint16 auxPGA_Av = 0x3, auxPGA_Vmid = 0x91;
	int16 V[4][3] = {{0, 0}}, Vout[4] = {0, 0, 0, 0};
	int16 offset = (int16) pi->phy_tempsense_offset;
	int32 radio_temp = 0;
	int32 t_scale = 16384;
	int32 t_slope = 8766;
	int32 t_offset = 1902100;
	int32 avbq_scale = 256;
	int32 avbq_slope[3] = {527, 521, 522};
	uint16 save_afePuCtrl = 0, save_gpio = 0, save_gpioHiOutEn = 0;
	uint16 fval2g_orig, fval5g_orig, fval2g, fval5g;
	uint32 save_chipc = 0;
	uint8  stall_val = 0, log2_nsamps = 3;
	int32 k, tmp_samp, samp_accum;

	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID) {
		wlc_phy_tempsense_acphy_tiny(pi);
		return pi->u.pi_acphy->current_temperature;
	}

	/* Prepare Mac and Phregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		auxPGA_Av = 0x3;
		auxPGA_Vmid = 0x91;
	}

	wlc_phy_tempsense_phy_setup_acphy(pi);
	wlc_phy_tempsense_radio_setup_acphy(pi, auxPGA_Av, auxPGA_Vmid);
	wlc_phy_init_adc_read(pi, &save_afePuCtrl, &save_gpio,
	                          &save_chipc, &fval2g_orig, &fval5g_orig,
	                          &fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
	wlc_phy_pulse_adc_reset_acphy(pi);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	  wlc_phy_gpiosel_acphy(pi, 16+core, 1);
	  core_cnt++;
	  for (idx = 0; idx < 4; idx++) {
	    switch (idx) {
	    case 0:
	      sel_Vb = 1;
	      swap_amp = 0;
		      break;
	    case 1:
	      sel_Vb = 0;
	      swap_amp = 0;
	      break;
	    case 2:
	      sel_Vb = 1;
	      swap_amp = 1;
	      break;
	    case 3:
	      sel_Vb = 0;
	      swap_amp = 1;
	      break;
	    default:
	      sel_Vb = 0;
	      swap_amp = 0;
	      break;
	    }

	    /* Reg conflict with 2069 rev 16 */
	    if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
		MOD_RADIO_REGC(pi, OVR18, core, ovr_tempsense_sel_Vbe_Vbg, 0x1);
	    } else {
		MOD_RADIO_REGC(pi, GE16_OVR19, core, ovr_tempsense_sel_Vbe_Vbg, 0x1);
	    }
	    MOD_RADIO_REGC(pi, TEMPSENSE_CFG, core, tempsense_sel_Vbe_Vbg, sel_Vb);

	    /* Reg conflict with 2069 rev 16 */
	    if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0) {
		MOD_RADIO_REGC(pi, OVR18, core, ovr_tempsense_swap_amp, 0x1);
	    } else {
		MOD_RADIO_REGC(pi, GE16_OVR19, core, ovr_tempsense_swap_amp, 0x1);
	    }
	    MOD_RADIO_REGC(pi, TEMPSENSE_CFG, core, swap_amp, swap_amp);

	    OSL_DELAY(10);
	    samp_accum = 0;
	    for (k = 0; k < (1 << log2_nsamps); k++) {
	      /* read out the i-value */
	      tmp_samp = READ_PHYREG(pi, gpioHiOut) >> 2;
	      tmp_samp -= (tmp_samp < 512) ? 0 : 1024;
	      samp_accum += tmp_samp;
	    }
	    V[idx][core] = (int16) (samp_accum >> log2_nsamps);
	  }
	}

	if ((RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) ||
	    (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2)) {

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			t_slope = -5453;
			t_offset = 1748881;
		} else if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 2) {
			t_slope = -5549;
			t_offset = 1697118;
		}

		avbq_scale = 800;
		avbq_slope[0] = 1024;
		avbq_slope[1] = 1024;
		t_scale	= 16384;

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
	        radio_temp += (int32)(((V[0][core] + V[2][core] - V[1][core] - V[3][core]) / 2))
		                      * ((t_slope * avbq_scale) / (avbq_slope[core] * core_cnt));
			Vout[0] += V[0][core] / core_cnt;
			Vout[1] += V[1][core] / core_cnt;
			Vout[2] += V[2][core] / core_cnt;
			Vout[3] += V[3][core] / core_cnt;

		}
		radio_temp = (radio_temp + t_offset)/t_scale;

		/* Forcing offset to zero as this is not characterized yet for 4335 */
		offset = 0;

	} else {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			radio_temp += (int32)(V[1][core] + V[3][core] - V[0][core] - V[2][core])
			        * t_slope / 2 * avbq_scale / avbq_slope[core] / core_cnt;
			Vout[0] += V[0][core] / core_cnt;
			Vout[1] += V[1][core] / core_cnt;
			Vout[2] += V[2][core] / core_cnt;
			Vout[3] += V[3][core] / core_cnt;
		}
		radio_temp = (radio_temp + t_offset) / t_scale;
	}

	PHY_THERMAL(("Tempsense\n\tAuxADC0 Av,Vmid = 0x%x,0x%x\n",
	             auxPGA_Av, auxPGA_Vmid));
	PHY_THERMAL(("\tVref1,Vref2,Vctat1,Vctat2 =%d,%d,%d,%d\n",
	             Vout[0], Vout[2], Vout[1], Vout[3]));
	PHY_THERMAL(("\t^C Formula: (%d*(Vctat1+Vctat2-Vref1-Vref2)/2*800/1024+%d)/%d\n",
	             t_slope, t_offset, t_scale));
	PHY_THERMAL(("\t^C = %d, applied offset = %d\n",
	             radio_temp, offset));

	wlc_phy_tempsense_phy_cleanup_acphy(pi);
	wlc_phy_tempsense_radio_cleanup_acphy(pi);
	wlc_phy_restore_after_adc_read(pi,  &save_afePuCtrl, &save_gpio,
	                                    &save_chipc,  &fval2g_orig,  &fval5g_orig,
	                                    &fval2g,  &fval5g, &stall_val, &save_gpioHiOutEn);
	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	/* Store temperature and return value */
	pi->u.pi_acphy->current_temperature = (int16) radio_temp + offset;

#ifdef ATE_BUILD
	ate_buffer_regval.curr_radio_temp = pi->u.pi_acphy->current_temperature;
#endif // endif

	return ((int16) radio_temp + offset);
}

static void
wlc_phy_tempsense_radio_setup_acphy(phy_info_t *pi, uint16 Av, uint16 Vmid)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	tempsense_radioregs_t *porig =
		&(pi_ac->ac_tempsense_radioregs_orig.u.acphy_tempsense_radioregs);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Reg conflict with 2069 rev 16 */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0)
			porig->OVR18[core]         = READ_RADIO_REGC(pi, RF, OVR18, core);
		else
			porig->OVR19[core]         = READ_RADIO_REGC(pi, RF, GE16_OVR19, core);
		porig->tempsense_cfg[core] = READ_RADIO_REGC(pi, RF, TEMPSENSE_CFG, core);
		porig->OVR5[core]          = READ_RADIO_REGC(pi, RF, OVR5, core);
		porig->testbuf_cfg1[core]  = READ_RADIO_REGC(pi, RF, TESTBUF_CFG1, core);
		porig->OVR3[core]          = READ_RADIO_REGC(pi, RF, OVR3, core);
		porig->auxpga_cfg1[core]   = READ_RADIO_REGC(pi, RF, AUXPGA_CFG1, core);
		porig->auxpga_vmid[core]   = READ_RADIO_REGC(pi, RF, AUXPGA_VMID, core);

		MOD_RADIO_REGC(pi, OVR5, core, ovr_tempsense_pu, 0x1);
		MOD_RADIO_REGC(pi, TEMPSENSE_CFG, core, pu, 0x1);
		MOD_RADIO_REGC(pi, OVR5, core, ovr_testbuf_PU, 0x1);
		MOD_RADIO_REGC(pi, TESTBUF_CFG1, core, PU, 0x1);
		MOD_RADIO_REGC(pi, TESTBUF_CFG1, core, GPIO_EN, 0x0);
		MOD_RADIO_REGC(pi, OVR3, core, ovr_afe_auxpga_i_sel_vmid, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_VMID, core, auxpga_i_sel_vmid, Vmid);
		MOD_RADIO_REGC(pi, OVR3, core, ovr_auxpga_i_sel_gain, 0x1);
		MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_sel_gain, Av);

		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 1) {
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_vcm_ctrl, 0x0);
			/* This bit is supposed to be controlled by phy direct control line.
			 * Please check: http://jira.broadcom.com/browse/HW11ACRADIO-45
			 */
			MOD_RADIO_REGC(pi, AUXPGA_CFG1, core, auxpga_i_sel_input, 0x1);
		}
	}
}

static void
wlc_phy_tempsense_phy_setup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_tempsense_phyregs_t *porig = &(pi_ac->ac_tempsense_phyregs_orig);
	uint16 sdadc_config, mask;
	uint8 core;

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		sdadc_config = sdadc_cfg80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		if (pi->sdadc_config_override)
			sdadc_config = sdadc_cfg40hs;
		else
			sdadc_config = sdadc_cfg40;
	} else {
		sdadc_config = sdadc_cfg20;
	}

	porig->RxFeCtrl1 = READ_PHYREG(pi, RxFeCtrl1);
	MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, 0);
	MOD_PHYREG(pi, RxFeCtrl1, swap_iq1, 0);
	MOD_PHYREG(pi, RxFeCtrl1, swap_iq2, 0);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		mask = ACPHY_RfctrlIntc0_override_tr_sw_MASK(rev) |
		        ACPHY_RfctrlIntc0_tr_sw_tx_pu_MASK(rev);
		porig->RfctrlIntc[core] = phy_reg_read(pi, ACPHYREGCE(pi, RfctrlIntc, core));
		phy_reg_write(pi, ACPHYREGCE(pi, RfctrlIntc, core), mask);  /* elna off */

		porig->RfctrlOverrideAuxTssi[core]  = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi,
		                                                    core);
		porig->RfctrlCoreAuxTssi1[core]     = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
		porig->RfctrlOverrideRxPus[core]    = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
		porig->RfctrlCoreRxPus[core]        = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
		porig->RfctrlOverrideTxPus[core]    = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
		porig->RfctrlCoreTxPus[core]        = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
		porig->RfctrlOverrideLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfSwtch,
		                                                    core);
		porig->RfctrlCoreLpfSwtch[core]     = READ_PHYREGCE(pi, RfctrlCoreLpfSwtch, core);
		porig->RfctrlOverrideAfeCfg[core]   = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
		porig->RfctrlCoreAfeCfg1[core]      = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
		porig->RfctrlCoreAfeCfg2[core]      = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);
		porig->RfctrlOverrideGains[core]    = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
		porig->RfctrlCoreLpfGain[core]      = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);

		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, amux_sel_port, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, amux_sel_port, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideAuxTssi,  core, afe_iqadc_aux_en, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAuxTssi1,     core, afe_iqadc_aux_en, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus,    core, lpf_pu_dc, 1);
		MOD_PHYREGCE(pi, RfctrlCoreRxPus,        core, lpf_pu_dc, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideTxPus,    core, lpf_bq1_pu, 1);
		MOD_PHYREGCE(pi, RfctrlCoreTxPus,        core, lpf_bq1_pu, 1);
		MOD_PHYREGCE(pi, RfctrlOverrideTxPus,    core, lpf_bq2_pu, 1);
		MOD_PHYREGCE(pi, RfctrlCoreTxPus,        core, lpf_bq2_pu, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideTxPus,    core, lpf_pu, 1);
		MOD_PHYREGCE(pi, RfctrlCoreTxPus,        core, lpf_pu, 1);

		WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core,         0x154);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,     0x3ff);

		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_mode, sdadc_config & 0x7);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_mode, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, afe_iqadc_pwrup,
		             (sdadc_config >> 3) & 0x3f);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_pwrup, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_flashhspd,
		             (sdadc_config >> 9) & 0x1);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_flashhspd, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_ctrl_flash17lvl,
		             (sdadc_config >> 10) & 0x1);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_ctrl_flash17lvl, 1);
		MOD_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, afe_iqadc_adc_bias,
		             (sdadc_config >> 11) & 0x3);
		MOD_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, afe_iqadc_adc_bias,  1);

		MOD_PHYREGCE(pi, RfctrlCoreLpfGain,      core, lpf_bq1_gain, 0);
		MOD_PHYREGCE(pi, RfctrlOverrideGains,    core, lpf_bq1_gain, 1);
	}
}

static void
wlc_phy_tempsense_radio_cleanup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	tempsense_radioregs_t *porig =
		&(pi_ac->ac_tempsense_radioregs_orig.u.acphy_tempsense_radioregs);
	uint8 core;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/* Reg conflict with 2069 rev 16 */
		if (RADIOMAJORREV(pi->pubpi.radiomajorrev) == 0)
			write_radio_reg(pi, RF_2069_OVR18(core),         porig->OVR18[core]);
		else
			write_radio_reg(pi, RF_2069_GE16_OVR19(core),         porig->OVR19[core]);
		write_radio_reg(pi, RF_2069_TEMPSENSE_CFG(core), porig->tempsense_cfg[core]);
		write_radio_reg(pi, RF_2069_OVR5(core),          porig->OVR5[core]);
		write_radio_reg(pi, RF_2069_TESTBUF_CFG1(core),  porig->testbuf_cfg1[core]);
		write_radio_reg(pi, RF_2069_OVR3(core),          porig->OVR3[core]);
		write_radio_reg(pi, RF_2069_AUXPGA_CFG1(core),   porig->auxpga_cfg1[core]);
		write_radio_reg(pi, RF_2069_AUXPGA_VMID(core),   porig->auxpga_vmid[core]);
	}
}

static void
wlc_phy_tempsense_phy_cleanup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_tempsense_phyregs_t *porig = &(pi_ac->ac_tempsense_phyregs_orig);
	uint8 core;

	WRITE_PHYREG(pi, RxFeCtrl1, porig->RxFeCtrl1);

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		WRITE_PHYREGCE(pi, RfctrlIntc, core, porig->RfctrlIntc[core]);

		WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, porig->RfctrlOverrideAuxTssi[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, porig->RfctrlCoreAuxTssi1[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, porig->RfctrlOverrideRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, porig->RfctrlCoreRxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, porig->RfctrlOverrideTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, porig->RfctrlCoreTxPus[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core,
		              porig->RfctrlOverrideLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, porig->RfctrlCoreLpfSwtch[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, porig->RfctrlOverrideAfeCfg[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, porig->RfctrlCoreAfeCfg1[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, porig->RfctrlCoreAfeCfg2[core]);
		WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, porig->RfctrlOverrideGains[core]);
		WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, porig->RfctrlCoreLpfGain[core]);
	}
}

void
wlc_phy_rxcore_setstate_acphy(wlc_phy_t *pih, uint8 rxcore_bitmask)
{
	phy_info_t *pi = (phy_info_t*)pih;
	uint16 rfseqCoreActv_DisRx_save;
	uint16 rfseqMode_save;
	uint8 stall_val = 0;
	uint8 orig_rxfectrl1 = 0;
	uint16 classifier_state = 0;
	uint16 edThreshold_save = 0;

	ASSERT((rxcore_bitmask > 0) && (rxcore_bitmask <= 7));
	pi->sh->phyrxchain = rxcore_bitmask;

	if (!pi->sh->clk)
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Disable classifier */
		classifier_state = READ_PHYREG(pi, ClassifierCtrl);
		wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK, 4);

		/* Disable stalls and hold FIFOs in reset */
		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		orig_rxfectrl1 = READ_PHYREGFLD(pi, RxFeCtrl1, soft_sdfeFifoReset);
		ACPHY_REG_LIST_START
			ACPHY_DISABLE_STALL_ENTRY(pi)
			MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	/* Save Registers */
	rfseqCoreActv_DisRx_save = READ_PHYREGFLD(pi, RfseqCoreActv2059, DisRx);
	rfseqMode_save = READ_PHYREG(pi, RfseqMode);

	/* JIRA: CRDOT11ACPHY-909; The fix is to max out the edThreshold to prevent
	* the unused core stuck at wait_energy_drop during coremask setting
	*/

	edThreshold_save = READ_PHYREG(pi, Core0edThreshold);
	ACPHYREG_BCAST(pi, Core0edThreshold, 0xffff);
	/* delay to allow the edThreshold setting take effect */
	OSL_DELAY(10);
	/* Indicate to PHY of the Inactive Core */
	MOD_PHYREG(pi, CoreConfig, CoreMask, rxcore_bitmask);
	/* Indicate to RFSeq of the Inactive Core */
	MOD_PHYREG(pi, RfseqCoreActv2059, EnRx, rxcore_bitmask);
	ACPHY_REG_LIST_START
		/* Make sure Rx Chain gets shut off in Rx2Tx Sequence */
		MOD_PHYREG_ENTRY(pi, RfseqCoreActv2059, DisRx, 7)
		/* Make sure Tx Chain doesn't get turned off during this function */
		MOD_PHYREG_ENTRY(pi, RfseqCoreActv2059, EnTx, 0)
		MOD_PHYREG_ENTRY(pi, RfseqMode, CoreActv_override, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	wlc_phy_force_rfseq_noLoleakage_acphy(pi);

	/* Make TxEn chains point to hwphytxchain & should be subset of rxchain */
	MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, pi->sh->hw_phytxchain & rxcore_bitmask);

	/*  Restore Register */
	MOD_PHYREG(pi, RfseqCoreActv2059, DisRx, rfseqCoreActv_DisRx_save);
	WRITE_PHYREG(pi, RfseqMode, rfseqMode_save);

	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* Restore FIFO reset and Stalls */
		ACPHY_ENABLE_STALL(pi, stall_val);
		MOD_PHYREG(pi, RxFeCtrl1, soft_sdfeFifoReset, orig_rxfectrl1);
		OSL_DELAY(1);

		/* Restore classifier */
		WRITE_PHYREG(pi, ClassifierCtrl, classifier_state);
		OSL_DELAY(1);

		/* Reset PHY */
		wlc_phy_resetcca_acphy(pi);
	}

	 /* Restore edThreshold */
	ACPHYREG_BCAST(pi, Core0edThreshold, edThreshold_save);

	wlapi_enable_mac(pi->sh->physhim);
}

uint8
wlc_phy_rxcore_getstate_acphy(wlc_phy_t *pih)
{
	uint16 rxen_bits;
	phy_info_t *pi = (phy_info_t*)pih;

	rxen_bits = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnRx);

	ASSERT(pi->sh->phyrxchain == rxen_bits);

	return ((uint8) rxen_bits);
}

static void wlc_phy_tx_gm_gain_boost(phy_info_t *pi)
{
	uint8 core;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			MOD_RADIO_REGC(pi, TXGM_CFG1, core, gc_res, 0x1);
		}
	} else {
		if (pi_ac->srom.gainboosta01) {
			/* Boost A0/1 radio gain */
			FOREACH_CORE(pi, core) {
				MOD_RADIO_REGC(pi, TXMIX5G_CFG1, core, gainboost, 0x6);
				MOD_RADIO_REGC(pi, PGA5G_CFG1, core, gainboost, 0x6);
			}
		}
		if (RADIOREV(pi->pubpi.radiorev) <= 3) {
			/* Boost A2 radio gain */
			core = 2;
			MOD_RADIO_REGC(pi, TXMIX5G_CFG1, core, gainboost, 0x6);
			MOD_RADIO_REGC(pi, PGA5G_CFG1, core, gainboost, 0x6);
		}
	}
}

static void acphy_load_txv_for_spexp(phy_info_t *pi)
{
	uint32 len = 243, offset = 1220;

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFMUSERINDEX,
	                          len, offset, 32, acphy_txv_for_spexp);
}

static int
wlc_phy_txpower_core_offset_set_acphy(phy_info_t *pi, struct phy_txcore_pwr_offsets *offsets)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	int8 core_offset;
	int core;
	int offset_changed = FALSE;

	FOREACH_CORE(pi, core) {
		core_offset = offsets->offset[core];
		if (core_offset != 0 && core > pi->pubpi.phy_corenum) {
			return BCME_BADARG;
		}

		if (pi_ac->txpwr_offset[core] != core_offset) {
			offset_changed = TRUE;
			pi_ac->txpwr_offset[core] = core_offset;
		}
	}

	/* Apply the new per-core targets to the hw */
	if (pi->sh->clk && offset_changed) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phy_txpower_recalc_target_acphy(pi);
		wlapi_enable_mac(pi->sh->physhim);
	}
	return BCME_OK;
}

static int
wlc_phy_txpower_core_offset_get_acphy(phy_info_t *pi, struct phy_txcore_pwr_offsets *offsets)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	int core;

	memset(offsets, 0, sizeof(struct phy_txcore_pwr_offsets));

	FOREACH_CORE(pi, core) {
		offsets->offset[core] = pi_ac->txpwr_offset[core];
	}
	return BCME_OK;
}

static void
wlc_phy_set_crs_min_pwr_acphy(phy_info_t *pi, uint8 ac_th, int8 offset_1, int8 offset_2)
{
	uint8 core;
	uint8 mfcrs_1bit = 0; /* match filter carrier sense 1 bit mode */
	uint8 mf_th = ac_th, ac_th1;
	int8  mf_off1 = offset_1;

	PHY_TRACE(("%s: AC %d\n", __FUNCTION__, ac_th));

	/* 1-bit MF: 4335A0, 4335B0, 4350 */
	/* 6-bit MF: 4335C0 */

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_2(pi->pubpi.phy_rev)) {
		mfcrs_1bit = 1;
	} else {
		mfcrs_1bit = 0;
	}

	/* did not see any positive pwr consumption impact of 1 bit mode, so increase sensitivity */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		mfcrs_1bit = 0;
	}

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
		mfcrs_1bit = 0; /* >= v2.1 */
	}

	if (ac_th == 0) {
		if (mfcrs_1bit == 1) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				mf_th = 60;
				ac_th = 58;
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				mf_th = 60;
				ac_th = 58;
			} else if (CHSPEC_IS80(pi->radio_chanspec)) {
				mf_th = 67;
				ac_th = 60;
			}
		} else {
			mf_th = ACPHY_CRSMIN_DEFAULT;
			ac_th = ACPHY_CRSMIN_DEFAULT;
		}
		pi->u.pi_acphy->phy_crs_th_from_crs_cal = ac_th;
	} else {
		if (mfcrs_1bit == 1) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				mf_th = ((ac_th*101)/100) + 2;
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				mf_th = ((ac_th*109)/100) - 2;
			} else if (CHSPEC_IS80(pi->radio_chanspec)) {
				mf_th = ((ac_th*105)/100) + 2;
			}
		}
	}

	/* Adjust offset values for 1-bit MF */
	/* Not needed for 4335 and 4360, will be needed for 4350, disabled for now */

	if (mfcrs_1bit == 1) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (core == 1) {
				if (CHSPEC_IS5G(pi->radio_chanspec)) {
					if (CHSPEC_IS20(pi->radio_chanspec))
					{
						mf_off1 = ((((ac_th+offset_1)*101)/100) + 2)-mf_th;
					} else if (CHSPEC_IS40(pi->radio_chanspec)) {
						mf_off1 = ((((ac_th+offset_1)*109)/100) - 2)-mf_th;
					} else if (CHSPEC_IS80(pi->radio_chanspec)) {
						mf_off1 = ((((ac_th+offset_1)*105)/100) + 2)-mf_th;
					}
				}
			}
		}
	} /* else mf_off1 = offset_1 */

	FOREACH_CORE(pi, core) {
		switch (core) {
			case 0:
				/* 4345:temp solution to resolve SWWLAN-42160 */
				if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
					ac_th1 = ac_th + 16;
					if ((CHSPEC_IS5G(pi->radio_chanspec)) &&
						(pi->u.pi_acphy->LTEJ_WAR_en == TRUE)) {
						if (ac_th1 > 106) {
							ac_th1 = 106;
						}
					} else {
						if (ac_th1 > 90) {
							ac_th1 = 90;
						}
					}
					MOD_PHYREG(pi, crsminpoweru0, crsminpower0, ac_th1);
				} else {
					MOD_PHYREG(pi, crsminpoweru0, crsminpower0, ac_th);
					/* MOD_PHYREG(pi, crsminpoweru0, crsminpower1, ac_th); */
				}
				MOD_PHYREG(pi, crsmfminpoweru0, crsmfminpower0, mf_th);
				MOD_PHYREG(pi, crsminpowerl0, crsminpower0, ac_th);
				MOD_PHYREG(pi, crsmfminpowerl0, crsmfminpower0, mf_th);
				MOD_PHYREG(pi, crsminpoweruSub10, crsminpower0, ac_th);
				MOD_PHYREG(pi, crsmfminpoweruSub10, crsmfminpower0,  mf_th);
				MOD_PHYREG(pi, crsminpowerlSub10, crsminpower0, ac_th);
				MOD_PHYREG(pi, crsmfminpowerlSub10, crsmfminpower0,  mf_th);

				/* Set CRS thresholds for gain_HI same with INIT gain */

				/* if (ACMAJORREV_2(pi->pubpi.phy_rev) && */
				/*     (ACMINORREV_0(pi->pubpi.phy_rev) || */
				/*      ACMINORREV_1(pi->pubpi.phy_rev) || */
				/*      ACMINORREV_4(pi->pubpi.phy_rev))) { */
				/* MOD_PHYREG(pi, crsmfminpoweru0, crsmfminpower1, mf_th); */
				/* MOD_PHYREG(pi, crsminpowerl0, crsminpower1, ac_th); */
				/* MOD_PHYREG(pi, crsmfminpowerl0, crsmfminpower1, mf_th); */
				/* MOD_PHYREG(pi, crsminpoweruSub10, crsminpower1, ac_th); */
				/* MOD_PHYREG(pi, crsmfminpoweruSub10, crsmfminpower1,  mf_th); */
				/* MOD_PHYREG(pi, crsminpowerlSub10, crsminpower1, ac_th); */
				/* MOD_PHYREG(pi, crsmfminpowerlSub10, crsmfminpower1,  mf_th); */
				/* } */
				break;
			case 1:
				/* Force the offsets for core-1 */
				/* Core 1 */
				MOD_PHYREG(pi, crsminpoweroffset1,
				           crsminpowerOffsetu, offset_1);
				MOD_PHYREG(pi, crsminpoweroffset1,
				           crsminpowerOffsetl, offset_1);
				MOD_PHYREG(pi, crsmfminpoweroffset1,
				           crsmfminpowerOffsetu, mf_off1);
				MOD_PHYREG(pi, crsmfminpoweroffset1,
				           crsmfminpowerOffsetl, mf_off1);
				MOD_PHYREG(pi, crsminpoweroffsetSub11,
				           crsminpowerOffsetlSub1, offset_1);
				MOD_PHYREG(pi, crsminpoweroffsetSub11,
				           crsminpowerOffsetuSub1, offset_1);
				MOD_PHYREG(pi, crsmfminpoweroffsetSub11,
				           crsmfminpowerOffsetlSub1, mf_off1);
				MOD_PHYREG(pi, crsmfminpoweroffsetSub11,
				           crsmfminpowerOffsetuSub1, mf_off1);
				break;
			case 2:
				/* Force the offsets for core-2 */
				/* Core 2 */
				MOD_PHYREG(pi, crsminpoweroffset2,
				           crsminpowerOffsetu, offset_2);
				MOD_PHYREG(pi, crsminpoweroffset2,
				           crsminpowerOffsetl, offset_2);
				MOD_PHYREG(pi, crsmfminpoweroffset2,
				           crsmfminpowerOffsetu, offset_2);
				MOD_PHYREG(pi, crsmfminpoweroffset2,
				           crsmfminpowerOffsetl, offset_2);
				MOD_PHYREG(pi, crsminpoweroffsetSub12,
				           crsminpowerOffsetlSub1, offset_2);
				MOD_PHYREG(pi, crsminpoweroffsetSub12,
				           crsminpowerOffsetuSub1, offset_2);
				MOD_PHYREG(pi, crsmfminpoweroffsetSub12,
				           crsmfminpowerOffsetlSub1, offset_2);
				MOD_PHYREG(pi, crsmfminpoweroffsetSub12,
				           crsmfminpowerOffsetuSub1, offset_2);
				break;
		default:
			break;
		}
	}
}

#ifndef WLC_DISABLE_ACI
static void
wlc_phy_set_crs_min_pwr_higain_acphy(phy_info_t *pi, uint8 thresh)
{
	MOD_PHYREG(pi, crsminpoweru0, crsminpower1, thresh);
	MOD_PHYREG(pi, crsmfminpoweru0, crsmfminpower1, thresh);
	MOD_PHYREG(pi, crsminpowerl0, crsminpower1, thresh);
	MOD_PHYREG(pi, crsmfminpowerl0, crsmfminpower1, thresh);
	MOD_PHYREG(pi, crsminpoweruSub10, crsminpower1, thresh);
	MOD_PHYREG(pi, crsmfminpoweruSub10, crsmfminpower1,  thresh);
	MOD_PHYREG(pi, crsminpowerlSub10, crsminpower1, thresh);
	MOD_PHYREG(pi, crsmfminpowerlSub10, crsmfminpower1,  thresh);
}
#endif /* !WLC_DISABLE_ACI */

#if defined(WLTEST)

int16
wlc_phy_test_tssi_acphy(phy_info_t *pi, int8 ctrl_type, int8 pwr_offs)
{
	int16 tssi = 0;
	int16 temp = 0;
	int Npt, Npt_log2, i;

	Npt_log2 = READ_PHYREGFLD(pi, TxPwrCtrlNnum, Npt_intg_log2);
	Npt = 1 << Npt_log2;

	switch (ctrl_type & 0x7) {
	case 0:
	case 1:
	case 2:
		for (i = 0; i < Npt; i++) {
			OSL_DELAY(10);
			temp = READ_PHYREGCE(pi, TssiVal_path, ctrl_type) & 0x3ff;
			temp -= (temp >= 512) ? 1024 : 0;
			tssi += temp;
		}
		tssi = tssi >> Npt_log2;
		break;
	default:
		tssi = -1024;
	}
	return (tssi);
}

int16
wlc_phy_test_idletssi_acphy(phy_info_t *pi, int8 ctrl_type)
{
	int16 idletssi = INVALID_IDLETSSI_VAL;

	switch (ctrl_type & 0x7) {
	case 0:
	case 1:
	case 2:
		idletssi = READ_PHYREGCE(pi, TxPwrCtrlIdleTssi_path, ctrl_type) & 0x3ff;
		idletssi -= (idletssi >= 512) ? 1024 : 0;
		break;
	default:
		idletssi = INVALID_IDLETSSI_VAL;
	}

	return (idletssi);
}

void
wlc_phy_test_scraminit_acphy(phy_info_t *pi, int8 init)
{
	/* PR 38226: routine to allow special testmodes where the scrambler is
	 * forced to a fixed init value, hence, the same bit sequence into
	 * the MAC produces the same constellation point sequence every
	 * time
	 */

	if (init < 0) {
		/* auto: clear Mode bit so that scrambler LFSR will be free
		 * running.  ok to leave scramindexctlEn and initState in
		 * whatever current condition, since their contents are unused
		 * when free running.
		 */
		MOD_PHYREG(pi, ScramSigCtrl, scramCtrlMode, 0);
	} else {
		/* fixed init: set Mode bit, clear scramindexctlEn, and write
		 * init to initState, so that scrambler LFSR will be
		 * initialized with specified value for each transmission.
		 */
		MOD_PHYREG(pi, ScramSigCtrl, initStateValue, init);
		MOD_PHYREG(pi, ScramSigCtrl, scramindexctlEn, 0);
		MOD_PHYREG(pi, ScramSigCtrl, scramCtrlMode, 1);
	}
}

void
wlc_phy_iovar_patrim_acphy(phy_info_t *pi, int32 *ret_int_ptr)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (ACMAJORREV_2(pi->pubpi.phy_rev) && pi_ac->srom.tssi_div_war) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				*ret_int_ptr = 0x0;
			}
			else {
				*ret_int_ptr = 0x3;
			}
		}
		else
			*ret_int_ptr = 0x0;
	} else if ((ACMAJORREV_1(pi->pubpi.phy_rev) || TINY_RADIO(pi)) &&
		pi_ac->srom.tssi_div_war) {
		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			*ret_int_ptr = 0x21;
		}
		else
			*ret_int_ptr = 0x14;
	}
	else
		*ret_int_ptr = 0x0;

}

#endif // endif

/** Tx implicit beamforming. Ingress and outgress channels are assumed to have reprocity. */
void wlc_phy_populate_recipcoeffs_acphy(phy_info_t *pi)
{
	int16 sin_tbl[] = {
	0x000, 0x00d, 0x019, 0x026, 0x032, 0x03f, 0x04b, 0x058,
	0x064, 0x070, 0x07c, 0x089, 0x095, 0x0a1, 0x0ac, 0x0b8,
	0x0c4, 0x0cf, 0x0db, 0x0e6, 0x0f1, 0x0fc, 0x107, 0x112,
	0x11c, 0x127, 0x131, 0x13b, 0x145, 0x14e, 0x158, 0x161,
	0x16a, 0x173, 0x17b, 0x184, 0x18c, 0x194, 0x19b, 0x1a3,
	0x1aa, 0x1b1, 0x1b7, 0x1bd, 0x1c4, 0x1c9, 0x1cf, 0x1d4,
	0x1d9, 0x1de, 0x1e2, 0x1e6, 0x1ea, 0x1ed, 0x1f1, 0x1f4,
	0x1f6, 0x1f8, 0x1fa, 0x1fc, 0x1fe, 0x1ff, 0x1ff, 0x200};

	uint16 start_words[][3] = {
		{0x005B, 0x0000, 0x0000},
		{0x8250, 0x0000, 0x0000},
		{0xC338, 0x0000, 0x0000},
		{0x4527, 0x0001, 0x0000},
		{0xA6A1, 0x0001, 0x0000},
		{0x081B, 0x0002, 0x0000},
		{0x8A18, 0x0002, 0x0000},
		{0x2C96, 0x0003, 0x0000},
		{0x8E17, 0x0003, 0x0000},
		{0x101B, 0x0004, 0x0000},
		{0x0020, 0x0000, 0x0000},
		{0x0020, 0x0000, 0x0000}};

	/* total (64+128+256+4) 48-bit words
	 * due to memory limitations of function,
	 * we write 4 times with 113 words respectively.
	 */
	uint16 table_words[113][3];
	uint16 packed_word[3] = {0, 0, 0};
	uint16 zero_word[3] = {0, 0, 0};

	uint16 ang_tmp, recip_coef_nfrac = 11;
	uint16 subband_idx, k, m, num_angles = 2;
	uint16 theta[2];
	int16  re = 0, im = 0, exp, quad;
	int16  sin_idx, cos_idx;
	int16  sin_out, cos_out;
	uint32 packed;
	uint16 nwords_start = 12, nwords_pad = 4, nwords_recip;
	uint8  stall_val;

	bool is_caled = wlc_phy_is_txbfcal((wlc_phy_t *)pi);

	if ((pi->sh->hw_phytxchain <= 1) || !(is_caled)) {
		return;
	}

	/* 1. obtain angles from SROM */
	subband_idx = wlc_phy_get_chan_freq_range_acphy(pi, 0);
	switch (subband_idx) {
	case WL_CHAN_FREQ_RANGE_2G:
#ifdef WLTXBF_2G_DISABLED
		ang_tmp = 0;
#else
		ang_tmp = pi->sh->rpcal2g;
#endif /* WLTXBF_2G_DISABLED */
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND0:
		ang_tmp = pi->sh->rpcal5gb0;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND1:
		ang_tmp = pi->sh->rpcal5gb1;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND2:
		ang_tmp = pi->sh->rpcal5gb2;
		break;
	case WL_CHAN_FREQ_RANGE_5G_BAND3:
		ang_tmp = pi->sh->rpcal5gb3;
		break;
	default:
		ang_tmp = pi->sh->rpcal2g;
		break;
	}
	theta[0] = (uint8) (ang_tmp & 0xFF);
	theta[1] = (uint8) ((ang_tmp >> 8) & 0xFF);

	/* printf("---- theta1 = %d, theta2 = %d\n", theta[0], theta[1]); */

	/* 2. generate packed word */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {

		for (k = 0, packed = 0; k < num_angles; k++) {

			/* 6 LSBs for 1st quadrant */
			sin_idx = (theta[k] & 0x3F);
			cos_idx = 63 - sin_idx;

			sin_out = sin_tbl[sin_idx];
			cos_out = sin_tbl[cos_idx];

			/* 2MSBs for quadrant */
			quad = ((theta[k] >> 6) & 0x3);

			if (quad == 0) {
				re =  cos_out; im = -sin_out;
			} else if (quad == 1) {
				re = -sin_out; im = -cos_out;
			} else if (quad == 2) {
				re = -cos_out; im =  sin_out;
			} else if (quad == 3) {
				re =  sin_out; im =  cos_out;
			}

			re += (re < 0) ? (1 << recip_coef_nfrac) : 0;
			im += (im < 0) ? (1 << recip_coef_nfrac) : 0;
			exp = 1;

			packed = (uint32) ((exp << (2*recip_coef_nfrac)) |
			(im << recip_coef_nfrac) | re);

			if (k == 0) {
				packed_word[0] = (packed & 0xFFFF);
				packed_word[1] = (packed >> 16) & 0xFF;
			} else if (k == 1) {
				packed_word[1] |= ((packed & 0xFF) << 8);
				packed_word[2] = (packed >> 8) & 0xFFFF;
			}
		}
		/* printf("reciprocity packed_word: %x%x%x\n",
		packed_word[2], packed_word[1], packed_word[0]);
		*/

	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {

		/* every 4 tones are packed into 1 word */
		packed = (theta[0] | (theta[0] << 8) | (theta[0] << 16) | (theta[0] << 24));

		/* printf("reciprocity packedWideWord: %x\n", packed); */
	}

	/* Disable stalls and hold FIFOs in reset */
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	/* 3. write to table */
	if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
		/* 4360: write the reciprocity table */
		nwords_recip = 64 + 128 + 256;
		for (k = 0; k < nwords_start; k++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG,
			1, k, 48, start_words[k]);
		}
		for (k = 0; k < nwords_recip; k++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG,
			1, nwords_start + k, 48, packed_word);
		}
		for (k = 0; k < nwords_pad; k++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG,
			1, nwords_start + nwords_recip + k, 48, zero_word);
		}
	} else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* 43602: write the 12 header words first */
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG,
		nwords_start, 0, 48, &(start_words[0][0]));

		/* prepare the words to be written to the table */
		nwords_recip = 113;
		for (k = 0; k < nwords_recip; k++) {
			for (m = 0; m < 3; m++) {
				table_words[k][m] = packed_word[m];
			}
		}
		/* then writ 3 rounds of 113 words */
		for (k = 0; k < 3; k++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG, nwords_recip,
			nwords_start + k*nwords_recip, 48, &(table_words[0][0]));
		}
		/* write one more round of 113 words with 4 zero pads */
		for (k = 0; k < nwords_pad; k++) {
			for (m = 0; m < 3; m++) {
				table_words[nwords_recip-nwords_pad+k][m] = 0;
			}
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG,
		nwords_recip, nwords_start + 3*nwords_recip, 48, &(table_words[0][0]));
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {

		/* 4 tones are packed into one word */
		nwords_recip = (256 >> 2);

		for (k = 0; k < nwords_recip; k++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_BFECONFIG2X2TBL,
			1, k, 32, &packed);
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

void
wlc_phy_init_test_acphy(phy_info_t *pi)
{

	/* Force WLAN antenna */
	wlc_btcx_override_enable(pi);
	/* Disable tx power control */
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
	/* Recalibrate for this channel */
	wlc_phy_cals_acphy(pi, PHY_CAL_SEARCHMODE_RESTART);
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
}

static void
wlc_phy_rxcal_leakage_comp_acphy(phy_info_t *pi, phy_iq_est_t loopback_rx_iq,
phy_iq_est_t leakage_rx_iq, int32 *angle, int32 *mag)
{

	acphy_iq_mismatch_t loopback_mismatch, leakage_mismatch;
	int32 loopback_sin_angle;
	int32 leakage_sin_angle;

	int32 den, num, tmp;
	int16 nbits;
	int32 weight = 0;
	cint32 val;

	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	wlc_phy_calc_iq_mismatch_acphy(&loopback_rx_iq, &loopback_mismatch);
	*mag = loopback_mismatch.mag;

	if (pi_ac->fdiqi.leakage_comp_mode == ACPHY_RXCAL_LEAKAGE_COMP) {
		wlc_phy_calc_iq_mismatch_acphy(&leakage_rx_iq, &leakage_mismatch);

		loopback_sin_angle = loopback_mismatch.sin_angle;
		leakage_sin_angle  = leakage_mismatch.sin_angle;

		den = loopback_rx_iq.i_pwr + loopback_rx_iq.q_pwr;
		num = leakage_rx_iq.i_pwr  + leakage_rx_iq.q_pwr;

		nbits = wlc_phy_nbits(num);
		if (nbits % 2 == 1) nbits++;

		num = num << (30 - nbits);
		if (nbits > 10)
			den = den >> (nbits - 10);
		else
			den = den << (10 - nbits);
		num += (den >> 1);

		if (den != 0) {
			weight = (int32) wlc_phy_sqrt_int((uint32)(num / den));
		}

		if (weight > 41) { /* 40.96 = 0.04 * 2^10 */
			tmp = (loopback_sin_angle-leakage_sin_angle) * weight;
			tmp = tmp >> 10;

			val.q = loopback_sin_angle + tmp;

			tmp = (val.q >> 1);
			tmp *= tmp;
			tmp = (1 << 30) - tmp;
			val.i = (int32) wlc_phy_sqrt_int((uint32) tmp);
			val.i = ( val.i << 1) ;

			wlc_phy_inv_cordic(val, angle);
		} else {
			*angle = loopback_mismatch.angle;
		}
#if defined(BCMDBG_RXCAL)
	printf("   Ang :: %d loopback %d leakage %d weight %d Mag :: %d\n",
	       *angle, loopback_mismatch.angle, leakage_mismatch.angle,
		weight, *mag);
#endif /* BCMDBG_RXCAL */

	} else {
		*angle = loopback_mismatch.angle;
#if defined(BCMDBG_RXCAL)
		printf("   Ang :: %d Mag :: %d\n", *angle, *mag);
#endif /* BCMDBG_RXCAL */
	}

}

static void
wlc_phy_rx_fdiqi_lin_reg_acphy(phy_info_t *pi, acphy_rx_fdiqi_t *freq_ang_mag, uint16 num_data)
{

	int32 Sf2 = 0;
	int32 Sfa[PHY_CORE_MAX], Sa[PHY_CORE_MAX], Sm[PHY_CORE_MAX];
	int32 intcp[PHY_CORE_MAX], mag[PHY_CORE_MAX];
	int32 refBW;

	int8 idx;
	uint8 core;

	phy_iq_comp_t coeffs[PHY_CORE_MAX];
	int32 sin_angle, cos_angle;
	cint32 cordic_out;
	int32  a, b, sign_sa;

	/* initialize array for all cores to prevent compile warning (UNINIT) */
	FOREACH_CORE(pi, core) {
		Sfa[core] = 0; Sa[core] = 0; Sm[core] = 0;
	}

	for (idx = 0; idx < num_data; idx++) {
		Sf2 += freq_ang_mag[idx].freq * freq_ang_mag[idx].freq;
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			Sfa[core] += freq_ang_mag[idx].freq * freq_ang_mag[idx].angle[core];
			Sa[core] += freq_ang_mag[idx].angle[core];
			Sm[core] += freq_ang_mag[idx].mag[core];
		}
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		sign_sa = Sa[core] >= 0 ? 1 : -1;
		intcp[core] = (Sa[core] + sign_sa * (num_data >> 1)) / num_data;
		mag[core]   = (Sm[core] + (num_data >> 1)) / num_data;

		wlc_phy_cordic(intcp[core], &cordic_out);
		sin_angle = cordic_out.q;
		cos_angle = cordic_out.i;

		b = mag[core] * cos_angle;
		a = mag[core] * sin_angle;

		b = ((b >> 15) + 1) >> 1;
		b -= (1 << 10);  /* 10 bit */
		a = ((a >> 15) + 1) >> 1;

		a = (a < -512) ? -512 : ((a > 511) ? 511 : a);
		b = (b < -512) ? -512 : ((b > 511) ? 511 : b);

		coeffs[core].a = a & 0x3ff;
		coeffs[core].b = b & 0x3ff;

		if (pi->u.pi_acphy->fdiqi.enabled) {
			refBW = (CHSPEC_IS80(pi->radio_chanspec)) ? 30 :
				(CHSPEC_IS40(pi->radio_chanspec)) ? 15 : 8;
			pi->u.pi_acphy->fdiqi.slope[core] =
				(((-Sfa[core] * refBW / Sf2) >> 14) + 1 ) >> 1;
		}

#if defined(BCMDBG_RXCAL)
		printf("   a=%d b=%d :: ", a, b);
		if (pi->u.pi_acphy->fdiqi.enabled) {
			printf("   Slope = %d\n", pi->u.pi_acphy->fdiqi.slope[core]);
		} else {
			printf("   Slope = OFF\n");
		}
#endif /* BCMDBG_RXCAL */
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_rx_iq_comp_acphy(pi, 1, &(coeffs[core]), core);
	}

	if (pi->u.pi_acphy->fdiqi.enabled && !(TINY_RADIO(pi))) {
		wlc_phy_rx_fdiqi_comp_acphy(pi, TRUE);
	}

}

static void
wlc_phy_rx_fdiqi_comp_acphy(phy_info_t *pi, bool enable)
{
	uint8 core;
	int16 sign_slope;
	int8 idx;
	int32 slope;
#if defined(BCMDBG_RXCAL)
	int16 regval;
#endif /* BCMDBG_RXCAL */

	int16 filtercoeff[11][11] = {{0, 0, 0, 0, 0, 1024, 0, 0, 0, 0, 0},
		{-12, 15, -20, 30, -60, 1024, 61, -30, 20, -15, 12},
		{-24, 30, -40, 60, -120, 1024, 122, -61, 41, -30, 24},
		{-36, 45, -60, 91, -180, 1024, 184, -92, 61, -46, 37},
		{-42, 52, -69, 103, -206, 1024, 211, -105, 70, -52, 42},
		{-52, 65, -86, 129, -256, 1024, 264, -131, 87, -65, 52},
		{-62, 78, -103, 155, -307, 1023, 319, -158, 105, -78, 63},
		{-73, 91, -121, 180, -357, 1023, 373, -184, 122, -92, 73},
		{-83, 104, -138, 206, -407, 1023, 428, -211, 140, -105, 84},
		{-93, 117, -155, 231, -456, 1023, 483, -238, 158, -118, 94},
		{-104, 129, -172, 257, -506, 1022, 539, -265, 176, -132, 105}};

	/* enable: 0 - disable FDIQI comp
	 *         1 - program FDIQI comp filter and enable
	 */

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

#ifdef WL_PROXDETECT
	if (pi->u.pi_acphy->tof_active) {
		return;
	}
#endif // endif

	/* write values */
	if (enable == FALSE) {
		MOD_PHYREG(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable, 0);
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			pi->u.pi_acphy->fdiqi.slope[core] = 0;
		}
#if defined(BCMDBG_RXCAL)
	/*	printf("   FDIQI Disabled\n"); */
#endif /* BCMDBG_RXCAL */
		return;
	} else {

#define ACPHY_RXFDIQCOMP_STR(pi, core, tap)	((ACPHY_rxfdiqcomp_str0_c0(pi->pubpi.phy_rev) +	\
	(0x200 * (core)) + (tap)))

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			slope = pi->u.pi_acphy->fdiqi.slope[core];
			sign_slope = slope >= 0 ? 1 : -1;
			slope *= sign_slope;
			if (slope > 10) slope = 10;

			ACPHY_REG_LIST_START
			    MOD_PHYREG_ENTRY(pi, rxfdiqImbN_offcenter_scale, N_offcenter_scale, 4)
			    MOD_PHYREG_ENTRY(pi, rxfdiqImbCompCtrl, rxfdiq_iorq, 0)
			    MOD_PHYREG_ENTRY(pi, rxfdiqImbCompCtrl, calibration_notoperation, 0)
			    MOD_PHYREG_ENTRY(pi, fdiqi_rx_comp_Nshift_out, Nshift_out, 10)
			ACPHY_REG_LIST_EXECUTE(pi)

			for (idx = 0; idx < 11; idx++) {
				if (sign_slope == -1) {
					phy_reg_write(pi, ACPHY_RXFDIQCOMP_STR(pi, core, idx),
						filtercoeff[slope][10-idx]);
				} else {
					phy_reg_write(pi, ACPHY_RXFDIQCOMP_STR(pi, core, idx),
						filtercoeff[slope][idx]);
				}
			}

#if defined(BCMDBG_RXCAL)
			printf("   Core=%d, Slope= %d :: ", core, sign_slope*slope);
			for (idx = 0; idx < 11; idx++) {
				regval = _PHY_REG_READ(pi, ACPHY_RXFDIQCOMP_STR(pi, core, idx));
				if (regval > 1024) regval -= 2048;
				printf(" %d", regval);
			}
			printf("\n");
#endif /* BCMDBG_RXCAL */

		}
		MOD_PHYREG(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable, 1);
	}

}

/* Program the Init, clip Hi/Mid/Low/Clip2 registers */
static void
wlc_phy_set_analog_rxgain(phy_info_t *pi, uint8 clipgain, uint8 *gain_idx, bool trtx, uint8 core)
{
	uint8 lna1, lna2, mix, bq0, bq1, tx, rx, dvga, lna1byp_val;
	uint16 gaincodeA, gaincodeB, final_gain;
	bool lna1byp_flag;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	ASSERT(core < PHY_CORE_MAX);

	lna1 = gain_idx[1];
	lna2 = gain_idx[2];
	mix = gain_idx[3];
	bq0 = (TINY_RADIO(pi)) ? 0 : gain_idx[4];
	bq1 = gain_idx[5];
	dvga = (TINY_RADIO(pi)) ? gain_idx[6] : 0;

	lna1byp_flag = pi_ac->fem_rxgains[core].lna1byp;
	if (lna1byp_flag || !trtx) {
		tx = 0; rx = 1;
	} else {
		tx = 1; rx = 0;
	}

	if (lna1byp_flag && (clipgain == 3)) {
		lna1 = 6;	/* select idx 6 of the lnaRout table */
		lna1byp_val = 1;
	} else {
		lna1byp_val = 0;
	}

	gaincodeA = (mix << 7) | (lna2 << 4) | (lna1 << 1);
	gaincodeB = (dvga <<12) | (bq1 << 8) | (bq0 << 4) |
	            (tx << 3) | (rx << 2) | (lna1byp_val << 1);

	if (clipgain == 0) {
		WRITE_PHYREGC(pi, InitGainCodeA, core, gaincodeA);
		WRITE_PHYREGC(pi, InitGainCodeB, core, gaincodeB);
		final_gain = ((bq1 << 13) | (bq0 << 10) | (mix << 6) | (lna2 << 3) | (lna1 << 0));

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0xf9 + core), 16,
		                          &final_gain);

		if (TINY_RADIO(pi)) {
			uint8 gmrout;
			uint16 rfseq_init_aux;
			uint8 offset = CHSPEC_IS2G(pi->radio_chanspec) ? lna1 : lna1 + 8;

			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT, 1, offset, 8, &gmrout);

			rfseq_init_aux = (((0xf & (gmrout >> 3)) << 4) | dvga);

			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0xf6 + core), 16,
			                          &rfseq_init_aux);

			/* elna index always zero, not required */
		}
	} else if (clipgain == 1) {
		WRITE_PHYREGC(pi, clipHiGainCodeA, core, gaincodeA);
		WRITE_PHYREGC(pi, clipHiGainCodeB, core, gaincodeB);
	} else if (clipgain == 2) {
		WRITE_PHYREGC(pi, clipmdGainCodeA, core, gaincodeA);
		WRITE_PHYREGC(pi, clipmdGainCodeB, core, gaincodeB);
	} else if (clipgain == 3) {
		WRITE_PHYREGC(pi, cliploGainCodeA, core, gaincodeA);
		WRITE_PHYREGC(pi, cliploGainCodeB, core, gaincodeB);
	} else if (clipgain == 4) {
		WRITE_PHYREGC(pi, clip2GainCodeA, core, gaincodeA);
		WRITE_PHYREGC(pi, clip2GainCodeB, core, gaincodeB);
	}
}

static void
BCMATTACHFN(wlc_phy_srom_read_gainctrl_acphy)(phy_info_t *pi)
{
	uint8 core, srom_rx, i;
	char srom_name[30];
	phy_info_acphy_t *pi_ac;
	uint8 raw_elna, raw_trloss, raw_bypass;

	pi_ac = pi->u.pi_acphy;
	pi_ac->srom.elna2g_present = (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
	                              BFL_SROM11_EXTLNA) != 0;
	pi_ac->srom.elna5g_present = (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
	                              BFL_SROM11_EXTLNA_5GHz) != 0;

	FOREACH_CORE(pi, core) {
		pi_ac->srom.femrx_2g[core].elna = 0;
		pi_ac->srom.femrx_2g[core].trloss = 0;
		pi_ac->srom.femrx_2g[core].elna_bypass_tr = 0;

		pi_ac->srom.femrx_5g[core].elna = 0;
		pi_ac->srom.femrx_5g[core].trloss = 0;
		pi_ac->srom.femrx_5g[core].elna_bypass_tr = 0;

		pi_ac->srom.femrx_5gm[core].elna = 0;
		pi_ac->srom.femrx_5gm[core].trloss = 0;
		pi_ac->srom.femrx_5gm[core].elna_bypass_tr = 0;

		pi_ac->srom.femrx_5gh[core].elna = 0;
		pi_ac->srom.femrx_5gh[core].trloss = 0;
		pi_ac->srom.femrx_5gh[core].elna_bypass_tr = 0;

		/*  -------  2G -------  */
		if (pi_ac->srom.elna2g_present) {
			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains2gelnagainaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL) {
				srom_rx = (uint8)PHY_GETINTVAR(pi, srom_name);
				pi_ac->srom.femrx_2g[core].elna = (2 * srom_rx) + 6;
			}

			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains2gtrelnabypaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL) {
				pi_ac->srom.femrx_2g[core].elna_bypass_tr =
				        (uint8)PHY_GETINTVAR(pi, srom_name);
			}
		}

		snprintf(srom_name, sizeof(srom_name),  rstr_rxgains2gtrisoaD, core);
		if (PHY_GETVAR(pi, srom_name) != NULL) {
			srom_rx = (uint8)PHY_GETINTVAR(pi, srom_name);
			pi_ac->srom.femrx_2g[core].trloss = (2 * srom_rx) + 8;
		}

		/*  -------  5G -------  */
		if (pi_ac->srom.elna5g_present) {
			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gelnagainaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL) {
				srom_rx = (uint8)PHY_GETINTVAR(pi, srom_name);
				pi_ac->srom.femrx_5g[core].elna = (2 * srom_rx) + 6;
			}

			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gtrelnabypaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL) {
				pi_ac->srom.femrx_5g[core].elna_bypass_tr =
				        (uint8)PHY_GETINTVAR(pi, srom_name);
			}
		}

		snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gtrisoaD, core);
		if (PHY_GETVAR(pi, srom_name) != NULL) {
			srom_rx = (uint8)PHY_GETINTVAR(pi, srom_name);
			pi_ac->srom.femrx_5g[core].trloss = (2 * srom_rx) + 8;
		}

		/*  -------  5G (mid) -------  */
		raw_elna = 0; raw_trloss = 0; raw_bypass = 0;
		if (pi_ac->srom.elna5g_present) {
			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gmelnagainaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL)
				raw_elna = (uint8)PHY_GETINTVAR(pi, srom_name);

			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gmtrelnabypaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL)
				raw_bypass = (uint8)PHY_GETINTVAR(pi, srom_name);
		}
		snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5gmtrisoaD, core);
		if (PHY_GETVAR(pi, srom_name) != NULL)
			raw_trloss = (uint8)PHY_GETINTVAR(pi, srom_name);

		if (((raw_elna == 0) && (raw_trloss == 0) && (raw_bypass == 0)) ||
		    ((raw_elna == 7) && (raw_trloss == 0xf) && (raw_bypass == 1))) {
			/* No entry in SROM, use generic 5g ones */
			pi_ac->srom.femrx_5gm[core].elna = pi_ac->srom.femrx_5g[core].elna;
			pi_ac->srom.femrx_5gm[core].elna_bypass_tr =
			        pi_ac->srom.femrx_5g[core].elna_bypass_tr;
			pi_ac->srom.femrx_5gm[core].trloss = pi_ac->srom.femrx_5g[core].trloss;
		} else {
			pi_ac->srom.femrx_5gm[core].elna = (2 * raw_elna) + 6;
			pi_ac->srom.femrx_5gm[core].elna_bypass_tr = raw_bypass;
			pi_ac->srom.femrx_5gm[core].trloss = (2 * raw_trloss) + 8;
		}

		/*  -------  5G (high) -------  */
		raw_elna = 0; raw_trloss = 0; raw_bypass = 0;
		if (pi_ac->srom.elna5g_present) {
			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5ghelnagainaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL)
				raw_elna = (uint8)PHY_GETINTVAR(pi, srom_name);

			snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5ghtrelnabypaD, core);
			if (PHY_GETVAR(pi, srom_name) != NULL)
				raw_bypass = (uint8)PHY_GETINTVAR(pi, srom_name);
		}
		snprintf(srom_name, sizeof(srom_name),  rstr_rxgains5ghtrisoaD, core);
		if (PHY_GETVAR(pi, srom_name) != NULL)
			raw_trloss = (uint8)PHY_GETINTVAR(pi, srom_name);

		if (((raw_elna == 0) && (raw_trloss == 0) && (raw_bypass == 0)) ||
		    ((raw_elna == 7) && (raw_trloss == 0xf) && (raw_bypass == 1))) {
			/* No entry in SROM, use generic 5g ones */
			pi_ac->srom.femrx_5gh[core].elna = pi_ac->srom.femrx_5gm[core].elna;
			pi_ac->srom.femrx_5gh[core].elna_bypass_tr =
			        pi_ac->srom.femrx_5gm[core].elna_bypass_tr;
			pi_ac->srom.femrx_5gh[core].trloss = pi_ac->srom.femrx_5gm[core].trloss;
		} else {
			pi_ac->srom.femrx_5gh[core].elna = (2 * raw_elna) + 6;
			pi_ac->srom.femrx_5gh[core].elna_bypass_tr = raw_bypass;
			pi_ac->srom.femrx_5gh[core].trloss = (2 * raw_trloss) + 8;
		}

		/* Stella modules have lower gain for core 0 low-5g channels */
		/* we can boost gain by changing elna gain for this core/subband */
		/* for dongle drivers this can be done via nvram, but for NIC there is not */
		/* enough SROM space, hence use this flag */
		if (pi_ac->rx5ggainwar && ACMAJORREV_2(pi->pubpi.phy_rev)) {
			pi_ac->srom.femrx_5g[0].elna = 8;
		}
	}

	snprintf(srom_name, sizeof(srom_name),  rstr_dot11b_opts);

	if (PHY_GETVAR(pi, srom_name) != NULL) {
	  pi_ac->srom.dot11b_opts = (uint32)PHY_GETINTVAR(pi, srom_name);

	} else {
	  pi_ac->srom.dot11b_opts = 0x1; /* B0 datapath */
	}

	snprintf(srom_name, sizeof(srom_name),  rstr_tiny_maxrxgain);

	if (PHY_GETVAR(pi, srom_name) != NULL) {
	  for (i = 0; i < 3; i++) {
	    pi_ac->srom.tiny_maxrxgain[i] =
	    (uint8) PHY_GETINTVAR_ARRAY_DEFAULT(pi, rstr_tiny_maxrxgain, i, 0);
	  }
	} else {
	    for (i = 0; i < 3; i++) {
	      pi_ac->srom.tiny_maxrxgain[i] = 0;
	    }
	}

}

int32
acphy_get_rxgain_index(phy_info_t *pi, uint8 *index)
{
	rxgain_t rxgain[PHY_CORE_MAX];
	int16 gain_db[PHY_CORE_MAX];
	uint8 rssi_rev = pi->u.pi_acphy->rssi_cal_rev;
	int i;
	bool forced;

	if (CHIPID(pi->sh->chip) != BCM4345_CHIP_ID)
		return BCME_UNSUPPORTED;

	forced = READ_PHYREGFLDCE(pi, RfctrlOverrideGains, 0, rxgain);

	for (i = 0; i < PHY_CORE_MAX; i++) {
		if (i == 0) {
			pi->u.pi_acphy->rssi_cal_rev = TRUE; /* prevent any rssi cal */
			/* when forced, init gain will contain current gain. In normal
				operation we use GainInfo. These correspond to added gain modes
				11 and 10 respectively
			*/
			/* init gain or pkt */
			wlc_phy_get_rxgain_acphy(pi, rxgain, gain_db, forced ? 11 : 10);
			pi->u.pi_acphy->rssi_cal_rev = rssi_rev;
		}

		/* driver applied 2 dB boardloss only to non-bypass mode.
			TODO: change code for 4345 to at least have consistent
			boardloss for bypass and max gain modes.
		*/

		if (rxgain[i].trtx == 0)
			gain_db[i] += 2;

		/* compute index with round */
		index[i] = ((gain_db[i] + 20)*85+255)/256;

		if (index[i] >= 64)
			return BCME_ERROR;

		/* if ACI mode, index reference from 64 */
		if (pi->u.pi_acphy->curr_desense.ofdm_desense ||
			pi->u.pi_acphy->curr_desense.bphy_desense ||
			pi->u.pi_acphy->curr_desense.lna1_tbl_desense)
			index[i] += 64;
	}
	return BCME_OK;
}

int32 acphy_set_rxgain_index(phy_info_t *pi, int index)
{
	uint8 core;
	int gain_step;
	int8 dB;
	uint8 rb_index[PHY_CORE_MAX];
	uint8 gain_idx[ACPHY_MAX_RX_GAIN_STAGES] = {0, 0, 0, 0, 0, 0, 0};
	bool trtx;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	rxgain_t rxgain[PHY_CORE_MAX];
	bool blocker_mode;
	bool elna_present = (CHSPEC_IS2G(pi->radio_chanspec)) ? pi_ac->srom.elna2g_present
		: pi_ac->srom.elna5g_present;
	bool forced = READ_PHYREGFLDCE(pi, RfctrlOverrideGains, 0, rxgain);
	rxgain_ovrd_t rxgain_ovrd[PHY_CORE_MAX];

	if (CHIPID(pi->sh->chip) != BCM4345_CHIP_ID)
		return BCME_UNSUPPORTED;

	pi->u.pi_acphy->curr_desense.clipgain_desense[0] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[1] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[2] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[3] = 0;

	/* max from index to gain */
	blocker_mode = index > 63;
	gain_step = index & 0x3f;

	/* return an error in out of bounds
		 (rely on encode gain for actualy max/min checking)
	*/
	gain_step = MIN(MAX(gain_step, 0), 38);
	/* round ? may need to add bias to unique unique mapping */
	dB = gain_step * 3 - 20;

	if ((blocker_mode == 0) || (index == 255)) {
		pi->u.pi_acphy->curr_desense.ofdm_desense = 0;
		pi->u.pi_acphy->curr_desense.bphy_desense = 0;
		pi->u.pi_acphy->curr_desense.lna1_tbl_desense = 0;
	} else {
		pi->u.pi_acphy->curr_desense.ofdm_desense = 9;
		pi->u.pi_acphy->curr_desense.bphy_desense = 9;
		pi->u.pi_acphy->curr_desense.lna1_tbl_desense = 1;
	}

	wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(pi, 0, ACPHY_TBL_ID_GAIN0,
		ACPHY_TBL_ID_GAINBITS0);
	wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);

	/* find gain */
	FOREACH_CORE(pi, core) {
		if (index == 255) {
			/* index 255 - release any gain override */
			WRITE_PHYREGCE(pi, RfctrlOverrideGains, core,
				rxgainindx_cmd_ovrd[core].rfctrlovrd);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core,
				rxgainindx_cmd_ovrd[core].rxgain);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core,
				rxgainindx_cmd_ovrd[core].rxgain2);
			WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core,
				rxgainindx_cmd_ovrd[core].lpfgain);
			MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 0);
			continue;
		}

		if (dB < pi_ac->rx_elna_bypass_gain_th)
			trtx = elna_present;
		else
			trtx = 0;

		(void)wlc_phy_rxgainctrl_encode_gain_acphy(pi, core, dB, trtx, FALSE, gain_idx);

		/* write to gain code A , also allows us to use get_rxgain */
		wlc_phy_set_analog_rxgain(pi, 0, gain_idx, trtx, core);

		acphy_get_rxgain_index(pi, rb_index); /* debug only */

		/* also write to rfctrl (not strictly necessary if we are
			 enforcing stay-in-carrier search
		*/
		rxgain[core].lna1 = gain_idx[1];
		rxgain[core].lna2 = gain_idx[2];
		rxgain[core].mix  = gain_idx[3];
		rxgain[core].lpf0 = gain_idx[4];
		rxgain[core].lpf1 = gain_idx[5];
		rxgain[core].dvga = gain_idx[6];
		PHY_INFORM(("GAIN: index %d:%d %d %d elna %d lna1 %d lna2 %d "
			"mix %d biq0 %d biq1 %d dvga %d trtx %d\n",
			index, rb_index[0], dB,
			wlc_phy_rxgainctrl_encode_gain_acphy(pi, core, dB, trtx, FALSE, gain_idx),
			gain_idx[0], gain_idx[1], gain_idx[2], gain_idx[3], gain_idx[4],
			gain_idx[5], gain_idx[6], trtx));

		if (forced == 0) {
			/* gain is currently unforced - save override state for to restore
				 at a later date if required
			*/
			rxgainindx_cmd_ovrd[core].rfctrlovrd =
				READ_PHYREGCE(pi, RfctrlOverrideGains, core);
			rxgainindx_cmd_ovrd[core].rxgain =
				READ_PHYREGCE(pi, RfctrlCoreRXGAIN1, core);
			rxgainindx_cmd_ovrd[core].rxgain2 =
				READ_PHYREGCE(pi, RfctrlCoreRXGAIN2, core);
			rxgainindx_cmd_ovrd[core].lpfgain =
				READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
		}

		/* override gains */
		wlc_phy_rfctrl_override_rxgain_acphy(pi, 0, rxgain, rxgain_ovrd);

		/* override tr/tx */
		if (trtx) {
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, trtx);
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
		} else {
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 0);
		}
	}

	/* flush init gain changes */
	wlc_phy_resetcca_acphy(pi);

	return BCME_OK;

}

static void
wlc_phy_rxgainctrl_gainctrl_acphy_tiny(phy_info_t *pi)
{
	/* at present this is just a place holder for
	 * 'static' ELNA configuration. Eventually both TCL and
	 * driver should be changes to follow the auto-calc
	 * routine used in wlc_phy_rxgainctrl_gainctrl_acphy
	 */
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool elna_present = (CHSPEC_IS2G(pi->radio_chanspec)) ? pi_ac->srom.elna2g_present
	                                                      : pi_ac->srom.elna5g_present;
	uint8 max_analog_gain;
	int16 maxgain[ACPHY_MAX_RX_GAIN_STAGES] = {0, 0, -100, 0, -100, 125, 125};
	uint8 i, core;
	bool init_trtx, hi_trtx, md_trtx, lo_trtx, lna1byp;
	int8 md_low_end, hi_high_end, lo_low_end, md_high_end;
	int8 clip2_gain;
	int8 hi_gain1, mid_gain1, lo_gain1;
	int8 w1clip_pwrdBm;
	int16 nbclip_pwrdBm;
	int8 clip_gain[] = {61, 37, 19, 1};

	pi_ac->mdgain_trtx_allowed = FALSE;

	max_analog_gain = READ_PHYREGFLD(pi, Core0HpFBw, maxAnalogGaindb);

	/* fill in gain limits for analog stages */
	maxgain[0] = maxgain[1] = maxgain[3] = max_analog_gain;

	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
		pi_ac->rxgainctrl_maxout_gains[i] = maxgain[i];

	/* Keep track of it (used in interf_mitigation) */
	pi_ac->curr_desense.elna_bypass = wlc_phy_get_max_lna_index_acphy(pi, 0);
	init_trtx = elna_present & pi_ac->curr_desense.elna_bypass;
	hi_trtx = elna_present & pi_ac->curr_desense.elna_bypass;
	md_trtx = elna_present & (pi_ac->mdgain_trtx_allowed | pi_ac->curr_desense.elna_bypass);
	lo_trtx = elna_present;

	if (!elna_present || md_trtx) {
	  if (CHSPEC_IS2G(pi->radio_chanspec)) {
	    clip_gain[2] = 19;
	    clip_gain[3] = 1;
	  } else {
	    clip_gain[2] = 19;
	    clip_gain[3] = 1;
	  }
	} else {
	  if (CHSPEC_IS2G(pi->radio_chanspec)) {
	    clip_gain[2] = 24;
	    clip_gain[3] = 15;
	  } else {
	    clip_gain[2] = 24;
	    clip_gain[3] = 15;
	  }
	}

	if (ACPHY_ENABLE_FCBS_HWACI(pi))
		/* Apply desense */
		for (i = 0; i < 4; i++)
			clip_gain[i] -= pi_ac->curr_desense.clipgain_desense[i];

	/* with elna if md_gain uses TR != T, then LO_gain needs to be higher */
	clip2_gain = md_trtx ? clip_gain[3] : (clip_gain[2] + clip_gain[3]) >> 1;

	FOREACH_CORE(pi, core) {
		lna1byp = pi_ac->fem_rxgains[core].lna1byp;	/* not supported on Tiny yet */

		/* 0,1,2,3 for Init, hi, md and lo gains respectively */
		wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 0, clip_gain[0], init_trtx,
		                                            FALSE, core);

		hi_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 1, clip_gain[1],
		                                                       hi_trtx, FALSE, core);

		mid_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 2, clip_gain[2],
		                                                        md_trtx, FALSE, core);

		wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 4, clip2_gain, md_trtx,
		                                            FALSE, core);

		lo_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 3, clip_gain[3],
		                                                       lo_trtx, lna1byp, core);

		/* NB_CLIP */
		md_low_end = wlc_phy_rxgainctrl_calc_low_sens_acphy(pi, mid_gain1, md_trtx, core);
		hi_high_end = wlc_phy_rxgainctrl_calc_high_sens_acphy(pi, hi_gain1, hi_trtx, core);
		lo_low_end = wlc_phy_rxgainctrl_calc_low_sens_acphy(pi, lo_gain1, lo_trtx, core);
		md_high_end = wlc_phy_rxgainctrl_calc_high_sens_acphy(pi, mid_gain1, md_trtx, core);

		w1clip_pwrdBm = (lo_low_end + md_high_end) >> 1;

		/* -1 times pwr to avoid rounding off error */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			/*
			 * use mid-point, as late clip2 is causing minor humps,
			 * move nb/w1 clip to a lower pwr
			 */
			nbclip_pwrdBm = (md_low_end + hi_high_end) >> 1;
		} else {
			/*
			 * (0.4*md/lo + 0.6*hi/md) fixed point. On fading channels,
			 * low-end sensitivity degrades, keep more margin there.
			 */
			nbclip_pwrdBm = (((-2 * md_low_end) + (-3 * hi_high_end)) * 13) >> 6;
			nbclip_pwrdBm = -nbclip_pwrdBm;
		}

		nbclip_pwrdBm = wlc_phy_rxgainctrl_nbclip_acphy_tiny(pi, core, nbclip_pwrdBm);
		wlc_phy_rxgainctrl_w1clip_acphy_tiny(pi, core, w1clip_pwrdBm);
		wlc_phy_rxgainctrl_w1clip_acphy(pi, core, w1clip_pwrdBm);

		/* save threshold for gain index functions */

		if (md_trtx)
			/* assume 12 dB backoff */
		  pi_ac->rx_elna_bypass_gain_th = clip_gain[0] + (-13 - nbclip_pwrdBm/10);
		else if (lo_trtx)
		  pi_ac->rx_elna_bypass_gain_th = clip_gain[0] + (-13 - w1clip_pwrdBm/10);
		else
		  pi_ac->rx_elna_bypass_gain_th = -100;
	}
	/* Saving the values of Init gain to be used
	 * in "wlc_phy_get_rxgain_acphy" function (used in rxiqest)
	 */
	pi_ac->initGain_codeA = READ_PHYREGC(pi, InitGainCodeA, 0);
	pi_ac->initGain_codeB = READ_PHYREGC(pi, InitGainCodeB, 0);
}

static void
wlc_phy_rxgainctrl_gainctrl_acphy(phy_info_t *pi)
{
	bool elna_present;
	bool init_trtx, hi_trtx, md_trtx, lo_trtx, lna1byp;
	uint8 init_gain = ACPHY_INIT_GAIN, hi_gain = ACPHY_HI_GAIN;
	uint8 mid_gain = 35, lo_gain, clip2_gain;
	uint8 hi_gain1, mid_gain1, lo_gain1;
	uint32 fc = wf_channel2mhz(CHSPEC_CHANNEL(pi->radio_chanspec),
		CHSPEC_IS2G(pi->radio_chanspec) ? WF_CHAN_FACTOR_2_4_G
		: WF_CHAN_FACTOR_5_G);
	/* 1% PER point used for all the PER numbers */

	/* For bACI/ACI: max output pwrs {elna, lna1, lna2, mix, bq0, bq1, dvga} */
	uint8 maxgain_2g[] = {43, 43, 43, 52, 52, 100, 0};
	uint8 maxgain_5g[] = {47, 47, 47, 52, 52, 100, 0};
	uint8 subband_idx;

	uint8 i, core, elna_idx;
	int8 md_low_end, hi_high_end, lo_low_end, md_high_end, max_himd_hi_end;
	int8 nbclip_pwrdBm, w1clip_pwrdBm;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->total_desense;
	bool elnabyp_en = (CHSPEC_IS2G(pi->radio_chanspec) & pi_ac->hirssi_elnabyp2g_en) ||
	        (CHSPEC_IS5G(pi->radio_chanspec) & pi_ac->hirssi_elnabyp5g_en);

	if (desense->lna1_bypass) {
		/* As LNA1 is in bypass we do not want to put the */
		/* eLNA in bypass for mid gain */
		pi_ac->mdgain_trtx_allowed = FALSE;
	} else {
		pi_ac->mdgain_trtx_allowed = TRUE;
	}
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
			pi_ac->rxgainctrl_maxout_gains[i] = maxgain_2g[i];
		elna_present = pi_ac->srom.elna2g_present;
	} else {
		for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
			pi_ac->rxgainctrl_maxout_gains[i] = maxgain_5g[i];
		elna_present = pi_ac->srom.elna5g_present;
	}

	subband_idx = wlc_phy_get_chan_freq_range_acphy(pi, CHSPEC_CHANNEL(pi->radio_chanspec));

	FOREACH_CORE(pi, core) {
		/* Stella modules have lower gain for core 0 low-5g channels */
		if (pi_ac->rx5ggainwar && ACMAJORREV_2(pi->pubpi.phy_rev)) {
			if (CHSPEC_IS5G(pi->radio_chanspec) &&
			    ((subband_idx == 1) || (subband_idx == 2))) {
				if (core == 0) {
					init_gain = 70;
				} else {
					init_gain = 69;
				}
			}
		}

		/* Keep track of it (used in interf_mitigation) */
		pi_ac->curr_desense.elna_bypass = wlc_phy_get_max_lna_index_acphy(pi, 0);
		if (pi_ac->btcx_hybrid_mode_simul_rx.on &&
			core == pi_ac->btcx_hybrid_mode_simul_rx.shared_core) {
			pi_ac->curr_desense.elna_bypass =
				pi_ac->btcx_hybrid_mode_simul_rx.shared_core_elna_bypass;
		}
		init_trtx = elna_present & pi_ac->curr_desense.elna_bypass;
		hi_trtx = elna_present & pi_ac->curr_desense.elna_bypass;
		md_trtx = elna_present & (pi_ac->mdgain_trtx_allowed |
		                          pi_ac->curr_desense.elna_bypass);
		if (desense->lna1_bypass) {
			lo_trtx = FALSE;
		} else {
			lo_trtx = TRUE;
		}

		/* with elna if md_gain uses TR != T, then LO_gain needs to be higher */
		if (elnabyp_en) {
			lo_gain = ((!elna_present) || md_trtx) ? 15 : 30;
		} else if (desense->lna1_bypass) {
			/* LNA1 is in bypass, let lo_gain be low */
			lo_gain = 20;
		} else {
			lo_gain = ((!elna_present) || md_trtx) ? 20 : 30;
		}
		clip2_gain = md_trtx ? lo_gain : (mid_gain + lo_gain) >> 1;

		lna1byp = pi_ac->fem_rxgains[core].lna1byp;
		if (lna1byp) {
			hi_gain = 48;
			mid_gain = 35;
			lo_gain = 15;
			PHY_INFORM((" iPa chip, set lo_gain = 15 \n"));
		}
		elna_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initExtLnaIndex);
		max_himd_hi_end = - 16 - pi_ac->rxgainctrl_params[core].gaintbl[0][elna_idx];
		if (pi_ac->curr_desense.elna_bypass == 1)
			max_himd_hi_end += pi_ac->fem_rxgains[core].trloss;

		/* 0,1,2,3 for Init, hi, md and lo gains respectively */
		wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 0, init_gain, init_trtx,
			FALSE, core);
		hi_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 1, hi_gain,
			hi_trtx, FALSE, core);
		mid_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 2, mid_gain,
			md_trtx, FALSE, core);
		wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 4, clip2_gain, md_trtx,
			FALSE, core);
		lo_gain1 = wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 3, lo_gain,
			lo_trtx, lna1byp, core);

		/* NB_CLIP */
		md_low_end = wlc_phy_rxgainctrl_calc_low_sens_acphy(pi, mid_gain1, md_trtx, core);
		hi_high_end = wlc_phy_rxgainctrl_calc_high_sens_acphy(pi, hi_gain1, hi_trtx, core);
		lo_low_end = wlc_phy_rxgainctrl_calc_low_sens_acphy(pi, lo_gain1, lo_trtx, core);
		md_high_end = wlc_phy_rxgainctrl_calc_high_sens_acphy(pi, mid_gain1, md_trtx, core);

		/* -1 times pwr to avoid rounding off error */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			/* use mid-point, as late clip2 is causing minor humps,
			   move nb/w1 clip to a lower pwr
			*/
			nbclip_pwrdBm = (md_low_end + hi_high_end) >> 1;
		} else {
			/* (0.4*md/lo + 0.6*hi/md) fixed point. On fading channels,
			   low-end sensitivity degrades, keep more margin there.
			*/
			nbclip_pwrdBm = (((-2*md_low_end)+(-3*hi_high_end)) * 13) >> 6;
			nbclip_pwrdBm *= -1;
			if (CHSPEC_IS80(pi->radio_chanspec) &&
			    (ACMAJORREV_2(pi->pubpi.phy_rev))) {

				/* 43569a2/43570a2 */
				if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID && PHY_ILNA(pi)) &&
				    (RADIOREV(pi->pubpi.radiorev) == 0x2C)) {
					/* to cure the 20ll PER hump issue for 43569/43570
					 * http://confluence.broadcom.com/x/NC-UEg
					 */
					nbclip_pwrdBm -= 6;
				} else {
					nbclip_pwrdBm -= 4;
				}
			}
		}

		if (CHSPEC_IS20(pi->radio_chanspec) ||
		    (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		     !PHY_ILNA(pi))) {
			if (elnabyp_en) {
				w1clip_pwrdBm = (((-2*lo_low_end) + (-3*md_high_end)) * 13) >> 6;
				w1clip_pwrdBm *= -1;
			} else {
				w1clip_pwrdBm = (lo_low_end + md_high_end) >> 1;
			}
		} else {
			w1clip_pwrdBm = (((-2*lo_low_end) + (-3*md_high_end)) * 13) >> 6;
			w1clip_pwrdBm *= -1;
		}
		if (CHSPEC_IS20(pi->radio_chanspec) &&
		    ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_3(pi->pubpi.phy_rev) &&
		    !ACMINORREV_5(pi->pubpi.phy_rev) && !PHY_ILNA(pi)) {
			w1clip_pwrdBm += 3;
		}
		/* 5G VHT40 hump in iLNA, WAR for 4354 */
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			/* Move w1 lower to avoid the LNA1 clamping issue at 2G */
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				w1clip_pwrdBm -= 3;
			} else {
				if ((CHSPEC_IS80(pi->radio_chanspec) ||
					CHSPEC_IS40(pi->radio_chanspec))) {
					/* for bw 80, solve per hump of 20/80 */
					/* for bw 40, solves the 43602 sss chip per hump issue at 70
					   degree C, SWWLAN-54192
					 */
					nbclip_pwrdBm -= 4;

					/* for bw40 and bw80, move W1 clip to be around -30dBm
						to avoid clip2 in normal AGC
					*/
					w1clip_pwrdBm -= 6;
				}
			}
		}

		wlc_phy_rxgainctrl_nbclip_acphy(pi, core, nbclip_pwrdBm);
		wlc_phy_rxgainctrl_w1clip_acphy(pi, core, w1clip_pwrdBm);

		if (CHSPEC_IS40(pi->radio_chanspec) && CHSPEC_IS5G(pi->radio_chanspec) &&
		(fc >= 5500) && ACMAJORREV_2(pi->pubpi.phy_rev) &&
		(ACMINORREV_1(pi->pubpi.phy_rev) || ACMINORREV_3(pi->pubpi.phy_rev) ||
		ACMINORREV_5(pi->pubpi.phy_rev)) &&
		(RADIOREV(pi->pubpi.radiorev) == 0x27 || RADIOREV(pi->pubpi.radiorev) == 0x29) &&
		PHY_ILNA(pi) && PHY_XTAL_IS37M4(pi)) {
			w1clip_pwrdBm -= 3;
		}
		/* 2G/5G VHT20 hump in eLNA, WAR for 43162 */
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
		     !PHY_ILNA(pi) && CHSPEC_IS20(pi->radio_chanspec) && PHY_XTAL_IS40M(pi)) {
			if (CHSPEC_IS5G(pi->radio_chanspec))
				nbclip_pwrdBm = ((md_low_end + hi_high_end) >> 1) - 5;
			else
				nbclip_pwrdBm = ((md_low_end + hi_high_end) >> 1) - 4;

			wlc_phy_rxgainctrl_nbclip_acphy(pi, core, nbclip_pwrdBm);
		}
	}
	/* After comming out of this loop, gain ctrl is done. So, values of Init gain in the phyregs
	 * are the correct/default ones. These should be the ones that should be used in
	 * "wlc_phy_get_rxgain_acphy" function (used in rxiqest). So, we have to save the default
	 * Init gain phyregs in some variables. We assume, that both core's init gains will be same
	 * and thus save only core 0's init gain and this should be fine for single core chips too.
	 */
	pi_ac->initGain_codeA = READ_PHYREGC(pi, InitGainCodeA, 0);
	pi_ac->initGain_codeB = READ_PHYREGC(pi, InitGainCodeB, 0);
}

static int8
wlc_phy_rxgainctrl_calc_low_sens_acphy(phy_info_t *pi, int8 clipgain, bool trtx, uint8 core)
{
	int sens, sens_bw[] = {-66, -63, -60};   /* c9s1 1% sensitivity for 20/40/80 mhz */
	uint8 low_sen_adjust[] = {25, 22, 19};   /* low_end_sens = -clip_gain - low_sen_adjust */
	uint8 bw_idx, elna_idx, trloss, elna_bypass_tr;
	int8 elna, detection, demod;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->total_desense;

	ASSERT(core < PHY_CORE_MAX);
	bw_idx = CHSPEC_IS20(pi->radio_chanspec) ? 0 : CHSPEC_IS40(pi->radio_chanspec) ? 1 : 2;
	sens =  sens_bw[bw_idx];

	elna_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initExtLnaIndex);
	elna = pi_ac->rxgainctrl_params[core].gaintbl[0][elna_idx];
	trloss = pi_ac->fem_rxgains[core].trloss;
	elna_bypass_tr = pi_ac->fem_rxgains[core].elna_bypass_tr;

	if (TINY_RADIO(pi))
		detection = -6 - (clipgain + low_sen_adjust[bw_idx]);
	else
		detection = 0 - (clipgain + low_sen_adjust[bw_idx]);

	demod = trtx ? (sens + trloss - (elna_bypass_tr * elna)) : sens;
	demod += desense->nf_hit_lna12;
	return MAX(detection, demod);
}

static int8
wlc_phy_rxgainctrl_calc_high_sens_acphy(phy_info_t *pi, int8 clipgain, bool trtx, uint8 core)
{
	uint8 high_sen_adjust = 23;  /* high_end_sens = high_sen_adjust - clip_gain */
	uint8 elna_idx, trloss;
	int8 elna, saturation, clipped, lna1_sat;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (TINY_RADIO(pi)) {
	  if (CHSPEC_IS2G(pi->radio_chanspec)) {
	    lna1_sat = -10;
	    high_sen_adjust = 17;
	  } else {
	    lna1_sat = -2;
	    high_sen_adjust = 19;
	  }
	} else {
	  lna1_sat = -16;
	  high_sen_adjust = 23;
	}

	ASSERT(core < PHY_CORE_MAX);
	elna_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initExtLnaIndex);
	elna = pi_ac->rxgainctrl_params[core].gaintbl[0][elna_idx];
	trloss = pi_ac->fem_rxgains[core].trloss;

	/* c9 needs lna1 input to be below lna1_sat */
	saturation = trtx ? (trloss  + lna1_sat - elna) : 0 + lna1_sat - elna;
	clipped = high_sen_adjust - clipgain;

	return MIN(saturation, clipped);
}

/* Wrapper to call encode_gain & set init/clip gains */
static uint8
wlc_phy_rxgainctrl_set_init_clip_gain_acphy(phy_info_t *pi, uint8 clipgain, int8 gain_dB,
                                      bool trtx, bool lna1byp, uint8 core)
{
	uint8 gain_idx[ACPHY_MAX_RX_GAIN_STAGES];
	uint8 gain_applied;

	gain_applied = wlc_phy_rxgainctrl_encode_gain_acphy(pi, core, gain_dB, trtx, lna1byp,
		gain_idx);
	wlc_phy_set_analog_rxgain(pi, clipgain, gain_idx, trtx, core);

	return gain_applied;
}

static int8
wlc_phy_rxgainctrl_encode_gain_acphy(phy_info_t *pi, uint8 core, int8 gain_dB,
                                     bool trloss, bool lna1byp, uint8 *gidx)
{
	int16 min_gains[ACPHY_MAX_RX_GAIN_STAGES], max_gains[ACPHY_MAX_RX_GAIN_STAGES];
	int8 k, maxgain_this_stage;
	int16 sum_min_gains, gain_needed, tr;
	uint8 i, j;
	int8 *gaintbl_this_stage, gain_this_stage;
	int16 total_gain = 0;
	int16 gain_applied = 0;
	uint8 *gainbitstbl_this_stage;
	uint8 gaintbl_len, lowest_idx;
	int8 lna1bypgain = 0;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 rnd_stage = TINY_RADIO(pi) ? ACPHY_MAX_RX_GAIN_STAGES - 4
	                                 : ACPHY_MAX_RX_GAIN_STAGES - 3;

	PHY_TRACE(("%s: TARGET %d\n", __FUNCTION__, gain_dB));
	ASSERT(core < PHY_CORE_MAX);

	if (lna1byp) {
		lna1bypgain = READ_PHYREGFLDCCE(pi, _lna1BypVals, core, lna1BypGain);
		tr = 0;
	} else if (trloss) {
		tr = pi_ac->fem_rxgains[core].trloss;
	} else {
		tr = 0;
	}
	gain_needed = gain_dB + tr;

	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
		max_gains[i] = pi_ac->rxgainctrl_maxout_gains[i] + tr;

	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
		min_gains[i] = pi_ac->rxgainctrl_params[core].gaintbl[i][0];

	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++) {
		if (i == rnd_stage) {
			if ((gain_needed % 3) == 2)
				++gain_needed;
			if ((!TINY_RADIO(pi)) && (gain_needed > 30))
				gain_needed = 30;
		}
		sum_min_gains = 0;

		for (j = i + 1; j < ACPHY_MAX_RX_GAIN_STAGES; j++) {
			if (TINY_RADIO(pi) && i < 5 && j >= 5)
				break;

			sum_min_gains += min_gains[j];
		}

		maxgain_this_stage = gain_needed - sum_min_gains;
		gaintbl_this_stage = pi_ac->rxgainctrl_params[core].gaintbl[i];
		gainbitstbl_this_stage = pi_ac->rxgainctrl_params[core].gainbitstbl[i];
		gaintbl_len = pi_ac->rxgainctrl_stage_len[i];

		for (k = gaintbl_len - 1; k >= 0; k--) {
			gain_this_stage = (lna1byp && (i == 1)) ? lna1bypgain :
			                                          gaintbl_this_stage[k];
			total_gain = gain_this_stage + gain_applied;
			lowest_idx = 0;

			if (gainbitstbl_this_stage[k] == gainbitstbl_this_stage[0])
				lowest_idx = 1;
			if ((lowest_idx == 1) || (lna1byp && (i == 1)) ||
			    ((gain_this_stage <= maxgain_this_stage) && (total_gain
			                                                 <= max_gains[i]))) {
				gidx[i] = gainbitstbl_this_stage[k];
				gain_applied += gain_this_stage;
				gain_needed = gain_needed - gain_this_stage;
				break;
			}
		}
	}
	PHY_INFORM(("gain_applied = %d, tr = %d \n", gain_applied, tr));

	return (gain_applied - tr);
}

#define ACPHY_NUM_NB_THRESH 8
static void
wlc_phy_rxgainctrl_nbclip_acphy(phy_info_t *pi, uint8 core, int8 rxpwr_dBm)
{
	/* Multiply all pwrs by 10 to avoid floating point math */
	int rxpwrdBm_60mv, pwr;
	int pwr_60mv[] = {-40, -40, -40};     /* 20, 40, 80 */
	uint8 nb_thresh[] = {0, 35, 60, 80, 95, 120, 140, 156}; /* nb_thresh*10 to avoid float */
	const char *reg_name[ACPHY_NUM_NB_THRESH] = {"low", "low", "mid", "mid", "mid",
					       "mid", "high", "high"};
	uint8 mux_sel[] = {0, 0, 1, 1, 1, 1, 2, 2};
	uint8 reg_val[] = {1, 0, 1, 2, 0, 3, 1, 0};
	uint8 nb, i;
	int nb_thresh_bq[ACPHY_NUM_NB_THRESH];
	int v1, v2, vdiff1, vdiff2;
	uint8 idx[ACPHY_MAX_RX_GAIN_STAGES];
	uint16 initgain_codeA;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	ASSERT(core < PHY_CORE_MAX);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	rxpwrdBm_60mv = (CHSPEC_IS80(pi->radio_chanspec)) ? pwr_60mv[2] :
	        (CHSPEC_IS40(pi->radio_chanspec)) ? pwr_60mv[1] : pwr_60mv[0];

	for (i = 0; i < ACPHY_NUM_NB_THRESH; i++) {
		nb_thresh_bq[i] = rxpwrdBm_60mv + nb_thresh[i];
	}

	/* Get the INITgain code */
	initgain_codeA = READ_PHYREGC(pi, InitGainCodeA, core);

	idx[0] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initExtLnaIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initExtLnaIndex);
	idx[1] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initLnaIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initLnaIndex);
	idx[2] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initlna2Index)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initlna2Index);
	idx[3] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initmixergainIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initmixergainIndex);
	idx[4] = READ_PHYREGFLDC(pi, InitGainCodeB, core, InitBiQ0Index);
	idx[5] = READ_PHYREGFLDC(pi, InitGainCodeB, core, InitBiQ1Index);
	idx[6] = READ_PHYREGFLDC(pi, InitGainCodeB, core, initvgagainIndex);

	pwr = rxpwr_dBm;
	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES - 2; i++)
		pwr += pi_ac->rxgainctrl_params[core].gaintbl[i][idx[i]];
	if (pi_ac->curr_desense.elna_bypass == 1)
		pwr = pwr - pi_ac->fem_rxgains[core].trloss;
	pwr = pwr * 10;

	nb = 0;
	if (pwr < nb_thresh_bq[0]) {
		nb = 0;
	} else if (pwr > nb_thresh_bq[ACPHY_NUM_NB_THRESH - 1]) {
		nb = ACPHY_NUM_NB_THRESH - 1;

		/* Reduce the bq0 gain, if can't achieve nbclip with highest nbclip thresh */
		if ((pwr - nb_thresh_bq[ACPHY_NUM_NB_THRESH - 1]) > 20) {
			if ((idx[4] > 0) && (idx[5] < 7)) {
				MOD_PHYREGC(pi, InitGainCodeB, core, InitBiQ0Index, idx[4] - 1);
				MOD_PHYREGC(pi, InitGainCodeB, core, InitBiQ1Index, idx[5] + 1);
			}
		}
	} else {
		for (i = 0; i < ACPHY_NUM_NB_THRESH - 1; i++) {
			v1 = nb_thresh_bq[i];
			v2 = nb_thresh_bq[i + 1];
			if ((pwr >= v1) && (pwr <= v2)) {
				vdiff1 = pwr > v1 ? (pwr - v1) : (v1 - pwr);
				vdiff2 = pwr > v2 ? (pwr - v2) : (v2 - pwr);

				if (vdiff1 < vdiff2)
					nb = i;
				else
					nb = i+1;
				break;
			}
		}
	}

	MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcNbClipMuxSel, mux_sel[nb]);

	if (strcmp(reg_name[nb], "low") == 0) {
		MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_Refctrl_low, reg_val[nb]);
	} else if (strcmp(reg_name[nb], "mid") == 0) {
		MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_Refctrl_mid, reg_val[nb]);
	} else {
		MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_Refctrl_high, reg_val[nb]);
	}
}

#define ACPHY_NUM_NB_THRESH_TINY 9
static int16
wlc_phy_rxgainctrl_nbclip_acphy_tiny(phy_info_t *pi, uint8 core, int16 rxpwr_dBm)
{
	/* Multuply all pwrs by 10 to avoid floating point math */
	int16 rxpwrdBm_bw, pwr;
	int16 pwr_dBm[] = {-40, -40, -40};	/* 20, 40, 80 */
	int16 nb_thresh[] = { 0, 20, 40, 60, 80, 100, 120, 140, 160}; /* nb_thresh*10 avoid float */
	const char * const reg_name[ACPHY_NUM_NB_THRESH_TINY] = {"low", "low", "low", "mid", "mid",
	                                                    "high", "high", "high", "high"};
	uint8 mux_sel[] = {0, 0, 0, 1, 1, 2, 2, 2, 2};
	uint8 reg_val[] = {0, 2, 4, 2, 4, 1, 3, 5, 7};
	uint8 nb, i;
	int v1, v2, vdiff1, vdiff2;
	int8 idx[ACPHY_MAX_RX_GAIN_STAGES] = {-1, -1, -1, -1, -1, -1, -1};
	uint16 initgain_codeA;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool use_w3_detector = FALSE; /* To chhose betwen NB(T2) and W3(T1) detectors */
	int16 t2_delta_dB = 0; /* the power delta between T2 and T1 detectors */
	int16 nb_thresh_end;

	ASSERT(core < PHY_CORE_MAX);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	rxpwrdBm_bw = (CHSPEC_IS80(pi->radio_chanspec)) ? pwr_dBm[2] :
	              (CHSPEC_IS40(pi->radio_chanspec)) ? pwr_dBm[1] : pwr_dBm[0];

	PHY_TRACE(("%s: adc pwr %d \n", __FUNCTION__, rxpwrdBm_bw));

	nb_thresh_end = nb_thresh[ACPHY_NUM_NB_THRESH_TINY - 1] + rxpwrdBm_bw;

	/* Get the INITgain code */
	initgain_codeA = READ_PHYREGC(pi, InitGainCodeA, core);

	idx[0] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initExtLnaIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initExtLnaIndex);
	idx[1] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initLnaIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initLnaIndex);
	idx[3] = (initgain_codeA &
		ACPHY_REG_FIELD_MASK(pi, InitGainCodeA, core, initmixergainIndex)) >>
		ACPHY_REG_FIELD_SHIFT(pi, InitGainCodeA, core, initmixergainIndex);

	pwr = rxpwr_dBm;

	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES - 2; i++)
		if (idx[i] >= 0)
			pwr += pi_ac->rxgainctrl_params[core].gaintbl[i][idx[i]];

	if (pi_ac->curr_desense.elna_bypass == 1)
		pwr -= pi_ac->fem_rxgains[core].trloss;

	pwr *= 10;

	/* Use T1 detector bank if T2 bank is not covering pwr, and in 5G only (for the */
	/* time being). As it can be seen for T1 vs. T2 delta to be > 0 TIA index >4 is */
	/* needed, typically for the current 2G gain line up TIA index = 4 (BIQ 2 is off), */
	/* and T1 doesn't help. To make this work for 2G, it is needed to decresse LNA */
	/* index which can lower sensitivity. */
	if (pwr > nb_thresh_end) {
	  use_w3_detector = TRUE;

	  if (CHSPEC_IS80(pi->radio_chanspec)) {
	    if (idx[3] >= 8)
	      t2_delta_dB = 75;
	    else if (idx[3] >= 4)
	      t2_delta_dB = 60;
	    else
	      t2_delta_dB = 0;
	  } else if (CHSPEC_IS40(pi->radio_chanspec)) {
	    if (idx[3] >= 8)
	      t2_delta_dB = 75;
	    else if (idx[3] >= 5)
	      t2_delta_dB = 60;
	    else
	      t2_delta_dB = 0;
	  } else {
	    if (idx[3] >= 5)
	      t2_delta_dB = 60;
	    else
	      t2_delta_dB = 0;
	  }
	}

	use_w3_detector = use_w3_detector && (t2_delta_dB > 0);
	for (i = 0; i < ACPHY_NUM_NB_THRESH_TINY; i++) {
	  nb_thresh[i] += (rxpwrdBm_bw + t2_delta_dB);
	}

	if (pwr < nb_thresh[0]) {
		nb = 0;
	} else if (pwr > nb_thresh[ACPHY_NUM_NB_THRESH_TINY - 1]) {
		nb = ACPHY_NUM_NB_THRESH_TINY - 1;
	} else {
		nb = 0;
		for (i = 0; i < ACPHY_NUM_NB_THRESH_TINY - 1; i++) {
			v1 = nb_thresh[i];
			v2 = nb_thresh[i + 1];
			if ((pwr >= v1) && (pwr <= v2)) {
				vdiff1 = pwr > v1 ? (pwr - v1) : (v1 - pwr);
				vdiff2 = pwr > v2 ? (pwr - v2) : (v2 - pwr);

				nb = (vdiff1 < vdiff2) ? i : i + 1;
				break;
			}
		}
	}

	MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcNbClipMuxSel, mux_sel[nb]);
	if (use_w3_detector) {
	  MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcW3ClipMuxSel, 1);
	  if (strcmp(reg_name[nb], "low") == 0) {
	    MOD_RADIO_REG_20691(pi, TIA_CFG13, 0, wrssi3_ref_low_sel, reg_val[nb]);
	  } else if (strcmp(reg_name[nb], "mid") == 0) {
	    MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, wrssi3_ref_mid_sel, reg_val[nb]);
	  } else {
	    MOD_RADIO_REG_20691(pi, TIA_CFG12, 0, wrssi3_ref_high_sel, reg_val[nb]);
	  }
	} else {
	  MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcW3ClipMuxSel, 0);
	  if (strcmp(reg_name[nb], "low") == 0) {
	    MOD_RADIO_REG_20691(pi, TIA_CFG13, 0, nbrssi_ref_low_sel, reg_val[nb]);
	  } else if (strcmp(reg_name[nb], "mid") == 0) {
	    MOD_RADIO_REG_20691(pi, TIA_CFG13, 0, nbrssi_ref_mid_sel, reg_val[nb]);
	  } else {
	    MOD_RADIO_REG_20691(pi, TIA_CFG13, 0, nbrssi_ref_high_sel, reg_val[nb]);
	  }
	}
	return nb_thresh[nb];
}

#define ACPHY_NUM_W1_THRESH 12
static void
wlc_phy_rxgainctrl_w1clip_acphy(phy_info_t *pi, uint8 core, int8 rxpwr_dBm)
{
	/* Multiply all pwrs by 10 to avoid floating point math */

	int lna1_rxpwrdBm_lo4;
	int lna1_pwrs_w1clip[] = {-340, -340, -340};   /* 20, 40, 80 */
	uint8 *w1_hi, w1_delta[] = {0, 19, 35, 49, 60, 70, 80, 88, 95, 102, 109, 115};
	uint8 w1_delta_hi2g[] = {0, 19, 35, 49, 60, 70, 80, 92, 105, 120, 130, 140};
	uint8 w1_delta_hi5g[] = {0, 19, 35, 49, 60, 70, 80, 96, 113, 130, 155, 180};
	int w1_thresh_low[ACPHY_NUM_W1_THRESH], w1_thresh_mid[ACPHY_NUM_W1_THRESH];
	int w1_thresh_high[ACPHY_NUM_W1_THRESH];
	int *w1_thresh;
	uint8 i, w1_muxsel, w1;
	uint8 elna, lna1_idx;
	int v1, v2, vdiff1, vdiff2, pwr, lna1_diff;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	ASSERT(core < PHY_CORE_MAX);
	w1_hi = CHSPEC_IS2G(pi->radio_chanspec) ? &w1_delta_hi2g[0] : &w1_delta_hi5g[0];

	if (TINY_RADIO(pi)) {
	  if (CHSPEC_IS2G(pi->radio_chanspec))
	    lna1_rxpwrdBm_lo4 = -370;
	  else
	    lna1_rxpwrdBm_lo4 = -310;
	} else
	  lna1_rxpwrdBm_lo4 = (CHSPEC_IS80(pi->radio_chanspec)) ? lna1_pwrs_w1clip[2] :
	    (CHSPEC_IS40(pi->radio_chanspec)) ? lna1_pwrs_w1clip[1] : lna1_pwrs_w1clip[0];

	/* mid is 6dB higher than low, and high is 6dB higher than mid */
	for (i = 0; i < ACPHY_NUM_W1_THRESH; i++) {
		w1_thresh_low[i] = lna1_rxpwrdBm_lo4 + w1_delta[i];
		w1_thresh_mid[i] = 60 + w1_thresh_low[i];
		w1_thresh_high[i] = 120 + lna1_rxpwrdBm_lo4 + w1_hi[i];
	}

	elna = pi_ac->rxgainctrl_params[core].gaintbl[0][0];

	lna1_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initLnaIndex);

	if (TINY_RADIO(pi)) {
		lna1_diff = 24 - pi_ac->rxgainctrl_params[core].gaintbl[1][lna1_idx];
	} else if (CHSPEC_IS2G(pi->radio_chanspec) && ACMAJORREV_2(pi->pubpi.phy_rev) &&
	           (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev)) &&
	           PHY_XTAL_IS40M(pi)) {
		lna1_diff = 25 - pi_ac->rxgainctrl_params[core].gaintbl[1][lna1_idx];
	} else {
		lna1_diff = pi_ac->rxgainctrl_params[core].gaintbl[1][5] -
		            pi_ac->rxgainctrl_params[core].gaintbl[1][lna1_idx];
	}

	pwr = rxpwr_dBm + elna - lna1_diff;
	if (pi_ac->curr_desense.elna_bypass == 1)
		pwr = pwr - pi_ac->fem_rxgains[core].trloss;
	pwr = pwr * 10;

	if (pwr <= w1_thresh_low[0]) {
		w1 = 0;
		w1_muxsel = 0;
	} else if (pwr >= w1_thresh_high[ACPHY_NUM_W1_THRESH - 1]) {
		w1 = 11;
		w1_muxsel = 2;
	} else {
		if (pwr > w1_thresh_mid[ACPHY_NUM_W1_THRESH - 1]) {
			w1_thresh = w1_thresh_high;
			w1_muxsel = 2;
		} else if (pwr < w1_thresh_mid[0]) {
			w1_thresh = w1_thresh_low;
			w1_muxsel = 0;
		} else {
			w1_thresh = w1_thresh_mid;
			w1_muxsel = 1;
		}

		for (w1 = 0; w1 < ACPHY_NUM_W1_THRESH - 1; w1++) {
			v1 = w1_thresh[w1];
			v2 = w1_thresh[w1 + 1];
			if ((pwr >= v1) && (pwr <= v2)) {
				vdiff1 = pwr > v1 ? (pwr - v1) : (v1 - pwr);
				vdiff2 = pwr > v2 ? (pwr - v2) : (v2 - pwr);

				if (vdiff2 <= vdiff1)
					w1 = w1 + 1;

				break;
			}
		}
	}

	if (TINY_RADIO(pi)) {
		MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcW1ClipMuxSel, w1_muxsel);

		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REG_20691(pi, LNA2G_RSSI1, 0, lna2g_dig_wrssi1_threshold, w1+4);
		} else {
			MOD_RADIO_REG_20691(pi, LNA5G_RSSI1, 0, lna5g_dig_wrssi1_threshold, w1+4);
		}
	} else {
		/* the w1 thresh array is wrt w1 code = 4 */
		/*	MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcW1ClipCntTh, w1 + 4); */
		MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcW1ClipMuxSel, w1_muxsel);
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			MOD_RADIO_REGC(pi, LNA2G_RSSI, core, dig_wrssi1_threshold, w1 + 4);
		} else {
			MOD_RADIO_REGC(pi, LNA5G_RSSI, core, dig_wrssi1_threshold, w1 + 4);
		}
	}
}

static void
wlc_phy_rxgainctrl_w1clip_acphy_tiny(phy_info_t *pi, uint8 core, int8 rxpwr_dBm)
{
	/* Multuply all pwrs by 10 to avoid floating point math */
	int16 rxpwrdBm_bw, pwr;
	int16 pwr_dBm[] = {-90, -90, -90};     /* 20, 40, 80 */
	int16 w1_thresh[] = {0, 19, 35, 60, 80, 102, 120, 140, 163, 180, 200, 220};
	uint8 mux_sel[] =   {0,  0,  0,  0,  0,   0,   1,   1,   1,   2,   2,   2};
	uint8 reg_val[] =   {4,  5,  6,  8, 10,  13,   8,  10,  13,   8,  10,  13};
	uint8 w1, i;
	int v1, v2, vdiff1, vdiff2;
	int8 lna1_gain;
	uint8 elna, lna1_idx;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	ASSERT(core < PHY_CORE_MAX);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	rxpwrdBm_bw = (CHSPEC_IS80(pi->radio_chanspec)) ? pwr_dBm[2] :
	        (CHSPEC_IS40(pi->radio_chanspec)) ? pwr_dBm[1] : pwr_dBm[0];

	PHY_TRACE(("%s: inpwr %d\n", __FUNCTION__, rxpwr_dBm));
	for (i = 0; i < ACPHY_NUM_W1_THRESH; i++) {
		w1_thresh[i] += rxpwrdBm_bw;
	}

	/* Get the INITgain code */
	elna = pi_ac->rxgainctrl_params[core].gaintbl[0][0];

	lna1_idx = READ_PHYREGFLDC(pi, InitGainCodeA, core, initLnaIndex);
	lna1_gain = pi_ac->rxgainctrl_params[core].gaintbl[1][lna1_idx];
	pwr = rxpwr_dBm + elna + lna1_gain;

	if (pi_ac->curr_desense.elna_bypass == 1)
		pwr -= pi_ac->fem_rxgains[core].trloss;

	pwr *= 10;

	if (pwr < w1_thresh[0]) {
		w1 = 0;
	} else if (pwr > w1_thresh[ACPHY_NUM_W1_THRESH - 1]) {
		w1 = ACPHY_NUM_W1_THRESH - 1;
	} else {
		w1 = 0;
		for (i = 0; i < ACPHY_NUM_W1_THRESH - 1; i++) {
			v1 = w1_thresh[i];
			v2 = w1_thresh[i + 1];
			if ((pwr >= v1) && (pwr <= v2)) {
				vdiff1 = pwr > v1 ? (pwr - v1) : (v1 - pwr);
				vdiff2 = pwr > v2 ? (pwr - v2) : (v2 - pwr);

				w1 = (vdiff1 < vdiff2) ? i : i + 1;
				break;
			}
		}
	}

	MOD_PHYREGC(pi, RssiClipMuxSel, core, fastAgcW1ClipMuxSel, mux_sel[w1]);

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		MOD_RADIO_REG_20691(pi, LNA2G_RSSI1, 0, lna2g_dig_wrssi1_threshold, reg_val[w1]);
	} else {
		MOD_RADIO_REG_20691(pi, LNA5G_RSSI1, 0, lna5g_dig_wrssi1_threshold, reg_val[w1]);
	}
}

static uint8
wlc_phy_get_max_lna_index_acphy(phy_info_t *pi, uint8 lna)
{
	uint8 max_idx;
	acphy_desense_values_t *desense = NULL;
	uint8 elna_bypass, lna1_backoff, lna2_backoff;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	desense = &pi_ac->total_desense;
	elna_bypass = desense->elna_bypass;
	lna1_backoff = desense->lna1_tbl_desense;
	lna2_backoff = desense->lna2_tbl_desense;

	/* Find default max_idx */
	if (lna == 0) {
		max_idx = elna_bypass;       /* elna */
	} else if (lna == 1) {               /* lna1 */
		max_idx = MAX(0, ACPHY_MAX_LNA1_IDX  - lna1_backoff);
	} else {                             /* lna2 */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (desense->lna1_bypass) {
				/* For now, when LNA1 is in bypass, max out LNA2 */
				max_idx = ACPHY_ILNA2G_MAX_LNA2_IDX;	/* Full range */
			} else if (pi_ac->srom.elna2g_present && (elna_bypass == 0)) {
				uint8 core = 0;
				if (pi_ac->srom.femrx_2g[core].elna > 10) {
					max_idx = ACPHY_ELNA2G_MAX_LNA2_IDX;
				} else if (pi_ac->srom.femrx_2g[core].elna > 8) {
					max_idx = ACPHY_ELNA2G_MAX_LNA2_IDX_L;
				} else {
					max_idx = ACPHY_ILNA2G_MAX_LNA2_IDX;
				}
			} else {
				max_idx = ACPHY_ILNA2G_MAX_LNA2_IDX;
			}
		} else {
			max_idx = (pi_ac->srom.elna5g_present && (elna_bypass == 0)) ?
			        ACPHY_ELNA5G_MAX_LNA2_IDX : ACPHY_ILNA5G_MAX_LNA2_IDX;
		}
		max_idx = MAX(0, max_idx - lna2_backoff);
	}

	return max_idx;
}

static void
wlc_phy_upd_lna1_lna2_gains_acphy(phy_info_t *pi)
{
	uint8 i;
	bool lmt_pktgain_rout;

	for (i = 1; i <= 2; i++) {
		lmt_pktgain_rout = wlc_phy_upd_lna1_lna2_routs_acphy(pi, i);
		wlc_phy_upd_lna1_lna2_gainlimittbls_acphy(pi, i, lmt_pktgain_rout);
		wlc_phy_upd_lna1_lna2_gaintbls_acphy(pi, i);
	}
}

static void
wlc_phy_upd_lna1_lna2_gaintbls_acphy(phy_info_t *pi, uint8 lna12)
{
	uint8 offset, rout_offset, sz, core, i;
	uint8 gaintbl[10], gainbitstbl[10];
	uint8 max_idx, min_idx, *default_gaintbl = NULL;
	uint16 gain_tblid, gainbits_tblid;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->total_desense;
	uint8 lna_rout_tbl[] = {0, 1, 2, 3, 4, 5, 6};
	uint8 lna1, lna1_idx, lna1_rout, lna2, lna2_idx, lna2_rout;
	uint8 stall_val;

	ASSERT((lna12 == 1) || (lna12 == 2));
	sz = pi_ac->rxgainctrl_stage_len[lna12];

	if (lna12 == 1) {
		pi_ac->curr_desense.lna1_bypass = desense->lna1_bypass;
		pi_ac->curr_desense.lna1_tbl_desense = desense->lna1_tbl_desense;
	} else {
		pi_ac->curr_desense.lna2_tbl_desense = desense->lna2_tbl_desense;
	}

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (lna12 == 1) {          /* lna1 */

		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (desense->lna1_bypass) {

				/* Enable LNA1 bypass and LNA1 Rout using phytables */
				wlc_phy_lna1bypass_acphy(pi, 1);

				/* For some reason core 0 reads the LNA1 bypass gain from */
				/* lna1BypGain0 where core 1 does not do this. Anyhow, */
				/* correct the LNA1 bypass gain for both cores */
				if (desense->lna1_rout == 0) {
					default_gaintbl = ac_lna1_2g_43569_btdesense_rout_0;
					MOD_PHYREG(pi, Core0_lna1BypVals, lna1BypGain0, 9);
					MOD_PHYREG(pi, Core1_lna1BypVals, lna1BypGain1, 9);
				} else if (desense->lna1_rout == 4) {
					default_gaintbl = ac_lna1_2g_43569_btdesense_rout_4;
					MOD_PHYREG(pi, Core0_lna1BypVals, lna1BypGain0, 5);
					MOD_PHYREG(pi, Core1_lna1BypVals, lna1BypGain1, 5);
				} else {
					/* Currently only Rout1=4 Rout1=0 supported */
					ASSERT(0);
				}

				MOD_PHYREG(pi, Core0_lna1BypVals, lna1BypIndex0, 5);
				MOD_PHYREG(pi, Core1_lna1BypVals, lna1BypIndex1, 5);
			} else if (!TINY_RADIO(pi)) {
				/* Undo LNA1 bypass that could be set by the desense code */
				wlc_phy_lna1bypass_acphy(pi, 0);

				if (PHY_ILNA(pi)) { /* iLNA only chip */
					default_gaintbl = ac_lna1_2g_ilna;
				} else {
					if (pi->u.pi_acphy->srom.ltecoex_gaintbl_en == 1 &&
					    ACMAJORREV_1(pi->pubpi.phy_rev)) {
						default_gaintbl = ac_lna1_2g_ltecoex;
					} else {
						default_gaintbl = ac_lna1_2g;
					}
				}
			} else {
				/* Undo LNA1 bypass that could be set by the desense code */
				wlc_phy_lna1bypass_acphy(pi, 0);

				default_gaintbl = ac_lna1_2g_tiny;
			}

		} else { /* not CHSPEC_IS2G */

			/* Undo LNA1 bypass that could be set by the desense code */
			/* Note: Leaving this on for 5G gives strange effects */
			wlc_phy_lna1bypass_acphy(pi, 0);

			/* for 4354 use rout of 2 for better radio linearity and aci performance */
			/* lna1 gain dB is different for rout of 2 */
			default_gaintbl = (TINY_RADIO(pi)) ? ac_lna1_5g_tiny : ac_lna1_5g;
		}
	} else {  /* lna2 */
		if (TINY_RADIO(pi)) {
			if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACREV_GE(pi->pubpi.phy_rev, 11) &&
			    PHY_ILNA(pi)) {
				default_gaintbl = ac_lna2_tiny_ilna_dcc_comp;
			} else {
				default_gaintbl = ac_lna2_tiny;
			}
		} else if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (PHY_ILNA(pi)) { /* iLNA only chip */
				default_gaintbl = ac_lna2_2g_ilna;
			} else {
				if (pi_ac->srom.ltecoex_gaintbl_en == 1 &&
				    ACMAJORREV_1(pi->pubpi.phy_rev)) {
					default_gaintbl = ac_lna2_2g_ltecoex;
				} else {
					default_gaintbl = (desense->elna_bypass)
						? ac_lna2_2g_gm3 : ac_lna2_2g_gm2;
				}
			}
		} else {
			default_gaintbl = ac_lna2_5g;
		}
		memcpy(pi_ac->lna2_complete_gaintbl, default_gaintbl, sizeof(uint8)*sz);
	}

	FOREACH_CORE(pi, core) {
		/* JIRA(CRDOT11ACPHY-142) - Don't use idx = 0 of lna1/lna2 */
		min_idx = (pi->pubpi.phy_rev == 0) ? 1 : 0;
		max_idx = wlc_phy_get_max_lna_index_acphy(pi, lna12);

		if (pi_ac->btcx_hybrid_mode_simul_rx.on &&
		    core == pi_ac->btcx_hybrid_mode_simul_rx.shared_core) {
			if (lna12 == 1) {
				min_idx = pi_ac->btcx_hybrid_mode_simul_rx.shared_core_lna1_idx;
				max_idx = pi_ac->btcx_hybrid_mode_simul_rx.shared_core_lna1_idx;
			}
			if (lna12 == 2)
				max_idx = pi_ac->btcx_hybrid_mode_simul_rx.shared_core_lna2_max_idx;
		}
		wlc_phy_limit_rxgaintbl_acphy(gaintbl, gainbitstbl, sz, default_gaintbl,
		                              min_idx, max_idx);

		if (!TINY_RADIO(pi)) {
			/* Read lna_rout tables */
			rout_offset = (lna12 == 1) ? (core * 24) : (core * 24) + 16;
			if (CHSPEC_IS5G(pi->radio_chanspec)) rout_offset += 8;
			if ((lna12 == 1) || CHSPEC_IS2G(pi->radio_chanspec))
				wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT, sz,
				                         rout_offset, 8, lna_rout_tbl);

			if (lna12 == 1) { /* lna1 */

				if (pi_ac->fem_rxgains[core].lna1byp) {
					/* Additional settings to use LNA1 bypass instead of T/R */
					wlc_phy_upd_lna1_bypass_acphy(pi, core, rout_offset);
				}
				for (i = 0; i < sz; i++) {
					lna1 = lna_rout_tbl[gainbitstbl[i]];
					lna1_idx = lna1 & 0x7;
					lna1_rout = (lna1 >> 3) & 0xf;
					if (desense->lna1_bypass) {
						gaintbl[i] = default_gaintbl[lna1_idx];
					} else {
						gaintbl[i] = CHSPEC_IS2G(pi->radio_chanspec) ?
						        default_gaintbl[lna1_idx] -
						        ac_lna1_rout_delta_2g[lna1_rout]:
						        default_gaintbl[lna1_idx] -
						        ac_lna1_rout_delta_5g[lna1_rout];
					}
				}
			} else { /* Only 2G has LNA2 rout */
				for (i = 0; i < sz; i++) {
					lna2 = lna_rout_tbl[gainbitstbl[i]];
					lna2_idx = lna2 & 0x7;
					lna2_rout = (lna2 >> 3) & 0xf;
					gaintbl[i] = CHSPEC_IS2G(pi->radio_chanspec) ?
					        default_gaintbl[lna2_idx] -
					        ac_lna2_rout_delta_2g[lna2_rout]:
					        default_gaintbl[lna2_idx];
				}
			}

			memcpy(pi_ac->lna2_complete_gaintbl, gaintbl, sizeof(uint8)*sz);
		}

		/* Update gaintbls */
		offset = (lna12 == 1) ? 8 : 16;
		gain_tblid = (core == 0) ? ACPHY_TBL_ID_GAIN0 :
		        ((core == 1) ? ACPHY_TBL_ID_GAIN1 : ACPHY_TBL_ID_GAIN2);
		gainbits_tblid = (core == 0) ? ACPHY_TBL_ID_GAINBITS0 :
		        ((core == 1) ? ACPHY_TBL_ID_GAINBITS1 : ACPHY_TBL_ID_GAINBITS2);

		memcpy(pi_ac->rxgainctrl_params[core].gaintbl[lna12], gaintbl, sizeof(uint8)*sz);
		wlc_phy_table_write_acphy(pi, gain_tblid, sz, offset, 8, gaintbl);
		memcpy(pi_ac->rxgainctrl_params[core].gainbitstbl[lna12], gainbitstbl,
		       sizeof(uint8)*sz);
		wlc_phy_table_write_acphy(pi, gainbits_tblid, sz, offset, 8, gainbitstbl);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

/* Additional settings to use LNA1 bypass instead of T/R */
/* See also the CRDOT11ACPHY-1161 WAR in wlc_phy_init_acphy */
static void
wlc_phy_upd_lna1_bypass_acphy(phy_info_t *pi, uint8 core, uint8 rout_offset)
{
	const uint8 rout_2g = 10;
	const int8  gain_2g = -3;
	const uint8 rout_5g = 4;
	const int8  gain_5g = -12;
	const uint8 idx = 6;	/* Rout table index to be used when in bypass */
	uint8 rout;
	int8 gain;
	uint16 byp_val;
	uint8 rout_val;

	/* Make sure the AGC knows the gain when LNA1 is in bypass */
	gain = CHSPEC_IS2G(pi->radio_chanspec) ? gain_2g: gain_5g;
	byp_val = gain << ACPHY_Core0_lna1BypVals_lna1BypGain0_SHIFT(pi->pubpi.phy_rev);

	/* Gain/Rout table index to be used when in bypass */
	byp_val |= idx << ACPHY_Core0_lna1BypVals_lna1BypIndex0_SHIFT(pi->pubpi.phy_rev);

	/* Have the AGC use the gain set in lna1BypGain */
	byp_val |= 1 << ACPHY_Core0_lna1BypVals_lna1BypEn0_SHIFT(pi->pubpi.phy_rev);

	WRITE_PHYREGC(pi, _lna1BypVals, core, byp_val);

	/* Set the Rout to be used for index 6 */
	rout = CHSPEC_IS2G(pi->radio_chanspec) ? rout_2g: rout_5g;
	rout_val = (rout << 3) + idx;
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT, 1, rout_offset + idx, 8, &rout_val);

	/* Power down LNA1 when bypassed */
	MOD_PHYREG(pi, AfePuCtrl, lna1_pd_during_byp, 1);

	/* Only for chips with a dedicated BT-LNA, no shared LNA */
	ASSERT(READ_PHYREGFLD(pi, SlnaControl, SlnaEn) == 0);

	/* WAR for LNA1 bypass sticky on Core 0, CRDOT11ACPHY-1161 */
	MOD_PHYREG(pi, SlnaControl, SlnaCore, 3);
}

static void
wlc_phy_upd_lna1_lna2_gainlimittbls_acphy(phy_info_t *pi, uint8 lna12, bool lmt_pktgain_rout)
{
	uint8 i, max_idx;
	uint8 lna1_tbl[] = {11, 12, 14, 32, 36, 40};
	uint8 lna2_tbl[] = {0, 0, 0, 3, 3, 3, 3};
	uint8 tiny_lna2_tbl[] = {127, 127};
	uint8 tiny_tia_tbl[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 127};
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->total_desense;
	uint8 stall_val;
	uint8 sz = pi_ac->rxgainctrl_stage_len[lna12];

	if (lna12 == 1) {
		pi_ac->curr_desense.lna1_gainlmt_desense = desense->lna1_gainlmt_desense;
	} else {
		pi_ac->curr_desense.lna2_gainlmt_desense = desense->lna2_gainlmt_desense;
	}

	/* if we are using pktgain Rout limitation, i.e. INITgain & pktgain routs are different
	   then don't use highest index of lnaRout
	*/
	if (lmt_pktgain_rout) {
		if (lna12 == 1) lna1_tbl[sz - 1] = 0x7f;
		else if (lna12 == 2) lna2_tbl[sz - 1] = 0x7f;
	}

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (CHSPEC_IS2G(pi->radio_chanspec) && desense->lna1_bypass) {
		if (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_XTAL_IS40M(pi) &&
		    (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev))) {
			/* Zero out the LNA1 and LNA2 gain limit table */
			/* TODO MVe: Is this really needed? */
			uint8 zero_tbl[] = {0, 0, 0, 0, 0, 0, 0};
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 6,  8, 8, zero_tbl);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 7, 16, 8, zero_tbl);
		}
	} else if (!TINY_RADIO(pi)) {
		/* Limit based on desense mitigation mode */
		if (lna12 == 1) {
			max_idx = MAX(0, (sz - 1) - desense->lna1_gainlmt_desense);
		} else {
			max_idx = MAX(0, (sz - 1) - desense->lna2_gainlmt_desense);
		}

		/* Write 0x7f to entries not to be used */
		for (i = (max_idx + 1); i < sz; i++) {
			if (lna12 == 1) {
				lna1_tbl[i] = 0x7f;
			} else {
				lna2_tbl[i] = 0x7f;
			}
		}

		if (lna12 == 1) {
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT0, sz,
					8, 8,  lna1_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT1, sz,
					8, 8,  lna1_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT2, sz,
					8, 8,  lna1_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT0, sz,
					72, 8,  lna1_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT1, sz,
					72, 8,  lna1_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT2, sz,
					72, 8,  lna1_tbl);
			} else
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, sz,
					8, 8, lna1_tbl);

			/* 4335C0: This is for DSSS_CCK packet gain limit */
			if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
				(ACMAJORREV_0(pi->pubpi.phy_rev)))
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, sz, 72, 8,
				                          lna1_tbl);
		}
		else {
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT0, sz,
					16, 8, lna2_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT1, sz,
					16, 8, lna2_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT2, sz,
					16, 8, lna2_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT0, sz,
					80, 8, lna2_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT1, sz,
					80, 8, lna2_tbl);
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT2, sz,
					80, 8, lna2_tbl);
			} else
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, sz,
					16, 8, lna2_tbl);

			/* 4335C0: This is for DSSS_CCK packet gain limit */
			if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
				(ACMAJORREV_0(pi->pubpi.phy_rev)))
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, sz,
					80, 8, lna2_tbl);
		}
	} else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 2, 16,     8, tiny_lna2_tbl);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 2, 16+64,  8, tiny_lna2_tbl);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 12, 32,    8, tiny_tia_tbl);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_GAINLIMIT, 12, 32+64, 8, tiny_tia_tbl);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_limit_rxgaintbl_acphy(uint8 gaintbl[], uint8 gainbitstbl[], uint8 sz,
                              uint8 default_gaintbl[], uint8 min_idx, uint8 max_idx)
{
	uint8 i;

	for (i = 0; i < sz; i++) {
		if (i < min_idx) {
			gaintbl[i] = default_gaintbl[min_idx];
			gainbitstbl[i] = min_idx;
		} else if (i > max_idx) {
			gaintbl[i] = default_gaintbl[max_idx];
			gainbitstbl[i] = max_idx;
		} else {
			gaintbl[i] = default_gaintbl[i];
			gainbitstbl[i] = i;
		}
	}
}

static bool
wlc_phy_upd_lna1_lna2_routs_acphy(phy_info_t *pi, uint8 lna12)
{
	uint8 sz, core, i, offset;
	uint8 lna1Rout = 0x25, lna2Rout = 0x44;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 band = CHSPEC_IS2G(pi->radio_chanspec) ? 2 : 5;
	acphy_desense_values_t *desense = &pi_ac->total_desense;
	uint8 rout, rout_gainlmt;
	uint8 min_lna_rout_2g, max_lna_rout_5g;   /* For max gains */
	uint8 lna_rout_tbl[7];
	uint8 stall_val;
	bool lmt_pktgain_rout = FALSE;

	ASSERT((lna12 == 1) || (lna12 == 2));
	if (ACREV_IS(pi->pubpi.phy_rev, 0)) return lmt_pktgain_rout;
	if (lna12 == 2) {
		if (TINY_RADIO(pi)) return lmt_pktgain_rout; /* TINY has no lna2 */
		else if (band == 5) return lmt_pktgain_rout; /* no rout for lna2 in 5g (non-tiny) */
	}

	if (lna12 == 1) {
		pi_ac->curr_desense.lna1rout_gainlmt_desense = desense->lna1rout_gainlmt_desense;
		pi_ac->curr_desense.lna1_rout = desense->lna1_rout;
	} else {
		pi_ac->curr_desense.lna2rout_gainlmt_desense = desense->lna2rout_gainlmt_desense;
		pi_ac->curr_desense.lna2_rout = desense->lna2_rout;
	}

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (TINY_RADIO(pi)) {
		uint8 x;
		uint8 lnarout_val;

		/* 2G index is 0->5 */
		for (x = 0; x < 6; x++) {
			lnarout_val = (ac_tiny_g_lna_rout_map[x] << 3) |
			        ac_tiny_g_lna_gain_map[x];
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT,
			                          1, x, 8, &lnarout_val);
		}

		/* 5G index is 8->13 */
		for (x = 0; x < 6; x++) {
			lnarout_val = (ac_tiny_a_lna_rout_map[x] << 3) |
			        ac_tiny_a_lna_gain_map[x];
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT,
			                          1, 8 + x, 8, &lnarout_val);
		}
	} else {
		if (pi->u.pi_acphy->srom.ltecoex_gaintbl_en == 1 &&
		    ACMAJORREV_1(pi->pubpi.phy_rev)) {
			/* for now changing rout of lna1 and lna2 to achieve */
			/* lower gain of 3dB for the init gain index only */
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT, 1, 5, 8, &lna1Rout);
			MOD_RADIO_REG(pi, RFX, OVR6, ovr_lna2g_lna1_Rout, 0);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT, 1, 20, 8, &lna2Rout);
			MOD_RADIO_REG(pi, RFX, OVR6, ovr_lna2g_lna2_Rout, 0);
		} else {
			sz = pi_ac->rxgainctrl_stage_len[lna12];
			min_lna_rout_2g = 0;
			if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev) &&
			    (pi->u.pi_acphy->srom.phy4350_ss_opt) && (lna12 == 1))
				max_lna_rout_5g = 2;
			else
				max_lna_rout_5g = 4;

			if (lna12 == 1) {
				rout = (band == 2) ?
				        MIN(11, min_lna_rout_2g + desense->lna1_rout) :
				        MAX(0, max_lna_rout_5g - desense->lna1_rout);
				rout_gainlmt = (band == 2) ?
				        MIN(11, 0 + desense->lna1rout_gainlmt_desense) :
				        MAX(0, 4 - desense->lna1rout_gainlmt_desense);
			} else {
				rout = (band == 2) ?
				        MIN(11, min_lna_rout_2g + desense->lna2_rout) :
				        MAX(0, max_lna_rout_5g - desense->lna2_rout);
				rout_gainlmt = (band == 2) ?
				        MIN(11, 0 + desense->lna2rout_gainlmt_desense) :
				        MAX(0, 4 - desense->lna2rout_gainlmt_desense);
			}

			for (i = 0; i < sz; i++)
				lna_rout_tbl[i] = (rout << 3) | i;

			/* pktgain only, 2g/5g have different direction of rout for maxgain */
			if (((band == 2) && (rout_gainlmt > rout)) ||
			    ((band == 5) && (rout_gainlmt < rout))) {
				lmt_pktgain_rout = TRUE;
				for (i = 0; i < sz - 1; i++)
					lna_rout_tbl[i] = (rout_gainlmt << 3) | (i + 1);
			}

			FOREACH_CORE(pi, core) {
				offset = (lna12 == 1) ? (core * 24) : (core * 24) + 16;
				if (band == 5) offset += 8;
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_LNAROUT, sz,
				                          offset, 8, lna_rout_tbl);
			}
		}
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
	return lmt_pktgain_rout;
}

/* XXX Tx-Core Shut-Down to prevent hitting critical junction temperature
 * Assumptions: Code written assuming max txchain = 7 (3 Tx Chain)
 * Output is stored in pi->txcore_temp.bitmap.
 * BitMap returns the active RxChain and TxChain.
 */
void
wlc_phy_stf_chain_temp_throttle_acphy(phy_info_t *pi)
{
	/* XXX Shut-Down All Tx-Core Except One When Hot
	 * When there is only 1 tx-core on, there will be no change
	 */
	uint8 txcore_shutdown_lut[] = {1, 1, 2, 1, 4, 1, 2, 1};
	uint8 phyrxchain = pi->sh->phyrxchain;
	uint8 phytxchain = pi->sh->phytxchain;
	uint8 new_phytxchain;
	int16 currtemp;

	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		return;

	ASSERT(phytxchain);

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	currtemp = wlc_phy_tempsense_acphy(pi);
	wlapi_enable_mac(pi->sh->physhim);
#if defined(BCMDBG) || defined(WLTEST)
	if (pi->tempsense_override)
		currtemp = pi->tempsense_override;
#endif // endif
	if (!pi->txcore_temp.heatedup) {
		if (currtemp >= pi->txcore_temp.disable_temp) {
			new_phytxchain = txcore_shutdown_lut[phytxchain];
			pi->txcore_temp.heatedup = TRUE;
			pi->txcore_temp.bitmap = ((phyrxchain << 4) | new_phytxchain);
		}
	} else {
		if (currtemp <= pi->txcore_temp.enable_temp) {
			new_phytxchain = pi->sh->hw_phytxchain;
			pi->txcore_temp.heatedup = FALSE;
			pi->txcore_temp.bitmap = ((phyrxchain << 4) | new_phytxchain);
		}
	}
}

void wlc_phy_rfctrl_override_rxgain_acphy(phy_info_t *pi, uint8 restore,
                                           rxgain_t rxgain[], rxgain_ovrd_t rxgain_ovrd[])
{
	uint8 core;

	if (restore == 1) {
		/* restore the stored values */
		FOREACH_CORE(pi, core) {
			WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, rxgain_ovrd[core].rfctrlovrd);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core, rxgain_ovrd[core].rxgain);
			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core, rxgain_ovrd[core].rxgain2);
			WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, rxgain_ovrd[core].lpfgain);
			PHY_INFORM(("%s, Restoring RfctrlOverride(rxgain) values\n", __FUNCTION__));
		}
	} else {
		uint8 lna1_Rout, lna2_Rout;
		uint16 reg_rxgain, reg_rxgain2, reg_lpfgain;
		uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		uint8 lna1_gm;
		uint8 offset;
		bool suspend;

		suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
		if (!suspend) {
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			wlc_phyreg_enter((wlc_phy_t *)pi);
		}
		if (stall_val == 0)
			ACPHY_DISABLE_STALL(pi);

		FOREACH_CORE(pi, core) {
			/* Save the original values */
			rxgain_ovrd[core].rfctrlovrd = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
			rxgain_ovrd[core].rxgain = READ_PHYREGCE(pi, RfctrlCoreRXGAIN1, core);
			rxgain_ovrd[core].rxgain2 = READ_PHYREGCE(pi, RfctrlCoreRXGAIN2, core);
			rxgain_ovrd[core].lpfgain = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);

			if (CHSPEC_IS2G(pi->radio_chanspec)) {
				offset = TINY_RADIO(pi) ? rxgain[core].lna1 : 5;
			} else {
				offset = TINY_RADIO(pi) ? (8 + rxgain[core].lna1) : 13;
			}

			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT,
			                         1, offset + (24 * core), 8, &lna1_Rout);
			wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT,
			                         1, 22 + (24 * core), 8, &lna2_Rout);

			/* Write the rxgain override registers */
			lna1_gm = TINY_RADIO(pi) ? (lna1_Rout & 0x7) : rxgain[core].lna1;

			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN1, core,
			              (rxgain[core].dvga << 10) | (rxgain[core].mix << 6) |
			              (rxgain[core].lna2 << 3) | lna1_gm);

			WRITE_PHYREGCE(pi, RfctrlCoreRXGAIN2, core,
			              (((lna2_Rout >> 3) & 0xf) << 4 | ((lna1_Rout >> 3) & 0xf)));
			WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core,
			              (rxgain[core].lpf1 << 3) | rxgain[core].lpf0);

			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, rxgain, 1);
			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq1_gain, 1);
			MOD_PHYREGCE(pi, RfctrlOverrideGains, core, lpf_bq2_gain, 1);

			reg_rxgain = READ_PHYREGCE(pi, RfctrlCoreRXGAIN1, core);
			reg_rxgain2 = READ_PHYREGCE(pi, RfctrlCoreRXGAIN2, core);
			reg_lpfgain = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
			PHY_INFORM(("%s, core %d. rxgain_ovrd = 0x%x, lpf_ovrd = 0x%x\n",
			            __FUNCTION__, core, reg_rxgain, reg_lpfgain));
			PHY_INFORM(("%s, core %d. rxgain_rout_ovrd = 0x%x\n",
			            __FUNCTION__, core, reg_rxgain2));
			BCM_REFERENCE(reg_rxgain);
			BCM_REFERENCE(reg_rxgain2);
			BCM_REFERENCE(reg_lpfgain);
		}
		ACPHY_ENABLE_STALL(pi, stall_val);
		if (!suspend) {
			wlc_phyreg_exit((wlc_phy_t *)pi);
			wlapi_enable_mac(pi->sh->physhim);
		}
	}
}

/* Override/Restore routine for Rx Digital LPF:
 * 1) Override: Save digital LPF config and set new LPF configuration
 * 2) Restore: Restore digital LPF config
 */
void
wlc_phy_dig_lpf_override_acphy(phy_info_t *pi, uint8 dig_lpf_ht)
{
	if ((dig_lpf_ht > 0) && !pi->phy_rx_diglpf_default_coeffs_valid) {
		pi->phy_rx_diglpf_default_coeffs[0] = READ_PHYREG(pi, RxStrnFilt40Num00);
		pi->phy_rx_diglpf_default_coeffs[1] = READ_PHYREG(pi, RxStrnFilt40Num01);
		pi->phy_rx_diglpf_default_coeffs[2] = READ_PHYREG(pi, RxStrnFilt40Num02);
		pi->phy_rx_diglpf_default_coeffs[3] = READ_PHYREG(pi, RxStrnFilt40Den00);
		pi->phy_rx_diglpf_default_coeffs[4] = READ_PHYREG(pi, RxStrnFilt40Den01);
		pi->phy_rx_diglpf_default_coeffs[5] = READ_PHYREG(pi, RxStrnFilt40Num10);
		pi->phy_rx_diglpf_default_coeffs[6] = READ_PHYREG(pi, RxStrnFilt40Num11);
		pi->phy_rx_diglpf_default_coeffs[7] = READ_PHYREG(pi, RxStrnFilt40Num12);
		pi->phy_rx_diglpf_default_coeffs[8] = READ_PHYREG(pi, RxStrnFilt40Den10);
		pi->phy_rx_diglpf_default_coeffs[9] = READ_PHYREG(pi, RxStrnFilt40Den11);
		pi->phy_rx_diglpf_default_coeffs_valid = TRUE;

	}

	switch (dig_lpf_ht) {
	case 0:  /* restore rx dig lpf */

		/* ASSERT(pi->phy_rx_diglpf_default_coeffs_valid); */
		if (!pi->phy_rx_diglpf_default_coeffs_valid) {
			break;
		}
		WRITE_PHYREG(pi, RxStrnFilt40Num00, pi->phy_rx_diglpf_default_coeffs[0]);
		WRITE_PHYREG(pi, RxStrnFilt40Num01, pi->phy_rx_diglpf_default_coeffs[1]);
		WRITE_PHYREG(pi, RxStrnFilt40Num02, pi->phy_rx_diglpf_default_coeffs[2]);
		WRITE_PHYREG(pi, RxStrnFilt40Den00, pi->phy_rx_diglpf_default_coeffs[3]);
		WRITE_PHYREG(pi, RxStrnFilt40Den01, pi->phy_rx_diglpf_default_coeffs[4]);
		WRITE_PHYREG(pi, RxStrnFilt40Num10, pi->phy_rx_diglpf_default_coeffs[5]);
		WRITE_PHYREG(pi, RxStrnFilt40Num11, pi->phy_rx_diglpf_default_coeffs[6]);
		WRITE_PHYREG(pi, RxStrnFilt40Num12, pi->phy_rx_diglpf_default_coeffs[7]);
		WRITE_PHYREG(pi, RxStrnFilt40Den10, pi->phy_rx_diglpf_default_coeffs[8]);
		WRITE_PHYREG(pi, RxStrnFilt40Den11, pi->phy_rx_diglpf_default_coeffs[9]);

		pi->phy_rx_diglpf_default_coeffs_valid = FALSE;
		break;
	case 1:  /* set rx dig lpf to ltrn-lpf mode */

		WRITE_PHYREG(pi, RxStrnFilt40Num00, READ_PHYREG(pi, RxFilt40Num00));
		WRITE_PHYREG(pi, RxStrnFilt40Num01, READ_PHYREG(pi, RxFilt40Num01));
		WRITE_PHYREG(pi, RxStrnFilt40Num02, READ_PHYREG(pi, RxFilt40Num02));
		WRITE_PHYREG(pi, RxStrnFilt40Num10, READ_PHYREG(pi, RxFilt40Num10));
		WRITE_PHYREG(pi, RxStrnFilt40Num11, READ_PHYREG(pi, RxFilt40Num11));
		WRITE_PHYREG(pi, RxStrnFilt40Num12, READ_PHYREG(pi, RxFilt40Num12));
		WRITE_PHYREG(pi, RxStrnFilt40Den00, READ_PHYREG(pi, RxFilt40Den00));
		WRITE_PHYREG(pi, RxStrnFilt40Den01, READ_PHYREG(pi, RxFilt40Den01));
		WRITE_PHYREG(pi, RxStrnFilt40Den10, READ_PHYREG(pi, RxFilt40Den10));
		WRITE_PHYREG(pi, RxStrnFilt40Den11, READ_PHYREG(pi, RxFilt40Den11));

		break;
	case 2:  /* bypass rx dig lpf */
		/* 0x2d4 = sqrt(2) * 512 */
		ACPHY_REG_LIST_START
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num00, 0x2d4)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num01, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num02, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Den00, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Den01, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num10, 0x2d4)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num11, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Num12, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Den10, 0)
			WRITE_PHYREG_ENTRY(pi, RxStrnFilt40Den11, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
		break;

	default:
		ASSERT((dig_lpf_ht == 2) || (dig_lpf_ht == 1) || (dig_lpf_ht == 0));
		break;
	}
}

/* Setup/Cleanup routine for high-pass corner (HPC) of LPF:
 * 1) Setup: Save LPF config and set HPC to lowest value (0x1)
 * 2) Cleanup: Restore HPC config
 */
void wlc_phy_lpf_hpc_override_acphy(phy_info_t *pi, bool setup_not_cleanup)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_lpfCT_phyregs_t *porig = &(pi_ac->ac_lpfCT_phyregs_orig);
	uint8 core;
	uint16 tmp_tia_hpc, tmp_lpf_dc_bw;
	uint16 val_tia_hpc, val_lpf_dc_bw;
	uint8 stall_val;

	if (setup_not_cleanup) {
		/* XXX
		 *-------------
		 * Phy "Setup"
		 *-------------
		 */

		ASSERT(!porig->is_orig);
		porig->is_orig = TRUE;
		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		ACPHY_DISABLE_STALL(pi);

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x122, 16, &tmp_tia_hpc);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, 0x125, 16, &tmp_lpf_dc_bw);

		ACPHY_ENABLE_STALL(pi, stall_val);

		FOREACH_CORE(pi, core) {
			porig->RfctrlOverrideLpfCT[core] =
				READ_PHYREGCE(pi, RfctrlOverrideLpfCT, core);
			porig->RfctrlCoreLpfCT[core] = READ_PHYREGCE(pi, RfctrlCoreLpfCT, core);

			val_tia_hpc = (tmp_tia_hpc >> (core * 4)) & 0xf;
			val_lpf_dc_bw = (tmp_lpf_dc_bw >> (core * 4)) & 0xf;

			MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, tia_HPC,  1);
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT,     core, tia_HPC, val_tia_hpc);

			MOD_PHYREGCE(pi, RfctrlOverrideLpfCT, core, lpf_dc_bw, 1);
			MOD_PHYREGCE(pi, RfctrlCoreLpfCT,     core, lpf_dc_bw, val_lpf_dc_bw);
		}
	} else {
		/* XXX
		 *-------------
		 * Phy "Cleanup"
		 *-------------
		 */

		ASSERT(porig->is_orig);
		porig->is_orig = FALSE;

		FOREACH_CORE(pi, core) {
			WRITE_PHYREGCE(pi, RfctrlOverrideLpfCT, core,
				porig->RfctrlOverrideLpfCT[core]);
			WRITE_PHYREGCE(pi, RfctrlCoreLpfCT, core, porig->RfctrlCoreLpfCT[core]);
		}
	}
}

static void
wlc_phy_bt_on_gpio4_acphy(phy_info_t *pi)
{
	uint16 mask = 0x10;    /* gpio 4 = 0 */

	/* Force gpio4 to be 0 */
	si_gpioout(pi->sh->sih, (1 << 4), (0 << 4), GPIO_DRV_PRIORITY);
	si_gpioouten(pi->sh->sih, (1 << 4), (1 << 4), GPIO_DRV_PRIORITY);

	/* Take away gpio4 contorl from phy */
	si_gpiocontrol(pi->sh->sih, mask, 0, GPIO_DRV_PRIORITY);
}

static void
wlc_phy_compute_rssi_gainerror_acphy(phy_info_t *pi)
{
	/* XXX
	 * Gain error computed as follows:
	 * 1) Backoff subband dependent init_gain from gaintable,
	 * 2) add back fixed init-gain assumed by rxiqest,
	 * 3) add subband-dependent rxiqest gain error (retrieved from srom)
	 */
	int16 gainerr[PHY_CORE_MAX], tmp;
	int16 initgain_dB[PHY_CORE_MAX];
	int16 rxiqest_gain;
	uint8 core;
	bool srom_isempty = FALSE;
	uint8 dummy[ACPHY_MAX_RX_GAIN_STAGES];
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/* Retrieve rxiqest gain error: */
	srom_isempty = wlc_phy_get_rxgainerr_phy(pi, gainerr);

	if (srom_isempty) {
		/* XXX
		 * Do not apply gain error correction
		 * if nothing was written to SROM
		 */
		FOREACH_CORE(pi, core) {
			pi->phy_rssi_gain_error[core] = 0;
		}
		return;
	}

	/* Retrieve rxiqest gain: */
	/* XXX
	 * Must sync with rxiqest if gain assumed changes there
	 */
	if (pi_ac->srom.femctrl == 2) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			rxiqest_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_2G);
		} else {
			rxiqest_gain = (int16)(ACPHY_NOISE_INITGAIN_X29_5G);
		}
	} else {
		rxiqest_gain = (int16)(ACPHY_NOISE_INITGAIN);
	}

	/* Compute correction */
	FOREACH_CORE(pi, core) {
		/* Retrieve initgains in dB */
		initgain_dB[core] = wlc_phy_rxgainctrl_encode_gain_acphy(pi, core, ACPHY_INIT_GAIN,
		                                                         FALSE, FALSE, dummy) - 2;

		/* gainerr is in 0.5dB steps; round to nearest dB */
		tmp = gainerr[core];
		tmp = ((tmp >= 0) ? ((tmp + 1) >> 1) : -1*((-1*tmp + 1) >> 1));
		/* report rssi gainerr in 0.5dB steps */
		pi->phy_rssi_gain_error[core] =
			(int8)((rxiqest_gain << 1) - (initgain_dB[core] << 1) + gainerr[core]);
	}
}

void wlc_phy_get_rxgain_acphy(phy_info_t *pi, rxgain_t rxgain[], int16 *tot_gain,
                              uint8 force_gain_type)
{
	uint8  core, bw_idx, i;
	uint16 code_A, code_B, gain_tblid, stall_val;
	int8   gain_dvga, gain_bq0, gain_bq1, gain_lna1, gain_lna2, gain_mix, tr_loss;
	int8   elna_gain[PHY_CORE_MAX];
	bool   elna_present, chan_found;
	int8   subband_idx;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	bzero(elna_gain, sizeof(elna_gain));

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		elna_present = pi_ac->srom.elna2g_present;
		bw_idx = (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
	} else {
		elna_present = pi_ac->srom.elna5g_present;
		bw_idx = (CHSPEC_IS80(pi->radio_chanspec)) ? 2 :
		        (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;
	}

	FOREACH_CORE(pi, core) {

		if (force_gain_type == 4) {
			code_A  =  READ_PHYREGC(pi, cliploGainCodeA, core);
			code_B   = READ_PHYREGC(pi, cliploGainCodeB, core);
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 1);
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
		} else if (force_gain_type == 3) {
			code_A  =  READ_PHYREGC(pi, clipmdGainCodeA, core);
			code_B   = READ_PHYREGC(pi, clipmdGainCodeB, core);
			if (pi_ac->mdgain_trtx_allowed) {
				MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 1);
				MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
				MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);
			}
		} else if (force_gain_type == 2) {
			code_A  =  READ_PHYREGC(pi, clipHiGainCodeA, core);
			code_B   = READ_PHYREGC(pi, clipHiGainCodeB, core);
		} else if ((force_gain_type == 1) || (force_gain_type == 11)) {
			/* Change limited to 4350, Olympic program
			 * When we issue iqest with -i 1 option, INIT gain is applied.
			 * But because of Interference_code, the INIT gain can change
			 * So, for 4350, we have forced the fixed init gain by hardcoding it.
			 */
			if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
				code_A	=  pi_ac->initGain_codeA;
				code_B	 = pi_ac->initGain_codeB;
			} else {
				code_A  =  READ_PHYREGC(pi, InitGainCodeA, core);
				code_B   = READ_PHYREGC(pi, InitGainCodeB, core);
			}
		} else if (force_gain_type == 7) {
			code_A	=  pi_ac->initGain_codeA;
			code_B	 = pi_ac->initGain_codeB;
		} else if (force_gain_type == 8) {
			code_A	=  pi_ac->initGain_codeA;
			code_B	 = pi_ac->initGain_codeB;
		} else if (force_gain_type == 9) {
			code_A  =  0x16a;
			code_B   = 0x554;
		} else if (force_gain_type == 6) {
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
			MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 0);
			continue;
		} else if (force_gain_type == 10) {
			/* use pktgain info */
			code_A  =  READ_PHYREGCE(pi, PhyStatsGainInfo, core)<<1;
			code_B  =  READ_PHYREGCE(pi, Auxphystats, core);
			code_B  =  (((code_B >> 2) & 0xf) << 12) | ((code_B & 1) << 3) |
				(((code_A >> 11) & 7) << 4) | (((code_A >> 14) & 7) << 8);
		} else {
			return;
		}

		rxgain[core].lna1 = (code_A >> 1) & 0x7;
		rxgain[core].lna2 = (code_A >> 4) & 0x7;
		rxgain[core].mix  = (code_A >> 7) & 0xf;
		rxgain[core].lpf0 = (code_B >> 4) & 0x7;
		rxgain[core].lpf1 = (code_B >> 8) & 0x7;
		rxgain[core].dvga = (code_B >> 12) & 0xf;
		rxgain[core].trtx = (code_B >> 3) & 0x1;

		if (core == 0) {
			gain_tblid =  ACPHY_TBL_ID_GAIN0;
		} else if (core == 1) {
			gain_tblid =  ACPHY_TBL_ID_GAIN1;
		} else {
			gain_tblid =  ACPHY_TBL_ID_GAIN2;
		}

		stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
		ACPHY_DISABLE_STALL(pi);
		/* ELNA */
		if (elna_present == 1) {
			wlc_phy_table_read_acphy(pi, gain_tblid, 1, (0x0 + (code_A & 0x1)),
			                         8, &elna_gain[core]);
		}

		/* lna1, lna2 and mixer */
		wlc_phy_table_read_acphy(pi, gain_tblid, 1, (0x8 + rxgain[core].lna1), 8,
		                         &gain_lna1);
		gain_lna2 = pi_ac->lna2_complete_gaintbl[rxgain[core].lna2];
		wlc_phy_table_read_acphy(pi, gain_tblid, 1, (0x20 + rxgain[core].mix), 8,
		                         &gain_mix);

		if (TINY_RADIO(pi) && (force_gain_type >= 10)) {
		  /* bug fix for tiny radio - temporarily protect rssi code */
		  gain_bq0 = 3 * rxgain[core].lpf0;
			wlc_phy_table_read_acphy(pi, gain_tblid, 1, (0x70 + rxgain[core].lpf1),
				8, &gain_bq1);
		} else {
		  gain_bq0 = 3 * rxgain[core].lpf0;
		  gain_bq1 = 3 * rxgain[core].lpf1;
		}

		ACPHY_ENABLE_STALL(pi, stall_val);

		gain_dvga = 3 * rxgain[core].dvga;

		if ((force_gain_type == 4) ||
		    ((force_gain_type == 3) && (pi_ac->mdgain_trtx_allowed))||
		    ((force_gain_type == 1 || force_gain_type >= 10) && rxgain[core].trtx)) {
			if (core == 0) {
				tr_loss = READ_PHYREGFLD(pi, Core0_TRLossValue, freqGainTLoss0);
			} else if (core == 1) {
				tr_loss = READ_PHYREGFLD(pi, Core1_TRLossValue, freqGainTLoss1);
			} else {
				tr_loss = READ_PHYREGFLD(pi, Core2_TRLossValue, freqGainTLoss2);
			}
		} else {
			tr_loss =  READ_PHYREG(pi, TRLossValue) & 0x7f;
		}

		/* Total gain: */
		tot_gain[core] = elna_gain[core] + gain_lna1 + gain_lna2 + gain_mix + gain_bq0
		        +  gain_bq1 - tr_loss + gain_dvga;

		if (pi_ac->rssi_cal_rev == FALSE) {
		  /* adjust total gain based on common rssi correction factor: */
		  chan_found = FALSE;
		  if (CHSPEC_IS2G(pi->radio_chanspec)) {
		    tot_gain[core] -=
		      pi_ac->srom.rssioffset.rssi_corr_normal[core][bw_idx];
		    for (i = 0; i < ACPHY_NUM_CHAN_2G_20; i++) {
		      if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi_ac->srom
			  .rssioffset.rssi_corr_pchan_2g_chan[core][bw_idx][i]) {
			chan_found = TRUE;
			break;
		      }
		    }
		    if (chan_found) {
		      tot_gain[core] -=
		      pi_ac->srom.rssioffset.rssi_corr_pchan_2g_val[core][bw_idx][i];
		    }
		  } else {
		    subband_idx = wlc_phy_get_chan_freq_range_acphy(pi,
		      CHSPEC_CHANNEL(pi->radio_chanspec))-1;
		    tot_gain[core] -=
		      pi_ac->srom.rssioffset.rssi_corr_normal_5g[core][subband_idx]
		      [bw_idx];
		    for (i = 0; i < ACPHY_NUM_CHAN_5G_20; i++) {
		      if (CHSPEC_CHANNEL(pi->radio_chanspec) == pi_ac->srom
			  .rssioffset.rssi_corr_pchan_5g_chan[core][bw_idx][i]) {
			chan_found = TRUE;
			break;
		      }
		    }
		    if (chan_found) {
		      tot_gain[core] -=
		      pi_ac->srom.rssioffset.rssi_corr_pchan_5g_val[core][bw_idx][i];
		    }
		  }
		}
		PHY_RXIQ(("In %s: | Mode = %d | Code_A = %X | Code_B = %X |"
			  "\n", __FUNCTION__, force_gain_type, code_A, code_B));
	}
}

uint8 wlc_phy_calc_extra_init_gain_acphy(phy_info_t *pi, uint8 extra_gain_3dB,
 rxgain_t rxgain[])
{
	uint16 init_gain_code[4];
	uint8 core, MAX_DVGA, MAX_LPF, MAX_MIX;
	uint8 dvga, mix, lpf0, lpf1;
	uint8 dvga_inc, lpf0_inc, lpf1_inc;
	uint8 max_inc, gain_ticks = extra_gain_3dB;

	MAX_DVGA = 4; MAX_LPF = 10; MAX_MIX = 4;
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 3, 0xf9, 16, &init_gain_code);

	/* Find if the requested gain increase is possible */
	FOREACH_CORE(pi, core) {
		dvga = 0;
		mix = (init_gain_code[core] >> 6) & 0xf;
		lpf0 = (init_gain_code[core] >> 10) & 0x7;
		lpf1 = (init_gain_code[core] >> 13) & 0x7;
		max_inc = MAX(0, MAX_DVGA - dvga) + MAX(0, MAX_LPF - lpf0 - lpf1) +
		        MAX(0, MAX_MIX - mix);
		gain_ticks = MIN(gain_ticks, max_inc);
	}
	if (gain_ticks != extra_gain_3dB) {
		PHY_INFORM(("%s: Unable to find enough extra gain. Using extra_gain = %d\n",
		            __FUNCTION__, 3 * gain_ticks));
	}
		/* Do nothing if no gain increase is required/possible */
	if (gain_ticks == 0) {
		return gain_ticks;
	}
	/* Find the mix, lpf0, lpf1 gains required for extra INITgain */
	FOREACH_CORE(pi, core) {
		uint8 gain_inc = gain_ticks;
		dvga = 0;
		mix = (init_gain_code[core] >> 6) & 0xf;
		lpf0 = (init_gain_code[core] >> 10) & 0x7;
		lpf1 = (init_gain_code[core] >> 13) & 0x7;
		dvga_inc = MIN((uint8) MAX(0, MAX_DVGA - dvga), gain_inc);
		dvga += dvga_inc;
		gain_inc -= dvga_inc;
		lpf1_inc = MIN((uint8) MAX(0, MAX_LPF - lpf1 - lpf0), gain_inc);
		lpf1 += lpf1_inc;
		gain_inc -= lpf1_inc;
		lpf0_inc = MIN((uint8) MAX(0, MAX_LPF - lpf1 - lpf0), gain_inc);
		lpf0 += lpf0_inc;
		gain_inc -= lpf0_inc;
		mix += MIN((uint8) MAX(0, MAX_MIX - mix), gain_inc);
		rxgain[core].lna1 = init_gain_code[core] & 0x7;
		rxgain[core].lna2 = (init_gain_code[core] >> 3) & 0x7;
		rxgain[core].mix  = mix;
		rxgain[core].lpf0 = lpf0;
		rxgain[core].lpf1 = lpf1;
		rxgain[core].dvga = dvga;
	}
	return gain_ticks;
}

/**
 * Function parameters:
 *     gpioen: bitmask. Setting a bit to '0' allows the ucode to drive that GPIO bit.
 */
static void
wlc_phy_set_bt_on_core1_acphy(phy_info_t *pi, uint8 bt_fem_val, uint16 gpioen)
{
	/* *** NOTE : For boards with BT on sharead antenna, update code in
	   wlc_bmac_set_ctrl_bt_shd0() so that in down mode BT has control of fem
	   Also, BT needs control when insmod (but not up), in that case wlc_phy_ac.c
	   is not even called, and so need to have some code in wlc_bmac.
	*/

	/* chip_bandsel = bandsel */
	MOD_PHYREG(pi, BT_SwControl, bt_sharing_en, 1);
	/* Bring c1_2g ctrls on gpio/srmclk */
	WRITE_PHYREG(pi, shFemMuxCtrl, 0x555);

	/* Setup chipcontrol (chipc[3] for acphy_gpios) */
	si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
		CCTRL4360_BTSWCTRL_MODE, CCTRL4360_BTSWCTRL_MODE);

	/* point fem_bt to chip_bt control line */
	MOD_PHYREG(pi, BT_FemControl, bt_fem, bt_fem_val);

	if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
		/* PHY controls bits 5,6,7 of gpio for BT boards (only needed for A0) */
		si_gpiocontrol(pi->sh->sih, 0xffff, 0x00e0, GPIO_DRV_PRIORITY);

		/* acphy_gpios = mux(bt_fem, femctrl[7:4]) */
		WRITE_PHYREG(pi, gpioSel, 0xb);
		/* bt control lines in gpio 5,6,7 */
		WRITE_PHYREG(pi, gpioLoOutEn, 0xe0);

		pi->u.pi_acphy->poll_adc_WAR = TRUE;

		/* 4360A0 : Force in WLAN mode, as A0 does not have inv_btcx_prisel bit,
		   and we have to change top level MAC definition of prisel (too complicated)
		   We are not supporting BT on 4360A0 anyway
		*/
		MOD_PHYREG(pi, BT_FemControl, bt_en, 0);
		MOD_PHYREG(pi, BT_FemControl, bt_en_ovrd, 1);
	} else {
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		    ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, BT_FemControl, bt_en, 0)
			MOD_PHYREG_ENTRY(pi, BT_FemControl, bt_en_ovrd, 1)
		    ACPHY_REG_LIST_EXECUTE(pi);
		}
		pi->u.pi_acphy->poll_adc_WAR = FALSE;

		/* For MAC prisel = 0 means BT, and 1 means WLAN. PHY code assumes opp behavior */
		MOD_PHYREG(pi, BT_SwControl, inv_btcx_prisel, 1);
	}

	/* In wlan Off/sleep mode, Make BT as input, and driver others as 0 */
	si_gpioout(pi->sh->sih, gpioen, 0, GPIO_DRV_PRIORITY);
	si_gpioouten(pi->sh->sih, gpioen, gpioen, GPIO_DRV_PRIORITY);
	si_gpiocontrol(pi->sh->sih, gpioen, 0, GPIO_DRV_PRIORITY);
}

#ifndef WLC_DISABLE_ACI
/**********  DESENSE : ACI, NOISE, BT (start)  ******** */

/*********** Desense (geneal) ********** */
/* IMP NOTE: make sure whatever regs are changed here are either:
1. reset back to default below OR
2. Updated in gainctrl()
*/
void
wlc_phy_desense_apply_acphy(phy_info_t *pi, bool apply_desense)
{
	/* reset:
	   1 --> clear aci settings (the ones that gainctrl does not clear)
	   0 --> apply aci_noise_bt mitigation
	*/
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense;
	uint8 ofdm_desense, bphy_desense, initgain_desense;
	uint8 crsmin_thresh, crsmin_init;
	int8 crsmin_high;
	uint8 bphy_minshiftbits[] = {0x77, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04,
	     0x04, 0x04, 0x04};
	uint16 bphy_peakenergy[]  = {0x10, 0x60, 0x10, 0x4c, 0x60, 0x30, 0x40, 0x40, 0x38, 0x2e,
	     0x40, 0x34, 0x40};
	uint8 bphy_initgain_backoff[] = {0, 0, 0, 0, 0, 0, 0, 3, 6, 9, 9, 12, 12};
	uint8 max_bphy_shiftbits = sizeof(bphy_minshiftbits) / sizeof(uint8);

	uint8 max_initgain_desense = 12;   /* only desnese bq0 */
	uint8 core, bphy_idx = 0;

	desense = &pi_ac->total_desense;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);

	if (!apply_desense && !desense->forced) {
		/* when channel is changed, and the current channel is in mitigatation, then
		   we need to restore the values. wlc_phy_rxgainctrl_gainctrl_acphy() takes
		   care of all the gainctrl part, but we need to still restore back bphy regs
		*/
		wlc_phy_set_crs_min_pwr_acphy(pi, ACPHY_CRSMIN_DEFAULT, 0, 0);
	  if ((ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	      ACMINORREV_1(pi->pubpi.phy_rev) || ACMINORREV_4(pi->pubpi.phy_rev))) ||
	    (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
	    wlc_phy_set_crs_min_pwr_higain_acphy(pi, ACPHY_CRSMIN_GAINHI);
	  } else {
	    wlc_phy_set_crs_min_pwr_higain_acphy(pi, ACPHY_CRSMIN_DEFAULT);
	  }
		wlc_phy_desense_mf_high_thresh_acphy(pi, FALSE);
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
		  /* should not be needed for 4345 anyway */
		  if (!ACMAJORREV_3(pi->pubpi.phy_rev))
		    WRITE_PHYREG(pi, DigiGainLimit0, 0x4477);
		  WRITE_PHYREG(pi, PeakEnergyL, 0x10);
		}

		pi_ac->curr_desense.ofdm_desense = 0;
		pi_ac->curr_desense.bphy_desense = 0;

		wlc_phy_desense_print_phyregs_acphy(pi, "restore");
	} else {
		bphy_desense = MIN(ACPHY_ACI_MAX_DESENSE_BPHY_DB, desense->bphy_desense);
		ofdm_desense = MIN(ACPHY_ACI_MAX_DESENSE_OFDM_DB, desense->ofdm_desense);

		/* Update current desense */
		pi_ac->curr_desense.ofdm_desense = ofdm_desense;
		pi_ac->curr_desense.bphy_desense = bphy_desense;

		/* if any ofdm desense is needed, first start using higher
		   mf thresholds (1dB sens loss)
		*/
		wlc_phy_desense_mf_high_thresh_acphy(pi, (ofdm_desense > 0));
		if (ofdm_desense > 0)
			ofdm_desense -= 1;

		/* Distribute desense between INITgain & crsmin(ofdm) & digigain(bphy) */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			/* round to 2, as bphy desense table is in 2dB steps */
			bphy_idx = MIN((bphy_desense + 1) >> 1, max_bphy_shiftbits - 1);
			initgain_desense = bphy_initgain_backoff[bphy_idx];
		} else {
			initgain_desense = 0;
		}

#ifdef BCMLTECOEX
		if (pi_ac->ltecx_mode == 1)
			initgain_desense = ofdm_desense;
		else
#endif // endif
		initgain_desense = MIN(initgain_desense, max_initgain_desense);

		/* OFDM Desense */
		/* With init gain, max crsmin desense = 30dB, after which ADC will start clipping */
		/* With HI gain, crsmin desense = new_sens - old_sens
		   = (-96 + desense) - (0 - (higain + 27))
		   = -69 + desense + higain
		*/
		crsmin_init = MAX(0, ofdm_desense - initgain_desense);
		crsmin_high = ofdm_desense + ACPHY_HI_GAIN - 69;

		PHY_ACI(("aci_mode1, desense, init = %d, bphy_idx = %d, crsmin = {%d %d}\n",
		         initgain_desense, bphy_idx, crsmin_init, crsmin_high));

		if (!TINY_RADIO(pi)) {
			/* Update INITgain */
			FOREACH_CORE(pi, core) {
				wlc_phy_rxgainctrl_set_init_clip_gain_acphy(pi, 0,
				                                            ACPHY_INIT_GAIN
				                                            - initgain_desense,
				                                            desense->elna_bypass,
				                                            FALSE, core);
			}
		}

		/* adjust crsmin threshold, 8 ticks increase gives 3dB rejection */
		crsmin_thresh = ACPHY_CRSMIN_DEFAULT + ((88 * crsmin_init) >> 5);  /* init gain */

#ifdef BCMLTECOEX
		if (pi_ac->ltecx_mode == 1)
			wlc_phy_set_crs_min_pwr_acphy(pi,
				MAX(crsmin_thresh, ACPHY_CRSMIN_DEFAULT), 0, 0);
		else
#endif // endif

		wlc_phy_set_crs_min_pwr_acphy(pi,
			MAX(crsmin_thresh, pi->u.pi_acphy->phy_crs_th_from_crs_cal), 0, 0);

		/* crs high_gain */
		if ((ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
		      ACMINORREV_1(pi->pubpi.phy_rev) || ACMINORREV_4(pi->pubpi.phy_rev))) ||
		  (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev))) {
		    crsmin_thresh = MAX(ACPHY_CRSMIN_GAINHI,
			ACPHY_CRSMIN_DEFAULT + ((88 * crsmin_high) >> 5));  /* hi gain */
		  } else {
		    crsmin_thresh = ACPHY_CRSMIN_DEFAULT
			+ MAX(0, ((88 * crsmin_high) >> 5));  /* hi gain */
		}
		wlc_phy_set_crs_min_pwr_higain_acphy(pi, crsmin_thresh);

		/* bphy desense */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			WRITE_PHYREG(pi, DigiGainLimit0, 0x4400 | bphy_minshiftbits[bphy_idx]);
			WRITE_PHYREG(pi, PeakEnergyL, bphy_peakenergy[bphy_idx]);
		}
		wlc_phy_desense_print_phyregs_acphy(pi, "apply");
	}

	/* Inform rate control to slow down is mitigation is on */
	wlc_phy_aci_updsts_acphy(pi);

	wlapi_enable_mac(pi->sh->physhim);
}

static void
wlc_phy_desense_calc_total_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

#ifdef BCMLTECOEX
	acphy_desense_values_t *bt, *aci, *lte;
#else
	acphy_desense_values_t *bt, *aci;
#endif // endif

	acphy_desense_values_t *total = &pi_ac->total_desense;

	aci = (pi_ac->aci == NULL) ? &pi_ac->zero_desense : &pi_ac->aci->desense;

	/* if desense is forced, then skip without calculation and just use the forced value */
	if (total->forced)
		return;

#ifdef BCMLTECOEX
	if ((pi_ac->btc_mode == 0 && pi_ac->ltecx_mode == 0) || wlc_phy_is_scan_chan_acphy(pi) ||
	    CHSPEC_IS5G(pi->radio_chanspec)) {
		/* only consider aci desense */
		memcpy(total, aci, sizeof(acphy_desense_values_t));
	} else {
		/* Merge BT & ACI & LTE desense, take max */
		bt  = &pi_ac->bt_desense;
		lte = &pi_ac->lte_desense;
		total->ofdm_desense = MAX(MAX(aci->ofdm_desense, bt->ofdm_desense),
			lte->ofdm_desense);
		total->bphy_desense = MAX(MAX(aci->bphy_desense, bt->bphy_desense),
			lte->bphy_desense);
		total->elna_bypass = MAX(MAX(aci->elna_bypass, bt->elna_bypass),
			lte->elna_bypass);
		total->lna1_tbl_desense = MAX(MAX(aci->lna1_tbl_desense, bt->lna1_tbl_desense),
			lte->lna1_tbl_desense);
		total->lna2_tbl_desense = MAX(MAX(aci->lna2_tbl_desense, bt->lna2_tbl_desense),
			lte->lna2_tbl_desense);
		total->lna1_gainlmt_desense = MAX(MAX(aci->lna1_gainlmt_desense,
			bt->lna1_gainlmt_desense), lte->lna1_gainlmt_desense);
		total->lna1_bypass = MAX(MAX(aci->lna1_bypass, bt->lna1_bypass), lte->lna1_bypass);
		total->lna1_rout = MAX(MAX(aci->lna1_rout, bt->lna1_rout), lte->lna1_rout);
		total->lna2_gainlmt_desense = MAX(MAX(aci->lna2_gainlmt_desense,
			bt->lna2_gainlmt_desense), lte->lna2_gainlmt_desense);
		total->lna2_rout = MAX(MAX(aci->lna2_rout, bt->lna2_rout), lte->lna2_rout);
		total->mixer_setting_desense = MAX(MAX(aci->mixer_setting_desense,
		       bt->mixer_setting_desense), lte->mixer_setting_desense);
		total->biq0_tbl_desense = MAX(MAX(aci->biq0_tbl_desense, bt->biq0_tbl_desense),
		       lte->biq0_tbl_desense);
		total->biqs_maxgain = MAX(MAX(aci->biqs_maxgain, bt->biqs_maxgain),
		       lte->biqs_maxgain);
		total->nf_hit_lna12 =  MAX(MAX(aci->nf_hit_lna12, bt->nf_hit_lna12),
			lte->nf_hit_lna12);
		total->on = aci->on | bt->on | lte->on;
	}
#else
	if ((pi_ac->btc_mode == 0) || wlc_phy_is_scan_chan_acphy(pi) ||
	    CHSPEC_IS5G(pi->radio_chanspec)) {
		/* only consider aci desense */
		memcpy(total, aci, sizeof(acphy_desense_values_t));
	} else {
		/* Merge BT & ACI desense, take max */
		bt  = &pi_ac->bt_desense;
		total->ofdm_desense = MAX(aci->ofdm_desense, bt->ofdm_desense);
		total->bphy_desense = MAX(aci->bphy_desense, bt->bphy_desense);
		total->elna_bypass = MAX(aci->elna_bypass, bt->elna_bypass);
		total->lna1_tbl_desense = MAX(aci->lna1_tbl_desense, bt->lna1_tbl_desense);
		total->lna2_tbl_desense = MAX(aci->lna2_tbl_desense, bt->lna2_tbl_desense);
		total->lna1_gainlmt_desense =
		  MAX(aci->lna1_gainlmt_desense, bt->lna1_gainlmt_desense);
		total->lna1_bypass = MAX(aci->lna1_bypass, bt->lna1_bypass);
		total->lna1_rout = MAX(aci->lna1_rout, bt->lna1_rout);
		total->lna2_gainlmt_desense =
		  MAX(aci->lna2_gainlmt_desense, bt->lna2_gainlmt_desense);
		total->lna2_rout = MAX(aci->lna2_rout, bt->lna2_rout);
		total->mixer_setting_desense =
		  MAX(aci->mixer_setting_desense, bt->mixer_setting_desense);
		total->biq0_tbl_desense = MAX(aci->biq0_tbl_desense, bt->biq0_tbl_desense);
		total->biqs_maxgain = MAX(aci->biqs_maxgain, bt->biqs_maxgain);
		total->nf_hit_lna12 =  MAX(aci->nf_hit_lna12, bt->nf_hit_lna12);
		total->on = aci->on | bt->on;
	}
#endif /* BCMLTECOEX */

	/* uCode detected high pwr RSSI. Time to save ilna1 */
	if (CHSPEC_IS2G(pi->radio_chanspec) && (pi_ac->hirssi_timer2g > PHY_SW_HIRSSI_OFF))
		total->elna_bypass = TRUE;
	if (CHSPEC_IS5G(pi->radio_chanspec) && (pi_ac->hirssi_timer5g > PHY_SW_HIRSSI_OFF))
		total->elna_bypass = TRUE;
}

/*
Default - High MF thresholds are used only if pktgain < 81dB.
To always use high mf thresholds, change this to 98dBs
*/
static void
wlc_phy_desense_mf_high_thresh_acphy(phy_info_t *pi, bool on)
{
	uint16 val;

	if (on) {
		val = 0x5f62;
	} else {
		val = (TINY_RADIO(pi)) ? 0x454b : 0x4e51;
	}

	WRITE_PHYREG(pi, crshighlowpowThresholdl, val);
	WRITE_PHYREG(pi, crshighlowpowThresholdu, val);
	WRITE_PHYREG(pi, crshighlowpowThresholdlSub1, val);
	WRITE_PHYREG(pi, crshighlowpowThresholduSub1, val);
}

/********** DESENSE (ACI, CCI, Noise - glitch based) ******** */

/* Top level wrapper to call various deense/gainctrl functions */
static void
wlc_phy_apply_total_mitigation_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *curr_desense, *desense;
	bool call_gainctrl = FALSE;

	/* Get total desense based on aci & bt & lte */
	wlc_phy_desense_calc_total_acphy(pi);
	curr_desense = &pi_ac->curr_desense;
	desense = &pi_ac->total_desense;

	if ((curr_desense->ofdm_desense != desense->ofdm_desense) ||
	    (curr_desense->bphy_desense != desense->bphy_desense)) {
		wlc_phy_desense_apply_acphy(pi, TRUE);
	}

	/* check mixer/biq/lna1_bypass change and update gain table */
	/* better way to implement be to write a function similar to */
	/* wlc_phy_upd_lna1_lna2_gainlimittbls_acphy */
	/* that changes only biq & mix gain */
	if ((curr_desense->elna_bypass != desense->elna_bypass) ||
	    (curr_desense->lna1_bypass != desense->lna1_bypass) ||
	    (curr_desense->lna1_tbl_desense != desense->lna1_tbl_desense) ||
	    (curr_desense->lna2_tbl_desense != desense->lna2_tbl_desense) ||
	    (curr_desense->mixer_setting_desense != desense->mixer_setting_desense) ||
	    (curr_desense->biq0_tbl_desense != desense->biq0_tbl_desense) ||
	    (curr_desense->biqs_maxgain != desense->biqs_maxgain)) {
		wlc_phy_rxgainctrl_set_gaintbls_acphy(pi, TRUE, TRUE, TRUE);
		call_gainctrl = TRUE;
	}

	if ((curr_desense->lna1_gainlmt_desense != desense->lna1_gainlmt_desense) ||
	    (curr_desense->lna2_gainlmt_desense != desense->lna2_gainlmt_desense) ||
	    (curr_desense->lna1rout_gainlmt_desense != desense->lna1rout_gainlmt_desense) ||
	    (curr_desense->lna2rout_gainlmt_desense != desense->lna2rout_gainlmt_desense) ||
	    (curr_desense->lna1_rout != desense->lna1_rout) ||
	    (curr_desense->lna2_rout != desense->lna2_rout)) {
		wlc_phy_upd_lna1_lna2_gains_acphy(pi);
		call_gainctrl = TRUE;
	}

	/* Call gainctrl if required */
	if (call_gainctrl) {
		if (TINY_RADIO(pi)) {
			wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);
		} else {
			wlc_phy_rxgainctrl_gainctrl_acphy(pi);
		}
	}
}

static void
BCMATTACHFN(wlc_phy_hwaci_init_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/* common */
	pi_ac->hwaci_args.energy_thresh = 0x3e8;
	pi_ac->hwaci_args.detect_thresh = 0x1f4;
	pi_ac->hwaci_args.wait_period = 0x1;
	pi_ac->hwaci_args.sliding_window = 0xf;
	pi_ac->hwaci_args.samp_cluster = 0xf;
	pi_ac->hwaci_args.w3_lo_th = 0x0;
	pi_ac->hwaci_args.w3_md_th = 0x0;
	pi_ac->hwaci_args.w3_hi_th = 0x0;
	pi_ac->hwaci_args.w2 = 4;

	pi_ac->hwaci_max_states_2g = 4;     /* <= ACPHY_HWACI_MAX_STATES */
	pi_ac->hwaci_max_states_5g = 4;     /* <= ACPHY_HWACI_MAX_STATES */

	/* 2g */
	bzero(pi_ac->hwaci_states_2g, ACPHY_HWACI_MAX_STATES * sizeof(acphy_hwaci_state_t));
	/* hwaci states: 0, no ACI settings */
	pi_ac->hwaci_states_2g[0].energy_thresh = 0xffff;   /* don't care */
	pi_ac->hwaci_states_2g[0].w2_sel = 0;
	pi_ac->hwaci_states_2g[0].w2_thresh = 30;
	pi_ac->hwaci_states_2g[0].nb_thresh = 4;
	pi_ac->hwaci_states_2g[0].lna1_pktg_lmt = 5;
	pi_ac->hwaci_states_2g[0].lna2_pktg_lmt = 6;
	pi_ac->hwaci_states_2g[0].lna1rout_pktg_lmt = 0;
	pi_ac->hwaci_states_2g[0].lna2rout_pktg_lmt = 0;

	/* hwaci states: 1, check/desense for > -45dBm */
	pi_ac->hwaci_states_2g[1].w2_sel = 0;

	/* hwaci states: 2, check/desense for > -40dBm */
	pi_ac->hwaci_states_2g[2].w2_sel = 1;

	/* hwaci states: 3, check/desense for > -35dBm */
	pi_ac->hwaci_states_2g[3].w2_sel = 2;

	/* hwaci states: 4, check/desense */
	pi_ac->hwaci_states_5g[4].w2_sel = 2;

	/* 5g */
	bzero(pi_ac->hwaci_states_5g, ACPHY_HWACI_MAX_STATES * sizeof(acphy_hwaci_state_t));
	/* hwaci states: 0, no ACI settings */
	pi_ac->hwaci_states_5g[0].energy_thresh = 0xffff;   /* don't care */
	pi_ac->hwaci_states_5g[0].w2_sel = 0;
	pi_ac->hwaci_states_5g[0].w2_thresh = 30;
	pi_ac->hwaci_states_5g[0].nb_thresh = 4;
	pi_ac->hwaci_states_5g[0].lna1_pktg_lmt = 5;
	pi_ac->hwaci_states_5g[0].lna2_pktg_lmt = 6;
	pi_ac->hwaci_states_5g[0].lna1rout_pktg_lmt = 4;

	/* hwaci states: 1, check/desense */
	pi_ac->hwaci_states_5g[1].w2_sel = 0;

	/* hwaci states: 2, check/desense */
	pi_ac->hwaci_states_5g[2].w2_sel = 1;

	/* hwaci states: 3, check/desense */
	pi_ac->hwaci_states_5g[3].w2_sel = 2;

	/* hwaci states: 4, check/desense */
	pi_ac->hwaci_states_5g[4].w2_sel = 2;

	/* 4335C0 */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		/* hwaci params */
		pi_ac->hwaci_args.sample_time = 300;
		pi_ac->hwaci_args.nb_lo_th = 0x0;
		/* 2g */
		pi_ac->hwaci_states_2g[1].energy_thresh = 4000;
		pi_ac->hwaci_states_2g[1].w2_thresh = 30;
		pi_ac->hwaci_states_2g[1].nb_thresh = 10;
		pi_ac->hwaci_states_2g[1].lna1_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[1].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[1].lna1rout_pktg_lmt = 0;

		pi_ac->hwaci_states_2g[2].energy_thresh = 9000;
		pi_ac->hwaci_states_2g[2].w2_thresh = 16;
		pi_ac->hwaci_states_2g[2].nb_thresh = 10;
		pi_ac->hwaci_states_2g[2].lna1_pktg_lmt = 3;
		pi_ac->hwaci_states_2g[2].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[2].lna1rout_pktg_lmt = 0;

		pi_ac->hwaci_states_2g[3].energy_thresh = 14000;
		pi_ac->hwaci_states_2g[3].w2_thresh = 2;
		pi_ac->hwaci_states_2g[3].nb_thresh = 10;
		pi_ac->hwaci_states_2g[3].lna1_pktg_lmt = 3;
		pi_ac->hwaci_states_2g[3].lna2_pktg_lmt = 3;
		pi_ac->hwaci_states_2g[3].lna1rout_pktg_lmt = 0;

		/* 5g */
		pi_ac->hwaci_states_5g[1].energy_thresh = 1000;
		pi_ac->hwaci_states_5g[1].w2_thresh = 30;
		pi_ac->hwaci_states_5g[1].nb_thresh = 4;
		pi_ac->hwaci_states_5g[1].lna1_pktg_lmt = 4;
		pi_ac->hwaci_states_5g[1].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_5g[1].lna1rout_pktg_lmt = 4;

		pi_ac->hwaci_states_5g[2].energy_thresh = 11000;
		pi_ac->hwaci_states_5g[2].w2_thresh = 25;
		pi_ac->hwaci_states_5g[2].nb_thresh = 4;
		pi_ac->hwaci_states_5g[2].lna1_pktg_lmt = 3;
		pi_ac->hwaci_states_5g[2].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_5g[2].lna1rout_pktg_lmt = 4;

		pi_ac->hwaci_states_5g[3].energy_thresh = 17000;
		pi_ac->hwaci_states_5g[3].w2_thresh = 15;
		pi_ac->hwaci_states_5g[3].nb_thresh = 8;
		pi_ac->hwaci_states_5g[3].lna1_pktg_lmt = 3;
		pi_ac->hwaci_states_5g[3].lna2_pktg_lmt = 3;
		pi_ac->hwaci_states_5g[3].lna1rout_pktg_lmt = 4;
	}
	/* 4354 related */
	else if (AC4354REV(pi)) {
		/* 43569/43570: http://confluence.broadcom.com/x/HJBHEQ */
		if (PHY_ILNA(pi)) {
			/* hwaci params */
			pi_ac->hwaci_args.sample_time = 300;
			pi_ac->hwaci_args.nb_lo_th = 0x1;
			/* 2g */
			pi_ac->hwaci_states_2g[1].energy_thresh = 4000;
			pi_ac->hwaci_states_2g[1].w2_thresh = 30;
			pi_ac->hwaci_states_2g[1].nb_thresh = 4;
			pi_ac->hwaci_states_2g[1].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_2g[1].lna2_pktg_lmt = 6;
			pi_ac->hwaci_states_2g[1].lna1rout_pktg_lmt = 3;
			pi_ac->hwaci_states_2g[1].lna2rout_pktg_lmt = 3;

			pi_ac->hwaci_states_2g[2].energy_thresh = 11000;
			pi_ac->hwaci_states_2g[2].w2_thresh = 14;
			pi_ac->hwaci_states_2g[2].nb_thresh = 4;
			pi_ac->hwaci_states_2g[2].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_2g[2].lna2_pktg_lmt = 6;
			pi_ac->hwaci_states_2g[2].lna1rout_pktg_lmt = 3;
			pi_ac->hwaci_states_2g[2].lna2rout_pktg_lmt = 9;

			pi_ac->hwaci_states_2g[3].energy_thresh = 17000;
			pi_ac->hwaci_states_2g[3].w2_thresh = 8;
			pi_ac->hwaci_states_2g[3].nb_thresh = 4;
			pi_ac->hwaci_states_2g[3].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_2g[3].lna2_pktg_lmt = 6;
			pi_ac->hwaci_states_2g[3].lna1rout_pktg_lmt = 7;
			pi_ac->hwaci_states_2g[3].lna2rout_pktg_lmt = 7;

			/* 5g */
			pi_ac->hwaci_states_5g[1].energy_thresh = 8000;
			pi_ac->hwaci_states_5g[1].w2_thresh = 30;
			pi_ac->hwaci_states_5g[1].nb_thresh = 4;
			pi_ac->hwaci_states_5g[1].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[1].lna2_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[1].lna1rout_pktg_lmt = 2;

			pi_ac->hwaci_states_5g[2].energy_thresh = 18000;
			pi_ac->hwaci_states_5g[2].w2_thresh = 25;
			pi_ac->hwaci_states_5g[2].nb_thresh = 4;
			pi_ac->hwaci_states_5g[2].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[2].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[2].lna1rout_pktg_lmt = 0;

			pi_ac->hwaci_states_5g[3].energy_thresh = 24000;
			pi_ac->hwaci_states_5g[3].w2_thresh = 15;
			pi_ac->hwaci_states_5g[3].nb_thresh = 4;
			pi_ac->hwaci_states_5g[3].lna1_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[3].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[3].lna1rout_pktg_lmt = 0;
		} else {
			/* hwaci params */
			pi_ac->hwaci_args.sample_time = 300;
			pi_ac->hwaci_args.nb_lo_th = 0x1;
			/* 2g */
			pi_ac->hwaci_states_2g[1].energy_thresh = 4000;
			pi_ac->hwaci_states_2g[1].w2_thresh = 30;
			pi_ac->hwaci_states_2g[1].nb_thresh = 4;
			pi_ac->hwaci_states_2g[1].lna1_pktg_lmt = 4;
			pi_ac->hwaci_states_2g[1].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_2g[1].lna1rout_pktg_lmt = 0;

			pi_ac->hwaci_states_2g[2].energy_thresh = 11000;
			pi_ac->hwaci_states_2g[2].w2_thresh = 14;
			pi_ac->hwaci_states_2g[2].nb_thresh = 4;
			pi_ac->hwaci_states_2g[2].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_2g[2].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_2g[2].lna1rout_pktg_lmt = 0;

			pi_ac->hwaci_states_2g[3].energy_thresh = 17000;
			pi_ac->hwaci_states_2g[3].w2_thresh = 8;
			pi_ac->hwaci_states_2g[3].nb_thresh = 4;
			pi_ac->hwaci_states_2g[3].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_2g[3].lna2_pktg_lmt = 3;
			pi_ac->hwaci_states_2g[3].lna1rout_pktg_lmt = 0;

			/* 5g */
			pi_ac->hwaci_states_5g[1].energy_thresh = 8000;
			pi_ac->hwaci_states_5g[1].w2_thresh = 30;
			pi_ac->hwaci_states_5g[1].nb_thresh = 4;
			pi_ac->hwaci_states_5g[1].lna1_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[1].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[1].lna1rout_pktg_lmt = 4;

			pi_ac->hwaci_states_5g[2].energy_thresh = 18000;
			pi_ac->hwaci_states_5g[2].w2_thresh = 25;
			pi_ac->hwaci_states_5g[2].nb_thresh = 4;
			pi_ac->hwaci_states_5g[2].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_5g[2].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[2].lna1rout_pktg_lmt = 4;

			pi_ac->hwaci_states_5g[3].energy_thresh = 24000;
			pi_ac->hwaci_states_5g[3].w2_thresh = 15;
			pi_ac->hwaci_states_5g[3].nb_thresh = 4;
			pi_ac->hwaci_states_5g[3].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_5g[3].lna2_pktg_lmt = 3;
			pi_ac->hwaci_states_5g[3].lna1rout_pktg_lmt = 4;
		}
	}
	/* 4360B0, 43602 related */
	else if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* hwaci params */
		pi_ac->hwaci_args.sample_time = 300;
		pi_ac->hwaci_args.nb_lo_th = 0x1;
		/* 2g */
		pi_ac->hwaci_states_2g[1].energy_thresh = 4000;
		pi_ac->hwaci_states_2g[1].w2_thresh = 30;
		pi_ac->hwaci_states_2g[1].nb_thresh = 4;
		pi_ac->hwaci_states_2g[1].lna1_pktg_lmt = 5;
		pi_ac->hwaci_states_2g[1].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[1].lna1rout_pktg_lmt = 0;

		pi_ac->hwaci_states_2g[2].energy_thresh = 8000;
		pi_ac->hwaci_states_2g[2].w2_thresh = 22;
		pi_ac->hwaci_states_2g[2].nb_thresh = 4;
		pi_ac->hwaci_states_2g[2].lna1_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[2].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[2].lna1rout_pktg_lmt = 0;

		pi_ac->hwaci_states_2g[3].energy_thresh = 11000;
		pi_ac->hwaci_states_2g[3].w2_thresh = 10;
		pi_ac->hwaci_states_2g[3].nb_thresh = 4;
		pi_ac->hwaci_states_2g[3].lna1_pktg_lmt = 3;
		pi_ac->hwaci_states_2g[3].lna2_pktg_lmt = 4;
		pi_ac->hwaci_states_2g[3].lna1rout_pktg_lmt = 0;

		/* 5g */
		if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			/* 4360 A0 */
			pi_ac->hwaci_max_states_5g = 4;
			pi_ac->hwaci_states_5g[1].energy_thresh = 1000;
			pi_ac->hwaci_states_5g[1].w2_thresh = 30;
			pi_ac->hwaci_states_5g[1].nb_thresh = 4;
			pi_ac->hwaci_states_5g[1].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[1].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[1].lna1rout_pktg_lmt = 4;

			pi_ac->hwaci_states_5g[2].energy_thresh = 6000;
			pi_ac->hwaci_states_5g[2].w2_thresh = 25;
			pi_ac->hwaci_states_5g[2].nb_thresh = 4;
			pi_ac->hwaci_states_5g[2].lna1_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[2].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[2].lna1rout_pktg_lmt = 4;

			pi_ac->hwaci_states_5g[3].energy_thresh = 10000;
			pi_ac->hwaci_states_5g[3].w2_thresh = 15;
			pi_ac->hwaci_states_5g[3].nb_thresh = 4;
			pi_ac->hwaci_states_5g[3].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_5g[3].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[3].lna1rout_pktg_lmt = 4;
		} else {
			/* 4360 B0, 43602 */
			pi_ac->hwaci_max_states_5g = 5;
			pi_ac->hwaci_states_5g[1].energy_thresh = 3000;
			pi_ac->hwaci_states_5g[1].w2_thresh = 30;
			pi_ac->hwaci_states_5g[1].nb_thresh = 4;
			pi_ac->hwaci_states_5g[1].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[1].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[1].lna1rout_pktg_lmt = 4;

			pi_ac->hwaci_states_5g[2].energy_thresh = 8000;
			pi_ac->hwaci_states_5g[2].w2_thresh = 15;
			pi_ac->hwaci_states_5g[2].nb_thresh = 4;
			pi_ac->hwaci_states_5g[2].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[2].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[2].lna1rout_pktg_lmt = 2;

			pi_ac->hwaci_states_5g[3].energy_thresh = 11000;
			pi_ac->hwaci_states_5g[3].w2_thresh = 8;
			pi_ac->hwaci_states_5g[3].nb_thresh = 4;
			pi_ac->hwaci_states_5g[3].lna1_pktg_lmt = 5;
			pi_ac->hwaci_states_5g[3].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[3].lna1rout_pktg_lmt = 0;

			pi_ac->hwaci_states_5g[4].energy_thresh = 12000;
			pi_ac->hwaci_states_5g[4].w2_thresh = 25;
			pi_ac->hwaci_states_5g[4].nb_thresh = 4;
			pi_ac->hwaci_states_5g[4].lna1_pktg_lmt = 3;
			pi_ac->hwaci_states_5g[4].lna2_pktg_lmt = 4;
			pi_ac->hwaci_states_5g[4].lna1rout_pktg_lmt = 4;
		}
	}

	/* 4350 GT c0  */
	if (ACHWACIREV(pi)) {
		/* HW ACI Detection SW ACI Mitigation
		 * These settings have been tested well,
		 * with only LNA back off's and using no Routs.
		 */

		/* hwaci params */
		pi_ac->hwaci_args.energy_thresh = 3000;
		pi_ac->hwaci_args.energy_thresh_w2 = 3000;
		pi_ac->hwaci_args.detect_thresh = 1000;
		pi_ac->hwaci_args.nb_lo_th = 0x1;
		pi_ac->hwaci_args.wait_period = 0x0;
		pi_ac->hwaci_args.sliding_window = 0xf;
		pi_ac->hwaci_args.samp_cluster = 0x5;
		pi_ac->hwaci_args.w3_lo_th = 0x0;
		pi_ac->hwaci_args.w3_md_th = 0x0;
		pi_ac->hwaci_args.w3_hi_th = 0x1;
		pi_ac->hwaci_args.w2 = 10;
		pi_ac->hwaci_args.aci_present_th = 0;	/* 0 = 1/8; 1 = 1/4; */
		pi_ac->hwaci_args.aci_present_select = 2; /* 2 = W3 || W12  */

		if ((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0) {
			/* HW Swithching makes a decision in 100 ms */
			pi_ac->hwaci_args.sample_time = 100;
		} else if ((pi->sh->interference_mode & ACPHY_ACI_HWACI_PKTGAINLMT) != 0) {
			/* SW Swithching makes a decision in 990 ms */
			pi_ac->hwaci_args.sample_time = 990;
		}

		/* 2g */
		pi_ac->hwaci_states_2g[1] = hwaci_states_2g_4350[0];
		pi_ac->hwaci_states_2g[2] = hwaci_states_2g_4350[1];
		pi_ac->hwaci_states_2g[3] = hwaci_states_2g_4350[2];

		/* 5g */
		pi_ac->hwaci_states_5g[1] = hwaci_states_5g_4350[0];
		pi_ac->hwaci_states_5g[2] = hwaci_states_5g_4350[1];
		pi_ac->hwaci_states_5g[3] = hwaci_states_5g_4350[2];

	}
}

void
wlc_phy_desense_aci_reset_params_acphy(phy_info_t *pi, bool all2g, bool all5g)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (all2g)
		bzero(pi_ac->aci_list2g, ACPHY_ACI_CHAN_LIST_SZ * sizeof(acphy_aci_params_t));
	if (all5g)
		bzero(pi_ac->aci_list5g, ACPHY_ACI_CHAN_LIST_SZ * sizeof(acphy_aci_params_t));

	if (all2g || all5g) {
		pi_ac->aci = NULL;
	} else if (pi_ac->aci != NULL) {
		bzero(&pi_ac->aci->bphy_hist, sizeof(desense_history_t));
		bzero(&pi_ac->aci->ofdm_hist, sizeof(desense_history_t));
		pi_ac->aci->glitch_buff_idx = 0;
		pi_ac->aci->glitch_upd_wait = 1;
		bzero(&pi_ac->aci->desense, sizeof(acphy_desense_values_t));
	}

	wlc_phy_apply_total_mitigation_acphy(pi);
}

static acphy_aci_params_t*
wlc_phy_desense_aci_getset_chanidx_acphy(phy_info_t *pi, chanspec_t chanspec, bool create)
{
	uint8 idx, oldest_idx;
	uint64 oldest_time;
	acphy_aci_params_t *ret = NULL;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_aci_params_t *aci_list;

	aci_list = CHSPEC_IS2G(chanspec) ? pi_ac->aci_list2g : pi_ac->aci_list5g;

	/* Find if this chan/bw already exists */
	for (idx = 0; idx < ACPHY_ACI_CHAN_LIST_SZ; idx++) {
		if ((aci_list[idx].chan == CHSPEC_CHANNEL(chanspec)) &&
		    (aci_list[idx].bw == CHSPEC_BW(chanspec))) {
			ret = &aci_list[idx];
			PHY_ACI(("aci_debug. *** old_chan. idx = %d, chan = %d, bw = %d\n",
			         idx, ret->chan, ret->bw));
			break;
		}
	}

	/* If doesn't exist & don't want to create one */
	if ((ret == NULL) && !create) return ret;

	if (ret == NULL) {
		/* Chan/BW does not exist on in the list of ACI channels.
		   Create a new one (based on oldest timestamp)
		*/
		oldest_idx = 0; oldest_time = aci_list[oldest_idx].last_updated;
		for (idx = 1; idx < ACPHY_ACI_CHAN_LIST_SZ; idx++) {
			if (aci_list[idx].last_updated < oldest_time) {
				oldest_time = aci_list[idx].last_updated;
				oldest_idx = idx;
			}
		}

		/* Clear the new aciinfo data */
		ret = &aci_list[oldest_idx];
		bzero(ret, sizeof(acphy_aci_params_t));
		ret->chan =  CHSPEC_CHANNEL(pi->radio_chanspec);
		ret->bw = pi->bw;
		ret->glitch_upd_wait = 2;
		PHY_ACI(("aci_debug, *** new_chan = %d %d, idx = %d\n",
		         CHSPEC_CHANNEL(pi->radio_chanspec), pi->bw, oldest_idx));
	}

	/* Only if the request came for creation */
	if (create) {
		ret->last_updated = wlc_phy_get_time_usec(pi);
	}

	return ret;
}

void
wlc_phy_desense_aci_engine_acphy(phy_info_t *pi, bool upd_glitch_hist)
{
	uint8 ma_idx, badplcp_idx, i;
	bool call_mitigation = FALSE;
	uint32 bphy_glitches, bphy_badplcp;
	uint32 ofdm_glitches, ofdm_badplcp;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint32 avg_glitch_ofdm, avg_glitch_bphy;
	uint8 new_bphy_desense, new_ofdm_desense;
	acphy_desense_values_t *desense;
	acphy_aci_params_t *aci;

	if (pi_ac->aci == NULL)
		pi_ac->aci = wlc_phy_desense_aci_getset_chanidx_acphy(pi, pi->radio_chanspec, TRUE);

	aci = pi_ac->aci;
	desense = &aci->desense;

	aci->engine_called = TRUE;

	if (aci->glitch_upd_wait > 0) {
		aci->glitch_upd_wait--;
		return;
	}

	if (upd_glitch_hist) {
		/* bphy glitches/badplcp */
		ma_idx = (pi->interf.noise.bphy_ma_index == 0) ? PHY_NOISE_MA_WINDOW_SZ - 1 :
		        pi->interf.noise.bphy_ma_index - 1;
		badplcp_idx = (pi->interf.noise.bphy_badplcp_ma_index == 0) ?
		        PHY_NOISE_MA_WINDOW_SZ - 1 :
		        pi->interf.noise.bphy_badplcp_ma_index - 1;
		bphy_glitches = pi->interf.noise.bphy_glitch_ma_list[ma_idx];
		bphy_badplcp = pi->interf.noise.bphy_badplcp_ma_list[badplcp_idx];
		PHY_ACI(("aci_mode1, bphy(glitch, badplcp) = %d %d \n",
		         bphy_glitches, bphy_badplcp));

		/* Ofdm glitches/badplcp */
		ma_idx = (pi->interf.noise.ofdm_ma_index == 0) ? PHY_NOISE_MA_WINDOW_SZ - 1 :
		        pi->interf.noise.ofdm_ma_index - 1;
		badplcp_idx = (pi->interf.noise.ofdm_badplcp_ma_index == 0) ?
		        PHY_NOISE_MA_WINDOW_SZ - 1 :
		        pi->interf.noise.ofdm_badplcp_ma_index - 1;
		ofdm_glitches = pi->interf.noise.ofdm_glitch_ma_list[ma_idx];
		ofdm_badplcp = pi->interf.noise.ofdm_badplcp_ma_list[badplcp_idx];
		PHY_ACI(("aci_mode1, ofdm(glitch, badplcp) = %d %d \n",
		         ofdm_glitches, ofdm_badplcp));

		/* Update glitch history */
		wlc_phy_desense_aci_upd_glitches_acphy(aci, bphy_glitches, bphy_badplcp,
		                                       ofdm_glitches, ofdm_badplcp);
	}

	PHY_ACI(("aci_mode1, bphy : glitch + (2 * badplcp) = "));
	for (i = 0; i < ACPHY_ACI_GLITCH_BUFFER_SZ; i++)
		PHY_ACI(("%d ", aci->bphy_hist.glitches[i]));
	PHY_ACI(("\n"));

	PHY_ACI(("aci_mode1, ofdm : glitch + (2 * badplcp) = "));
	for (i = 0; i < ACPHY_ACI_GLITCH_BUFFER_SZ; i++)
		PHY_ACI(("%d ", aci->ofdm_hist.glitches[i]));
	PHY_ACI(("\n"));

	/* Find AVG of Max glitches in last N seconds */
	avg_glitch_bphy =
	        wlc_phy_desense_aci_get_avg_max_glitches_acphy(aci->bphy_hist.glitches);
	avg_glitch_ofdm =
	        wlc_phy_desense_aci_get_avg_max_glitches_acphy(aci->ofdm_hist.glitches);

	PHY_ACI(("aci_mode1, max {bphy, ofdm} = {%d %d}, rssi = %d, aci_on = %d\n",
	         avg_glitch_bphy, avg_glitch_ofdm, aci->weakest_rssi, desense->on));

	/* Don't need to do anything if interference mitigation is off & glitches < thresh */
	if (!(desense->on || (avg_glitch_bphy > ACPHY_ACI_BPHY_HI_GLITCH_THRESH) ||
	      (avg_glitch_ofdm > ACPHY_ACI_OFDM_HI_GLITCH_THRESH)))
		return;

	new_bphy_desense = wlc_phy_desense_aci_calc_acphy(pi, &aci->bphy_hist,
	                                             desense->bphy_desense,
	                                             avg_glitch_bphy,
	                                             ACPHY_ACI_BPHY_LO_GLITCH_THRESH,
	                                             ACPHY_ACI_BPHY_HI_GLITCH_THRESH);

	new_ofdm_desense = wlc_phy_desense_aci_calc_acphy(pi, &aci->ofdm_hist,
	                                             desense->ofdm_desense,
	                                             avg_glitch_ofdm,
	                                             ACPHY_ACI_OFDM_LO_GLITCH_THRESH,
	                                             ACPHY_ACI_OFDM_HI_GLITCH_THRESH);

	/* Limit desnese */
	new_bphy_desense = MIN(new_bphy_desense, ACPHY_ACI_MAX_DESENSE_BPHY_DB);
	new_ofdm_desense = MIN(new_ofdm_desense, ACPHY_ACI_MAX_DESENSE_OFDM_DB);

	if (ASSOC_INPROG_PHY(pi) || PUB_NOT_ASSOC(pi)) {
		new_bphy_desense = 0;
		new_ofdm_desense = 0;
	}

	if (pi_ac->limit_desense_on_rssi) {
		new_bphy_desense = MIN(new_bphy_desense, MAX(0, aci->weakest_rssi + 85));
		new_ofdm_desense = MIN(new_ofdm_desense, MAX(0, aci->weakest_rssi + 80));
	}

	PHY_ACI(("aci_mode1, old desense = {%d %d}, new = {%d %d}\n",
	         desense->bphy_desense,
	         desense->ofdm_desense,
	         new_bphy_desense, new_ofdm_desense));

	if (new_bphy_desense != desense->bphy_desense) {
		call_mitigation = TRUE;
		desense->bphy_desense = new_bphy_desense;

		/* Clear old glitch history when desnese changed */
		for (i = 0; i <  ACPHY_ACI_GLITCH_BUFFER_SZ; i++)
			aci->bphy_hist.glitches[i] = ACPHY_ACI_BPHY_LO_GLITCH_THRESH;
	}

	if (new_ofdm_desense != desense->ofdm_desense) {
		call_mitigation = TRUE;
		desense->ofdm_desense = new_ofdm_desense;

		/* Clear old glitch history when desnese changed */
		for (i = 0; i <  ACPHY_ACI_GLITCH_BUFFER_SZ; i++)
			aci->ofdm_hist.glitches[i] = ACPHY_ACI_OFDM_LO_GLITCH_THRESH;
	}

	desense->on = ((desense->ofdm_desense > 0) || (desense->bphy_desense > 0));

	if (call_mitigation) {
		PHY_ACI(("aci_mode1 : desense = %d %d\n",
		         desense->bphy_desense, desense->ofdm_desense));
		wlc_phy_apply_total_mitigation_acphy(pi);

		/* After gain change, it takes a while for updated glitches to show up */
		aci->glitch_upd_wait = ACPHY_ACI_WAIT_POST_MITIGATION;
	}
}

static void
wlc_phy_desense_aci_upd_glitches_acphy(acphy_aci_params_t *aci,
                                       uint32 bphy_glitches, uint32 bphy_badplcp,
                                       uint32 ofdm_glitches, uint32 ofdm_badplcp)
{
	uint8 glitch_idx;
	/* Update glitch history */
	glitch_idx = aci->glitch_buff_idx;
	aci->bphy_hist.glitches[glitch_idx] = bphy_glitches + (2 * bphy_badplcp);
	aci->ofdm_hist.glitches[glitch_idx] = ofdm_glitches + (2 * ofdm_badplcp);
	aci->glitch_buff_idx = (glitch_idx + 1) % ACPHY_ACI_GLITCH_BUFFER_SZ;
}

static void
wlc_phy_save_def_gain_settings_acphy(phy_info_t *pi)
{
	acphy_hwaci_defgain_settings_t *pi_ac_dgain = pi->u.pi_acphy->def_gains;
	ASSERT(pi_ac_dgain);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 8, 8, pi_ac_dgain->lna1_gainlim_ofdm_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 72, 8, pi_ac_dgain->lna1_gainlim_cck_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT,
	6, 0, 8, pi_ac_dgain->lna1_rout_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAIN0,
	6, 8, 8, pi_ac_dgain->lna1_gaindb_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 8, 8, pi_ac_dgain->lna1_gainbits_2g_def);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 17, 8, pi_ac_dgain->lna2_gainlim_ofdm_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 81, 8, pi_ac_dgain->lna2_gainlim_cck_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT,
	6, 17, 8, pi_ac_dgain->lna2_rout_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAIN0,
	6, 17, 8, pi_ac_dgain->lna2_gaindb_2g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 17, 8, pi_ac_dgain->lna2_gainbits_2g_def);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 8, 8, pi_ac_dgain->lna1_gainlim_5g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_LNAROUT,
	6, 8, 8, pi_ac_dgain->lna1_rout_5g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAIN0,
	6, 8, 8, pi_ac_dgain->lna1_gaindb_5g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 8, 8, pi_ac_dgain->lna1_gainbits_5g_def);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 17, 8, pi_ac_dgain->lna2_gainlim_5g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAIN0,
	6, 17, 8, pi_ac_dgain->lna2_gaindb_5g_def);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 17, 8, pi_ac_dgain->lna2_gainbits_5g_def);

}

void
wlc_phy_hwaci_mitigate_acphy(phy_info_t *pi, bool aci_status)
{

	acphy_hwaci_defgain_settings_t *pi_ac_dgain = pi->u.pi_acphy->def_gains;

	/* These are HW ACI Mitigation settings (to be written to FCBS table) */
	uint8 *lna1_gainlim_ofdm;
	uint8 *lna1_gainlim_cck;
	uint8 *lna1_rout;
	uint8 *lna1_gaindb;
	uint8 *lna1_gainbits;

	uint8 *lna2_gainlim_ofdm;
	uint8 *lna2_gainlim_cck;
	uint8 *lna2_rout;
	uint8 *lna2_gaindb;
	uint8 *lna2_gainbits;

	uint8 core;
	uint16 table_id_core[PHY_CORE_MAX];
	uint16 start_off_core[PHY_CORE_MAX];

	/* If any of the 10 settings (7 for 5G) are changed,
	* they will be initialized to new values here
	* If they are not being changed, they will be read
	* from the phytable, so that they are initialized.
	*/
	uint8 lna1_gainlim_ofdm_2g_aci[6] = {0xb, 0xc, 0xe, 0x7f, 0x7f, 0x7f};
	uint8 lna1_gainlim_cck_2g_aci[6] = {0xb, 0xc, 0xe, 0x7f, 0x7f, 0x7f};
	uint8 lna1_rout_2g_aci[6] = {0x55, 0x55, 0x55, 0x3, 0x4, 0x5};
	uint8 lna1_gaindb_2g_aci[6] = {0x2, 0x2, 0x2, 0xb, 0xb, 0x19};
	uint8 lna1_gainbits_2g_aci[6];

	uint8 lna2_gainlim_ofdm_2g_aci[6];
	uint8 lna2_gainlim_cck_2g_aci[6];
	uint8 lna2_rout_2g_aci[6] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6};
	uint8 lna2_gainbits_2g_aci[6] = {1, 2, 3, 4, 5, 6};
	uint8 lna2_gaindb_2g_aci[6] = {-8, -4, -1, 2, 2, 9};

	uint8 lna1_gainlim_5g_aci[6] = {0xb, 0xc, 0xe, 0x20, 0x7f, 0x7f};
	uint8 lna1_rout_5g_aci[6] = {0x20, 0x21, 0x22, 0x03, 0x24, 0x25};
	uint8 lna1_gaindb_5g_aci[6] = {0xfe, 0xfe, 0x04, 0x06, 0x10, 0x17};
	uint8 lna1_gainbits_5g_aci[6];

	uint8 lna2_gainlim_5g_aci[6] = {0x0, 0x0, 0x3, 0x3, 0x3, 0x7f};
	uint8 lna2_gaindb_5g_aci[6];
	uint8 lna2_gainbits_5g_aci[6];

	uint8 dummy_array[6] = {0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f};
	bool suspend;
	uint8 stall_val;

	ASSERT(pi_ac_dgain);

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phyreg_enter((wlc_phy_t *)pi);
	}
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 8, 8, lna1_gainbits_2g_aci);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 17, 8, lna2_gainlim_ofdm_2g_aci);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINLIMIT,
	6, 81, 8, lna2_gainlim_cck_2g_aci);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 8, 8, lna1_gainbits_5g_aci);

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAIN0,
	6, 17, 8, lna2_gaindb_5g_aci);
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_GAINBITS0,
	6, 17, 8, lna2_gainbits_5g_aci);

	if (aci_status == 1) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			lna1_gainlim_ofdm =   lna1_gainlim_ofdm_2g_aci;
			lna1_gainlim_cck =    lna1_gainlim_cck_2g_aci;
			lna1_rout =           lna1_rout_2g_aci;
			lna1_gaindb =         lna1_gaindb_2g_aci;
			lna1_gainbits =	      lna1_gainbits_2g_aci;

			lna2_gainlim_ofdm =   lna2_gainlim_ofdm_2g_aci;
			lna2_gainlim_cck =    lna2_gainlim_cck_2g_aci;
			lna2_rout =           lna2_rout_2g_aci;
			lna2_gaindb =         lna2_gaindb_2g_aci;
			lna2_gainbits =       lna2_gainbits_2g_aci;
		} else {
			lna1_gainlim_ofdm =	  lna1_gainlim_5g_aci;
			lna1_gainlim_cck =    dummy_array;
			lna1_rout =           lna1_rout_5g_aci;
			lna1_gaindb =         lna1_gaindb_5g_aci;
			lna1_gainbits =		  lna1_gainbits_5g_aci;

			lna2_gainlim_ofdm =	  lna2_gainlim_5g_aci;
			lna2_gainlim_cck =    dummy_array;
			lna2_rout =           dummy_array;
			lna2_gaindb =         lna2_gaindb_5g_aci;
			lna2_gainbits =		  lna2_gainbits_5g_aci;
		}
	} else {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			lna1_gainlim_ofdm =   pi_ac_dgain->lna1_gainlim_ofdm_2g_def;
			lna1_gainlim_cck =    pi_ac_dgain->lna1_gainlim_cck_2g_def;
			lna1_rout =           pi_ac_dgain->lna1_rout_2g_def;
			lna1_gaindb =         pi_ac_dgain->lna1_gaindb_2g_def;
			lna1_gainbits =       pi_ac_dgain->lna1_gainbits_2g_def;

			lna2_gainlim_ofdm =   pi_ac_dgain->lna2_gainlim_ofdm_2g_def;
			lna2_gainlim_cck =    pi_ac_dgain->lna2_gainlim_cck_2g_def;
			lna2_rout =           pi_ac_dgain->lna2_rout_2g_def;
			lna2_gaindb =         pi_ac_dgain->lna2_gaindb_2g_def;
			lna2_gainbits =       pi_ac_dgain->lna2_gainbits_2g_def;
		} else {
			lna1_gainlim_ofdm =   pi_ac_dgain->lna1_gainlim_5g_def;
			lna1_gainlim_cck =    dummy_array;
			lna1_rout =           pi_ac_dgain->lna1_rout_5g_def;
			lna1_gaindb =         pi_ac_dgain->lna1_gaindb_5g_def;
			lna1_gainbits =       pi_ac_dgain->lna1_gainbits_5g_def;

			lna2_gainlim_ofdm =   pi_ac_dgain->lna2_gainlim_5g_def;
			lna2_gainlim_cck =    dummy_array;
			lna2_rout =           dummy_array;
			lna2_gaindb =         pi_ac_dgain->lna2_gaindb_5g_def;
			lna2_gainbits =	      pi_ac_dgain->lna2_gainbits_5g_def;
		}
	}

	FOREACH_CORE(pi, core) {

		/* LNA1 settings */
		table_id_core[core] = ACPHY_TBL_ID_GAINLIMIT;
		start_off_core[core] = (core == 0) ? 8 : 0xff;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna1_gainlim_ofdm, 0);

		table_id_core[core] = ACPHY_TBL_ID_GAINLIMIT;
		start_off_core[core] = (core == 0) ? 72 : 0xff;

		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna1_gainlim_cck, 1);

		table_id_core[core] = ACPHY_TBL_ID_LNAROUT;
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			start_off_core[core] = (core == 0) ? 0 : 24;
		} else {
			start_off_core[core] = (core == 0) ? 8 : 32;
		}
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna1_rout, 0);

		table_id_core[core] = (core == 0) ? ACPHY_TBL_ID_GAIN0 :
		ACPHY_TBL_ID_GAIN1;
		start_off_core[core] = 8;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna1_gaindb, 0);

		table_id_core[core] = (core == 0) ? ACPHY_TBL_ID_GAINBITS0 :
		ACPHY_TBL_ID_GAINBITS1;
		start_off_core[core] = 8;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna1_gainbits, 0);

		/* LNA2 settings */
		table_id_core[core] = ACPHY_TBL_ID_GAINLIMIT;
		start_off_core[core] = (core == 0) ? 17 : 0xff;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna2_gainlim_ofdm, 0);

		table_id_core[core] = ACPHY_TBL_ID_GAINLIMIT;
		start_off_core[core] = (core == 0) ? 81 : 0xff;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna2_gainlim_cck, 1);

		table_id_core[core] = ACPHY_TBL_ID_LNAROUT;
		start_off_core[core] = (core == 0) ? 17 : 41;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna2_rout, 1);

		table_id_core[core] = (core == 0) ? ACPHY_TBL_ID_GAIN0 :
		ACPHY_TBL_ID_GAIN1;
		start_off_core[core] = 17;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna2_gaindb, 0);

		table_id_core[core] = (core == 0) ? ACPHY_TBL_ID_GAINBITS0 :
		ACPHY_TBL_ID_GAINBITS1;
		start_off_core[core] = 17;
		wlc_phy_hwaci_write_table_acphy(pi, table_id_core[core],
			start_off_core[core], lna2_gainbits, 0);
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
	if (!suspend) {
		wlc_phyreg_exit((wlc_phy_t *)pi);
		wlapi_enable_mac(pi->sh->physhim);
	}
}

static void
wlc_phy_hwaci_write_table_acphy(phy_info_t *pi, uint16 table_id,
uint16 start_off, uint8 *table_entry, bool check_5G)
{
	uint8 def_values[6];
	if ((start_off == 0xff) || (CHSPEC_IS5G(pi->radio_chanspec) && check_5G))
		return;
	wlc_phy_table_read_acphy(pi, table_id,
	6, start_off, 8, def_values);
	if (!memcmp(def_values, table_entry, sizeof(uint8)*6)) {
		start_off = 0xff;
	}
	if (start_off != 0xff) {
		wlc_phy_table_write_acphy(pi, table_id,
			6, start_off, 8, table_entry);
	}

}

void
wlc_phy_hwaci_override_acphy(phy_info_t *pi, int state)
{

	if ((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0) {
		/* This part of function is for HW Mitigation */
		if (state == 0) {
			ACPHY_REG_LIST_START
				/* Make sure HWACI never triggers. */
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_1_w3, 0xfffe)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_2_w3, 0xfffe)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_1_w12, 0xfffe)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_2_w12, 0xfffe)
			ACPHY_REG_LIST_EXECUTE(pi);
			wlc_phy_hwaci_mitigate_acphy(pi, FALSE);
		} else if (state == 1) {
			ACPHY_REG_LIST_START
				/* Make sure HWACI is ALWAYS detected. */
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_1_w3, 0x1)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_2_w3, 0x1)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_1_w12, 0x1)
				WRITE_PHYREG_ENTRY(pi, ACI_Detect_energy_threshold_2_w12, 0x1)
			ACPHY_REG_LIST_EXECUTE(pi);
			wlc_phy_hwaci_mitigate_acphy(pi, TRUE);
		} else if (state == -1) {
			wlc_phy_hwaci_setup_acphy(pi, TRUE, TRUE);
			wlc_phy_hwaci_mitigate_acphy(pi, 0);
		}

	} else {
		/* This part of function is for SW Mitigation */
		int lna1_idx, lna2_idx;

		phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
		acphy_aci_params_t *aci;
		acphy_desense_values_t *desense;
		uint8 band = CHSPEC_IS2G(pi->radio_chanspec) ? 2 : 5;
		acphy_hwaci_state_t  *hwaci_states = (band == 2) ? pi_ac->hwaci_states_2g :
		        pi_ac->hwaci_states_5g;
		/* Get current channels ACI structure */
		if (pi_ac->aci == NULL)
			pi_ac->aci = wlc_phy_desense_aci_getset_chanidx_acphy(pi,
				pi->radio_chanspec, TRUE);
		aci = pi_ac->aci;

		desense = &aci->desense;

		pi_ac->aci->hwaci_desense_state = (uint8)state;

		/* Update Desense settings */
		lna1_idx = hwaci_states[state].lna1_pktg_lmt;
		lna2_idx = hwaci_states[state].lna2_pktg_lmt;

		desense->lna1_gainlmt_desense = MAX(0, 5 - lna1_idx);
		desense->lna2_gainlmt_desense = MAX(0, 6 - lna2_idx);
		pi_ac->total_desense.lna1_gainlmt_desense = desense->lna1_gainlmt_desense;
		pi_ac->total_desense.lna2_gainlmt_desense = desense->lna2_gainlmt_desense;

		/* Update the tables. If other things are updated may need to call gainctrl */
		wlc_phy_upd_lna1_lna2_gainlimittbls_acphy(pi, 1, FALSE);
		wlc_phy_upd_lna1_lna2_gainlimittbls_acphy(pi, 2, FALSE);
	}
}
void
wlc_phy_hwaci_engine_acphy(phy_info_t *pi)
{
	uint32 hw_detect, hw_report, sw_detect, sw_report;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_aci_params_t *aci;
	acphy_desense_values_t *desense;
	uint8 band = CHSPEC_IS2G(pi->radio_chanspec) ? 2 : 5;
	uint8 core, core_ctr, lna1_idx, lna2_idx, lna1_rout;
	uint16 thresh;
	uint8 state, prev_setup_state, prev_desense_state;
	bool hwaci_present = FALSE, w2aci_present = FALSE, aci_present;
	uint8 w2sel, w2thresh, w2[3], nb, max_states;
	bool hwaci, w2aci, hwaci_mit;
	acphy_hwaci_state_t  *hwaci_states = (band == 2) ? pi_ac->hwaci_states_2g :
	        pi_ac->hwaci_states_5g;
	uint8 shft = CHSPEC_IS20(pi->radio_chanspec) ? 0 :
	        (CHSPEC_IS40(pi->radio_chanspec) ? 1 : 2);

	ASSERT(!ACPHY_ENABLE_FCBS_HWACI(pi));

	hwaci = (pi->sh->interference_mode & ACPHY_ACI_HWACI_PKTGAINLMT) != 0;
	w2aci = (pi->sh->interference_mode & ACPHY_ACI_W2NB_PKTGAINLMT) != 0;
	hwaci_mit = (pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) != 0;
	if (!(hwaci | w2aci) || hwaci_mit) return;

	/* Get current channels ACI structure */
	if (pi_ac->aci == NULL)
		pi_ac->aci = wlc_phy_desense_aci_getset_chanidx_acphy(pi, pi->radio_chanspec, TRUE);
	aci = pi_ac->aci;
	desense = &aci->desense;

	if (aci->hwaci_sleep > 0) {
		aci->hwaci_sleep--;
		return;
	}

	/* Don't use highest desense level based on SOI RSSi */
	max_states = (band == 2) ? pi_ac->hwaci_max_states_2g : pi_ac->hwaci_max_states_5g;
	if (aci->weakest_rssi < -75)
		max_states = MAX(1, max_states - 1);

	aci->hwaci_noaci_timer = MAX(0, aci->hwaci_noaci_timer - 1);
	state = aci->hwaci_setup_state;

	PHY_ACI(("aci_mode2_4. setup_state = %d, timer = %d\n", state, aci->hwaci_noaci_timer));

	/* Suspend mac before accessing phyregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);

	/* Disable BT as it affects rssi counters used for w2aci */
	wlc_btcx_override_enable(pi);
	if (hwaci) {
	  if (ACHWACIREV(pi)) {
	    hwaci_present = READ_PHYREGFLD(pi, ACI_Mitigation_status, aci_present_status);
	    PHY_ACI(("aci_mode2_4(hwaci). state {setup, desense} = {%d, %d}, "
		     "aci_present = %d\n",
		     aci->hwaci_setup_state, aci->hwaci_desense_state, hwaci_present));
	  } else {

		/* HW ACI Output */
		hw_detect = 0; hw_report = 0; sw_detect = 0; sw_report = 0; core_ctr = 0;
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (core == 0) {
				if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
				    !ACMINORREV_0(pi->pubpi.phy_rev)) {
					hw_detect +=
						READ_PHYREG(pi, ACI_Detect_aci_detected_ctr_w30);
					sw_detect +=
						READ_PHYREG(pi, ACI_Detect_sw_aci_detected_ctr_w30);
				} else {
					hw_detect += READ_PHYREG(pi, ACI_Detect_aci_detected_ctr0);
					sw_detect +=
						READ_PHYREG(pi, ACI_Detect_sw_aci_detected_ctr0);
				}
				hw_report += READ_PHYREG(pi, ACI_Detect_aci_report_ctr0);
				sw_report += READ_PHYREG(pi, ACI_Detect_sw_aci_report_ctr0);
				core_ctr++;
			}
			if (core == 1) {
				if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
				    !ACMINORREV_0(pi->pubpi.phy_rev)) {
					hw_detect +=
						READ_PHYREG(pi, ACI_Detect_aci_detected_ctr_w31);
					sw_detect +=
						READ_PHYREG(pi, ACI_Detect_sw_aci_detected_ctr_w31);
				} else {
					hw_detect += READ_PHYREG(pi, ACI_Detect_aci_detected_ctr1);
					sw_detect +=
						READ_PHYREG(pi, ACI_Detect_sw_aci_detected_ctr1);
				}
				hw_report += READ_PHYREG(pi, ACI_Detect_aci_report_ctr1);
				sw_report += READ_PHYREG(pi, ACI_Detect_sw_aci_report_ctr1);
				core_ctr++;
			}
			if (core == 2) {
				hw_detect += READ_PHYREG(pi, ACI_Detect_aci_detected_ctr2);
				hw_report += READ_PHYREG(pi, ACI_Detect_aci_report_ctr2);
				sw_detect += READ_PHYREG(pi, ACI_Detect_sw_aci_detected_ctr2);
				sw_report += READ_PHYREG(pi, ACI_Detect_sw_aci_report_ctr2);
				core_ctr++;
			}
		}
		/* Average over cores */
		if (core_ctr > 1) {
			hw_detect /= core_ctr;
			hw_report /= core_ctr;
			sw_detect /= core_ctr;
			sw_report /= core_ctr;
		}

		if (sw_report < 200) {
			/* Try to think of doing something here */
			if (hw_report < 200) {
				/* invalid value, ignore */
				sw_detect = 0;
			} else {
				sw_detect = hw_detect;
				sw_report = hw_report;
			}
		}

		/* Here, if the ratio of report/detect < 2 declare ACI */
		hwaci_present = (sw_detect > 0) & (sw_report < 4 * sw_detect);

		PHY_ACI(("aci_mode2_4(hwaci). hw_detect = %d, hw_report = %d, "
		         "sw_detect = %d, sw_report = %d, state {setup, desense} = {%d, %d}, "
		         "aci_present = %d\n",
		         hw_detect, hw_report, sw_detect, sw_report, aci->hwaci_setup_state,
		         aci->hwaci_desense_state, hwaci_present));
	  }
	}

	/* w2, nb pair */
	if (w2aci && !ACHWACIREV(pi)) {
		nb = READ_PHYREGFLD(pi, NbClipCnt1, NbClipCntAccum1_i) >> shft;
		w2[0] = READ_PHYREGFLD(pi, W2W1ClipCnt1, W2ClipCntAccum1) >> shft;
		w2[1] = READ_PHYREGFLD(pi, W2W1ClipCnt2, W2ClipCntAccum2) >> shft;
		w2[2] = READ_PHYREGFLD(pi, W2W1ClipCnt3, W2ClipCntAccum3) >> shft;

		w2sel = hwaci_states[state].w2_sel;
		w2thresh = hwaci_states[state].w2_thresh;
		w2aci_present = (nb <= hwaci_states[state].nb_thresh);
		if (w2sel == 0) {
			/* lo */
			w2aci_present &= (w2[0] >= w2thresh) ||
			        (w2[1] > 0) || (w2[2] > 0);
		} else if (w2sel == 1) {
			/* md */
			w2aci_present &= (w2[1] >= w2thresh) || (w2[2] > 0);
		} else {
			/* hi */
			w2aci_present &= (w2[2] >= w2thresh);
		}

		PHY_ACI(("aci_mode2_4(w2nb). w2 = {%d %d %d}, nb_lo = %d, w2aci = %d\n",
		         w2[0], w2[1], w2[2], nb, w2aci_present));
	}

	aci_present = hwaci_present | w2aci_present;

	/* ***** HWACI State Machine & Apply Settings ******* */
	prev_setup_state = aci->hwaci_setup_state;
	prev_desense_state = aci->hwaci_desense_state;
	if (aci->hwaci_setup_state == 0) {
		/* Coming here for the first time */
		aci->hwaci_setup_state = 1;
	} else {
		if (aci_present) {
			/* ACI found */
			aci->hwaci_noaci_timer = ACPHY_HWACI_NOACI_WAIT_TIME;
			aci->hwaci_desense_state = aci->hwaci_setup_state;
			aci->hwaci_setup_state++;
		} else if (aci->hwaci_noaci_timer == 0) {
			/* No ACI found */
			aci->hwaci_setup_state = MAX(0, aci->hwaci_setup_state - 1);
			if (aci->hwaci_setup_state < aci->hwaci_desense_state) {
				aci->hwaci_desense_state = aci->hwaci_setup_state;
			}
		}
	}

	/* keep setup state between 1 & max. 0 is noACI state, for setup use atleast state 1 */
	aci->hwaci_setup_state = MAX(1, MIN(aci->hwaci_setup_state, max_states - 1));
	if (ASSOC_INPROG_PHY(pi) || PUB_NOT_ASSOC(pi)) {
		aci->hwaci_setup_state = 1;
		aci->hwaci_desense_state = 0;
	}

	/* Update new settings & desense */
	if (prev_setup_state != aci->hwaci_setup_state) {
		state = aci->hwaci_setup_state;
		aci->hwaci_noaci_timer = ACPHY_HWACI_NOACI_WAIT_TIME;
		aci->hwaci_sleep = ACPHY_HWACI_SLEEP_TIME;           /* let hwaci get refreshed */

	if ((pi->sh->interference_mode & ACPHY_ACI_PREEMPTION) != 0) {
		if (AC4354REV(pi) && !(PHY_ILNA(pi))) {
			wlc_phy_switch_preemption_settings_AC4354REV(pi, aci->hwaci_setup_state);
		} else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			wlc_phy_switch_preemption_settings_ACMAJORREV5(pi, aci->hwaci_setup_state);
		}
	}

	/* Update HWACI settings */
	if (hwaci) {
		thresh = hwaci_states[state].energy_thresh;

		if (AC4354REV(pi) || ACHWACIREV(pi)) {
			WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1_w3, thresh);
			WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2_w3, thresh);
			thresh = hwaci_states[state].energy_thresh_w2;
			WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1_w12, thresh);
			WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2_w12, thresh);
		} else {
			WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1, thresh);
				WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2, thresh);
		}
	}

	PHY_ACI(("aci_mode2_4. SETUP STATE CHANGED. state = {%d --> %d}\n",
	         prev_setup_state, aci->hwaci_setup_state));
	}

	if (prev_desense_state != aci->hwaci_desense_state) {
		state = aci->hwaci_desense_state;
		/* Update Desense settings */
		lna1_idx = hwaci_states[state].lna1_pktg_lmt;
		lna2_idx = hwaci_states[state].lna2_pktg_lmt;
		lna1_rout = hwaci_states[state].lna1rout_pktg_lmt;
		desense->lna1_gainlmt_desense = MAX(0, 5 - lna1_idx);
		desense->lna2_gainlmt_desense = MAX(0, 6 - lna2_idx);
		desense->lna1rout_gainlmt_desense = (band == 5) ? MAX(0, 4 - lna1_rout) : lna1_rout;

		if (band == 2) {
			 desense->lna2rout_gainlmt_desense = hwaci_states[state].lna2rout_pktg_lmt;
		}

		/* Update the tables. If other things are updated may need to call gainctrl */
		wlc_phy_desense_calc_total_acphy(pi);            /* Update in total desense */
		wlc_phy_upd_lna1_lna2_gains_acphy(pi);
		if (TINY_RADIO(pi)) {
			wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);
		} else {
			wlc_phy_rxgainctrl_gainctrl_acphy(pi);
		}

		/* Inform rate contorl to slow down is mitigation is on */
		wlc_phy_aci_updsts_acphy(pi);

		PHY_ACI(("aci_mode2_4. DESENSE ST CHG. state = %d --> %d, lna1 = %d, lna2 = %d ",
		         prev_desense_state, aci->hwaci_desense_state, lna1_idx, lna2_idx));
		PHY_ACI(("lna1_rout = %d\n", lna1_rout));
	}

	/* Disabling BTCX Override */
	wlc_phy_btcx_override_disable(pi);

	wlapi_enable_mac(pi->sh->physhim);
}

static uint32
wlc_phy_desense_aci_get_avg_max_glitches_acphy(uint32 glitches[])
{
	uint8 i, j;
	uint32 max_glitch, glitch_cnt = 0;
	uint8 max_glitch_idx;
	uint32 glitches_sort[ACPHY_ACI_GLITCH_BUFFER_SZ];

	for (i = 0; i < ACPHY_ACI_GLITCH_BUFFER_SZ; i++)
		glitches_sort[i] = glitches[i];

	/* Get 2 max from the list */
	for (j = 0; j < ACPHY_ACI_NUM_MAX_GLITCH_AVG; j++) {
		max_glitch_idx = 0;
		max_glitch = glitches_sort[0];
		for (i = 1; i <  ACPHY_ACI_GLITCH_BUFFER_SZ; i++) {
			if (glitches_sort[i] > max_glitch) {
				max_glitch_idx = i;
				max_glitch = glitches_sort[i];
			}
		}
		glitches_sort[max_glitch_idx] = 0;
		glitch_cnt += max_glitch;
	}

	/* avg */
	glitch_cnt /= ACPHY_ACI_NUM_MAX_GLITCH_AVG;
	return glitch_cnt;
}

static uint8
wlc_phy_desense_aci_calc_acphy(phy_info_t *pi, desense_history_t *aci_desense, uint8 desense,
                          uint32 glitch_cnt, uint16 glitch_th_lo, uint16 glitch_th_hi)
{
	uint8 hi, lo, cnt, cnt_thresh = 0;
	bool border = FALSE;

	hi = aci_desense->hi_glitch_dB;
	lo = aci_desense->lo_glitch_dB;
	cnt = aci_desense->no_desense_change_time_cnt;

	if (glitch_cnt > glitch_th_hi) {
		hi = desense;
		if (hi >= lo) desense += ACPHY_ACI_COARSE_DESENSE_UP;
		else desense = MAX(desense + 1, (hi + lo) >> 1);
		cnt = 0;
	} else {
		/* Sleep for different times under different conditions */
		border = ACMAJORREV_5(pi->pubpi.phy_rev) ?
			(((desense - hi == 2) || (desense - hi == 1)) && (lo - hi <= 2))
			: (desense -hi == 1);
		if (border) {
			cnt_thresh = ACPHY_ACI_BORDER_GLITCH_SLEEP;
			if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
				desense = MAX(desense, hi + 2);
				lo = desense;
			}
		} else {
			cnt_thresh = (glitch_cnt >= glitch_th_lo) ? ACPHY_ACI_MD_GLITCH_SLEEP :
			        ACPHY_ACI_LO_GLITCH_SLEEP;
		}

		if (cnt > cnt_thresh) {
			lo = desense;
			if (lo <= hi) desense = MAX(0, desense - ACPHY_ACI_COARSE_DESENSE_DN);
			else {
				if (ACMAJORREV_5(pi->pubpi.phy_rev))
				desense = MAX(0, MIN(desense - 2, (hi + lo) >> 1));
				else
				desense = MAX(0, MIN(desense - 1, (hi + lo) >> 1));
			}
			cnt = 0;
		}
	}

	PHY_ACI(("aci_mode1, lo = %d, hi = %d, desense = %d, cnt = %d(%d)\n",  lo, hi, desense,
	         cnt, cnt_thresh));

	/* Update the values */
	aci_desense->hi_glitch_dB = hi;
	aci_desense->lo_glitch_dB = lo;
	aci_desense->no_desense_change_time_cnt = MIN(cnt + 1, 255);

	return desense;
}

/* Update chan stats offline, i.e. we might not be on this channel currently */
void
wlc_phy_desense_aci_upd_rssi_acphy(phy_info_t *pi, chanspec_t chanspec, int8 rssi)
{
	acphy_aci_params_t *aci;

	aci = (acphy_aci_params_t *)
	        wlc_phy_desense_aci_getset_chanidx_acphy(pi, chanspec, FALSE);

	if (aci == NULL) return;   /* not found in phy list of channels */

	aci->weakest_rssi = rssi;
}

void
wlc_phy_desense_aci_upd_chan_stats_acphy(phy_info_t *pi, chanspec_t chanspec,
                                   uint32 bphy_glitches, uint32 bphy_badplcp,
                                   uint32 ofdm_glitches, uint32 ofdm_badplcp)
{
	acphy_aci_params_t *aci;

	aci = (acphy_aci_params_t *)
	        wlc_phy_desense_aci_getset_chanidx_acphy(pi, chanspec, FALSE);

	if (aci == NULL) return;   /* not found in phy list of channels */

	/* Update glitch history */
	wlc_phy_desense_aci_upd_glitches_acphy(aci, bphy_glitches, bphy_badplcp,
	                                       ofdm_glitches, ofdm_badplcp);
}

static void
wlc_phy_aci_updsts_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_aci_params_t *aci;
	uint32 phy_mode = 0;

	if (pi_ac->aci != NULL) {
		aci = pi_ac->aci;
		if (aci->desense.on || aci->hwaci_desense_state > 0)
			phy_mode = PHY_MODE_ACI;
	}

	wlapi_high_update_phy_mode(pi->sh->physhim, phy_mode);
}

/********** Desense BT  ******** */
void
wlc_phy_desense_btcoex_acphy(phy_info_t *pi, int32 mode)
{

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->bt_desense;
	int32 old_mode = pi_ac->btc_mode;

	if (ACPHY_ENABLE_FCBS_HWACI(pi))
		return;

	/* Start with no limits */
	bzero(desense, sizeof(acphy_desense_values_t));
	pi_ac->btc_mode = mode;

	switch (mode) {
	case 1: /* BT power =  -30dBm, -35dBm */
		desense->lna1_gainlmt_desense = 1;   /* 4 */
		desense->lna2_gainlmt_desense = 3;   /* 3 */
		desense->elna_bypass = 0;
		break;
	case 2: /* BT power = -20dBm , -25dB */
		desense->lna1_gainlmt_desense = 0;   /* 5 */
		desense->lna2_gainlmt_desense = 0;   /* 6 */
		desense->elna_bypass = 1;
		break;
	case 3: /* BT power = -15dBm */
		desense->lna1_gainlmt_desense = 0;   /* 5 */
		desense->lna2_gainlmt_desense = 2;   /* 4 */
		desense->elna_bypass = 1;
		desense->nf_hit_lna12 = 2;
		break;
	case 4: /* BT power = -10dBm */
		desense->lna1_gainlmt_desense = 1;   /* 4 */
		desense->lna2_gainlmt_desense = 2;   /* 4 */
		desense->elna_bypass = 1;
		desense->nf_hit_lna12 = 3;
		break;
	case 5: /* BT power = -5dBm */
		desense->lna1_gainlmt_desense = 3;   /* 2 */
		desense->lna2_gainlmt_desense = 0;   /* 6 */
		desense->elna_bypass = 1;
		desense->nf_hit_lna12 = 13;
		break;
	case 6: /* BT power = 0dBm */
		desense->lna1_gainlmt_desense = 3;   /* 2 */
		desense->lna2_gainlmt_desense = 4;   /* 2 */
		desense->elna_bypass = 1;
		desense->nf_hit_lna12 = 24;
		break;

	/* Alternative implementations of mode 2 with less NF impact */

	case 12: /* BT power = -20dBm , -25dB */
		/* eLNA on, LNA1 bypass, Rout=4, LNA2 max and mixer/BiQ0 limited */
		desense->lna1_bypass = 1;
		desense->lna1_rout = 4;
		desense->mixer_setting_desense = 1;
		desense->biq0_tbl_desense = 3;		/* maximum 3 - 12 dB */
		desense->biqs_maxgain = 30;
		break;

	/* iLNA-based BTCX desense levels */

	case 21: /* BT power = -30dBm , -35dB */
		/* low desense */
		desense->lna1_rout = 3;
		desense->lna2_rout = 9;
		desense->biq0_tbl_desense = 3;		/* maximum 3 - 12 dB */
		desense->biqs_maxgain = 30;
		break;

	case 22: /* BT power = -20dBm , -25dB */
		/* medium desense */
		desense->lna1_rout = 7;
		desense->lna2_rout = 7;
		desense->biq0_tbl_desense = 3;		/* maximum 3 - 12 dB */
		desense->biqs_maxgain = 30;
		break;

	case 23: /* BT power = -10dBm , -15dB */
		/* high desense */
		desense->lna1_bypass = 1;
		desense->lna1_rout = 0;
		desense->biq0_tbl_desense = 3;		/* maximum 3 - 12 dB */
		desense->biqs_maxgain = 30;
		break;

	case 24: /* BT power = -5dBm , -10dB */
		/* very high desense */
		desense->lna1_bypass = 1;
		desense->lna1_rout = 0;
		desense->lna2_rout = 7;
		desense->biq0_tbl_desense = 2;		/* maximum 2 - 9 dB */
		desense->biqs_maxgain = 30;
		break;

	case 7:
	case 8:
	case 9:
	case 10:
	case 11:
		PHY_ERROR(("Unsupported desense mode\n"));
		break;
	default:
		break;
	}

	/* Apply these settings if this is called while on an active 2g channel */
	if (CHSPEC_IS2G(pi->radio_chanspec) && !SCAN_RM_IN_PROGRESS(pi)) {
		/* If bt desense changed, then reset aci params. But, keep the aci settings intact
		   if bt is switched off (as you will still need aci desense)
		*/
		if (AC4354REV(pi) && (mode != old_mode) && (mode > 0)) {
			/* Disabling HWACI whenever BT desense is applied */
			wlc_phy_desense_aci_reset_params_acphy(pi, TRUE, FALSE);
			pi->sh->btcoex_interference_mode_override = TRUE;
			pi->sh->interference_mode_2G_btcoex = pi->sh->interference_mode_2G & 0xfff9;
			pi->sh->interference_mode = pi->sh->interference_mode_2G_btcoex;
		} else if ((mode != old_mode) && (mode > 0)) {
			/* aci_reset_params one calls total_mitigation also */
			wlc_phy_desense_aci_reset_params_acphy(pi, FALSE, FALSE);
		} else {
			wlc_phy_apply_total_mitigation_acphy(pi);
			pi->sh->btcoex_interference_mode_override = FALSE;
			pi->sh->interference_mode = pi->sh->interference_mode_2G;
		}
	}
}

/********** Desense LTE  ******** */
#ifdef BCMLTECOEX
void
wlc_phy_desense_ltecx_acphy(phy_info_t *pi, int32 mode)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_desense_values_t *desense = &pi_ac->lte_desense;

	/* Start with everything at 0 */
	bzero(desense, sizeof(acphy_desense_values_t));
	pi_ac->ltecx_mode = mode;
	if (pi_ac->ltecx_mode == 0) {
		pi->u.pi_acphy->ltecx_elna_bypass_status = 0;
	}

	switch (mode) {
	case 1: /* LTE - Add new cases in the future */
		desense->ofdm_desense = 24;
		desense->bphy_desense = 24;
		desense->elna_bypass = 1;
		desense->nf_hit_lna12 = 24;
		pi->u.pi_acphy->ltecx_elna_bypass_status = 1;
		break;
	default:
		break;
	}

	/* Apply these settings if this is called while on an active 2g channel */
	if (CHSPEC_IS2G(pi->radio_chanspec) && !SCAN_RM_IN_PROGRESS(pi))
		wlc_phy_apply_total_mitigation_acphy(pi);
}
#endif /* BCMLTECOEX */

static void
wlc_phy_desense_print_phyregs_acphy(phy_info_t *pi, const char str[])
{
}
/**********  DESENSE : ACI, NOISE, BT (end)  ********** */
#endif /* !WLC_DISABLE_ACI */

static uint8
wlc_phy_spurwar_4345(phy_info_t *pi, uint32 xtal_hz, uint8 i,
                     uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES], int8 *tone_id, uint8 *core_sp)
{
	uint32 dn, phy_bw;
	int32 sci, sc, fc, n, ni, df, nstp, max_sc;
	uint32 xtal = xtal_hz / 100000;
	uint16 channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	fc = wf_channel2mhz(channel, CHSPEC_IS5G(pi->radio_chanspec)
			    ? WF_CHAN_FACTOR_5_G : WF_CHAN_FACTOR_2_4_G);

	if (CHSPEC_IS80(pi->radio_chanspec))
		phy_bw = 80;
	else if (CHSPEC_IS40(pi->radio_chanspec))
		phy_bw = 40;
	else
		phy_bw = 20;

	n  = fc * 100 / xtal;
	ni = n / 10;

	if (n - ni * 10 >= 5)
		ni++;

	/* for higher bw may have multiple harmonics */
	dn     = phy_bw * 5 / xtal;
	max_sc = 28 * phy_bw / 20;
	nstp   = ni + dn;
	ni    -= dn;

	for (; ni <= nstp; ni++) {
		df  = (xtal * ni - fc * 10);
		sc  = df * 32;
		sci = sc / 100;

		if ((sci >= -max_sc) && (sci <= max_sc)) {
			*core_sp = 1; /* core 0 */

			if (sci * 100 == sc) {
				tone_id[i + 0] = (int8) sci - 1;
				tone_id[i + 1] = (int8) sci;
				tone_id[i + 2] = (int8) sci + 1;

				noise_var[PHY_CORE_0][i + 0] = 3;
				noise_var[PHY_CORE_0][i + 1] = 9;
				noise_var[PHY_CORE_0][i + 2] = 3;

				PHY_INFORM((
				"applying spurwar (channel %d sub.ch [%d to %d] xtal_int %d)\n",
				channel, sci - 1, sci + 1, xtal / 10));

				i += 3;
			} else {
				sci -= (sci < 0);
				tone_id[i + 0] = (int8) sci;
				tone_id[i + 1] = (int8) sci + 1;

				noise_var[PHY_CORE_0][i + 0] = 9;
				noise_var[PHY_CORE_0][i + 1] = 9;

				PHY_INFORM((
				"applying spurwar (channel %d sub.ch [%d to %d] xtal_int %d)\n",
				channel, sci, sci + 1, xtal / 10));

				i += 2;
			}

		}

	}

	return i;
}

static void
wlc_phy_spurwar_acphy(phy_info_t *pi, uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES],
                            int8 *tone_id, uint8 *core_sp)
{
	uint8 i;
	uint16 channel = 0;

	/* Starting offset for spurwar */
	i = ACPHY_SPURWAR_NTONES_OFFSET;

	channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (!PHY_ILNA(pi) && (pi->u.pi_acphy->srom.spur_war_enb_2g == 1) &&
		(pi->u.pi_acphy->srom.phy4350_ss_opt)) {

		if (ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_1(pi->pubpi.phy_rev) ||
		                                        ACMINORREV_3(pi->pubpi.phy_rev) ||
		                                        ACMINORREV_5(pi->pubpi.phy_rev))) {
					switch (channel) {
					case 4:
							*core_sp = 3;
							tone_id[i+0] = 12;
							tone_id[i+1] = 13;
							noise_var[PHY_CORE_0][i+0] = 0x9;
							noise_var[PHY_CORE_0][i+1] = 0x9;
							noise_var[PHY_CORE_1][i+0] = 0x9;
							noise_var[PHY_CORE_1][i+1] = 0x9;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					case 5:
							*core_sp = 3;
							tone_id[i+0] = -3;
							tone_id[i+1] = -4;
							noise_var[PHY_CORE_0][i+0] = 0x9;
							noise_var[PHY_CORE_0][i+1] = 0x9;
							noise_var[PHY_CORE_1][i+0] = 0x9;
							noise_var[PHY_CORE_1][i+1] = 0x9;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					case 6:
							*core_sp = 3;
							tone_id[i+0] = -20;
							tone_id[i+1] = -19;
							noise_var[PHY_CORE_0][i+0] = 0x9;
							noise_var[PHY_CORE_0][i+1] = 0x9;
							noise_var[PHY_CORE_1][i+0] = 0x9;
							noise_var[PHY_CORE_1][i+1] = 0x9;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					case 11:
							*core_sp = 3;
							tone_id[i+0] = 20;
							tone_id[i+1] = 21;
							noise_var[PHY_CORE_0][i+0] = 0x7;
							noise_var[PHY_CORE_0][i+1] = 0x7;
							noise_var[PHY_CORE_1][i+0] = 0x7;
							noise_var[PHY_CORE_1][i+1] = 0x7;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					case 12:
							*core_sp = 3;
							tone_id[i+0] = 4;
							tone_id[i+1] = 5;
							noise_var[PHY_CORE_0][i+0] = 0x7;
							noise_var[PHY_CORE_0][i+1] = 0x7;
							noise_var[PHY_CORE_1][i+0] = 0x7;
							noise_var[PHY_CORE_1][i+1] = 0x7;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					case 13:
							*core_sp = 3;
							tone_id[i+0] = -12;
							tone_id[i+1] = -11;
							noise_var[PHY_CORE_0][i+0] = 0x7;
							noise_var[PHY_CORE_0][i+1] = 0x7;
							noise_var[PHY_CORE_1][i+0] = 0x7;
							noise_var[PHY_CORE_1][i+1] = 0x7;
							PHY_INFORM(("wlc_phy_spurwar_acphy: "
										"applying spurwar"
										" for channel "
										"%d\n", channel));
							break;
					default:
							break;
	}
			}
	}

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
#define FVCO_4345 963000000
		i = wlc_phy_spurwar_4345(pi, PHY_XTALFREQ(pi->xtalfreq),
		                         i, noise_var, tone_id, core_sp);
		i = wlc_phy_spurwar_4345(pi, FVCO_4345 / 2, i, noise_var, tone_id, core_sp);
	} else if (PHY_ILNA(pi)) {
			/* Spur war for 4354/4354z iLNA board type */
		if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
			(ACMINORREV_1(pi->pubpi.phy_rev) || ACMINORREV_3(pi->pubpi.phy_rev) ||
			ACMINORREV_5(pi->pubpi.phy_rev)) &&
			((RADIOREV(pi->pubpi.radiorev) == 0x27) ||
			(RADIOREV(pi->pubpi.radiorev) == 0x29)) &&
			PHY_XTAL_IS37M4(pi)) {
			/* Spur war for 4354z iPA/iLNA board */
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				switch (channel) {
				case 4:
					*core_sp = 3;
					tone_id[i+0] = 12;
					tone_id[i+1] = 13;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 5:
					*core_sp = 3;
					tone_id[i+0] = -3;
					tone_id[i+1] = -4;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 6:
					*core_sp = 3;
					tone_id[i+0] = -19;
					tone_id[i+1] = -20;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 11:
					*core_sp = 3;
					tone_id[i+0] = 20;
					tone_id[i+1] = 21;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 12:
					*core_sp = 3;
					tone_id[i+0] = 4;
					tone_id[i+1] = 5;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 13:
					*core_sp = 3;
					tone_id[i+0] = -11;
					tone_id[i+1] = -12;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				/* 5G band */
				case 48:
					*core_sp = 2;
					tone_id[i+0] = -12;
					tone_id[i+1] = -13;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 64:
					*core_sp = 2;
					tone_id[i+0] = -29;
					tone_id[i+1] = -30;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 108:
					*core_sp = 2;
					tone_id[i+0] = -15;
					tone_id[i+1] = -16;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 136:
					*core_sp = 2;
					tone_id[i+0] =  15;
					tone_id[i+1] =  16;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				default:
					break;
				}
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				switch (channel) {
				case 3:
					*core_sp = 3;
					tone_id[i+0] = 28;
					tone_id[i+1] = 29;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 4:
					*core_sp = 3;
					tone_id[i+0] = 12;
					tone_id[i+1] = 13;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 5:
					*core_sp = 3;
					tone_id[i+0] = -3;
					tone_id[i+1] = -4;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 6:
					*core_sp = 3;
					tone_id[i+0] = -19;
					tone_id[i+1] = -20;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 7:
					*core_sp = 3;
					tone_id[i+0] = -35;
					tone_id[i+1] = -36;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 8:
					*core_sp = 3;
					tone_id[i+0] = -51;
					tone_id[i+1] = -52;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 9:
					*core_sp = 3;
					tone_id[i+0] =  52;
					tone_id[i+1] =  53;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 10:
					*core_sp = 3;
					tone_id[i+0] =  36;
					tone_id[i+1] =  37;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 11:
					*core_sp = 3;
					tone_id[i+0] = 20;
					tone_id[i+1] = 21;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					noise_var[PHY_CORE_1][i+0] = 0x9;
					noise_var[PHY_CORE_1][i+1] = 0x9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				/* 5G band */
				case 46:
					*core_sp = 2;
					tone_id[i+0] = 19;
					tone_id[i+1] = 20;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 62:
					*core_sp = 2;
					tone_id[i+0] =  2;
					tone_id[i+1] =  3;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 110:
					*core_sp = 2;
					tone_id[i+0] = -47;
					tone_id[i+1] = -48;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				default:
					break;
				}
			} else if (CHSPEC_IS80(pi->radio_chanspec)) {
				switch (channel) {
				case 42:
					*core_sp = 2;
					tone_id[i+0] = 83;
					tone_id[i+1] = 84;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 58:
					*core_sp = 2;
					tone_id[i+0] = 66;
					tone_id[i+1] = 67;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				case 106:
					*core_sp = 2;
					tone_id[i+0] = 16;
					tone_id[i+1] = 17;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 4354iLNA spurwar"
								" for channel %d\n", channel));
					break;
				default:
					break;
				}
			}
			/* Spur war for 43570eLNA */
		} else if ((CHIPID(pi->sh->chip) == BCM43570_CHIP_ID) &&
		           ACMAJORREV_2(pi->pubpi.phy_rev) &&
		           (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev)) &&
		           ((RADIOREV(pi->pubpi.radiorev) == 0x28) ||
		           (RADIOREV(pi->pubpi.radiorev) == 0x2c) ||
		           (RADIOREV(pi->pubpi.radiorev) == 0x2e)) &&
		           (pi->sh->boardtype == BCM943570PCIEHP_SSID) &&
		           PHY_XTAL_IS40M(pi)) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				switch (channel) {
				case 5:
					*core_sp = 2;
					tone_id[i+0] = 25;
					tone_id[i+1] = 26;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 6:
					*core_sp = 2;
					tone_id[i+0] = 9;
					tone_id[i+1] = 10;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 7:
					*core_sp = 2;
					tone_id[i+0] = -7;
					tone_id[i+1] = -6;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 8:
					*core_sp = 2;
					tone_id[i+0] = -23;
					tone_id[i+1] = -22;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 13:
					*core_sp = 2;
					tone_id[i+0] = 25;
					tone_id[i+1] = 26;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				}
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				switch (channel) {
				case 3:
					*core_sp = 2;
					tone_id[i+0] = 57;
					tone_id[i+1] = 58;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 4:
					*core_sp = 2;
					tone_id[i+0] = 41;
					tone_id[i+1] = 42;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 5:
					*core_sp = 2;
					tone_id[i+0] = 25;
					tone_id[i+1] = 26;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 6:
					*core_sp = 2;
					tone_id[i+0] = 9;
					tone_id[i+1] = 10;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 7:
					*core_sp = 2;
					tone_id[i+0] = -7;
					tone_id[i+1] = -6;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 8:
					*core_sp = 2;
					tone_id[i+0] = -22;
					tone_id[i+1] = -23;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 9:
					*core_sp = 2;
					tone_id[i+0] = -39;
					tone_id[i+1] = -38;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 10:
					*core_sp = 2;
					tone_id[i+0] = -55;
					tone_id[i+1] = -54;
					noise_var[PHY_CORE_1][i+0] = 0x3;
					noise_var[PHY_CORE_1][i+1] = 0x3;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				case 11:
					*core_sp = 2;
					tone_id[i+0] = 57;
					tone_id[i+1] = 58;
					noise_var[PHY_CORE_1][i+0] = 0x6;
					noise_var[PHY_CORE_1][i+1] = 0x6;
					PHY_INFORM(("wlc_phy_spurwar_acphy: 43570eLNAPCIEHP spurwar"
								" for channel %d\n", channel));
					break;
				}
			}
		} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		         (RADIOREV(pi->pubpi.radiorev) == 0x28 &&
		         PHY_XTAL_IS40M(pi))) {
			/* Spur war for 43569/43570a0 */
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				switch (channel) {
				case 5:
					*core_sp = 3;
					tone_id[i+0] = 25;
					tone_id[i+1] = 26;
					noise_var[PHY_CORE_0][i+0] = 12;
					noise_var[PHY_CORE_0][i+1] = 15;
					noise_var[PHY_CORE_1][i+0] = 12;
					noise_var[PHY_CORE_1][i+1] = 15;
					break;
				case 6:
					*core_sp = 3;
					tone_id[i+0] = 9;
					tone_id[i+1] = 10;
					noise_var[PHY_CORE_0][i+0] = 12;
					noise_var[PHY_CORE_0][i+1] = 15;
					noise_var[PHY_CORE_1][i+0] = 12;
					noise_var[PHY_CORE_1][i+1] = 15;
					break;
				case 7:
					*core_sp = 3;
					tone_id[i+0] = -6;
					tone_id[i+1] = -7;
					noise_var[PHY_CORE_0][i+0] = 15;
					noise_var[PHY_CORE_0][i+1] = 12;
					noise_var[PHY_CORE_1][i+0] = 15;
					noise_var[PHY_CORE_1][i+1] = 12;
					break;
				case 8:
					*core_sp = 3;
					tone_id[i+0] = -22;
					tone_id[i+1] = -23;
					noise_var[PHY_CORE_0][i+0] = 15;
					noise_var[PHY_CORE_0][i+1] = 12;
					noise_var[PHY_CORE_1][i+0] = 15;
					noise_var[PHY_CORE_1][i+1] = 12;
					break;
				case 13:
					*core_sp = 3;
					tone_id[i+0] = 25;
					tone_id[i+1] = 26;
					noise_var[PHY_CORE_0][i+0] = 12;
					noise_var[PHY_CORE_0][i+1] = 15;
					noise_var[PHY_CORE_1][i+0] = 12;
					noise_var[PHY_CORE_1][i+1] = 15;
					break;
				case 14:
					*core_sp = 3;
					tone_id[i+0] = -12;
					tone_id[i+1] = -13;
					noise_var[PHY_CORE_0][i+0] = 12;
					noise_var[PHY_CORE_0][i+1] = 24;
					noise_var[PHY_CORE_1][i+0] = 12;
					noise_var[PHY_CORE_1][i+1] = 24;
					break;
				}
			}
		} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		           (RADIOREV(pi->pubpi.radiorev) == 0x2C && PHY_XTAL_IS40M(pi))) {
			/* Spur war for 43569/43570a2 is replaced by wlc_acphy_cal_xtal_spur */
			ASSERT(0);

		} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				switch (channel) {
				case 4:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = 12;
					tone_id[i+1] = 13;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 5:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = -3;
					tone_id[i+1] = -4;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 6:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = -19;
					tone_id[i+1] = -20;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 11:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = 20;
					tone_id[i+1] = 21;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 12:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = 4;
					tone_id[i+1] = 5;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 13:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = -11;
					tone_id[i+1] = -12;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
					   " for channel %d\n", channel));
					break;
				default:
					break;
				}
			} else if (CHSPEC_IS40(pi->radio_chanspec)) {
				switch (channel) {
				case 7:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = -35;
					tone_id[i+1] = -36;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				case 8:
					*core_sp = 3; /* core 0 and core 1 */
					tone_id[i+0] = -51;
					tone_id[i+1] = -52;
					noise_var[PHY_CORE_0][i+0] = 9;
					noise_var[PHY_CORE_0][i+1] = 9;
					noise_var[PHY_CORE_1][i+0] = 9;
					noise_var[PHY_CORE_1][i+1] = 9;
					PHY_INFORM(("wlc_phy_spurwar_acphy: applying spurwar"
				            " for channel %d\n", channel));
					break;
				default:
					break;
				}
			}
		} else { /* Not explicitly mentioned anywhere, but this should be for 4339 */
		*core_sp = 1; /* core 0 */
			switch (channel) {
				case 1:
					tone_id[i+0] = 1;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					break;
				case 2:
					tone_id[i+0] = -15;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					break;
				case 4:
					tone_id[i+0] = 1;
					tone_id[i+1] = -1;
					tone_id[i+2] = 12;
					tone_id[i+3] = 13;
					noise_var[PHY_CORE_0][i+0] = 0x4;
					noise_var[PHY_CORE_0][i+1] = 0x4;
					noise_var[PHY_CORE_0][i+2] = 0x2;
					noise_var[PHY_CORE_0][i+3] = 0x9;
					break;
				case 5:
					tone_id[i+0] = -3;
					tone_id[i+1] = -4;
					tone_id[i+2] = 17;
					tone_id[i+3] = 18;
					tone_id[i+4] = 25;
					tone_id[i+5] = 26;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_0][i+2] = 0x5;
					noise_var[PHY_CORE_0][i+3] = 0x2;
					noise_var[PHY_CORE_0][i+4] = 0x3;
					noise_var[PHY_CORE_0][i+5] = 0x4;
					break;
				case 6:
					tone_id[i+0] = 28;
					tone_id[i+1] = 29;
					tone_id[i+2] = -19;
					tone_id[i+3] = -20;
					tone_id[i+4] = 1;
					tone_id[i+5] = 2;
					tone_id[i+6] = 9;
					tone_id[i+7] = 10;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_0][i+2] = 0x9;
					noise_var[PHY_CORE_0][i+3] = 0x3;
					noise_var[PHY_CORE_0][i+4] = 0x5;
					noise_var[PHY_CORE_0][i+5] = 0x2;
					noise_var[PHY_CORE_0][i+6] = 0x3;
					noise_var[PHY_CORE_0][i+7] = 0x4;
					break;
				case 7:
					tone_id[i+0] = 24;
					tone_id[i+1] = 25;
					tone_id[i+2] = -6;
					tone_id[i+3] = -7;
					tone_id[i+4] = -14;
					tone_id[i+5] = -15;
					noise_var[PHY_CORE_0][i+0] = 0x7;
					noise_var[PHY_CORE_0][i+1] = 0x7;
					noise_var[PHY_CORE_0][i+2] = 0x4;
					noise_var[PHY_CORE_0][i+3] = 0x3;
					noise_var[PHY_CORE_0][i+4] = 0x3;
					noise_var[PHY_CORE_0][i+5] = 0x5;
					break;
				case 8:
					tone_id[i+0] = -14;
					tone_id[i+1] = -15;
					tone_id[i+2] = -22;
					tone_id[i+3] = -23;
					tone_id[i+4] = 8;
					tone_id[i+5] = 9;
					noise_var[PHY_CORE_0][i+0] = 0x4;
					noise_var[PHY_CORE_0][i+1] = 0x2;
					noise_var[PHY_CORE_0][i+2] = 0x5;
					noise_var[PHY_CORE_0][i+3] = 0x6;
					noise_var[PHY_CORE_0][i+4] = 0x4;
					noise_var[PHY_CORE_0][i+5] = 0x9;
					break;
				case 9:
					tone_id[i+0] = -7;
					tone_id[i+1] = -8;
					tone_id[i+2] = 25;
					tone_id[i+3] = 26;
					noise_var[PHY_CORE_0][i+0] = 0x8;
					noise_var[PHY_CORE_0][i+1] = 0x3;
					noise_var[PHY_CORE_0][i+2] = 0x4;
					noise_var[PHY_CORE_0][i+3] = 0x5;
					break;
				case 10:
					tone_id[i+0] = 17;
					tone_id[i+1] = 18;
					tone_id[i+2] = -23;
					tone_id[i+3] = -24;
					tone_id[i+4] = 9;
					tone_id[i+5] = 10;
					noise_var[PHY_CORE_0][i+0] = 0x3;
					noise_var[PHY_CORE_0][i+1] = 0x4;
					noise_var[PHY_CORE_0][i+2] = 0x8;
					noise_var[PHY_CORE_0][i+3] = 0x3;
					noise_var[PHY_CORE_0][i+4] = 0x4;
					noise_var[PHY_CORE_0][i+5] = 0x5;
					break;
				case 11:
					tone_id[i+0] = 20;
					tone_id[i+1] = 21;
					tone_id[i+2] = 1;
					tone_id[i+3] = 2;
					noise_var[PHY_CORE_0][i+0] = 0x7;
					noise_var[PHY_CORE_0][i+1] = 0x6;
					noise_var[PHY_CORE_0][i+2] = 0x5;
					noise_var[PHY_CORE_0][i+3] = 0x7;
					break;
				case 12:
					tone_id[i+0] = -14;
					tone_id[i+1] = 4;
					tone_id[i+2] = 5;
					tone_id[i+3] = -22;
					tone_id[i+4] = -23;
					tone_id[i+5] = 25;
					noise_var[PHY_CORE_0][i+0] = 0x4;
					noise_var[PHY_CORE_0][i+1] = 0x8;
					noise_var[PHY_CORE_0][i+2] = 0x7;
					noise_var[PHY_CORE_0][i+3] = 0x7;
					noise_var[PHY_CORE_0][i+4] = 0x7;
					noise_var[PHY_CORE_0][i+5] = 0x5;
					break;
				case 13:
					tone_id[i+0] = -11;
					tone_id[i+1] = -12;
					tone_id[i+2] = 25;
					tone_id[i+3] = 26;
					tone_id[i+4] = 9;
					noise_var[PHY_CORE_0][i+0] = 0x6;
					noise_var[PHY_CORE_0][i+1] = 0x7;
					noise_var[PHY_CORE_0][i+2] = 0x7;
					noise_var[PHY_CORE_0][i+3] = 0x7;
					noise_var[PHY_CORE_0][i+4] = 0x4;
					break;
				case 14:
					tone_id[i+0] = 10;
					tone_id[i+1] = -4;
					tone_id[i+2] = -5;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x4;
					noise_var[PHY_CORE_0][i+2] = 0x4;
					break;
				case 108:
					tone_id[i+0] = -15;
					tone_id[i+1] = -16;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					break;
				case 153:
					tone_id[i+0] = -17;
					tone_id[i+1] = -18;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					break;
				case 161:
					tone_id[i+0] = -25;
					tone_id[i+1] = -26;
					noise_var[PHY_CORE_0][i+0] = 0x9;
					noise_var[PHY_CORE_0][i+1] = 0x9;
					break;
				default:
					break;
			}
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
	           ((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
	            (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
	            (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
	            (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
	           (PHY_XTAL_IS37M4(pi))) {

		switch (channel) {
		case 4:
			*core_sp = 3;
			tone_id[i+0] = 12;
			tone_id[i+1] = 13;
			noise_var[PHY_CORE_0][i+0] = 0x3;
			noise_var[PHY_CORE_0][i+1] = 0x9;
			noise_var[PHY_CORE_1][i+0] = 0x3;
			noise_var[PHY_CORE_1][i+1] = 0x9;
			PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
			            __FUNCTION__, channel));
			break;
		case 5:
			*core_sp = 3;
			tone_id[i+0] = -3;
			tone_id[i+1] = -4;
			noise_var[PHY_CORE_0][i+0] = 0x9;
			noise_var[PHY_CORE_0][i+1] = 0x3;
			noise_var[PHY_CORE_1][i+0] = 0x9;
			noise_var[PHY_CORE_1][i+1] = 0x3;
			PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
			            __FUNCTION__, channel));
			break;
		case 6:
			*core_sp = 3;
			tone_id[i+0] = -19;
			tone_id[i+1] = -20;
			noise_var[PHY_CORE_0][i+0] = 0x9;
			noise_var[PHY_CORE_0][i+1] = 0x3;
			noise_var[PHY_CORE_1][i+0] = 0x9;
			noise_var[PHY_CORE_1][i+1] = 0x3;
			PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
			            __FUNCTION__, channel));
			break;
		}
		if (CHSPEC_IS40(pi->radio_chanspec)) {
			switch (channel) {
			case 3:
				*core_sp = 3;
				tone_id[i+0] = 28;
				tone_id[i+1] = 29;
				noise_var[PHY_CORE_0][i+0] = 9;
				noise_var[PHY_CORE_0][i+1] = 9;
				noise_var[PHY_CORE_1][i+0] = 9;
				noise_var[PHY_CORE_1][i+1] = 9;
				PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
						__FUNCTION__, channel));
				break;
			case 7:
				*core_sp = 3;
				tone_id[i+0] = -35;
				tone_id[i+1] = -36;
				noise_var[PHY_CORE_0][i+0] = 9;
				noise_var[PHY_CORE_0][i+1] = 9;
				noise_var[PHY_CORE_1][i+0] = 9;
				noise_var[PHY_CORE_1][i+1] = 9;
				PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
						__FUNCTION__, channel));
				break;
			case 8:
				*core_sp = 3;
				tone_id[i+0] = -51;
				tone_id[i+1] = -52;
				noise_var[PHY_CORE_0][i+0] = 9;
				noise_var[PHY_CORE_0][i+1] = 9;
				noise_var[PHY_CORE_1][i+0] = 9;
				noise_var[PHY_CORE_1][i+1] = 9;
				PHY_INFORM(("%s: 4350 spurwar nvshp for channel %d\n",
						__FUNCTION__, channel));
				break;
			default:
				break;
			}
		}
	}
}

static void
wlc_phy_spurwar_nvshp_acphy(phy_info_t *pi, bool bw_changed, bool spurwar, bool nvshp)
{
	uint8 i, core;
	uint8 core_nv = 0, core_sp = 0;
	uint8 noise_var[PHY_CORE_MAX][ACPHY_SPURWAR_NV_NTONES];
	int8 tone_id[ACPHY_SPURWAR_NV_NTONES];

	/* Initialize variables */
	for (i = 0; i < ACPHY_SPURWAR_NV_NTONES; i++) {
		tone_id[i]   = 0;
		FOREACH_CORE(pi, core)
			noise_var[core][i] = 0;
	}

	/* Table reset req or not */
	if (nvshp && !bw_changed && !spurwar)
		nvshp = FALSE;

	if (spurwar || nvshp) {
		/* Reset Table */
		wlc_phy_reset_noise_var_shaping_acphy(pi);

		/* Call nvshp */
		if (nvshp)
			wlc_phy_set_noise_var_shaping_acphy(pi, noise_var, tone_id, &core_nv);

		/* Call spurwar */
		if (spurwar)
			wlc_phy_spurwar_acphy(pi, noise_var, tone_id, &core_sp);

		/* Write table
		 * If both nvshp and spurwar tries to write same tone
		 * priority lies with spurwar
		 */
		wlc_phy_noise_var_shaping_acphy(pi, core_nv, core_sp, tone_id, noise_var, 0);
	}
}

static void
wlc_phy_set_noise_var_shaping_acphy(phy_info_t *pi, uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES],
                                             int8 *tone_id, uint8 *core_nv)
{
	uint8 i;

	/* Starting offset for nvshp */
	i = ACPHY_NV_NTONES_OFFSET;

	/* 4335C0 */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		if (!PHY_ILNA(pi)) {
			if (CHSPEC_IS80(pi->radio_chanspec)) {
				static const int8 tone_id_def[] = {-123, -122, -121, -120,
				                                   -119, -118, -117, -116,
				                                   -115, -114, -113, -112,
				                                    112,  113,  114,  115,
				                                    116,  117,  118,  119,
				                                    120,  121,  122,  123};
				static const uint8 noise_var_def[] = {0xF8, 0xF8, 0xF8, 0xF8,
				                                      0xF8, 0xF8, 0xF8, 0xF8,
				                                      0xFA, 0xFA, 0xFC, 0xFE,
				                                      0xFE, 0xFC, 0xFA, 0xFA,
				                                      0xF8, 0xF8, 0xF8, 0xF8,
				                                      0xF8, 0xF8, 0xF8, 0xF8};
				memcpy((tone_id + i), tone_id_def, sizeof(int8)*ACPHY_NV_NTONES);
				memcpy((noise_var[PHY_CORE_0] + i), noise_var_def,
				        sizeof(uint8)*ACPHY_NV_NTONES);
				*core_nv = 1; /* core 0 */
				PHY_INFORM(("wlc_phy_set_noise_var_shaping_acphy:"
				            "applying noise_var shaping for BW 80MHz\n"));
			}
		}
	}
}

static void
wlc_phy_reset_noise_var_shaping_acphy(phy_info_t *pi)
{
	uint8 i;
	uint32 zeroval = 0;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_nshapetbl_mon_t* nshapetbl_mon = &pi_ac->nshapetbl_mon;
	uint8* offset = nshapetbl_mon->offset;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	/* Do table writes only if table has been modified */
	if (nshapetbl_mon->mod_flag) {

		/* Reset only already-modified entries */
		for (i = 0; i < ACPHY_SPURWAR_NV_NTONES; i++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVNOISESHAPINGTBL,
			   1, offset[i], 32, &zeroval);
			PHY_INFORM(("wlc_phy_reset_noise_var_shaping_acphy: offset %d; val 0x00\n",
			            offset[i]));
		}

		/* Invalidate the monitor upon reseting the nvar shaping table */
		nshapetbl_mon->mod_flag = 0;
	}
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_phy_noise_var_shaping_acphy(phy_info_t *pi, uint8 core_nv, uint8 core_sp, int8 *tone_id,
                                        uint8 noise_var[][ACPHY_SPURWAR_NV_NTONES], uint8 reset)
{
	uint8 i, core;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_nshapetbl_mon_t* nshapetbl_mon = &pi_ac->nshapetbl_mon;
	uint8* offset = nshapetbl_mon->offset;
	uint32 tbllen;
	uint32 nvar;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		/* 80mhz */
		tbllen = 256;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		/* 40mhz */
		tbllen = 128;
	} else {
		/* 20mhz */
		tbllen = 64;
	}

	/* total tones should be equal to (nvshp + sp) tones */
	ASSERT(ACPHY_SPURWAR_NV_NTONES == ACPHY_NV_NTONES + ACPHY_SPURWAR_NTONES);

	for (i = 0; i < ACPHY_SPURWAR_NV_NTONES; i++) {
		nvar = 0;
		/* Wrap around up to tbllen */
		offset[i] = (tone_id[i] >= 0)? tone_id[i] : (tbllen + tone_id[i]);
		/* Using separate core value to have flexibility
		 * of doing nvshp & spurwar on different cores
		 * for multiple core chips without increasing
		 * number of table writes
		 */
		FOREACH_CORE(pi, core) {
			if (i < ACPHY_NV_NTONES) {
				nvar |= (core_nv & (0x1 << core))? ((noise_var[core][i] << 8*core) &
					(0xFF << 8*core)): 0x0; /* nvshp tones */
			} else {
				nvar |= (core_sp & (0x1 << core))? ((noise_var[core][i] << 8*core) &
					(0xFF << 8*core)): 0x0; /* spurwar tones */
			}
		}

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_NVNOISESHAPINGTBL,
		                          1, offset[i], 32, &nvar);

		PHY_INFORM(("wlc_phy_reset_noise_var_shaping_acphy: offset %d; val 0x%x\n",
		            offset[i], nvar));
	}
	/* activate monitor flag */
	nshapetbl_mon->mod_flag = 1;
	ACPHY_ENABLE_STALL(pi, stall_val);
}

static bool
wlc_phy_is_scan_chan_acphy(phy_info_t *pi)
{
	return (SCAN_RM_IN_PROGRESS(pi) &&
	        (pi->interf.curr_home_channel != CHSPEC_CHANNEL(pi->radio_chanspec)));
}

#if defined(SAMPLE_COLLECT) || defined(PHY_XTAL_SPUR_CAL)

/* channel to frequency conversion */
static int
wlc_phy_chan2fc_acphy(uint channel)
{
	/* go from channel number (such as 6) to carrier freq (such as 2442) */
	if (channel >= 184 && channel <= 228)
		return (channel*5 + 4000);
	else if (channel >= 32 && channel <= 180)
		return (channel*5 + 5000);
	else if (channel >= 1 && channel <= 13)
		return (channel*5 + 2407);
	else if (channel == 14)
		return (2484);
	else
		return -1;
}

#endif /* SAMPLE_COLLECT || PHY_XTAL_SPUR_CAL */

#ifdef SAMPLE_COLLECT

static uint16
acphy_words_per_us(phy_info_t *pi, uint16 sd_adc_rate, uint16 mo)
{
	uint16 words_per_us = sd_adc_rate / 4;
	uint16 sampRate;
	uint8 md_datapath_os = (ACMAJORREV_3(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev))
	                           ? 2 : 1;

	/* For more comments on how "words_per_us"is calculated, check the d11samples.tcl file */

	switch (mo)
		{
		case SC_MODE_0_sd_adc:

			sampRate = sd_adc_rate;
			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					words_per_us = sampRate/2;
					break;
				case WL_CHANSPEC_BW_40:
					words_per_us = sampRate/4;
					break;
				case WL_CHANSPEC_BW_80:
					words_per_us = sampRate/4;
					break;
				default:
					/* Default 20MHz */
					words_per_us = sampRate/2;
					ASSERT(0); /* should never get here */
					break;
			}
			break;

		case SC_MODE_1_sd_adc_5bits:

			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = sd_adc_rate;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = sd_adc_rate/2;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = sd_adc_rate/2;
					break;
				default:
					/* Default 20MHz */
					sampRate = sd_adc_rate;
					ASSERT(0); /* should never get here */
					break;
			}
			words_per_us = sampRate / 2;
			break;

		case SC_MODE_2_cic0:

			sampRate  = sd_adc_rate / 2;

			words_per_us = sampRate;
			break;

		case SC_MODE_3_cic1:

			sampRate  = sd_adc_rate / 4;

			words_per_us = sampRate;

			break;
		case SC_MODE_4s_rx_farrow_1core:
		case SC_MODE_5s_iq_comp:
		case SC_MODE_6s_dc_filt:
			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20 * 2;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40 * 2;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80 * 2;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20 * 2;
					ASSERT(0); /* should never get here */
					break;
			}
			sampRate /= md_datapath_os;
			words_per_us = sampRate;
			break;

		case SC_MODE_4m_rx_farrow:
		case SC_MODE_5_iq_comp:
		case SC_MODE_6_dc_filt:
		case SC_MODE_8_rssi:
		case SC_MODE_9_rssi_all:

			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20 * 2;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40 * 2;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20 * 2;
					ASSERT(0); /* should never get here */
					break;
			}
			if ((mo == SC_MODE_5_iq_comp) || (mo == SC_MODE_6_dc_filt))
				sampRate /= 2;

			words_per_us = sampRate * 2;
			break;

		case SC_MODE_7_rx_filt:
			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80 / 2;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20;
					ASSERT(0); /* should never get here */
					break;
			}
			words_per_us = sampRate * 4;
			break;

		case SC_MODE_7s_rx_filt:
			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20;
					ASSERT(0); /* should never get here */
					break;
			}
			words_per_us = sampRate;
			break;

		case SC_MODE_10_tx_farrow:
			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20 * 4;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40 * 4;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80 * 2;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20;
					ASSERT(0); /* should never get here */
					break;
			}
			sampRate /= md_datapath_os;
			words_per_us = sampRate;
			break;

		case SC_MODE_11_gpio:

			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20 * 4;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40 * 4;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20;
					ASSERT(0); /* should never get here */
					break;
			}
			words_per_us = sampRate;
			break;

		case SC_MODE_12_gpio_trans:

			switch (pi->bw) {
				case WL_CHANSPEC_BW_20:
					sampRate = 20 * 4;
					break;
				case WL_CHANSPEC_BW_40:
					sampRate = 40 * 2;
					break;
				case WL_CHANSPEC_BW_80:
					sampRate = 80 / 2;
					break;
				default:
					/* Default 20MHz */
					sampRate = 20;
					ASSERT(0); /* should never get here */
					break;
			}
			words_per_us = sampRate * 2;

			break;

		case SC_MODE_14_spect_ana:

			words_per_us = sd_adc_rate;

			break;
	}
	return words_per_us;
}

static uint32
wlc_phy_sample_collect_set_pmu_chipctl5(const phy_info_t *pi)
{
	uint32 pmu_chipctReg5 = si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL5, 0, 0);
	uint32 pmu_chipctReg5_orig = pmu_chipctReg5;
	uint32 use_backend_clk_for_sample_sync_clk = 0;
	uint32 use_backend_clk_for_mac_clk = 0;

	pmu_chipctReg5 |= (0xffff << 16);

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		pmu_chipctReg5 = (pmu_chipctReg5 & 0x1036ffff) |
		                 (use_backend_clk_for_sample_sync_clk << 29) |
		                 (use_backend_clk_for_mac_clk << 30);
	} else {
		/*
		 * For 20 and 40MHz Mode 0 will be active which means
		 * I and Q are packed in 32bits word
		 */
		pmu_chipctReg5 = (pmu_chipctReg5 & 0x100effff) |
		                 (use_backend_clk_for_sample_sync_clk << 29) |
		                 (use_backend_clk_for_mac_clk << 30);
	}
	si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL5, 0xFFFFFFFF, pmu_chipctReg5);

	return pmu_chipctReg5_orig;
}

#endif /* SAMPLE_COLLECT */

#if defined(SAMPLE_COLLECT) || defined(PHY_XTAL_SPUR_CAL)

/* Get the offset / length for the sample capture buffer in BM
 * Note that the BM is also used by ucode and Tx/Rx buffering so an allocation will
 * overwrite memory that is normally used for other things
 */
static void
wlc_phy_get_sc_buff_offs_len(phy_info_t *pi, uint32 needed, uint32 *sc_buff_offset,
		uint32 *sc_buff_length)
{
	uint32 szbytes;
	uint32 offset;

	/* get Buffer length length in words */
	if ((D11REV_IS(pi->sh->corerev, 48) || D11REV_IS(pi->sh->corerev, 49)) &&
			(needed <= 80*1024)) {
		/* CRWLDOT11M-1160: the first 80KB of bmc is unused for MAC due to the SR WAR */
		szbytes = 80*1024;
		offset = 0;
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
		szbytes = 192*1024;
		offset = 0;
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		szbytes = 320*1024;
		offset = 128 * 1024 >> 2;
	} else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		szbytes = 576*1024;
		offset = 192 * 1024 >> 2;
	} else {
		szbytes = 512*1024;
		offset = 0;
	}
	*sc_buff_offset = offset;
	*sc_buff_length = szbytes >> 2;
}

/* Code to do the actual sample collect for timer == now.
 * Returs TRUE if okay, FALSE if timed out
 */
static bool
wlc_phy_sample_collect_now(phy_info_t *pi, wl_samplecollect_args_t *collect,
                           const uint32 sc_buff_start)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8 sample_capture_pointer_timeout_max_retries = 10;

	uint32 phy_ctl;
	uint32 timer = collect->timeout;

	acphy_set_sc_stopptr(pi, pi_ac->pstop);

	/* set Stop bit and Start bit (start capture) */
	phy_ctl = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
	/* no trigger flags collect (turn off just to be sure) */
	wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_BMP, 0x0);
	if (collect->mode == SC_MODE_12_gpio_trans) {
		/* For GPIO tranisition mode do continuous sample collect */
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl | (1 << 4));
	} else {
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl | (1 << 4) | (1 << 5));

		sample_capture_pointer_timeouts = 0;

		/* wait until done */
		do {
			OSL_DELAY(10);
			timer--;

			/* Check for a stuck sample collect pointer - SW4345-88 */
			if (CHIPID(pi->sh->chip) == BCM4345_CHIP_ID &&
			    acphy_get_sc_curptr(pi) == 0 &&
			    sample_capture_pointer_timeouts <
			    sample_capture_pointer_timeout_max_retries) {

				PHY_ERROR(("%s: sample capture pointer got stuck "
					   "- retriggering - attempt %i\n",
					   __FUNCTION__, sample_capture_pointer_timeouts));

				/* timeout count for ATE */
				++sample_capture_pointer_timeouts;

				/* Rearm the main timeout timer */
				timer = collect->timeout;

				/* clear start/stop bits */
				W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param,
				      phy_ctl & 0xFFCF);

				/* reset the start and stop pointers */
				acphy_set_sc_startptr(pi, sc_buff_start);
				acphy_set_sc_stopptr(pi, pi_ac->pstop);

				/* Also need to kick the phy with a ResetCCA. */
				wlc_phy_resetcca_acphy(pi);

				/* set Stop bit and Start bit (start capture) */
				phy_ctl = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
				wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_BMP, 0x0);
				W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param,
				      phy_ctl | (1 << 4) | (1 << 5));
			}
		} while (!acphy_is_sc_done(pi) && timer > 0);
	}

	/* Restore PHY_CTL to its original state */
	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl);

	/* set start/stop pointers for readout */
	pi_ac->pfirst = acphy_get_sc_startptr(pi);
	pi_ac->plast = acphy_get_sc_curptr(pi);

	return (timer > 0);
}

#endif /* SAMPLE_COLLECT || PHY_XTAL_SPUR_CAL */

#ifdef SAMPLE_COLLECT

#define FILE_HDR_LEN 20 /* words */
/* (FIFO memory is 176kB = 45056 x 32bit) */

int
wlc_phy_sample_collect_acphy(phy_info_t *pi, wl_samplecollect_args_t *collect, uint32 *buf)
{
	uint32 needed;
	uint32 sc_buff_length, sc_buff_offs, sc_buff_start, sc_buff_end;
	uint16 sd_adc_rate;
	uint16 save_gpio;
	int coreSel = 0;
	uint32 mo = 0xffff;
	int bitStartVal = 2;
	uint32 timer, cnt;
	uint16 val;
	uint16 words_per_us = 0;
	uint16 fc = (uint16)wlc_phy_chan2fc_acphy(CHSPEC_CHANNEL(pi->radio_chanspec));
	uint8 core, gpio_collection = 0;
	uint32 *ptr;
	phy_info_acphy_t *pi_ac;
	wl_sampledata_t *sample_data;
	int16 agc_gain[PHY_CORE_NUM_4];
	bool downSamp = FALSE;
	uint index;
	uint16 fft_sampRate = 0;
	uint16 macBasedDACPlayEn_save = 0;
	uint16 forceFront_save[PHY_CORE_MAX];
	uint8 RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save;
	/* subtract from ADC sample power to obtain true analog power in dBm */
	uint16 dBsample_to_dBm_sub;
	uint8 sample_rate, sample_bitwidth;
	uint8 support_spectrum_analyzer_mode;
	uint16 num_cores = PHYCORENUM(pi->pubpi.phy_corenum);
	uint32 pmu_chipctReg5_def = 0;
	uint32 pmu_chip_ctl_regupdate = 0;
	uint32 mac_ctl;

	ASSERT(pi);
	pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	if (!pi_ac)
		return BCME_ERROR;

	mac_ctl = R_REG(pi->sh->osh, &pi->regs->maccontrol);

	/*
	 * In 4345A0, to avoid glitches in the captured samples, suspending MAC or
	 * just disabling MAC PSM were found to help.
	 */
	if (CHIPID(pi->sh->chip) == BCM4345_CHIP_ID) {
		/* disable mac psm */
		W_REG(pi->sh->osh, &pi->regs->maccontrol, (mac_ctl & ~MCTL_PSM_RUN));
	}

	/* Initializing the agc gain */
	for (index = 0; index < PHY_CORE_NUM_4; index++) {
		agc_gain[index] = 0;
	}

	/* initial return info pointers */
	sample_data = (wl_sampledata_t *)buf;
	ptr = (uint32 *)&sample_data[1];
	bzero((uint8 *)sample_data, sizeof(wl_sampledata_t));
	sample_data->version = htol16(WL_SAMPLEDATA_T_VERSION);
	sample_data->size = htol16(sizeof(wl_sampledata_t));

	/* Store MAC based sample play information */
	macBasedDACPlayEn_save = READ_PHYREGFLD(pi, macbasedDACPlay, macBasedDACPlayEn);

	/* Store forceFront register as it may be modified while setting up the samode capture */
	FOREACH_CORE(pi, core) {
		forceFront_save[core] =  READ_PHYREGCE(pi, forceFront, core);
	}

	/* Store RxFeTesMmuxCtrl register */
	RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save =  READ_PHYREGFLD(pi, RxFeTesMmuxCtrl,
	                                                        rxfe_dbg_mux_sel);

	if (fc < 5180) {
		/* 2G channel */
		switch (pi->bw) {
			case WL_CHANSPEC_BW_20:
				sd_adc_rate = fc * 3/ 32;
				break;
			case WL_CHANSPEC_BW_40:
				sd_adc_rate = fc * 3/16;
				break;
			case WL_CHANSPEC_BW_80:
				sd_adc_rate = fc * 3/12;
				break;
			default:
				/* Default 20MHz */
				sd_adc_rate = fc * 3/ 32;
				ASSERT(0); /* should never get here */
				break;
		}
	} else {
		/* 5G channel */
		switch (pi->bw) {
			case WL_CHANSPEC_BW_20:
				sd_adc_rate = fc/24;
				break;
			case WL_CHANSPEC_BW_40:
				sd_adc_rate = fc/12;
				break;
			case WL_CHANSPEC_BW_80:
				sd_adc_rate = fc/9;
				break;
			default:
				/* Default 20MHz */
				sd_adc_rate = fc/24;
				ASSERT(0); /* should never get here */
				break;
		}
	}

	WRITE_PHYREG(pi, AdcDataCollect, 0);
	WRITE_PHYREG(pi, RxFeTesMmuxCtrl, 0);

	/* 4360A0/A2, 4335A0/B0, 4345 do not have the spectrum analyzer mode */
	if (ACREV_IS(pi->pubpi.phy_rev, 0) ||
	    ACREV_IS(pi->pubpi.phy_rev, 2) || ACREV_IS(pi->pubpi.phy_rev, 5) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		support_spectrum_analyzer_mode = 0;
	} else {
		support_spectrum_analyzer_mode = 1;
		if (ACREV_IS(pi->pubpi.phy_rev, 1))
			PHY_REG_WRITE(pi, ACPHY, SpectrumAnalyzerMode(1), 0);
		else /* phyrev!=0 && phyrev !=1  */
			PHY_REG_WRITE(pi, ACPHY, SpectrumAnalyzerMode(2), 0);
		if (!ACREV_IS(pi->pubpi.phy_rev, 1))
			WRITE_PHYREG(pi, SpecAnaDataCollect, 0);
	}

	switch (collect->mode)
		{
		case SC_MODE_0_sd_adc:

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, RxFeTesMmuxCtrl, samp_coll_core_sel, coreSel);
			MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, 0);

			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]    - mode id=0
			*/
			mo = ((coreSel << 12) | (1 << 8) | 0);

			/*  	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us  = acphy_words_per_us(pi, sd_adc_rate, SC_MODE_0_sd_adc);

			break;

		case  SC_MODE_1_sd_adc_5bits:

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, RxFeTesMmuxCtrl, samp_coll_core_sel, coreSel);
			MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, 1);

			if (pi->bw == WL_CHANSPEC_BW_40 || pi->bw == WL_CHANSPEC_BW_80) {
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]    - mode id=1
			*/
			mo = ((coreSel << 12) | (1 << 8) | 1);

			/*  	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi, sd_adc_rate, SC_MODE_1_sd_adc_5bits);

			break;

		case  SC_MODE_2_cic0:

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, RxFeTesMmuxCtrl, samp_coll_core_sel, coreSel);
			MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, 2);

			if (pi->bw == WL_CHANSPEC_BW_40 || pi->bw == WL_CHANSPEC_BW_80) {
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]    - mode id=2
			*/
			mo = ((coreSel << 12) | (1 << 8) | 2);

			/*  	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi, sd_adc_rate, SC_MODE_2_cic0);

			break;

		case SC_MODE_3_cic1:

			if (pi->bw == WL_CHANSPEC_BW_80) {
				return BCME_ERROR;
			}

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, RxFeTesMmuxCtrl, samp_coll_core_sel, coreSel);
			MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, 3);

			/*	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=3
			*/
			mo = ((coreSel << 12) | (1 << 8) | 3);

			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi, sd_adc_rate, SC_MODE_3_cic1);

			break;

		case  SC_MODE_4s_rx_farrow_1core:
			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, RxFeTesMmuxCtrl, samp_coll_core_sel, coreSel);
			MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, 4);

			/*	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=4
			*/
			mo = ((coreSel << 12) | (1 << 8) | 4);

			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi, sd_adc_rate,
				SC_MODE_4s_rx_farrow_1core);

			if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID) {
				/* Incase of 4335, 4 samples are packed into 3 words
				   (32bits per word)
				 */
				words_per_us = (words_per_us * 3) >> 2;
			}

			if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
				pmu_chipctReg5_def = wlc_phy_sample_collect_set_pmu_chipctl5(pi);
				pmu_chip_ctl_regupdate = 1;
			}

			/* Special mode for BCM43457A0/B0, BCM4345B0/B1 (CRDOT11ACPHY-590) */
			if (ACMAJORREV_3(pi->pubpi.phy_rev) &&
			    !ACMINORREV_0(pi->pubpi.phy_rev) && !ACMINORREV_1(pi->pubpi.phy_rev)) {
				MOD_PHYREG(pi, SpecAnaDataCollect, pktprocMuxEn, 1);
			}
			break;

		case SC_MODE_4m_rx_farrow:

			bitStartVal = collect->bitStart;
			if ((bitStartVal < 0) || (bitStartVal > 2)) {
				bitStartVal = 2;
			}

			MOD_PHYREG(pi, AdcDataCollect, bitStart, bitStartVal);
			MOD_PHYREG(pi, AdcDataCollect, sampSel, 4);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/*	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=4
			*/

			mo = ((coreSel << 12) | (num_cores << 8) | 4);

			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi, sd_adc_rate, SC_MODE_4m_rx_farrow);

			break;

		case  SC_MODE_5_iq_comp:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 5);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - always 0
				bits [11:8]   - number of cores (always 3)
				bits [7:0]	  - mode id=5
			*/
			mo = ((num_cores << 8) | 5);

			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_5_iq_comp);

			break;

		case  SC_MODE_5s_iq_comp:

			if (ACREV_IS(pi->pubpi.phy_rev, 0) ||
			    ACREV_IS(pi->pubpi.phy_rev, 1) ||
			    ACREV_IS(pi->pubpi.phy_rev, 2) ||
			    ACREV_IS(pi->pubpi.phy_rev, 5)) {
				PHY_ERROR(("IQ_comp singlecore is not supported"
				           " on phy rev 0, 1, 2, and 5\n"));
				return BCME_UNSUPPORTED;
			}
			MOD_PHYREG(pi, AdcDataCollect, sampSel, 5);

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}
			MOD_PHYREG(pi, AdcDataCollect, rxCoreSel, coreSel);
			MOD_PHYREG(pi, AdcDataCollect, rxSingleCoreMode, 1);

			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=5
			*/
			mo = ((coreSel << 12) | (1 << 8) | 5);

			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_5s_iq_comp);

			break;

		case  SC_MODE_6_dc_filt:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 6);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - always 0
				bits [11:8]   - number of cores (always 3)
				bits [7:0]	  - mode id=6
			*/
			mo = ((num_cores << 8) | 6);
			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_6_dc_filt);

			if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
				pmu_chipctReg5_def = wlc_phy_sample_collect_set_pmu_chipctl5(pi);
				pmu_chip_ctl_regupdate = 1;
			}
			break;

		case  SC_MODE_6s_dc_filt:

			if (ACREV_IS(pi->pubpi.phy_rev, 0) ||
			    ACREV_IS(pi->pubpi.phy_rev, 1) ||
			    ACREV_IS(pi->pubpi.phy_rev, 2) ||
			    ACREV_IS(pi->pubpi.phy_rev, 5)) {
				PHY_ERROR(("DC_filt singlecore is not supported"
				           " on phy rev 0,1,2 and 5\n"));
				return BCME_UNSUPPORTED;
			}
			MOD_PHYREG(pi, AdcDataCollect, sampSel, 6);
			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}
			MOD_PHYREG(pi, AdcDataCollect, rxCoreSel, coreSel);
			MOD_PHYREG(pi, AdcDataCollect, rxSingleCoreMode, 1);
			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=6
			*/
			mo = ((coreSel << 12) | (1 << 8) | 6);
			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_6s_dc_filt);

			if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
				pmu_chipctReg5_def = wlc_phy_sample_collect_set_pmu_chipctl5(pi);
				pmu_chip_ctl_regupdate = 1;
			}
			break;

		case  SC_MODE_7_rx_filt:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 7);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - always 0
				bits [11:8]   - number of cores (always 3)
				bits [7:0]	  - mode id=7
			*/
			mo = ((num_cores << 8) | 7);
			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_7_rx_filt);

			if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
				pmu_chipctReg5_def = wlc_phy_sample_collect_set_pmu_chipctl5(pi);
				pmu_chip_ctl_regupdate = 1;
			}
			break;

		case  SC_MODE_7s_rx_filt:
			if (ACREV_IS(pi->pubpi.phy_rev, 0) ||
			    ACREV_IS(pi->pubpi.phy_rev, 1) ||
			    ACREV_IS(pi->pubpi.phy_rev, 2) ||
			    ACREV_IS(pi->pubpi.phy_rev, 5)) {
				PHY_ERROR(("rx_filt singlecore is not supported"
				            "on phy rev 0,1,2 and 5\n"));
				return BCME_UNSUPPORTED;
			}
			MOD_PHYREG(pi, AdcDataCollect, sampSel, 7);
			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}
			MOD_PHYREG(pi, AdcDataCollect, rxCoreSel, coreSel);
			MOD_PHYREG(pi, AdcDataCollect, rxSingleCoreMode, 1);
			/* 	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=7
			*/
			mo = ((coreSel << 12) | (1 << 8) | 7);
			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_7s_rx_filt);

			if (!ACMAJORREV_5(pi->pubpi.phy_rev)) {
				pmu_chipctReg5_def = wlc_phy_sample_collect_set_pmu_chipctl5(pi);
				pmu_chip_ctl_regupdate = 1;
			}
			break;

		case  SC_MODE_8_rssi:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 8);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/*	Mode
				bits [15:12]  - always 0
				bits [11:8]   - number of cores (always 3)
				bits [7:0]	  - mode id=8
			*/
			mo = ((num_cores << 8) | 8);
			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_8_rssi);

			break;

		case  SC_MODE_9_rssi_all:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 9);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/*	Mode
				bits [15:12]  - always 0
				bits [11:8]   - number of cores (always 3)
				bits [7:0]	  - mode id=9
			*/
			mo = ((num_cores << 8) | 9);

			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate, SC_MODE_9_rssi_all);
			break;

		case  SC_MODE_10_tx_farrow:

			MOD_PHYREG(pi, AdcDataCollect, sampSel, 10);

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			MOD_PHYREG(pi, AdcDataCollect, txCoreSel, coreSel);

			if (pi->bw == WL_CHANSPEC_BW_80) {
				MOD_PHYREG(pi, AdcDataCollect, downSample, 1);
				downSamp = 1;
			}

			/* 	Mode
				bits [15:12]  - Tx coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=10
			*/
			mo = ((coreSel << 12) | (1 << 8) | 10);

			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate,  SC_MODE_10_tx_farrow);

			break;

		case  SC_MODE_11_gpio:

			save_gpio = READ_PHYREG(pi, gpioSel);

			/* Writing to lower 8 bits */
			WRITE_PHYREG(pi, gpioSel, ((save_gpio & 0xFF00)| collect->gpio_sel));

			MOD_PHYREG(pi, AdcDataCollect, gpioMode, 0);
			MOD_PHYREG(pi, AdcDataCollect, gpioSel,  1);

			gpio_collection = 1;

			mo = 0xFF;

			/* 	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate,  SC_MODE_11_gpio);

			break;

		case  SC_MODE_12_gpio_trans:

			save_gpio = READ_PHYREG(pi, gpioSel);

			/* Writing to lower 8 bits */
			WRITE_PHYREG(pi, gpioSel, ((save_gpio & 0xFF00)| collect->gpio_sel));

			WRITE_PHYREG(pi, gpioCapMaskHigh, ((collect->gpioCapMask >> 16) & 0xFFFF));
			WRITE_PHYREG(pi, gpioCapMaskLow, (collect->gpioCapMask  & 0xFFFF));

			MOD_PHYREG(pi, AdcDataCollect, gpioMode, 1);
			MOD_PHYREG(pi, AdcDataCollect, gpioSel,  1);

			gpio_collection = 1;

			mo = 0x1FF;

			/*	Determine how many words need to be placed in the MAC buffer
				to capture 1us of the signal, in this sample capture mode
			*/
			words_per_us = acphy_words_per_us(pi,  sd_adc_rate,  SC_MODE_12_gpio_trans);

			break;

		case  SC_MODE_14_spect_ana:

			if (support_spectrum_analyzer_mode == 0) {
				PHY_ERROR(("FFT is not supported on phy rev 0, 2, 4, and 5\n"));
				return BCME_UNSUPPORTED;
			}

			if (ACREV_IS(pi->pubpi.phy_rev, 1)) {
				if (IS20MHZ(pi)) {
					MOD_PHYREG(pi, AdcDataCollect, specAnaModeDs, 1);
					fft_sampRate = 20;
				} else if (IS40MHZ(pi)) {
					MOD_PHYREG(pi, AdcDataCollect, specAnaModeDs, 0);
					fft_sampRate = 40;
				} else {
					MOD_PHYREG(pi, AdcDataCollect, specAnaModeDs, 3);
					fft_sampRate = 80;
				}
			} else {
				if (IS20MHZ(pi)) {
					MOD_PHYREG(pi, SpecAnaDataCollect, specAnaModeDs, 1);
					fft_sampRate = 20;
				} else if (IS40MHZ(pi)) {
					MOD_PHYREG(pi, SpecAnaDataCollect, specAnaModeDs, 0);
					fft_sampRate = 40;
				} else {
					MOD_PHYREG(pi, SpecAnaDataCollect, specAnaModeDs, 3);
					fft_sampRate = 80;
				}
			}

			coreSel = collect->cores;
			if ((coreSel < 0) || (coreSel > 2)) {
				coreSel = 0;
			}

			/* reset CCA */
			wlc_phy_resetcca_acphy(pi);

			if (ACREV_IS(pi->pubpi.phy_rev, 1)) {
				MOD_PHYREG(pi, SpectrumAnalyzerMode, saModeChan, coreSel);

				MOD_PHYREG(pi, fdiqi_rx_controller_bits,
				           max_no_of_symbols, 0);
				MOD_PHYREG(pi, rxfdiqImbCompCtrl,
				           calibration_notoperation, 1);

				MOD_PHYREG(pi, SpectrumAnalyzerMode, saModeEn, 1);
				MOD_PHYREG(pi, AdcDataCollect, specAnaMode, 1);
			} else { /* phyrev >=2 */

				MOD_PHYREG(pi, SpecAnaDataCollect,
				           specAnaModeChanSel, coreSel);
				MOD_PHYREG(pi, SpectrumAnalyzerMode, specAnaModeEn, 1);
				MOD_PHYREG(pi, SpecAnaDataCollect, specAnaMode, 1);
				FOREACH_CORE(pi, core) {
					MOD_PHYREGCE(pi, forceFront, core, freqEst, 1);
				}
			}

			/*	Mode
				bits [15:12]  - coreSel
				bits [11:8]   - number of cores (always 1)
				bits [7:0]	  - mode id=254
			*/
			mo = ((coreSel << 12) | (1 << 8) | 254);

			words_per_us = acphy_words_per_us(pi, fft_sampRate, SC_MODE_14_spect_ana);
			break;

		default:
			break;
	}

	if (gpio_collection == 0) {
		MOD_PHYREG(pi, AdcDataCollect, adcDataCollectEn, 1);
	}

	/* Get the offset and the size of the sample capture buffer */
	needed = (collect->pre_dur + collect->post_dur) * words_per_us;
	wlc_phy_get_sc_buff_offs_len(pi, needed, &sc_buff_offs, &sc_buff_length);

	if (macBasedDACPlayEn_save == 1) {
		/* If MAC based sample play is being used, use only half the TX FIFO for */
		/* sample capture, unless user specifies a non-zero startptr value */
		sc_buff_start = sc_buff_length >> 1;
	}
	else {
		sc_buff_start = 0;
	}
	sc_buff_start   = sc_buff_start + sc_buff_offs;
	sc_buff_end     = sc_buff_length + sc_buff_offs;

	/* duration(s): length sanity check and mapping from "max" to usec values */
	if (needed > sc_buff_length) {
		PHY_ERROR(("wl%d: %s: Bad Duration Option\n", pi->sh->unit, __FUNCTION__));
		return BCME_RANGE;
	}

	/* be deaf if requested (e.g. for spur measurement) */
	if (collect->be_deaf) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	}

	/* perform AGC if requested */
	if (collect->agc) {
		/* Backup gain config prior to gain control --- Not beng implemented at the moment.
		wlc_phy_agc_rxgain_config_acphy(pi, TRUE);
		wlc_phy_agc_acphy(pi, agc_gain);
		*/
	} else {
		/* Set reported agc gains to init_gain with gain_error correction */
		int16 gainerr[PHY_CORE_MAX];

		wlc_phy_get_rxgainerr_phy(pi, gainerr);
		FOREACH_CORE(pi, core) {
			/* gainerr is in 0.5dB steps; needs to be rounded to nearest dB */
			int16 tmp = gainerr[core];
			tmp = ((tmp >= 0) ? ((tmp + 1) >> 1) : -1*((-1*tmp + 1) >> 1));
			agc_gain[core] = ACPHY_NOISE_INITGAIN + tmp;
		}
	}

	/* Apply filter settings if requested */
	if (collect->filter) {
		/* Override the LPF high pass corners to their lowest values (0x1) */
		wlc_phy_lpf_hpc_override_acphy(pi, TRUE);
	}

	/* set Tx-FIFO collect start pointer to sc_buff_start */
	acphy_set_sc_startptr(pi, sc_buff_start);

	PHY_TRACE(("wl%d: %s Start capture, trigger = %d\n", pi->sh->unit, __FUNCTION__,
		collect->trigger));

	timer = collect->timeout;

	PHY_TRACE(("wl%d: %s Start capture, timer = %d\n", pi->sh->unit, __FUNCTION__,
		collect->timeout));

	/* immediate trigger */
	if (collect->trigger == TRIGGER_NOW) {

		/* compute and set stop pointer */
		pi_ac->pstop = sc_buff_start +
			(collect->pre_dur + collect->post_dur) * words_per_us;

		if (pi_ac->pstop >= sc_buff_end - 1)
			pi_ac->pstop = sc_buff_end - 1;

		/* wlc_phy_sample_collect_now return FALSE if things timed out,
		 * later timer is checked to be zero and an error is returned
		 */
		timer = wlc_phy_sample_collect_now(pi, collect, sc_buff_start) ? 1 : 0;

	} else {
		uint32 dur_1_8th_us;
		uint32 phy_ctl;
		uint16 bred;

		/* enable mac and run psm */
		W_REG(pi->sh->osh, &pi->regs->maccontrol, mac_ctl | MCTL_PSM_RUN | MCTL_EN_MAC);

		/* set stop pointer */
		pi_ac->pstop = sc_buff_end - 1;

		acphy_set_sc_stopptr(pi, pi_ac->pstop);

		/* set up post-trigger duration (expected by ucode in units of 1/8 us) */
		bred = R_REG(pi->sh->osh, &pi->regs->psm_bred_3);
		W_REG(pi->sh->osh, &pi->regs->psm_bred_3, bred | 0x10);
		dur_1_8th_us = collect->post_dur << 3;
		W_REG(pi->sh->osh, &pi->regs->PHYREF_TSF_GPT2_CTR_L, dur_1_8th_us & 0x0000FFFF);
		W_REG(pi->sh->osh, &pi->regs->PHYREF_TSF_GPT2_CTR_H, dur_1_8th_us >> 16);

		/* start ucode trigger-based sample collect procedure */
		wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_BMP, 0x0);

		/* set Start bit (start capture) */
		phy_ctl = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param);
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl | (1 << 4));

		if (ISSIM_ENAB(pi->sh->sih)) {
			OSL_DELAY(1000*collect->pre_dur);
		} else {
			OSL_DELAY(collect->pre_dur);
		}
		wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_BMP, (int8)collect->trigger);
		wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_CTL, 1);

		PHY_TRACE(("wl%d: %s Wait for trigger ...\n", pi->sh->unit, __FUNCTION__));
		do {
			OSL_DELAY(10000);
			val = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param) & 0x30;
			timer--;
		} while ((val != 0) && (timer > 0));
		if (val != 0) {
			PHY_ERROR(("wl%d: %s timer expired without trigger fired.\n",
				pi->sh->unit, __FUNCTION__));
		}

		/* set first and last pointer indices for readout */
		pi_ac->plast = acphy_get_sc_curptr(pi);

		if (pi_ac->plast >= (collect->pre_dur + collect->post_dur) * words_per_us) {
			pi_ac->pfirst =
				pi_ac->plast - (collect->pre_dur + collect->post_dur)*words_per_us;
		} else {
			pi_ac->pfirst = (pi_ac->pstop - pi_ac->pstart + 1) +
				pi_ac->plast - (collect->pre_dur + collect->post_dur)*words_per_us;
		}

		/* restore mac_ctl */
		W_REG(pi->sh->osh, &pi->regs->maccontrol, mac_ctl);

		W_REG(pi->sh->osh, &pi->regs->psm_bred_3, bred);

		/* erase trigger setup */
		W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl);
		wlapi_bmac_write_shm(pi->sh->physhim, D11AC_M_SMPL_COL_BMP, 0);
	}

	/* CLEAN UP: */
	/* return from deaf if requested */
	if (collect->be_deaf) {
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		wlapi_enable_mac(pi->sh->physhim);
	}

	/* revert to original gains if AGC was applied */
	if (collect->agc) {
	  /* wlc_phy_agc_rxgain_config_acphy(pi, FALSE); */
	}
	/* Restore filter settings if changed */
	if (collect->filter) {
		/* Restore LPF high pass corners to their original values */
		wlc_phy_lpf_hpc_override_acphy(pi, FALSE);
	}
	/* turn off sample collect config in PHY & MAC */
	MOD_PHYREG(pi, AdcDataCollect, adcDataCollectEn, 0);
	if (support_spectrum_analyzer_mode == 1) {
		MOD_PHYREG(pi, SpectrumAnalyzerMode, specAnaModeEn, 0);
		if (!ACREV_IS(pi->pubpi.phy_rev, 1))
			MOD_PHYREG(pi, SpecAnaDataCollect, specAnaMode, 0);
		FOREACH_CORE(pi, core) {
			WRITE_PHYREGCE(pi, forceFront, core, forceFront_save[core]);
		}
	}

	/* Restore RxFeTesMmuxCtrl register */
	MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save);

	/* Note: This line is required in order to read from the TX MAC FIFO */
	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, 0x2);

	/* Note: This line is needed in order to successfully restore MAC based sample play */
	/*       at the end of the proc in case it is being used */
	MOD_PHYREG(pi, macbasedDACPlay,
	              macBasedDACPlayEn, 0);

	/* Restore acphyreg(macbasedDACPlay.macBasedDACPlayEn) to its original state */
	MOD_PHYREG(pi, macbasedDACPlay,
	              macBasedDACPlayEn, macBasedDACPlayEn_save);

	/* abort if timeout ocurred */
	if (timer == 0) {
		PHY_ERROR(("wl%d: %s Error: Timeout\n", pi->sh->unit, __FUNCTION__));
		return BCME_ERROR;
	}

	PHY_TRACE(("wl%d: %s: Capture successful\n", pi->sh->unit, __FUNCTION__));

	if (pi_ac->pfirst > pi_ac->plast) {
		cnt = pi_ac->pstop - pi_ac->pfirst + 1;
		cnt += pi_ac->plast;
	} else {
		cnt = pi_ac->plast - pi_ac->pfirst;
	}

	sample_data->tag = htol16(WL_SAMPLEDATA_HEADER_TYPE);
	sample_data->length = htol16((WL_SAMPLEDATA_HEADER_SIZE));
	sample_data->flag = 0;		/* first sequence */
	sample_data->flag |= htol32(WL_SAMPLEDATA_MORE_DATA);

	sample_rate = CHSPEC_IS40(pi->radio_chanspec) ? 80 : 40;
	sample_bitwidth = 10;
	/* Hack in conversion factor for subtracting from adc sample
	 * power to obtain true analog power in dBm:
	 */
	dBsample_to_dBm_sub = 49;

	/* store header to buf */
	ptr[0] = htol32(0xACDC2009);
	ptr[1] = htol32(0xFFFF0000 | (FILE_HDR_LEN<<8));
	ptr[2] = htol32(cnt % (acphy_sc_length(pi) + 1));
	ptr[3] = htol32(0xFFFF0000 | (pi->pubpi.phy_rev<<8) | pi->pubpi.phy_type);
	ptr[4] = htol32(0xFFFFFF00);
	ptr[5] = htol32(((fc / 100) << 24) | ((fc % 100) << 16) | (num_cores << 8) |
	                (CHSPEC_IS20(pi->radio_chanspec) ? 20 :
	                 (CHSPEC_IS40(pi->radio_chanspec) ? 40 : 80)));

	ptr[6] = htol32((collect->gpio_sel << 24) | (((mo >> 8)  & 0xff) << 16) |
	          ((mo & 0xff) << 8) | gpio_collection);
	ptr[7] = htol32(0xFFFF0000 | (downSamp << 8) | collect->trigger);
	ptr[8] = htol32(0xFFFFFFFF);
	ptr[9] = htol32((collect->post_dur << 16) | collect->pre_dur);
	FOREACH_CORE(pi, core) {
		ptr[10+core] = htol32((READ_PHYREGCE(pi, Core1RxIQCompA, core)) |
		                 (READ_PHYREGCE(pi, Core1RxIQCompB, core) << 16));
	}
	ptr[13] = htol32(((collect->filter ? 1 : 0) << 24) | ((collect->agc ? 1 : 0) << 16) |
		(sample_rate << 8) | sample_bitwidth);
	ptr[14] = htol32(((dBsample_to_dBm_sub << 16) | agc_gain[0]));
	ptr[15] = htol32(((agc_gain[2] << 16) | agc_gain[1]));
	ptr[16] = htol32(0xFFFFFFFF);
	ptr[17] = htol32(0xFFFFFFFF);
	ptr[18] = htol32(0xFFFFFFFF);
	ptr[19] = htol32(0xFFFFFFFF);
	STATIC_ASSERT(FILE_HDR_LEN == 20);
	PHY_TRACE(("wl%d: %s: pfirst 0x%x plast 0x%x pstart 0x%x pstop 0x%x\n", pi->sh->unit,
		__FUNCTION__, pi_ac->pfirst, pi_ac->plast, pi_ac->pstart, pi_ac->pstop));
	PHY_TRACE(("wl%d: %s Capture length = %d words\n", pi->sh->unit, __FUNCTION__, cnt));

	if (pmu_chip_ctl_regupdate == 1) {
		si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL5, 0xFFFFFFFF, pmu_chipctReg5_def);
	}

	/*
	 * Restore the original mac_ctl value.
	 * For ATE sample capture, even if mac is reenabled at this point, there is a burst of
	 * glitches at around 260us.
	 */
#ifndef ATE_BUILD
	if (CHIPID(pi->sh->chip) == BCM4345_CHIP_ID)
		W_REG(pi->sh->osh, &pi->regs->maccontrol, mac_ctl);
#endif /* ATE_BUILD */

	return BCME_OK;
}

#else /* SAMPLE_COLLECT */

#ifdef PHY_XTAL_SPUR_CAL
/* trimmed down implementation of wlc_phy_sample_collect_acphy only doing SC_MODE_14_spect_ana */
static int
wlc_phy_spectrum_collect_acphy(phy_info_t *pi, wl_samplecollect_args_t *collect)
{
	uint32 needed;
	uint32 sc_buff_length, sc_buff_start;
	int coreSel = 0;
	uint32 timer, cnt;
	uint16 words_per_us = 0;
	uint8 core;
	phy_info_acphy_t *pi_ac;
	uint16 fft_sampRate = 0;
	uint16 forceFront_save[PHY_CORE_MAX];
	uint8 RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save;
	uint8 specAnaModeDs;

	ASSERT(pi);
	pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	if (!pi_ac)
		return BCME_ERROR;

	/* 4360A0/A2, 4335A0/B0, 4345 do not have the spectrum analyzer mode */
	if (ACREV_IS(pi->pubpi.phy_rev, 0) ||
	    ACREV_IS(pi->pubpi.phy_rev, 2) || ACREV_IS(pi->pubpi.phy_rev, 5) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		PHY_ERROR(("FFT is not supported on phy rev 0, 2, 4, and 5\n"));
		return BCME_ERROR;
	}

	/* Store forceFront register as it may be modified while setting up the samode capture */
	FOREACH_CORE(pi, core) {
		forceFront_save[core] =  READ_PHYREGCE(pi, forceFront, core);
	}

	/* Store RxFeTesMmuxCtrl register */
	RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save =  READ_PHYREGFLD(pi, RxFeTesMmuxCtrl,
	                                                        rxfe_dbg_mux_sel);

	WRITE_PHYREG(pi, AdcDataCollect, 0);
	WRITE_PHYREG(pi, RxFeTesMmuxCtrl, 0);

	if (ACREV_IS(pi->pubpi.phy_rev, 1))
		PHY_REG_WRITE(pi, ACPHY, SpectrumAnalyzerMode(1), 0);
	else /* phyrev!=0 && phyrev !=1  */
		PHY_REG_WRITE(pi, ACPHY, SpectrumAnalyzerMode(2), 0);
	if (!ACREV_IS(pi->pubpi.phy_rev, 1))
		WRITE_PHYREG(pi, SpecAnaDataCollect, 0);

	/* SC_MODE_14_spect_ana begin */
	if (IS20MHZ(pi)) {
		specAnaModeDs = 1;
		fft_sampRate = 20;
	} else if (IS40MHZ(pi)) {
		specAnaModeDs = 0;
		fft_sampRate = 40;
	} else {
		specAnaModeDs = 3;
		fft_sampRate = 80;
	}
	if (ACREV_IS(pi->pubpi.phy_rev, 1)) {
		MOD_PHYREG(pi, AdcDataCollect, specAnaModeDs, specAnaModeDs);
	} else {
		MOD_PHYREG(pi, SpecAnaDataCollect, specAnaModeDs, specAnaModeDs);
	}

	coreSel = collect->cores;
	if ((coreSel < 0) || (coreSel > 2)) {
		coreSel = 0;
	}

	/* reset CCA */
	wlc_phy_resetcca_acphy(pi);

	if (ACREV_IS(pi->pubpi.phy_rev, 1)) {
		MOD_PHYREG(pi, SpectrumAnalyzerMode, saModeChan, coreSel);

		MOD_PHYREG(pi, fdiqi_rx_controller_bits,
		           max_no_of_symbols, 0);
		MOD_PHYREG(pi, rxfdiqImbCompCtrl,
		           calibration_notoperation, 1);

		MOD_PHYREG(pi, SpectrumAnalyzerMode, saModeEn, 1);
		MOD_PHYREG(pi, AdcDataCollect, specAnaMode, 1);
	} else { /* phyrev >=2 */

		MOD_PHYREG(pi, SpecAnaDataCollect,
		           specAnaModeChanSel, coreSel);
		MOD_PHYREG(pi, SpectrumAnalyzerMode, specAnaModeEn, 1);
		MOD_PHYREG(pi, SpecAnaDataCollect, specAnaMode, 1);
		FOREACH_CORE(pi, core) {
			MOD_PHYREGCE(pi, forceFront, core, freqEst, 1);
		}
	}

	words_per_us = fft_sampRate;

	/* SC_MODE_14_spect_ana end */

	MOD_PHYREG(pi, AdcDataCollect, adcDataCollectEn, 1);

	/* Get the offset and the size of the sample capture buffer */
	needed = (collect->pre_dur + collect->post_dur) * words_per_us;
	wlc_phy_get_sc_buff_offs_len(pi, needed, &sc_buff_start, &sc_buff_length);

	/* duration(s): length sanity check and mapping from "max" to usec values */
	if (needed > sc_buff_length) {
		PHY_ERROR(("wl%d: %s: Bad Duration Option\n", pi->sh->unit, __FUNCTION__));
		return BCME_RANGE;
	}

	/* set Tx-FIFO collect start pointer and calculate stop pointer */
	acphy_set_sc_startptr(pi, sc_buff_start);
	pi_ac->pstop    = sc_buff_start + needed;

	/* be deaf if requested (e.g. for spur measurement) */
	if (collect->be_deaf) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	}

	PHY_TRACE(("wl%d: %s Start capture, trigger = %d\n", pi->sh->unit, __FUNCTION__,
		collect->trigger));

	timer = collect->timeout;

	PHY_TRACE(("wl%d: %s Start capture, timer = %d\n", pi->sh->unit, __FUNCTION__,
		collect->timeout));

	/* immediate trigger */

	/* wlc_phy_sample_collect_now return FALSE if things timed out,
	 * later timer is checked to be zero and an error is returned
	 */
	timer = wlc_phy_sample_collect_now(pi, collect, sc_buff_start) ? 1 : 0;

	/* CLEAN UP: */
	/* return from deaf if requested */
	if (collect->be_deaf) {
		wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
		wlapi_enable_mac(pi->sh->physhim);
	}

	/* turn off sample collect config in PHY & MAC */
	MOD_PHYREG(pi, AdcDataCollect, adcDataCollectEn, 0);
	MOD_PHYREG(pi, SpectrumAnalyzerMode, specAnaModeEn, 0);
	if (!ACREV_IS(pi->pubpi.phy_rev, 1))
		MOD_PHYREG(pi, SpecAnaDataCollect, specAnaMode, 0);
	FOREACH_CORE(pi, core) {
		WRITE_PHYREGCE(pi, forceFront, core, forceFront_save[core]);
	}

	/* Restore RxFeTesMmuxCtrl register */
	MOD_PHYREG(pi, RxFeTesMmuxCtrl, rxfe_dbg_mux_sel, RxFeTesMmuxCtrl_rxfe_dbg_mux_sel_save);

	/* Note: This line is required in order to read from the TX MAC FIFO */
	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, 0x2);

	/* abort if timeout ocurred */
	if (timer == 0) {
		PHY_ERROR(("wl%d: %s Error: Timeout\n", pi->sh->unit, __FUNCTION__));
		return BCME_ERROR;
	}

	PHY_TRACE(("wl%d: %s: Capture successful\n", pi->sh->unit, __FUNCTION__));

	if (pi_ac->pfirst > pi_ac->plast) {
		cnt = pi_ac->pstop - pi_ac->pfirst + 1;
		cnt += pi_ac->plast;
	} else {
		cnt = pi_ac->plast - pi_ac->pfirst;
	}

	PHY_TRACE(("wl%d: %s: pfirst 0x%x plast 0x%x pstart 0x%x pstop 0x%x\n", pi->sh->unit,
		__FUNCTION__, pi_ac->pfirst, pi_ac->plast, pi_ac->pstart, pi_ac->pstop));
	PHY_TRACE(("wl%d: %s Capture length = %d words\n", pi->sh->unit, __FUNCTION__, cnt));

	return BCME_OK;
}

#endif /* PHY_XTAL_SPUR_CAL */

#endif /* !SAMPLE_COLLECT */

#ifdef SAMPLE_COLLECT

int
wlc_phy_sample_data_acphy(phy_info_t *pi, wl_sampledata_t *sample_data, void *b)
{
	uint32 data, cnt, bufsize, seq;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8* head = (uint8 *)b;
	uint32* buf = (uint32 *)(head + sizeof(wl_sampledata_t));
	/* buf2 is used when sampledata is unpacked for
	 * version WL_SAMPLEDATA_T_VERSION_SPEC_AN
	 */

	int16* buf2 = (int16 *)(head + sizeof(wl_sampledata_t));
	int i;

	bufsize = ltoh32(sample_data->length) - sizeof(wl_sampledata_t);

	if (sample_data->version == (WL_SAMPLEDATA_T_VERSION_SPEC_AN)) {
		/* convert to # of (4*num_cores)--byte  words */
		bufsize = bufsize / (PHYCORENUM(pi->pubpi.phy_corenum) * 4);
	} else {
		/* convert to # of 4--byte words */
		bufsize = bufsize >> 2;
	}

	/* get the last sequence number */
	seq = ltoh32(sample_data->flag) & 0xff;

	/* Saturate sequence number to 0xff */
	seq = (seq < 0xff) ? (seq + 1) : 0xff;

	/* write back to data struct */
	sample_data->flag = htol32(seq);

	PHY_TRACE(("wl%d: %s: bufsize(words) %d flag 0x%x\n", pi->sh->unit, __FUNCTION__,
		bufsize, sample_data->flag));

	wlapi_bmac_templateptr_wreg(pi->sh->physhim, pi_ac->pfirst << 2);

	/* Currently only 3 cores (and collect mode 0) are supported
	 * for version WL_SAMPLEDATA_T_VERSION_SPEC_AN
	 */

	if ((sample_data->version == WL_SAMPLEDATA_T_VERSION_SPEC_AN) &&
	    (PHYCORENUM(pi->pubpi.phy_corenum) != 3))  {
		/* No more data to read */
		sample_data->flag = sample_data->flag & 0xff;

		/* No bytes were read */
		sample_data->length = 0;

		bcopy((uint8 *)sample_data, head, sizeof(wl_sampledata_t));
		PHY_ERROR(("wl%d: %s: Number of cores != 3\n",
			pi->sh->unit, __FUNCTION__));
		return BCME_ERROR;
	}

	/* Initialization for version WL_SAMPLEDATA_T_VERSION_SPEC_AN: */
	if ((sample_data->version == WL_SAMPLEDATA_T_VERSION_SPEC_AN) && (seq == 1)) {
		bool capture_start = FALSE;

		/* Search for and sync to a sample with a valid 2-bit '00' alignment pattern */
		while ((!capture_start) && (pi_ac->pfirst != pi_ac->plast)) {
			data = wlapi_bmac_templatedata_rreg(pi->sh->physhim);
			/* wrap around end of fifo if necessary */
			if (pi_ac->pfirst == pi_ac->pstop) {
				wlapi_bmac_templateptr_wreg(pi->sh->physhim, pi_ac->pstart << 2);
				pi_ac->pfirst = pi_ac->pstart;
				PHY_TRACE(("wl%d: %s TXFIFO wrap around\n",
					pi->sh->unit, __FUNCTION__));
			} else {
				pi_ac->pfirst++;
			}

			/* Check for alignment pattern 0x3 in the captured word */
			if (((data >> 30) & 0x3) == 0x3) {
				/* Read and discard one 32-bit word to
				 * move to where the next sample
				 * (with alignment pattern '00') starts
				 */
				data = wlapi_bmac_templatedata_rreg(pi->sh->physhim);

				/* wrap around end of fifo if necessary */
				if (pi_ac->pfirst == pi_ac->pstop) {
					wlapi_bmac_templateptr_wreg(pi->sh->physhim,
					      pi_ac->pstart << 2);
					pi_ac->pfirst = pi_ac->pstart;
					PHY_TRACE(("wl%d: %s TXFIFO wrap around\n",
						pi->sh->unit, __FUNCTION__));
				} else {
					pi_ac->pfirst++;
				}

				if (pi_ac->pfirst != pi_ac->plast) {
					capture_start = TRUE;
				}
			}
		}

		if (capture_start == FALSE) {
			/* ERROR: No starting pattern was found! */
			/* No more data to read */
			sample_data->flag = sample_data->flag & 0xff;

			/* No bytes were read */
			sample_data->length = 0;

			bcopy((uint8 *)sample_data, head, sizeof(wl_sampledata_t));
			PHY_ERROR(("wl%d: %s: Starting pattern not found! \n",
				pi->sh->unit, __FUNCTION__));
			return BCME_ERROR;
		}
	}

	/* start writing samples to buffer */
	cnt = 0;

	while ((cnt < bufsize) && (pi_ac->pfirst != pi_ac->plast)) {

		if (sample_data->version == WL_SAMPLEDATA_T_VERSION_SPEC_AN) {

			/* Unpack collected samples and write to buffer */
			uint32 data1[2];
			int16 isample[PHY_CORE_MAX];
			int16 qsample[PHY_CORE_MAX];

			for (i = 0; ((i < 2) && (pi_ac->pfirst != pi_ac->plast)); i++) {
				data1[i] = wlapi_bmac_templatedata_rreg(pi->sh->physhim);
				/* wrap around end of fifo if necessary */
				if (pi_ac->pfirst == pi_ac->pstop) {
					wlapi_bmac_templateptr_wreg(pi->sh->physhim,
					      pi_ac->pstart << 2);
					pi_ac->pfirst = pi_ac->pstart;
					PHY_TRACE(("wl%d: %s TXFIFO wrap around\n",
						pi->sh->unit, __FUNCTION__));
				} else {
					pi_ac->pfirst++;
				}
			}

			/* Unpack samples only if two 32-bit words have
			 * been successfully read from TX FIFO
			 */
			if (i == 2) {
				/* Unpack and perform sign extension: */
				uint16 temp;

				/* Core 0: */
				temp = (uint16)(data1[0] & 0x3ff);
				isample[0] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;
				temp = (uint16)((data1[0] >> 10) & 0x3ff);
				qsample[0] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;

				/* Core 1: */
				temp = (uint16)((data1[0] >> 20) & 0x3ff);
				isample[1] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;
				temp = (uint16)(data1[1] & 0x3ff);
				qsample[1] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;

				/* Core 2: */
				temp = (uint16)((data1[1] >> 10) & 0x3ff);
				isample[2] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;
				temp = (uint16)((data1[1] >> 20) & 0x3ff);
				qsample[2] = (temp & 0x200) ? (int16)(temp | 0xfc00) : temp;

				/* Write to buffer in 2-byte words */
				buf2[6*cnt]     = isample[0];
				buf2[6*cnt + 1] = qsample[0];
				buf2[6*cnt + 2] = isample[1];
				buf2[6*cnt + 3] = qsample[1];
				buf2[6*cnt + 4] = isample[2];
				buf2[6*cnt + 5] = qsample[2];

				cnt++;
			}

		} else {
			/* Write collected samples as-is to buffer */

			data = wlapi_bmac_templatedata_rreg(pi->sh->physhim);
			/* write one 4-byte word */
			buf[cnt++] = htol32(data);
			/* wrap around end of fifo if necessary */
			if (pi_ac->pfirst == pi_ac->pstop) {
				wlapi_bmac_templateptr_wreg(pi->sh->physhim, pi_ac->pstart << 2);
				pi_ac->pfirst = pi_ac->pstart;
				PHY_TRACE(("wl%d: %s TXFIFO wrap around\n",
					pi->sh->unit, __FUNCTION__));
			} else {
				pi_ac->pfirst++;
			}
		}
	}

	PHY_TRACE(("wl%d: %s: Data fragment completed (pfirst %d plast %d)\n",
		pi->sh->unit, __FUNCTION__, pi_ac->pfirst, pi_ac->plast));
	if (pi_ac->pfirst != pi_ac->plast) {
		sample_data->flag |= htol32(WL_SAMPLEDATA_MORE_DATA);
	}

	/* update to # of bytes read */
	if (sample_data->version == WL_SAMPLEDATA_T_VERSION_SPEC_AN) {
		sample_data->length = htol16((cnt * 4 * PHYCORENUM(pi->pubpi.phy_corenum)));
	} else {
		sample_data->length = htol16((cnt << 2));
	}

	bcopy((uint8 *)sample_data, head, sizeof(wl_sampledata_t));
	PHY_TRACE(("wl%d: %s: Capture length = %d words\n", pi->sh->unit, __FUNCTION__, cnt));
	return BCME_OK;
}

int
acphy_sc_length(phy_info_t *pi)
{

	uint32 start_ptr, stop_ptr;
	int sc_len;
	start_ptr = acphy_get_sc_startptr(pi);
	stop_ptr = acphy_get_sc_stopptr(pi);
	sc_len = stop_ptr - start_ptr;

	return sc_len;
}

#endif /* SAMPLE_COLLECT */

uint32
acphy_get_sc_startptr(phy_info_t *pi)
{

	uint32 start_ptr_low, start_ptr_high, start_ptr;

	start_ptr_low = R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStartPtr);
	start_ptr_high = (R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh)) & 0xF;
	start_ptr = ((start_ptr_high << 16) | start_ptr_low);

	return start_ptr;
}

uint32
acphy_get_sc_stopptr(phy_info_t *pi)
{

	uint32 stop_ptr_low, stop_ptr_high, stop_ptr;

	stop_ptr_low = 	R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStopPtr);
	stop_ptr_high = (R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh) >> 4) & 0xF;
	stop_ptr = 		((stop_ptr_high << 16) | stop_ptr_low);

	return stop_ptr;
}

uint32
acphy_get_sc_curptr(phy_info_t *pi)
{

	uint32 cur_ptr_low, cur_ptr_high, cur_ptr;

	cur_ptr_low = 	R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr);
	cur_ptr_high = (R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtrHigh)) & 0xF;
	cur_ptr = ((cur_ptr_high << 16) | cur_ptr_low);

	return cur_ptr;
}

uint32
acphy_is_sc_done(phy_info_t *pi)
{

	uint32 cur_ptr, stop_ptr;
	bool sc_done;

	cur_ptr  = acphy_get_sc_curptr(pi);
	stop_ptr = acphy_get_sc_stopptr(pi);

	if (cur_ptr == stop_ptr) {
		sc_done = TRUE;
	} else {
		sc_done = FALSE;
	}

	return sc_done;
}

void
acphy_set_sc_startptr(phy_info_t *pi, uint32 start_idx)
{
	uint16 ptr_high;

	W_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStartPtr, (start_idx & 0xFFFF));
	ptr_high = R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh) & ~0xF;
	ptr_high |= (start_idx >> 16) & 0xF;
	W_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh, ptr_high);
}

void
acphy_set_sc_stopptr(phy_info_t *pi, uint32 stop_idx)
{
	uint16 ptr_high;

	W_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStopPtr, (stop_idx & 0xFFFF));
	ptr_high = R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh) & ~0xF0;
	ptr_high |= (stop_idx >> 12) & 0xF0;
	W_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectPlayPtrHigh, ptr_high);
}

#ifdef WL_LPC

#define LPC_MIN_IDX 31
#define LPC_TOT_IDX (LPC_MIN_IDX + 1)
#define PWR_VALUE_BITS  0x3F

/*	table containing values of 0.5db difference,
	Each value is represented in S4.1 format
*/
static uint8 lpc_pwr_level[LPC_TOT_IDX] = {
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
		0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
		0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11,
		0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
		0x1E, 0x1F /* Max = Target - 15.5db */
		};

uint8
wlc_acphy_lpc_getminidx(void)
{
	return LPC_MIN_IDX;
}

uint8
wlc_acphy_lpc_getoffset(uint8 index)
{
	return lpc_pwr_level[index];
	/* return lpc_pwr_level[index]; for PHYs which expect the actual offset
	 * for example, HT 4331.
	 */
}

#ifdef WL_LPC_DEBUG
uint8 *
wlc_acphy_lpc_get_pwrlevelptr(void)
{
	return lpc_pwr_level;
}
#endif // endif
#endif /* WL_LPC */

#if   defined(WLOFFLD) || defined(BCM_OL_DEV)
int8
wlc_phy_noise_sample_acphy(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int8 noise_dbm = PHY_NOISE_FIXED_VAL_NPHY;

#ifndef	BCM_OL_DEV
	if (!pi->sh->clk) {
		PHY_TRACE(("%s: No Clock\n", __FUNCTION__));
		return noise_dbm;
	}
#endif /* BCM_OL_DEV */

	wlapi_bmac_read_shm(pi->sh->physhim, M_JSSI_AUX);
	noise_dbm = wlc_phy_noise_read_shmem(pi);
	pi->sh->phy_noise_window[pi->sh->phy_noise_index] = noise_dbm;
	pi->sh->phy_noise_index = MODINC(pi->sh->phy_noise_index, MA_WINDOW_SZ);

	PHY_TRACE(("%s: Noise Sample %d[%d]\n",
		__FUNCTION__, noise_dbm, pi->sh->phy_noise_index));

	return noise_dbm;
}

void
wlc_phy_noise_reset_ma_acphy(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t*)pih;
	int     i;

	for (i = 0; i < MA_WINDOW_SZ; i++) {
		pi->sh->phy_noise_window[i] = 0;
	}
	pi->sh->phy_noise_index = 0;
}
#endif /* defined(WLOFFLD) || defined(BCM_OL_DEV) */

#if defined(PHYCAL_CACHING) || defined(WLMCHAN)|| defined(WL_MODESW)
int8 wlc_phy_get_thresh_acphy(phy_info_t *pi)
{
#ifdef WLOLPC
#if defined(BCMDBG) || defined(WLTEST)
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
#endif /* BCMDBG || WLTEST */
	acphy_calcache_t *cache;
	ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
	if (ctx) {
		if (ctx->valid) {
			cache = &ctx->u.acphy_cache;
			if (cache->olpc_caldone)
				return wlc_phy_olpcthresh();
		}
	}
#if defined(BCMDBG) || defined(WLTEST)
	else {
		if (pi_ac->olpc_dbg_mode)
			return wlc_phy_olpcthresh();
	}
#endif /* BCMDBG || WLTEST */
#endif /* WLOLPC */
	return wlc_phy_tssivisible_thresh_acphy(pi);
}

#ifdef WLOLPC
static int8
wlc_phy_olpcthresh()
{
	/* Threshold = -128 */
	/* When OLPC in use, allow rates with negative power */
	int8 olpc_thresh = OLPC_MIN_POWER;
	return olpc_thresh;
}

void
wlc_phy_update_olpc_cal(wlc_phy_t *ppi, bool set, bool dbg)
{
	phy_info_t *pi = (phy_info_t *)ppi;
#if defined(BCMDBG) || defined(WLTEST)
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
#endif /* BCMDBG || WLTEST */

	ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
	acphy_calcache_t *cache;

	if (ctx) {
		cache = &ctx->u.acphy_cache;
		cache->olpc_caldone = set;

		/* Set the TSSI visibility limits for 4360 A0/B0, 4350 */
		/* TODO: Should this be in this if or outside this if??? */
		/* Should be ok since ctx is also checked in it */
		wlc_phy_set_tssisens_lim_acphy(pi, pi->txpwroverride);
	}
#if defined(BCMDBG) || defined(WLTEST)
	else {
		if (dbg) {
			pi_ac->olpc_dbg_mode = dbg;
			wlapi_suspend_mac_and_wait(pi->sh->physhim);
			/* Toggle Power Control to save off base index */
			wlc_phy_txpwrctrl_enable_acphy(pi, 0);
			wlc_phy_txpwrctrl_enable_acphy(pi, 1);
			wlapi_enable_mac(pi->sh->physhim);
		}
	}
#endif /* BCMDBG || WLTEST */
}

void
wlc_phy_pi_update_olpc_cal(phy_info_t *pi, bool set, bool dbg)
{
	wlc_phy_update_olpc_cal((wlc_phy_t *)pi, set, dbg);
}
#endif /* WLOLPC */

void
wlc_phy_cal_cache_acphy(wlc_phy_t *pih)
{
	phy_info_t *pi = (phy_info_t *) pih;
	ch_calcache_t *ctx;
	acphy_calcache_t *cache;
	uint8 core;
	uint16 tbl_cookie;
#ifdef WLPAPDPARAMS_CACHE
	uint32 *epsilon_cache;
	uint16 *epstbl_offset_cache;
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};
	uint32 rfpwrlut_table_ids[] = { ACPHY_TBL_ID_RFPWRLUTS0,
		ACPHY_TBL_ID_RFPWRLUTS1, ACPHY_TBL_ID_RFPWRLUTS2};
#endif /* WLPAPDPARAMS_CACHE */
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#ifndef WLOLPC
	/* A context must have been created before reaching here */
	ASSERT(ctx != NULL);
#endif /* WLOLPC */
	if (ctx == NULL) {
		PHY_ERROR(("wl%d: %s call with null ctx\n",
			pi->sh->unit, __FUNCTION__));
		return;
	}
	/* Ensure that the Callibration Results are valid */
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
		IQTBL_CACHE_COOKIE_OFFSET, 16, &tbl_cookie);
	if (tbl_cookie != TXCAL_CACHE_VALID) {
		return;
	}

	ctx->valid = TRUE;

	cache = &ctx->u.acphy_cache;
#ifdef WLPAPDPARAMS_CACHE
	epsilon_cache = cache->papd_eps;
	epstbl_offset_cache = cache->eps_offset_cache;
	cache->rfpwrlut_ptr = rfpwrlut_ptr;
#endif /* WLPAPDPARAMS_CACHE */

	/* save the callibration to cache */
	FOREACH_CORE(pi, core) {
		uint16 ab_int[2];
		/* Save OFDM Tx IQ Imb Coeffs A,B and Digital Loft Comp Coeffs */
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		                                ab_int, TB_OFDM_COEFFS_AB, core);
		cache->ofdm_txa[core] = ab_int[0];
		cache->ofdm_txb[core] = ab_int[1];
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		                                &cache->ofdm_txd[core], TB_OFDM_COEFFS_D, core);
		/* Save OFDM Tx IQ Imb Coeffs A,B and Digital Loft Comp Coeffs */
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		                                ab_int, TB_BPHY_COEFFS_AB, core);
		cache->bphy_txa[core] = ab_int[0];
		cache->bphy_txb[core] = ab_int[1];
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_READ,
		                                &cache->bphy_txd[core], TB_BPHY_COEFFS_D, core);

		if (!TINY_RADIO(pi)) {
			/* Save Analog Tx Loft Comp Coeffs */
			cache->txei[core] = (uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_I, core);
			cache->txeq[core] = (uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_FINE_Q, core);
			cache->txfi[core] = (uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_I,
			                                           core);
			cache->txfq[core] = (uint8)READ_RADIO_REGC(pi, RF, TXGM_LOFT_COARSE_Q,
			                                           core);
		}

		/* Save Rx IQ Imb Coeffs */
		cache->rxa[core] = READ_PHYREGCE(pi, Core1RxIQCompA, core);
		cache->rxb[core] = READ_PHYREGCE(pi, Core1RxIQCompB, core);
		cache->rxs[core] = pi->u.pi_acphy->fdiqi.slope[core];
		cache->rxe =  pi->u.pi_acphy->fdiqi.enabled;
		/* Save base index */
		cache->baseidx[core] = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, baseIndex);
		if (TINY_RADIO(pi)) {
			cache->baseidx_cck[core] = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_cck_path,
				core, baseIndex_cck);
		}
		/* save idle TSSI */
		cache->idle_tssi[core] = READ_PHYREGCE(pi, TxPwrCtrlIdleTssi_path, core);
#ifdef WLPAPDPARAMS_CACHE
		/* save PAPD epsilon offsets */
		if (PHY_PAPDEN(pi)) {
			wlc_phy_table_read_acphy(pi, epsilon_table_ids[core],
				ACPHY_PAPD_EPS_TBL_SIZE, 0, 32, epsilon_cache);
			epsilon_cache += ACPHY_PAPD_EPS_TBL_SIZE;
			wlc_phy_table_read_acphy(pi, rfpwrlut_table_ids[core],
				128, 0, 16, epstbl_offset_cache);
			epstbl_offset_cache += 128;
		}
#endif /* WLPAPDPARAMS_CACHE */
	}

#ifdef BCMDBG
	PHY_CAL(("wl%d: %s: Cached cal values for chanspec 0x%x are:\n",
		pi->sh->unit, __FUNCTION__,  ctx->chanspec));
	wlc_phy_cal_cache_dbg_acphy(pih, ctx);
#endif // endif
}

#ifdef BCMDBG
static void
wlc_phy_cal_cache_dbg_acphy(wlc_phy_t *pih, ch_calcache_t *ctx)
{
	phy_info_t *pi = (phy_info_t *) pih;

	if (ISACPHY(pi)) {
		uint8 i;
		acphy_calcache_t *cache = &ctx->u.acphy_cache;

		FOREACH_CORE(pi, i) {
			PHY_CAL(("CORE %d:\n", i));
			PHY_CAL(("\tofdm_txa:0x%x  ofdm_txb:0x%x  ofdm_txd:0x%x\n",
				cache->ofdm_txa[i], cache->ofdm_txb[i], cache->ofdm_txd[i]));
			PHY_CAL(("\tbphy_txa:0x%x  bphy_txb:0x%x  bphy_txd:0x%x\n",
				cache->bphy_txa[i], cache->bphy_txb[i], cache->bphy_txd[i]));
			PHY_CAL(("\ttxei:0x%x  txeq:0x%x\n", cache->txei[i], cache->txeq[i]));
			PHY_CAL(("\ttxfi:0x%x  txfq:0x%x\n", cache->txfi[i], cache->txfq[i]));
			PHY_CAL(("\trxa:0x%x  rxb:0x%x\n", cache->rxa[i], cache->rxb[i]));
			PHY_CAL(("\trxs:0x%x  rxe:0x%x\n", cache->rxs[i], cache->rxe));
			PHY_CAL(("\tidletssi:0x%x\n", cache->idle_tssi[i]));
			PHY_CAL(("\tbasedindex:0x%x\n", cache->baseidx[i]));
			if (TINY_RADIO(pi)) {
				PHY_CAL(("\tbasedindex:0x%x\n", cache->baseidx_cck[i]));
			}
		}
	}
}

void
wlc_phydump_cal_cache_acphy(phy_info_t *pi, ch_calcache_t *ctx, struct bcmstrbuf *b)
{
	if (ISACPHY(pi)) {
		uint8 i;
		acphy_calcache_t *cache = &ctx->u.acphy_cache;

		FOREACH_CORE(pi, i) {
			bcm_bprintf(b, "CORE %d:\n", i);
			bcm_bprintf(b, "\tofdm_txa:0x%x  ofdm_txb:0x%x  ofdm_txd:0x%x\n",
				cache->ofdm_txa[i], cache->ofdm_txb[i], cache->ofdm_txd[i]);
			bcm_bprintf(b, "\tbphy_txa:0x%x  bphy_txb:0x%x  bphy_txd:0x%x\n",
				cache->bphy_txa[i], cache->bphy_txb[i], cache->bphy_txd[i]);
			bcm_bprintf(b, "\ttxei:0x%x  txeq:0x%x\n", cache->txei[i], cache->txeq[i]);
			bcm_bprintf(b, "\ttxfi:0x%x  txfq:0x%x\n", cache->txfi[i], cache->txfq[i]);
			bcm_bprintf(b, "\trxa:0x%x  rxb:0x%x\n", cache->rxa[i], cache->rxb[i]);
			bcm_bprintf(b, "\tidletssi:0x%x\n", cache->idle_tssi[i]);
			bcm_bprintf(b, "\tbasedindex:0x%x\n", cache->baseidx[i]);
			if (TINY_RADIO(pi)) {
				bcm_bprintf(b, "\tbasedindex:0x%x\n", cache->baseidx_cck[i]);
			}
		}
	}
}
#endif /* BCMDBG */

int
wlc_phy_cal_cache_restore_acphy(phy_info_t *pi)
{
	ch_calcache_t *ctx;
	acphy_calcache_t *cache = NULL;
	bool suspend;
	uint8 core;
	uint16 tbl_cookie = TXCAL_CACHE_VALID;

	phy_iq_comp_t coeffs[PHY_CORE_MAX];
#ifdef WLPAPDPARAMS_CACHE
	uint32 *epsilon_cache;
	uint16 *epstbl_offset_cache;
	uint32 epsilon_table_ids[] = { ACPHY_TBL_ID_EPSILON0, ACPHY_TBL_ID_EPSILON1,
		ACPHY_TBL_ID_EPSILON2};
	uint32 rfpwrlut_table_ids[] = { ACPHY_TBL_ID_RFPWRLUTS0,
		ACPHY_TBL_ID_RFPWRLUTS1, ACPHY_TBL_ID_RFPWRLUTS2};
#endif /* WLPAPDPARAMS_CACHE */
	ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);

	if (!ctx) {
		PHY_ERROR(("wl%d: %s: Chanspec 0x%x not found in calibration cache\n",
		           pi->sh->unit, __FUNCTION__, pi->radio_chanspec));
		return BCME_ERROR;
	}

	if (!ctx->valid) {
		PHY_CAL(("wl%d: %s: Chanspec 0x%x found, but not valid in phycal cache\n",
		           pi->sh->unit, __FUNCTION__, ctx->chanspec));
		return BCME_ERROR;
	}

	PHY_CAL(("wl%d: %s: Restoring all cal coeffs from calibration cache for chanspec 0x%x\n",
	           pi->sh->unit, __FUNCTION__, pi->radio_chanspec));

	cache = &ctx->u.acphy_cache;
#ifdef WLPAPDPARAMS_CACHE
	epsilon_cache = cache->papd_eps;
	epstbl_offset_cache = cache->eps_offset_cache;
	rfpwrlut_ptr = cache->rfpwrlut_ptr;
#endif /* WLPAPDPARAMS_CACHE */
	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend) {
		/* suspend mac */
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
	}
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* restore the txcal from cache */
	FOREACH_CORE(pi, core) {
		uint16 ab_int[2];
		/* Restore OFDM Tx IQ Imb Coeffs A,B and Digital Loft Comp Coeffs */
		ab_int[0] = cache->ofdm_txa[core];
		ab_int[1] = cache->ofdm_txb[core];
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
		                                ab_int, TB_OFDM_COEFFS_AB, core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
		                                &cache->ofdm_txd[core], TB_OFDM_COEFFS_D, core);
		/* Restore BPHY Tx IQ Imb Coeffs A,B and Digital Loft Comp Coeffs */
		ab_int[0] = cache->bphy_txa[core];
		ab_int[1] = cache->bphy_txb[core];
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
		                                ab_int, TB_BPHY_COEFFS_AB, core);
		wlc_phy_cal_txiqlo_coeffs_acphy(pi, CAL_COEFF_WRITE,
		                                &cache->bphy_txd[core], TB_BPHY_COEFFS_D, core);

		if (!TINY_RADIO(pi)) {
			/* Restore Analog Tx Loft Comp Coeffs */
			write_radio_reg(pi, RF_2069_TXGM_LOFT_FINE_I(core), cache->txei[core]);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_FINE_Q(core), cache->txeq[core]);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_COARSE_I(core), cache->txfi[core]);
			write_radio_reg(pi, RF_2069_TXGM_LOFT_COARSE_Q(core), cache->txfq[core]);
		}

		/* Restore Rx IQ Imb Coeffs */
		coeffs[core].a = cache->rxa[core] & 0x3ff;
		coeffs[core].b = cache->rxb[core] & 0x3ff;
		wlc_phy_rx_iq_comp_acphy(pi, 1, &(coeffs[core]), core);

		if (cache->rxe) {
		  pi->u.pi_acphy->fdiqi.slope[core] = cache->rxs[core];
		}
		/* Restore base index */
		wlc_phy_txpwrctrl_set_baseindex(pi, core, cache->baseidx[core], ACPHY_ENC_OFDM);
		if (TINY_RADIO(pi)) {
			wlc_phy_txpwrctrl_set_baseindex(pi, core,
				cache->baseidx_cck[core], ACPHY_ENC_CCK);
		}
		/* Restore Idle TSSI & Vmid values */
		wlc_phy_txpwrctrl_set_idle_tssi_acphy(pi, cache->idle_tssi[core], core);

#ifdef WLPAPDPARAMS_CACHE
		/* Restore PAPD epsilon offsets */
		if (PHY_PAPDEN(pi)) {
			wlc_phy_table_write_acphy(pi, epsilon_table_ids[core],
				ACPHY_PAPD_EPS_TBL_SIZE, 0, 32, epsilon_cache);
			epsilon_cache += ACPHY_PAPD_EPS_TBL_SIZE;
			wlc_phy_table_write_acphy(pi, rfpwrlut_table_ids[core],
				128, 0, 16, epstbl_offset_cache);
			epstbl_offset_cache += 128;
		}

#endif /* WLPAPDPARAMS_CACHE */
	}

	if (!TINY_RADIO(pi) && cache->rxe) {
	        wlc_phy_rx_fdiqi_comp_acphy(pi, TRUE);
	}

	/* Validate the Calibration Results */
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1,
	                          IQTBL_CACHE_COOKIE_OFFSET, 16, &tbl_cookie);

	wlc_phyreg_exit((wlc_phy_t *)pi);

	/* unsuspend mac */
	if (!suspend) {
		wlapi_enable_mac(pi->sh->physhim);
	}

#ifdef BCMDBG
	PHY_CAL(("wl%d: %s: Restored values for chanspec 0x%x are:\n", pi->sh->unit,
	           __FUNCTION__, ctx->chanspec));
	wlc_phy_cal_cache_dbg_acphy((wlc_phy_t *)pi, ctx);
#endif // endif
	return BCME_OK;
}
#endif /* PHYCAL_CACHING */

static void wlc_phy_write_regtbl_fc_from_nvram(phy_info_t *pi)
{
	uint8 band = 0, ovr_en = 0, ovr_ant = 0, elna = 0, ant = 0;
	uint8 inv_btcx_prisel = 0, muxErcxPriSel = 0;
	/* uint8 tdm, ercx_prisel; */
	uint8 ABAND = 0, BT_priority = 0, BT_TX = 0, MUX_CTRL = 0;
	uint8 WL_ANT_SEL = 0, BT_AoA = 0, WL_ePA_PU = 0;
	uint8 WL_eLNA_Gain = 0, BT_eLNA_Gain = 0, WL_eLNA_PU = 0;
	uint8 BT_RX = 0, WL_TRSW = 0, BT_rx_attn = 0;
	uint16 index = 0, indx = 0, femctrlout = 0;
	uint32 *swctrlmap = NULL, *swctrlmapext = NULL, decoded_address = 0;
	uint8 core = 0;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
#if defined(WLTEST)
	uint32 swctrlmap_ov[ACPHY_SWCTRL_NVRAM_PARAMS] = {0};
	uint32 swctrlmapext_ov[ACPHY_SWCTRL_NVRAM_PARAMS] = {0};
#endif // endif

	#define ACPHY_MASK_TDM	                0x100
	#define ACPHY_MASK_OVR_EN	        0x200
	#define ACPHY_MASK_OVR_ANT              0x400
	#define ACPHY_MAP_BT_TX	                0xc00
	#define ACPHY_MASK_BT_TX	        0xc90
	#define ACPHY_MAP_BT_RX	                0x800
	#define ACPHY_MASK_BT_RX                0x810
	#define ACPHY_MAP_WLAN_RX	        0x002
	#define ACPHY_MASK_WLAN_RX	        0xbcf
	#define ACPHY_MAP_WLAN_LOW_GAIN_RX	0x003
	#define ACPHY_MASK_WLAN_LOW_GAIN_RX	0xbcf
	#define ACPHY_MAP_WLAN_TX	        0x009
	#define ACPHY_MASK_WLAN_TX	        0xbcf
	#define ACPHY_MASK_ANT                  0x020
	#define ACPHY_MASK_BAND                 0x010
	/* BT_prisel and ErcxPriSel polarity info */
	/* No Need of forcing inv_btcx_prisel below */
	/* should be already taken care of in reg_on_init function */
	/*
	MOD_PHYREG(pi, BT_SwControl, inv_btcx_prisel, 0x1);
	*/
	inv_btcx_prisel = READ_PHYREGFLD(pi, BT_SwControl, inv_btcx_prisel);
	muxErcxPriSel = READ_PHYREGFLD(pi, FemCtrl, muxErcxPriSel);

	for (band = 0; band <= 1; band++) {
#if defined(WLTEST)
		if (pi_ac->swctrlmap_mask) {
			uint8 i;
			uint32 swctrlmap_value;
			uint32 *swctrlmap_nvram, *swctrlmapext_nvram;

			/* Entry to be applied for all modes */
			swctrlmap_value = pi_ac->swctrlmap_entry & pi_ac->swctrlmap_mask;

			/* Note the present NVRAM values */
			swctrlmap_nvram = ((band == 0) ?
				&(pi_ac->srom.nvram_femctrl.swctrlmap_2g[0]) :
				&(pi_ac->srom.nvram_femctrl.swctrlmap_5g[0]));
			swctrlmapext_nvram = ((band == 0) ?
				&(pi_ac->srom.nvram_femctrl.swctrlmapext_2g[0]) :
				&(pi_ac->srom.nvram_femctrl.swctrlmapext_5g[0]));
			bcopy((void*)swctrlmap_nvram, (void*)swctrlmap_ov,
				(ACPHY_SWCTRL_NVRAM_PARAMS * sizeof(uint32)));
			bcopy((void*)swctrlmapext_nvram, (void*)swctrlmapext_ov,
				(ACPHY_SWCTRL_NVRAM_PARAMS * sizeof(uint32)));

			/* Modify each mode accordingly */
			for (i = 0; i < ACPHY_SWCTRL_NVRAM_PARAMS; i++) {
				swctrlmap_ov[i] = swctrlmap_ov[i] & ~pi_ac->swctrlmap_mask;
				swctrlmap_ov[i] = swctrlmap_ov[i] | swctrlmap_value;
				swctrlmapext_ov[i] = swctrlmapext_ov[i] & ~pi_ac->swctrlmap_mask;
				swctrlmapext_ov[i] = swctrlmapext_ov[i] | swctrlmap_value;
			}
			swctrlmap = swctrlmap_ov;
			swctrlmapext = swctrlmapext_ov;
		}
		else
#endif // endif
		{
			swctrlmap = ((band == 0) ?
				&(pi_ac->srom.nvram_femctrl.swctrlmap_2g[0]) :
				&(pi_ac->srom.nvram_femctrl.swctrlmap_5g[0]));
			swctrlmapext = ((band == 0) ?
				&(pi_ac->srom.nvram_femctrl.swctrlmapext_2g[0]) :
				&(pi_ac->srom.nvram_femctrl.swctrlmapext_5g[0]));
			if (band) {
				pi_ac->srom.femctrlmask_2g =
					((pi_ac->srom.nvram_femctrl.swctrlmapext_2g[4] & 0x3)<<8 |
					(pi_ac->srom.nvram_femctrl.swctrlmap_2g[4] & 0xff));
			} else {
				pi_ac->srom.femctrlmask_5g =
					((pi_ac->srom.nvram_femctrl.swctrlmapext_5g[4] & 0x3)<<8 |
					(pi_ac->srom.nvram_femctrl.swctrlmap_5g[4] & 0xff));
			}
			elna =  ((band == 0) ?
				pi_ac->srom.elna2g_present : pi_ac->srom.elna5g_present);
			/* tdm = ((swctrlmap[4] & ACPHY_MASK_TDM) == ACPHY_MASK_TDM); */
			ovr_en = ((swctrlmap[4] & ACPHY_MASK_OVR_EN) == ACPHY_MASK_OVR_EN);
			ovr_ant = ((swctrlmap[4] & ACPHY_MASK_OVR_ANT) == ACPHY_MASK_OVR_ANT);
		}

		FOREACH_CORE(pi, core) {
			/* Core 0 and 1 respectively have 8 and 6 inputs to the FEM ctrl LUT */
			for (index = 0; index < ((core == 0) ? 128 : 32); index++) {
				/* split the index into appropriate controls */
				femctrlout = 0;
				ABAND = band;
				/* generate a femctrl index which includes band bit as well */
				indx = (index & 0xf) | (ABAND<<4) | ((index>>4) <<5);
				/* BT_priority and BT_TX */
				BT_priority =  (indx & (1 << 7)) >> 7;
				BT_TX = (indx & (1 << 6)) >> 6;
				if (inv_btcx_prisel == 1) {
					MUX_CTRL  =  BT_priority & (ABAND == 0);
				} else {
					MUX_CTRL  =  (BT_priority == 0) & (ABAND == 0);
				}
				/* BT_AoA and ANT_SEL */
				if ((MUX_CTRL == 0) || (core == 1)) {
					WL_ANT_SEL = (indx & (1 << 5)) >> 5;
					BT_AoA  =   0;
				} else {
					WL_ANT_SEL =  0;
					BT_AoA     =  (indx & (1 << 5)) >> 5;
				}
				/* ercx_prisel and WL_ePA_PU */
				if ((muxErcxPriSel == 0) || (core == 1)) {
					WL_ePA_PU = (indx & (1 << 3)) >> 3;
					/* ercx_prisel = 0; */
				} else {
					WL_ePA_PU = 0;
					/* ercx_prisel = (indx & (1 << 3)) >> 3; */
				}
				/* eLNA_gain */
				if ((MUX_CTRL == 0) || (core == 1)) {
					WL_eLNA_Gain = (indx & (1 << 2)) >> 2;
					BT_eLNA_Gain =   0;
				} else {
					WL_eLNA_Gain = 0;
					BT_eLNA_Gain = (indx & (1 << 2)) >> 2;
				}
				/* RX_PU */
				if ((MUX_CTRL == 0) || (core == 1)) {
					WL_eLNA_PU  = (indx & (1 << 1)) >> 1;
					BT_RX   =  0;
				} else {
					WL_eLNA_PU = 0;
					BT_RX  = (indx & (1 << 1)) >> 1;
				}
				/* TR switch related */
				if ((MUX_CTRL == 0) || (core == 1)) {
					WL_TRSW = (indx & (1 << 0)) >> 0;
					BT_rx_attn   =  0;
				} else {
					WL_TRSW = 0;
					BT_rx_attn = (indx & (1 << 0)) >> 0;
				}
				/* now classify which case this address corresponds to */
				decoded_address = WL_TRSW+2*WL_eLNA_PU+4*WL_eLNA_Gain+8*WL_ePA_PU
				        +16*ABAND+32*WL_ANT_SEL+64*BT_rx_attn+128*BT_RX
				        +256*BT_eLNA_Gain+512*BT_AoA+1024*BT_TX+2048*BT_priority;
				/* depending on the case decoded and if elna and ant overrdide */
				/* read appropriate byte from swctrlmap */
				ant =  ((ovr_en == 1) ? ovr_ant :
				        ((decoded_address & ACPHY_MASK_ANT) == ACPHY_MASK_ANT));
				/* No 2o3 antenna selection for 2x2 for now */
				if (pi->pubpi.phy_corenum == 2)
					ant = core;

				if ((decoded_address & ACPHY_MASK_WLAN_TX) ==
					ACPHY_MAP_WLAN_TX) {
				    uint32 swctrlwordext, swctrlword;
					wlc_phy_wltx_word_get(pi, band, swctrlmap[0],
						swctrlmapext[0], &swctrlword, &swctrlwordext);
					femctrlout = wlc_phy_femctrlout_get_val(
						swctrlwordext, swctrlword, 8*ant);
				} else if ((decoded_address & ACPHY_MASK_WLAN_RX) ==
				           ACPHY_MAP_WLAN_RX) {
					femctrlout = wlc_phy_femctrlout_get_val(
						swctrlmapext[1], swctrlmap[1], 8*ant+16*elna);
				} else if ((decoded_address & ACPHY_MASK_WLAN_LOW_GAIN_RX) ==
				           ACPHY_MAP_WLAN_LOW_GAIN_RX) {
					femctrlout = wlc_phy_femctrlout_get_val(
						swctrlmapext[2], swctrlmap[2], 8*ant+16*elna);
				} else if ((decoded_address & ACPHY_MASK_BT_TX) ==
				           ACPHY_MAP_BT_TX) {
					femctrlout = wlc_phy_femctrlout_get_val(
						swctrlmapext[3], swctrlmap[3], 16);
				} else if ((decoded_address & ACPHY_MASK_BT_RX) ==
				           ACPHY_MAP_BT_RX) {
					femctrlout = wlc_phy_femctrlout_get_val(
						swctrlmapext[3], swctrlmap[3],
						8*elna*!BT_eLNA_Gain);
				} else if (core == 0) {
					/* Init entire FEM table of core 0 w/ a predefined value */
					femctrlout = ((ABAND == 0) ?
						pi_ac->srom.nvram_femctrl.init_val_2g :
						pi_ac->srom.nvram_femctrl.init_val_5g);
				}

				if (core == 1)
					indx += 256;

				if (femctrlout != 0) {
					/* antdiv_rfswctrlpin_aX is the rfswctrl bit to override */
					/* For Stella: bit 7, for USI ES2.0 : bit 9 */
					/* For Stella: Antdiv 0:  RF_SW_CTL_7 (Low). */
					/* For Stella: Antdiv 1:  RF_SW_CTL_7 (High). 	*/
		      if (pi_ac->ant_swOvr_state_core0 != 2 && core == 0) {
			      if (pi_ac->ant_swOvr_state_core0 == 1) {
			        femctrlout = ((femctrlout & (~(1<<pi_ac->antdiv_rfswctrlpin_a0)))
					       | (1<<pi_ac->antdiv_rfswctrlpin_a0));
			      } else {
			        femctrlout = (femctrlout & (~(1<<pi_ac->antdiv_rfswctrlpin_a0)));
			      }
			    }

		      /* antdiv_rfswctrlpin_a1  - 8 maps to the LUT bit position */
		      if (pi_ac->ant_swOvr_state_core1 != 2 && core == 1) {
			      if (pi_ac->ant_swOvr_state_core1 == 1) {
							femctrlout =
							((femctrlout &
							(~(1<<(pi_ac->antdiv_rfswctrlpin_a1-8)))) |
							(1<<(pi_ac->antdiv_rfswctrlpin_a1-8)));
			      } else {
			        femctrlout =
			        (femctrlout &
			        (~(1<<(pi_ac->antdiv_rfswctrlpin_a1-8))));
			      }
			    }
				}
	      wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, indx,
	        16, &femctrlout);
			}
		}
	}
}

static uint16 wlc_phy_femctrlout_get_val(uint32 val_ext, uint32 val, uint32 MASK)
{
	uint32 value = 0;
	value =  ((val_ext>>(MASK)) & 0x3)<<8 | ((val>>(MASK)) & 0xff);
	return (uint16) value;
}

#ifdef WL_SAR_SIMPLE_CONTROL
static void
BCMATTACHFN(wlc_phy_nvram_dynamicsarctrl_read)(phy_info_t *pi)
{
/* Nvram parameter to get sarlimits customized by user
 * Value interpetation:
 *  dynamicsarctrl_2g = 0x[core3][core2][core1][core0]
 * each core# has the bitmask followings:
 * 8th bit : 0 - sarlimit enable / 1 - sarlimit disable
 * 0 ~ 7 bits : qdbm power val (0x7f as a maxumum)
 */
	char phy_var_name[20];

	(void)snprintf(phy_var_name, sizeof(phy_var_name), "dynamicsarctrl_2g");
	if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi->dynamic_sarctrl_2g = (uint32)PHY_GETINTVAR(pi, phy_var_name);
	}

	(void)snprintf(phy_var_name, sizeof(phy_var_name), "dynamicsarctrl_5g");
	if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
		pi->dynamic_sarctrl_5g = (uint32)PHY_GETINTVAR(pi, phy_var_name);
	}
}
#endif /* WL_SAR_SIMPLE_CONTROL */

static void
BCMATTACHFN(wlc_phy_nvram_femctrl_read)(phy_info_t *pi)
{
	uint8 i;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (ACPHY_FEMCTRL_ACTIVE(pi)) {
		return;
	}

	if (PHY_GETVAR(pi, rstr_swctrlmap_2g)) {
		for (i = 0; i < ACPHY_SWCTRL_NVRAM_PARAMS; i++) {
			pi_ac->srom.nvram_femctrl.swctrlmap_2g[i] =
				(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_swctrlmap_2g, i);
		}
	} else {
		PHY_ERROR(("%s: Switch control map(%s) is NOT found\n",
		           __FUNCTION__, rstr_swctrlmap_2g));
	}

	if (PHY_GETVAR(pi, rstr_swctrlmapext_2g)) {
			for (i = 0; i < ACPHY_SWCTRL_NVRAM_PARAMS; i++) {
				pi_ac->srom.nvram_femctrl.swctrlmapext_2g[i] =
					(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_swctrlmapext_2g, i);
			}
	}

	if (PHY_GETVAR(pi, rstr_swctrlmap_5g)) {
			for (i = 0; i < ACPHY_SWCTRL_NVRAM_PARAMS; i++) {
				pi_ac->srom.nvram_femctrl.swctrlmap_5g[i] =
					(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_swctrlmap_5g, i);
			}
	} else {
		PHY_ERROR(("%s: Switch control map(%s) is NOT found\n",
		           __FUNCTION__, rstr_swctrlmap_5g));
	}

	if (PHY_GETVAR(pi, rstr_swctrlmapext_5g)) {
			for (i = 0; i < ACPHY_SWCTRL_NVRAM_PARAMS; i++) {
				pi_ac->srom.nvram_femctrl.swctrlmapext_5g[i] =
					(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_swctrlmapext_5g, i);
			}
	}

	pi_ac->srom.nvram_femctrl.txswctrlmap_2g =
		(uint32) PHY_GETINTVAR_DEFAULT(pi, rstr_txswctrlmap_2g, PAMODE_HI_LIN);

	pi_ac->srom.nvram_femctrl.txswctrlmap_2g_mask =
		(uint16) PHY_GETINTVAR_DEFAULT(pi, rstr_txswctrlmap_2g_mask, 0x3fff);

	pi_ac->srom.nvram_femctrl.txswctrlmap_5g =
		(uint32) PHY_GETINTVAR_DEFAULT(pi, rstr_txswctrlmap_5g, PAMODE_HI_LIN);

	if (PHY_GETVAR(pi, rstr_fem_table_init_val)) {
		pi_ac->srom.nvram_femctrl.init_val_2g =
			(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_fem_table_init_val, 0);
		pi_ac->srom.nvram_femctrl.init_val_5g =
			(uint32) PHY_GETINTVAR_ARRAY(pi, rstr_fem_table_init_val, 1);
	}
}

static void
wlc_phy_set_reg_on_bw_change_acphy(phy_info_t *pi)
{
	uint8 core;
	const bool chspec_is20 = CHSPEC_IS20(pi->radio_chanspec);
	const bool chspec_is40 = CHSPEC_IS40(pi->radio_chanspec);

	if (TINY_RADIO(pi))
		MOD_PHYREG(pi, TssiEnRate, StrobeRateOverride, 1);
	MOD_PHYREG(pi, TssiEnRate, StrobeRate, chspec_is20 ?
		0x1 : chspec_is40 ? 0x2 : 0x3);
	MOD_PHYREG(pi, ClassifierCtrl, mac_bphy_band_sel, chspec_is20 ?
		0x1 : chspec_is40 ? 0x0  : 0x0);
	MOD_PHYREG(pi, RxControl, bphy_band_sel, chspec_is20 ?
		0x1 : chspec_is40 ? 0x0 : 0x0);
	MOD_PHYREG(pi, DcFiltAddress, dcCoef0, chspec_is20 ?
		0x15 : chspec_is40 ? 0xb : 0x5);

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, CRSMiscellaneousParam, crsMfFlipCoef,
			chspec_is20 ? 0x0 : 0x1);
		MOD_PHYREG(pi, iqest_input_control, dc_accum_wait_vht,
			chspec_is20 ? 0xc : chspec_is40 ? 0x1d : 0x3b);
		MOD_PHYREG(pi, iqest_input_control, dc_accum_wait_mm,
			chspec_is20 ? 0xb : chspec_is40 ? 0x1b : 0x37);
	}

	if (!TINY_RADIO(pi)) {
		MOD_PHYREG(pi, RxFilt40Num00, RxFilt40Num00, chspec_is20 ?
			0x146 : chspec_is40 ? 0x181 : 0x17a);
		MOD_PHYREG(pi, RxFilt40Num01, RxFilt40Num01, chspec_is20 ?
			0x88 : chspec_is40 ? 0x5a : 0x9e);
		MOD_PHYREG(pi, RxFilt40Num02, RxFilt40Num02, chspec_is20 ?
			0x146 : chspec_is40 ? 0x181 : 0x17a);
		MOD_PHYREG(pi, RxFilt40Den00, RxFilt40Den00, chspec_is20 ?
			0x76e : chspec_is40 ? 0x793 : 0x7ca);
		MOD_PHYREG(pi, RxFilt40Den01, RxFilt40Den01, chspec_is20 ?
			0x1a8 : chspec_is40 ? 0x1b7 : 0x1b2);
		MOD_PHYREG(pi, RxFilt40Num10, RxFilt40Num10, chspec_is20 ?
			0xa3 : chspec_is40 ? 0xc1 : 0xbd);
		MOD_PHYREG(pi, RxFilt40Num11, RxFilt40Num11, chspec_is20 ?
			0xf4 : chspec_is40 ? 0x102 : 0x114);
		MOD_PHYREG(pi, RxFilt40Num12, RxFilt40Num12, chspec_is20 ?
			0xa3 : chspec_is40 ? 0xc1 : 0xbd);
		MOD_PHYREG(pi, RxFilt40Den10, RxFilt40Den10, chspec_is20 ?
			0x684 : chspec_is40 ? 0x6c0 : 0x6d6);
		MOD_PHYREG(pi, RxFilt40Den11, RxFilt40Den11, chspec_is20 ?
			0xad : chspec_is40 ? 0xa9 : 0xa2);
		MOD_PHYREG(pi, RxStrnFilt40Num00, RxStrnFilt40Num00,
			chspec_is20 ? 0xe5 : chspec_is40 ? 0x162 : 0x16c);
		MOD_PHYREG(pi, RxStrnFilt40Num01, RxStrnFilt40Num01,
			chspec_is20 ? 0x68 : chspec_is40 ? 0x42 : 0x6f);
		MOD_PHYREG(pi, RxStrnFilt40Num02, RxStrnFilt40Num02,
			chspec_is20 ? 0xe5 : chspec_is40 ? 0x162 : 0x16c);
		MOD_PHYREG(pi, RxStrnFilt40Den00, RxStrnFilt40Den00,
			chspec_is20 ? 0x6be : chspec_is40 ? 0x75c : 0x793);
		MOD_PHYREG(pi, RxStrnFilt40Den01, RxStrnFilt40Den01,
			chspec_is20 ? 0x19e : chspec_is40 ? 0x1b3 : 0x1b2);
		MOD_PHYREG(pi, RxStrnFilt40Num10, RxStrnFilt40Num10,
			chspec_is20 ? 0x73 : chspec_is40 ? 0xb1 : 0xb6);
		MOD_PHYREG(pi, RxStrnFilt40Num11, RxStrnFilt40Num11,
			chspec_is20 ? 0xb2 : chspec_is40 ? 0xed : 0xff);
		MOD_PHYREG(pi, RxStrnFilt40Num12, RxStrnFilt40Num12,
			chspec_is20 ? 0x73 : chspec_is40 ? 0xb1 : 0xb6);
		MOD_PHYREG(pi, RxStrnFilt40Den10, RxStrnFilt40Den10,
			chspec_is20 ? 0x5fe : chspec_is40 ? 0x692 : 0x6b4);
		MOD_PHYREG(pi, RxStrnFilt40Den11, RxStrnFilt40Den11,
			chspec_is20 ? 0xcc : chspec_is40 ? 0xaf : 0xa8);
	}
	MOD_PHYREG(pi, nvcfg3, noisevar_rxevm_lim_qdb, chspec_is20 ?
		0x97 : chspec_is40 ? 0x8b : 0x97);
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		MOD_PHYREG(pi, RadarBlankCtrl, radarBlankingInterval,
			chspec_is20 ? 0x19 : chspec_is40 ? 0x32 : 0x32);
		MOD_PHYREG(pi, RadarT3BelowMin, Count, chspec_is20 ?
			0x14 : chspec_is40 ? 0x28 : 0x28);
		MOD_PHYREG(pi, RadarT3Timeout, Timeout, chspec_is20 ?
			0xc8 : chspec_is40 ? 0x190 : 0x190);
		MOD_PHYREG(pi, RadarResetBlankingDelay, Count, chspec_is20 ?
			0x19 : chspec_is40 ? 0x32 : 0x32);
	}
	MOD_PHYREG(pi, ClassifierCtrl6, logACDelta2, chspec_is20 ?
		0x13 : chspec_is40 ? 0x13 : 0x9);
	MOD_PHYREG(pi, ClassifierLogAC1, logACDelta1, chspec_is20 ?
		0x13 : chspec_is40 ? 0x13 : 0x9);
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, bphyPreDetectThreshold6, ac_det_1us_aci_th,
				chspec_is20 ? 0x80 : chspec_is40 ? 0x200 : 0x200);
		}
	}
	FOREACH_CORE(pi, core) {
		MOD_PHYREGC(pi, Adcclip, core, adc_clip_cnt_th, chspec_is20 ?
			0xa : chspec_is40 ? 0x14 : 0x14);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcNbClipCntTh,
			chspec_is20 ? 0x17 : chspec_is40 ? 0x2a : 0x54);
		MOD_PHYREGC(pi, FastAgcClipCntTh, core, fastAgcW1ClipCntTh,
			chspec_is20 ? 0xe : chspec_is40 ? 0x16 : 0x2c);
	}
	if (!ACMAJORREV_0(pi->pubpi.phy_rev) &&
	    !(ACMAJORREV_2(pi->pubpi.phy_rev) && ACMINORREV_0(pi->pubpi.phy_rev))) {
		MOD_PHYREG(pi, CRSMiscellaneousParam, crsMfFlipCoef, chspec_is20 ?
			0x0 : 0x1);
	}
	/* FIX ME : Currently setting only for 4350, Other phy revs should
	 * check with RTL folks and set accordingly
	 */
	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, FSTRCtrl, fineStrSgiVldCntVal, chspec_is20 ?
			0x9 : 0xa);
		MOD_PHYREG(pi, FSTRCtrl, fineStrVldCntVal, chspec_is20 ?
			0x9 : 0xa);
	}
}

void wlc_acphy_set_scramb_dyn_bw_en(wlc_phy_t *pih, bool enable)
{
	phy_info_t *pi = (phy_info_t *)pih;

	wlc_phyreg_enter(pih);
	MOD_PHYREG(pi, NsyncscramInit1, scramb_dyn_bw_en, (enable) ? 1 : 0);
	wlc_phyreg_exit(pih);
}

static void
wlc_phy_init_adc_read(phy_info_t* pi, uint16* save_afePuCtrl, uint16* save_gpio,
                      uint32* save_chipc, uint16* fval2g_orig, uint16* fval5g_orig,
                      uint16* fval2g, uint16* fval5g, uint8* stall_val,
                      uint16* save_gpioHiOutEn)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	*stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	*save_afePuCtrl = READ_PHYREGFLD(pi, AfePuCtrl, tssiSleepEn);
	MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, 0);
	*save_gpio = READ_PHYREG(pi, gpioSel);
	*save_gpioHiOutEn = READ_PHYREG(pi, gpioHiOutEn);

	if (pi_ac->poll_adc_WAR) {
		ACPHY_REG_LIST_START
			ACPHY_DISABLE_STALL_ENTRY(pi)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_2g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_5g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, override_ext_pa, 1)
		ACPHY_REG_LIST_EXECUTE(pi);

		*save_chipc = si_corereg(pi->sh->sih, SI_CC_IDX,
		                         OFFSETOF(chipcregs_t, chipcontrol), 0, 0);
		si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
		           0xffffffff, CCTRL4360_EXTRA_FEMCTRL_MODE);

		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 41, 16, fval2g_orig);
		wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 57, 16, fval5g_orig);

		*fval2g = (*fval2g_orig & 0xf0) << 1;
		*fval5g = (*fval5g_orig & 0xf);

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 41, 16, fval2g);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 57, 16, fval5g);

		ACPHY_REG_LIST_START
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_2g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_5g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, override_ext_pa, 0)
		ACPHY_REG_LIST_EXECUTE(pi);

		ACPHY_ENABLE_STALL(pi, *stall_val);
	}
}

static void
wlc_phy_restore_after_adc_read(phy_info_t *pi, uint16* save_afePuCtrl, uint16 *save_gpio,
                               uint32* save_chipc, uint16* fval2g_orig, uint16* fval5g_orig,
                               uint16* fval2g, uint16* fval5g, uint8* stall_val,
                               uint16* save_gpioHiOutEn)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	ACPHY_DISABLE_STALL(pi);
	WRITE_PHYREG(pi, gpioSel, *save_gpio);
	WRITE_PHYREG(pi, gpioHiOutEn, *save_gpioHiOutEn);
	if (pi_ac->poll_adc_WAR) {
		ACPHY_REG_LIST_START
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_2g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_5g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, override_ext_pa, 1)
		ACPHY_REG_LIST_EXECUTE(pi);

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 41, 16, fval2g_orig);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT, 1, 57, 16, fval5g_orig);

		si_corereg(pi->sh->sih, SI_CC_IDX, OFFSETOF(chipcregs_t, chipcontrol),
		           0xffffffff, *save_chipc);

		ACPHY_REG_LIST_START
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_2g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, ext_5g_papu, 0)
			MOD_PHYREGCE_ENTRY(pi, RfctrlIntc, 1, override_ext_pa, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	MOD_PHYREG(pi, AfePuCtrl, tssiSleepEn, *save_afePuCtrl);

	ACPHY_ENABLE_STALL(pi, *stall_val);
}

#ifdef PREASSOC_PWRCTRL
void
wlc_phy_store_tx_pwrctrl_setting_acphy(phy_info_t *pi, chanspec_t previous_channel)
{
	uint8 core, iidx;

	if (CHSPEC_IS5G(previous_channel)) {
		pi->u.pi_acphy->pwr_ctrl_save.last_chan_stored_5g = previous_channel;

	} else {
		pi->u.pi_acphy->pwr_ctrl_save.last_chan_stored_2g = previous_channel;

	}
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		iidx = READ_PHYREGFLDCE(pi, TxPwrCtrlStatus_path, core, baseIndex);
		if (CHSPEC_IS5G(previous_channel)) {
			pi->u.pi_acphy->pwr_ctrl_save.status_idx_5g[core] = iidx;
			pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_5g[core] =
			        wlc_phy_txpwrctrl_get_target_acphy(pi, core);
			pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core] = TRUE;

		} else {
			pi->u.pi_acphy->pwr_ctrl_save.status_idx_2g[core] = iidx;
			pi->u.pi_acphy->pwr_ctrl_save.pwr_qdbm_2g[core] =
			        wlc_phy_txpwrctrl_get_target_acphy(pi, core);
			pi->u.pi_acphy->pwr_ctrl_save.stored_not_restored_5g[core] = TRUE;
		}

	}
}

void
wlc_phy_pwrctrl_shortwindow_upd_acphy(phy_info_t *pi, bool shortterm)
{
	if (shortterm) {
		/* 2 packet avergaing */
		MOD_PHYREG(pi, TxPwrCtrlNnum, Npt_intg_log2, PWRCTRL_SHORTW_AVG);
	} else {
		/* 16 packet avergaing */
		MOD_PHYREG(pi, TxPwrCtrlNnum, Npt_intg_log2, PWRCTRL_LONGW_AVG);
	}
}

static uint8
wlc_phy_txpwrctrl_get_target_acphy(phy_info_t *pi, uint8 core)
{
	/* set target powers in 6.2 format (in dBs) */
	switch (core) {
	case 0:
		return READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path0, targetPwr0);
		break;
	case 1:
		return READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path1, targetPwr1);
		break;
	case 2:
		return READ_PHYREGFLD(pi, TxPwrCtrlTargetPwr_path2, targetPwr2);
		break;
	}
	return 0;
}
#endif /* PREASSOC_PWRCTRL */

void
wlc_phy_aci_w2nb_setup_acphy(phy_info_t *pi, bool on)
{
	uint8 core, on_off;

	on_off = on ? 1 : 0;
	FOREACH_CORE(pi, core) {
		MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_wrssi2_pwrup, on_off);
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_wrssi2_pwrup, 0x1);

#ifndef WLC_DISABLE_ACI
		if (TINY_RADIO(pi))
			PHY_INFORM(("%s: HWACI not yet implemented for Tiny Radio chips\n",
				__FUNCTION__));
		else if (on) {
			MOD_RADIO_REGC(pi, LNA5G_RSSI, core,
			               dig_wrssi2_threshold, pi->u.pi_acphy->hwaci_args.w2);
			if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev)) {
				MOD_RADIO_REGC(pi, LNA2G_RSSI, core,
				               dig_wrssi2_threshold, pi->u.pi_acphy->hwaci_args.w2);
			}
		}
#endif /* !WLC_DISABLE_ACI */
	}
}

#ifndef WLC_DISABLE_ACI
void
wlc_phy_hwaci_setup_acphy(phy_info_t *pi, bool on, bool init)
{
	uint8 core, on_off;
	uint8 wrssi3_ib_Refbuf;
	uint8 nbrssi_Refctrl_low;
	uint8 wrssi3_Refctrl_low, wrssi3_Refctrl_mid, wrssi3_Refctrl_high;
	uint8 wrssi3_ib_powersaving, wrssi3_ib_Refladder;
	uint16 regval;

	/* For ACI_Detect_CTRL */
	uint8 aci_detect_window_size;
	uint8 aci_rpt_det_ctr_clren;
	uint8 aci_detect_enable;
	uint8 aci_detect_clkenable;

	uint8 aci_present_th;

	/* For ACPHY_ACI_Detect_collect_interval */
	uint8 aci_detect_collect_interval;

	/* ACI_Detect_wait_period 0x552 0x553 */
	uint16 aci_detect_wait_period;

	/* Energy and detect threshold 0x554 0x555 0x556 0x557 */
	uint16 aci_detect_energy_threshold;
	uint16 aci_detect_diff_threshold;
	uint16 aci_detect_energy_threshold_w2;
	uint16 aci_detect_diff_threshold_w2;

	/* ACI_Detect_MAX_COUNT 0x558 0x559 */
	uint32 max_count;
	uint16 sample_time_period_ms;
	acphy_hwaci_setup_t hwaci;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	on_off = on ? 1 : 0;

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    AC4354REV(pi) || ACHWACIREV(pi)) {
		on_off = on ? 7 : 0;
	}
	FOREACH_CORE(pi, core) {
		MOD_PHYREGCE(pi, RfctrlCoreTxPus, core, lpf_wrssi3_pwrup, on_off);
		MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, lpf_wrssi3_pwrup, 0x1);
	}
	if (ACHWACIREV(pi)) {
		FOREACH_CORE(pi, core) {
			MOD_PHYREGCE(pi, RfctrlCoreRxPus, core, rxrf_lna2_wrssi2_pwrup, 1);
			MOD_PHYREGCE(pi, RfctrlOverrideRxPus, core, rxrf_lna2_wrssi2_pwrup, 0x1);
		}
	}
	if (!init) return;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM2069_ID);

	hwaci = pi_ac->hwaci_args;

	/* These are the thresholds of comparators */
	wrssi3_ib_Refladder = 0x0;
	wrssi3_ib_Refbuf = 0x0;
	wrssi3_ib_powersaving = 0x0;
	nbrssi_Refctrl_low = hwaci.nb_lo_th;
	wrssi3_Refctrl_low = hwaci.w3_lo_th;
	wrssi3_Refctrl_mid = hwaci.w3_md_th;
	wrssi3_Refctrl_high = hwaci.w3_hi_th;

	/* For ACI_Detect_CTRL */
	aci_detect_window_size = hwaci.sliding_window;
	aci_rpt_det_ctr_clren = 1;
	aci_detect_enable = 1;
	aci_detect_clkenable = 1;
	aci_present_th = hwaci.aci_present_th;

	/* For ACPHY_ACI_Detect_collect_interval */
	aci_detect_collect_interval = hwaci.samp_cluster;

	/* ACI_Detect_wait_period 0x552 0x553 */
	aci_detect_wait_period = hwaci.wait_period;

	/* Energy and detect threshold 0x554 0x555 0x556 0x557 */
	aci_detect_energy_threshold = hwaci.energy_thresh;
	aci_detect_diff_threshold = hwaci.detect_thresh;
	aci_detect_energy_threshold_w2 = hwaci.energy_thresh_w2;
	aci_detect_diff_threshold_w2 = hwaci.detect_thresh;

	/* ACI_Detect_MAX_COUNT 0x558 0x559 */
	/* For 1 sec, it is = 1000 */
	sample_time_period_ms = hwaci.sample_time;
	FOREACH_CORE(pi, core) {
		/*  Configure nb_low can't touch mid, hi as auto-gainctrl is going to pick those */
		MOD_RADIO_REGC(pi, NBRSSI_CONFG, core, nbrssi_Refctrl_low, nbrssi_Refctrl_low);

		/* Configure w3 */
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core, wrssi3_ib_Refladder, wrssi3_ib_Refladder);
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core, wrssi3_ib_Refbuf, wrssi3_ib_Refbuf);
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core,
		               wrssi3_ib_powersaving, wrssi3_ib_powersaving);
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core, wrssi3_Refctrl_low, wrssi3_Refctrl_low);
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core, wrssi3_Refctrl_mid, wrssi3_Refctrl_mid);
		MOD_RADIO_REGC(pi, WRSSI3_CONFG, core, wrssi3_Refctrl_high, wrssi3_Refctrl_high);

		if (ACHWACIREV(pi)) {
			if (CHSPEC_IS2G(pi->radio_chanspec)) {
			  MOD_RADIO_REGC(pi, LNA2G_RSSI, core, dig_wrssi2_threshold, hwaci.w2);
			} else {
			  MOD_RADIO_REGC(pi, LNA5G_RSSI, core, dig_wrssi2_threshold, hwaci.w2);
			}
		}
	}

	/* ACPHY_ACI_Detect_CTRL */
	/* Reset ACI detection block */
	MOD_PHYREG(pi, ACI_Detect_CTRL, aci_detect_enable, 0);
	regval = READ_PHYREG(pi, ACI_Detect_CTRL);
	regval = (regval & ~ACPHY_ACI_Detect_CTRL_aci_detect_enable_MASK(pi->pubpi.phy_rev)) |
	        (aci_detect_enable <<
		 ACPHY_ACI_Detect_CTRL_aci_detect_enable_SHIFT(pi->pubpi.phy_rev));
	regval = (regval & ~ACPHY_ACI_Detect_CTRL_aci_report_ctr_clren_MASK(pi->pubpi.phy_rev)) |
	        (aci_rpt_det_ctr_clren <<
		 ACPHY_ACI_Detect_CTRL_aci_report_ctr_clren_SHIFT(pi->pubpi.phy_rev));
	regval = (regval & ~ACPHY_ACI_Detect_CTRL_aci_detected_ctr_clren_MASK(pi->pubpi.phy_rev)) |
	        (aci_rpt_det_ctr_clren <<
		 ACPHY_ACI_Detect_CTRL_aci_detected_ctr_clren_SHIFT(pi->pubpi.phy_rev));
	regval = (regval &
		~ACPHY_ACI_Detect_CTRL_aci_detect_window_size_1_MASK(pi->pubpi.phy_rev)) |
	        (aci_detect_window_size <<
		 ACPHY_ACI_Detect_CTRL_aci_detect_window_size_1_SHIFT(pi->pubpi.phy_rev));
	regval = (regval &
		~ACPHY_ACI_Detect_CTRL_aci_detect_window_size_2_MASK(pi->pubpi.phy_rev)) |
	        (aci_detect_window_size <<
		 ACPHY_ACI_Detect_CTRL_aci_detect_window_size_2_SHIFT(pi->pubpi.phy_rev));

	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    AC4354REV(pi) || ACHWACIREV(pi)) {

		regval = (regval &
			~ACPHY_ACI_Detect_CTRL_aci_detect_clkenable_MASK(pi->pubpi.phy_rev)) |
		        (aci_detect_clkenable <<
			 ACPHY_ACI_Detect_CTRL_aci_detect_clkenable_SHIFT(pi->pubpi.phy_rev));
	}
	WRITE_PHYREG(pi, ACI_Detect_CTRL, regval);

	/* ACPHY_ACI_Detect_collect_interval */
	MOD_PHYREG(pi, ACI_Detect_collect_interval, aci_detect_collect_interval_1,
	           aci_detect_collect_interval);
	MOD_PHYREG(pi, ACI_Detect_collect_interval, aci_detect_collect_interval_2,
	           aci_detect_collect_interval);

	/* ACI_Detect_wait_period */
	WRITE_PHYREG(pi, ACI_Detect_wait_period_1, aci_detect_wait_period);
	WRITE_PHYREG(pi, ACI_Detect_wait_period_2, aci_detect_wait_period);

	if (AC4354REV(pi) || ACHWACIREV(pi)) {

		/* Energy threshold */
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1_w3, aci_detect_energy_threshold);
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2_w3, aci_detect_energy_threshold);

		/* Detect threshold */
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_1_w3, aci_detect_diff_threshold);
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_2_w3, aci_detect_diff_threshold);

		/* Energy threshold */
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1_w12, aci_detect_energy_threshold_w2);
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2_w12, aci_detect_energy_threshold_w2);

		/* Detect threshold */
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_1_w12, aci_detect_diff_threshold_w2);
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_2_w12, aci_detect_diff_threshold_w2);

	} else {
		/* Energy threshold */
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_1, aci_detect_energy_threshold);
		WRITE_PHYREG(pi, ACI_Detect_energy_threshold_2, aci_detect_energy_threshold);
		/* Detect threshold */
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_1, aci_detect_diff_threshold);
		WRITE_PHYREG(pi, ACI_Detect_detect_threshold_2, aci_detect_diff_threshold);
	}
	/* max count = time/0.8 us */
	max_count = sample_time_period_ms * 1000 * 10/8;
	WRITE_PHYREG(pi, ACI_Detect_MAX_COUNT_LO, (uint16) (max_count & 0xffff));
	WRITE_PHYREG(pi, ACI_Detect_MAX_COUNT_HI, (uint16) (max_count >> 16));

	/* SlnaControl bt prisel to be inv for 2G HWACI to work 4335C0 */
	if ((ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) ||
	    ACMAJORREV_3(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, SlnaControl, inv_btcx_prisel_polarity, 1);
	}
	if (ACHWACIREV(pi)) {
		MOD_PHYREG(pi, ACI_Mitigation_CTRL1, aci_present_th_mit_on_w12, aci_present_th);
		MOD_PHYREG(pi, ACI_Mitigation_CTRL1, aci_present_th_mit_off_w12, aci_present_th);
		MOD_PHYREG(pi, ACI_Mitigation_CTRL, aci_present_th_mit_on_w3, aci_present_th);
		MOD_PHYREG(pi, ACI_Mitigation_CTRL, aci_present_th_mit_off_w3, aci_present_th);
		MOD_PHYREG(pi, ACI_Detect_CTRL1, aci_present_select, hwaci.aci_present_select);

		if ((pi->sh->interference_mode & ACPHY_HWACI_MITIGATION) == 0) {
		  /* HW ACI Detection and SW Mitigation */
		  ACPHY_REG_LIST_START
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hwtrig_disable, 1)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hw_enable, 1)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 1)
		    MOD_PHYREG_ENTRY(pi, ACI_Detect_report_ctr_threshold_lo, aci_report_ctr_th_lo,
		      30)
		  ACPHY_REG_LIST_EXECUTE(pi)
		} else {
		  /* HW ACI Detection and HW Mitigation */
		  ACPHY_REG_LIST_START
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hwtrig_disable, 1)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, ACIMitigationIndicatorBit, 0)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, ACIMitigationONShadowBit, 0)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, Disable_ChannelIndicator, 1)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hw_enable, 2)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_timeout_LO, aci_mitigation_timeout_lo, 0)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_timeout_HI, aci_mitigation_timeout_hi, 0)
		    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 0)
		    MOD_PHYREG_ENTRY(pi, ACI_Detect_report_ctr_threshold_lo, aci_report_ctr_th_lo,
		      30)
		  ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

}

/* From proc acphy_hwaci_mitigation_enable {{ enable 0 }} { */
void
wlc_phy_hwaci_mitigation_enable_acphy_tiny(phy_info_t *pi, uint8 hwaci_mode, bool init)
{
	ASSERT(ACPHY_ENABLE_FCBS_HWACI(pi));

	switch (hwaci_mode) {
	case 1:
	case 2:
	case 3:
		PHY_ACI(("Tiny HWACI: Enable clocks, preempt \n"));
		if (init) {
			/* Disable HWACI while updating FCBS */
			wlc_phy_hwaci_mitigation_enable_acphy_tiny(pi, 0, FALSE);
			wlc_phy_preempt(pi, TRUE);
			wlc_phy_hwaci_fcbsinit_acphy(pi);
			wlc_phy_init_FCBS_hwaci(pi);
			ACPHY_REG_LIST_START
			    MOD_PHYREG_ENTRY(pi, SlnaControl, inv_btcx_prisel_polarity, 1)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_clkenable, 1)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_enable, 1)
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hw_enable, 2)
			ACPHY_REG_LIST_EXECUTE(pi);
			}
		break;

	default:
		PHY_ACI(("Tiny HWACI: Disable HW-ACI-Mitigation\n"));
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_clkenable, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_enable, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_hw_enable, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
		break;
	}

	switch (hwaci_mode) {
	case 1:
		if (init) {
			PHY_ACI(("Tiny HWACI: AUTO mode\n"));
			/*
			 * From proc do_aci_setup Optimise by
			 * amalgamating writes by using WRITE_PHYREG
			 */
			ACPHY_REG_LIST_START
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 0)
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_present_th_mit_off, 5)
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_present_th_mit_on, 5)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_report_ctr_threshold,
			        aci_report_ctr_th, 0)

			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_status, aci_pwr_input_shift, 6)
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_status, aci_pwr_block_shift, 4)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_collect_interval,
			        aci_detect_collect_interval_1, 2)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_collect_interval,
			        aci_detect_collect_interval_2, 2)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_wait_period_1,
			        aci_detect_wait_period_1, 0x1)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_wait_period_2,
			        aci_detect_wait_period_2, 0xff)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_window_size_1, 8)
			    MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_detect_window_size_2, 8)

			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_status, aci_T_RSSI_select, 0)
			    MOD_PHYREG_ENTRY(pi, ACI_Mitigation_status, aci_detect_direct_output, 1)

			    /* these are for eLNA boards only */
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config1, 0x03e8)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config2, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config3, 0x00c8)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config4, 0x0064)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config5, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config6, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config7, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config8, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config9, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config10, 0x0)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config11, 0x0451)
			    WRITE_PHYREG_ENTRY(pi, Tiny_ACI_config12, 0x0534)
			ACPHY_REG_LIST_EXECUTE(pi);
			}
		break;

	case 2:
		PHY_ACI(("Tiny HWACI: Forced NORMAL mode \n"));
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_sel, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
		break;

	case 3:
		PHY_ACI(("Tiny HWACI: Forced ACI mode \n"));
		ACPHY_REG_LIST_START
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 0)
			MOD_PHYREG_ENTRY(pi, ACI_Detect_CTRL, aci_sel, 1)
			MOD_PHYREG_ENTRY(pi, ACI_Mitigation_CTRL, aci_mitigation_sw_enable, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
		break;

	default:
		break;
		}

	MOD_PHYREG(pi, aci_detector_reset, aci_soft_reset, 1);
	MOD_PHYREG(pi, aci_detector_reset, aci_soft_reset, 0);
}

/*  From proc init_fastcsTbl_for_aci_detector {} { */
static void
wlc_phy_init_FCBS_hwaci(phy_info_t *pi)
{

/*
 * Initialise FCBS table with ACI mitigation settings.
 * These are generated by running AGC config code
 * and then copying values to FCBS.
 *
 */

	uint16 val;
	uint16 *ptr_val;
	int i;

	uint16 fastchswTableIndex, startoffset;

	uint16 *reg_list_ptr;
	hwaci_fcbs_phytbl_list_entry  *tbl_list_ptr;

	const uint16 fcbs_table_delim = 0xffff;

	ASSERT(ACPHY_ENABLE_FCBS_HWACI(pi));

	ptr_val = &val;

	fastchswTableIndex = startoffset =
		READ_PHYREGFLD(pi, ACI_Mitigation_CTRL1, ACIMitigation_iniraddr);

	pi->u.pi_acphy->curr_desense.ofdm_desense = 0;
	pi->u.pi_acphy->curr_desense.bphy_desense = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[0] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[1] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[2] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[3] = 0;
	pi->u.pi_acphy->curr_desense.lna1_tbl_desense = 0;

	wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(pi, 0, ACPHY_TBL_ID_GAIN0,
		ACPHY_TBL_ID_GAINBITS0);
	wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);

/* First write the Normal values, reg addresses, tbl id and delimiters */
	for (reg_list_ptr = hwaci_fcbs_rfregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = read_radio_reg(pi, *reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		fastchswTableIndex += 3;
	}

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;

	for (reg_list_ptr = hwaci_fcbs_phyregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = phy_reg_read(pi, *reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		fastchswTableIndex += 3;
	}

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;

	for (tbl_list_ptr = hwaci_fcbs_phytbls; tbl_list_ptr->tbl_id != 0xFFFF;  tbl_list_ptr++) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, &tbl_list_ptr->tbl_id);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, &tbl_list_ptr->tbl_offset);
		/* calc end offset */
		val = tbl_list_ptr->tbl_offset + tbl_list_ptr->num_entries - 1;
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);

		fastchswTableIndex += 3; /* point to first normal entry */
		for (i = 0; i < tbl_list_ptr->num_entries;  i++) {
			wlc_phy_table_read_acphy(pi, tbl_list_ptr->tbl_id, 1,
				tbl_list_ptr->tbl_offset + i, 16, ptr_val);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1,
				fastchswTableIndex, 16, ptr_val);
/* set to next normal entry OR table id  OR delimiter */
			fastchswTableIndex += 2;
		}
	}

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);

/* Write the ACI values */

	fastchswTableIndex = startoffset;

	pi->u.pi_acphy->curr_desense.ofdm_desense = 15;
	pi->u.pi_acphy->curr_desense.bphy_desense = 15;
	pi->u.pi_acphy->curr_desense.clipgain_desense[0] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[1] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[2] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[3] = 0;

	pi->u.pi_acphy->curr_desense.lna1_tbl_desense = 1;

	wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(pi, 0, ACPHY_TBL_ID_GAIN0,
		ACPHY_TBL_ID_GAINBITS0);
	wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);

	for (reg_list_ptr = hwaci_fcbs_rfregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = read_radio_reg(pi, *reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
	}

	fastchswTableIndex += 1; /* skip delimiter */

	for (reg_list_ptr = hwaci_fcbs_phyregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = phy_reg_read(pi, *reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
	}

	fastchswTableIndex += 1;  /* skip delimiter */

	for (tbl_list_ptr = hwaci_fcbs_phytbls; tbl_list_ptr->tbl_id != 0xFFFF;  tbl_list_ptr++) {
		fastchswTableIndex += 4;   /* point to first aci entry */
		for (i = 0; i < tbl_list_ptr->num_entries;  i++) {
			wlc_phy_table_read_acphy(pi, tbl_list_ptr->tbl_id,  1,
				tbl_list_ptr->tbl_offset + i, 16, ptr_val);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1,
				fastchswTableIndex,	16, ptr_val);
			/* point to next aci entry, next table, or delimiter */
			fastchswTableIndex += 2;
		}
		fastchswTableIndex -= 1;  /* back up one to point to Table ID entry */
	}

	fastchswTableIndex += 1; /* skip delimiter */
/*
 * Fill up rest of table with delimiters
 * FIXME: USE #define for FCBS table size???
 */
	while ((fastchswTableIndex) < 800) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, &fcbs_table_delim);
		fastchswTableIndex += 1;
	}

	pi->u.pi_acphy->curr_desense.ofdm_desense = 0;
	pi->u.pi_acphy->curr_desense.bphy_desense = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[0] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[1] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[2] = 0;
	pi->u.pi_acphy->curr_desense.clipgain_desense[3] = 0;
	pi->u.pi_acphy->curr_desense.lna1_tbl_desense = 0;

	wlc_phy_rxgainctrl_set_gaintbls_acphy_20691(pi, 0, ACPHY_TBL_ID_GAIN0,
		ACPHY_TBL_ID_GAINBITS0);
	wlc_phy_rxgainctrl_gainctrl_acphy_tiny(pi);

}
#endif /* !WLC_DISABLE_ACI */

/* Required FEM tabel update to enable simultaneous RX.
    Since PRIEL is to WLAN, bt tX should trigger FEM to BT-TX.
    In addition, BT RX signal input to FEM, is muxed out only WLAN RX is
    available, we have to assume BT RX whenever BT is not transmitting.
*/
static void
wlc_phy_btcx_hybrid_mode_update_fem_acphy(phy_info_t *pi, bool on)
{
	/* number of fem lut entries to update */
	#define FEM_ENTRY_NUM 7

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 *val, *idx;
	int32 i;

	if (pi_ac->srom.femctrl == 10) {
		uint8 fem_idx[FEM_ENTRY_NUM] = {0, 1, 64, 65, 66, 67, 73};
		idx = fem_idx;
		if (pi_ac->srom.femctrl_sub == 5 ||
		    (!pi_ac->srom.femctrl_sub && pi->u.pi_acphy->srom.femctrl_from_nvram)) {
			/* 4350 X14 and stella */
			uint8 fem_val_ovr_on[FEM_ENTRY_NUM] = {40, 40, 56, 56, 56, 56, 56};
			uint8 fem_val_ovr_off[FEM_ENTRY_NUM] = {0, 0, 0, 0, 32, 40, 24};
			val = on ? fem_val_ovr_on : fem_val_ovr_off;

			for (i = 0; i < FEM_ENTRY_NUM; i++) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT,
				    1, idx[i], 8, &val[i]);
			}
		} else if (pi_ac->srom.femctrl_sub == 0) {
			/* 4350 FP */
			uint8 fem_val_ovr_on[FEM_ENTRY_NUM] = {32, 32, 128, 128, 128, 128, 128};
			uint8 fem_val_ovr_off[FEM_ENTRY_NUM] = {0, 0, 0, 0, 96, 32, 8};
			val = on ? fem_val_ovr_on : fem_val_ovr_off;

			for (i = 0; i < FEM_ENTRY_NUM; i++) {
				wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FEMCTRLLUT,
				    1, idx[i], 8, &val[i]);
			}
		}
	}
}

void
wlc_phy_btcx_hybrid_mode_simul_rx_acphy(phy_info_t *pi, uint8 mode)
{

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_btcx_hybrid_mode_simul_rx_t *hybrid_mode_simul_rx = &pi_ac->btcx_hybrid_mode_simul_rx;
	uint16 btcx_blk_ptr;
	uint16 btcx_wars;

	/* currently only on and off, preparing for a few more modes */
	hybrid_mode_simul_rx->mode = mode;

	if (!pi->sh->clk) return;

	btcx_blk_ptr = 2 * wlapi_bmac_read_shm(pi->sh->physhim, M_BTCX_BLK_PTR);
	btcx_wars = wlapi_bmac_read_shm(pi->sh->physhim, btcx_blk_ptr + M_BTCX_HOST_FLAGS);

	switch (mode) {
	case 0:
		/* hybrid mode off */

		hybrid_mode_simul_rx->on = FALSE;
		/* remove radio overrides */
		write_radio_reg(pi, RF_2069_OVR6(0), 0x0);

		/* remove prisel forcing */
		btcx_wars &= ~BTCWAR_ANT2WL_NBIT;

		wlc_phy_btcx_hybrid_mode_update_fem_acphy(pi, FALSE);

		break;

	case 1:

		/* hybrid mode - simultaneous RX : */
		hybrid_mode_simul_rx->on = TRUE;
		if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags2) & BFL2_BT_SHARE_ANT0)
			hybrid_mode_simul_rx->shared_core = 0;
		else
			hybrid_mode_simul_rx->shared_core = 1;

		/* AGC */
		hybrid_mode_simul_rx->shared_core_elna_bypass = 1;
		hybrid_mode_simul_rx->shared_core_lna1_idx = 5;
		hybrid_mode_simul_rx->shared_core_lna2_max_idx = 6;

		/* Radio overrides :
			LNA1 on,
			output kill switch to RX position,
			gain idx 5
		*/
		write_radio_reg(pi, RF_2069_LNA2G_CFG1(0),
			(5<<RF_2069_LNA2G_CFG1_lna1_gain_SHIFT) |
			RF_2069_LNA2G_CFG1_lna1_pu_MASK |
			RF_2069_LNA2G_CFG1_tr_rx_en_MASK);
		write_radio_reg(pi, RF_2069_OVR6(0),
			RF_2069_OVR6_ovr_lna2g_lna1_gain_MASK |
			RF_2069_OVR6_ovr_lna2g_lna1_pu_MASK |
			RF_2069_GE16_OVR6_ovr_lna2g_tr_rx_en_MASK);

		/* force prisel to wlan */
		btcx_wars |= BTCWAR_ANT2WL_NBIT;

		/* update FEM control table */
		wlc_phy_btcx_hybrid_mode_update_fem_acphy(pi, TRUE);

		break;
	}

	wlapi_bmac_write_shm(pi->sh->physhim, btcx_blk_ptr + M_BTCX_HOST_FLAGS, btcx_wars);

	wlc_phy_rxgainctrl_set_gaintbls_acphy(pi, TRUE, TRUE, TRUE);
	wlc_phy_rxgainctrl_gainctrl_acphy(pi);
}

void
wlc_phy_set_femctrl_bt_wlan_ovrd_acphy(phy_info_t *pi, int8 state)
{
	uint16 btcx_ctrl = 0;

	if (BCM4350_CHIP(pi->sh->chip)) {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		if (state == ON)
			wlc_phy_set_mask_for_femctrl10(pi);
		else
			MOD_PHYREG(pi, FemCtrl, femCtrlMask, 0x3ff);
		wlapi_enable_mac(pi->sh->physhim);
		btcx_ctrl = R_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_CTRL);
		if (state == ON) /* invert prisel polarity */
			W_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_CTRL,
				btcx_ctrl |= BTCX_CTRL_PRI_POL);
		else
			W_REG(pi->sh->osh, &pi->regs->PHYREF_BTCX_CTRL,
				btcx_ctrl &= ~BTCX_CTRL_PRI_POL);
	} else {
		wlapi_suspend_mac_and_wait(pi->sh->physhim);
		if (state == ON) {
			MOD_PHYREG(pi, BT_FemControl, bt_en, 1);
			MOD_PHYREG(pi, BT_FemControl, bt_en_ovrd, 1);
		} else if (state == OFF) {
			MOD_PHYREG(pi, BT_FemControl, bt_en, 0);
			MOD_PHYREG(pi, BT_FemControl, bt_en_ovrd, 1);
		} else {
			MOD_PHYREG(pi, BT_FemControl, bt_en_ovrd, 0);
			MOD_PHYREG(pi, BT_FemControl, bt_en, 0);
		}
		wlapi_enable_mac(pi->sh->physhim);
	}

	pi->u.pi_acphy->btswitch = state;
}

int8
wlc_phy_get_femctrl_bt_wlan_ovrd_acphy(phy_info_t *pi)
{
	return pi->u.pi_acphy->btswitch;
}

void
wlc_phydump_aci_acphy(phy_info_t *pi, struct bcmstrbuf *b)
{
	uint8 bw;
	acphy_desense_values_t *desense;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	int8 rssi = 0;

	if (SCAN_RM_IN_PROGRESS(pi)) {
		bcm_bprintf(b, "Scanning is in progress. Can't dump aci mitigation info.\n");
		return;
	}

	bw = CHSPEC_IS20(pi->radio_chanspec) ? 20 : (CHSPEC_IS40(pi->radio_chanspec) ? 40 : 80);

	if (pi_ac->aci != NULL)
		rssi = pi_ac->aci->weakest_rssi;

	/* Get total desense based on aci & bt */
	desense = &pi_ac->total_desense;
	bcm_bprintf(b, "\n");
	bcm_bprintf(b, "** Channel = %d(%d mhz), Weakest RSSI = %d, Associated = %d ** \n",
	            CHSPEC_CHANNEL(pi->radio_chanspec), bw, rssi,
	            !(ASSOC_INPROG_PHY(pi) || PUB_NOT_ASSOC(pi)));
	bcm_bprintf(b, "OFDM desense (dB) = %d\n", desense->ofdm_desense);
	bcm_bprintf(b, "BPHY desense (dB) = %d\n", desense->bphy_desense);
	bcm_bprintf(b, "lna1 tbl desense (ticks) = %d\n", desense->lna1_tbl_desense);
	bcm_bprintf(b, "lna2 tbl desense (ticks) = %d\n", desense->lna2_tbl_desense);
	bcm_bprintf(b, "lna1 pktgain limit (ticks) = %d\n", desense->lna1_gainlmt_desense);
	bcm_bprintf(b, "lna2 pktgain limit (ticks) = %d\n", desense->lna2_gainlmt_desense);
	bcm_bprintf(b, "lna1 ROUT tbl limit (ticks) = %d\n", desense->lna1_rout);
	bcm_bprintf(b, "lna2 ROUT tbl limit (ticks) = %d\n", desense->lna2_rout);
	bcm_bprintf(b, "lna1 ROUT pktgain limit (ticks) = %d\n", desense->lna1rout_gainlmt_desense);
	bcm_bprintf(b, "lna2 ROUT pktgain limit (ticks) = %d\n", desense->lna2rout_gainlmt_desense);
	bcm_bprintf(b, "elna bypass = %d\n", desense->elna_bypass);
	bcm_bprintf(b, "forced = %d\n", desense->forced);
	bcm_bprintf(b, "\n");
}

int8
wlc_phy_tssivisible_thresh_acphy(phy_info_t *pi)
{
	int8 visi_thresh_qdbm = WL_RATE_DISABLED;
#ifdef WLOLPC
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint16 channel = CHSPEC_CHANNEL(pi->radio_chanspec);

	if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
		/* J28 */
		if ((pi_ac->srom.femctrl == 3) && (pi_ac->srom.femctrl_sub == 2)) {
			visi_thresh_qdbm = 30;  /* 7.5*4 */
		} else {
			if (IS_X52C_BOARDTYPE(pi))
				visi_thresh_qdbm = 5*4;
			else if (IS_X29C_BOARDTYPE(pi) && (channel >= 149))
				visi_thresh_qdbm = 22; /* 5.5 dBm */
			else
				visi_thresh_qdbm = 6*4;
		}
	}
	else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		if (pi->olpc_thresh != 0)
			visi_thresh_qdbm = pi->olpc_thresh;
		else
			visi_thresh_qdbm = 7*4;

		if (pi->disable_olpc == 1)
			visi_thresh_qdbm = WL_RATE_DISABLED;
	}
	else if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
	  if (pi->olpc_thresh != 0)
	    visi_thresh_qdbm = pi->olpc_thresh;
	  else if (pi->u.pi_acphy->srom_2g_pdrange_id == 24)
	    visi_thresh_qdbm = 4*4;
	  else
	    visi_thresh_qdbm = 7*4;
	  if (pi->disable_olpc == 1)
	    visi_thresh_qdbm = WL_RATE_DISABLED;
	}
	else visi_thresh_qdbm = WL_RATE_DISABLED;
#endif	/* WLOLPC */
	return visi_thresh_qdbm;
}

/* TIA LUT tables to be used in wlc_20691_tia_config() */

static const uint8 tiaRC_20691_8b_20[]= { /* LUT 0--51 (20 MHz) */
	0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xff, 0xff,
	0xb7, 0xb5, 0x97, 0x81, 0xe5, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x1d, 0x28, 0x34, 0x34, 0x34,
	0x34, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40,
	0x5b, 0x6c, 0x80, 0x80
};

static const uint16 tiaRC_20691_16b_20[]= { /* LUT 52--82 (20 MHz) */
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x00b5, 0x0080, 0x005a,
	0x0040, 0x002d, 0x0020, 0x0017, 0x0000, 0x0100, 0x00b5, 0x0080,
	0x005b, 0x0040, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0080, 0x001f, 0x1fe0, 0xf500, 0x00ff
};

static const uint8 tiaRC_20691_8b_40[]= { /* LUT 0--51 (40 MHz) */
	0xff, 0xe1, 0xb9, 0x81, 0x5d, 0xff, 0xad, 0x82,
	0x6d, 0x5d, 0x4c, 0x41, 0x73, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x16, 0x1b, 0x1d, 0x1d, 0x1f,
	0x20, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x4c,
	0x5b, 0x6c, 0x80, 0x80
};

static const uint16 *tiaRC_20691_16b_40 = tiaRC_20691_16b_20;  /* LUT 52--82 (40 MHz) */

static const uint8 tiaRC_20691_8b_80[]= { /* LUT 0--51 (80 MHz) */
	0xc2, 0x86, 0x5d, 0xff, 0xbe, 0x88, 0x5f, 0x43,
	0x37, 0x2e, 0x26, 0x20, 0x39, 0x00, 0x00, 0x00,
	0x0b, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0d,
	0x0d, 0x07, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x4c,
	0x5b, 0x6c, 0x80, 0x80
};

static const uint16 tiaRC_20691_16b_80[]= { /* LUT 52--82 (80 MHz) */
	0x0000, 0x0000, 0x0000, 0x016b, 0x0100, 0x00b6, 0x0080, 0x005a,
	0x0040, 0x002d, 0x0020, 0x0017, 0x0000, 0x0100, 0x00b5, 0x0080,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0080, 0x0007, 0x1ff8, 0xf500, 0x00ff
};

static void
wlc_20691_tia_config(phy_info_t *pi)
{
/*
 *  The TIA has 13 distinct gain steps.
 *  Each of the tia_* scalers are packed with the
 *  tia settings for each gain step.
 *  Mapping for each gain step is:
 *  pwrup_amp2, amp2_bypass, R1, R2, R3, R4, C1, C2, enable_st1
 */
	const uint8  *p8;
	const uint16 *p16;
	uint16 lut;
	int core;

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		STATIC_ASSERT(ARRAYSIZE(tiaRC_20691_8b_80) + ARRAYSIZE(tiaRC_20691_16b_80) == 82);
		p8 = tiaRC_20691_8b_80;
		p16 = tiaRC_20691_16b_80;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		STATIC_ASSERT(ARRAYSIZE(tiaRC_20691_8b_40) + ARRAYSIZE(tiaRC_20691_16b_20) == 82);
		p8 = tiaRC_20691_8b_40;
		p16 = tiaRC_20691_16b_40;
	} else {
		STATIC_ASSERT(ARRAYSIZE(tiaRC_20691_8b_20) + ARRAYSIZE(tiaRC_20691_16b_20) == 82);
		p8 = tiaRC_20691_8b_20;
		p16 = tiaRC_20691_16b_20;
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		lut = RADIO_REG(pi, TIA_LUT_0, core);

		/* the assumption is that all the TIA LUT registers are in sequence */
		ASSERT(RADIO_REG(pi, TIA_LUT_82, core) - lut == 81);

		do {
			write_radio_reg(pi, lut++, *p8++);
		} while (lut <= RADIO_REG(pi, TIA_LUT_51, core));

		do {
			write_radio_reg(pi, lut++, *p16++);
		} while (lut <= RADIO_REG(pi, TIA_LUT_82, core));
	}
}

#define WLC_20691_GI_MULT_P12		4096U
#define WLC_20691_GI_MULT_TWEAK_P12	4096U
#define WLC_20691_GI_MULT		WLC_20691_GI_MULT_P12

static void
wlc_20691_sigdel_slow0g6_tune(phy_info_t *pi, int g_mult_raw_p12, tiny_adc_tuning_array_t *gvalues,
	int gi_mult)
{
	int g_mult_p12;
	int ri;
	int r21;
	int r32;
	int r43;
	int rff1;
	int rff2;
	int rff3;
	int rff4;
	int r12v;
	int r34v;
	int r11v;
	int g21;
	int g32;
	int g43;
	int r12;
	int r34;
	int g11;
	int temp;

	/* RC cals the slow ADC IN 20MHz channels or 10MHz bandwidth, based on g_mult */
	/* input signal scaling, changes ADC gain, 4096 <=> 1.0 for g_mult and gi_mult */
	/* Function is 32 bit (signed) integer arithmetic and a/b division rounding  */
	/* is performed in integers from: (a-1)/b+1 */

	/* ERR! 20691_rc_cal "adc" returns the RC value, so correction is 1/rccal! */
	/* so invert it */
	/* This is a nice way of inverting the number... jnh */
	/* inverse of gmult precomputed to minimise division operations for speed */
	/* 4.12 fixed point so scale reciprocal by 2^24 */
	g_mult_p12 = g_mult_raw_p12 > 0 ? g_mult_raw_p12 : 1;
	g_mult_p12 = 16777216 / g_mult_p12;
	g_mult_p12 = (WLC_20691_GI_MULT_TWEAK_P12 * g_mult_p12) >> 12;

	/* to avoid divide by zeros and negative values */
	if (g_mult_p12 <= 0)
		g_mult_p12 = 1;

	/* RC cal in slow ADC is mostly of the form Runit/(Rval/(g_mult/2**12)-Roff). */
	/* For integer manipulation do Runit/({Rval*2**12}/gmult-Roff).  */
	/* where Rval*2**12 are res design values in matlab script {x kint234 , kr12, kr34} */
	/* but right shifted a number of times */
	/* All but r11 and rff4 resistances are x2 for 20MHz. */

	/* Rvals from matlab already scaled by kint234, kr12 */
	/* or kr34 (due to amplifier finite GBW) */
	/* x2 for half the BW and half the sampling frequency. */
	ri = 10176 << 1;
	r21 = 8323 << 1;
	r32 = 6390 << 1;
	r43 = 6827 << 1;
	rff1 = 19768 << 1;
	rff2 = 16916 << 1;
	rff3 = 29113  << 1;
	/* rff4 does not double with 20MHz channels, 10MHz BW. */
	rff4 = 100000;
	r12v = 83205 << 1;
	r34v = 243530 << 1;
	/* rff4 does not double with 20MHz channels, 10MHz BW. */
	r11v = 8000;

	/* saturate correctly when you get negative numbers and round divisions */
	/* subject to gmult twice so scale gmult back to 12b so it only divides with 12b+ r21 */
	g21 = (g_mult_p12 * g_mult_p12) >> 12;
	if (g21 <= 0)
		g21 = 1;
	g21 = ((r21 << 12) - 1) / g21 + 1;
	g21 = (512000 - 1) / g21 + 1;
	g21 = wlc_20691_sigdel_wrap(g21, 127);
	g32 = (256000 - 1) / (((r32 << 12) - 1) / g_mult_p12 + 1) + 1;
	g32 = wlc_20691_sigdel_wrap(g32, 127);
	g43 = (256000 - 1) / (((r43 << 12) - 1) / g_mult_p12 + 1) + 1;
	g43  = wlc_20691_sigdel_wrap(g43, 127);

	/* gff1234 subject to gmult and gimult; step operations so range */
	/* is not exceeded and scale is correct */
	/* gff1234 overflow if $g_mult_p12*$gi_mult < 1023*2, eq. to 0.25, */
	/* assuming rff1234 {<<2} < 131072 */

	/* gi */
	temp = (((ri << 12) - 1) / gi_mult) - 4000 + 1;
	ASSERT(temp > 0);	/* should be a positive value */
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gi = (uint16) temp;

	/* gff1 */
	temp = ((((((rff1 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / gi_mult) - 8000 + 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff1 = (uint16) temp;

	/* gff2 */
	temp = ((((((rff2 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / gi_mult) - 4000 + 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff2 = (uint16) temp;

	/* gff3 */
	temp = ((((((rff3 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / gi_mult) - 32000
		+ 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff3 = (uint16) temp;

	/* gff4 */
	temp = (((rff4 << 12) - 1) / gi_mult) - 72000 + 1;	/* subject to gimult only */
	ASSERT(temp > 0);	/* should be a positive value */
	temp = (256000 - 1) / temp + 1;
	temp  = wlc_20691_sigdel_wrap(temp, 255);
	gvalues->gff4 = (uint16) temp;

	/* stays constant to RC shifts, g21 shifts twice for it. */
	r12 = (r12v - 1) / 4000 + 1;
	r12 = wlc_20691_sigdel_wrap(r12, 127);
	r34 = ((((r34v << 12) - 1) / g_mult_p12 +1) - 128000 - 1) / 4000 + 1;
	if (r34 <= 0)
		r34 = 1;
	r34 = wlc_20691_sigdel_wrap(r34, 127);
	g11 = (((r11v << 12) - 1) / g_mult_p12 +1) - 2000;
	if (g11 <= 0)
		g11 = 1;
	g11 = (128000 - 1) / g11 + 1;
	g11 = wlc_20691_sigdel_wrap(g11, 127);

	gvalues->g21 = (uint16) g21;
	gvalues->g32 = (uint16) g32;
	gvalues->g43 = (uint16) g43;
	gvalues->r12 = (uint16) r12;
	gvalues->r34 = (uint16) r34;
	gvalues->g11 = (uint16) g11;
	PHY_TRACE(("gi   = %i\n", gvalues->gi));
	PHY_TRACE(("g21  = %i\n", gvalues->g21));
	PHY_TRACE(("g32  = %i\n", gvalues->g32));
	PHY_TRACE(("g43  = %i\n", gvalues->g43));
	PHY_TRACE(("r12  = %i\n", gvalues->r12));
	PHY_TRACE(("r34  = %i\n", gvalues->r34));
	PHY_TRACE(("gff1 = %i\n", gvalues->gff1));
	PHY_TRACE(("gff2 = %i\n", gvalues->gff2));
	PHY_TRACE(("gff3 = %i\n", gvalues->gff3));
	PHY_TRACE(("gff4 = %i\n", gvalues->gff4));
	PHY_TRACE(("g11  = %i\n", gvalues->g11));
}

static int
wlc_20691_sigdel_fast_mult(int raw_p8, int mult_p12, int max_val, int rshift)
{
	int prod;
	/* >> 20 follows from .12 fixed-point for mult, various.8 for raw */
	prod = (mult_p12 * raw_p8) >> rshift;
	return (prod > max_val) ? max_val : prod;
}

static void
wlc_20691_sigdel_fast_tune(phy_info_t *pi, int g_mult_raw_p12, tiny_adc_tuning_array_t *gvalues)
{
	int g_mult_tweak_p12;
	int g_mult_p12;
	int g_inv_p12;
	int gi_inv_p12;
	int gi_p8;
	int ri3_p8;
	int g21_p8;
	int g32_p8;
	int g43_p8;
	int g54_p8;
	int g65_p8;
	int r12_p8;
	int r34_p8;
	int gi, ri3, g21, g32, g43, g54, g65, r12, r34;

	/* tweak to g_mult to trade off stability over PVT versus performance */
	g_mult_tweak_p12 = 4096;
	g_mult_p12 = (g_mult_tweak_p12 * g_mult_raw_p12) >> 12;

	/* inverse of gmult precomputed to minimise division operations for speed */
	g_inv_p12 = 16777216 / g_mult_p12;
	gi_inv_p12 = 16777216 / WLC_20691_GI_MULT;

	/* untuned values in p8 fixed-point format, ie. multiplied by 2^8 */
	gi_p8 = 16384;
	ri3_p8 = 1477;
	g21_p8 = 17997;
	g32_p8 = 18341;
	g43_p8 = 15551;
	g54_p8 = 19915;
	g65_p8 = 12369;
	r12_p8 = 1156;
	r34_p8 = 4331;

	/* RC cal */
	gi = wlc_20691_sigdel_fast_mult(gi_p8, WLC_20691_GI_MULT, 127, 20);
	ri3 = wlc_20691_sigdel_fast_mult(ri3_p8, gi_inv_p12, 63, 20);
	g21 = wlc_20691_sigdel_fast_mult(g21_p8, g_mult_p12, 127, 20);
	g32 = wlc_20691_sigdel_fast_mult(g32_p8, g_mult_p12, 127, 20);
	g43 = wlc_20691_sigdel_fast_mult(g43_p8, g_mult_p12, 127, 20);
	g54 = wlc_20691_sigdel_fast_mult(g54_p8, g_mult_p12, 127, 20);
	g65 = wlc_20691_sigdel_fast_mult(g65_p8, g_mult_p12, 63, 20);
	r12 = wlc_20691_sigdel_fast_mult(r12_p8, g_inv_p12, 63, 20);
	r34 = wlc_20691_sigdel_fast_mult(r34_p8, g_inv_p12, 63, 20);

	gvalues->gi = (uint16) gi;
	gvalues->ri3 = (uint16) ri3;
	gvalues->g21 = (uint16) g21;
	gvalues->g32 = (uint16) g32;
	gvalues->g43 = (uint16) g43;
	gvalues->g54 = (uint16) g54;
	gvalues->g65 = (uint16) g65;
	gvalues->r12 = (uint16) r12;
	gvalues->r34 = (uint16) r34;
}

static void
wlc_20691_sigdel_slow1g2_tune(phy_info_t *pi, int g_mult_raw_p12, tiny_adc_tuning_array_t *gvalues)
{
	int g_mult_p12;
	int ri;
	int r21;
	int r32;
	int r43;
	int rff1;
	int rff2;
	int rff3;
	int rff4;
	int r12v;
	int r34v;
	int r11v;
	int g21;
	int g32;
	int g43;
	int r12;
	int r34;
	int g11;
	int temp;

	/*
	 * RC cals the slow ADC in 40MHz channels or 20MHz bandwidth, based on g_mult
	 * input signal scaling, changes ADC gain, 4096 <=> 1.0 for gi_mult and g_mult.
	 * Function is 32 bit arithmetic, with  a/b division rounding performed from:
	 * (a-1)/b+1
	 */

	/*
	 * ERR! 20691_rc_cal "adc" returns the RC value, so correction is 1/rccal!
	 * so invert it.
	 * This is a nice way of inverting the number... jnh
	 * inverse of gmult precomputed to minimise division operations for speed
	 * 4.12 fixed point so scale reciprocal by 2^24
	 */
	g_mult_p12 = (g_mult_raw_p12 > 0) ? g_mult_raw_p12 : 1;
	g_mult_p12 = 16777216 / g_mult_p12;

	/* tweak to g_mult */
	g_mult_p12 = (WLC_20691_GI_MULT_TWEAK_P12 * g_mult_p12) >> 12;

	/* to avoid divide by zeros and negative values */
	if (g_mult_p12 <= 0)
		g_mult_p12 = 1;

	/*
	 * RC cal in slow ADC is mostly of the form Runit/(Rval/(g_mult/2**12)-Roff).
	 * For integer manipulation do Runit/({Rval*2**12}/gmult-Roff),
	 * where Rval*2**12 are res design values in matlab script {x kint234 , kr12, kr34}
	 * but right shifted a number of times.
	 * All but r11 and rff4 resistances are x2 for 20MHz.
	 */

	/* Rvals from matlab already scaled by kint234, kr12 or kr34 (due to amplifier finite GBW)
	 */
	ri = 10670;
	r21 = 8323;
	r32 = 6390;
	r43 = 6827;
	rff1 = 19768;
	rff2 = 16916;
	rff3 = 29113;
	rff4 = 100000;
	r12v = 83205;
	r34v = 243530;
	r11v = 8000;

	/* subject to gmult twice, so scale it back to 12b and it only divides with r21+12b */
	g21 = (g_mult_p12 * g_mult_p12) >> 12;
	if (g21 <= 0)
		g21 = 1;
	g21 = ((r21 << 12) - 1) / g21 + 1;
	g21 = (512000 - 1) / g21 + 1;
	g21 = wlc_20691_sigdel_wrap(g21, 127);
	g32 = (256000 - 1) / (((r32 << 12) - 1) / g_mult_p12 + 1) + 1;
	g32 = wlc_20691_sigdel_wrap(g32, 127);
	g43 = (256000 - 1) / (((r43 << 12) - 1) / g_mult_p12 + 1) + 1;
	g43 =  wlc_20691_sigdel_wrap(g43, 127);

	/*
	 * gff1234 subject to gmult and gimult, step operations so range is not exceeded and
	 * scale correct.
	 * gff1234 will overflow if $g_mult_p12*$gi_mult < 1023*2, eq. to 0.25,
	 * assuming rff1234 {<<2} < 131072.
	 */

	/* gi */
	temp = (((ri << 12) - 1) / WLC_20691_GI_MULT) - 4000 + 1;
	ASSERT(temp > 0);	/* should be a positive value */
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gi = (uint16) temp;

	/* gff1 */
	temp = ((((((rff1 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / WLC_20691_GI_MULT) - 8000 + 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff1 = (uint16) temp;

	/* gff2 */
	temp = ((((((rff2 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / WLC_20691_GI_MULT) - 4000 + 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff2 = (uint16) temp;

	/* gff3 */
	temp = ((((((rff3 << 12) - 1) / g_mult_p12 + 1) << 12) - 1) / WLC_20691_GI_MULT) - 12000
		+ 1;
	if (temp <= 0)
		temp = 1;
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 127);
	gvalues->gff3 = (uint16) temp;

	/* gff4 */
	temp = ((rff4 << 12) - 1) / WLC_20691_GI_MULT - 72000 + 1;	/* subject to gimult only */
	ASSERT(temp > 0);	/* should be a positive value */
	temp = (256000 - 1) / temp + 1;
	temp = wlc_20691_sigdel_wrap(temp, 255);
	gvalues->gff4 = (uint16) temp;

	/* stays constant to RC shifts, g21 shifts twice for it. */
	r12 = (r12v - 1) / 4000 + 1;
	r12 = wlc_20691_sigdel_wrap(r12, 12);
	r34 = ((r34v << 12) - 1) / g_mult_p12 / 4000 + 1;
	if (r34 <= 0)
		r34 = 1;
	r34 = wlc_20691_sigdel_wrap(r34, 127);
	g11 = ((r11v << 12) - 1) / g_mult_p12 - 2000 + 1;
	if (g11 <= 0)
		g11 = 1;
	g11 = (128000 - 1) / g11 + 1;
	g11 = wlc_20691_sigdel_wrap(g11, 127);

	gvalues->g21 = (uint16) g21;
	gvalues->g32 = (uint16) g32;
	gvalues->g43 = (uint16) g43;
	gvalues->r12 = (uint16) r12;
	gvalues->r34 = (uint16) r34;
	gvalues->g11 = (uint16) g11;
	PHY_TRACE(("gi   = %i\n", gvalues->gi));
	PHY_TRACE(("g21  = %i\n", gvalues->g21));
	PHY_TRACE(("g32  = %i\n", gvalues->g32));
	PHY_TRACE(("g43  = %i\n", gvalues->g43));
	PHY_TRACE(("r12  = %i\n", gvalues->r12));
	PHY_TRACE(("r34  = %i\n", gvalues->r34));
	PHY_TRACE(("gff1 = %i\n", gvalues->gff1));
	PHY_TRACE(("gff2 = %i\n", gvalues->gff2));
	PHY_TRACE(("gff3 = %i\n", gvalues->gff3));
	PHY_TRACE(("gff4 = %i\n", gvalues->gff4));
	PHY_TRACE(("g11  = %i\n", gvalues->g11));
}

static void
wlc_20691_adc_setup_slow0g6(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues)
{
	/* SETS UP THE slow ADC IN 20MHz channels or 10MHz bandwidth */
	/* Function should be 32 bit (signed) arithmetic */

	/* EXPLICITELY ENABLE/DISABLE ADCs and INTERNAL CLKs? */
	/* Only changes between fast/slow ADC, not 20/40MHz */
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_fast_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_fast_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_slow_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_fast_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_fast_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_slow_pu, 0x0)

		/* Setup internal dividers and sipo for 1G2Hz mode */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_drive_strength, 0x4)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x1)
		/* set adc_clk_slow_div3 to 0x0 in 20MHz mode, 0x1 in 40MHz mode */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_slow_div3, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_sipo_sel_fast, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG18, 0, adc_od_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_od_pu, 0x1)

		/* Setup biases */
		/* Slow adc halves opamp current from 20MHz to 40MHz channels */
		/* Opamp1 is 26u/0, 4u/2 other 3 are 26u/0, 4u/4,    */
		/* so opamp1 (40M, 20M, = (0x20, 0x10,, opamp234 = (0x10, 0x8, */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp1, 0x10)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp2, 0x8)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp3, 0x8)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp4, 0x8)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG8, 0, adc_ff_mult_opamp, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref_control, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref4_control, 0x40)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Setup transconductances, These are tuned with gmult(RC, and/or gimult(input gain, */
	/* rnm */
	MOD_RADIO_REG_20691(pi, ADC_CFG2, 0, adc_gi, gvalues->gi);
	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g21, gvalues->g21);
	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g32, gvalues->g32);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g43, gvalues->g43);
	/* rff */
	MOD_RADIO_REG_20691(pi, ADC_CFG16, 0, adc_gff1, gvalues->gff1);
	MOD_RADIO_REG_20691(pi, ADC_CFG16, 0, adc_gff2, gvalues->gff2);
	MOD_RADIO_REG_20691(pi, ADC_CFG17, 0, adc_gff3, gvalues->gff3);
	MOD_RADIO_REG_20691(pi, ADC_CFG17, 0, adc_gff4, gvalues->gff4);
	/* resonator and r11 */
	MOD_RADIO_REG_20691(pi, ADC_CFG5, 0, adc_r12, gvalues->r12);
	MOD_RADIO_REG_20691(pi, ADC_CFG8, 0, adc_r34, gvalues->r34);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g54, gvalues->g11);

	ACPHY_REG_LIST_START
		/* Setup feedback DAC and tweak delay compensation */
		/* In slow 40MHz ADC rt is 0x0, in 20MHz ADC rt is 0x2 */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG19, 0, adc_rt, 0x2)
		/* In slow 40MHz ADC slow_dacs is 0x2 in 20MHz ADC rt is 0x1 */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG19, 0, adc_slow_dacs, 0x1)

		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_20691_adc_setup_slow1g2(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues)
{
	/*
	 * SETS UP THE slow ADC IN 40MHz channels or 20MHz bandwidth.
	 * Function should be 32 bit (signed) arithmetic.
	 * EXPLICITELY ENABLE/DISABLE ADCs and INTERNAL CLKs?
	 * Only changes between fast/slow ADC, not 20/40MHz
	 */

	ACPHY_REG_LIST_START
		/* reg to 0x0 for fast */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_fast_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_fast_pu, 0x0)

		/* reg to 0x1 for fast */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_slow_pu, 0x0)
		/* MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_slow_pu) 0x0 */
		/* reg to 0x0 for fast */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_fast_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_fast_pu, 0x0)

		/* reg to 0x1 for fast */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_slow_pu, 0x0)
		/* MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_slow_pu) 0x0 */

		/* Setup internal dividers and sipo for 1G2Hz mode */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_drive_strength, 0x4)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x1)
		/* set adc_clk_slow_div3 to 0x0 in 20MHz mode */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_slow_div3, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_sipo_sel_fast, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG18, 0, adc_od_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_od_pu, 0x1)

		/* Setup biases */
		/* Slow adc halves opamp current from 20MHz to 40MHz channels */
		/* Opamp1 is 26u/0, 4u/2 other 3 are 26u/0, 4u/4, */
		/* so opamp1 (40M,20M) = (0x20,0x10), opamp234 = (0x10,0x8) */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp1, 0x20)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp2, 0x10)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp3, 0x10)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp4, 0x10)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG8, 0, adc_ff_mult_opamp, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref_control, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref4_control, 0x40)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Setup transconductances.  These are tuned with gmult(RC) and/or gimult(input gain) */
	/* rnm */
	MOD_RADIO_REG_20691(pi, ADC_CFG2, 0, adc_gi, gvalues->gi);
	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g21, gvalues->g21);
	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g32, gvalues->g32);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g43, gvalues->g43);
	/* rff */
	MOD_RADIO_REG_20691(pi, ADC_CFG16, 0, adc_gff1, gvalues->gff1);
	MOD_RADIO_REG_20691(pi, ADC_CFG16, 0, adc_gff2, gvalues->gff2);
	MOD_RADIO_REG_20691(pi, ADC_CFG17, 0, adc_gff3, gvalues->gff3);
	MOD_RADIO_REG_20691(pi, ADC_CFG17, 0, adc_gff4, gvalues->gff4);
	/* resonator and r11 */
	MOD_RADIO_REG_20691(pi, ADC_CFG5, 0, adc_r12, gvalues->r12);
	MOD_RADIO_REG_20691(pi, ADC_CFG8, 0, adc_r34, gvalues->r34);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g54, gvalues->g11);

	ACPHY_REG_LIST_START
		/* Setup feedback DAC and tweak delay compensation */
		/* In slow 40MHz ADC rt is 0x0, in 20MHz ADC rt is 0x2 */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG19, 0, adc_rt, 0x0)
		/* In slow 40MHz ADC slow_dacs is 0x2 in 20MHz ADC rt is 0x1 */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG19, 0, adc_slow_dacs, 0x2)

		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_20691_adc_setup_fast(phy_info_t *pi, tiny_adc_tuning_array_t *gvalues)
{

#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	ACPHY_REG_LIST_START
		/* EXPLICITLY ENABLE/DISABLE ADCs and INTERNAL CLKs?  */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_fast_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_slow_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_slow_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_fast_pu, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_adc_clk_slow_pu, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_slow_pu, 0x0)

		/* Setup internal dividers and sipo for 3G2Hz mode. */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_drive_strength, 0x4)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG15, 0, adc_clk_slow_div3, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_sipo_sel_fast, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_drive_strength, 0x4)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_sipo_div8, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp1, 0x60)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG6, 0, adc_biasadj_opamp2, 0x60)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp3, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG7, 0, adc_biasadj_opamp4, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG8, 0, adc_ff_mult_opamp, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref_control, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG9, 0, adc_cmref4_control, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_sipo_sel_fast, 0x1)

		/* Turn on overload detector */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG18, 0, adc_od_bias_comp, 0x40)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG18, 0, adc_od_threshold, 0x3)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG18, 0, adc_od_reset_duration, 0x3)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* ovr_adc_od_pu does not exist in TC */
	if (RADIO20691_MAJORREV(radio_rev) != 0) {
		MOD_RADIO_REG_20691(pi, ADC_OVR1, 0, ovr_adc_od_pu, 0x1);
	}

	MOD_RADIO_REG_20691(pi, ADC_CFG18, 0, adc_od_pu, 0x1);
	MOD_RADIO_REG_20691(pi, ADC_CFG2, 0, adc_gi, gvalues->gi);

	/* typo in spreadsheet for TC only - should be ri3 but got called ri1 */
	if (RADIO20691_MAJORREV(radio_rev) == 0) {
		MOD_RADIO_REG_20691(pi, ADC_CFG2, 0, adc_ri1, gvalues->ri3);
	} else {
		MOD_RADIO_REG_20691(pi, ADC_CFG2, 0, adc_ri3, gvalues->ri3);
	}

	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g21, gvalues->g21);
	MOD_RADIO_REG_20691(pi, ADC_CFG3, 0, adc_g32, gvalues->g32);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g43, gvalues->g43);
	MOD_RADIO_REG_20691(pi, ADC_CFG4, 0, adc_g54, gvalues->g54);
	MOD_RADIO_REG_20691(pi, ADC_CFG5, 0, adc_g65, gvalues->g65);
	MOD_RADIO_REG_20691(pi, ADC_CFG5, 0, adc_r12, gvalues->r12);
	MOD_RADIO_REG_20691(pi, ADC_CFG8, 0, adc_r34, gvalues->r34);
	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG1, 0, adc_adcs_reset, 0x0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, 0, ovr_reset_adc, 0x0)
	ACPHY_REG_LIST_EXECUTE(pi);
}

static void
wlc_phy_afe_war_setup_acphy(phy_info_t *pi)
{
	tiny_adc_tuning_array_t gvalues;
	uint16 val;
	uint16 rxfectrl_a;
	uint16 rxfectrl_v;
	uint16 val_40[afe_fcbs_rfregs_size];
	uint16 val_farrow_40[2];
	uint32 fcw;
	uint16 *ptr_val;
	int i;
	uint16 fastchswTableIndex, fastchswTableIndexfor20;
	uint16 *reg_list_ptr, *afe_fcbs_rfregs_begin, *afe_fcbs_rfregs_end;
	const uint16 fcbs_table_delim = 0xffff;
	ptr_val = &val;
	(void)memset(val_farrow_40, 0, sizeof(val_farrow_40));

	wlc_phy_afe_fcbsinit_acphy(pi);

	MOD_RADIO_REG_20691(pi, ADC_CFG15, 0, adc_clk_slow_diff, 0x1);
	/* write 40MHz data */
	fastchswTableIndex = 0;
	i = 0;
	for (reg_list_ptr = afe_fcbs_rfregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = read_radio_reg(pi, *reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
		val_40[i] = val;
		i++;
	}
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;

	/* reset farrow, set bilge cnt to 4 */
	rxfectrl_a = ACPHY_RxFeCtrl1(pi->pubpi.phy_rev);
	rxfectrl_v = READ_PHYREG(pi, RxFeCtrl1) & ~(1 | (0xf << 2));
	rxfectrl_v |= (1 | (4 << 2));
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &rxfectrl_a);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
		16, &rxfectrl_v);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
		16, &rxfectrl_v);
	fastchswTableIndex += 3;

	i = 0;
	for (reg_list_ptr = afe_fcbs_phyregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = phy_reg_read(pi, *reg_list_ptr);
		if ((i == 0) || (i == 1)) {
			val_farrow_40[i] = val;
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
		i++;
	}

	/* un-reset farrow */
	rxfectrl_v &= ~1;
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &rxfectrl_a);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
	16, &rxfectrl_v);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
		16, &rxfectrl_v);
	fastchswTableIndex += 3;

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;

	/* write 20MHz data */
	wlc_20691_sigdel_slow0g6_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues, 3900);
	wlc_20691_adc_setup_slow0g6(pi, &gvalues);
	afe_fcbs_rfregs_begin = afe_fcbs_rfregs;
	afe_fcbs_rfregs_end = afe_fcbs_rfregs + afe_fcbs_rfregs_size - 1;
	fastchswTableIndexfor20 =  fastchswTableIndex;
	i = afe_fcbs_rfregs_size - 1;
	for (reg_list_ptr = afe_fcbs_rfregs_end; reg_list_ptr != afe_fcbs_rfregs_begin-1;
		reg_list_ptr--) {
		val = read_radio_reg(pi, *reg_list_ptr);
		val = (val & afe_fcbs_mask[i]) | (val_40[i] & ~afe_fcbs_mask[i]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
		i--;
	}
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1; /* skip delimiter */
	i = 0;
	fcw = ((((uint32)val_farrow_40[0] << 16) |
		((uint32)val_farrow_40[1] & 0xffff)) & 0x3ffffff) >> 1;
	if (fcw < (1<<24)) fcw = (1<<24);
	for (reg_list_ptr = afe_fcbs_phyregs; *reg_list_ptr != 0xFFFF;  reg_list_ptr++) {
		val = phy_reg_read(pi, *reg_list_ptr);
		if (i == 0) {
			val = (val_farrow_40[i] & ~0x3ff) | (uint16)((fcw >> 16) & 0x3ff);
		} else if (i == 1) {
			val = (uint16)(fcw & 0xffff);
		} else if (i == 2) {
			val = val | 0x10;
		} else {
			val = 0;
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
			16, reg_list_ptr);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+1,
			16, ptr_val);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex+2,
			16, ptr_val);
		fastchswTableIndex += 3;
		i++;
	}
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FASTCHSWITCH, 1, fastchswTableIndex,
		16, &fcbs_table_delim);
	fastchswTableIndex += 1;

	/* Restore 40MHz values */
	wlc_20691_sigdel_slow1g2_tune(pi, pi->u.pi_acphy->rccal_adc_gmult, &gvalues);
	wlc_20691_adc_setup_slow1g2(pi, &gvalues);
	MOD_RADIO_REG_20691(pi, ADC_CFG15, 0, adc_clk_slow_diff, 0x1);

	wlapi_bmac_write_shm(pi->sh->physhim, 2*(wlapi_bmac_read_shm(pi->sh->physhim,
		M_TOF_PTR) + 51), fastchswTableIndexfor20);
	wlapi_bmac_mhf(pi->sh->physhim, MHF5, MHF5_AFE_WAR, MHF5_AFE_WAR, WLC_BAND_ALL);

}

static int
wlc_20691_sigdel_wrap(int prod, int max_val)
{
	/* to make sure you hit the maximum number of bits in word allocated  */
	return (prod > max_val) ? max_val : prod;
}

/* The following are the txiqcc offsets in the ACPHY_TBL_ID_IQLOCAL table, from acphyprocs.tcl */
static uint8 tbl_offset_ofdm_a[] = {96, 100, 104, 108};
static uint8 tbl_offset_bphy_a[] = {112, 116, 120, 124};

static void
wlc_acphy_get_tx_iqcc(phy_info_t *pi, uint16 *a, uint16 *b)
{
	uint16 iqcc[2];

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 2, tbl_offset_ofdm_a[0], 16, &iqcc);

	*a = iqcc[0];
	*b = iqcc[1];
}

static void
wlc_acphy_set_tx_iqcc(phy_info_t *pi, uint16 a, uint16 b)
{
	uint16 iqcc[2];
	uint8 core = 0;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);

	iqcc[0] = a;
	iqcc[1] = b;

	ACPHY_DISABLE_STALL(pi);

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 2, tbl_offset_ofdm_a[core], 16, iqcc);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 2, tbl_offset_bphy_a[core], 16, iqcc);

	ACPHY_ENABLE_STALL(pi, stall_val);
}

/* The following are the txlocc offsets in the ACPHY_TBL_ID_IQLOCAL table, from acphyprocs.tcl */
static uint8 tbl_offset_ofdm_d[] = {98, 102, 106, 110};
static uint8 tbl_offset_bphy_d[] = {114, 118, 122, 126};

static uint16
wlc_acphy_get_tx_locc(phy_info_t *pi)
{
	uint16 didq;

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, tbl_offset_ofdm_d[0], 16, &didq);
	return didq;
}

static void
wlc_acphy_set_tx_locc(phy_info_t *pi, uint16 didq)
{
	uint8 core = 0;
	uint8 stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);

	ACPHY_DISABLE_STALL(pi);

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, tbl_offset_ofdm_d[core], 16, &didq);
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_IQLOCAL, 1, tbl_offset_bphy_d[core], 16, &didq);

	ACPHY_ENABLE_STALL(pi, stall_val);
}

static void
wlc_acphy_get_radio_loft(phy_info_t *pi,
	uint8 *ei0,
	uint8 *eq0,
	uint8 *fi0,
	uint8 *fq0)
{
	/* Not required for 4345 */
	*ei0 = 0;
	*eq0 = 0;
	*fi0 = 0;
	*fq0 = 0;
}

static void
wlc_acphy_set_radio_loft(phy_info_t *pi,
	uint8 ei0,
	uint8 eq0,
	uint8 fi0,
	uint8 fq0)
{
	/* Not required for 4345 */
	return;
}

static void
wlc_phy_dssfB_acphy(phy_info_t *pi, bool on)
{
	if (DSSFB_ENABLE) {
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_dssfB_values_t *dssfB = &pi_ac->dssfB;
	dssfB->channel = 0;
	dssfB->DSSFB_gain_th0_s1 = 61;
	dssfB->DSSFB_gain_th1_s1 = 67;
	dssfB->DSSFB_gain_th2_s1 = 73;
	dssfB->DSSFB_gain_th0_s2 = 61;
	dssfB->DSSFB_gain_th1_s2 = 67;
	dssfB->DSSFB_gain_th2_s2 = 73;

	dssfB->idepth_s1 = 0;
	dssfB->idepth_s2 = 0;
	dssfB->enabled_s1 = 0;
	dssfB->enabled_s2 = 0;
	dssfB->theta_i_s1 = 0;
	dssfB->theta_q_s1 = 0;
	dssfB->theta_i_s2 = 0;
	dssfB->theta_q_s2 = 0;
	dssfB->DSSFB_C_CTRL = 0;
	dssfB->on = on;
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
	/* Reset DSSFB filter */
	WRITE_PHYREG(pi, DSSFB_C_CTRL, 0);
	if (on) {
		dssfB->channel = CHSPEC_CHANNEL(pi->radio_chanspec);
		if (ACMAJORREV_2(pi->pubpi.phy_rev) && !ACMINORREV_0(pi->pubpi.phy_rev) &&
		    PHY_ILNA(pi) &&
		    !((RADIOREV(pi->pubpi.radiorev) == 0x28 ||
		       RADIOREV(pi->pubpi.radiorev) == 0x2C ||
		       RADIOREV(pi->pubpi.radiorev) == 0x2E) && PHY_XTAL_IS40M(pi))) {
			switch (dssfB->channel) {
				/* 2G, 20Mhz && 40Mhz */
			case 4:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 3313; /* freq = 4 */
				dssfB->theta_q_s1 = 2407; /* freq = 4 */
				break;
			case 5:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 4045; /* freq = -1 */
				dssfB->theta_q_s1 = 7551; /* freq = -1 */
				break;
			case 6:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 2406; /* freq = -6 */
				dssfB->theta_q_s1 = 4879; /* freq = -6 */
				break;
			case 11:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 2106; /* freq = 6.395 */
				dssfB->theta_q_s1 = 3313; /* freq = 6.395 */
				break;
			case 12:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 4044; /* freq = 1.395 */
				dssfB->theta_q_s1 =  901; /* freq = 1.395 */
				break;
			case 13:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 3313; /* freq = -3.605 */
				dssfB->theta_q_s1 = 6086; /* freq = -3.605 */
				break;
			default:
				break;
			}
		/* DSSFB for 43569a[03]/43570a[03]/43566a0/43567 */
		} else if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		           (RADIOREV(pi->pubpi.radiorev) == 0x28 ||
		            RADIOREV(pi->pubpi.radiorev) == 0x2E) && PHY_XTAL_IS40M(pi)) {
			switch (dssfB->channel) {
				/* 2G, 20Mhz && 40Mhz */
			case 6:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 3648; /* freq = 3 */
				dssfB->theta_q_s1 = 1859; /* freq = 3 */
				break;
			case 7:
				PHY_INFORM(("wlc_phy_dssfB_acphy: applying dssfB for channel %d\n",
				            dssfB->channel));
				dssfB->idepth_s1 = 1;
				dssfB->idepth_s2 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->enabled_s2 = 0;
				dssfB->DSSFB_C_CTRL = 0xc;
				dssfB->theta_i_s1 = 3894; /* freq = -2 */
				dssfB->theta_q_s1 = 6927; /* freq = -2 */
				break;
			default:
				break;
			}
		} else if ((!PHY_ILNA(pi)) && (pi->u.pi_acphy->srom.spur_war_enb_2g == 1) &&
			(pi->u.pi_acphy->srom.phy4350_ss_opt)) {
				switch (dssfB->channel) {
				case 4:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 3313; /* freq = 4 */
					dssfB->theta_q_s1 = 2407; /* freq = 4 */
					break;
				case 5:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 4045; /* freq = -1 */
					dssfB->theta_q_s1 = 7551; /* freq = -1 */
					break;
				case 6:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 2406; /* freq = -6 */
					dssfB->theta_q_s1 = 4879; /* freq = -6 */
					break;
				case 11:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 2106; /* freq = 6.395 */
					dssfB->theta_q_s1 = 3313; /* freq = 6.395 */
					break;
				case 12:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 4044; /* freq = 1.395 */
					dssfB->theta_q_s1 =  901; /* freq = 1.395 */
					break;
				case 13:
					PHY_INFORM(("wlc_phy_dssfB_acphy: "
								"applying dssfB for channel %d\n",
								dssfB->channel));
					dssfB->idepth_s1 = 1;
					dssfB->idepth_s2 = 1;
					dssfB->enabled_s1 = 1;
					dssfB->enabled_s2 = 0;
					dssfB->DSSFB_C_CTRL = 0xb;
					dssfB->theta_i_s1 = 3313; /* freq = -3.605 */
					dssfB->theta_q_s1 = 6086; /* freq = -3.605 */
					break;
				default:
					break;

				}
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev) &&
		           ((RADIOMINORREV(pi->pubpi.radiominorrev) == 4) ||
		            (RADIOMINORREV(pi->pubpi.radiominorrev) == 10) ||
		            (RADIOMINORREV(pi->pubpi.radiominorrev) == 11) ||
		            (RADIOMINORREV(pi->pubpi.radiominorrev) == 13)) &&
		           (PHY_XTAL_IS37M4(pi))) {
			switch (dssfB->channel) {
			case 4:
				dssfB->idepth_s1 = 2;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 3313;
				dssfB->theta_q_s1 = 2407;
				break;
			case 5:
				dssfB->idepth_s1 = 2;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 4045;
				dssfB->theta_q_s1 = 7551;
				break;
			case 6:
				dssfB->idepth_s1 = 2;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 2406;
				dssfB->theta_q_s1 = 4879;
				break;
			case 11:
				dssfB->idepth_s1 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 2106;
				dssfB->theta_q_s1 = 3313;
				break;
			case 12:
				dssfB->idepth_s1 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 4044;
				dssfB->theta_q_s1 =  901;
				break;
			case 13:
				dssfB->idepth_s1 = 1;
				dssfB->enabled_s1 = 1;
				dssfB->theta_i_s1 = 3313;
				dssfB->theta_q_s1 = 6086;
				break;
			}
			if (dssfB->theta_i_s1 || dssfB->theta_i_s2) {
				dssfB->DSSFB_C_CTRL = 0xb;
				PHY_INFORM(("%s: xtal freq 37.4M, applying dssfB for channel %d\n",
				            __FUNCTION__, dssfB->channel));
			}
		}
	} else {
		dssfB->DSSFB_C_CTRL = 0;
		dssfB->enabled_s1 = 0;
		dssfB->enabled_s2 = 0;
	}

	wlc_phy_dssfB_setup_acphy(pi);
	wlc_phy_resetcca_acphy(pi);
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
	}
}

static void
wlc_phy_dssf_acphy(phy_info_t *pi, bool on)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_dssf_values_t *dssf = &pi_ac->dssf;

	if (!DSSF_ENABLE)
		return;

	dssf->channel = 0;
	dssf->core = 0;

	if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		dssf->DSSF_gain_th0_s1 = 46;
		dssf->DSSF_gain_th1_s1 = 52;
		dssf->DSSF_gain_th2_s1 = 58;
		dssf->DSSF_gain_th0_s2 = 46;
		dssf->DSSF_gain_th1_s2 = 52;
		dssf->DSSF_gain_th2_s2 = 58;
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
	           PHY_IPA(pi) && PHY_XTAL_IS40M(pi)) {
		/* There is only 1 gain used in 5G BW80, so no waste lines here */
		if (CHSPEC_IS40(pi->radio_chanspec)) {
			dssf->DSSF_gain_th0_s1 = 60;
			dssf->DSSF_gain_th1_s1 = 66;
			dssf->DSSF_gain_th2_s1 = 72;
			dssf->DSSF_gain_th0_s2 = 60;
			dssf->DSSF_gain_th1_s2 = 66;
			dssf->DSSF_gain_th2_s2 = 72;
		} else {
			dssf->DSSF_gain_th0_s1 = 64;
			dssf->DSSF_gain_th1_s1 = 73;
			dssf->DSSF_gain_th2_s1 = 78;
			dssf->DSSF_gain_th0_s2 = 64;
			dssf->DSSF_gain_th1_s2 = 73;
			dssf->DSSF_gain_th2_s2 = 78;
		}
	} else {
		dssf->DSSF_gain_th0_s1 = 68;
		dssf->DSSF_gain_th1_s1 = 74;
		dssf->DSSF_gain_th2_s1 = 80;
		dssf->DSSF_gain_th0_s2 = 68;
		dssf->DSSF_gain_th1_s2 = 74;
		dssf->DSSF_gain_th2_s2 = 80;
	}
	dssf->idepth_s1 = 2;
	dssf->idepth_s2 = 2;
	dssf->enabled_s1 = 1;
	dssf->enabled_s2 = 0;
	dssf->theta_i_s1 = 0;
	dssf->theta_q_s1 = 0;
	dssf->theta_i_s2 = 0;
	dssf->theta_q_s2 = 0;
	dssf->DSSF_C_CTRL = 0;
	dssf->on = on;
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, ON);
	/* Reset DSSF filter */
	WRITE_PHYREG(pi, DSSF_C_CTRL, 0);

	/* For 4350c2 and beyond, this bit will bypass dssf out when resetfront40 gets asserted */
	if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		MOD_PHYREG(pi, GIDet_CTRL, GIdet_hold, 1);
	}

	if (on) {
		dssf->channel = CHSPEC_CHANNEL(pi->radio_chanspec);

		if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
			switch (dssf->channel) {
			case 1:
				/* bw=20, fc= 2412 MHz */
				dssf->theta_i_s1 =   641; /* freq =  -4.50 (bbpll) */
				dssf->theta_q_s1 =  4147; /* freq =  -4.50 (bbpll) */
				dssf->DSSF_gain_th0_s1 = 40;
				dssf->DSSF_gain_th1_s1 = 46;
				dssf->DSSF_gain_th2_s1 = 52;
				break;
			case 4:
				/* bw=20, fc= 2427 MHz */
				dssf->theta_i_s1 =  1265; /* freq =  +4.00 (xtal) */
				dssf->theta_q_s1 =  3895; /* freq =  +4.00 (xtal) */
				break;
			case 5:
				/* bw=20, fc= 2432 MHz */
				dssf->theta_i_s1 =  3895; /* freq =  -1.00 (xtal) */
				dssf->theta_q_s1 =  6927; /* freq =  -1.00 (xtal) */
				break;
			case 6:
				/* bw=20, fc= 2437 MHz */
				dssf->theta_i_s1 =  6927; /* freq =  -6.00 (xtal) */
				dssf->theta_q_s1 =  4297; /* freq =  -6.00 (xtal) */
				dssf->DSSF_gain_th0_s1 = 49;
				dssf->DSSF_gain_th1_s1 = 55;
				dssf->DSSF_gain_th2_s1 = 61;
				break;
			case 11:
				/* bw=20, fc= 2462 MHz */
				dssf->theta_i_s1 =  6448; /* freq =  +6.40 (xtal) */
				dssf->theta_q_s1 =  3705; /* freq =  +6.40 (xtal) */
				break;
			case 12:
				/* bw=20, fc= 2467 MHz */
				dssf->theta_i_s1 =  3705; /* freq =  +1.40 (xtal) */
				dssf->theta_q_s1 =  1744; /* freq =  +1.40 (xtal) */
				break;
			case 13:
				/* bw=20, fc= 2472 MHz */
				dssf->theta_i_s1 =  1744; /* freq =  -3.60 (xtal) */
				dssf->theta_q_s1 =  4487; /* freq =  -3.60 (xtal) */
				break;
			case 40:
				/* bw=20, fc= 5200 MHz */
				dssf->theta_i_s1 =  3705; /* freq =  -1.40 (xtal) */
				dssf->theta_q_s1 =  6448; /* freq =  -1.40 (xtal) */
				break;
			case 48:
				/* bw=20, fc= 5240 MHz */
				dssf->theta_i_s1 =  1265; /* freq =  -4.00 (xtal) */
				dssf->theta_q_s1 =  4297; /* freq =  -4.00 (xtal) */
				break;
			case 56:
				/* bw=20, fc= 5280 MHz */
				dssf->theta_i_s1 =  6219; /* freq =  -6.60 (xtal) */
				dssf->theta_q_s1 =  4604; /* freq =  -6.60 (xtal) */
				break;
			case 60:
				/* bw=20, fc= 5300 MHz */
				dssf->theta_i_s1 =  1859; /* freq =  -3.50 (bbpll) */
				dssf->theta_q_s1 =  4543; /* freq =  -3.50 (bbpll) */
				dssf->DSSF_gain_th0_s1 = 43;
				dssf->DSSF_gain_th1_s1 = 49;
				dssf->DSSF_gain_th2_s1 = 55;
				break;
			case 100:
				/* bw=20, fc= 5500 MHz */
				dssf->theta_i_s1 =  3155; /* freq =  -2.20 (xtal) */
				dssf->theta_q_s1 =  5582; /* freq =  -2.20 (xtal) */
				break;
			case 108:
				/* bw=20, fc= 5540 MHz */
				dssf->theta_i_s1 =   257; /* freq =  -4.80 (xtal) */
				dssf->theta_q_s1 =  4105; /* freq =  -4.80 (xtal) */
				break;
			case 116:
				/* bw=20, fc= 5580 MHz */
				dssf->theta_i_s1 =  5389; /* freq =  -7.40 (xtal) */
				dssf->theta_q_s1 =  5207; /* freq =  -7.40 (xtal) */
				break;
			case 128:
				/* bw=20, fc= 5640 MHz */
				dssf->theta_i_s1 =  5389; /* freq =  +7.40 (xtal) */
				dssf->theta_q_s1 =  2985; /* freq =  +7.40 (xtal) */
				break;
			case 130:
				/* bw=20, fc= 5650 MHz */
				dssf->theta_i_s1 =  2803; /* freq =  -2.60 (xtal) */
				dssf->theta_q_s1 =  5207; /* freq =  -2.60 (xtal) */
				dssf->DSSF_gain_th0_s1 = 43;
				dssf->DSSF_gain_th1_s1 = 49;
				dssf->DSSF_gain_th2_s1 = 55;
				break;
			case 136:
				/* bw=20, fc= 5680 MHz */
				dssf->theta_i_s1 =   257; /* freq =  +4.80 (xtal) */
				dssf->theta_q_s1 =  4087; /* freq =  +4.80 (xtal) */
				break;
			case 144:
				/* bw=20, fc= 5720 MHz */
				dssf->theta_i_s1 =  3155; /* freq =  +2.20 (xtal) */
				dssf->theta_q_s1 =  2610; /* freq =  +2.20 (xtal) */
				break;
			case 153:
				/* bw=20, fc= 5765 MHz */
				dssf->theta_i_s1 =  7679; /* freq =  -5.40 (xtal) */
				dssf->theta_q_s1 =  4129; /* freq =  -5.40 (xtal) */
				dssf->DSSF_gain_th0_s1 = 43;
				dssf->DSSF_gain_th1_s1 = 49;
				dssf->DSSF_gain_th2_s1 = 55;
				break;
			case 161:
				/* bw=20, fc= 5805 MHz */
				dssf->theta_i_s1 =  4879; /* freq =  -8.00 (xtal) */
				dssf->theta_q_s1 =  5785; /* freq =  -8.00 (xtal) */
				break;
			case 165:
				/* bw=20, fc= 5825 MHz */
				dssf->theta_i_s2 =  4170; /* freq =  +9.40 (xtal) */
				dssf->theta_q_s2 =   767; /* freq =  +9.40 (xtal) */
				break;
			case 38:
				/* bw=40, fc= 5190 MHz */
				dssf->theta_i_s1 =   893; /* freq =  +8.60 (xtal) */
				dssf->theta_q_s1 =  3996; /* freq =  +8.60 (xtal) */
				break;
			case 46:
				/* bw=40, fc= 5230 MHz */
				dssf->theta_i_s1 =  2407; /* freq =  +6.00 (xtal) */
				dssf->theta_q_s1 =  3313; /* freq =  +6.00 (xtal) */
				break;
			case 102:
				/* bw=40, fc= 5510 MHz */
				dssf->theta_i_s1 =  6805; /* freq = -12.20 (xtal) */
				dssf->theta_q_s1 =  4339; /* freq = -12.20 (xtal) */
				break;
			case 110:
				/* bw=40, fc= 5550 MHz */
				dssf->theta_i_s1 =  5389; /* freq = -14.80 (xtal) */
				dssf->theta_q_s1 =  5207; /* freq = -14.80 (xtal) */
				break;
			case 118:
				/* bw=40, fc= 5590 MHz */
				dssf->theta_i_s1 =  4434; /* freq = -17.40 (xtal) */
				dssf->theta_q_s1 =  6566; /* freq = -17.40 (xtal) */
				break;
			case 126:
				/* bw=40, fc= 5630 MHz */
				dssf->theta_i_s1 =  4434; /* freq = +17.40 (xtal) */
				dssf->theta_q_s1 =  1626; /* freq = +17.40 (xtal) */
				break;
			case 134:
				/* bw=40, fc= 5670 MHz */
				dssf->theta_i_s1 =  5389; /* freq = +14.80 (xtal) */
				dssf->theta_q_s1 =  2985; /* freq = +14.80 (xtal) */
				break;
			case 142:
				/* bw=40, fc= 5710 MHz */
				dssf->theta_i_s1 =  6805; /* freq = +12.20 (xtal) */
				dssf->theta_q_s1 =  3853; /* freq = +12.20 (xtal) */
				break;
			case 151:
				/* bw=40, fc= 5755 MHz */
				dssf->theta_i_s1 =  3072; /* freq =  +4.60 (xtal) */
				dssf->theta_q_s1 =  2708; /* freq =  +4.60 (xtal) */
				break;
			case 159:
				/* bw=40, fc= 5795 MHz */
				dssf->theta_i_s1 =  3895; /* freq =  +2.00 (xtal) */
				dssf->theta_q_s1 =  1265; /* freq =  +2.00 (xtal) */

				dssf->theta_i_s2 =  4543; /* freq = -17.00 (bbpll) */
				dssf->theta_q_s2 =  6333; /* freq = -17.00 (bbpll) */
				break;
			case 42:
				/* bw=80, fc= 5210 MHz */
				dssf->theta_i_s1 =  2560; /* freq = -11.40 (xtal) */
				dssf->theta_q_s1 =  4996; /* freq = -11.40 (xtal) */

				dssf->theta_i_s2 =  6333; /* freq = +26.00 (xtal) */
				dssf->theta_q_s2 =  3649; /* freq = +26.00 (xtal) */
				break;
			case 58:
				/* bw=80, fc= 5290 MHz */
				dssf->theta_i_s1 =  1081; /* freq = -16.60 (xtal) */
				dssf->theta_q_s1 =  4242; /* freq = -16.60 (xtal) */

				dssf->theta_i_s2 =  7935; /* freq = +20.80 (xtal) */
				dssf->theta_q_s2 =  4087; /* freq = +20.80 (xtal) */
				break;
			case 106:
				/* bw=80, fc= 5530 MHz */
				dssf->theta_i_s1 =  4842; /* freq = -32.20 (xtal) */
				dssf->theta_q_s1 =  5837; /* freq = -32.20 (xtal) */

				dssf->theta_i_s2 =  3758; /* freq =  +5.20 (xtal) */
				dssf->theta_q_s2 =  1626; /* freq =  +5.20 (xtal) */
				break;

			case 122:
				/* bw=80, fc= 5610 MHz */
				dssf->theta_i_s1 =  4182; /* freq = -37.40 (xtal) */
				dssf->theta_q_s1 =  7362; /* freq = -37.40 (xtal) */

				dssf->theta_i_s2 =  4182; /* freq = +37.40 (xtal) */
				dssf->theta_q_s2 =   830; /* freq = +37.40 (xtal) */
				break;
			case 138:
				/* bw=80, fc= 5690 MHz */
				dssf->theta_i_s1 =  4842; /* freq = +32.20 (xtal) */
				dssf->theta_q_s1 =  2355; /* freq = +32.20 (xtal) */

				dssf->theta_i_s2 =  3758; /* freq =  -5.20 (xtal) */
				dssf->theta_q_s2 =  6566; /* freq =  -5.20 (xtal) */
				break;
			case 155:
				/* bw=80, fc= 5775 MHz */
				dssf->theta_i_s1 =  7551; /* freq = +22.00 (xtal) */
				dssf->theta_q_s1 =  4045; /* freq = +22.00 (xtal) */

				dssf->theta_i_s2 =  1447; /* freq = -15.40 (xtal) */
				dssf->theta_q_s2 =  4361; /* freq = -15.40 (xtal) */
				break;
			default:
				;
			}

			if (dssf->theta_i_s1 || dssf->theta_i_s2) {
				dssf->DSSF_C_CTRL = 4;

				if (dssf->theta_i_s2)
					dssf->enabled_s2 = 1;

				PHY_INFORM(("%s: xtal freq 37.4M, applying dssf for channel %d\n",
				           __FUNCTION__, dssf->channel));
			}
		} else if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
			if (PHY_IPA(pi) && PHY_XTAL_IS40M(pi)) {
				switch (dssf->channel) {
				/* 2G, 20Mhz && 40Mhz */
				case 3:
					dssf->DSSF_C_CTRL = 4;
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 4298; /* freq = 18 */
						dssf->theta_q_s1 = 1265; /* freq = 18 */
					}
					break;
				case 4:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 6333; /* freq = 13 */
						dssf->theta_q_s1 = 3648; /* freq = 13 */
					}
					break;
				case 5:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 1265; /* freq = 8 */
						dssf->theta_q_s1 = 3894; /* freq = 8 */
					} else {
						dssf->theta_i_s1 = 4880; /* freq = 8 */
						dssf->theta_q_s1 = 2406; /* freq = 8 */
					}
					break;
				case 6:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 3648; /* freq = 3 */
						dssf->theta_q_s1 = 1859; /* freq = 3 */
					} else {
						dssf->theta_i_s1 = 2406; /* freq = 3 */
						dssf->theta_q_s1 = 3312; /* freq = 3 */
					}
					break;
				case 7:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 3894; /* freq = -2 */
						dssf->theta_q_s1 = 6927; /* freq = -2 */
					} else {
						dssf->theta_i_s1 = 3312; /* freq = -2 */
						dssf->theta_q_s1 = 5786; /* freq = -2 */
					}
					break;
				case 8:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 1859; /* freq = -7 */
						dssf->theta_q_s1 = 4544; /* freq = -7 */
					} else {
						dssf->theta_i_s1 = 5786; /* freq = -7 */
						dssf->theta_q_s1 = 4880; /* freq = -7 */
					}
					break;
				case 9:
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
						dssf->DSSF_C_CTRL = 4;
						dssf->theta_i_s1 = 6927; /* freq = -12 */
						dssf->theta_q_s1 = 4298; /* freq = -12 */
					}
					break;
				case 10:
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
						dssf->DSSF_C_CTRL = 4;
						dssf->theta_i_s1 = 4544; /* freq = -17 */
						dssf->theta_q_s1 = 6333; /* freq = -17 */
					}
					break;
				case 11:
					if (CHSPEC_IS40(pi->radio_chanspec)) {
						PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
						dssf->DSSF_C_CTRL = 4;
						dssf->theta_i_s1 = 4298; /* freq = 18 */
						dssf->theta_q_s1 = 1265; /* freq = 18 */
						dssf->theta_i_s2 = 4298; /* freq = 18 */
						dssf->theta_q_s2 = 1265; /* freq = 18 */
						dssf->DSSF_gain_th0_s1 = 40;
						dssf->DSSF_gain_th1_s1 = 64;
						dssf->DSSF_gain_th2_s1 = 69;
						dssf->DSSF_gain_th0_s2 = 40;
						dssf->DSSF_gain_th1_s2 = 64;
						dssf->DSSF_gain_th2_s2 = 69;
						dssf->enabled_s2 = 1;
					}
					break;
				case 13:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					if (CHSPEC_IS20(pi->radio_chanspec)) {
						dssf->DSSF_C_CTRL = 4;
					} else if (CHSPEC_IS40(pi->radio_chanspec)) {
						dssf->theta_i_s1 = 1265; /* freq = 8 */
						dssf->theta_q_s1 = 3894; /* freq = 8 */
						dssf->theta_i_s2 = 1265; /* freq = 8 */
						dssf->theta_q_s2 = 3894; /* freq = 8 */
					} else {
						dssf->theta_i_s1 = 4880; /* freq = 8 */
						dssf->theta_q_s1 = 2406; /* freq = 8 */
						dssf->theta_i_s2 = 4880; /* freq = 8 */
						dssf->theta_q_s2 = 2406; /* freq = 8 */
						dssf->DSSF_gain_th0_s1 = 60;
						dssf->DSSF_gain_th1_s1 = 68;
						dssf->DSSF_gain_th2_s1 = 74;
						dssf->DSSF_gain_th0_s2 = 60;
						dssf->DSSF_gain_th1_s2 = 68;
						dssf->DSSF_gain_th2_s2 = 74;
					}
					dssf->enabled_s2 = 1;
					break;

				/* 5G, 40Mhz */
				case 38:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 0; /* freq = -10 */
					dssf->theta_q_s1 = 4098; /* freq = -10 */
					dssf->theta_i_s2 = 0; /* freq = 10 */
					dssf->theta_q_s2 = 4094; /* freq = 10 */
					dssf->enabled_s2 = 1;
					break;
				case 62:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 0; /* freq = -10 */
					dssf->theta_q_s1 = 4098; /* freq = -10 */
					dssf->theta_i_s2 = 0; /* freq = 10 */
					dssf->theta_q_s2 = 4094; /* freq = 10 */
					dssf->enabled_s2 = 1;
					break;
				case 110:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 0; /* freq = -10 */
					dssf->theta_q_s1 = 4098; /* freq = -10 */
					dssf->theta_i_s2 = 0; /* freq = 10 */
					dssf->theta_q_s2 = 4094; /* freq = 10 */
					dssf->enabled_s2 = 1;
					break;
				case 134:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 0; /* freq = -10 */
					dssf->theta_q_s1 = 4098; /* freq = -10 */
					dssf->theta_i_s2 = 0; /* freq = 10 */
					dssf->theta_q_s2 = 4094; /* freq = 10 */
					dssf->enabled_s2 = 1;
					break;

				/* 5G, 80Mhz */
				case 122:
					PHY_INFORM((
						"%s: xtal freq 40M, applying dssf for channel %d\n",
						__FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 0; /* freq = 20 */
					dssf->theta_q_s1 = 4094; /* freq = 20 */
					dssf->theta_i_s2 = 5297; /* freq = 30 */
					dssf->theta_q_s2 = 2895; /* freq = 30 */
					dssf->DSSF_gain_th0_s1 = 63;
					dssf->DSSF_gain_th1_s1 = 69;
					dssf->DSSF_gain_th2_s1 = 75;
					dssf->DSSF_gain_th0_s2 = 63;
					dssf->DSSF_gain_th1_s2 = 69;
					dssf->DSSF_gain_th2_s2 = 75;
					dssf->enabled_s2 = 1;
					break;

				default:
					break;
				}
			} else if (PHY_ILNA(pi)) {
				switch (dssf->channel) {
				case 1:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 4880; /* freq = 8 */
					dssf->theta_q_s1 = 2406; /* freq = 8 */
					dssf->DSSF_gain_th0_s1 = 68;
					dssf->DSSF_gain_th1_s1 = 78;
					dssf->DSSF_gain_th2_s1 = 84;
					break;
				case 2:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 2406; /* freq = 3 */
					dssf->theta_q_s1 = 3312; /* freq = 3 */
					break;
				case 3:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3313; /* freq = -2 */
					dssf->theta_q_s1 = 5785; /* freq = -2 */
					dssf->DSSF_gain_th0_s1 = 68;
					dssf->DSSF_gain_th1_s1 = 74;
					dssf->DSSF_gain_th2_s1 = 84;
					break;
				case 4:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 5785; /* freq = -7 */
					dssf->theta_q_s1 = 4879; /* freq = -7 */
					dssf->theta_i_s2 = 1265; /* freq = 4 */
					dssf->theta_q_s2 = 3894; /* freq = 4 */
					dssf->enabled_s2 = 1;
					break;
				case 5:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3894; /* freq = -1 */
					dssf->theta_q_s1 = 6927; /* freq = -1 */
					dssf->DSSF_gain_th0_s1 = 72;
					dssf->DSSF_gain_th1_s1 = 78;
					dssf->DSSF_gain_th2_s1 = 84;
					break;
				case 6:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6927; /* freq = -6 */
					dssf->theta_q_s1 = 4298; /* freq = -6 */
					dssf->DSSF_gain_th0_s1 = 72;
					dssf->DSSF_gain_th1_s1 = 78;
					dssf->DSSF_gain_th2_s1 = 84;
					break;
				case 11:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6455; /* freq = 6.395 */
					dssf->theta_q_s1 = 3708; /* freq = 6.395 */
					break;
				case 12:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3708; /* freq = 1.395 */
					dssf->theta_q_s1 = 1737; /* freq = 1.395 */
					break;
				case 13:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 1737; /* freq = -3.605 */
					dssf->theta_q_s1 = 4484; /* freq = -3.605 */
					break;
				case 48:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 1265; /* freq = -4.0 */
					dssf->theta_q_s1 = 4297; /* freq = -4.0 */
					break;
				case 56:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6214; /* freq = -6.605 */
					dssf->theta_q_s1 = 4607; /* freq = -6.605 */
					break;
				case 100:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3146; /* freq = -2.211 */
					dssf->theta_q_s1 = 5571; /* freq = -2.211 */
					break;
				case 108:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 271; /* freq = -4.789 */
					dssf->theta_q_s1 = 4106; /* freq = -4.789 */
					dssf->DSSF_gain_th0_s1 = 64;
					dssf->DSSF_gain_th1_s1 = 70;
					dssf->DSSF_gain_th2_s1 = 76;
					break;
				case 116:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 5389; /* freq = -7.4 */
					dssf->theta_q_s1 = 5207; /* freq = -7.4 */
					break;
				case 128:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 5389; /* freq = 7.4 */
					dssf->theta_q_s1 = 2985; /* freq = 7.4 */
					break;
				case 136:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 271; /* freq = 4.789 */
					dssf->theta_q_s1 = 4086; /* freq = 4.789 */
					break;
				case 144:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 0;
					dssf->theta_i_s1 = 3146; /* freq = 2.211 */
					dssf->theta_q_s1 = 2621; /* freq = 2.211 */
					break;
				case 153:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 7686; /* freq = -5.395 */
					dssf->theta_q_s1 = 4129; /* freq = -5.395 */
					break;
				case 161:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 4880; /* freq = -8 */
					dssf->theta_q_s1 = 5786; /* freq = -8 */
					break;
				case 165:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 4170; /* freq = 9.395 */
					dssf->theta_q_s1 = 774; /* freq = 9.395 */
					break;
				/* 40Mhz */
				case 46:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 2406; /* freq = 6 */
					dssf->theta_q_s1 = 3312; /* freq = 6 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 54:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3526; /* freq = 3.395 */
					dssf->theta_q_s1 = 2081; /* freq = 3.395 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 62:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 4063; /* freq = 0.789 */
					dssf->theta_q_s1 = 506; /* freq = 0.789 */
					dssf->DSSF_gain_th0_s1 = 58;
					dssf->DSSF_gain_th1_s1 = 64;
					dssf->DSSF_gain_th2_s1 = 70;
					break;
				case 102:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6798; /* freq = -12.211 */
					dssf->theta_q_s1 = 4341; /* freq = -12.211 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 110:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 5394; /* freq = -14.789 */
					dssf->theta_q_s1 = 5203; /* freq = -14.789 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 134:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 5394; /* freq = 14.789 */
					dssf->theta_q_s1 = 2989; /* freq = 14.789 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 142:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6798; /* freq = 12.211 */
					dssf->theta_q_s1 = 3850; /* freq = 12.211 */
					dssf->DSSF_gain_th0_s1 = 60;
					dssf->DSSF_gain_th1_s1 = 66;
					dssf->DSSF_gain_th2_s1 = 72;
					break;
				case 151:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3069; /* freq = 4.605 */
					dssf->theta_q_s1 = 2710; /* freq = 4.605 */
					dssf->DSSF_gain_th0_s1 = 58;
					dssf->DSSF_gain_th1_s1 = 64;
					dssf->DSSF_gain_th2_s1 = 70;
					break;
				case 159:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3895; /* freq = 2 */
					dssf->theta_q_s1 = 1265; /* freq = 2 */
					dssf->DSSF_gain_th0_s1 = 58;
					dssf->DSSF_gain_th1_s1 = 64;
					dssf->DSSF_gain_th2_s1 = 70;
					break;
				/* 80Mhz */
				case 42:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 6332; /* freq = -26 */
					dssf->theta_q_s1 = 4543; /* freq = -26 */
					dssf->DSSF_gain_th0_s1 = 54;
					dssf->DSSF_gain_th1_s1 = 60;
					dssf->DSSF_gain_th2_s1 = 66;
					break;
				case 58:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 7938; /* freq = -20.789 */
					dssf->theta_q_s1 = 4104; /* freq = -20.789 */
					dssf->DSSF_gain_th0_s1 = 54;
					dssf->DSSF_gain_th1_s1 = 60;
					dssf->DSSF_gain_th2_s1 = 66;
					break;
				case 106:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3757; /* freq = -5.211 */
					dssf->theta_q_s1 = 1630; /* freq = -5.211 */
					dssf->DSSF_gain_th0_s1 = 54;
					dssf->DSSF_gain_th1_s1 = 60;
					dssf->DSSF_gain_th2_s1 = 66;
					break;
				case 138:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 3757; /* freq = 5.211 */
					dssf->theta_q_s1 = 1630; /* freq = 5.211 */
					dssf->theta_i_s2 = 4840; /* freq = -32.211 */
					dssf->theta_q_s2 = 5840; /* freq = -32.211 */
					dssf->enabled_s2 = 1;
					dssf->DSSF_gain_th0_s1 = 54;
					dssf->DSSF_gain_th1_s1 = 60;
					dssf->DSSF_gain_th2_s1 = 66;
					break;
				case 155:
					PHY_INFORM(("%s: applying dssf for channel %d\n",
					            __FUNCTION__, dssf->channel));
					dssf->DSSF_C_CTRL = 4;
					dssf->theta_i_s1 = 1448; /* freq = 15.395 */
					dssf->theta_q_s1 = 3830; /* freq = 15.396 */
					dssf->DSSF_gain_th0_s1 = 54;
					dssf->DSSF_gain_th1_s1 = 60;
					dssf->DSSF_gain_th2_s1 = 66;
					break;
				default:
					break;
				}
			}
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && ACMINORREV_5(pi->pubpi.phy_rev)) {
			if (PHY_ILNA(pi) && PHY_XTAL_IS40M(pi)) {
				dssf->core = 1;
				dssf->enabled_s2 = 0;
				dssf->idepth_s2 = 0;
				dssf->DSSF_gain_th0_s1 = 0;
				dssf->DSSF_gain_th1_s1 = 0;
				dssf->DSSF_gain_th2_s1 = 0;
				dssf->DSSF_gain_th0_s2 = 0;
				dssf->DSSF_gain_th1_s2 = 0;
				dssf->DSSF_gain_th2_s2 = 0;
				switch (dssf->channel) {
				/* 2G, 20Mhz */
				case 5:
					dssf->enabled_s1 = 1;
					dssf->idepth_s1 = 2;
					dssf->DSSF_C_CTRL = 2;
					dssf->theta_i_s1 = 4880; /* freq = 8 */
					dssf->theta_q_s1 = 2406; /* freq = 8 */
					break;
				case 6:
					dssf->enabled_s1 = 1;
					dssf->idepth_s1 = 2;
					dssf->DSSF_C_CTRL = 2;
					dssf->theta_i_s1 = 2406; /* freq = 3 */
					dssf->theta_q_s1 = 3312; /* freq = 3 */
					break;
				case 7:
					dssf->enabled_s1 = 1;
					dssf->idepth_s1 = 2;
					dssf->DSSF_C_CTRL = 2;
					dssf->theta_i_s1 = 3312; /* freq = -2 */
					dssf->theta_q_s1 = 5786; /* freq = -2 */
					break;
				case 8:
					dssf->enabled_s1 = 1;
					dssf->idepth_s1 = 2;
					dssf->DSSF_C_CTRL = 2;
					dssf->theta_i_s1 = 5786; /* freq = -7 */
					dssf->theta_q_s1 = 4880; /* freq = -7 */
					break;
				case 13:
					dssf->enabled_s1 = 1;
					dssf->idepth_s1 = 2;
					dssf->DSSF_C_CTRL = 2;
					dssf->theta_i_s1 = 4880; /* freq = 8 */
					dssf->theta_q_s1 = 2406; /* freq = 8 */
					break;
				default:
					dssf->enabled_s1 = 0;
					dssf->idepth_s1 = 0;
					dssf->DSSF_C_CTRL = 0;
					break;
				}
			}
		}
	} else {
		dssf->DSSF_C_CTRL = 0;
		dssf->enabled_s1 = 0;
		dssf->enabled_s2 = 0;
	}

	wlc_phy_dssf_setup_acphy(pi);
	wlc_phy_resetcca_acphy(pi);
	wlapi_bmac_phyclk_fgc(pi->sh->physhim, OFF);
}

static void
wlc_phy_dssfB_setup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_dssfB_values_t *dssfB = &pi_ac->dssfB;
	WRITE_PHYREG(pi, DSSFB_C_CTRL, dssfB->DSSFB_C_CTRL);
	WRITE_PHYREG(pi, DSSFB_gain_th0_s1,      dssfB->DSSFB_gain_th0_s1);
	WRITE_PHYREG(pi, DSSFB_gain_th1_s1,      dssfB->DSSFB_gain_th1_s1);
	WRITE_PHYREG(pi, DSSFB_gain_th2_s1,      dssfB->DSSFB_gain_th2_s1);
	WRITE_PHYREG(pi, DSSFB_gain_th0_s2,      dssfB->DSSFB_gain_th0_s2);
	WRITE_PHYREG(pi, DSSFB_gain_th1_s2,      dssfB->DSSFB_gain_th1_s2);
	WRITE_PHYREG(pi, DSSFB_gain_th2_s2,      dssfB->DSSFB_gain_th2_s2);
	WRITE_PHYREG(pi, DSSFB_exp_j_theta_i_s1, dssfB->theta_i_s1);
	WRITE_PHYREG(pi, DSSFB_exp_i_theta_q_s1, dssfB->theta_q_s1);
	WRITE_PHYREG(pi, DSSFB_exp_j_theta_i_s2, dssfB->theta_i_s2);
	WRITE_PHYREG(pi, DSSFB_exp_i_theta_q_s2, dssfB->theta_q_s2);

	MOD_PHYREG(pi, DSSFB_control, idepth_s1,  dssfB->idepth_s1);
	MOD_PHYREG(pi, DSSFB_control, idepth_s2,  dssfB->idepth_s2);
	MOD_PHYREG(pi, DSSFB_control, enabled_s1, dssfB->enabled_s1);
	MOD_PHYREG(pi, DSSFB_control, enabled_s2, dssfB->enabled_s2);
}

static void
wlc_phy_dssf_setup_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	acphy_dssf_values_t *dssf = &pi_ac->dssf;
	WRITE_PHYREG(pi, DSSF_C_CTRL, dssf->DSSF_C_CTRL);
	WRITE_PHYREGCE(pi, DSSF_gain_th0_s1, dssf->core, dssf->DSSF_gain_th0_s1);
	WRITE_PHYREGCE(pi, DSSF_gain_th1_s1, dssf->core, dssf->DSSF_gain_th1_s1);
	WRITE_PHYREGCE(pi, DSSF_gain_th2_s1, dssf->core, dssf->DSSF_gain_th2_s1);
	WRITE_PHYREGCE(pi, DSSF_gain_th0_s2, dssf->core, dssf->DSSF_gain_th0_s2);
	WRITE_PHYREGCE(pi, DSSF_gain_th1_s2, dssf->core, dssf->DSSF_gain_th1_s2);
	WRITE_PHYREGCE(pi, DSSF_gain_th2_s2, dssf->core, dssf->DSSF_gain_th2_s2);
	WRITE_PHYREGCE(pi, DSSF_exp_j_theta_i_s1, dssf->core, dssf->theta_i_s1);
	WRITE_PHYREGCE(pi, DSSF_exp_i_theta_q_s1, dssf->core, dssf->theta_q_s1);
	WRITE_PHYREGCE(pi, DSSF_exp_j_theta_i_s2, dssf->core, dssf->theta_i_s2);
	WRITE_PHYREGCE(pi, DSSF_exp_i_theta_q_s2, dssf->core, dssf->theta_q_s2);

	if (dssf->core == 0) {
	  MOD_PHYREG(pi, DSSF_control_0, idepth_s1, dssf->idepth_s1);
	  MOD_PHYREG(pi, DSSF_control_0, idepth_s2, dssf->idepth_s2);
	  MOD_PHYREG(pi, DSSF_control_0, enabled_s1, dssf->enabled_s1);
	  MOD_PHYREG(pi, DSSF_control_0, enabled_s2, dssf->enabled_s2);
	} else if (dssf->core == 1) {
	  MOD_PHYREG(pi, DSSF_control_1, idepth_s1, dssf->idepth_s1);
	  MOD_PHYREG(pi, DSSF_control_1, idepth_s2, dssf->idepth_s2);
	  MOD_PHYREG(pi, DSSF_control_1, enabled_s1, dssf->enabled_s1);
	  MOD_PHYREG(pi, DSSF_control_1, enabled_s2, dssf->enabled_s2);
	}
}

void
wlc_phy_get_tssisens_min_acphy(phy_info_t *pi, int8 *tssiSensMinPwr)
{
	tssiSensMinPwr[0] = READ_PHYREGFLD(pi, TxPwrCtrlCore0TSSISensLmt, tssiSensMinPwr);
	if (PHYCORENUM(pi->pubpi.phy_corenum) > 1) {
		tssiSensMinPwr[1] = READ_PHYREGFLD(pi, TxPwrCtrlCore1TSSISensLmt, tssiSensMinPwr);
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2)
			tssiSensMinPwr[2] = READ_PHYREGFLD(pi, TxPwrCtrlCore2TSSISensLmt,
				tssiSensMinPwr);
	}
}

void
wlc_phy_set_tssisens_lim_acphy(phy_info_t *pi, uint8 override)
{
	uint16 tssi_limit;
	int8 visi_thresh_qdbm = WL_RATE_DISABLED;
#if defined(PHYCAL_CACHING) || defined(WLMCHAN)|| defined(WL_MODESW)
	acphy_calcache_t *cache;
	ch_calcache_t *ctx = wlc_phy_get_chanctx(pi, pi->radio_chanspec);
#endif // endif
	if (override) {
		/* Override mode, always write tssi visible thresh */
		visi_thresh_qdbm = wlc_phy_tssivisible_thresh_acphy(pi);
	}
#if defined(PHYCAL_CACHING) || defined(WLMCHAN)|| defined(WL_MODESW)
	else {
		if (ctx) {
			if (ctx->valid) {
				cache = &ctx->u.acphy_cache;
				if (cache->olpc_caldone) {
					/* If cal is done, write correct visibility thresh
					 * else, write -127
					 */
					visi_thresh_qdbm = wlc_phy_tssivisible_thresh_acphy(pi);
				}
			}
		}
	}
#endif // endif
	tssi_limit = (127 << 8) + (visi_thresh_qdbm & 0xFF);
	ACPHYREG_BCAST(pi, TxPwrCtrlCore0TSSISensLmt, tssi_limit);
}

static void
wlc_20691_dc_static_WAR(phy_info_t *pi)
{
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			if (RADIO20691_MAJORREV(pi->pubpi.radiorev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, 0, ovr_rxmix2g_pu, 0);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_rxmix2g_pu, 0);
			}
		}
	} else {
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			ACPHY_REG_LIST_START
			    MOD_RADIO_REG_20691_ENTRY(pi, RXMIX2G_CFG1, 0, rxmix2g_pu, 1)

			    MOD_RADIO_REG_20691_ENTRY(pi, RXRF2G_CFG1, 0, rxdiv2g_rs, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_rs, 1)
			    MOD_RADIO_REG_20691_ENTRY(pi, RXRF2G_CFG1, 0, rxdiv2g_pu_bias, 1)
			    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0,
			        ovr_rxdiv2g_pu_bias, 1)
			ACPHY_REG_LIST_EXECUTE(pi);

			if (RADIO20691_MAJORREV(pi->pubpi.radiorev) == 0) {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR1, 0, ovr_rxmix2g_pu, 1);
			} else {
				MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_rxmix2g_pu, 1);
			}
		} else {
			ACPHY_REG_LIST_START
			    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0, ovr_rxdiv2g_rs, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, RXRF2G_CFG1, 0, rxdiv2g_rs, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_EAST, 0,
			        ovr_rxdiv2g_pu_bias, 0)
			    MOD_RADIO_REG_20691_ENTRY(pi, RXRF2G_CFG1, 0, rxdiv2g_pu_bias, 0)
			ACPHY_REG_LIST_EXECUTE(pi);
		}
	}

	wlc_phy_force_rfseq_noLoleakage_acphy(pi);
}

static void
wlc_20691_setup_coarse_dcc(phy_info_t *pi)
{
	uint8 phybw;

	/*
	 * Settings required to use the RFSeq to trigger the coarse DCC
	 * 4345TC Not used. 20691_coarse_dcc used
	 * 4345A0 offset comparator has hysteresis and dc offset but is adequate for 5G
	 */

	wlc_20691_dc_static_WAR(pi);

	ACPHY_REG_LIST_START
		/* Control via pktproc, instead of RFSEQ */
		MOD_PHYREG_ENTRY(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl,  1)

		/* Disable overrides that may have been set during 2G cal */
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_dac_pwrup, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_dac, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_NORTH, 0, ovr_tia_offset_comp_pwrup, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_dac, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Set idac LSB to 1uA */
	MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_biasadj,
	                    (CHSPEC_IS2G(pi->radio_chanspec)) ? 4 : 12);

	/* Set minimum idle gain incase of restart */
	MOD_PHYREG(pi, rx_tia_dc_loop_0, restart_gear, 6);

	if (IS20MHZ(pi))
		phybw = 0;
	else if (IS40MHZ(pi))
		phybw = 1;
	else
		phybw = 2;

	/*
	 * Because FSM clock is PHY_BW dependant scale gear gain and loop count.
	 *
	 * Settings below assume:
	 *	9 DCC FSM clock cycle latency and single pole  RC filter >=2MHz ala 4345B0.
	 * (Valid also for 4345A0).
	 */
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_0, loop_gain_0, 15); /* disable */
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_1, loop_gain_1, 2 + phybw);
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_2, loop_gain_2, 4 + phybw);
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_3, loop_gain_3, 5 + phybw);
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_4, loop_gain_4, 6 + phybw);
	MOD_PHYREG(pi, rx_tia_dc_loop_gain_5, loop_gain_5, 8 + phybw);

	MOD_PHYREG(pi, rx_tia_dc_loop_count_0, loop_count_0, 0); /* disable */
	MOD_PHYREG(pi, rx_tia_dc_loop_count_1, loop_count_1, (phybw > 1) ? 255 : (80 << phybw));
	MOD_PHYREG(pi, rx_tia_dc_loop_count_2, loop_count_2, (phybw > 1) ? 255 : (80 << phybw));
	MOD_PHYREG(pi, rx_tia_dc_loop_count_3, loop_count_3, (phybw > 1) ? 255 : (80 << phybw));
	MOD_PHYREG(pi, rx_tia_dc_loop_count_4, loop_count_4, (phybw > 1) ? 255 : (80 << phybw));
	MOD_PHYREG(pi, rx_tia_dc_loop_count_5, loop_count_5, (20 << phybw));

	if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACREV_GE(pi->pubpi.phy_rev, 11))
		wlc_enable_lna_dcc_comp_20691(pi, PHY_ILNA(pi));
}

static void
wlc_20691_coarse_dcoc(phy_info_t *pi)
{
	int save_i = 0;
	int save_q = 0;
#ifndef BCMRADIOREV
	uint32 radio_rev = pi->pubpi.radiorev;
#endif // endif

	PHY_TRACE(("%s\n", __FUNCTION__));
	/*
	 * Null adjust TIA iDACs for minimum DC out of ADC's
	 * Effectively overriding DCOC FSM
	 * Can be used to verify operation of DCOC FSM by comparing results
	 */
	if (RADIO20691_MAJORREV(radio_rev) == 0) {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR1, 0, ovr_tia_offset_dac, 1);
	} else {
		MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_dac, 1);
	}

	/* For 4345A0 allow DCOC FSM to run to supply clock to comparator */
	if (RADIO20691_MAJORREV(radio_rev) != 0) {
	    ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, rx_tia_dc_loop_0, en_lock, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_NORTH, 0, ovr_tia_offset_comp_pwrup, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, 0, ovr_tia_offset_dac_pwrup, 1)
	    ACPHY_REG_LIST_EXECUTE(pi);
	}

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG8, 0, tia_offset_dac_pwrup, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG15, 0, tia_offset_comp_pwrup, 1)

		/* current non-default until we verify tx unaffected */
		/* setting forces to ensure DCOC cal is static over tx/rx */
		/* this affects DC offsets, and OFDM RX performance above -60 dBm */
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, 0, adc_in_test, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	/* Force stability on DC offsets over txrx transition
	 * for TC DC offset changes on (1) adc clk pu and (2)
	 * rx2gmix (important for boardtest as acphy_set_active_core
	 * would otherwise invalidate dc offset)
	 */

	/* TODO XXX: why is tx transition is affecting DC offsets ??
	 * we call core mask to execute this transition once
	 * The next two statements are actually "acphy_rx_coremask 1"
	 * in the tcl but I think they can be reduced to the following.
	 * I'm double checking with John Olip.
	 */
	wlc_phy_force_rfseq_noLoleakage_acphy(pi);

	wlc_20691_dc_static_WAR(pi);

	/* reset required for dac rate mode 2
	 * rx2tx; tx2rx transition in acphy_rx_coremask (causes gain lockup)
	 */
	wlc_phy_resetcca_acphy(pi);

	/* Using the radiooffset comparator(limiter) get coarse idac settings
	 * HACK WAR: not fully understood but looks like the logen is not getting a suitable reset
	 * resetcca then intermitently results in a large DC offset.
	 */
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		ACPHY_REG_LIST_START
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_OVR1, 0, ovr_logencore_reset, 1)
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_reset, 0)
			MOD_RADIO_REG_20691_ENTRY(pi, LOGEN_CFG2, 0, logencore_reset, 1)
		ACPHY_REG_LIST_EXECUTE(pi);
		OSL_DELAY(1000);
		MOD_RADIO_REG_20691(pi, LOGEN_CFG2, 0, logencore_reset, 0);
		MOD_RADIO_REG_20691(pi, LOGEN_OVR1, 0, ovr_logencore_reset, 0);
	}
	wlc_20691_dcoc_idac_set(pi, 0, IDAC_20691_I_CHANNEL);
	save_i = wlc_20691_idac_iterate_lim(pi, IDAC_20691_I_CHANNEL, 8);

	wlc_20691_dcoc_idac_set(pi, 0, IDAC_20691_Q_CHANNEL);
	save_q = wlc_20691_idac_iterate_lim(pi, IDAC_20691_Q_CHANNEL, 8);

	PHY_INFORM(("%s: iterate_lim values: i=%i q=%i\n", __FUNCTION__, save_i, save_q));

	/* About these coarse settings find the minimum */
	save_i = wlc_20691_idac_minsearch_iqest(pi, IDAC_20691_I_CHANNEL,
	                                        save_i - 20, save_i + 20, 1);
	save_q = wlc_20691_idac_minsearch_iqest(pi, IDAC_20691_Q_CHANNEL,
	                                        save_q - 20, save_q + 20, 1);
	PHY_INFORM(("%s: save_i=%i, save_q=%i\n", __FUNCTION__, save_i, save_q));

	wlc_20691_dcoc_idac_set(pi, save_i, IDAC_20691_I_CHANNEL);
	wlc_20691_dcoc_idac_set(pi, save_q, IDAC_20691_Q_CHANNEL);
}

static void
wlc_20691_dcoc_idac_set(phy_info_t *pi, int dac, int ch)
{
	/* Override dcoc idac with desired values. */
	if (ch == IDAC_20691_I_CHANNEL) {
		MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_sign_i,
		                    (dac >= 0) ? 0 : 1);
		MOD_RADIO_REG_20691(pi, TIA_CFG11, 0, tia_offset_dac_d_i, ABS(dac));
	} else {
		MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_sign_q,
		                    (dac >= 0) ? 0 : 1);
		MOD_RADIO_REG_20691(pi, TIA_CFG11, 0, tia_offset_dac_d_q, ABS(dac));
	}
}

static int
wlc_20691_idac_iterate_lim(phy_info_t *pi, int ch, int iters)
{
	int dac_max = (RADIO20691_MAJORREV(pi->pubpi.radiorev) == 0) ? 127 : 255;
	int dac_0;
	int dac_1;
	int dac_2;
	int dc_off;
	int x;
	int i;

#define LIMITER_SAMPLES 128	/* Ensure an even number of samples to average over */

	PHY_TRACE(("%s\n", __FUNCTION__));

	dac_0 = -dac_max;
	dac_2 = dac_max;
	dac_1 = 0;

	for (x = 0; x < iters; x++)
	{
		dac_1 = (dac_0 + dac_2) / 2;
		wlc_20691_dcoc_idac_set(pi, dac_1, ch);
		OSL_DELAY(100);
		dc_off = 0;
		for (i = 0; i < LIMITER_SAMPLES; i++) {
			if (ch == IDAC_20691_I_CHANNEL)
				dc_off += READ_RADIO_REGFLD_20691(pi, TIA_CFG10, 0,
				                                  tia_offset_comp_out_i);
			else
				dc_off += READ_RADIO_REGFLD_20691(pi, TIA_CFG10, 0,
				                                  tia_offset_comp_out_q);
			OSL_DELAY(1);
		}
		if (dc_off < (LIMITER_SAMPLES >> 1)) {
			dac_2 = dac_1;
		} else {
			dac_0 = dac_1;
		}
		PHY_NONE(("%s[%i]: dc_off=%i : dac_0=%i : dac_1=%i : dac_2=%i\n",
		          __FUNCTION__, x, dc_off, dac_0, dac_1, dac_2));
	}

	return dac_1;
}

static int
wlc_20691_idac_minsearch_iqest(phy_info_t *pi, int ch, int dac_min, int dac_max,  int dac_step)
{
	int dac_settle = 10;
	int idac_min = 0;
	phy_iq_est_t iq_ii_qq[PHY_CORE_MAX];
	int dac;
	uint32 min_power = 100000000U;
	uint32 power;
	uint8 core;

	MOD_PHYREG(pi, DcFiltAddress, dcBypass, 1);

	for (dac = dac_min; dac <= dac_max; dac += dac_step)
	{
		wlc_20691_dcoc_idac_set(pi, dac, ch);
		OSL_DELAY(dac_settle);

		wlc_phy_rx_iq_est_acphy(pi, iq_ii_qq, 0x4000, 32, 0, 0);

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			if (READ_PHYREGFLD(pi, RxFeCtrl1, swap_iq0) == 1)
				power = (ch == IDAC_20691_I_CHANNEL) ? iq_ii_qq[core].q_pwr
				                                     : iq_ii_qq[core].i_pwr;
			else
				power = (ch == IDAC_20691_I_CHANNEL) ? iq_ii_qq[core].i_pwr
				                                     : iq_ii_qq[core].q_pwr;

			PHY_NONE(("%s[%c]: dac = %i : power = %i\n", __FUNCTION__,
			         (ch == IDAC_20691_I_CHANNEL) ? 'I' : 'Q', dac, power));

			if (power < min_power) {
				idac_min = dac;
				min_power = power;
			}
		}
	}

	MOD_PHYREG(pi, DcFiltAddress, dcBypass, 0);

	return idac_min;
}

/* NB returns SUM not AVERAGE of hpf dc est */
/* Based on: proc acphy_get_hpf_dc_est { {averages 10} } */

static void
wlc_phy_get_rx_hpf_dc_est_acphy(phy_info_t *pi, phy_hpf_dc_est_t *hpf_iqdc, uint16 nump_samps)
{
	uint8 core;
	uint16 i;

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		hpf_iqdc[core].i_accum = 0;
		hpf_iqdc[core].q_accum = 0;
	}
	for (i = 0; i < nump_samps; i++) {
		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			hpf_iqdc[core].i_accum += (int16)READ_PHYREG(pi, DCestimateI0);
			hpf_iqdc[core].q_accum += (int16)READ_PHYREG(pi, DCestimateQ0);
		}
	}
}

/*
 * Based on:
 *  proc acphy_digi_dccomp_minsearch { {DDCC_MIN -32} {DDCC_MAX 31} {DDCC_STEP 1} {use_hpf_est 1} }
 *  proc acphy_tiny_static_dc_offset_cal { }
 */
static int
wlc_phy_tiny_static_dc_offset_cal(phy_info_t *pi)
{
	/* Use HPF DC estimate to find optimum static DC offset setting */

	int16 inext[PHY_CORE_MAX];
	int16 qnext[PHY_CORE_MAX];
	uint16 sparereg;

	phy_hpf_dc_est_t hpf_iqdc[PHY_CORE_MAX];

	uint8 core;
	uint8 count;
	uint8 swap_saved[PHY_CORE_MAX];
	uint8 ovr, pu, idacbias;

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));

	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* set LNA off */
	/* save config */
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		ovr = READ_RADIO_REGFLD_20691(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_pu);
		pu = READ_RADIO_REGFLD_20691(pi, LNA5G_CFG1, 0, lna5g_lna1_pu);
		ACPHY_REG_LIST_START
		    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_out_short_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG1, 0, lna5g_lna1_out_short_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, LNA5G_CFG1, 0, lna5g_lna1_pu, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	} else {
		ovr = READ_RADIO_REGFLD_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_lna1_pu);
		pu  = READ_RADIO_REGFLD_20691(pi, LNA2G_CFG1, 0, lna2g_lna1_pu);
		ACPHY_REG_LIST_START
		    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_NORTH, 0,
		        ovr_lna2g_lna1_out_short_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG1, 0, lna2g_lna1_out_short_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_lna1_pu, 1)
		    MOD_RADIO_REG_20691_ENTRY(pi, LNA2G_CFG1, 0, lna2g_lna1_pu, 0)
		ACPHY_REG_LIST_EXECUTE(pi);
	}

	idacbias = READ_RADIO_REGFLD_20691(pi, TIA_CFG8, 0, tia_offset_dac_biasadj);

	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 0);

	/* Minimise idac step size so that it does not contribute to DC offsets */
	MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_biasadj, 1);

	OSL_DELAY(1);	/* allow radio to settle */

	wlc_dcc_fsm_reset(pi);	/* Redo Coarse cal */

	sparereg = READ_PHYREG(pi, SpareReg);
	WRITE_PHYREG(pi, SpareReg,  sparereg | 0x4000);	/* assert dcc fsm hold */

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		swap_saved[core] = READ_PHYREGFLD(pi, RxFeCtrl1, swap_iq0);
		MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, 0);
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		inext[core] = 0;
		qnext[core] = 0;
	}

	for (count = 0; count < 3; count++) {

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			wlc_rx_digi_dccomp_set(pi, inext[core], qnext[core], core);
		}

		wlc_phy_get_rx_hpf_dc_est_acphy(pi, hpf_iqdc, 13);

		FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
			inext[core] = inext[core] - (int16)(hpf_iqdc[core].i_accum >> 11);
			qnext[core] = qnext[core] - (int16)(hpf_iqdc[core].q_accum >> 11);
		}
	}

	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		/*
		 * Limit adjustment to maximum expected. This includes net offset due to:
		 * TIA, comparator and ADC offsets
		 */
		if (inext[core] < -15)  inext[core] = -15;
		if (qnext[core] < -15)  qnext[core] = -15;
		if (inext[core] > 15)  inext[core] = 15;
		if (qnext[core] > 15)  qnext[core] = 15;

		wlc_rx_digi_dccomp_set(pi, inext[core], qnext[core], core);
		MOD_PHYREG(pi, RxFeCtrl1, swap_iq0, swap_saved[core]);
#if defined(BCMDBG_RXCAL)
		printf("core[%d]: static dc offset cal (%i, %i)\n", core, inext[core], qnext[core]);
#endif // endif
	}

	MOD_RADIO_REG_20691(pi, TIA_CFG8, 0, tia_offset_dac_biasadj, idacbias);

	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_pu, ovr);
		MOD_RADIO_REG_20691(pi, LNA5G_CFG1, core, lna5g_lna1_pu, pu);
		MOD_RADIO_REG_20691(pi, LNA5G_CFG1, 0, lna5g_lna1_out_short_pu, 0);
		MOD_RADIO_REG_20691(pi, RX_TOP_5G_OVR, 0, ovr_lna5g_lna1_out_short_pu, 0);
	} else {
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_lna1_pu, ovr);
		MOD_RADIO_REG_20691(pi, LNA2G_CFG1, core, lna2g_lna1_pu, pu);
		MOD_RADIO_REG_20691(pi, RX_TOP_2G_OVR_NORTH, 0, ovr_lna2g_lna1_out_short_pu, 0);
		MOD_RADIO_REG_20691(pi, LNA2G_CFG1, 0, lna2g_lna1_out_short_pu, 0);
	}

	OSL_DELAY(2);
	WRITE_PHYREG(pi, SpareReg, sparereg & 0xbfff);	/* Release dcc fsm hold */
	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 1);

	wlc_dcc_fsm_reset(pi);	/* Redo Coarse cal */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	return BCME_OK;
}

/*
 * Based on: proc tiny_rx_digi_dccomp_set {{value 0} { channel "i" }}
 */
static void
wlc_rx_digi_dccomp_set(phy_info_t *pi, int16 i, int16 q, uint8 core)
{
	uint16 war;

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));

	if (i < -32)  i = -32;
	if (q < -32)  q = -32;
	if (i > 31)  i = 31;
	if (q > 31)  q = 31;

	/* Convert to 2's complement 6 bits representation */
	if (i < 0)
		i += 64;

	if (q < 0)
		q += 64;

	war = READ_PHYREG(pi, work_around_ctrl);
	WRITE_PHYREG(pi, work_around_ctrl, (war & 0x8181) | ((q & 0x3f) << 9) | ((i & 0x3f) << 1));

	PHY_NONE(("%d  %d  0x%x\n", i, q, (READ_PHYREG(pi, work_around_ctrl) & 0x7e7e)));
}

static void
wlc_idac_read_20691(phy_info_t *pi, int16 *i, int16 *q)
{
	int16 i1, q1;

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));

	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 0x0);

	if (ACREV_GE(pi->pubpi.phy_rev, 13))
		wlc_enable_lna_dcc_comp_20691(pi, 0);
	OSL_DELAY(2);

	i1 = READ_PHYREG(pi, TIA_offset_DAC_I);

	if (i1 > 255)
		i1 = 256 - i1;

	q1 = READ_PHYREG(pi, TIA_offset_DAC_Q);

	if (q1 > 255)
		q1 = 256 - q1;

	*i = i1;
	*q = q1;

	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 0x1);

	if (ACREV_GE(pi->pubpi.phy_rev, 13))
		wlc_enable_lna_dcc_comp_20691(pi, PHY_ILNA(pi));
}

static void
wlc_idac_preload_20691(phy_info_t *pi, int16 i, int16 q)
{
	uint16 cnt;
	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));

	if (i < 0)
		i += 512;
	if (q < 0)
		q += 512;

	i &= 0x1ff;
	q &= 0x1ff;

	/* WAR for negative values -ensure fsm is running */
	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 0x0);
	cnt = READ_PHYREG(pi, rx_tia_dc_loop_gain_5);
	WRITE_PHYREG(pi, rx_tia_dc_loop_gain_5, 15); /* restart gain is 0, ie NOP */
	MOD_PHYREG(pi, rx_tia_dc_loop_0, en_lock, 0); /* always run */
	OSL_DELAY(1);

	/* overide offset comp PU; phyctrl logic not reliable for preload WAR,
	   dac value fails to update occassionally
	*/
	MOD_RADIO_REG_20691(pi, TIA_CFG15, 0, tia_offset_comp_pwrup, 1);
	MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_NORTH, 0, ovr_tia_offset_comp_pwrup, 1);

	/* restart to enable preload WAR for negative value (CRDOT11ACPHY-871) */
	wlc_dcc_fsm_restart(pi);

	/* write the values across */
	WRITE_PHYREG(pi, BfmConfig3, 0x0200 | i);
	WRITE_PHYREG(pi, BfmConfig3, 0x0600 | q);
	WRITE_PHYREG(pi, BfmConfig3, 0x0000);

	/* remove comp pwrup force */
	MOD_RADIO_REG_20691(pi, RX_BB_2G_OVR_NORTH, 0, ovr_tia_offset_comp_pwrup, 0);

	/* stop loop running and restore config */
	MOD_PHYREG(pi, rx_tia_dc_loop_0, en_lock, 1);

	OSL_DELAY(1);

	WRITE_PHYREG(pi, rx_tia_dc_loop_gain_5, cnt);

	MOD_PHYREG(pi, RfseqTrigger, en_pkt_proc_dcc_ctrl, 0x1);
}

/* Based on: proc 20691_dcc_reset {  } */
static void
wlc_dcc_fsm_reset(phy_info_t *pi)
{
	uint16 sparereg = READ_PHYREG(pi, SpareReg);

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));
	WRITE_PHYREG(pi, SpareReg,  sparereg | 0x8000);
	WRITE_PHYREG(pi, SpareReg,  sparereg & 0x7fff);
	OSL_DELAY(10);	/* Wait for FSM to finish. NB: depends on total dcc_loop_count_XX */
}

/* Based on: proc 20691_dcc_restart {  } */
static void
wlc_dcc_fsm_restart(phy_info_t *pi)
{
	uint16 sparereg = READ_PHYREG(pi, SpareReg);

	ASSERT(ACREV_GE(pi->pubpi.phy_rev, 11));
	WRITE_PHYREG(pi, SpareReg,  sparereg | 0x4000);
	WRITE_PHYREG(pi, SpareReg,  sparereg & 0xbfff);
}

/* Set up rx2tx rfseq tables differently for cal vs. packets for tiny */
/* to avoid problems with AGC lock-up */
static void
wlc_phy_tiny_rfseq_mode_set(phy_info_t *pi, bool cal_mode)
{
	if (cal_mode) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00,
			16, rfseq_rx2tx_cmd);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 112, 16,
			rfseq_rx2tx_dly);
	} else {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 0x00, 16,
			tiny_rfseq_rx2tx_cmd);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, 112, 16,
			tiny_rfseq_rx2tx_dly);
	}
}

#if defined(WLTEST)
void
wlc_phy_force_vcocal_acphy(phy_info_t *pi)
{
	/* IOVAR call */
	if (RADIOID(pi->pubpi.radioid) == BCM20691_ID)
		wlc_phy_radio20691_vcocal(pi);
	else if (RADIOID(pi->pubpi.radioid) == BCM20693_ID)
		wlc_phy_radio20693_vcocal(pi);
	else
		wlc_phy_radio2069_vcocal(pi);
}
#endif // endif

void
wlc_phy_set_trloss_reg_acphy(phy_info_t *pi, int8 core)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint8 boardloss = 2, trt, trr;
	int8 rssi_tr_offset = 0;
	int8  bw_idx, subband_idx;
	uint16 intc, mask = ACPHY_RfctrlIntc0_override_tr_sw_MASK(rev) |
	        ACPHY_RfctrlIntc0_tr_sw_tx_pu_MASK(rev) | ACPHY_RfctrlIntc0_tr_sw_rx_pu_MASK(rev);

	bw_idx = (CHSPEC_IS80(pi->radio_chanspec)) ? 2 :
	        (CHSPEC_IS40(pi->radio_chanspec)) ? 1 : 0;

	if (pi_ac->rssi_cal_rev == FALSE) {
		subband_idx = wlc_phy_get_chan_freq_range_acphy(pi,
		  CHSPEC_CHANNEL(pi->radio_chanspec))-1;
	} else {
		subband_idx = wlc_phy_rssi_get_chan_freq_range_acphy(pi,
		  CHSPEC_CHANNEL(pi->radio_chanspec));
	}
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
	  if (pi->u.pi_acphy->rssi_cal_rev == FALSE) {
	    rssi_tr_offset =
	      pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g[core]
	        [ACPHY_GAIN_DELTA_ELNA_OFF][bw_idx]-
	        pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g[core]
	        [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx];
	  } else {
	    rssi_tr_offset =
	      pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g_sub
	        [core][ACPHY_GAIN_DELTA_ELNA_OFF][bw_idx][subband_idx]-
	        pi_ac->srom.rssioffset.rssi_corr_gain_delta_2g_sub
	        [core][ACPHY_GAIN_DELTA_ELNA_ON][bw_idx][subband_idx];
	  }
	} else {
	  if (pi->u.pi_acphy->rssi_cal_rev == FALSE) {
	    rssi_tr_offset =
	      pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g[core]
	        [ACPHY_GAIN_DELTA_ELNA_OFF][bw_idx][subband_idx]-
	        pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g[core]
	        [ACPHY_GAIN_DELTA_ELNA_ON][bw_idx][subband_idx];
	  } else {
	    rssi_tr_offset =
	      pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g_sub
	        [core][ACPHY_GAIN_DELTA_ELNA_OFF][bw_idx][subband_idx]-
	        pi_ac->srom.rssioffset.rssi_corr_gain_delta_5g_sub
	        [core][ACPHY_GAIN_DELTA_ELNA_ON][bw_idx][subband_idx];
	  }
	}
	if (pi->u.pi_acphy->rssi_cal_rev == TRUE) {

	  int16 gain_err_temp_adj = 0;

	  if ((pi->u.pi_acphy->srom.apply_trloss_comp_wrt_temp == TRUE) &&
	      (pi->u.pi_acphy->temp_comp_tr_loss == TRUE)) {
	    int16 temp_diff, curr_temp = 0;
	    int16 gain_temp_slope_delta = 0;
	    curr_temp = pi->u.pi_acphy->current_temperature;

	    curr_temp = MIN(MAX(curr_temp, PHY_TEMPSENSE_MIN_RSSI_CAL_REV_1), PHY_TEMPSENSE_MAX);

	    /* check that non programmed SROM for cal temp are not changed */
	    if (pi->srom_gain_cal_temp != 255) {
	      temp_diff = curr_temp - pi->srom_gain_cal_temp;
	    } else {
	      temp_diff = 0;
	    }

	    /* adjust gain based on the temperature difference now vs. calibration time:
	     * make gain diff rounded to nearest 0.25 dbm, where 1 tick is 0.25 dbm
	     */

	    if (CHSPEC_IS2G(pi->radio_chanspec)) {
	      gain_temp_slope_delta =
	      pi->u.pi_acphy->srom.rxgain_tempadj_2g_sub_elnaoff[core][subband_idx] -
	      pi->u.pi_acphy->srom.rxgain_tempadj_2g_sub[core][subband_idx];
	    } else {
	      if (subband_idx == 0) {
		gain_temp_slope_delta =
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gl_elnaoff[core] -
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gl[core];
	      } else if (subband_idx == 1) {
		gain_temp_slope_delta =
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gml_elnaoff[core] -
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gml[core];
	      } else if (subband_idx == 2) {
		gain_temp_slope_delta =
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gmu_elnaoff[core] -
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gmu[core];
	      } else if (subband_idx == 3) {
		gain_temp_slope_delta =
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gh_elnaoff[core] -
		  pi->u.pi_acphy->srom.rxgain_tempadj_5gh[core];
	      }
	    }

	    if ((temp_diff * gain_temp_slope_delta) >= 0) {
	      gain_err_temp_adj = (temp_diff * gain_temp_slope_delta*2 + 250)/500;
	    } else {
	      gain_err_temp_adj = (temp_diff * gain_temp_slope_delta*2 - 250)/500;
	    }

	    pi->u.pi_acphy->srom.trloss_comp_wrt_temp_applied = TRUE;
		pi->u.pi_acphy->srom.last_trloss_adj_temp = curr_temp;

	  } else {
	    pi->u.pi_acphy->srom.trloss_comp_wrt_temp_applied = FALSE;
	  }

	  rssi_tr_offset += gain_err_temp_adj;
	  /* With new scheme, rssi gain delta's are in qdB steps */
	  rssi_tr_offset = (rssi_tr_offset + 2) >> 2;

	}

	/* adjust TRLoss with rssi cal param */
	trr = boardloss;
	trt = pi_ac->fem_rxgains[core].trloss + rssi_tr_offset;

	/* Not sure why all 4335 boards don't need boardloss = 2 (chip default) */
	if (ACMAJORREV_0(pi->pubpi.phy_rev) ||
	    ACMAJORREV_2(pi->pubpi.phy_rev) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev) ||
	    (ACMAJORREV_1(pi->pubpi.phy_rev) &&
	     ACMINORREV_2(pi->pubpi.phy_rev) && PHY_ILNA(pi)))
		trt += boardloss;

	/* Clear up RfctrlIntc override (as uCode might have set it for hirssi_elnabypass */
	if (PHY_SW_HIRSSI_UCODE_CAP(pi)) {
		intc = phy_reg_read(pi, ACPHYREGCE(pi, RfctrlIntc, core)) & (~mask);
		phy_reg_write(pi, ACPHYREGCE(pi, RfctrlIntc, core), intc);
	}

	switch (core) {
	case 0 :
		if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			/* adjust TRLoss with rssi cal param */
			MOD_PHYREG(pi, TRLossValue, freqGainTLoss, trt);
			MOD_PHYREG(pi, TRLossValue, freqGainRLoss, trr);
		} else {
			MOD_PHYREG(pi, Core0_TRLossValue, freqGainTLoss0, trt);
			MOD_PHYREG(pi, Core0_TRLossValue, freqGainRLoss0, trr);
		}
		break;
	case 1:
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 1 &&
		    ACREV_GT(pi->pubpi.phy_rev, 0)) {
			/* adjust TRLoss with rssi cal param */
			MOD_PHYREG(pi, Core1_TRLossValue, freqGainTLoss1, trt);
			MOD_PHYREG(pi, Core1_TRLossValue, freqGainRLoss1, trr);
		}
		break;
	case 2:
		if (PHYCORENUM(pi->pubpi.phy_corenum) > 2 &&
		    ACREV_GT(pi->pubpi.phy_rev, 0)) {
			/* adjust TRLoss with rssi cal param */
			MOD_PHYREG(pi, Core2_TRLossValue, freqGainTLoss2, trt);
			MOD_PHYREG(pi, Core2_TRLossValue, freqGainRLoss2, trr);
		}
		break;
	default:
		break;
	}
}

static void
wlc_phy_dac_rate_mode_acphy(phy_info_t *pi, uint8 dac_rate_mode)
{
	uint8 bw_idx = 0;
	uint16 dac_rate = 200;

	bw_idx = CHSPEC_IS20(pi->radio_chanspec)? 0 : (CHSPEC_IS40(pi->radio_chanspec)? 1 : 2);

	MOD_PHYREG(pi, Logen_AfeDiv_reset_select, use_hw_afeclk_reset, 0x0);

	switch (bw_idx) {
	case 0:
		switch (dac_rate_mode) {
			case 2:
				dac_rate = 600;
				break;
			case 3:
				dac_rate = 400;
				break;
			default: /* dac rate mode 1 */
				dac_rate = 200;
				break;
		}
		break;
	case 1:
		switch (dac_rate_mode) {
			case 2:
				dac_rate = 600;
				break;
			default: /* dac rate mode 1 and 3 */
				dac_rate = 400;
				break;
		}
		break;
	case 2:
		dac_rate = 600;
		break;
	default:
		PHY_ERROR(("Unsupported bandwidth\n"));
		ASSERT(0);
		break;
	}
	pi->u.pi_acphy->dac_rate = dac_rate;

	/* Stall AFE clocks to PHY */
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 1)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, disable_stalls, 1)
		WRITE_PHYREG_ENTRY(pi, sdfeClkGatingCtrl, 0xE)
		MOD_PHYREG_ENTRY(pi, fineclockgatecontrol, forceAfeClocksOff, 0x1)
	ACPHY_REG_LIST_EXECUTE(pi)

	if (dac_rate_mode == 2) {
		si_core_cflags(pi->sh->sih, 0x300, 0x200);
	} else if (dac_rate_mode == 3) {
		si_core_cflags(pi->sh->sih, 0x300, 0x300);
	} else {
		si_core_cflags(pi->sh->sih, 0x300, 0x100);
	}

	/* Restore AFE clocks to PHY */
	ACPHY_REG_LIST_START
		MOD_PHYREG_ENTRY(pi, fineclockgatecontrol, forceAfeClocksOff, 0)
		WRITE_PHYREG_ENTRY(pi, sdfeClkGatingCtrl, 0x0)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, soft_sdfeFifoReset, 0)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, disable_stalls, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	if (TINY_RADIO(pi)) {
		switch (dac_rate) {
			case 200:
				MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, sel_dac_div,
				(((pi->vcodivmode & 0x1) && (CHSPEC_IS2G(pi->radio_chanspec))) ||
				((pi->vcodivmode & 0x2) && (CHSPEC_IS5G(pi->radio_chanspec))))
				? 3 : 4);
				break;
			case 400:
				MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, sel_dac_div,
				((pi->vcodivmode & 0x4) && (CHSPEC_IS5G(pi->radio_chanspec)) &&
				(pi->u.pi_acphy->logenmode43 == 0))
				? 1 : 2);
				break;
			case 600:
				MOD_RADIO_REG_20691(pi, CLK_DIV_CFG1, 0, sel_dac_div, 0);
				break;
			default:
				PHY_ERROR(("Unsupported dac_rate %d\n", dac_rate));
				ASSERT(0);
				break;
		}

	    if ((dac_rate_mode == 1) || (bw_idx == 2)) {
		    MOD_PHYREG(pi, sdfeClkGatingCtrl, txlbclkmode_ovr, 0);
	    } else {
		    MOD_PHYREG(pi, sdfeClkGatingCtrl, txlbclkmode_ovr, 1);
		    if (bw_idx == 1)
			    MOD_PHYREG(pi, sdfeClkGatingCtrl, txlbclkmode_ovr_value, 2);
		    else
			    MOD_PHYREG(pi, sdfeClkGatingCtrl, txlbclkmode_ovr_value, 1);
	    }

		wlc_phy_farrow_setup_tiny(pi, pi->radio_chanspec);
	} else {
		wlc_phy_farrow_setup_acphy(pi, pi->radio_chanspec);
	}
}

/* ******************  HIRSSI ELNABYPASS (uCode supported). Begin ****************** */
void
wlc_phy_hirssi_elnabypass_init_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	pi_ac->hirssi_timer2g = PHY_SW_HIRSSI_OFF;
	pi_ac->hirssi_timer5g = PHY_SW_HIRSSI_OFF;

	if (PHY_SW_HIRSSI_UCODE_CAP(pi)) {
		pi_ac->hirssi_elnabyp2g_en = pi_ac->hirssi_en;
		pi_ac->hirssi_elnabyp5g_en = pi_ac->hirssi_en;
		if (pi->sh->clk) {
			wlc_phy_hirssi_elnabypass_set_ucode_params_acphy(pi);
			wlapi_bmac_write_shm(pi->sh->physhim, M_HIRSSI_FLAG, 0);
		}
	} else {
		pi_ac->hirssi_elnabyp2g_en = FALSE;
		pi_ac->hirssi_elnabyp5g_en = FALSE;
	}
}

void
wlc_phy_hirssi_elnabypass_engine(phy_info_t *pi)
{
	int16 timer;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool ucode_hirssi, upd = FALSE;

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		timer = pi_ac->hirssi_timer2g;
		pi_ac->hirssi_timer5g = MAX(pi_ac->hirssi_timer5g - 1, PHY_SW_HIRSSI_OFF);
		if (!pi_ac->hirssi_elnabyp2g_en) return;
	} else {
		timer = pi_ac->hirssi_timer5g;
		pi_ac->hirssi_timer2g = MAX(pi_ac->hirssi_timer2g - 1, PHY_SW_HIRSSI_OFF);
		if (!pi_ac->hirssi_elnabyp5g_en) return;
	}

	/* Logic */
	if (timer > PHY_SW_HIRSSI_OFF) {
		timer--;
		if (timer == PHY_SW_HIRSSI_OFF) {
			ucode_hirssi = wlc_phy_hirssi_elnabypass_shmem_read_clear_acphy(pi);
			if (ucode_hirssi) {
				PHY_TRACE(("wl%d: %s state:Already ON\n", pi->sh->unit,
				           __FUNCTION__));
				timer = pi_ac->hirssi_period;
			} else  {
				PHY_TRACE(("wl%d: %s state:OFF\n", pi->sh->unit, __FUNCTION__));
				timer = PHY_SW_HIRSSI_OFF;
				upd = TRUE;

			}
		}
	} else {
		ucode_hirssi = wlc_phy_hirssi_elnabypass_shmem_read_clear_acphy(pi);
		if (ucode_hirssi) {
			PHY_TRACE(("wl%d: %s state:ON\n", pi->sh->unit, __FUNCTION__));
			timer = pi_ac->hirssi_period;
			upd = TRUE;
		}
	}

	/* Update Timer */
	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		pi_ac->hirssi_timer2g = timer;
	} else {
		pi_ac->hirssi_timer5g = timer;
	}

	/* Update uCode & apply gainctrl changes */
	if (upd) {
		wlc_phy_hirssi_elnabypass_set_ucode_params_acphy(pi);
		wlc_phy_hirssi_elnabypass_apply_acphy(pi);
	}
}

void
wlc_phy_hirssi_elnabypass_set_ucode_params_acphy(phy_info_t *pi)
{
	int16 hirssi_rssi = 50;
	uint16 hirssi_w1_reg =  PHY_SW_HIRSSI_W1_BYP_REG;
	uint16 hirssi_w1_cnt = 500;
	bool res, en;
	uint8 factor;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (!PHY_SW_HIRSSI_UCODE_CAP(pi)) return;

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		en = pi_ac->hirssi_elnabyp2g_en;
		res = pi_ac->hirssi_timer2g > PHY_SW_HIRSSI_OFF;
	} else {
		en = pi_ac->hirssi_elnabyp5g_en;
		res = pi_ac->hirssi_timer5g > PHY_SW_HIRSSI_OFF;
	}

	if (en) {
		hirssi_rssi = (res) ? pi_ac->hirssi_res_rssi : pi_ac->hirssi_byp_rssi;
		hirssi_w1_reg = (res) ? PHY_SW_HIRSSI_W1_RES_REG : PHY_SW_HIRSSI_W1_BYP_REG;
		hirssi_w1_cnt = (res) ? pi_ac->hirssi_res_cnt : pi_ac->hirssi_byp_cnt;

		factor = CHSPEC_IS20(pi->radio_chanspec) ? 1 :
		        (CHSPEC_IS40(pi->radio_chanspec) ? 2 : 4);
		hirssi_w1_cnt *= factor;
	}

	wlapi_bmac_write_shm(pi->sh->physhim, M_HIRSSI_THR, hirssi_rssi);
	wlapi_bmac_write_shm(pi->sh->physhim, M_PHYREG_WRSSI, hirssi_w1_reg);
	wlapi_bmac_write_shm(pi->sh->physhim, M_WRSSI_THR, hirssi_w1_cnt);
}

void
wlc_phy_hirssi_elnabypass_apply_acphy(phy_info_t *pi)
{
	if (!(pi->sh->clk))
		return;

	wlapi_suspend_mac_and_wait(pi->sh->physhim);

#ifndef WLC_DISABLE_ACI
	if (!ACPHY_ENABLE_FCBS_HWACI(pi)) {
		/* ACI - reset aci for current band & restore defaults */
		wlc_phy_desense_aci_reset_params_acphy(pi, CHSPEC_IS2G(pi->radio_chanspec),
		                                       CHSPEC_IS5G(pi->radio_chanspec));
	}
#endif /* !WLC_DISABLE_ACI */

	/* Set new gainctrl with current aci_off/elna_bypass settings */
	wlc_phy_rxgainctrl_set_gaintbls_acphy(pi, TRUE, TRUE, TRUE);
	wlc_phy_rxgainctrl_gainctrl_acphy(pi);

	wlc_phy_resetcca_acphy(pi);
	wlc_phy_force_rfseq_acphy(pi, ACPHY_RFSEQ_RESET2RX);

	wlapi_enable_mac(pi->sh->physhim);
}

static bool
wlc_phy_hirssi_elnabypass_shmem_read_clear_acphy(phy_info_t *pi)
{
	bool hirssi = FALSE;

	if (PHY_SW_HIRSSI_UCODE_CAP(pi)) {
		hirssi = (wlapi_bmac_read_shm(pi->sh->physhim, M_HIRSSI_FLAG) == 0xdead);
		if (hirssi)
			wlapi_bmac_write_shm(pi->sh->physhim, M_HIRSSI_FLAG, 0);
	}

	return hirssi;
}

bool
wlc_phy_hirssi_elnabypass_status_acphy(phy_info_t *pi)
{
	bool status;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (CHSPEC_IS2G(pi->radio_chanspec))
		status = pi_ac->hirssi_timer2g > PHY_SW_HIRSSI_OFF;
	else
		status = pi_ac->hirssi_timer5g > PHY_SW_HIRSSI_OFF;
	if (!pi->sh->clk)
		return status;
	else
		return (status || (wlapi_bmac_read_shm(pi->sh->physhim, M_HIRSSI_FLAG) == 0xdead));
}
/* ******************  HIRSSI ELNABYPASS (uCode supported). End  ****************** */

static void
wlc_phy_wltx_word_get(phy_info_t *pi, uint8 band, uint32 swctrlmap_wltx,
	uint32 swctrlmap_wltx_ext, uint32 *swctrlword,	uint32 *swctrlwordext)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/* If linear, use the lower 16 bits */
	if (pi_ac->pa_mode == PAMODE_HI_LIN) {
		*swctrlword = swctrlmap_wltx & PAMODE_HI_LIN_MASK;
		*swctrlwordext = swctrlmap_wltx_ext & PAMODE_HI_LIN_MASK;
	} else {

		/* Otherwise use the upper 16 bits. */
		*swctrlword = (swctrlmap_wltx & PAMODE_HI_EFF_MASK) >> 16;
		*swctrlwordext = (swctrlmap_wltx_ext & PAMODE_HI_EFF_MASK) >> 16;
	}
}

static void
wlc_txswctrlmap_set_acphy(phy_info_t *pi, int8 pamode_requested)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/*
	 * Populate the right swctrlmap only if the pa_mode requested is different
	 * from the current setting
	 */
	if (pi_ac->pa_mode != pamode_requested) {
		/* Note the new state */
		pi_ac->pa_mode = pamode_requested;

		/* Call this function again to repopulate the switch control table. */
		wlc_phy_write_regtbl_fc_from_nvram(pi);
	}
}

static int8
wlc_txswctrlmap_get_acphy(phy_info_t *pi)
{
	return pi->u.pi_acphy->pa_mode;
}

#if defined(WLTEST)
static void
wlc_swctrlmap_set_acphy(phy_info_t *pi, uint32 swctrlmap_entry, uint32 swctrlmap_mask)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/*
	 * Populate the swctrlmap to the one desired
	 */
	/* Note the new state */
	pi_ac->swctrlmap_entry = swctrlmap_entry;
	pi_ac->swctrlmap_mask = swctrlmap_mask;

	/* Call this function again to repopulate the switch control table. */
	wlc_phy_write_regtbl_fc_from_nvram(pi);
}

static void
wlc_swctrlmap_get_acphy(phy_info_t *pi, uint32 *swctrlmap_params)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	swctrlmap_params[0] = pi_ac->swctrlmap_entry;
	swctrlmap_params[1] = pi_ac->swctrlmap_mask;
	return;
}
#endif // endif

void
wlc_phy_btc_adjust_acphy(phy_info_t *pi, bool btactive)
{
	if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
	  wlapi_suspend_mac_and_wait(pi->sh->physhim);
	  wlc_phy_mlua_adjust_acphy(pi, btactive);
	  wlapi_enable_mac(pi->sh->physhim);
	}
}

static void
wlc_phy_mlua_adjust_acphy(phy_info_t *pi, bool btactive)
{
	uint8 zfuA1, zfuA1_log2, zfuA2, zfuA2_log2, zfuA0, zfuA3;
	uint8 mluA1, mluA1_log2, mluA2, mluA2_log2, mluA0, mluA3;

	/* Disable this for now, there is some issue with BTcoex */
	if (btactive) {
		mluA1 = 2; mluA1_log2 = 1; mluA2 = 0; mluA2_log2 = 0;
		zfuA1 = 2; zfuA1_log2 = 1; zfuA2 = 2; zfuA2_log2 = 1;
	} else {
		mluA1 = 4; mluA1_log2 = 2; mluA2 = 4; mluA2_log2 = 2;
		zfuA1 = 4; zfuA1_log2 = 2; zfuA2 = 4; zfuA2_log2 = 2;
		if ((CHIPID(pi->sh->chip) == BCM43566_CHIP_ID) ||
		    (CHIPID(pi->sh->chip) == BCM43567_CHIP_ID) ||
		    (CHIPID(pi->sh->chip) == BCM43569_CHIP_ID) ||
		    (CHIPID(pi->sh->chip) == BCM43570_CHIP_ID)) {
			/* see http://confluence.broadcom.com/x/AljxEQ */
			mluA2_log2 = 3;
			mluA1_log2 = 3;
		}
	}
	/* align 43602 mluA0/3 and zfmuA0/3 to be the same as 4360 */
	mluA0 = 4; mluA3 = 2; zfuA0 = 4; zfuA3 = 2;
	/* Increase Channel Update ML mu */
	if ((ACMAJORREV_0(pi->pubpi.phy_rev) && (ACMINORREV_0(pi->pubpi.phy_rev) ||
	                                        ACMINORREV_1(pi->pubpi.phy_rev))) ||
	    ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* 4360 a0,b0 43602 */
		MOD_PHYREG(pi, mluA, mluA1, mluA1);
		MOD_PHYREG(pi, mluA, mluA2, mluA2);
		/* zfuA register used to update channel for 256 QAM */
		MOD_PHYREG(pi, zfuA, zfuA1, zfuA1);
		MOD_PHYREG(pi, zfuA, zfuA2, zfuA2);
		/* 43602 */
		if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
			MOD_PHYREG(pi, mluA, mluA0, mluA0);
			MOD_PHYREG(pi, mluA, mluA3, mluA3);
			/* zfuA register used to update channel for 256 QAM */
			MOD_PHYREG(pi, zfuA, zfuA0, zfuA0);
			MOD_PHYREG(pi, zfuA, zfuA3, zfuA3);
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		/* 4350 a0,b0 (log domain) */
		MOD_PHYREG(pi, mluA, mluA1, mluA1_log2);
		MOD_PHYREG(pi, mluA, mluA2, mluA2_log2);
		/* zfuA register used to update channel for 256 QAM */
		MOD_PHYREG(pi, zfuA, zfuA1, zfuA1_log2);
		MOD_PHYREG(pi, zfuA, zfuA2, zfuA2_log2);
	} else {
	}
}

void
wlc_phy_stop_bt_toggle_acphy(phy_info_t *pi)
{
	uint8 phyrxchain = pi->sh->phyrxchain;
	uint8 phytxchain = pi->sh->phytxchain;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	int8 shared_ant_mask;
	if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL_FEM_BT) {
	  if (BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) & BFL2_BT_SHARE_ANT0)
	    shared_ant_mask = 1; /* 2 chain devices with first core shared */
	  else
	    shared_ant_mask = 2; /* 3 chain devices with middle core shared */
	} else
	  return;

	if (pi_ac->bt_sw_state == AUTO) {
	wlc_phyreg_enter((wlc_phy_t *)pi);
	  if (((phytxchain & shared_ant_mask) == 0) && ((shared_ant_mask & phyrxchain) == 0)) {
	    wlc_phy_set_femctrl_bt_wlan_ovrd_acphy(pi, 1);
	    /* forced bt switch to BT side instead of toggling */
	  } else
	    wlc_phy_set_femctrl_bt_wlan_ovrd_acphy(pi, AUTO);
	wlc_phyreg_exit((wlc_phy_t *)pi);
	}
}

int16
wlc_phy_calc_adjusted_cap_rgstr_acphy(phy_info_t *pi, uint8 core)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

#ifdef WL_SARLIMIT
	return MIN(pi->sarlimit[core], pi->tx_power_max_per_core[core] + pi_ac->txpwr_offset[core]);
#else
	return pi->tx_power_max_per_core[core] + pi_ac->txpwr_offset[core];
#endif // endif
}

#ifdef ATE_BUILD
void
wlc_phy_gpaio_acphy(phy_info_t *pi, wl_gpaio_option_t option)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20691_ID);

	/* To bring out various radio test signals on gpaio. */
	if (option == GPAIO_PMU_CLEAR)
	    MOD_RADIO_REG_20691(pi, GPAIO_SEL0, 0, gpaio_sel_0to15_port, (0x1 << 0));
	else
	    MOD_RADIO_REG_20691(pi, GPAIO_SEL0, 0, gpaio_sel_0to15_port, (0x1 << 14));

	MOD_RADIO_REG_20691(pi, GPAIO_SEL1, 0, gpaio_sel_16to31_port, 0x0);
	switch (option) {
		case (GPAIO_PMU_AFELDO): {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x01);
			MOD_RADIO_REG_20691(pi, PMU_CFG1, 0, wlpmu_ana_mux, 0x00);
			break;
		}
		case (GPAIO_PMU_TXLDO): {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x01);
			MOD_RADIO_REG_20691(pi, PMU_CFG1, 0, wlpmu_ana_mux, 0x01);
			break;
		}
		case (GPAIO_PMU_VCOLDO): {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x01);
			MOD_RADIO_REG_20691(pi, PMU_CFG1, 0, wlpmu_ana_mux, 0x02);
			break;
		}
		case GPAIO_PMU_LNALDO: {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x01);
			MOD_RADIO_REG_20691(pi, PMU_CFG1, 0, wlpmu_ana_mux, 0x03);
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_ana_mux_high, 0x00);
			break;
		}
		case GPAIO_PMU_ADCLDO: {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x01);
			MOD_RADIO_REG_20691(pi, PMU_CFG1, 0, wlpmu_ana_mux, 0x03);
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_ana_mux_high, 0x01);
			break;
		}
		case GPAIO_PMU_CLEAR: {
			MOD_RADIO_REG_20691(pi, PMU_CFG3, 0, wlpmu_tsten, 0x00);
			break;
		}
		default:
			break;
	}
}
#endif /* ATE_BUILD */

static void
BCMATTACHFN(wlc_phy_std_params_attach_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	uint8 i, core;
	uint8 gain_len[] = {2, 6, 7, 10, 8, 8, 11}; /* elna, lna1, lna2, mix, bq0, bq1, dvga */

	if (TINY_RADIO(pi)) {
		gain_len[3] = 12; /* tia */
		gain_len[5] = 3;  /* farrow */
	}

	pi->phy_cal_mode = PHY_PERICAL_MPHASE;
	pi->phy_cal_delay = PHY_PERICAL_DELAY_DEFAULT;
	pi->phy_scraminit = AUTO;
	pi_ac->init = FALSE;
#if defined(BCMDBG)
	pi_ac->fdiqi.forced = FALSE;
	pi_ac->fdiqi.forced_val = 0;
#endif // endif
	pi_ac->curr_band2g = CHSPEC_IS2G(pi->radio_chanspec);
	pi_ac->band2g_init_done = FALSE;
	pi_ac->band5g_init_done = FALSE;
	pi_ac->prev_subband = 15;
	pi_ac->curr_bw = CHSPEC_BW(pi->radio_chanspec);
	pi_ac->curr_spurmode = 0;
	pi_ac->btswitch = AUTO;

	if (CHIPID(pi->sh->chip) == BCM4335_CHIP_ID) {
		if (pi->sh->chippkg == BCM4335_WLBGA_PKG_ID) {
			pi_ac->curr_spurmode = 8;
			pi->acphy_spuravoid_mode = 8;
		} else {
			/* for WLCSP packages */
			if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
				/* for 4335 Cx Chips */
				pi_ac->curr_spurmode = 8;
				pi->acphy_spuravoid_mode = 8;
			} else {
				/* for 4335 Ax/Bx Chips */
				pi_ac->curr_spurmode = 2;
				pi->acphy_spuravoid_mode = 2;
			}
		}
		if (PHY_XTAL_IS52M(pi)) {
			pi_ac->curr_spurmode = 0;
			pi->acphy_spuravoid_mode = 0;
		}
	}
	pi->acphy_spuravoid_mode_override = 0;

	pi_ac->dac_mode = 1;
	pi_ac->dac_rate = 200;
	pi_ac->logenmode43 = 0;
	pi_ac->rccal_gmult = 128;
	pi_ac->rccal_gmult_rc = 128;
	pi_ac->rccal_dacbuf = 12;
	pi_ac->txcal_cache_cookie = 0;
	pi_ac->poll_adc_WAR = FALSE;
	pi_ac->crsmincal_enable = TRUE;
	pi_ac->force_crsmincal  = FALSE;
	pi_ac->crsmincal_run = 0;
	pi_ac->srom.elna2g_present = FALSE;
	pi_ac->srom.elna5g_present = FALSE;
	pi_ac->acphy_lp_mode = 1;
	pi_ac->acphy_prev_lp_mode = pi_ac->acphy_lp_mode;
	pi_ac->acphy_lp_status = pi_ac->acphy_lp_mode;
	pi_ac->acphy_enable_smth = SMTH_ENABLE;
	pi_ac->ant_swOvr_state_core0 = 2;
	pi_ac->ant_swOvr_state_core1 = 2;
	/* 4345 has only one antenna on core 0.
	 * Set this for txpwr capping to work properly
	*/
	if (CHIPID(pi->sh->chip) == BCM4345_CHIP_ID)
		pi_ac->ant_swOvr_state_core0 = 0;
	pi_ac->acphy_smth_dump_mode = SMTH_NODUMP;

	pi_ac->acphy_4335_radio_pd_status = 0;
	pi_ac->phy_crs_th_from_crs_cal = ACPHY_CRSMIN_DEFAULT;
	/* AFE */
	pi_ac->afeRfctrlCoreAfeCfg10 = READ_PHYREG(pi, RfctrlCoreAfeCfg10);
	pi_ac->afeRfctrlCoreAfeCfg20 = READ_PHYREG(pi, RfctrlCoreAfeCfg20);
	pi_ac->afeRfctrlOverrideAfeCfg0 = READ_PHYREG(pi, RfctrlOverrideAfeCfg0);
	/* Radio RX */
	pi_ac->rxRfctrlCoreRxPus0 = READ_PHYREG(pi, RfctrlCoreRxPus0);
	pi_ac->rxRfctrlOverrideRxPus0 = READ_PHYREG(pi, RfctrlOverrideRxPus0);
	/* Radio TX */
	pi_ac->txRfctrlCoreTxPus0 = READ_PHYREG(pi, RfctrlCoreTxPus0);
	pi_ac->txRfctrlOverrideTxPus0 = READ_PHYREG(pi, RfctrlOverrideTxPus0);
	/* {radio, rfpll, pllldo}_pu = 0 */
	pi_ac->radioRfctrlCmd = READ_PHYREG(pi, RfctrlCmd);
	pi_ac->radioRfctrlCoreGlobalPus = READ_PHYREG(pi, RfctrlCoreGlobalPus);
	pi_ac->radioRfctrlOverrideGlobalPus = READ_PHYREG(pi, RfctrlOverrideGlobalPus);
	/* read chipid */
#ifndef BCMCHIPID
	/* Used to select correct radio offsets based on chipid */
	acphychipid = pi->sh->chip;
#endif // endif
	/* pre_init to ON, register POR default setting */
	pi_ac->ac_rxldpc_override = ON;
	/* RSSI reg reporintg only happens for one core at a time */
	pi_ac->rssi_coresel = 0;
	/* ucode hirssi detect - bypass lna1 to save it */
	pi_ac->hirssi_en = 0; /* ACMAJORREV_0(pi->pubpi.phy_rev); */
	pi_ac->hirssi_period = PHY_SW_HIRSSI_PERIOD;
	pi_ac->hirssi_byp_rssi = PHY_SW_HIRSSI_BYP_THR;
	pi_ac->hirssi_res_rssi = PHY_SW_HIRSSI_RES_THR;
	pi_ac->hirssi_byp_cnt = PHY_SW_HIRSSI_W1_BYP_CNT;
	pi_ac->hirssi_res_cnt = PHY_SW_HIRSSI_W1_RES_CNT;

	/* J28 have attenuators, so don't use hirssi feature there */
	if (pi->sh->boardvendor == VENDOR_APPLE &&
	    ((pi->sh->boardtype == BCM94360J28_D11AC2G) ||
	     (pi->sh->boardtype == BCM94360J28_D11AC5G))) {
		pi_ac->hirssi_en = FALSE;
	}
	if (!ACMAJORREV_3(pi->pubpi.phy_rev)) {
		/* Only supported in ucode for mac revid 40 and 42 */
		wlc_phy_hirssi_elnabypass_init_acphy(pi);
	}

	pi->n_preamble_override = WLC_N_PREAMBLE_MIXEDMODE;

	/* RX-IQ-CAL per core */
	pi_ac->rxiqcal_percore_2g = FALSE;
	pi_ac->rxiqcal_percore_5g = TRUE;
	/* default clip1_th & edcrs_en */
	pi_ac->clip1_th = 0x404e;
	pi_ac->edcrs_en = 0xfff;

	/* Get xtal frequency from PMU */
#if !defined(XTAL_FREQ)
	pi->xtalfreq = si_alp_clock(pi->sh->sih);
#endif // endif
	ASSERT((PHY_XTALFREQ(pi->xtalfreq) % 1000) == 0);
	PHY_INFORM(("wl%d: %s: using %d.%d MHz xtalfreq for RF PLL\n",
		pi->sh->unit, __FUNCTION__,
		PHY_XTALFREQ(pi->xtalfreq) / 1000000, PHY_XTALFREQ(pi->xtalfreq) % 1000000));

	FOREACH_CORE(pi, core) {
		pi_ac->txpwrindex_hw_save[core] = 128;
		if (TINY_RADIO(pi)) {
			pi_ac->txpwrindex_cck_hw_save[core] = 128;
		}
	}
	for (i = 0; i < ACPHY_MAX_RX_GAIN_STAGES; i++)
		pi_ac->rxgainctrl_stage_len[i] = gain_len[i];

	bzero((uint8 *)pi_ac->phy_noise_pwr_array, sizeof(pi_ac->phy_noise_pwr_array));
	bzero((uint8 *)pi_ac->phy_noise_in_crs_min, sizeof(pi_ac->phy_noise_in_crs_min));

	pi_ac->phy_debug_crscal_counter = 0;
	pi_ac->phy_debug_crscal_channel = 0;
	pi_ac->phy_noise_counter = 0;

	if (ACMAJORREV_0(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		uint8 subband_num;
		for (subband_num = 0; subband_num <= 4; subband_num++) {
		  FOREACH_CORE(pi, core) {
				pi_ac->phy_noise_cache_crsmin[subband_num][core] = -30;
		  }
		}
	} else {
		FOREACH_CORE(pi, core) {
		  pi_ac->phy_noise_cache_crsmin[0][core] = -30;
		  /*
		     Global variable pi_ac->srom.elna5g_present is not initialized when this
		     function is called. Hence using local variable elna5g_present
		  */
		  if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		    pi_ac->phy_noise_cache_crsmin[1][core] = -32;
		    pi_ac->phy_noise_cache_crsmin[2][core] = -32;
		    pi_ac->phy_noise_cache_crsmin[3][core] = -31;
		    pi_ac->phy_noise_cache_crsmin[4][core] = -31;

		  } else {
		    pi_ac->phy_noise_cache_crsmin[1][core] = -28;
		    pi_ac->phy_noise_cache_crsmin[2][core] = -28;
		    pi_ac->phy_noise_cache_crsmin[3][core] = -26;
		    pi_ac->phy_noise_cache_crsmin[4][core] = -25;
		  }
		}
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev))
		pi_ac->acphy_force_lpvco_2G = 1; /* Enable 2G LP mode */
	else
		pi_ac->acphy_force_lpvco_2G = 0;
	pi_ac->pktabortctl = 0;
}

static void
BCMATTACHFN(wlc_phy_nvram_attach_acphy)(phy_info_t *pi)
{
	uint8 i;
	uint32 bfl3; /* boardflags3 */
#ifdef SROM12
	uint32 bfl4; /* boardflags4 */
#endif /* SROM12 */
	uint8 papdtempcomp_tempdelta;

	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	pi->sh->rpcal2g = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_rpcal2g, 0);
	pi->sh->rpcal5gb0 = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_rpcal5gb0, 0);
	pi->sh->rpcal5gb1 = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_rpcal5gb1, 0);
	pi->sh->rpcal5gb2 = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_rpcal5gb2, 0);
	pi->sh->rpcal5gb3 = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_rpcal5gb3, 0);
	pi->sh->txidxcap2g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_txidxcap2g, 0);
	pi->sh->txidxcap5g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_txidxcap5g, 0);
	pi->sh->epagain2g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_epagain2g, 0);
	pi->sh->epagain5g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_epagain5g, 0);
	pi->sh->extpagain2g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_extpagain2g, 0);
	pi->sh->extpagain5g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_extpagain5g, 0);
	pi->sh->ofdmfilttype = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_ofdmfilttype, 0);

	pi->sh->subband5Gver =
		(uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_subband5gver, PHY_SUBBAND_4BAND);

	pi->ipa2g_on = (pi->sh->extpagain2g == 2);
	pi->ipa5g_on = (pi->sh->extpagain5g == 2);

	/* update txpwr settings */
	wlc_phy_txpower_ipa_upd(pi);

	pi->bphy_scale = (uint16) (PHY_GETINTVAR_DEFAULT(pi, rstr_bphyscale, 0));
	pi->fdss_interp_en = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_fdss_interp_en, 1));
	for (i = 0; i < 2; i++) {
		pi->dacratemode2g[i] = (uint8) (PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_dacratemode2g, i, 1));
		pi->dacratemode5g[i] = (uint8) (PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_dacratemode5g, i, 1));
		pi->fdss_level_2g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_fdss_level_2g, i, -1));
		pi->fdss_level_5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT(pi,
			rstr_fdss_level_5g, i, -1));
	}

	if ((RADIOID(pi->pubpi.radioid) == BCM2069_ID) && ((RADIOREV(pi->pubpi.radiorev) == 4) ||
		(RADIOREV(pi->pubpi.radiorev) == 8) || (RADIOREV(pi->pubpi.radiorev) == 10) ||
	    (RADIOREV(pi->pubpi.radiorev) == 11) || (RADIOREV(pi->pubpi.radiorev) == 7))) {
		pi->init_tx_idx_2g = 20;
		pi->init_tx_idx_5g = 20;
	} else if (((RADIOREV(pi->pubpi.radiorev) == 40) && (PHY_XTAL_IS40M(pi))) ||
		(RADIOREV(pi->pubpi.radiorev) == 44)) {
		/* 4358a1, 43569/43570 */
		pi->init_tx_idx_2g = 10;
		pi->init_tx_idx_5g = 10;
	} else if (TINY_RADIO(pi)) {
		pi->init_tx_idx_2g = 64;
		pi->init_tx_idx_5g = 76;
	} else {
		pi->init_tx_idx_2g = 50;
		pi->init_tx_idx_5g = 50;
	}
	pi->init_tx_idx_2g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_initxidx2g,
		pi->init_tx_idx_2g));
	pi->init_tx_idx_5g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_initxidx5g,
		pi->init_tx_idx_5g));

	pi->vcodivmode = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_vcodivmode, 0));
	pi->epacal2g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_epacal2g, 0));
	pi->epacal5g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_epacal5g, 0));
	pi->itrsw = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_itrsw, 0));
	pi->pacal2g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacal2g, 1));
	pi->pacal5g = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacal5g, 1));
	pi->epacal2g_mask = (uint16) (PHY_GETINTVAR_DEFAULT(pi, rstr_epacal2g_mask, 0x3fff));
	pi->afewar40 = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_afewar40, 0));

	/* For 4345 */
	for (i = 0; i < 3; i++) {
		pi->pacalshift2g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_pacalshift2g, i, 0));
		pi->pacalshift5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_pacalshift5g, i, 0));
	}
	/* For 4350 */
	for (i = 0; i < 12; i++) {
		pi->pacalshift5ga0[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_pacalshift5ga0, i, 0));
		pi->pacalshift5ga1[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_pacalshift5ga1, i, 0));
	}
	pi->pacalshift2ga0 = (int8) (PHY_GETINTVAR_DEFAULT
		(pi, rstr_pacalshift2ga0, 0));
	pi->pacalshift2ga1 = (int8) (PHY_GETINTVAR_DEFAULT
		(pi, rstr_pacalshift2ga1, 0));
	pi->pacalindex2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacalindex2g, -1));
	for (i = 0; i < 3; i++) {
		pi->pacalindex5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_pacalindex5g, i, -1));
	}

	pi->txiqcalidx2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_txiqcalidx2g, -1));
	pi->txiqcalidx5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_txiqcalidx5g, -1));

	pi->disable_olpc = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_disable_olpc, 0));
	for (i = 0; i < PHY_CORE_MAX; i++) {
		/* Tempslope is in S0.10 format */
		pi->olpc_tempslope2g[i] = (int16) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_olpc_tempslope2g, i, 0));
		pi->olpc_tempslope5g[i] = (int16) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_olpc_tempslope5g, i, 0));
	}
	/* Both olpc_thresh and olpc_anchor are in qdb format */
	pi->olpc_thresh = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_thresh, 0));
	/* If olpc_thresh2g/5g not present in nvram, just load them with olpc_thresh value */
	pi->olpc_thresh2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_thresh2g, pi->olpc_thresh));
	pi->olpc_thresh5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_thresh5g, pi->olpc_thresh));
	pi->olpc_anchor2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_anchor2g, 0));
	pi->olpc_anchor5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_anchor5g, 0));
	/* olpc_idx_in_use is the top level control for whether  */
	/* table based txcal anchor point txidx will be used for OLPC */
	pi->olpc_idx_in_use = (uint8) (PHY_GETINTVAR_DEFAULT(pi, rstr_olpc_idx_in_use, 0));
	pi->papdpwrctrl = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_papdpwrctrl, 0));
	pi->pacalpwr2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacalpwr2g, -99));
	if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		/* For 4350, pacalpwr5g = lo, mi, hi, x1, lo, mi, hi, x1 */
		/*                       |    core 0     |     core 1    | */
		for (i = 0; i < 8; i++) {
			pi->pacalpwr5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			        (pi, rstr_pacalpwr5g, i, -99));
			pi->pacalpwr5g40[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			        (pi, rstr_pacalpwr5g40, i, -99));
			pi->pacalpwr5g80[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			        (pi, rstr_pacalpwr5g80, i, -99));
		}
	} else {
		/* For 4345 and others */
		for (i = 0; i < 4; i++) {
			pi->pacalpwr5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			        (pi, rstr_pacalpwr5g, i, -99));
		}
	}

	pi->txgaintbl5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_txgaintbl5g, -1));

	pi->parfps2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_parfps2g, -1));
	pi->parfps5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_parfps5g, -1));

	pi->papdbbmult2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_papdbbmult2g, -1));
	pi->papdbbmult5g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_papdbbmult5g, -1));

	pi->pacalmode = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacalmode, -1));
	pi->pacalopt = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_pacalopt, -1));

	pi->patoneidx2g = (int8) (PHY_GETINTVAR_DEFAULT(pi, rstr_patoneidx2g, -1));
	for (i = 0; i < 4; i++) {
		pi->patoneidx5g[i] = (int8) (PHY_GETINTVAR_ARRAY_DEFAULT
			(pi, rstr_patoneidx5g, i, -1));
	}

	/* Default value for forced papd cal index */
	pi_ac->pacalidx_iovar = -1;

	pi_ac->papdmode = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_papdmode, PAPD_LMS);
	pi_ac->srom_tworangetssi2g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_tworangetssi2g, FALSE);
	pi_ac->srom_tworangetssi5g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_tworangetssi5g, FALSE);
	pi_ac->srom_tssisleep_en = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_tssisleep_en, FALSE);
	pi_ac->srom_lowpowerrange2g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_lowpowerrange2g, FALSE);
	pi_ac->srom_lowpowerrange5g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_lowpowerrange5g, FALSE);
	pi_ac->srom_2g_pdrange_id = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_pdgain2g, 0);
	pi_ac->srom_5g_pdrange_id = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_pdgain5g, 0);
	pi_ac->srom_paprdis = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_paprdis, FALSE);
	pi_ac->srom_papdwar = (int8)PHY_GETINTVAR_DEFAULT(pi, rstr_papdwar, -1);
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || (PHY_IPA(pi) && ACMAJORREV_2(pi->pubpi.phy_rev))) {
		pi_ac->fastpapdgainctrl =
		(uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_fastpapdgainctrl, 1);
	} else {
		pi_ac->fastpapdgainctrl =
		(uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_fastpapdgainctrl, 0);
	}
	wlc_phy_nvram_epsdelta_read(pi);
	pi_ac->srom_edpdcalset = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_edpdcalset, 0);
	pi_ac->srom_txnospurmod5g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_txnospurmod5g, 1);
	pi_ac->srom_txnospurmod2g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_txnospurmod2g, 0);
	pi_ac->rx5ggainwar = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_rx5ggainwar, 0);
	pi_ac->ldo3p3_2g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_ldo3p3_2g, 0);
	pi_ac->ldo3p3_5g = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_ldo3p3_5g, 0);

#if (defined(WLTEST) || defined(ACMAJORREV2_THROUGHPUT_OPT))
	pi_ac->en_xtalldowar_2069 =
		((bool)PHY_GETINTVAR_DEFAULT(pi, rstr_dis_xtalldowar_2069, 0)) ? 0 : 1;
#endif // endif

	pi_ac->srom.femctrl = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_femctrl, 0);
	if ((PHY_GETVAR(pi, rstr_boardflags3)) != NULL) {
		bfl3 = (uint32)PHY_GETINTVAR(pi, rstr_boardflags3);
		pi_ac->srom.femctrl_sub = bfl3 & BFL3_FEMCTRL_SUB;
		pi_ac->srom.agc_cfg_2g = ((bfl3 & BFL3_AGC_CFG_2G) != 0);
		pi_ac->srom.agc_cfg_5g = ((bfl3 & BFL3_AGC_CFG_5G) != 0);
		pi_ac->srom.spur_war_enb_5g = ((bfl3 & BFL3_5G_SPUR_WAR) != 0);
		pi_ac->srom.femctrl_from_nvram = (bfl3 & BFL3_FEMTBL_FROM_NVRAM)
			>> BFL3_FEMTBL_FROM_NVRAM_SHIFT;
		pi_ac->srom.avvmid_from_nvram = (bfl3 & BFL3_AVVMID_FROM_NVRAM)
			>> BFL3_AVVMID_FROM_NVRAM_SHIFT;
		/* pi_ac->srom.vlin_en_from_nvram = (bfl3 & BFL3_VLIN_EN_FROM_NVRAM)
			>> BFL3_VLIN_EN_FROM_NVRAM_SHIFT;
		*/
		pi_ac->srom.txgaintbl_id = (bfl3 & BFL3_TXGAINTBLID) >> BFL3_TXGAINTBLID_SHIFT;
		pi_ac->srom.tssi_div_war = (bfl3 & BFL3_TSSI_DIV_WAR) >> BFL3_TSSI_DIV_WAR_SHIFT;
		pi_ac->srom.rcal_war = ((bfl3 & BFL3_RCAL_WAR) != 0);
		pi_ac->srom.rcal_otp_val_en = ((bfl3 & BFL3_RCAL_OTP_VAL_EN) != 0);
		pi_ac->srom.ppr_bit_ext = (bfl3 & BFL3_PPR_BIT_EXT) >> BFL3_PPR_BIT_EXT_SHIFT;
		pi_ac->srom.bbpll_spr_modes_dis = ((bfl3 & BFL3_BBPLL_SPR_MODE_DIS) != 0);
		pi_ac->srom.txgaintbl2g_blank = (bfl3 & BFL3_2GTXGAINTBL_BLANK) >>
			BFL3_2GTXGAINTBL_BLANK_SHIFT;
		pi_ac->srom.txgaintbl5g_blank = (bfl3 & BFL3_5GTXGAINTBL_BLANK) >>
			BFL3_5GTXGAINTBL_BLANK_SHIFT;
		pi_ac->srom.phasetrack_max_alphabeta = (bfl3 & BFL3_PHASETRACK_MAX_ALPHABETA) >>
			BFL3_PHASETRACK_MAX_ALPHABETA_SHIFT;
		pi_ac->srom.ltecoex_gaintbl_en = (bfl3 & BFL3_LTECOEX_GAINTBL_EN) >>
			BFL3_LTECOEX_GAINTBL_EN_SHIFT;
		pi_ac->srom.lpmode_2g = (bfl3 & BFL3_ACPHY_LPMODE_2G) >>
			BFL3_ACPHY_LPMODE_2G_SHIFT;
		pi_ac->srom.lpmode_5g = (bfl3 & BFL3_ACPHY_LPMODE_5G) >>
			BFL3_ACPHY_LPMODE_5G_SHIFT;
		pi_ac->srom.agc_cfg2_2g = ((bfl3 & BFL3_AGC_CFG2_2G) != 0);
		pi_ac->srom.agc_cfg2_5g = ((bfl3 & BFL3_AGC_CFG2_5G) != 0);
	} else {
		pi_ac->srom.femctrl_sub = 0;
		pi_ac->srom.agc_cfg_2g = 0;
		pi_ac->srom.agc_cfg_5g = 0;
		pi_ac->srom.spur_war_enb_5g = 0;
		pi_ac->srom.femctrl_from_nvram = 0;
		pi_ac->srom.txgaintbl_id = 0;
		pi_ac->srom.tssi_div_war = 0;
		pi_ac->srom.rcal_war = 0;
		pi_ac->srom.ppr_bit_ext = 0;
		pi_ac->srom.rcal_otp_val_en = 0;
		pi_ac->srom.bbpll_spr_modes_dis = 0;
		pi_ac->srom.txgaintbl2g_blank = 0;
		pi_ac->srom.txgaintbl5g_blank = 0;
		pi_ac->srom.phasetrack_max_alphabeta = 0;
		pi_ac->srom.ltecoex_gaintbl_en = 0;
		pi_ac->srom.lpmode_2g = 0;
		pi_ac->srom.lpmode_5g = 0;
	}

		pi_ac->srom.dBpad = 0;
#ifdef SROM12
	if ((PHY_GETVAR(pi, rstr_boardflags4)) != NULL) {
		bfl4 = (uint32)PHY_GETINTVAR(pi, rstr_boardflags4);
		pi_ac->srom.dBpad = bfl4 & BFL4_SROM12_4dBPAD;
	}
#endif // endif
	pi_ac->srom.rfpll_5g = ((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_APLL_WAR) != 0);
	pi_ac->srom.spur_war_enb_2g = ((BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_2G_SPUR_WAR) != 0);
	pi_ac->srom.dac_spur_improve = (BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_DAC_SPUR_IMPROVEMENT) != 0;
	pi_ac->srom.reduce_pa_turnontime = (BOARDFLAGS2(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_REDUCED_PA_TURNONTIME) != 0;
	pi_ac->srom.bt_coex = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		BFL_SROM11_BTCOEX) != 0);
	pi_ac->srom.gainboosta01 = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		BFL_SROM11_GAINBOOSTA01) != 0);
	pi_ac->srom.gainboost_core2 = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_GAINBOOST_CORE2) != 0);
	pi_ac->srom.epa_on_during_txiqlocal = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_EPA_ON_DURING_TXIQLOCAL) != 0);
	pi_ac->srom.precal_tx_idx = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags) &
		BFL_SROM11_PRECAL_TX_IDX) != 0);
	pi_ac->srom.xtal_spur_suppress = ((BOARDFLAGS(GENERIC_PHY_INFO(pi)->boardflags2) &
		BFL2_SROM11_XTAL_SPUR_SUPPRESS) != 0);

	if ((PHY_GETVAR(pi, rstr_cckdigfilttype)) != NULL) {
		pi_ac->acphy_cck_dig_filt_type = (uint8)PHY_GETINTVAR(pi, rstr_cckdigfilttype);
	} else {
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
			((pi->sh->epagain2g == 2) || (pi->sh->extpagain2g == 2)) &&
			((pi->sh->epagain5g == 2) || (pi->sh->extpagain5g == 2))) {
			/* 43162 improving ACPR */
			pi_ac->acphy_cck_dig_filt_type = 0x02;
		} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
			pi_ac->acphy_cck_dig_filt_type = 0x01;
		} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
			pi_ac->acphy_cck_dig_filt_type = -1;
		} else {
			/* bit0 is gaussian shaping and bit1 & 2 are for RRC alpha */
			pi_ac->acphy_cck_dig_filt_type = 0x01;
		}
	}

	if ((PHY_GETVAR(pi, rstr_pagc2g)) != NULL) {
		pi_ac->srom_pagc2g = (uint8)PHY_GETINTVAR(pi, rstr_pagc2g);
		pi_ac->srom_pagc2g_ovr = 0x1;
	} else {
		pi_ac->srom_pagc2g = 0xff;
		pi_ac->srom_pagc2g_ovr = 0x0;
	}

	if ((PHY_GETVAR(pi, rstr_pagc5g)) != NULL) {
		pi_ac->srom_pagc5g = (uint8)PHY_GETINTVAR(pi, rstr_pagc5g);
		pi_ac->srom_pagc5g_ovr = 0x1;
	} else {
		pi_ac->srom_pagc5g = 0xff;
		pi_ac->srom_pagc5g_ovr = 0x0;
	}

	if ((PHY_GETVAR(pi, ed_thresh2g)) != NULL) {
		pi_ac->srom.ed_thresh2g = (int32)PHY_GETINTVAR(pi, ed_thresh2g);
	} else {
		pi_ac->srom.ed_thresh2g = 0;
	}

	if ((PHY_GETVAR(pi, ed_thresh5g)) != NULL) {
		pi_ac->srom.ed_thresh5g = (int32)PHY_GETINTVAR(pi, ed_thresh5g);
	} else {
		if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev) &&
			((pi->sh->epagain2g == 2) || (pi->sh->extpagain2g == 2)) &&
			((pi->sh->epagain5g == 2) || (pi->sh->extpagain5g == 2)))
			/* 43162 5G adaptivity test */
			pi_ac->srom.ed_thresh5g = -73;
		else
			pi_ac->srom.ed_thresh5g = 0;
	}

	pi_ac->srom.phy4350_ss_opt = (uint8)PHY_GETINTVAR_DEFAULT(pi, rstr_phy4350_ss_opt, 0);

	if ((PHY_GETVAR(pi, rstr_antdiv_rfswctrlpin_a0)) != NULL) {
		pi_ac->antdiv_rfswctrlpin_a0 = (uint8)PHY_GETINTVAR(pi, rstr_antdiv_rfswctrlpin_a0);
	} else {
		pi_ac->antdiv_rfswctrlpin_a0 = (uint8)255;
	}
	if ((PHY_GETVAR(pi, rstr_antdiv_rfswctrlpin_a1)) != NULL) {
		pi_ac->antdiv_rfswctrlpin_a1 = (uint8)PHY_GETINTVAR(pi, rstr_antdiv_rfswctrlpin_a1);
	} else {
		pi_ac->antdiv_rfswctrlpin_a1 = (uint8)255;
	}

	if ((PHY_GETVAR(pi, "eu_edthresh2g")) != NULL) {
		pi->srom_eu_edthresh2g = (int8)PHY_GETINTVAR(pi, "eu_edthresh2g");
	} else {
		pi->srom_eu_edthresh2g = 0;
	}

	if ((PHY_GETVAR(pi, "eu_edthresh5g")) != NULL) {
		pi->srom_eu_edthresh5g = (int8)PHY_GETINTVAR(pi, "eu_edthresh5g");
	} else {
		pi->srom_eu_edthresh5g = 0;
	}

	/* Read the offset target power var */
	pi_ac->offset_targetpwr = (uint16)PHY_GETINTVAR_DEFAULT(pi, rstr_offtgpwr, 0);

	pi->cal_period = PHY_GETINTVAR_DEFAULT(pi, rstr_cal_period, PHY_PERICAL_TEMP_ONLY);

#if (defined(WLTEST) || defined(WLPKTENG))
	/* Read the per rate dpd enable param */
	pi_ac->perratedpd2g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_perratedpd2g, 0);
	pi_ac->perratedpd5g = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_perratedpd5g, 0);
#endif // endif

	/* Read paparambwver */
	pi_ac->paparambwver = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_paparambwver, 0);
	/* enable/Disable LTEJ WAR for 4345 */
	pi_ac->LTEJ_WAR_en = (bool)PHY_GETINTVAR_DEFAULT(pi, rstr_LTEJ_WAR_en, 1);
#ifdef WLC_SW_DIVERSITY
	wlc_phy_swdiv_srom_read_acphy(pi);
#endif /* WLC_SW_DIVERSITY */

	if (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
		((RADIOREV(pi->pubpi.radiorev) == 0x2C && PHY_XTAL_IS40M(pi)) ||
		(RADIOREV(pi->pubpi.radiorev) == 0x29 && PHY_XTAL_IS37M4(pi)))) {
		/* Temperature delta for PAPD temp compensation */
		papdtempcomp_tempdelta = (uint8)PHY_GETINTVAR_DEFAULT(pi,
			rstr_papdtempcomp_tempdelta, 0);
		/* Cal temperature compensation disabled if threshold not greater than 0 */
		if (papdtempcomp_tempdelta > 0) {
			/* Allocate the cal tempcomp data if not allocated yet */
			if (pi_ac->cal_tempcomp == NULL) {
				if ((pi_ac->cal_tempcomp = (acphy_cal_tempcomp_t*)MALLOC(
					pi->sh->osh, sizeof(acphy_cal_tempcomp_t))) == NULL) {
					PHY_ERROR(("wl%d: %s: out of memory, malloced %d bytes\n",
						pi->sh->unit, __FUNCTION__,
						MALLOCED(pi->sh->osh)));
				} else {
					bzero((char *)pi_ac->cal_tempcomp,
						sizeof(acphy_cal_tempcomp_t));
				}
			}
			if (pi_ac->cal_tempcomp) {
				/* Set the threshold */
				pi_ac->cal_tempcomp->papdtempcomp_tempdelta =
					papdtempcomp_tempdelta;
			}
		}
	}
}

static void
BCMATTACHFN(wlc_phy_nvram_epsdelta_read)(phy_info_t *pi)
{
/* Nvram parameter to adjust epsilon offset value per tx index
To bypass set B0index =<-1
Array interpetation:
epsdelta2g0 = [Aindex,B0index,B0offsetvalue,B1offsetvalue,B2offsetvalue..B3offsetvalue]
Aindex  - Fix offset for all Tx indexes
B0index - Fix offset from Tx index 0 until B0index
B0offsetvalue - offset value for index <= bo
B1offsetvalue - offset value for index = bo+1
BNoffsetvalue - offset value for index = bo+N
*/
	uint8 i;
	uint8 core;
	char phy_var_name[20];
	int16 default_array_4354[ACPHY_SIZE_EPSDELTA_ARRAY] =
	 {0, 16, -11, -9, -7, -5, -2, -1, 0, 0};
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	FOREACH_CORE(pi, core) {
		(void)snprintf(phy_var_name, sizeof(phy_var_name), "epsdelta2g%d", core);
		if ((PHY_GETVAR(pi, phy_var_name)) != NULL) {
			for (i = 0; i < ACPHY_SIZE_EPSDELTA_ARRAY; i++) {
				pi_ac->srom_epsdelta2g[core][i] =
				(int16) PHY_GETINTVAR_ARRAY_DEFAULT(pi, phy_var_name, i, 0);
			}
		} else {
			if (ACMAJORREV_2(pi->pubpi.phy_rev) && PHY_IPA(pi)) {
				for (i = 0; i < ACPHY_SIZE_EPSDELTA_ARRAY; i++) {
					pi_ac->srom_epsdelta2g[core][i] = default_array_4354[i];
				}
			} else {
				for (i = 0; i < ACPHY_SIZE_EPSDELTA_ARRAY; i++) {
					pi_ac->srom_epsdelta2g[core][i] = -1; /* bypass */
				}
			}
		}
	}
}

static void
BCMATTACHFN(wlc_phy_fptr_attach_acphy)(phy_info_t *pi)
{
	pi->pi_fptr.init = wlc_phy_init_acphy;
	pi->pi_fptr.detach = wlc_phy_detach_acphy;
	pi->pi_fptr.calinit = wlc_phy_cal_init_acphy;
	pi->pi_fptr.txiqccset = wlc_acphy_set_tx_iqcc;
	pi->pi_fptr.txiqccget = wlc_acphy_get_tx_iqcc;
	pi->pi_fptr.txloccget = wlc_acphy_get_tx_locc;
	pi->pi_fptr.txloccset = wlc_acphy_set_tx_locc;
	pi->pi_fptr.chanset = wlc_phy_chanspec_set_acphy;
	pi->pi_fptr.phywatchdog = wlc_phy_watchdog_acphy;
	pi->pi_fptr.radioloftget = wlc_acphy_get_radio_loft;
	pi->pi_fptr.radioloftset = wlc_acphy_set_radio_loft;
	pi->pi_fptr.phybtcadjust = wlc_phy_btc_adjust_acphy;
	pi->pi_fptr.txpwrrecalc = wlc_phy_txpower_recalc_target_acphy;
	pi->pi_fptr.txcorepwroffsetset = wlc_phy_txpower_core_offset_set_acphy;
	pi->pi_fptr.txcorepwroffsetget = wlc_phy_txpower_core_offset_get_acphy;
#ifdef ENABLE_FCBS
	if (CHIPID(pi->sh->chip) == BCM4360_CHIP_ID) {
		pi->pi_fptr.fcbs = wlc_phy_fcbs_acphy;
		pi->pi_fptr.prefcbs = wlc_phy_prefcbs_acphy;
		pi->pi_fptr.postfcbs = wlc_phy_postfcbs_acphy;
		pi->pi_fptr.fcbsinit = wlc_phy_fcbsinit_acphy;
		pi->pi_fptr.prefcbsinit = wlc_phy_prefcbsinit_acphy;
		pi->pi_fptr.postfcbsinit = wlc_phy_postfcbsinit_acphy;
		pi->HW_FCBS = TRUE;
		pi->FCBS = TRUE;
		if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
			pi->phy_fcbs.FCBS_ucode = TRUE;
		} else {
			pi->phy_fcbs.FCBS_ucode = FALSE;
		}
	}
#else
	pi->HW_FCBS = FALSE;
#endif /* ENABLE_FCBS */
#ifdef WL_LPC
	pi->pi_fptr.lpcsetmode = NULL;
	pi->pi_fptr.lpcgettxcpwrval = NULL;
	pi->pi_fptr.lpcsettxcpwrval = NULL;
	pi->pi_fptr.lpcgetpwros = wlc_acphy_lpc_getoffset;
	pi->pi_fptr.lpcgetminidx = wlc_acphy_lpc_getminidx;
#ifdef WL_LPC_DEBUG
	pi->pi_fptr.lpcgetpwrlevelptr = wlc_acphy_lpc_get_pwrlevelptr;
#endif // endif
#endif /* WL_LPC */
#ifdef ATE_BUILD
	pi->pi_fptr.gpaioconfigptr = wlc_phy_gpaio_acphy;
#endif // endif
	pi->pi_fptr.txswctrlmapsetptr = wlc_txswctrlmap_set_acphy;
	pi->pi_fptr.txswctrlmapgetptr = wlc_txswctrlmap_get_acphy;

#if defined(WLTEST) || defined(BCMDBG)
	pi->pi_fptr.epadpdsetptr = wlc_phy_epa_dpd_set_acphy;
#endif // endif

#if (defined(WLTEST) || defined(WLPKTENG))
	pi->pi_fptr.isperratedpdenptr = wlc_phy_isperratedpden_acphy;
	pi->pi_fptr.perratedpdsetptr = wlc_phy_perratedpdset_acphy;
#endif // endif

#if defined(WLTEST)
	pi->pi_fptr.swctrlmapsetptr = wlc_swctrlmap_set_acphy;
	pi->pi_fptr.swctrlmapgetptr = wlc_swctrlmap_get_acphy;
#endif // endif
}

void
BCMATTACHFN(wlc_phy_interference_mode_attach_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	bzero(&pi_ac->curr_desense, sizeof(acphy_desense_values_t));
	bzero(&pi_ac->zero_desense, sizeof(acphy_desense_values_t));
	bzero(&pi_ac->total_desense, sizeof(acphy_desense_values_t));
	bzero(&pi_ac->bt_desense, sizeof(acphy_desense_values_t));
	bzero(pi_ac->aci_list2g, ACPHY_ACI_CHAN_LIST_SZ * sizeof(acphy_aci_params_t));
	bzero(pi_ac->aci_list5g, ACPHY_ACI_CHAN_LIST_SZ * sizeof(acphy_aci_params_t));

	pi_ac->aci = NULL;
	pi_ac->btc_mode = 0;
	pi_ac->limit_desense_on_rssi = TRUE;

	if (ACMAJORREV_5(pi->pubpi.phy_rev)) {
		pi->sh->interference_mode_2G = ACPHY_ACI_GLITCHBASED_DESENSE |
			ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
			ACPHY_ACI_PREEMPTION | ACPHY_LPD_PREEMPTION;
		pi->sh->interference_mode_5G = ACPHY_ACI_GLITCHBASED_DESENSE |
			ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
			ACPHY_ACI_PREEMPTION;
	} else if (ACMAJORREV_4(pi->pubpi.phy_rev)) {
		/* 4349 and other TINY radio chips are on dingo and trunk -- need to merge this */
	} else if (ACMAJORREV_3(pi->pubpi.phy_rev)) {
		if (CHIPREV(pi->sh->chiprev) >= 4) {
#ifndef WLC_DISABLE_PREEMPT
		pi->sh->interference_mode_2G |= ACPHY_ACI_PREEMPTION | ACPHY_HWACI_MITIGATION;
		pi->sh->interference_mode_5G |= ACPHY_ACI_PREEMPTION;
#endif /* !WLC_DISABLE_PREEMPT */
		} else {
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev)) {
		if (PHY_XTAL_IS40M(pi)) {
			if (ACMINORREV_3(pi->pubpi.phy_rev) || ACMINORREV_5(pi->pubpi.phy_rev)) {
				/* for 43569/43570 turn-on swaci + preemption only */
				pi->sh->interference_mode_2G |=
				        ACPHY_ACI_GLITCHBASED_DESENSE | ACPHY_ACI_HWACI_PKTGAINLMT |
					ACPHY_ACI_W2NB_PKTGAINLMT | ACPHY_ACI_PREEMPTION;
				pi->sh->interference_mode_5G |=
				        ACPHY_ACI_GLITCHBASED_DESENSE | ACPHY_ACI_HWACI_PKTGAINLMT |
					ACPHY_ACI_W2NB_PKTGAINLMT | ACPHY_ACI_PREEMPTION;
			} else {
			}
		} else {
			if (ACMINORREV_3(pi->pubpi.phy_rev)) {
				/* 4354A1 */
				pi->sh->interference_mode_2G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
				        ACPHY_ACI_PREEMPTION;
				pi->sh->interference_mode_5G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
				        ACPHY_ACI_PREEMPTION;
			} else if (ACMINORREV_5(pi->pubpi.phy_rev)) {
				/* 4354a2/4356/4358a1 */
				pi->sh->interference_mode_2G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
				        ACPHY_ACI_PREEMPTION;
				pi->sh->interference_mode_5G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_HWACI_PKTGAINLMT | ACPHY_ACI_W2NB_PKTGAINLMT |
				        ACPHY_ACI_PREEMPTION;
			} else {
				/* For 4350, enable noise miti, HW ACI miti, Preemption */
				pi->sh->interference_mode_2G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_PREEMPTION | ACPHY_HWACI_MITIGATION;
				pi->sh->interference_mode_5G |= ACPHY_ACI_GLITCHBASED_DESENSE |
				        ACPHY_ACI_PREEMPTION | ACPHY_HWACI_MITIGATION;
			}
		}
	} else if (ACMAJORREV_1(pi->pubpi.phy_rev)) {
		pi->sh->interference_mode_2G = ACPHY_ACI_GLITCHBASED_DESENSE;
		pi->sh->interference_mode_5G = ACPHY_ACI_GLITCHBASED_DESENSE;
		if (ACMINORREV_2(pi->pubpi.phy_rev)) {
			/* 4335C0 */
			pi->sh->interference_mode_2G |= ACPHY_ACI_HWACI_PKTGAINLMT |
			        ACPHY_ACI_W2NB_PKTGAINLMT | ACPHY_ACI_PREEMPTION;
			pi->sh->interference_mode_5G |= ACPHY_ACI_HWACI_PKTGAINLMT |
			        ACPHY_ACI_W2NB_PKTGAINLMT | ACPHY_ACI_PREEMPTION;
		} else {
		}
	} else if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
		pi->sh->interference_mode_2G = ACPHY_ACI_GLITCHBASED_DESENSE;
		pi->sh->interference_mode_5G = ACPHY_ACI_GLITCHBASED_DESENSE;
		if (ACREV_IS(pi->pubpi.phy_rev, 1)) {
			/* 4360b0 */
			pi->sh->interference_mode_2G |= ACPHY_ACI_HWACI_PKTGAINLMT |
				ACPHY_ACI_W2NB_PKTGAINLMT;
			pi->sh->interference_mode_5G |= ACPHY_ACI_HWACI_PKTGAINLMT |
				ACPHY_ACI_W2NB_PKTGAINLMT;
		} else if (ACREV_IS(pi->pubpi.phy_rev, 0)) {
			/* 4360a0 */
			pi->sh->interference_mode_2G |= ACPHY_ACI_W2NB_PKTGAINLMT;
			pi->sh->interference_mode_5G |= ACPHY_ACI_W2NB_PKTGAINLMT;
		} else {
		}
	} else {
		pi->sh->interference_mode_2G = INTERFERE_NONE;
		pi->sh->interference_mode_5G = INTERFERE_NONE;
	}
}

void
wlc_phy_antdiv_acphy(phy_info_t *pi, uint8 val)
{
	if (val > ANT_RX_DIV_FORCE_1) {
		MOD_PHYREG(pi, AntDivConfig2059, board_switch_div0, 1); /* enable diversity */
		if (val == ANT_RX_DIV_START_1) {
			MOD_PHYREG(pi, AntDivConfig2059, CoreStartAntPos0, 1);
		} else {
			MOD_PHYREG(pi, AntDivConfig2059, CoreStartAntPos0, 0);
		}

		ACPHY_REG_LIST_START
			/* 1p6us dwell time */
			MOD_PHYREG_ENTRY(pi, AntennaDivDwellTime, DivDwellTime, 64)

			MOD_PHYREG_ENTRY(pi, DivEnableClipGain, AntDivEnClipGains_Md, 0)
			MOD_PHYREG_ENTRY(pi, DivEnableClipGain, AntDivEnClipGains_Lo, 0)
			MOD_PHYREG_ENTRY(pi, DivEnableClipGain, AntDivEnClipGains_Clip2, 0)
			MOD_PHYREG_ENTRY(pi, DivEnableClipGain, AntDivEnClipGainBphy, 0)
			MOD_PHYREG_ENTRY(pi, DivGainThreshold_OFDM, Div_GainThresh_OFDM, 85)
			MOD_PHYREG_ENTRY(pi, DivGainThreshold_BPHY, Div_GainThresh_BPHY, 95)
			MOD_PHYREG_ENTRY(pi, AntennaDivBackOffGain, BackoffGain, 6)
			MOD_PHYREG_ENTRY(pi, AntennaDivMinGain, cckBackoffGain, 0)
		/* MOD_PHYREG_ENTRY(pi, defer_setClip1_CtrLen, defer_setclip1gain_len, 20) */
		ACPHY_REG_LIST_EXECUTE(pi);

		if (CHSPEC_IS5G(pi->radio_chanspec)) {
			if (CHSPEC_IS80(pi->radio_chanspec)) {
				MOD_PHYREG(pi, DivEnableClipGain, AntDivEnClipGains_Hi, 1);
			} else {
				MOD_PHYREG(pi, DivEnableClipGain, AntDivEnClipGains_Hi, 0);
			}
		} else {
			MOD_PHYREG(pi, DivEnableClipGain, AntDivEnClipGains_Hi, 0);
		}
	} else {
		/* disable HW antsel */
		MOD_PHYREG(pi, AntDivConfig2059, board_switch_div0, 0);
		if (val == ANT_RX_DIV_FORCE_1) {
			MOD_PHYREG(pi, AntDivConfig2059, CoreStartAntPos0, 1);
		} else {
			MOD_PHYREG(pi, AntDivConfig2059, CoreStartAntPos0, 0);
		}
	}
}

#if defined(WLTEST) || defined(BCMDBG)
static void
wlc_phy_epa_dpd_set_acphy(phy_info_t *pi, uint8 enab_epa_dpd, bool in_2g_band)
{
	bool turn_papd_on = FALSE;
	bool iovar_in_band;
	uint8 core = 0;

	if (in_2g_band) {
		pi->epacal2g = enab_epa_dpd;
		turn_papd_on = (pi->epacal2g == 1);
	} else {
		pi->epacal5g = enab_epa_dpd;
		turn_papd_on = (pi->epacal5g == 1);
	}
	iovar_in_band = ((in_2g_band &&
		(CHSPEC_IS2G(pi->radio_chanspec))) ||
		(!in_2g_band && (CHSPEC_IS5G(pi->radio_chanspec))));
	if (iovar_in_band) {
		if (!PHY_PAPDEN(pi) && !PHY_IPA(pi) && in_2g_band) {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				/* WAR for FDIQI when bq_bw = 9, 25 MHz */
				wlc_phy_radio20691_lpf_tx_set(pi, 6, 2, 1, 1);
			} else {
				wlc_phy_radio20691_lpf_tx_set(pi, 6, 2, 6, 1);
			}
		}
		if (turn_papd_on) {
			wlc_phy_cals_acphy(pi, 0);
		} else {
			MOD_PHYREGCEE(pi, PapdEnable, core, papd_compEnb, 0);
		}
	}
}
#endif /* defined(WLTEST) || defined(BCMDBG) */

static void
wlc_phy_susp2tx_cts2self(phy_info_t *pi, uint16 duration)
{
	int mac_depth = 0;
	while ((mac_depth < 100) && !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC)) {
	  /* Unsuspend mac */
	  wlapi_enable_mac(pi->sh->physhim);
	  mac_depth++;
	}
	ASSERT((R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC) != 0);
	if (duration > 0)
	  wlapi_bmac_write_shm(pi->sh->physhim, M_CTS_DURATION, duration);
	while (mac_depth) {
	  /* Leave the mac in its original state */
	  wlapi_suspend_mac_and_wait(pi->sh->physhim);
	  mac_depth--;
	}
	/* Pepare Mac and Phregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);
	/* Disable Power control */
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
}

static void
wlc_phy_fdss_init(phy_info_t *pi)
{
	uint8 core;
	FOREACH_CORE(pi, core) {
		MOD_PHYREGCEE(pi, txfdss_ctrl, core, txfdss_enable, 1);
		MOD_PHYREGCEE(pi, txfdss_ctrl, core, txfdss_interp_enable, pi->fdss_interp_en);
		MOD_PHYREGCEE(pi, txfdss_cfgtbl, core, txfdss_num_20M_tbl, 2);
		MOD_PHYREGCEE(pi, txfdss_cfgtbl, core, txfdss_num_40M_tbl, 2);
		MOD_PHYREGCEE(pi, txfdss_cfgbrkpt0_, core, txfdss_num_20M_breakpoints, 5);
		MOD_PHYREGCEE(pi, txfdss_cfgbrkpt0_, core, txfdss_num_40M_breakpoints, 5);
		MOD_PHYREGCEE(pi, txfdss_cfgbrkpt1_, core, txfdss_num_80M_breakpoints, 5);
		MOD_PHYREGCEE(pi, txfdss_scaleadj_en_, core, txfdss_scale_adj_enable, 0);
		MOD_PHYREGCEE(pi, txfdss_scaleadj_en_, core, txfdss_scale_adj_enable, 7);
	}
}

static void
wlc_phy_set_fdss_table(phy_info_t *pi)
{
	uint8 mcstable[71] = {16, 16, 16, 16, 17, 17, 17, 17,
		16, 16, 16, 17, 17, 17, 17, 17,
		16, 16, 16, 17, 17, 17, 17, 17, 17, 17,
		16, 16, 16, 16, 17, 17, 17, 17,
		16, 16, 16, 17, 17, 17, 17, 17,
		16, 16, 16, 17, 17, 17, 17, 17, 17, 17,
		17,
		16, 16, 16, 17, 17, 17, 17, 17,
		16, 16, 16, 17, 17, 17, 17, 17, 17, 17,
		};

	uint8 i, fdss_level[2];
	uint8 breakpoint_list_20[5] = {0, 3, 17, 48, 62};
	uint8 breakpoint_list_40[5] = {0, 6, 34, 96, 124};
	uint8 breakpoint_list_80[5] = {0, 12, 68, 192, 248};
	uint8 breakpoint_list_interp_20[2] = {47, 61};
	uint8 breakpoint_list_interp_40[2] = {97, 123};
	uint8 breakpoint_list_interp_80[2] = {191, 247};

	uint8 fdss_scale_level[4][5] = {{128, 128, 128, 128, 128},
		{128, 128, 128, 128, 128},
		{164, 146, 104, 146, 164}, /* Mild, meets older +1, -3 dB flatness limits */
		{180, 128, 72, 128, 180} /* Extreme, meets older +3, -5 dB flatness limits */
		};
	int16 fdss_scale_level_interp_20[4][5] = {{0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0},
		{-683, -338, 0, 338, 683},
		{-2219, -512, 0, 512, 2219}};
	int16 fdss_scale_level_interp_40[4][5] = {{0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0},
		{-341, -169, 0, 169, 341},
		{-1109, -256, 0, 256, 1109}};
	int16 fdss_scale_level_interp_80[4][5] = {{0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0},
		{-171, -86, 0, 86, 171},
		{-555, -128, 0, 128, 555}};
	uint8 fdss_scale_level_adjust_20[4] = {128, 128, 132, 128};
	uint8 fdss_scale_level_adjust_40[4] = {128, 128, 132, 128};
	uint8 fdss_scale_level_adjust_80[4] = {128, 128, 134, 128};
	uint8 fdss_scale_level_adjust_interp_20[4] = {128, 128, 132, 128};
	uint8 fdss_scale_level_adjust_interp_40[4] = {128, 128, 131, 128};
	uint8 fdss_scale_level_adjust_interp_80[4] = {128, 128, 134, 128};

	if (CHSPEC_IS2G(pi->radio_chanspec)) {
		fdss_level[0] = pi->fdss_level_2g[0];
		if (pi->fdss_level_2g[1] ==  -1) {
			fdss_level[1] = 0;
		} else {
			fdss_level[1] = pi->fdss_level_2g[1];
		}
	} else {
		fdss_level[0] = pi->fdss_level_5g[0];
		if (pi->fdss_level_5g[1] ==  -1) {
			fdss_level[1] = 0;
		} else {
			fdss_level[1] = pi->fdss_level_5g[1];
		}
	}

	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_MCSINFOTBL0, 71, 0, 8, mcstable);

	/* Populate breakpoint and scale tables with the scale values for each BW */
	for (i = 0; i < 2; i++) {
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0, 5, 5*i, 8,
			breakpoint_list_20);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSTBL0, 5, 5*i, 8,
			fdss_scale_level[fdss_level[i]]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0, 1, i, 8,
			&fdss_scale_level_adjust_20[fdss_level[i]]);

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0, 5, 10+5*i, 8,
			breakpoint_list_40);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSTBL0, 5, 10+5*i, 8,
			fdss_scale_level[fdss_level[i]]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0, 1, i+2, 8,
			&fdss_scale_level_adjust_40[fdss_level[i]]);

		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0, 5, 20+5*i, 8,
			breakpoint_list_80);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSTBL0, 5, 20+5*i, 8,
			fdss_scale_level[fdss_level[i]]);
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0, 1, i+4, 8,
			&fdss_scale_level_adjust_80[fdss_level[i]]);
	}
	/* Edit  breakpoint table for interpolation case */

	if (pi->fdss_interp_en) {
		for (i = 0; i < 2; i++) {
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0,
				2, 3+5*i, 8, breakpoint_list_interp_20);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSDELTATBL0,
				5, 5*i, 16, fdss_scale_level_interp_20[fdss_level[i]]);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0,
				1, i, 8, &fdss_scale_level_adjust_interp_20[fdss_level[i]]);

			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0,
				2, 13+5*i, 8, breakpoint_list_interp_40);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSDELTATBL0,
				5, 10+5*i, 16, fdss_scale_level_interp_40[fdss_level[i]]);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0,
				1, i+2, 8, &fdss_scale_level_adjust_interp_40[fdss_level[i]]);

			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_BREAKPOINTSTBL0,
				2, 23+5*i, 8, breakpoint_list_interp_80);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEFACTORSDELTATBL0,
				5, 20+5*i, 16, fdss_scale_level_interp_80[fdss_level[i]]);
			wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_FDSS_SCALEADJUSTFACTORSTBL0,
				1, i+4, 8, &fdss_scale_level_adjust_interp_80[fdss_level[i]]);
		}
	}
}

static int16
wlc_phy_tempsense_acphy_tiny(phy_info_t *pi)
{
	/*
	 * # Description of mode = single:
	 * #	- used to digitally poll the radio's temperature sensors
	 * #	- does an absolute measurement by toggling the flip bit
	 * #	- saves and restores previous register values
	 * #	- returns per core values in degrees Celsius
	 * #
	 * # Description of mode = "scope": *** FIXME: not implemented ***
	 * #	- used to monitor the radio's temperature sensor on the scope by
	 * #	  means of the analog pwrdet signal
	 * #	- changes the state of the muxes and powers up the sensor
	 * # --------------------------------------------------------------------
	 */

	uint16 auxPGA_Av = 0x3, auxPGA_Vmid = 0x91;
	int32 radio_temp = 0;
	int32 t_scale = 16384;
	int32 t_slope = -10246;
	int32 t_offset = 1765868;
	int32 avbq_scale = 800;
	int32 avbq_slope = 1024;
	uint16 save_afePuCtrl = 0, save_gpio = 0, save_gpioHiOutEn = 0;
	uint16 fval2g_orig, fval5g_orig, fval2g, fval5g;
	uint32 save_chipc = 0;
	uint8  stall_val = 0;
	int32 measured_voltage[4] = {0};

	/*
	 * # If mac is suspended, leave it suspended and don't touch the state of the MAC
	 * # If not, suspend at the beginning of tempsense and resume it at the end.
	 * # (Suspending is required - as we arereading via muxes that are pin-contolled
	 * # during normal RX & TX.)
	 */
	/* Prepare Mac and Phregs */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	wlc_phy_tempsense_phy_setup_acphy_tiny(pi);
	wlc_phy_tempsense_radio_setup_acphy_tiny(pi, auxPGA_Av, auxPGA_Vmid);
	wlc_phy_init_adc_read(pi, &save_afePuCtrl, &save_gpio,
	                          &save_chipc, &fval2g_orig, &fval5g_orig,
	                          &fval2g, &fval5g, &stall_val, &save_gpioHiOutEn);
	wlc_phy_tempsense_poll_adc_war_tiny(pi, TRUE, measured_voltage);

	radio_temp += (int32)(((measured_voltage[0] + measured_voltage[2]
		- measured_voltage[1] - measured_voltage[3]) / 2)
		* t_slope * avbq_scale) / avbq_slope;
	radio_temp = (radio_temp + t_offset)/t_scale;

	wlc_phy_tempsense_phy_cleanup_acphy_tiny(pi);
	wlc_phy_tempsense_radio_cleanup_acphy_tiny(pi);
	wlc_phy_restore_after_adc_read(pi,	&save_afePuCtrl, &save_gpio,
		&save_chipc,  &fval2g_orig,  &fval5g_orig,
		&fval2g,  &fval5g, &stall_val, &save_gpioHiOutEn);
	wlc_phyreg_exit((wlc_phy_t *)pi);

	/* # RESUME MAC as soon as we are done reading/writing regs and muxes
	 * # -----------------------------------------------------------------
	 */
	wlapi_enable_mac(pi->sh->physhim);

	/* Store temperature and return value */
	pi->u.pi_acphy->current_temperature = (int16) radio_temp;

#ifdef ATE_BUILD
	ate_buffer_regval.curr_radio_temp = (int16) radio_temp;
#endif // endif

	return ((int16)radio_temp);
}

static int32
wlc_phy_tempsense_phy_setup_acphy_tiny(phy_info_t *pi)
{
	/* # this proc is used to configure the tempsense phy settings. */
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_tempsense_phyregs_t *porig = &(pi_ac->ac_tempsense_phyregs_orig);
	uint8 core = 0;

	/* Applicable # foreach core */
	porig->RfctrlOverrideAuxTssi[core] = READ_PHYREGCE(pi, RfctrlOverrideAuxTssi, core);
	porig->RfctrlCoreAuxTssi1[core]    = READ_PHYREGCE(pi, RfctrlCoreAuxTssi1, core);
	porig->RfctrlOverrideRxPus[core]   = READ_PHYREGCE(pi, RfctrlOverrideRxPus, core);
	porig->RfctrlCoreRxPus[core]       = READ_PHYREGCE(pi, RfctrlCoreRxPus, core);
	porig->RxFeCtrl1                   = READ_PHYREG(pi, RxFeCtrl1);
	porig->RfctrlOverrideTxPus[core]   = READ_PHYREGCE(pi, RfctrlOverrideTxPus, core);
	porig->RfctrlCoreTxPus[core]       = READ_PHYREGCE(pi, RfctrlCoreTxPus, core);
	porig->RfctrlOverrideGains[core]   = READ_PHYREGCE(pi, RfctrlOverrideGains, core);
	porig->RfctrlCoreLpfGain[core]     = READ_PHYREGCE(pi, RfctrlCoreLpfGain, core);
	porig->RxSdFeConfig1               = READ_PHYREG(pi, RxSdFeConfig1);
	porig->RxSdFeConfig6               = READ_PHYREG(pi, RxSdFeConfig6);
	porig->RfctrlOverrideLpfSwtch[core] = READ_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core);
	porig->RfctrlCoreLpfSwtch[core]    = READ_PHYREGCE(pi, RfctrlCoreLpfSwtch, core);
	porig->RfctrlOverrideAfeCfg[core]  = READ_PHYREGCE(pi, RfctrlOverrideAfeCfg, core);
	porig->RfctrlCoreAfeCfg1[core]     = READ_PHYREGCE(pi, RfctrlCoreAfeCfg1, core);
	porig->RfctrlCoreAfeCfg2[core]     = READ_PHYREGCE(pi, RfctrlCoreAfeCfg2, core);

	ACPHY_REG_LIST_START
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideAuxTssi,  0, amux_sel_port, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreAuxTssi1,	 0, amux_sel_port, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideAuxTssi,  0, afe_iqadc_aux_en, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreAuxTssi1,	 0, afe_iqadc_aux_en, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideRxPus,	 0, lpf_pu_dc, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreRxPus,		 0, lpf_pu_dc, 0)

	/* Power down LNAs - isolation of TIA power down is insufficient at high signal power */
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideRxPus,	 0, rxrf_lna1_pwrup, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideRxPus,	 0, rxrf_lna1_5G_pwrup, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreRxPus,	 0, rxrf_lna1_pwrup, 0)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreRxPus,	 0, rxrf_lna1_5G_pwrup, 0)
		MOD_PHYREG_ENTRY(pi, RxFeCtrl1, swap_iq0, 0)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideTxPus,    0, lpf_bq1_pu, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreTxPus,        0, lpf_bq1_pu, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideTxPus,    0, lpf_bq2_pu, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreTxPus,        0, lpf_bq2_pu, 0)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideTxPus,    0, lpf_pu, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreTxPus,        0, lpf_pu, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlOverrideGains,    0, lpf_bq1_gain, 1)
		MOD_PHYREGCE_ENTRY(pi, RfctrlCoreLpfGain,      0, lpf_bq1_gain, 0)
		MOD_PHYREG_ENTRY(pi, RxSdFeConfig1, farrow_rshift_force, 1)
		MOD_PHYREG_ENTRY(pi, RxSdFeConfig6, rx_farrow_rshift_0, 2)
	ACPHY_REG_LIST_EXECUTE(pi);

	return BCME_OK;
}

static int32
wlc_phy_tempsense_radio_setup_acphy_tiny(phy_info_t *pi, uint16 Av, uint16 Vmid)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	tempsense_radioregs_tiny_t *porig =
		&(pi_ac->ac_tempsense_radioregs_orig.u.acphy_tempsense_radioregs_tiny);
	const uint8 core = 0;

	porig->tempsense_cfg[core]     = READ_RADIO_REG_20691(pi, TEMPSENSE_CFG, core);
	porig->tempsense_ovr1[core]    = READ_RADIO_REG_20691(pi, TEMPSENSE_OVR1, core);
	porig->testbuf_cfg1[core]      = READ_RADIO_REG_20691(pi, TESTBUF_CFG1, core);
	porig->testbuf_ovr1[core]      = READ_RADIO_REG_20691(pi, TESTBUF_OVR1, core);
	porig->auxpga_cfg1[core]       = READ_RADIO_REG_20691(pi, AUXPGA_CFG1, core);
	porig->auxpga_vmid[core]       = READ_RADIO_REG_20691(pi, AUXPGA_VMID, core);
	porig->auxpga_ovr1[core]       = READ_RADIO_REG_20691(pi, AUXPGA_OVR1, core);
	porig->tia_cfg5[core]          = READ_RADIO_REG_20691(pi, TIA_CFG5, core);
	porig->tia_cfg7[core]          = READ_RADIO_REG_20691(pi, TIA_CFG7, core);
	porig->tia_cfg9[core]          = READ_RADIO_REG_20691(pi, TIA_CFG9, core);
	porig->adc_ovr1[core]          = READ_RADIO_REG_20691(pi, ADC_OVR1, core);
	porig->adc_cfg10[core]         = READ_RADIO_REG_20691(pi, ADC_CFG10, core);
	porig->rx_bb_2g_ovr_east[core] = READ_RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, core);

	ACPHY_REG_LIST_START
		/* # Setup Tempsense */
		MOD_RADIO_REG_20691_ENTRY(pi, TEMPSENSE_OVR1, core, ovr_tempsense_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TEMPSENSE_CFG, core, tempsense_pu, 1)

		/* # Setup Testbuf */
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_OVR1, core, ovr_testbuf_PU, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_CFG1, core, testbuf_PU, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_CFG1, core, testbuf_GPIO_EN, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_OVR1, core, ovr_testbuf_sel_test_port, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TESTBUF_CFG1, core, testbuf_sel_test_port, 1)

		/* # Setup AuxPGA */
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, core, ovr_auxpga_i_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, core, auxpga_i_pu, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, core, ovr_auxpga_i_sel_vmid, 1)

		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_VMID, core, auxpga_i_sel_vmid, 0x91)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, core, ovr_auxpga_i_sel_gain, 1)
	ACPHY_REG_LIST_EXECUTE(pi);

	MOD_RADIO_REG_20691(pi, AUXPGA_CFG1, core, auxpga_i_sel_gain, Av);

	ACPHY_REG_LIST_START
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, core, auxpga_i_vcm_ctrl, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_OVR1, core, ovr_auxpga_i_sel_input, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, AUXPGA_CFG1, core, auxpga_i_sel_input, 1)

		/* # Setup Aux Path */
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG9, core, txbb_dac2adc, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_OVR1, core, ovr_adc_in_test, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, ADC_CFG10, core, adc_in_test, 0xF)
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG5, core, tia_out_test, 1)

		/* # Turn off TIA otherwise it dominates the ADC input */
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, core, ovr_tia_amp1_pwrup, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG5, core, tia_amp1_pwrup, 0)
		MOD_RADIO_REG_20691_ENTRY(pi, RX_BB_2G_OVR_EAST, core, ovr_tia_pwrup_amp2, 1)
		MOD_RADIO_REG_20691_ENTRY(pi, TIA_CFG7, core, tia_pwrup_amp2, 0)
	ACPHY_REG_LIST_EXECUTE(pi);

	return BCME_OK;
}

static int32
wlc_phy_tempsense_poll_adc_war_tiny(phy_info_t *pi, bool init_adc_inside, int32 *measured_values)
{
	wlc_phy_tempsense_radio_swap_tiny(pi, ACPHY_TEMPSENSE_VBE, 0);
	measured_values[0] = wlc_phy_tempsense_poll_samps_tiny(pi, 200, init_adc_inside);

	wlc_phy_tempsense_radio_swap_tiny(pi, ACPHY_TEMPSENSE_VBG, 0);
	measured_values[1] = wlc_phy_tempsense_poll_samps_tiny(pi, 200, init_adc_inside);

	wlc_phy_tempsense_radio_swap_tiny(pi, ACPHY_TEMPSENSE_VBE, 1);
	measured_values[2] = wlc_phy_tempsense_poll_samps_tiny(pi, 200, init_adc_inside);

	wlc_phy_tempsense_radio_swap_tiny(pi, ACPHY_TEMPSENSE_VBG, 1);
	measured_values[3] = wlc_phy_tempsense_poll_samps_tiny(pi, 200, init_adc_inside);

	return BCME_OK;
}

static int32
wlc_phy_tempsense_poll_samps_tiny(phy_info_t *pi, uint16 samples, bool init_adc_inside)
{
	int32 measured_voltage;
	int32 i_sum = 0;
	int32 i_val = 0;
	int i = 0;

	/* Need to set the swap bit, otherwise there is a bug */
	if (init_adc_inside) {
		wlc_phy_tempsense_gpiosel_tiny(pi, 16, 1);
	}

	OSL_DELAY(10);
	for (i = 0; i < samples; i++) {
		i_val = READ_PHYREG(pi, gpioHiOut);
		/* 12 bit signed to 16 bit signed conversion. */
		i_val = (i_val & 0x0FFF);
		if ((i_val & 0x0800)) {
			i_val = (i_val | 0xFFFFF800);
		}
		i_sum += i_val;
	}
	measured_voltage = i_sum/samples;
	return (measured_voltage >> 2);
}

static int32
wlc_phy_tempsense_gpiosel_tiny(phy_info_t *pi, uint16 sel, uint8 word_swap)
{
	W_REG(pi->sh->osh, &pi->regs->psm_gpio_oe, 0x0);
	WRITE_PHYREG(pi, gpioLoOutEn, 0xFFFF);
	WRITE_PHYREG(pi, gpioHiOutEn, 0XFFFF);

	/* set up acphy GPIO sel */
	WRITE_PHYREG(pi, gpioSel, (word_swap<<8) | sel);
	return BCME_OK;
}

static int32
wlc_phy_tempsense_radio_swap_tiny(phy_info_t *pi, acphy_tempsense_cfg_opt_t type, uint8 swap)
{
	/* Enable override */
	MOD_RADIO_REG_20691(pi, TEMPSENSE_OVR1, 0, ovr_tempsense_sel_Vbe_Vbg, 1);
	MOD_RADIO_REG_20691(pi, TEMPSENSE_OVR1, 0, ovr_tempsense_swap_amp, 1);

	if (swap == 0) {
		MOD_RADIO_REG_20691(pi, TEMPSENSE_CFG, 0, tempsense_swap_amp, 0);
	} else if (swap == 1) {
		MOD_RADIO_REG_20691(pi, TEMPSENSE_CFG, 0, tempsense_swap_amp, 1);
	} else {
		PHY_ERROR(("Unsupported, swap should be 0 or 1\n"));
		return BCME_ERROR;
	}
	if (type == ACPHY_TEMPSENSE_VBG) {
		MOD_RADIO_REG_20691(pi, TEMPSENSE_CFG, 0, tempsense_sel_Vbe_Vbg, 0);
	} else if (type == ACPHY_TEMPSENSE_VBE) {
		MOD_RADIO_REG_20691(pi, TEMPSENSE_CFG, 0, tempsense_sel_Vbe_Vbg, 1);
	} else {
		PHY_ERROR(("Unsupported, supported types are"));
		PHY_ERROR((" ACPHY_TEMPSENSE_VBE/ACPHY_TEMPSENSE_VBG\n"));
		return BCME_ERROR;
	}
	return BCME_OK;
}

static int32
wlc_phy_tempsense_phy_cleanup_acphy_tiny(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	acphy_tempsense_phyregs_t *porig = &(pi_ac->ac_tempsense_phyregs_orig);
	uint8 core = 0;

	/* # restore T/R and external PA states */
	WRITE_PHYREG(pi, RxFeCtrl1, porig->RxFeCtrl1);
	WRITE_PHYREG(pi, RxSdFeConfig6, porig->RxSdFeConfig6);
	WRITE_PHYREG(pi, RxSdFeConfig1, porig->RxSdFeConfig1);
	WRITE_PHYREGCE(pi, RfctrlIntc, core, porig->RfctrlIntc[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideAuxTssi, core, porig->RfctrlOverrideAuxTssi[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreAuxTssi1, core, porig->RfctrlCoreAuxTssi1[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideRxPus, core, porig->RfctrlOverrideRxPus[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreRxPus, core, porig->RfctrlCoreRxPus[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideTxPus, core, porig->RfctrlOverrideTxPus[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreTxPus, core, porig->RfctrlCoreTxPus[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideLpfSwtch, core, porig->RfctrlOverrideLpfSwtch[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreLpfSwtch, core, porig->RfctrlCoreLpfSwtch[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideAfeCfg, core, porig->RfctrlOverrideAfeCfg[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg1, core, porig->RfctrlCoreAfeCfg1[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreAfeCfg2, core, porig->RfctrlCoreAfeCfg2[core]);
	WRITE_PHYREGCE(pi, RfctrlOverrideGains, core, porig->RfctrlOverrideGains[core]);
	WRITE_PHYREGCE(pi, RfctrlCoreLpfGain, core, porig->RfctrlCoreLpfGain[core]);
	return BCME_OK;
}

static int32
wlc_phy_tempsense_radio_cleanup_acphy_tiny(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	tempsense_radioregs_tiny_t *porig =
		&(pi_ac->ac_tempsense_radioregs_orig.u.acphy_tempsense_radioregs_tiny);

	/* # Get back old values */
	write_radio_reg(pi, RADIO_REG_20691(pi, TEMPSENSE_OVR1, 0), porig->tempsense_ovr1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TEMPSENSE_CFG, 0), porig->tempsense_cfg[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TESTBUF_OVR1, 0), porig->testbuf_ovr1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TESTBUF_CFG1, 0), porig->testbuf_cfg1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_OVR1, 0), porig->auxpga_ovr1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_CFG1, 0), porig->auxpga_cfg1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, AUXPGA_VMID, 0), porig->auxpga_vmid[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TIA_CFG9, 0), porig->tia_cfg9[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, ADC_OVR1, 0), porig->adc_ovr1[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, ADC_CFG10, 0), porig->adc_cfg10[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TIA_CFG5, 0), porig->tia_cfg5[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, RX_BB_2G_OVR_EAST, 0), porig->rx_bb_2g_ovr_east[0]);
	write_radio_reg(pi, RADIO_REG_20691(pi, TIA_CFG7, 0), porig->tia_cfg7[0]);

	return BCME_OK;
}

/* 20693 Radio functions */
static void
wlc_phy_radio20693_vcocal(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
}

static void
wlc_phy_radio20693_upd_prfd_values(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
}

static void
wlc_phy_radio20693_lpf_tx_set(phy_info_t *pi, int8 bq_bw, int8 bq_gain,
	int8 rc_bw_ofdm, int8 rc_bw_cck)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);

	wlc_phy_radio20693_rccal(pi);
}

static int8
wlc_phy_radio20693_minipmu_cal(phy_info_t *pi)
{
	uint8 calsuccesful = 1;

	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
	if (calsuccesful == 1) {
		/* FIXIT-20693: Return 0 for now. */
		return  0;
	} else {
		return -1;
	}
}

static void
wlc_phy_switch_radio_acphy_20693(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);

	/* minipmu_cal */
	wlc_phy_radio20693_minipmu_cal(pi);

	/* r cal */
#ifdef ATE_BUILD
	/* ATE firmware performs the rcal and the value is put in the OTP. */
	wlc_phy_radio20693_rcal(pi, 2);
#else
	wlc_phy_radio20693_rcal(pi, 1);
#endif // endif
}

static void
wlc_phy_set_regtbl_on_band_change_acphy_20693(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
}

static void
wlc_phy_set_reg_on_reset_acphy_20693(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
}

static void
wlc_phy_radio20693_pwron_seq(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);

	/* Update preferred values (not required for uCode PM) */
	wlc_phy_radio20693_upd_prfd_values(pi);
}

static void
wlc_phy_radio20693_rccal(phy_info_t *pi)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);
}

static void
wlc_phy_radio20693_rcal(phy_info_t *pi, uint8 mode)
{
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);

	/* Skip this function for QT */
	if (ISSIM_ENAB(pi->sh->sih))
		return;
}

static void
wlc_phy_chanspec_radio20693_setup(phy_info_t *pi, const void *chan_info, uint8 toggle_logen_reset)
{
	ASSERT(chan_info != NULL);
	ASSERT(RADIOID(pi->pubpi.radioid) == BCM20693_ID);

	PHY_TRACE(("wl%d: %s\n", pi->sh->unit, __FUNCTION__));

	wlc_phy_radio20693_xtal_tune_prep(pi);

	/* Do a VCO cal after writing the tuning table regs */
	wlc_phy_radio20693_vcocal(pi);

	wlc_phy_radio20693_xtal_tune(pi);
}

static void
wlc_phy_radio20693_xtal_tune_prep(phy_info_t *pi)
{
}

static void
wlc_phy_radio20693_xtal_tune(phy_info_t *pi)
{
}

static void
wlc_phy_radio20693_vco_opt(phy_info_t *pi, uint8 vco_mode)
{
}

static void
wlc_phy_radio20693_afecal(phy_info_t *pi)
{
}

#ifdef WL_PROXDETECT
#undef TOF_TEST_TONE

#ifdef WL_PROXD_SEQ

static void wlc_phy_tof_sc_acphy(phy_info_t *pi, bool setup, int sc_start, int sc_stop, uint16 cfg)
{
	uint16 phy_ctl;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	phy_ctl = R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param) & ~((1<<4) | (1<<5));
	W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl);
	WRITE_PHYREG(pi, RxFeTesMmuxCtrl,
	             (0x40 | (pi_ac->tof_core <<
	                      ACPHY_RxFeTesMmuxCtrl_samp_coll_core_sel_SHIFT(0))));
	WRITE_PHYREG(pi, AdcDataCollect, 0);
	if (setup) {
	  acphy_set_sc_startptr(pi, (uint32)sc_start);
	  acphy_set_sc_stopptr(pi, (uint32)sc_stop);
	  if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
	    uint32 pmu_chipctReg5 = si_pmu_chipcontrol(pi->sh->sih,
	                                               PMU_CHIPCTL5, 0, 0) & 0xcfe0ffff;
	    pmu_chipctReg5 |= (0x1036 << 16);
	    si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL5, 0xFFFFFFFF, pmu_chipctReg5);
	    pmu_chipctReg5 |= (1 << 19);
	    si_pmu_chipcontrol(pi->sh->sih, PMU_CHIPCTL5, 0xFFFFFFFF, pmu_chipctReg5);
	  }
	}
	if (cfg) {
	  W_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param, phy_ctl | ((1<<4) | (1<<5)));
	  WRITE_PHYREG(pi, AdcDataCollect, cfg);
	}
}

static int wlc_phy_tof_sc_read_acphy(phy_info_t *pi, bool iq, int n, cint32* pIn,
                                     int16 sc_ptr, int16 sc_base_ptr, int16* p_sc_start_ptr)
{
	d11regs_t *regs = pi->regs;
	uint32 dataL = 0, dataH, data;
	cint32* pEnd = pIn + n;
	int nbits = 0, n_out = 0;
	int32* pOut = (int32*)pIn;
	int16 sc_end_ptr;

	if (sc_ptr <= 0) {
	  /* Offset from sc_base_ptr */
	  sc_ptr = (-sc_ptr >> 2);
	  *p_sc_start_ptr = (sc_ptr << 2);
	  if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev))
	    sc_ptr = 3*sc_ptr;
	  else
	    sc_ptr = (sc_ptr << 2);
	  sc_ptr += sc_base_ptr;
	} else {
	  /* Actual address */
	  if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
	    sc_ptr = (sc_ptr - sc_base_ptr)/3;
	    *p_sc_start_ptr = 4*sc_ptr + sc_base_ptr;
	    sc_ptr = 3*sc_ptr + sc_base_ptr;
	  } else {
	    *p_sc_start_ptr = sc_ptr;
	  }
	}
	sc_end_ptr = R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr);
	W_REG(pi->sh->osh, &pi->regs->tplatewrptr, ((uint32)sc_ptr << 2));
	while ((pIn < pEnd) && (sc_ptr < sc_end_ptr)) {
	  if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
	    dataH = dataL;
	    dataL = (uint32)R_REG(pi->sh->osh, &regs->tplatewrdata);
	    nbits += 32;
	    do {
	      nbits -= 12;
	      data = (dataL >> nbits);
	      if (nbits)
		data |= (dataH << (32 - nbits));
	      if (nbits & 4) {
		pIn->q = (int32)(data) & 0xfff;
	      } else {
		pIn->i = (int32)(data) & 0xfff;
		pIn++;
		n_out++;
	      }
	    } while (nbits >= 12);
	  } else {
	    dataL = (uint32)R_REG(pi->sh->osh, &regs->tplatewrdata);
	    pIn->i = (int32)(dataL & 0xfff);
	    pIn->q = (int32)((dataL >> 16) & 0xfff);
	    pIn++;
	    n_out++;
	  }
	  sc_ptr++;
	}
	if (iq) {
	  int32 datum;

	  n = 2*n_out;
	  while (n-- > 0) {
	    datum = *pOut;
	    if (datum > 2047)
	      datum -= 4096;
	    *pOut++ = datum;
	  }
	}
	return n_out;
}

#define k_tof_filt_1_mask   0x1
#define k_tof_filt_neg_mask 0xc
#define k_tof_filt_non_zero_mask 0x3

static int
wlc_tof_rfseq_event_offset(phy_info_t *pi, uint16 event, uint16* rfseq_events)
{
	int i;

	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 16, (uint32)0, 16, (void*)rfseq_events);

	for (i = 0; i < 16; i++) {
	  if (rfseq_events[i] == event) {
	    break;
	  }
	}
	return i;
}

static void wlc_phy_tof_mf(phy_info_t *pi, int n, cint32* pIn, bool seq, int nF,
                           const uint32* pF, int a, int b, int cfo, int s1, int k2, int s2)
{
	int i, k;
	cint32 *pTmp;
	int32 tmp;
	pTmp = pIn;
	for (i = 0; i < n; i++) {
	  if (seq) {
	    pTmp->q = 0;
	    pTmp->i = (int32)s1;
	  } else {
	    pTmp->q = (pTmp->q + ((pTmp->i*(int32)a)>>10)) << s1;
	    pTmp->i = (pTmp->i + ((pTmp->i*(int32)b)>>10)) << s1;
	  }
	  pTmp++;
	}

	if (!seq) {
	  if (cfo) {
	  }
	  wlapi_fft(pi->sh->physhim, n, (void*)pIn, (void*)pIn, 2);
	}

	pTmp = pIn;
	for (k = 0; k < 2; k++) {
	  for (i = 0; i < nF; i++) {
	    uint32 f;
	    int j;

	    f = *pF++;
	    for (j = 0; j < 32; j += 4) {
	      if (f & k_tof_filt_non_zero_mask) {
		if (!(f & k_tof_filt_1_mask)) {
		  tmp = pTmp->q;
		  pTmp->q = pTmp->i;
		  pTmp->i = -tmp;
		}
		if (f & k_tof_filt_neg_mask) {
		  pTmp->i = -pTmp->i;
		  pTmp->q = -pTmp->q;
		}
	      } else {
		pTmp->i = 0;
		pTmp->q = 0;
	      }
	      pTmp++;
	      f = f >> 4;
	    }
	  }
	  if (!k) {
	    for (i = 0; i < (n - 2*8*nF); i++) {
	      pTmp->i = 0;
	      pTmp->q = 0;
	      pTmp++;
	    }
	  }
	}

	wlapi_fft(pi->sh->physhim, n, (void*)pIn, (void*)pIn, 2);

	if (s2) {
	  int32 *pTmpIQ, m2 = (int32)(1 << (s2 - 1));
	  pTmpIQ = (int32*)pIn;
	  for (i = 0; i < 2*n; i++) {
	    tmp = ((k2*(*pTmpIQ) + m2) >> s2);
	    *pTmpIQ++ = tmp;
	  }
	}
}

#define k_tof_rfseq_tiny_bundle_base 8
#define k_tof_seq_tiny_rx_fem_gain_offset 0x29
#define k_tof_seq_tiny_tx_fem_gain_offset 0x2b
const uint16 k_tof_seq_tiny_tbls[] = {
	ACPHY_TBL_ID_RFSEQ,
	0x260,
	15,
	0x42, 0x10, 0x8b, 0x9b, 0xaa, 0xb9, 0x8c, 0x9c, 0x9d,
	0xab, 0x8d, 0x9e, 0x43, 0x42, 0x1f,
	ACPHY_TBL_ID_RFSEQ,
	0x290,
	14,
	0x42, 0x10, 0x88, 0x98, 0xa8, 0xb8, 0x89, 0x99, 0xa9,
	0x8a, 0x9a, 0x43, 0x42, 0x1f,
	ACPHY_TBL_ID_RFSEQ,
	0x2f0,
	15,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04, 0x04,
	0x04, 0x01, 0x04, 0x1e, 0x01, 0x01,
	ACPHY_TBL_ID_RFSEQ,
	0x320,
	14,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04, 0x04,
	0x01, 0x04, 0x1e, 0x01, 0x01,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x008,
	18,
	0x0000, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,
	0x0000, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x018,
	21,
	0x0009, 0x8000, 0x0007, 0xf009, 0x8066, 0x0007, 0xf009, 0x8066, 0x0004,
	0x00c9, 0x8060, 0x0007, 0xf7d9, 0x8066, 0x0007, 0xf7f9, 0x8066, 0x0007,
	0xf739, 0x8066, 0x0004,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x028,
	12,
	0x0009, 0x0000, 0x0000, 0x0229, 0x0000, 0x0000, 0x0019, 0x0000, 0x0000,
	0x0099, 0x0000, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x038,
	6,
	0x0fc9, 0x00a6, 0x0000, 0x0fc9, 0x00a6, 0x0000,
};
#define k_tof_seq_rx_gain_tiny ((0 << 13) | (0 << 10) | (5 << 6) | (0 << 3) | (4 << 0))
#define k_tof_seq_rx_loopback_gain_tiny ((0 << 13) | (0 << 10) | (0 << 6) | (0 << 3) | (0 << 0))

#define k_tof_rfseq_bundle_base 8
#define k_tof_seq_rx_fem_gain_offset 0x29
#define k_tof_seq_tx_fem_gain_offset 0x2b
const uint16 k_tof_seq_tbls[] = {
	ACPHY_TBL_ID_RFSEQ,
	0x260,
	14,
	0x10, 0x8b, 0x9b, 0xaa, 0xb9, 0xc9, 0xd9, 0x8c, 0x9c,
	0x9d, 0xab, 0x8d, 0x9e, 0x1f,
	ACPHY_TBL_ID_RFSEQ,
	0x290,
	13,
	0x10, 0x88, 0x98, 0xa8, 0xb8, 0xc8, 0xd8, 0x89, 0x99,
	0xa9, 0x8a, 0x9a, 0x1f,
	ACPHY_TBL_ID_RFSEQ,
	0x2f0,
	14,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04,
	0x04, 0x04, 0x01, 0x04, 0x01,
	ACPHY_TBL_ID_RFSEQ,
	0x320,
	13,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x04,
	0x04, 0x01, 0x04, 0x01,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x008,
	18,
	0x0000, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,
	0x0000, 0x0030, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0020, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x018,
	21,
	0x0009, 0x8000, 0x000f, 0xff09, 0x8066, 0x000f, 0xff09, 0x8066, 0x000c,
	0x00c9, 0x8060, 0x000f, 0xffd9, 0x8066, 0x000f, 0xfff9, 0x8066, 0x000f,
	0xff39, 0x8066, 0x000c,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x028,
	12,
	0x0009, 0x0000, 0x0000, 0x0229, 0x0000, 0x0000, 0x0019, 0x0000, 0x0000,
	0x0099, 0x0000, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x038,
	6,
	0x0fc9, 0x00a6, 0x0000, 0x0fc9, 0x00a6, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x048,
	6,
	0x2099, 0x586e, 0x0000, 0x1519, 0x586e, 0x0000,
	ACPHY_TBL_ID_RFSEQBUNDLE,
	0x058,
	6,
	0x2409, 0xc040, 0x000c, 0x6b89, 0xc040, 0x000c,
};
#define k_tof_seq_rx_gain ((0 << 13) | (2 << 10) | (2 << 6) | (6 << 3) | (4 << 0))
#define k_tof_seq_rx_loopback_gain ((2 << 13) | (4 << 10) | (3 << 6) | (3 << 3) | (3 << 0))

#define k_tof_seq_rfseq_gain_base 0x1d0
#define k_tof_seq_rfseq_rx_gain_offset 7
#define k_tof_seq_rfseq_loopback_gain_offset  4

#define k_tof_seq_shm_offset 4
#define k_tof_seq_shm_setup_regs_offset 2*(0 + k_tof_seq_shm_offset)
#define k_tof_seq_shm_setup_regs_len    15
#define k_tof_seq_shm_setup_vals_offset 2*(15 + k_tof_seq_shm_offset)
#define k_tof_seq_shm_setup_vals_len    16
#define k_tof_set_shm_restr_regs_offset 2*(7 + k_tof_seq_shm_offset)
#define k_tof_set_shm_restr_vals_offset 2*(31 + k_tof_seq_shm_offset)
#define k_tof_set_shm_restr_vals_len    8
#define k_tof_seq_shm_fem_radio_hi_gain_offset 2*(18 + k_tof_seq_shm_offset)
#define k_tof_seq_shm_fem_radio_lo_gain_offset 2*(39 + k_tof_seq_shm_offset)
#define k_tof_seq_shm_dly_offset 2*(40 + k_tof_seq_shm_offset)
#define k_tof_seq_shm_dly_len    (3*2)

#define k_tof_seq_sc_start 1024
#define k_tof_seq_sc_stop  (k_tof_seq_sc_start + 2730)

#define k_tof_rfseq_dc_run_event 0x43
#define k_tof_rfseq_epa_event    0x4
#define k_tof_rfseq_end_event    0x1f
#define k_tof_rfseq_tssi_event   0x35
#define k_tof_rfseq_ipa_event    0x3

#define k_tof_sc_FS_80MHz 160

const uint16 k_tof_seq_ucode_regs[k_tof_seq_shm_setup_regs_len] = {
	ACPHY_RxControl(0),
	ACPHY_TableID(0),
	ACPHY_TableOffset(0),
	(ACPHY_TableDataWide(0) | (7 << 12)),
	ACPHY_TableID(0),
	ACPHY_TableOffset(0),
	ACPHY_TableDataLo(0),
	ACPHY_TableOffset(0),
	ACPHY_TableDataLo(0),
	ACPHY_RfseqMode(0),
	ACPHY_sampleCmd(0),
	ACPHY_RfseqMode(0),
	ACPHY_SlnaControl(0),
	ACPHY_AdcDataCollect(0),
	ACPHY_RxControl(0),
};

#define k_tof_seq_log2_n 8
#define k_tof_seq_n (1 << k_tof_seq_log2_n)
#define k_tof_seq_M ((10000 * k_tof_seq_n)/ k_tof_sc_FS_80MHz)
#define tof_w(x, n) (x - (k_tof_seq_n/2) + (n*k_tof_seq_n))

const uint16 k_tof_ucode_dlys_us[2][5] = {
	{1, 6, 6, tof_w(750,4), tof_w(750,0)}, /* RX -> TX */
	{2, 6, 6, tof_w(1850,-4), tof_w(1850,0)}, /* TX -> RX */
};

const uint16 k_tof_seq_fem_gains[] = {
	(8 | (1 << 5) | (1 << 9)), /* fem hi */
	(8 | (1 << 5)), /* fem lo */
};

#define k_tof_seq_in_scale (1<<12)
#define k_tof_seq_out_scale 11
#define k_tof_seq_out_shift 8
#define k_tof_mf_in_shift  0
#define k_tof_mf_out_scale 0
#define k_tof_mf_out_shift 0
#define k_tof_seq_spb_len 8
const uint32 k_tof_seq_spb[2*k_tof_seq_spb_len] = {
	0xee2ee200,
	0xe2e2ee22,
	0xe22eeeee,
	0xeeee2e2e,
	0xe2ee22ee,
	0xe22222e2,
	0xe2e2e22e,
	0x00000eee,
	0x11000000,
	0x1f1f11ff,
	0x1ff11111,
	0x1111f1f1,
	0x1f11ff11,
	0x1fffff1f,
	0x1f1f1ff1,
	0x01fff111,
};

static void
wlc_tof_seq_write_shm_acphy(phy_info_t *pi, int len, uint16 offset, uint16* p)
{
	uint16 p_shm = pi->u.pi_acphy->tof_shm_ptr;

	while (len-- > 0) {
	  wlapi_bmac_write_shm(pi->sh->physhim, (p_shm + offset), *p);
	  p++;
	  offset += 2;
	}
}

static int
wlc_phy_tof_seq_setup_acphy(phy_info_t *pi, bool enter, bool tx, uint8 core)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint8 stall_val;
	uint16 *pSrc, *pEnd;
	uint16 shm[18];
	uint16 tof_rfseq_bundle_offset, rx_ctrl, rfseq_mode, rfseq_trigger, rfseq_offset, mask;
	uint16 wrds_per_us;
	int i;
	bool  suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	cint32* pSeq;

	if (!enter)
	  return BCME_OK;

	if (!CHSPEC_IS80(pi->radio_chanspec) ||
	    ((pi_ac->tof_rfseq_bundle_offset >= k_tof_rfseq_bundle_base) && !TINY_RADIO(pi)) ||
	    ((pi_ac->tof_rfseq_bundle_offset >= k_tof_rfseq_tiny_bundle_base) && TINY_RADIO(pi)) ||
	    (READ_PHYREGFLD(pi, OCLControl1, ocl_mode_enable)))
	  return BCME_ERROR;

	WRITE_PHYREG(pi, sampleLoopCount, 0xffff);
	WRITE_PHYREG(pi, sampleDepthCount, (k_tof_seq_n - 1));
	if (pi_ac->tof_setup_done)
	  return BCME_OK;

	pSeq = (cint32*)MALLOC(pi->sh->osh, k_tof_seq_n*sizeof(cint32));
	if (!pSeq) {
	  return BCME_ERROR;
	}

	pi_ac->tof_tx = tx;
	pi_ac->tof_core = core;
	mask = (1 << pi_ac->tof_core);

	if (!suspend)
	  wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	/* Setup rfcontrol sequence for tx_on / tx_off events */
	tof_rfseq_bundle_offset = pi_ac->tof_rfseq_bundle_offset;
	if (TINY_RADIO(pi)) {
	  pSrc = (uint16*)k_tof_seq_tiny_tbls;
	  pEnd = pSrc + sizeof(k_tof_seq_tiny_tbls)/sizeof(uint16);
	} else {
	  pSrc = (uint16*)k_tof_seq_tbls;
	  pEnd = pSrc + sizeof(k_tof_seq_tbls)/sizeof(uint16);
	}
	while (pSrc != pEnd) {
	  uint32 id, width, len, tbl_len, offset;
	  uint16* pTblData;

	  id = (uint32)*pSrc++;
	  offset = (uint32)*pSrc++;
	  len = (uint32)*pSrc++;
	  if (id == ACPHY_TBL_ID_RFSEQBUNDLE) {
	    width = 48;
	    tbl_len = len / 3;
	    for (i = 0; i < len; i++) {
	      shm[i] = pSrc[i];
	      if ((offset >= 0x10) && ((i % 3) == 0)) {
		shm[i] = (shm[i] & ~7) | mask;
	      }
	    }
	    pTblData = shm;
	  } else {
	    width = 16;
	    tbl_len = len;
	    pTblData = pSrc;
	  }
	  wlc_phy_table_write_acphy(pi, id, tbl_len, offset, width, (void*)pTblData);
	  pSrc += len;
	}
	pi_ac->tof_rfseq_bundle_offset = tof_rfseq_bundle_offset;
	/* Set rx gain during loopback -- cant use rf bundles due to hw bug in 4350 */
	if (TINY_RADIO(pi))
	  shm[0] = k_tof_seq_rx_loopback_gain_tiny;
	else
	  shm[0] = k_tof_seq_rx_loopback_gain;
	wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
	                          (k_tof_seq_rfseq_gain_base + core*0x10
	                           + k_tof_seq_rfseq_loopback_gain_offset),
	                           16, (void*)&shm[0]);
	/* Setup shm which tells ucode sequence of phy reg writes */
	/* before/after triggering sequence */
	rx_ctrl = READ_PHYREG(pi, RxControl);
	rfseq_mode = (READ_PHYREG(pi, RfseqMode) &
	              ~(ACPHY_RfseqMode_CoreActv_override_MASK(0) |
	                ACPHY_RfseqMode_Trigger_override_MASK(0)));
	rfseq_offset = wlc_tof_rfseq_event_offset(pi, k_tof_rfseq_ipa_event, shm);
	wlc_tof_seq_write_shm_acphy(pi,
	                            k_tof_seq_shm_setup_regs_len,
	                            k_tof_seq_shm_setup_regs_offset,
	                            (uint16*)k_tof_seq_ucode_regs);
	bzero((void*)shm, sizeof(shm));
	shm[0] = rx_ctrl | ACPHY_RxControl_dbgpktprocReset_MASK(0); /* first setup */
	shm[1] = ACPHY_TBL_ID_RFSEQBUNDLE;
	if (TINY_RADIO(pi))
	  shm[2] = k_tof_seq_tiny_rx_fem_gain_offset;
	else
	  shm[2] = k_tof_seq_rx_fem_gain_offset;
	shm[3] = k_tof_seq_fem_gains[0] | mask;
	shm[6] = ACPHY_TBL_ID_RFSEQ; /* first restore */
	shm[7] = k_tof_seq_rfseq_gain_base + core*0x10 + k_tof_seq_rfseq_rx_gain_offset;
#ifdef TOF_DBG
	if (TINY_RADIO(pi))
	  shm[8] = k_tof_seq_rx_gain_tiny;
	else
	  shm[8] = k_tof_seq_rx_gain;
#endif // endif
	shm[9] = rfseq_offset;
	shm[10] = k_tof_rfseq_end_event;
	shm[11] = (rfseq_mode | ACPHY_RfseqMode_CoreActv_override_MASK(0));
	shm[12] = ACPHY_sampleCmd_start_MASK(0);
	shm[13] = (rfseq_mode |
	           ACPHY_RfseqMode_Trigger_override_MASK(0) |
	           ACPHY_RfseqMode_CoreActv_override_MASK(0));
	shm[14] = ((~core) & 3) << ACPHY_SlnaControl_SlnaCore_SHIFT(0);
	shm[15] = ACPHY_AdcDataCollect_adcDataCollectEn_MASK(0); /* last setup */
	wlc_tof_seq_write_shm_acphy(pi,
	                            k_tof_seq_shm_setup_vals_len,
	                            k_tof_seq_shm_setup_vals_offset,
	                            shm);
	shm[10] = k_tof_rfseq_ipa_event;
	shm[11] = rfseq_mode;
	shm[12] = ACPHY_sampleCmd_stop_MASK(0);
	shm[13] = rfseq_mode;
	shm[14] = READ_PHYREG(pi, SlnaControl);
	shm[15] = 0;
	shm[16] = rx_ctrl; /* last restore */
	wlc_tof_seq_write_shm_acphy(pi,
	                            k_tof_set_shm_restr_vals_len,
	                            k_tof_set_shm_restr_vals_offset,
	                            &shm[9]);

	/* Setup delays and triggers */
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev))
	  wrds_per_us = ((3*k_tof_sc_FS_80MHz) >> 2);
	else
	  wrds_per_us = k_tof_sc_FS_80MHz;
	pSrc = shm;
	rfseq_trigger = READ_PHYREG(pi, RfseqTrigger) &
	        ACPHY_RfseqTrigger_en_pkt_proc_dcc_ctrl_MASK(0);
	for (i = 0; i < 3; i++) {
	  *pSrc++ = k_tof_ucode_dlys_us[(tx ? 1 : 0)][i] * wrds_per_us;
	  if (i ^ tx)
	    *pSrc = rfseq_trigger | ACPHY_RfseqTrigger_ocl_shut_off_MASK(0);
	  else
	    *pSrc = rfseq_trigger | ACPHY_RfseqTrigger_ocl_reset2rx_MASK(0);
	  pSrc++;
	}
	shm[k_tof_seq_shm_dly_len-1] = rfseq_trigger; /* Restore value */
	shm[k_tof_seq_shm_dly_len] = ACPHY_PhyStatsGainInfo0(0) + 0x200*core;
	wlc_tof_seq_write_shm_acphy(pi,
	                            (k_tof_seq_shm_dly_len + 1),
	                            k_tof_seq_shm_dly_offset,
	                            shm);
	/* Setup sample play */
	wlc_phy_tof_mf(pi, k_tof_seq_n, pSeq, TRUE,
	               k_tof_seq_spb_len, k_tof_seq_spb,
	               0, 0, 0,
	               k_tof_seq_in_scale, k_tof_seq_out_scale, k_tof_seq_out_shift);
#ifdef TOF_TEST_TONE
	for (i = 0; i < k_tof_seq_n; i++) {
	  const int32 v[16] = {96, 89, 68, 37, 0, -37, -68, -89, -96, -89, -68, -37, 0, 37, 68, 89};
	  pSeq[i].i = v[i & 0xf];
	  pSeq[i].q = v[(i-4) & 0xf];
	}
#endif // endif
	wlc_phy_loadsampletable_acphy(pi, pSeq, k_tof_seq_n, FALSE, TRUE);

#ifdef TOF_DBG
	printf("SETUP CORE %d\n", core);
#endif // endif
	MFREE(pi->sh->osh, pSeq, k_tof_seq_n*sizeof(cint32));
	ACPHY_ENABLE_STALL(pi, stall_val);
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	if (!suspend)
	  wlapi_enable_mac(pi->sh->physhim);

	pi_ac->tof_setup_done = TRUE;
	return BCME_OK;
}

int
wlc_phy_seq_ts_acphy(phy_info_t *pi, int n, cint32* p_buffer, int tx,
                     int cfo, int adj, void* pparams, int32* p_ts, int32* p_seq_len, uint32* p_raw)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	int16 sc_ptr;
	int32 ts[2], dT;
	int i, n_out, a, b;

	if (!CHSPEC_IS80(pi->radio_chanspec) || (n < k_tof_seq_n))
	  return BCME_ERROR;
	a = READ_PHYREGCE(pi, Core1RxIQCompA, pi_ac->tof_core);
	b = READ_PHYREGCE(pi, Core1RxIQCompB, pi_ac->tof_core);
	if (a > 511)
	  a -= 1024;
	if (b > 511)
	  b -= 1024;

	for (i = 0; i < 2; i++) {
	  n_out = wlc_phy_tof_sc_read_acphy(pi, TRUE, n, p_buffer,
	                                    -(k_tof_ucode_dlys_us[tx][3+i]),
	                                    k_tof_seq_sc_start, &sc_ptr);
	  if (n_out != n)
	    return BCME_ERROR;
#ifdef TOF_DBG
	  if (p_raw && (2*(n_out + 1) <= k_tof_collect_Hraw_size)) {
	    int j;
	    for (j = 0; j < n_out; j++) {
	      *p_raw++ = (uint32)(p_buffer[j].i & 0xffff) |
	              ((uint32)(p_buffer[j].q & 0xffff) << 16);
	    }
	    *p_raw++ = (uint32)((int32)a & 0xffff) | (uint32)(((int32)b & 0xffff) << 16);
	  }
#endif // endif
#if defined(TOF_TEST_TONE)
	  ts[i] = 0;
#else
	  wlc_phy_tof_mf(pi, k_tof_seq_n, p_buffer, FALSE,
	                 k_tof_seq_spb_len, k_tof_seq_spb,
	                 a, b, (i)?cfo:0,
	                 k_tof_mf_in_shift,
	                 k_tof_mf_out_scale,
	                 k_tof_mf_out_shift);
	  if (wlapi_tof_pdp_ts(k_tof_seq_log2_n, (void*)p_buffer, k_tof_sc_FS_80MHz,
	                       i, pparams, &ts[i], NULL) != BCME_OK)
	    return BCME_ERROR;
#endif // endif
	}

	ts[0] += adj;
	dT = (ts[tx] - ts[tx ^ 1]);
	if (dT < 0)
	  dT += k_tof_seq_M;
	*p_ts = dT;
	*p_seq_len = k_tof_seq_M;
	return BCME_OK;
}

#if defined(TOF_DBG)
#define k_tof_dbg_sc_delta 32
int
wlc_phy_tof_dbg_acphy(wlc_phy_t *ppi, int arg)
{
	phy_info_t *pi = (phy_info_t*)ppi;
	cint32 buf[k_tof_dbg_sc_delta];
	int16  p, p_start;
	int i = 0, n = 0;
	bool  suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	uint8 stall_val;

	if (!suspend)
	  wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);
	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	ACPHY_DISABLE_STALL(pi);

	p = k_tof_seq_sc_start;
	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev))
	  p += ((k_tof_dbg_sc_delta>>2)*arg*3);
	else
	  p += (k_tof_dbg_sc_delta*arg);
	if (arg >= 255) {
	  int j;
	  uint16 v, offset = 0;
	  uint16 bundle[3*16];
	  const uint16 bundle_addr[] = {0x00, 0x10, 0x20, 0x30, 0x40, 0x50};
	  for (i = 0; i < sizeof(bundle_addr)/sizeof(uint16); i++) {
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQBUNDLE,
	                             8, bundle_addr[i]+8, 48, (void*)bundle);
	    for (j = 0; j < 16; j++) {
	      printf("RFBUNDLE 0x%x : 0x%04x%04x%04x\n",
	             (bundle_addr[i]+j),
	             bundle[3*j+2], bundle[3*j+1], bundle[3*j+0]);
	    }
	  }
	  for (i = 0; i < 16; i++) {
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x290 + i), 16, (void*)&bundle[0]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x320 + i), 16, (void*)&bundle[1]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x260 + i), 16, (void*)&bundle[2]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x2f0 + i), 16, (void*)&bundle[3]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x000 + i), 16, (void*)&bundle[4]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x070 + i), 16, (void*)&bundle[5]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x010 + i), 16, (void*)&bundle[6]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1, (0x080 + i), 16, (void*)&bundle[7]);
	    printf("RFSEQ RXs 0x%04x 0x%04x TXs 0x%04x 0x%04x TX 0x%04x 0x%04x RX 0x%04x 0x%04x\n",
	           bundle[0], bundle[1], bundle[2], bundle[3], bundle[4], bundle[5], bundle[6],
	           bundle[7]);
	  }
	  for (i = 0; i < 3; i++) {
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
	                             (k_tof_seq_rfseq_gain_base + i*0x10 +
	                              k_tof_seq_rfseq_loopback_gain_offset), 16, (void*)&bundle[0]);
	    wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_RFSEQ, 1,
	                             (k_tof_seq_rfseq_gain_base + i*0x10 +
	                              k_tof_seq_rfseq_rx_gain_offset), 16, (void*)&bundle[1]);
	    printf("GC%d  LBK 0x%04x RX 0x%04x\n", i, bundle[0], bundle[1]);
	  }
	  offset = k_tof_seq_shm_setup_regs_offset;
	  n = 46;
	  while (n-- > 0) {
	    v = wlapi_bmac_read_shm(pi->sh->physhim, (pi->u.pi_acphy->tof_shm_ptr + offset));
	    printf("SHM %d 0x%04x\n", ((offset - k_tof_seq_shm_setup_regs_offset) >> 1), v);
	    offset += 2;
	  }
	  n = 1;
	} else if (arg == 252) {
	  printf("MAC 0x%x STRT %d STP %d CUR %d\n",
	         R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param),
	         R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStartPtr),
	         R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStopPtr),
	         R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr));
	  n = 1;
	} else {
	  if (arg == 0) {
	    printf("MAC 0x%x STRT %d STP %d CUR %d ",
	           R_REG(pi->sh->osh, &pi->regs->psm_phy_hdr_param),
	           R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStartPtr),
	           R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectStopPtr),
	           R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr));
	  }
	  if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev))
	    n = (((int)R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr) - p)/3) << 2;
	  else
	    n = ((int)R_REG(pi->sh->osh, &pi->regs->PHYREF_SampleCollectCurPtr) - p);
	  if (n > k_tof_dbg_sc_delta)
	    n = k_tof_dbg_sc_delta;
	  if (n > 0) {
	    arg = wlc_phy_tof_sc_read_acphy(pi, TRUE, n, buf, p, k_tof_seq_sc_start, &p_start);
	    i = 0;
	    while (i < arg) {
	      if (buf[i].i > 2047)
		buf[i].i -= 4096;
	      if (buf[i].q > 2047)
		buf[i].q -= 4096;
	      printf("SD %4d %d %d\n", p_start, buf[i].i, buf[i].q);
	      i++;
	      p_start++;
	    }
	  } else {
	    printf("\n");
	  }
	}

	ACPHY_ENABLE_STALL(pi, stall_val);
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);
	if (!suspend)
	  wlapi_enable_mac(pi->sh->physhim);

	return (n > 0) ? 1 : 0;
}
#endif /* defined(TOF_DBG) */

#endif /* WL_PROXD_SEQ */

void wlc_phy_tof_reset_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	pi_ac->tof_setup_done = FALSE;
	pi_ac->tof_active = FALSE;
	pi_ac->tof_smth_forced = FALSE;
	pi_ac->tof_rfseq_bundle_offset = 0;
	pi_ac->tof_shm_ptr = (wlapi_bmac_read_shm(pi->sh->physhim, M_TOF_PTR) * 2);
}

int wlc_phy_tof_acphy(phy_info_t *pi, bool enter, bool tx, bool hw_adj, bool seq_en, int core)
{
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	bool change = pi_ac->tof_active != enter;
	bool  suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	int retval = BCME_OK;

	if (change) {
#ifdef WL_PROXD_SEQ
	  if (seq_en) {
	    retval = wlc_phy_tof_seq_setup_acphy(pi, enter, tx, core);

	  } else
#endif // endif
	  {
		  pi_ac->tof_setup_done = FALSE;
	    if (!suspend)
	      wlapi_suspend_mac_and_wait(pi->sh->physhim);
	    if (enter) {
	      /* Save state fdiqcomp and disable */
	      pi_ac->tof_rx_fdiqcomp_enable = (uint8)READ_PHYREGFLD(pi, rxfdiqImbCompCtrl,
	                                                            rxfdiqImbCompEnable);
	      pi_ac->tof_tx_fdiqcomp_enable = (uint8)READ_PHYREGFLD(pi, fdiqImbCompEnable,
	                                                            txfdiqImbCompEnable);
	      MOD_PHYREG(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable, 0);
	      MOD_PHYREG(pi, fdiqImbCompEnable, txfdiqImbCompEnable, 0);
	      if (hw_adj) {
		/* Save channel smoothing state and enable special  mode */
		pi_ac->tof_smth_enable = pi_ac->acphy_enable_smth;
		pi_ac->tof_smth_dump_mode = pi_ac->acphy_smth_dump_mode;
		wlc_phy_smth(pi, SMTH_ENABLE, SMTH_TIMEDUMP_AFTER_IFFT);
		pi_ac->tof_smth_forced = TRUE;
	      }
	    } else {
	      /* Restore fdiqcomp state */
	      MOD_PHYREG(pi, rxfdiqImbCompCtrl, rxfdiqImbCompEnable,
	                 pi_ac->tof_rx_fdiqcomp_enable);
	      MOD_PHYREG(pi, fdiqImbCompEnable, txfdiqImbCompEnable,
	                 pi_ac->tof_tx_fdiqcomp_enable);
	      if (pi_ac->tof_smth_forced) {
		/* Restore channel smoothing state */
		pi_ac->tof_smth_forced = FALSE;
		wlc_phy_smth(pi, pi_ac->tof_smth_enable, pi_ac->tof_smth_dump_mode);
	      }
	    }

	    wlc_phy_resetcca_acphy(pi);
	    if (!suspend)
	      wlapi_enable_mac(pi->sh->physhim);
	  }
	}
	pi_ac->tof_active = enter;
	return retval;
}

/* Unpacks floating point to fixed point for further processing */
/* Fixed point format:

	A.fmt = TRUE
			sign      real         sign       image             exp
			|-|--------------------||-|--------------------||----------|
	size:            nman                   nman              nexp

	B.fmt = FALSE
	         exp     sign		 image                  real
			|----------||-|-||-------------------||--------------------|
	size:		 nexp	 1 1          nman					nman

	When Hi is NULL, we return "real * real + image * image" in Hr array, otherwise
	real and image is save in Hr and Hi.

	When autoscale is TRUE, calculate the max shift to save fixed point value into uint32
*/

/*
	H holds upacked 32 bit data when the function is called.
	H and Hout could partially overlap.
	H and h can not overlap
*/

#define k_tof_unpack_sgn_mask (1<<31)
static int
wlc_unpack_float_acphy(int nbits, int autoscale, int shft,
	int fmt, int nman, int nexp, int nfft, uint32* H, cint32* Hout, int32* h)
{
	int e_p, maxbit, e, i, pwr_shft = 0, e_zero, sgn;
	int n_out, e_shift;
	int8 He[256];
	int32 vi, vq, *pOut;
	uint32 x, iq_mask, e_mask, sgnr_mask, sgni_mask;

	/* when fmt is TRUE, the size nman include its sign bit */
	/* so need to minus one to get value mask */
	if (fmt)
		iq_mask = (1<<(nman-1))- 1;
	else
		iq_mask = (1<<nman)- 1;

	e_mask = (1<<nexp)-1;	/* exp part mask */
	e_p = (1<<(nexp-1));	/* max abs value of exp */

	if (h) {
		/* Set pwr_shft to make sure that square sum can be hold by uint32 */
		pwr_shft = (2*nman + 1 - 31);
		if (pwr_shft < 0)
			pwr_shft = 0;
		pwr_shft = (pwr_shft + 1)>>1;
		sgnr_mask = 0;	/* don't care sign for square sum */
		sgni_mask = 0;
		e_zero = -(2*(nman - pwr_shft) + 1);
		pOut = (int32*)h;
		n_out = nfft;
		e_shift = 0;
	} else {
		/* Set the location of sign bit */
		if (fmt) {
			sgnr_mask = (1 << (nexp + 2*nman - 1));
			sgni_mask = (sgnr_mask >> nman);
		} else {
			sgnr_mask = (1 << 2*nman);
			sgni_mask = (sgnr_mask << 1);
		}
		e_zero = -nman;
		pOut = (int32*)Hout;
		n_out = (nfft << 1);
		e_shift = 1;
	}

	maxbit = -e_p;
	for (i = 0; i < nfft; i++) {
		/* get the real, image and exponent value */
		if (fmt) {
			vi = (int32)((H[i] >> (nexp + nman)) & iq_mask);
			vq = (int32)((H[i] >> nexp) & iq_mask);
			e =   (int)(H[i] & e_mask);
		} else {
			vi = (int32)(H[i] & iq_mask);
			vq = (int32)((H[i] >> nman) & iq_mask);
			e = (int32)((H[i] >> (2*nman + 2)) & e_mask);
		}

		/* adjust exponent */
		if (e >= e_p)
			e -= (e_p << 1);

		if (h) {
			/* calculate square sum of real and image data */
			vi = (vi >> pwr_shft);
			vq = (vq >> pwr_shft);
			h[i] = vi*vi + vq*vq;
			vq = 0;
			e = 2*(e + pwr_shft);
		}

		He[i] = (int8)e;

		/* auto scale need to find the maximus exp bits */
		x = (uint32)vi | (uint32)vq;
		if (autoscale && x) {
			uint32 m = 0xffff0000, b = 0xffff;
			int s = 16;

			while (s > 0) {
				if (x & m) {
					e += s;
					x >>= s;
				}
				s >>= 1;
				m = (m >> s) & b;
				b >>= s;
			}
			if (e > maxbit)
				maxbit = e;
		}

		if (!h) {
			if (H[i] & sgnr_mask)
				vi |= k_tof_unpack_sgn_mask;
			if (H[i] & sgni_mask)
				vq |= k_tof_unpack_sgn_mask;
			Hout[i].i = vi;
			Hout[i].q = vq;
		}
	}

	/* shift bits */
	if (autoscale)
		shft = nbits - maxbit;

	/* scal and sign */
	for (i = 0; i < n_out; i++) {
		e = He[(i >> e_shift)] + shft;
		vi = *pOut;
		sgn = 1;
		if (!h && (vi & k_tof_unpack_sgn_mask)) {
			sgn = -1;
			vi &= ~k_tof_unpack_sgn_mask;
		}
		/* trap the zero case */
		if (e < e_zero) {
			vi = 0;
		} else if (e < 0) {
			e = -e;
			vi = (vi >> e);
		} else {
			vi = (vi << e);
		}
		*pOut++ = (int32)sgn*vi;
	}

	return shft;
}

/* Get channel frequency response for deriving 11v rx timestamp */
int
wlc_phy_chan_freq_response_acphy(phy_info_t *pi,
	int len, int nbits, cint32* H, uint32* Hraw)
{
	uint32 *pTmp, *pIn;
	int i, i_l, i_r, n1, n2, n3, nfft, nfft_over_2;

	if ((len != TOF_NFFT_20MHZ) && (len != TOF_NFFT_40MHZ) && (len != TOF_NFFT_80MHZ))
		return BCME_ERROR;

	ASSERT(sizeof(cint32) == 2*sizeof(int32));

	pTmp = (uint32*)H;
	pIn = (uint32*)H + len;
	wlc_phy_table_read_acphy(pi, ACPHY_TBL_ID_CORE0CHANESTTBL, len, 0,
		CORE0CHANESTTBL_TABLE_WIDTH, pTmp);
#ifdef TOF_DBG
#if defined(k_tof_collect_Hraw_size)
	if (Hraw && (len <= k_tof_collect_Hraw_size))
	  bcopy((void*)pTmp, (void*)Hraw, len*sizeof(uint32));
#else
	if (Hraw) {
		bcopy((void*)pTmp, (void*)Hraw, len*sizeof(uint32));
	}

#endif // endif
/* store raw data for log collection */
#endif /* TOF_DBG */
	/* reorder tones */
	nfft = len;
	nfft_over_2 = (len >> 1);
	if (CHSPEC_IS80(pi->radio_chanspec)) {
		i_l = 122;
		i_r = 2;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		i_l = 58;
		i_r = 2;
	} else {
		/* for legacy this is 26, for vht-20 this is 28 */
		i_l = 28;
		i_r = 1;
	}
	memset((void *)pIn, 0, len * sizeof(int32));
	for (i = i_l; i >= i_r; i--) {
		n1 = nfft_over_2 - i;
		n2 = nfft_over_2 + i;
		n3 = nfft - i;
		pIn[n1] = pTmp[n3];
		pIn[n2] = pTmp[i];
	}

	if (ACMAJORREV_1(pi->pubpi.phy_rev) || ACMAJORREV_3(pi->pubpi.phy_rev)) {
		int32 chi, chq;

		for (i = 0; i < len; i++) {
			chi = ((int32)pIn[i] >> CORE0CHANESTTBL_INTEGER_DATA_SIZE) &
				CORE0CHANESTTBL_INTEGER_DATA_MASK;
			chq = (int32)pIn[i] & CORE0CHANESTTBL_INTEGER_DATA_MASK;
			if (chi >= CORE0CHANESTTBL_INTEGER_MAXVALUE)
				chi = chi - (CORE0CHANESTTBL_INTEGER_MAXVALUE << 1);
			if (chq >= CORE0CHANESTTBL_INTEGER_MAXVALUE)
				chq = chq - (CORE0CHANESTTBL_INTEGER_MAXVALUE << 1);
			H[i].i = chi;
			H[i].q = chq;
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) || ACMAJORREV_5(pi->pubpi.phy_rev)) {
		wlc_unpack_float_acphy(nbits, UNPACK_FLOAT_AUTO_SCALE, 0,
			CORE0CHANESTTBL_FLOAT_FORMAT, CORE0CHANESTTBL_REV2_DATA_SIZE,
			CORE0CHANESTTBL_REV2_EXP_SIZE, len, pIn, H, NULL);
	} else if (ACMAJORREV_0(pi->pubpi.phy_rev)) {
		wlc_unpack_float_acphy(nbits, UNPACK_FLOAT_AUTO_SCALE, 0,
			CORE0CHANESTTBL_FLOAT_FORMAT, CORE0CHANESTTBL_REV0_DATA_SIZE,
			CORE0CHANESTTBL_REV0_EXP_SIZE, len, pIn, H, NULL);
	} else {
		return BCME_UNSUPPORTED;
	}

	return BCME_OK;
}

/* Get mag sqrd channel impulse response(from channel smoothing hw) to derive 11v rx timestamp */
int
wlc_phy_chan_mag_sqr_impulse_response_acphy(phy_info_t *pi, int frame_type,
	int len, int offset, int nbits, int32* h, int* pgd, uint32* hraw, uint16 tof_shm_ptr)
{
	uint8 stall_val;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	int N, s0, s1, m_mask, idx, i, j, l, m, i32x4, i4x2, tbl_offset, gd, n;
	uint32 *pdata, *ptmp, data_l, data_h;
	uint16 chnsm_status0;

	idx = -offset;

	if (ACMAJORREV_1(pi->pubpi.phy_rev) && ACMINORREV_2(pi->pubpi.phy_rev)) {
		/* Only 11n/acphy frames */
		if (frame_type < 2)
			return BCME_UNSUPPORTED;
	} else if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_1(pi->pubpi.phy_rev)) {
		/* 11n/acphy frames + 20MHz legacy frames */
		if ((frame_type < 2) && !((frame_type == 1) && (pi_ac->curr_bw == 0)))
			return BCME_UNSUPPORTED;
	} else {
		return BCME_UNSUPPORTED;
	}

	if (CHSPEC_IS80(pi->radio_chanspec)) {
		N = TOF_NFFT_80MHZ;
		s0 = 2 + TOF_BW_80MHZ_INDEX;
	} else if (CHSPEC_IS40(pi->radio_chanspec)) {
		N = TOF_NFFT_40MHZ;
		s0 = 2 + TOF_BW_40MHZ_INDEX;
	} else if (CHSPEC_IS20(pi->radio_chanspec)) {
		N = TOF_NFFT_20MHZ;
		s0 = 2 + TOF_BW_20MHZ_INDEX;
	} else
		return BCME_ERROR;

	chnsm_status0 = wlapi_bmac_read_shm(pi->sh->physhim, tof_shm_ptr + M_TOF_CHNSM_0);
	gd = (int)((chnsm_status0 >>
		ACPHY_chnsmStatus0_group_delay_SHIFT(pi->pubpi.phy_rev)) & 0xff);
	if (gd > 127)
		gd -= 256;

	if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_1(pi->pubpi.phy_rev))
		idx += gd; /* Impulse response is not shited, 0 is @ gd */

	*pgd = Q1_NS * gd; /* gd in Q1 ns */

	if (len > N)
		len = N;

	s1 = s0 + 2;
	m_mask = (1 << s1) - 1;

	stall_val = READ_PHYREGFLD(pi, RxFeCtrl1, disable_stalls);
	if (stall_val == 0)
		ACPHY_DISABLE_STALL(pi);

	phy_reg_write(pi, ACPHY_TableID(pi->pubpi.phy_rev),
		(uint16)ACPHY_TBL_ID_CHANNELSMOOTHING_1x1);

	n = len;
	ptmp = (uint32*)h + len;
	pdata = ptmp;
	while (n > 0) {
		idx = idx & (N - 1);
		i = (idx >> 2);
		j = (idx & 3);
		l = i + j;
		i32x4 = (i & 0xc);
		if (N == TOF_NFFT_80MHZ) {
			m  = (i32x4 + (i << 2) + (i32x4 >> 2)) & 0xf;
			m += (i ^ ((i << 1) & 0x20)) & 0x30;
			l += (i >> 4) + (i >> 2);
		} else if (N == TOF_NFFT_40MHZ) {
			i4x2 = (i >> 3) & 2;
			m  = ((0x1320 >> i32x4) & 0xf) << 3;
			m += ((((i >> 2) & 1) + i + i4x2) & 3) << 1;
			m += (i4x2 >> 1);
			l += (0x130 >> i32x4) + i4x2;
		} else {
			m  = ((i & 3) + (i32x4 ^ (i32x4 << 1))) & 0xf;
			l += (i >> 2);
		}
		l = (l & 3);
		tbl_offset = ((m + (l << s0)) & m_mask) + (l << s1) + CHANNELSMOOTHING_DATA_OFFSET;
		phy_reg_write(pi, ACPHY_TableOffset(pi->pubpi.phy_rev), (uint16) tbl_offset);
		data_l = (uint32)phy_reg_read(pi, ACPHY_TableDataWide(pi->pubpi.phy_rev));
		data_h = (uint32)phy_reg_read_wide(pi);
		*pdata++ = (data_h << 16) | (data_l & 0xffff);
		idx++;
		n--;
	};

	if (stall_val == 0)
		ACPHY_ENABLE_STALL(pi, stall_val);
#ifdef TOF_DBG
#if defined(k_tof_collect_Hraw_size)
	if (hraw && ((len + 1) <= k_tof_collect_Hraw_size)) {
	  bcopy((void*)ptmp, (void*)hraw, len*sizeof(uint32));
/* store raw data for log collection */
	  hraw[len] = (uint32)chnsm_status0;
	}
#else
	if (hraw) {
		bcopy((void*)ptmp, (void*)hraw, len*sizeof(uint32));
		hraw[len] = (uint32)chnsm_status0;
	}
#endif // endif
#endif /* TOF_DBG */
	wlc_unpack_float_acphy(nbits, UNPACK_FLOAT_AUTO_SCALE, 0, CHANNELSMOOTHING_FLOAT_FORMAT,
		CHANNELSMOOTHING_FLOAT_DATA_SIZE, CHANNELSMOOTHING_FLOAT_EXP_SIZE,
		len, ptmp, NULL, h);

	return BCME_OK;
}

/* get rxed frame type, bandwidth and rssi value */
int
wlc_phy_tof_info_acphy(phy_info_t *pi, int* p_frame_type, int* p_frame_bw, int* p_cfo, int8* p_rssi)
{
	uint16 status0, status2, status5;
	int frame_type, frame_bw, rssi, cfo;

	status0 = (int)READ_PHYREG(pi, RxStatus0) & 0xffff;
	status2 = (int)READ_PHYREG(pi, RxStatus2);
	status5 = (int)READ_PHYREG(pi, RxStatus5);

	frame_type = status0 & PRXS0_FT_MASK;
	frame_bw = status0 & PRXS0_ACPHY_SUBBAND_MASK;
	if (frame_bw == PRXS_SUBBAND_80)
	  frame_bw = TOF_BW_80MHZ_INDEX;
	else if ((frame_bw == PRXS_SUBBAND_40L) || (frame_bw == PRXS_SUBBAND_40U))
	  frame_bw = TOF_BW_40MHZ_INDEX;
	else
	  frame_bw = TOF_BW_20MHZ_INDEX;
	rssi =  ((int)status2 >> 8) & 0xff;
	if (rssi > 127)
	  rssi -= 256;

	cfo = ((int)status5 & 0xff);
	if (cfo > 127)
	  cfo -= 256;
	cfo = cfo * 2298;

	*p_frame_type = frame_type;
	*p_frame_bw = frame_bw;
	*p_rssi = rssi;
	*p_cfo = cfo;

	return BCME_OK;
}

/* turn on classification to receive frames */
void
wlc_phy_tof_cmd_acphy(phy_info_t *pi, bool seq)
{
	uint16 class_mask;
#ifdef WL_PROXD_SEQ
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	if (seq) {
		uint16 tof_seq_fem_gains[2],  mask = (1 << pi_ac->tof_core);

		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, mask);
		tof_seq_fem_gains[0] = k_tof_seq_fem_gains[0] | mask;
		tof_seq_fem_gains[1] = k_tof_seq_fem_gains[1] | mask;
		wlc_tof_seq_write_shm_acphy(pi, 1, k_tof_seq_shm_fem_radio_hi_gain_offset,
		                            (uint16*)tof_seq_fem_gains);
		wlc_tof_seq_write_shm_acphy(pi, 1, k_tof_seq_shm_fem_radio_lo_gain_offset,
		                            (uint16*)tof_seq_fem_gains+1);
		wlc_phy_tof_sc_acphy(pi, TRUE, k_tof_seq_sc_start, k_tof_seq_sc_stop, 0);
	}
#endif /* WL_PROXD_SEQ */

	class_mask = CHSPEC_IS2G(pi->radio_chanspec) ? 7 : 6; /* No bphy in 5g */
	wlc_phy_classifier_acphy(pi, ACPHY_ClassifierCtrl_classifierSel_MASK, class_mask);
}

/* get K value for initiator or target  */
#define k_tof_k_rtt_adj_Q 2
int
wlc_phy_tof_kvalue_acphy(phy_info_t *pi, chanspec_t chanspec, uint32 *kip, uint32 *ktp, bool seq_en)
{
	uint16 const *kvaluep = NULL;
	int idx = 0, channel = CHSPEC_CHANNEL(chanspec);
	int32 ki = 0, kt = 0, kseq = 0;
	int rtt_adj = 0, rtt_adj_ts;
	int rtt_adj_papd = 0, papd_en = 0;

	if (ACMAJORREV_3(pi->pubpi.phy_rev) && ACMINORREV_3(pi->pubpi.phy_rev)) {
		/* For 4345 B0/B1 */
		if (CHSPEC_IS80(chanspec)) {
			kvaluep = proxd_4345_80m_k_values;
			ki = TOF_INITIATOR_K_4345_80M;
			kt = TOF_TARGET_K_4345_80M;
		}
		else if (CHSPEC_IS40(chanspec)) {
			kvaluep = proxd_4345_40m_k_values;
			ki = TOF_INITIATOR_K_4345_40M;
			kt = TOF_TARGET_K_4345_40M;
		}
		else if (channel >= 36) {
			kvaluep = proxd_4345_20m_k_values;
			ki = TOF_INITIATOR_K_4345_20M;
			kt = TOF_TARGET_K_4345_20M;
		}
		else {
			kvaluep = proxd_4345_2g_k_values;
			ki = TOF_INITIATOR_K_4345_2G;
			kt = TOF_TARGET_K_4345_2G;
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_1(pi->pubpi.phy_rev) ||
	                                               ACMINORREV_4(pi->pubpi.phy_rev))) {
		/* For 4350 C0/C1/C2 */
		if (CHSPEC_IS80(chanspec)) {
			kvaluep = proxd_4350_80m_k_values;
			ki = TOF_INITIATOR_K_4350_80M;
			kt = TOF_TARGET_K_4350_80M;
			kseq = 90;
		}
		else if (CHSPEC_IS40(chanspec)) {
			kvaluep = proxd_4350_40m_k_values;
			ki = TOF_INITIATOR_K_4350_40M;
			kt = TOF_TARGET_K_4350_40M;
		}
		else if (channel >= 36) {
			kvaluep = proxd_4350_20m_k_values;
			ki = TOF_INITIATOR_K_4350_20M;
			kt = TOF_TARGET_K_4350_20M;
		}
		else {
			kvaluep = proxd_4350_2g_k_values;
			ki = TOF_INITIATOR_K_4350_2G;
			kt = TOF_TARGET_K_4350_2G;
		}
	} else if (ACMAJORREV_2(pi->pubpi.phy_rev) && (ACMINORREV_3(pi->pubpi.phy_rev) ||
	                                               ACMINORREV_5(pi->pubpi.phy_rev))) {
		/* For 4354A1/4345A2(4356) */
		if (CHSPEC_IS80(chanspec)) {
			kvaluep = proxd_4354_80m_k_values;
			ki = TOF_INITIATOR_K_4354_80M;
			kt = TOF_TARGET_K_4354_80M;
		}
		else if (CHSPEC_IS40(chanspec)) {
			kvaluep = proxd_4354_40m_k_values;
			ki = TOF_INITIATOR_K_4354_40M;
			kt = TOF_TARGET_K_4354_40M;
		}
		else if (channel >= 36) {
			kvaluep = proxd_4354_20m_k_values;
			ki = TOF_INITIATOR_K_4354_20M;
			kt = TOF_TARGET_K_4354_20M;
		}
		else {
			kvaluep = proxd_4354_2g_k_values;
			ki = TOF_INITIATOR_K_4354_2G;
			kt = TOF_TARGET_K_4354_2G;
		}
	}

	if (seq_en) {
	  if (kip)
	    *kip = kseq;
	  if (ktp)
	    *ktp = kseq;
	  return BCME_OK;
	}

	if (kvaluep) {
	        rtt_adj = (4 - READ_PHYREGFLD(pi, RxFeCtrl1, rxfe_bilge_cnt));
	        rtt_adj_ts = 80;
		if (READ_PHYREGFLD(pi, PapdEnable0, papd_compEnb0))
			papd_en = 1;
		if (CHSPEC_IS80(chanspec)) {
			if (channel <= 58)
				idx = (channel - 42) >> 4;
			else if (channel <= 138)
				idx = ((channel - 106) >> 4) + 2;
			else
				idx = 5;
			rtt_adj_ts = 25;
			if (papd_en)
				rtt_adj_papd = 25;
		} else if (CHSPEC_IS40(chanspec)) {
			if (channel <= 62)
				idx = (channel - 38) >> 3;
			else if (channel <= 142)
				idx = ((channel - 102) >> 3) + 4;
			else
				idx = ((channel - 151) >> 3) + 10;
			rtt_adj_ts = 40;
			if (papd_en)
				rtt_adj_papd = 30;
		} else if (channel >= 36) {
			if (channel <= 64)
				idx = (channel - 36) >> 2;
			else if (channel <= 144)
				idx = ((channel - 100) >> 2) + 8;
			else
				idx = ((channel - 149) >> 2) + 20;
			if (papd_en)
				rtt_adj_papd = 66;
		} else if (channel >= 1 && channel <= 14) {
			idx = channel - 1;
			if (papd_en)
				rtt_adj_papd = 70;
		}
		rtt_adj = (rtt_adj_ts * rtt_adj) >> k_tof_k_rtt_adj_Q;
		ki += ((int32)rtt_adj  + (int32)rtt_adj_papd);
		kt += ((int32)rtt_adj  + (int32)rtt_adj_papd);
		if (kip)
		{
			*kip = (uint32)(ki + (int8)(kvaluep[idx] & 0xff));
		}
		if (ktp)
		{
			*ktp = (uint32)(kt + (int8)(kvaluep[idx] >> 8));
		}

		return BCME_OK;
	}

	return BCME_ERROR;
}
#endif /* WL_PROXDETECT */

#if (defined(WLTEST) || defined(WLPKTENG))
static bool
wlc_phy_isperratedpden_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (CHSPEC_IS2G(pi->radio_chanspec))
		return (pi->epacal2g && pi_ac->perratedpd2g);
	else
		return (pi->epacal5g && pi_ac->perratedpd5g);
}

static void
wlc_phy_perratedpdset_acphy(phy_info_t *pi, bool enable)
{
	/* Set the new value */
	MOD_PHYREG(pi, PapdEnable0, papd_compEnb0, enable);
}
#endif // endif

#if defined(WLC_TXCAL)
void
wlc_phy_set_olpc_anchor_acphy(phy_info_t *pi)
{
	/* Search over the linked txcal table list */
	/* to find out the anchor power tx idx */
	txcal_pwr_tssi_lut_t *LUT_pt;
	txcal_pwr_tssi_lut_t *LUT_root;
	uint8 chan_num = CHSPEC_CHANNEL(pi->radio_chanspec);
	uint8 flag_chan_found = 0;
	uint8 core;

	if (CHSPEC_IS2G(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_2G;
	else if (CHSPEC_IS80(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_5G80;
	else if (CHSPEC_IS40(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_5G40;
	else
		LUT_root = &pi->root_pwr_tssi_lut_5G20;

	if (LUT_root->txcal_pwr_tssi.channel == 0) {
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			/* No Txcal table is present, return */
			/* olpc_anchor_idx is a check in phy level */
			/* to verify whether the tx idx at the anchor */
			/* power is valid for current channel */
			pi->olpc_idx_valid = FALSE;
			return;
		} else {
			/* For 40 and 80 if no Txcal table is present */
			/* Use 20mhz txcal table */
			LUT_root = &pi->root_pwr_tssi_lut_5G20;
			if (LUT_root->txcal_pwr_tssi.channel == 0) {
				pi->olpc_idx_valid = FALSE;
				return;
			}
		}
	}

	LUT_pt = LUT_root;
	while (LUT_pt->next_chan != 0) {
		/* Go over all the entries in the list */
		if (LUT_pt->txcal_pwr_tssi.channel == chan_num) {
			flag_chan_found = 1;
			break;
		}
		if ((LUT_pt->txcal_pwr_tssi.channel < chan_num) &&
		    (LUT_pt->next_chan->txcal_pwr_tssi.channel > chan_num)) {
			flag_chan_found = 2;
			break;
		}
		LUT_pt = LUT_pt->next_chan;
	}
	if (LUT_pt->txcal_pwr_tssi.channel == chan_num) {
		/* In case only one entry is in the list */
		flag_chan_found = 1;
	}
	switch (flag_chan_found) {
	case 0:
		/* Channel not found in linked list or not between two channels */
		/* Then pick the closest one */
		if (chan_num < LUT_root->txcal_pwr_tssi.channel)
			LUT_pt = LUT_root;
		break;
	case 2:
		/* Channel is in between two channels, pick closest one as the anchor idx */
		if (ABS(chan_num - LUT_pt->txcal_pwr_tssi.channel) >=
		        ABS(LUT_pt->next_chan->txcal_pwr_tssi.channel - chan_num))
			LUT_pt = LUT_pt->next_chan;
		break;
	}

	FOREACH_CORE(pi, core) {
		pi->olpc_anchor_idx[core] = LUT_pt->txcal_pwr_tssi.pwr_start_idx[core];
		/* if anchor idx is 0, then decide it is not valid */
		if (pi->olpc_anchor_idx[core] == 0) {
			pi->olpc_idx_valid = FALSE;
			return;
		}
		/* temperature recorded for tx idx at the anchor power */
		pi->olpc_tempsense[core] = LUT_pt->txcal_pwr_tssi.tempsense[core];
	}
	pi->olpc_idx_valid = TRUE;
	return;
}

uint16
wlc_phy_adjusted_tssi_acphy(phy_info_t *pi, uint8 core_num)
{
	uint16 adj_tssi = 0;
	int16 tssi_OB, idletssi_OB;
	uint8 pos_slope;

	int16 tssi_reg, idletssi_reg;

	tssi_reg = READ_PHYREGCE(pi, TssiVal_path, core_num) & 0x3ff;

	if (tssi_reg >= 512)
		tssi_OB = tssi_reg - 511;
	else
		tssi_OB = tssi_reg + 512;

	idletssi_reg = READ_PHYREGCE(pi, TxPwrCtrlIdleTssi_path, core_num) & 0x3ff;
	if (idletssi_reg >= 512)
		idletssi_OB = idletssi_reg - 511;
	else
		idletssi_OB = idletssi_reg + 512;
	pos_slope = READ_PHYREGFLD(pi, TSSIMode, tssiPosSlope);
	if (pos_slope)
		adj_tssi = idletssi_OB - tssi_OB  + ((1 << 10)-1);
	else
		adj_tssi = tssi_OB - idletssi_OB  + ((1 << 10)-1);

	return adj_tssi;
}

uint8
wlc_phy_apply_pwr_tssi_tble_chan_acphy(phy_info_t *pi)
{
	txcal_pwr_tssi_lut_t *LUT_pt;
	txcal_pwr_tssi_lut_t *LUT_root;
	uint8 chan_num = CHSPEC_CHANNEL(pi->radio_chanspec);
	uint8 flag_chan_found = 0;

	if (CHSPEC_IS2G(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_2G;
	else if (CHSPEC_IS80(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_5G80;
	else if (CHSPEC_IS40(pi->radio_chanspec))
		LUT_root = &pi->root_pwr_tssi_lut_5G40;
	else
		LUT_root = &pi->root_pwr_tssi_lut_5G20;

	if (LUT_root->txcal_pwr_tssi.channel == 0) {
		/* if no txcal table is present for 2G and 5G20, apply paparam */
		/* For 5G40/80, apply 20mhz txcal table */
		if (CHSPEC_IS2G(pi->radio_chanspec)) {
			wlc_phy_txcal_apply_pa_params(pi);
			return BCME_OK;
		} else {
			if (CHSPEC_IS20(pi->radio_chanspec)) {
				wlc_phy_txcal_apply_pa_params(pi);
				return BCME_OK;
			} else {
				LUT_root = &pi->root_pwr_tssi_lut_5G20;
				if (LUT_root->txcal_pwr_tssi.channel == 0) {
					wlc_phy_txcal_apply_pa_params(pi);
					return BCME_OK;
				}
			}
		}
	}

	LUT_pt = LUT_root;
	while (LUT_pt->next_chan != 0) {
		/* Go over all the entries in the list */
		if (LUT_pt->txcal_pwr_tssi.channel == chan_num) {
			flag_chan_found = 1;
			break;
		}
		if ((LUT_pt->txcal_pwr_tssi.channel < chan_num) &&
		    (LUT_pt->next_chan->txcal_pwr_tssi.channel > chan_num)) {
			flag_chan_found = 2;
			break;
		}
		LUT_pt = LUT_pt->next_chan;
	}
	if (LUT_pt->txcal_pwr_tssi.channel == chan_num) {
		/* In case only one entry is in the list */
		flag_chan_found = 1;
	}

	switch (flag_chan_found) {
	case 0:
		/* Channel not found in linked list or not between two channels */
		/* Then pick the closest one */
		if (chan_num < LUT_root->txcal_pwr_tssi.channel)
			LUT_pt = LUT_root;
		wlc_phy_txcal_apply_pwr_tssi_tbl(pi, &LUT_pt->txcal_pwr_tssi);
		pi->txcal_status = 2;
		break;
	case 1:
		/* Channel found */
		wlc_phy_txcal_apply_pwr_tssi_tbl(pi, &LUT_pt->txcal_pwr_tssi);
		pi->txcal_status = 1;
		break;
	case 2:
		/* Channel is in between two channels, do interpolation */
		/* ---- need to verify goodness of interpolation */
		wlc_phy_estpwrlut_intpol_acphy(pi, chan_num,
			&LUT_pt->txcal_pwr_tssi, &LUT_pt->next_chan->txcal_pwr_tssi);
		pi->txcal_status = 2;
		break;
	}
	return BCME_OK;
}

uint8
wlc_phy_estpwrlut_intpol_acphy(phy_info_t *pi, uint8 channel,
       wl_txcal_power_tssi_t *pwr_tssi_lut_ch1, wl_txcal_power_tssi_t *pwr_tssi_lut_ch2)
{
	uint16 estpwr1[128];
	uint16 estpwr2[128];
	uint16 estpwr[128];
	int16 est_pwr_calc, est_pwr_calc1, est_pwr_calc2, est_pwr_intpol1, est_pwr_intpol2;
	uint32 tbl_len = 128;
	uint32 tbl_offset = 0;
	uint8 core, i;
	uint8 tx_pwr_ctrl_state;

	tx_pwr_ctrl_state =  pi->txpwrctrl;
	wlc_phy_txpwrctrl_enable_acphy(pi, PHY_TPC_HW_OFF);
	/* Interpolate between estpwrlut */
	FOREACH_ACTV_CORE(pi, pi->sh->phyrxchain, core) {
		wlc_phy_txcal_generate_estpwr_lut(pwr_tssi_lut_ch1, estpwr1, core);
		wlc_phy_txcal_generate_estpwr_lut(pwr_tssi_lut_ch2, estpwr2, core);
		for (i = 0; i < 128; i++) {
			est_pwr_calc1 = estpwr1[i] > 0x7F ?
				(int16) (estpwr1[i] - 0x100) : estpwr1[i];
			est_pwr_calc2 = estpwr2[i] > 0x7F ?
				(int16) (estpwr2[i] - 0x100) : estpwr2[i];
			/* round to the nearest integer */
			est_pwr_intpol1 = 2*(channel - pwr_tssi_lut_ch1->channel)*(est_pwr_calc2 -
				est_pwr_calc1)/(pwr_tssi_lut_ch2->channel -
				pwr_tssi_lut_ch1->channel);
			est_pwr_intpol2 = (channel - pwr_tssi_lut_ch1->channel)*(est_pwr_calc2 -
			        est_pwr_calc1)/(pwr_tssi_lut_ch2->channel -
				pwr_tssi_lut_ch1->channel);
			est_pwr_calc = est_pwr_calc1 + est_pwr_intpol1 - est_pwr_intpol2;
			estpwr[i] = (uint16) (est_pwr_calc & 0xFF);
		}
		wlc_phy_table_write_acphy(pi, ACPHY_TBL_ID_ESTPWRLUTS(core), tbl_len,
			tbl_offset, 16, estpwr);
	}

	wlc_phy_txpwrctrl_enable_acphy(pi, tx_pwr_ctrl_state);
	return BCME_OK;
}

static void
wlc_phy_olpc_idx_tempsense_comp_acphy(phy_info_t *pi, uint8 *iidx, uint8 core)
{
	/* This function calculates the init idx based on max tgt pwr, */
	/* table based txcal anchor power tx idx, and temperature */
	uint8 olpc_anchor = 0;
	int16 currtemp = 0;
	int16 olpc_tempslope = 0;
	int8 idx = 0;
	if (CHSPEC_IS5G(pi->radio_chanspec)) {
		olpc_anchor = pi->olpc_anchor5g;
		olpc_tempslope = pi->olpc_tempslope5g[core];
	} else {
		olpc_anchor = pi->olpc_anchor2g;
		olpc_tempslope = pi->olpc_tempslope2g[core];
	}

	idx = pi->olpc_anchor_idx[core] - ((pi->tx_power_max_per_core[core] - olpc_anchor
		+ 1) >> 1);
	if (olpc_tempslope) {
		currtemp = wlc_phy_tempsense_acphy(pi);
		idx = idx - (((currtemp - pi->olpc_tempsense[core]) * olpc_tempslope +
			512) >> 10);
	}
	*iidx = (idx >= 0) ? idx : 0;
}
#endif /* WLC_TXCAL */

#if defined(WLC_TXPWRCAP)
bool
wlc_phy_txpwrcap_get_cellstatus_acphy(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	return (pi_ac->txpwrcap_cellstatus & TXPWRCAP_CELLSTATUS_MASK);
}

void
wlc_phy_txpwrcap_set_cellstatus_acphy(phy_info_t *pi, int mask, int value)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	pi_ac->txpwrcap_cellstatus &= ~(mask);
	value &= mask;
	pi_ac->txpwrcap_cellstatus |= value;

	wlc_phy_txpwrcap_cellstatusupd_acphy(pi);
}

static void
wlc_phy_txpwrcap_cellstatusupd_acphy(phy_info_t *pi)
{
	int txpwrcap_upreqd = FALSE;
	int cellstatus_new, cellstatus_cur;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	/* CELLSTATUS_FORCE_UPD => Update forced, either by iovar or at init time
	 * CELLSTATUS_FORCE => value forced by iovar, ignore value from WCI2
	 * else compare value from WCI2 (cellstatus_new) and current value (cellstatus_cur)
	 * to determine if update needed
	 */
	if (pi_ac->txpwrcap_cellstatus & TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK) {
		pi_ac->txpwrcap_cellstatus &= ~(TXPWRCAP_CELLSTATUS_FORCE_UPD_MASK);
		txpwrcap_upreqd = TRUE;
	}
	else if (!(pi_ac->txpwrcap_cellstatus & TXPWRCAP_CELLSTATUS_FORCE_MASK)) {
		cellstatus_cur = (pi_ac->txpwrcap_cellstatus & TXPWRCAP_CELLSTATUS_MASK)
			>> TXPWRCAP_CELLSTATUS_NBIT;
		cellstatus_new = (pi_ac->txpwrcap_cellstatus & TXPWRCAP_CELLSTATUS_WCI2_MASK)
			>> TXPWRCAP_CELLSTATUS_WCI2_NBIT;
		/* Note if status change, as need to update PHY */
		if (cellstatus_cur != cellstatus_new) {
			pi_ac->txpwrcap_cellstatus &= ~(1 << TXPWRCAP_CELLSTATUS_NBIT);
			pi_ac->txpwrcap_cellstatus |= (cellstatus_new << TXPWRCAP_CELLSTATUS_NBIT);
			txpwrcap_upreqd = TRUE;
		}
	}

	if (txpwrcap_upreqd) {
		/* PHY update required */
#ifdef WLC_SW_DIVERSITY
		wlc_phy_swdiv_ovr_set_acphy(pi);
#endif // endif
		wlc_phy_txpwrcap_set_acphy(pi);
	}
}
#endif /* WLC_TXPWRCAP */

#ifdef WLC_SW_DIVERSITY
static void
BCMATTACHFN(wlc_phy_swdiv_srom_read_acphy)(phy_info_t *pi)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	/* Note: following swdiv parameters are also read and stored independently in wlc.c */
	/*       (not intended to be used as dynamic parameters) */
	pi_ac->swdiv_enable      = (bool)PHY_GETINTVAR(pi, rstr_swdiv_en);
	pi_ac->swdiv_gpio_num    = (uint8)PHY_GETINTVAR(pi, rstr_swdiv_gpio);
	pi_ac->swdiv_swctrl_en   = (wlc_swdiv_swctrl_t)PHY_GETINTVAR(pi, rstr_swdiv_swctrl_en);
	pi_ac->swdiv_swctrl_mask = (uint16)PHY_GETINTVAR(pi, rstr_swdiv_swctrl_mask);
	pi_ac->swdiv_swctrl_ant0 = (uint16)PHY_GETINTVAR(pi, rstr_swdiv_swctrl_ant0);
	pi_ac->swdiv_swctrl_ant1 = (uint16)PHY_GETINTVAR(pi, rstr_swdiv_swctrl_ant1);
}

static void
wlc_phy_swdiv_init_acphy(phy_info_t *pi)
{
	bool suspend;
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

	if (!pi_ac->swdiv_enable)
		return;

	if (pi_ac->swdiv_swctrl_en == SWDIV_SWCTRL_0)
		return;

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	if (!suspend)
		wlapi_suspend_mac_and_wait(pi->sh->physhim);

	switch (pi_ac->swdiv_swctrl_en) {
		case SWDIV_SWCTRL_2:
			MOD_PHYREG(pi, AntDivConfig2059, board_switch_div0, 0);
			MOD_PHYREG(pi, AntDivConfig2059, CoreStartAntPos0, 1);
			break;

		case SWDIV_SWCTRL_0:
		case SWDIV_SWCTRL_1:
		default:
			ASSERT(0);
	}

	if (!suspend)
		wlapi_enable_mac(pi->sh->physhim);

}

bool
wlc_phy_swdiv_ant_set_acphy(phy_info_t *pi, uint8 new_ant)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	bool suspend;
	uint16 val;

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	switch (pi_ac->swdiv_swctrl_en) {
		case SWDIV_SWCTRL_0:
			val = 1 << pi_ac->swdiv_gpio_num;
			if (new_ant == 1)
				OR_REG(pi->sh->osh, &pi->regs->psm_gpio_out, val);
			else
				AND_REG(pi->sh->osh, &pi->regs->psm_gpio_out, ~val);
			break;

		case SWDIV_SWCTRL_1:
				wlc_ant_div_sw_control(pi, new_ant, 0);
				break;

		case SWDIV_SWCTRL_2:
			val = 1 << pi_ac->swdiv_gpio_num;
			if (!suspend)
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
			if (new_ant == 1)
				phy_reg_or(pi, ACPHY_AntDivConfig2059(pi->pubpi.phy_rev), val);
			else
				phy_reg_and(pi, ACPHY_AntDivConfig2059(pi->pubpi.phy_rev), ~val);
			if (!suspend)
				wlapi_enable_mac(pi->sh->physhim);
			break;

		default:
			ASSERT(0);
	}

	return TRUE;
}

bool
wlc_phy_swdiv_ant_get_acphy(phy_info_t *pi, uint8 *cur_ant)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint16 val = 0;
	uint16 mask;
	bool suspend;

	suspend = !(R_REG(pi->sh->osh, &pi->regs->maccontrol) & MCTL_EN_MAC);
	switch (pi_ac->swdiv_swctrl_en) {
		case SWDIV_SWCTRL_0:
			val = R_REG(pi->sh->osh, &pi->regs->psm_gpio_out);
			mask = 1 << pi_ac->swdiv_gpio_num;
			*cur_ant = (val & mask) ? 1:0;
			break;

		case SWDIV_SWCTRL_1:
			*cur_ant = pi_ac->ant_swOvr_state_core0;
			break;

		case SWDIV_SWCTRL_2:
			if (!suspend)
				wlapi_suspend_mac_and_wait(pi->sh->physhim);
			val = READ_PHYREG(pi, AntDivConfig2059);
			if (!suspend)
				wlapi_enable_mac(pi->sh->physhim);
			mask = 1 << pi_ac->swdiv_gpio_num;
			*cur_ant = (val & mask) ? 1:0;
			break;

		default:
			ASSERT(0);
	}

	return TRUE;
}

static void
wlc_phy_swdiv_ovr_set_acphy(phy_info_t *pi)
{
#if defined(WLC_TXPWRCAP)
	bool cellstatus = wlc_phy_txpwrcap_get_cellstatus_acphy(pi);
#else
	bool cellstatus = FALSE;
#endif // endif

	uint8 ant = ANT_RX_DIV_FORCE_0;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;

	if (pi_ac->swdiv_swctrl_en && CHSPEC_IS2G(pi->radio_chanspec)) {
		if (cellstatus)
			ant = ANT_RX_DIV_FORCE_0;
		else
			ant = ANT_RX_DIV_START_0;
	} else if (pi_ac->swdiv_swctrl_en && CHSPEC_IS5G(pi->radio_chanspec)) {
		ant = ANT_RX_DIV_FORCE_0;
	}

	wlapi_swdiv_ovr_set(pi->sh->physhim, ant);
}
#endif /* WLC_SW_DIVERSITY */

#if defined(WLTEST) || defined(WLMEDIA_N2DBG) || defined(WLMEDIA_N2DEV) || \
	defined(DBG_PHY_IOV) || defined(WFD_PHY_LL_DEBUG)
/*
 * This function has been implemented to get over a problem seen in the multi-DUT test scenario.
 * In this scenarios because of the Tx Cal going on in the other neighbor DUT the Noise
 * calibration in this DUT would get high noise numbers. To avoid this problem this IOVAR can
 * be used to trigger a noise cal at a DUT under known conditions (other DUTs are not doing
 * any calibration). The algo in the PHY averages the last 4 values received from the noise cal
 * and uses them to populate the value in the crsminpoweru0 register. In order to refresh the
 * value in this register to a good value the post processing function (wlc_phy_noise_sample_intr)
 * is triggered 4 times after doing a single cal at the PSM, so as to flush out the stale readings.
 */
void
wlc_phy_noisecal_run_acphy(phy_info_t *pi)
{
	int status = 0, i;
	bool phywatchdog_override;
	bool force_crsmincal;
	bool trigger_crsmin_cal;

	/* Backup the watchdog's flag. */
	phywatchdog_override = pi->phywatchdog_override;
	pi->phywatchdog_override = 0;

	/* Suspend the PSM */
	wlapi_suspend_mac_and_wait(pi->sh->physhim);

	/* Ensure no Noise cal in progress */
	status = R_REG(pi->sh->osh, &pi->regs->maccommand);
	if (status & MCMD_BG_NOISE) {
		ASSERT(0);
		PHY_ERROR(("Fatal error. Aborting, PSM not done with previous noise cal.\n"));
		wlapi_enable_mac(pi->sh->physhim);
		return;
	}

	/* Start noise measurements. */
	OR_REG(pi->sh->osh, &pi->regs->maccommand, MCMD_BG_NOISE);

	/* Let the PSM run to perform Noise Cal */
	wlapi_enable_mac(pi->sh->physhim);

	do {
		status = R_REG(pi->sh->osh, &pi->regs->maccommand);
		OSL_DELAY(5);
	} while (status & MCMD_BG_NOISE);

	/* Backup CRS Min cal params */
	force_crsmincal = pi->u.pi_acphy->force_crsmincal;
	trigger_crsmin_cal = pi->u.pi_acphy->trigger_crsmin_cal;

	/* Calling it PHY_SIZE_NOISE_ARRAY times so as to take a fresh reading */
	for (i = 0; i < PHY_SIZE_NOISE_ARRAY; i++) {
		/* To set the phy reg to new cal value set the CRS Min cal params */
		pi->u.pi_acphy->force_crsmincal = TRUE;
		pi->u.pi_acphy->trigger_crsmin_cal = TRUE;
		wlc_phy_noise_sample_intr((wlc_phy_t *)pi);
	}

	/* Restore the watchdog's flag. */
	pi->phywatchdog_override = phywatchdog_override;
	pi->u.pi_acphy->trigger_crsmin_cal = trigger_crsmin_cal;
	pi->u.pi_acphy->force_crsmincal = force_crsmincal;
}
#endif // endif

void
wlc_phy_switch_preemption_settings_AC4354REV(phy_info_t *pi, uint8 state)
{
	/* 4354A0/A1:dynamic preemption settings based on hwaci state:
	   Aggressive settings for no_aci or aci < -40 dbm
	   & conservative settings for aci > -40 dbm
	 */
	const uint16 clip_detect_cond3_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond3_enable);
	const uint16 clip_detect_cond2_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond2_enable);
	const uint16 low_power_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, low_power_enable);
	const uint16 clip_detect_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_enable);

	if (!AC4354REV(pi)) return;

	if ((state == 0) || (state == 1)) {
		/* no aci or aci < -40 dbm : Aggressive settings */
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x24);
			if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
				ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, clip_detect_cond3_enable |
						clip_detect_cond2_enable | low_power_enable |
						clip_detect_enable);
			} else {
				ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, 0x31);
			}
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x48);
		} else {
			ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0xa0);
		}
	} else {
		/* state is 2 or 3:aci > -40 dbm */
		if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
			ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, clip_detect_cond3_enable |
					low_power_enable | clip_detect_enable);
		} else {
			ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, 0x21);
		}
		if (CHSPEC_IS20(pi->radio_chanspec)) {
			ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x2d);
		} else if (CHSPEC_IS40(pi->radio_chanspec)) {
			if (CHSPEC_IS5G(pi->radio_chanspec)) {
				ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x64);
			} else {
				ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0x48);
			}
		} else {
			ACPHYREG_BCAST(pi, PREMPT_ofdm_nominal_clip_cnt_th0, 0xdc);
		}
	}
}

void
wlc_phy_switch_preemption_settings_ACMAJORREV5(phy_info_t *pi, uint8 state)
{
	/* 43602: disable abort from timing search when lna 1 is desensed.
	   See Jira: SWWLAN-63373
	 */
	const uint16 clip_detect_cond2_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond2_enable);
	const uint16 low_power_enable =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, low_power_enable);
	uint16 supported_states = 0x2fff;
	uint16 per_pkt_en0 =
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_cond3_enable) |
			ACPHY_REG_FIELD_MASKE(pi, PREMPT_per_pkt_en, 0, clip_detect_enable);

	if (!ACMAJORREV_5(pi->pubpi.phy_rev)) return;

	if ((((state == 2) || (state == 3)) && CHSPEC_IS2G(pi->radio_chanspec)) ||
	    ((state == 4) && CHSPEC_IS5G(pi->radio_chanspec))) {
		supported_states &= ~pktabort_timing_search;
	}
	if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
		/* also disable abort from WAIT_NCLKS when Low Power Detect preemption is enabled */
		supported_states &= ~pktabort_wait_nclks;
	}

	WRITE_PHYREG(pi, PktAbortSupportedStates, supported_states);

	if ((pi->sh->interference_mode & ACPHY_LPD_PREEMPTION) != 0) {
		per_pkt_en0 |= low_power_enable;
	}
	if (state == 0) {
		/* no aci or aci < -40 dbm : Aggressive settings */
		per_pkt_en0 |= clip_detect_cond2_enable;
	}
	ACPHYREG_BCAST(pi, PREMPT_per_pkt_en0, per_pkt_en0);
}

#if (defined(WLTEST) || defined(ACMAJORREV2_THROUGHPUT_OPT))
void
wlc_acphy_set_ldo(wlc_phy_t *ppi, uint8 ldostatus)
{
	/* XXX switching xtalldo values to improve throughtput
	 * for unstable EVM issue for 4350
	 */
	phy_info_t *pi = (phy_info_t *)ppi;
	if (ldostatus == 0) {
		MOD_RADIO_REG(pi, RFP, PLL_XTALLDO1,
			ldo_1p2_xtalldo1p2_ctl, 0xb);
		pi->u.pi_acphy->xtalldo = ldostatus;
		/* Keep track of xtalldo status for channel init */
	} else {
		MOD_RADIO_REG(pi, RFP, PLL_XTALLDO1,
			ldo_1p2_xtalldo1p2_ctl, 0xf);
		pi->u.pi_acphy->xtalldo = ldostatus;
	}
}

bool
wlc_phy_get_2069_xtalldowar_status(wlc_phy_t *ppi)
{
	phy_info_t *pi = (phy_info_t *)ppi;
	return pi->pubpi.xtalldo_war_2069;
}
#endif // endif

void
wlc_acphy_paldo_change(phy_info_t *pi)
{
	si_t *sih = (si_t*)pi->sh->sih;
	osl_t *osh = si_osh(sih);
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;
	uint origidx = si_coreidx(sih);

	si_setcoreidx(sih, SI_CC_IDX);

	if (CHSPEC_IS2G(pi->radio_chanspec))
		si_pmu_set_ldo_voltage(sih, osh, 1, pi_ac->ldo3p3_2g);
	else
		si_pmu_set_ldo_voltage(sih, osh, 1, pi_ac->ldo3p3_5g);

	si_setcoreidx(sih, origidx);
}

int8
wlc_phy_calc_ppr_pwr_cap_acphy(phy_info_t *pi, uint8 core, int8 maxpwr)
{
	phy_info_acphy_t *pi_ac = pi->u.pi_acphy;

#ifdef WL_SARLIMIT
	pi->adjusted_pwr_cap[core] = MIN(pi->sarlimit[core], maxpwr + pi_ac->txpwr_offset[core]);
#else
	pi->adjusted_pwr_cap[core] = maxpwr + pi_ac->txpwr_offset[core];
#endif // endif
	return pi->adjusted_pwr_cap[core];
}

/* ------------------------ Calibrate nmos/pmos Xtal routines ---------------------------- */

#ifdef PHY_XTAL_SPUR_CAL

/* Enable to get debug output */
#undef BCMDBG_XTALCAL

#ifdef BCMDBG_XTALCAL
#define PHY_XTALCAL(args)   do {PHY_PRINT(args);} while (0)
#else
#define	PHY_XTALCAL(args)
#endif /* BCMDBG_XTALCAL */

/* Reverse the bit ordering for 'bits' bits of the input value 'val' */
static uint8
wlc_acphy_reflect(uint8 val, uint8 bits)
{
	uint8 i;
	uint8 ret = 0;

	for (i = 0; i < bits; i++) {
		ret = (ret << 1) | (val & 1);
		val = val >> 1;
	}
	return ret;
}

/* Convert bin to idx of the capture */
static uint8
wlc_acphy_bin2idx(uint8 bin, npmos_cal_state_t *pstate)
{
	uint8 fft_mid = pstate->nfft >> 1;
	uint8 idx;
	uint8 bits;

	switch (pstate->nfft) {
		case NFFT_BASE:
			bits = 6;
			break;
		case NFFT_BASE * 2:
			bits = 7;
			break;
		default:
			ASSERT(0);
			return -1;
	}

	/* FFT shift */
	idx = (bin < fft_mid) ? bin + fft_mid : bin - fft_mid;

	if (pstate->core >= PHY_CORE_1) {
		/* See CRDOT11ACPHY-327: Reverse bits */
		idx = wlc_acphy_reflect(idx, bits);
	}
	return idx;
}

/* Check if we need to do a Xtal spur calibration for this chip and channel.
 * If not needed return ASAP, if needed, calculate on which two bins the spur (mainly) is
 * and return a state structure with the two idx's for the spur and two indexes to measure
 * the noise.
 *
 * Returns value: TRUE if a calibration can/should be done, FALSE otherwise
 * If TRUE also the npmos_cal_state_t struct is initialized and used as input to
 * wlc_acphy_nmos_pmos_wrapper to do the actual calibration
 */
static bool
wlc_acphy_init_xtal_spur(phy_info_t *pi, npmos_cal_state_t *pstate)
{
	chanspec_t channel;
	uint16 center_mhz, harmonic;
	uint32 spur_khz;
	int32 tone_shift22, tone;
	uint8 spur_low, spur_high;
	uint8 noise1, noise2;
	uint16 nfft, dc_bin;

	const uint8 GAP = 5;	/* clearance (in bins) from sides and DC dip */

	/* 43569a2/43570a2 */
	bool is_569_570_2g = (RADIOID(pi->pubpi.radioid) == BCM2069_ID &&
	                      (RADIOREV(pi->pubpi.radiorev) == 0x2C) &&
	                      (PHY_XTAL_IS40M(pi)) &&
	                      PHY_ILNA(pi) && CHSPEC_IS2G(pi->radio_chanspec));

	/* Return if not applicable */
	if (is_569_570_2g == FALSE) {
		return FALSE;
	}

	pstate->core = PHY_CORE_1;  /* Spur problem on Core 1 */
	pstate->pi = pi;
	pstate->fail = 0;

	channel = CHSPEC_CHANNEL(pi->radio_chanspec);
	center_mhz = (uint16)wlc_phy_chan2fc_acphy(channel);
	if (PHY_XTAL_IS40M(pi)) {
		harmonic = (center_mhz + 20) / 40;
		spur_khz = 40000 * harmonic;
	} else if (PHY_XTAL_IS37M4(pi)) {
		harmonic = (10 * center_mhz + 187) / 374;
		spur_khz = 37400 * harmonic;
	} else {
		return FALSE;
	}

	switch (pi->bw) {
		case WL_CHANSPEC_BW_20:
			nfft = NFFT_BASE;
			break;
		case WL_CHANSPEC_BW_40:
			nfft = NFFT_BASE * 2;
			break;
		default:
			ASSERT(0);
			return FALSE;
	}
	pstate->nfft = nfft;
	dc_bin = nfft >> 1;

	/* tone_fractional = ((spur_mhz - center_mhz) / 20.0) * 64 */
	/* 2^22 * tone_fractional = (spur_mhz - center_mhz) * 13421.773 */
	tone_shift22 = (spur_khz - 1000 * (int32)center_mhz) * 13422;
	tone = dc_bin + (tone_shift22 >> 22);	/* 32..31 --> 0..63 */

	if ((tone < 1) || (nfft - tone - 1 < 1) || (tone == dc_bin)) {
		PHY_XTALCAL(("Spur has %d kHz offset, not in-band\n",
		             spur_khz - 1000 * center_mhz));
		return FALSE;
	}
	spur_low = (uint8)tone;
	spur_high = spur_low + 1;

	/* Around spur but not outside band (20MHz: 6..57) or in DC dip (20 MHz: 27..37) */
	noise1 = spur_low  - GAP;
	noise2 = spur_high + GAP;
	if ((noise1           <= GAP) || (ABS(noise1 - dc_bin) <= GAP))
		noise1 = spur_high + GAP + 1;
	if ((nfft - noise2 -1 <= GAP) || (ABS(noise2 - dc_bin) <= GAP))
		noise2 = spur_low  - GAP - 1;

	PHY_XTALCAL(("Center=%d MHz, harmonic=%d, spur=%d kHz/tone %d.%d\n",
	             center_mhz, harmonic, spur_khz,
	             tone_shift22 >> 22, (100 * (tone_shift22 & 0xFFF) >> 22)));
	PHY_XTALCAL(("Spur: low,high= %d,%d, noise: 1,2=%d,%d\n",
	             spur_low, spur_high, noise1, noise2));

	pstate->spur_low  = wlc_acphy_bin2idx(spur_low,  pstate);
	pstate->spur_high = wlc_acphy_bin2idx(spur_high, pstate);
	pstate->noise1    = wlc_acphy_bin2idx(noise1,    pstate);
	pstate->noise2    = wlc_acphy_bin2idx(noise2,    pstate);

	PHY_XTALCAL(("Spur: idx %d,%d, noise idx %d,%d\n",
	            pstate->spur_low, pstate->spur_high, pstate->noise1, pstate->noise2));

	return TRUE;
}

/* Set (or undo) the nmos/pmos radio override */
static void
wlc_acphy_override_nmos_pmos(phy_info_t *pi, bool on)
{
	uint8 val = on ? 1: 0;
	MOD_RADIO_REG(pi, RFP,  GE16_OVR23, ovr_xtal_coresize_nmos, val);
	MOD_RADIO_REG(pi, RFP,  GE16_OVR23, ovr_xtal_coresize_pmos, val);
}

/* Set the nmos/pmos driver strength using radio overrides
 * Could also be done using PMU_CHIPCTL0 but values are then not immediately updated
 */
static void
wlc_acphy_set_nmos_pmos(phy_info_t *pi, uint8 nmos, uint8 pmos)
{
	uint16 regval;
	const uint16 nmos_mask  = RF_2069_PLL_XTAL1_xtal_coresize_nmos_MASK;
	const uint16 pmos_mask  = RF_2069_PLL_XTAL1_xtal_coresize_pmos_MASK;
	const uint16 nmos_shift = RF_2069_PLL_XTAL1_xtal_coresize_nmos_SHIFT;
	const uint16 pmos_shift = RF_2069_PLL_XTAL1_xtal_coresize_pmos_SHIFT;

	regval = read_radio_reg(pi, RFP_2069_PLL_XTAL1);

	/* Prevent "all zero" going over from one value to another */
	if (((regval & nmos_mask) & ((nmos << nmos_shift) == 0)) ||
	    ((regval & pmos_mask) & ((pmos << pmos_shift) == 0))) {

		/* set nmos/pmos = 31/31 intermediate */
		regval &= ~(nmos_mask | pmos_mask);
		regval |= 31 << nmos_shift;
		regval |= 31 << pmos_shift;
		write_radio_reg(pi, RFP_2069_PLL_XTAL1, regval);
		PHY_XTALCAL(("n/pmos=31/31\n"));
	}

	/* set the desired value */
	regval &= ~(nmos_mask | pmos_mask);
	regval |= nmos << nmos_shift;
	regval |= pmos << pmos_shift;
	write_radio_reg(pi, RFP_2069_PLL_XTAL1, regval);

	PHY_XTALCAL(("npmos=%2d/%2d\n", nmos, pmos));
}

/* Read I/Q data from the sample collect buffer and return an approximated absolute value */
static uint16
wlc_acphy_get_bin_abs_val(phy_info_t *pi, int offset)
{
	uint32 data;
	int16 ival, qval;
	uint16 ret;

	/* Set the address and read the data from template memory */
	wlapi_bmac_templateptr_wreg(pi->sh->physhim, offset << 2);
	data = wlapi_bmac_templatedata_rreg(pi->sh->physhim);
	data = htol32(data);

	/* 32-bit value (two 16-bit signed values) --> two 16 bit absolute/positive values */
	ival = (int16)(data >> 16);
	qval = (int16)(data & 0xFFFF);

	ival = (ival >= 0) ? ival : -ival;
	qval = (qval >= 0) ? qval : -qval;

	/* Calculate/approximate absolute value */
	if (ival > qval) {
		ret = ival + (qval >> 1);
	} else {
		ret = qval + (ival >> 1);
	}

	return ret;
}

/* Do a sample capture and return the spur and noise level for the given idx's */
static void
wlc_acphy_measure_spur_level(npmos_cal_state_t *pstate)
{
	phy_info_t *pi = pstate->pi;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	wl_samplecollect_args_t collect;
#ifdef SAMPLE_COLLECT
	uint32 buf[(sizeof(wl_sampledata_t) >> 2) + FILE_HDR_LEN];
#endif // endif
	uint32 spur_total = 0, noise_total = 0;
	uint32 length;
	uint16 last_avg_noise = pi_ac->cal_avg_noise;
	uint16 nfft = pstate->nfft;
	uint32 offset_fft;
	bool noise_updated = TRUE;
	bool valid;
	int ret;

	/* Do the sample collect */
	collect.cores = 1;
	collect.pre_dur = 0;
	collect.post_dur = 100;
	collect.timeout = 1000;
	collect.trigger = TRIGGER_NOW;
	collect.be_deaf = FALSE;	/* Already done in wlc_acphy_nmos_pmos_wrapper */
	collect.agc = FALSE;
	collect.mode = SC_MODE_14_spect_ana;
#ifdef SAMPLE_COLLECT
	/* Only used in the full-blown sample_collect */
	collect.gpio_sel = 0;
	collect.filter = FALSE;
	/* Part of the collect struct but not used in ACPHY sample_collect
	collect.coll_us = 100;
	collect.version = 2;
	collect.length = 48;
	collect.downsamp = 0;
	*/
	ret = wlc_phy_sample_collect_acphy(pi, &collect, buf);
#else
	ret = wlc_phy_spectrum_collect_acphy(pi, &collect);
#endif // endif
	if (ret != BCME_OK) {
		PHY_XTALCAL(("sample_collect err=%d\n", ret));
		pstate->fail++;
		return;
	}

	/* Process the data, normally done in wlc_phy_sample_data_acphy */

	/* As we do TRIGGER_NOW with pre_dur == 0, there should be no wrapping */
	ASSERT((pi_ac->pstop < pi_ac->pfirst) || (pi_ac->pstop >= pi_ac->plast));

	length = (pi_ac->plast - pi_ac->pfirst);
	for (offset_fft = 0; offset_fft < length - nfft; offset_fft += nfft) {
		int offset = pi_ac->pfirst + offset_fft;
		spur_total  += wlc_acphy_get_bin_abs_val(pi, offset + pstate->spur_low);
		spur_total  += wlc_acphy_get_bin_abs_val(pi, offset + pstate->spur_high);
		noise_total += wlc_acphy_get_bin_abs_val(pi, offset + pstate->noise1);
		noise_total += wlc_acphy_get_bin_abs_val(pi, offset + pstate->noise2);
	}
	/* Should not happen, just to be sure */
	if (spur_total  > 0xFFFF)
	    spur_total  = 0xFFFF;
	if (noise_total > 0xFFFF)
	    noise_total = 0xFFFF;

	/* Save for higher layer function */
	pi_ac->cal_spur_lvl = (uint16)spur_total;	/* Should be saved over time */
	pstate->noise_lvl   = (uint16)noise_total;	/* Only for calling functions */

	/* Check/update noise */
	if (pi_ac->cal_avg_noise) {

		/* If the noise is 3 dB(m) or 1.41421 louder than the average */
		if ((128 * (uint16)noise_total) > (181 * pi_ac->cal_avg_noise)) {
			/* Too much noise variance */
			noise_updated = FALSE;
		} else {
			/* Update moving average */
			pi_ac->cal_avg_noise = (3 * last_avg_noise + noise_total) >> 2;
		}
	} else {
		/* Not initialized yet */
		pi_ac->cal_avg_noise = (uint16)noise_total;
	}

	/* Declare measurment valid if noise is fine or spur is 12 dB louder than noise */
	valid = noise_updated || (spur_total > 4 * noise_total);
	if (!valid)
		pstate->fail++;

	PHY_XTALCAL(("--> spur=%u, noise=%u (avg:%u): %s. %svalid\n", spur_total, noise_total,
	             pi_ac->cal_avg_noise, noise_updated ? "updated avg" : "too high",
	             valid ? "" : "in"));

}

#ifdef BCMDBG_XTALCAL
/* Code to dump the samples */
void
wlc_acphy_dump_samples(npmos_cal_state_t *pstate)
{
	uint8 bin, spur_low;
	phy_info_t *pi = pstate->pi;
	phy_info_acphy_t *pi_ac = (phy_info_acphy_t *)pi->u.pi_acphy;
	uint16 nfft = pstate->nfft;
	uint16 harmonic, val;
	uint32 spur_khz;
	int32 tone_shift22;
	char header[80];
	char *pheader = header;
	char vals[80];
	char *pvals = vals;

	/* Code from wlc_acphy_init_xtal_spur but as this is debug-only code, just copy it */
	chanspec_t channel = CHSPEC_CHANNEL(pi->radio_chanspec);
	uint16 center_mhz = (uint16)wlc_phy_chan2fc_acphy(channel);
	if (PHY_XTAL_IS40M(pi)) {
		harmonic = (center_mhz + 20) / 40;
		spur_khz = 40000 * harmonic;
	} else if (PHY_XTAL_IS37M4(pi)) {
		harmonic = (10 * center_mhz + 187) / 374;
		spur_khz = 37400 * harmonic;
	} else {
		return;
	}

	/* tone_fractional = ((spur_mhz - center_mhz) / 20.0) * 64 */
	/* 2^22 * tone_fractional = (spur_mhz - center_mhz) * 13421.773 */
	tone_shift22 = (spur_khz - 1000 * (int32)center_mhz) * 13422;
	spur_low = (uint8)((nfft >> 1) + (tone_shift22 >> 22));	/* 32..31 --> 0..63 */

	for (bin = spur_low - 6; bin <= spur_low + 7; bin++) {
		uint8 idx = wlc_acphy_bin2idx(bin, pstate);
		if (idx == pstate->spur_low) {
			pheader += sprintf(pheader, "^%3d ", idx);
		} else if (idx == pstate->spur_high) {
			pheader += sprintf(pheader, " %3d^", idx);
		} else if (idx == pstate->noise1) {
			pheader += sprintf(pheader, "~%3d ", idx);
		} else if (idx == pstate->noise2) {
			pheader += sprintf(pheader, " %3d~", idx);
		} else {
			pheader += sprintf(pheader, " %3d ", idx);
		}
		int offset = pi_ac->pfirst + idx;
		val = wlc_acphy_get_bin_abs_val(pi, offset);
		pvals += sprintf(pvals, "%4d ", val);
	}
	PHY_PRINT(("%s\n", header));
	PHY_PRINT(("%s\n", vals));
}
#endif /* BCMDBG_XTALCAL */

/* Wrapper around wlc_acphy_set_nmos_pmos and wlc_phy_measure_spur_level */
static uint16
wlc_acphy_get_npmos_spur_level(npmos_cal_state_t *pstate, uint8 nmos, uint8 pmos)
{
	if (!pstate->fail) {

		wlc_acphy_set_nmos_pmos(pstate->pi, nmos, pmos);
		OSL_DELAY(10); /* time to stabilize */
		wlc_acphy_measure_spur_level(pstate);

#ifdef BCMDBG_XTALCAL
		wlc_acphy_dump_samples(pstate);
#endif /* BCMDBG_XTALCAL */
	}

	return pstate->pi->u.pi_acphy->cal_spur_lvl;
}

/* Core calibration routine of the Xtal nmos/pmos spur calibration */
static void
wlc_acphy_cal_xtal_nmos_pmos(npmos_cal_state_t *pstate)
{
	uint8 i;
	uint8 line_nmos[13];
	uint8 line_pmos[13];
	uint16 val, best_val;
	uint8 idx, best_idx, last_idx, mid_idx;
	uint8 idxs[] = {2, 6, 10};
	uint8 nmos, pmos, best_nmos, best_pmos;
	uint8 min_nmos, min_pmos, max_nmos, max_pmos;

	/* Backup setting for the case the cal fails */
	uint16 xtal_backup = read_radio_reg(pstate->pi, RFP_2069_PLL_XTAL1);

	/* Make sure we can control nmos/pmos drive */
	wlc_acphy_override_nmos_pmos(pstate->pi, TRUE);

	/* Diagonal line over pattern */
	for (i = 0; i <= 12; i++) {
		line_nmos[i] = 19 + i;
		line_pmos[i] = 31 - i;
	}

	/* Take smallest of three samples */
	/* 0..12 = ..o...o...o.. */
	best_val = 0xFFFF;
	best_idx = idxs[0];
	for (i = 0; i < ARRAYSIZE(idxs); i++) {
		idx = idxs[i];
		val = wlc_acphy_get_npmos_spur_level(pstate, line_nmos[idx], line_pmos[idx]);
		if (pstate->fail)
			goto fail;

		if (val < best_val) {
			best_val = val;
			best_idx = idx;
		}
	}

	PHY_XTALCAL(("cal_xtal #1: best of three is %d at %d/%d\n",
	             best_val, line_nmos[best_idx], line_pmos[best_idx]));

	/* See if left or right on the line we can find a lower value */
	last_idx = best_idx;    /* To remember where we came from */

	idx = best_idx - 1;
	val = wlc_acphy_get_npmos_spur_level(pstate, line_nmos[idx], line_pmos[idx]);
	if (pstate->fail)
		goto fail;

	if (val < best_val) {
		best_idx = idx;
		best_val = val;

		idx--;
		val = wlc_acphy_get_npmos_spur_level(pstate, line_nmos[idx], line_pmos[idx]);
		/* check below */

	} else {

		idx = best_idx + 1;
		val = wlc_acphy_get_npmos_spur_level(pstate, line_nmos[idx], line_pmos[idx]);
		if (pstate->fail)
			goto fail;

		if (val < best_val) {
			best_idx = idx;
			best_val = val;

			idx++;
			val = wlc_acphy_get_npmos_spur_level(pstate,
			                                     line_nmos[idx], line_pmos[idx]);
			/* check below */
		}
	}
	/* Check for the measurement above */
	if (pstate->fail)
		goto fail;

	if (val < best_val) {
		last_idx = best_idx;
		best_idx = idx;
		best_val = val;
	}

	PHY_XTALCAL(("cal_xtal #2: best of line is %d at %d/%d\n",
	             best_val, line_nmos[best_idx], line_pmos[best_idx]));

	/* Search surroundings */
	mid_idx = best_idx;
	best_nmos = line_nmos[best_idx];
	best_pmos = line_pmos[best_idx];

	min_nmos = MAX(best_nmos - 1, 8);
	max_nmos = MIN(best_nmos + 1, 31);
	min_pmos = MAX(best_pmos - 1, 8);
	max_pmos = MIN(best_pmos + 1, 31);

	for (nmos = min_nmos; nmos <= max_nmos; nmos++) {
		for (pmos = min_pmos; pmos <= max_pmos; pmos++) {

			/* Skip what is already done */
			if (nmos == line_nmos[last_idx] && pmos == line_pmos[last_idx]) {
				PHY_XTALCAL(("Skip %d/%d\n", nmos, pmos));
				continue;
			}
			if (nmos == line_nmos[mid_idx] && pmos == line_pmos[mid_idx]) {
				PHY_XTALCAL(("Skip %d/%d\n", nmos, pmos));
				continue;
			}

			val = wlc_acphy_get_npmos_spur_level(pstate, nmos, pmos);
			if (pstate->fail)
				goto fail;

			if (val < best_val) {
				best_val = val;
				best_nmos = nmos;
				best_pmos = pmos;
			}
		}
	}

	/* Apply the best settings */
	wlc_acphy_set_nmos_pmos(pstate->pi, best_nmos, best_pmos);
	PHY_XTALCAL(("cal_xtal #3: best of surroundings is %d at %d/%d\n",
	             best_val, best_nmos, best_pmos));

	/* Save for next verify (cal_avg_noise is taken care of already) */
	pstate->pi->u.pi_acphy->cal_spur_lvl = best_val;
	return;

fail:
	write_radio_reg(pstate->pi, RFP_2069_PLL_XTAL1, xtal_backup);
	PHY_XTALCAL(("cal_xtal failure, nmos/pmos not updated\n"));
}

/* Calibration/verification wrapper routine */
static void
wlc_acphy_nmos_pmos_wrapper(bool do_cal, npmos_cal_state_t *pstate)
{
	phy_info_t *pi = pstate->pi;
	uint8 save_active_rxchains = 0;  /* Local copy of rxchains */
	uint8 save_EnTx = 0;             /* Local copy of EnTx */
	uint8 force_turnon = 0;          /* Flag to remember force turn-on */
	uint8 core = pstate->core;

	/* CRDOT11ACPHY-1362: Spectrum Analyzer sample collect mode not working correctly
	 * for single core A1
	 * Force turn-on rxchains if necessary
	 *
	 * NOTE: Do this before wlapi_suspend_mac_and_wait as wlc_phy_rxcore_setstate_acphy
	 *       is undoing wlapi_suspend_mac_and_wait
	 */
	if (pi->sh->phyrxchain != pi->sh->hw_phyrxchain) {
		save_active_rxchains = pi->sh->phyrxchain;
		pi->sh->phyrxchain = pi->sh->hw_phyrxchain;
		save_EnTx = READ_PHYREGFLD(pi, RfseqCoreActv2059, EnTx);
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->hw_phyrxchain);
		force_turnon = 1;
	}

	wlapi_suspend_mac_and_wait(pi->sh->physhim);
	wlc_phyreg_enter((wlc_phy_t *)pi);

	/* Switch T/R to T to attenuate the receive */
	MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_tx_pu, 1);
	MOD_PHYREGCE(pi, RfctrlIntc, core, tr_sw_rx_pu, 0);
	MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 1);

	/* Disable CRS, clip detect and ED, i.e. be_deaf */
	wlc_phy_stay_in_carriersearch_acphy(pi, TRUE);

	/* Actual calibration or verification */
	if (do_cal) {
		wlc_acphy_cal_xtal_nmos_pmos(pstate);
	} else {
		wlc_acphy_measure_spur_level(pstate);
	}

	/* Exit from be_be_deaf */
	wlc_phy_stay_in_carriersearch_acphy(pi, FALSE);

	/* T/R back to auto */
	MOD_PHYREGCE(pi, RfctrlIntc, core, override_tr_sw, 0);

	/* Testing things we saw the PHY sometimes hanging in PAY_DECODE */
	wlc_phy_resetcca_acphy(pi);

	wlc_phyreg_exit((wlc_phy_t *)pi);
	wlapi_enable_mac(pi->sh->physhim);

	/* Restore rxchains to original state */
	if (force_turnon) {
		pi->sh->phyrxchain = save_active_rxchains;
		wlc_phy_rxcore_setstate_acphy((wlc_phy_t *)pi, pi->sh->phyrxchain);
		/* Restore original value of EnTx */
		MOD_PHYREG(pi, RfseqCoreActv2059, EnTx, save_EnTx);
	}
}

/* Entry point from wlc_phy_cals_acphy
 * - If force is FALSE, first the spur is measured and compared with the last calibrate level
 *   and if too high, a calibration is done. If TRUE, the calibration is done always.
 * - If cts2self, wlc_phy_susp2tx_cts2self is called (to make phyreg_enter & mac_suspend in sync)
 *
 *   Returns a bool indicating something is done or cal is completely (incl. cts2self) skipped;
 */
static bool
wlc_acphy_cal_xtal_spur(phy_info_t *pi, bool force, bool cts2self)
{
	bool do_cal = force;

	/* Check if we need to calibrate for this chip and this channel and if so,
	 * get the initialized calibration state struct
	 */
	npmos_cal_state_t state;
	if (!wlc_acphy_init_xtal_spur(pi, &state)) {
		return FALSE;
	}

	/* Do we need to check if the spur is too high compared to last known value? */
	if (!force && (pi->u.pi_acphy->cal_spur_lvl > 0)) {
		uint16 last_spur_lvl = pi->u.pi_acphy->cal_spur_lvl; /* back up */

		/* Measure the spur */
		wlc_acphy_nmos_pmos_wrapper(FALSE, &state);

		/* If the new spur level is 3 dB(m) or 1.41421 louder than the previous */
		if ((128 * pi->u.pi_acphy->cal_spur_lvl) > (181 * last_spur_lvl)) {
			do_cal = TRUE;
		}
		PHY_XTALCAL(("cal_xtal_spur: spur was %d, now %d, %scalibrate\n", last_spur_lvl,
			pi->u.pi_acphy->cal_spur_lvl, do_cal ? "": "do not "));
	}

	if (do_cal) {
		if (cts2self) {
			wlc_phy_susp2tx_cts2self(pi, 4500);
		}
		/* Calibrate down the spur */
		wlc_acphy_nmos_pmos_wrapper(TRUE, &state);
	} else {
		if (cts2self) {
			/* To make phyreg_enter & mac_suspend in sync */
			wlc_phy_susp2tx_cts2self(pi, 0);
		}
	}

	return TRUE;
}

#if defined(WLTEST)

/* nmos/pmos calibration wl interface routine */
int
wlc_acphy_do_nmos_pmos(phy_info_t *pi, void *pparams)
{
	phy_cal_xtal_spur_t *p_wl_params = (phy_cal_xtal_spur_t *)pparams;
	npmos_cal_state_t state;

	/* Check if applicable for this chip/channel and if so get initialize state struct */
	if (!wlc_acphy_init_xtal_spur(pi, &state)) {
		return BCME_OUTOFRANGECHAN;
	}

	/* Override core */
	state.core = p_wl_params->cmd_stat & CAL_XTAL_COREMASK;

	/* Execute cal and/or verify */
	if (p_wl_params->cmd_stat & CAL_XTAL_EXECUTE) {
		wlc_acphy_nmos_pmos_wrapper(TRUE, &state);
	}
	if (p_wl_params->cmd_stat & CAL_XTAL_VERIFY) {
		wlc_acphy_nmos_pmos_wrapper(FALSE, &state);
	}

	/* Return parameters */
	p_wl_params->nmos  = READ_RADIO_REGFLD(pi, RFP, PLL_XTAL1, xtal_coresize_nmos);
	p_wl_params->pmos  = READ_RADIO_REGFLD(pi, RFP, PLL_XTAL1, xtal_coresize_pmos);
	p_wl_params->spur  = pi->u.pi_acphy->cal_spur_lvl;
	p_wl_params->noise = state.noise_lvl;

	if (state.fail) {
		p_wl_params->cmd_stat |= CAL_XTAL_FAIL;
		PHY_XTALCAL(("Cal failed: spur=%u, noise=%u --> keep npmos=%2d/%2d\n",
		             p_wl_params->spur, p_wl_params->noise, p_wl_params->nmos,
		             p_wl_params->pmos));
	} else {
		PHY_XTALCAL(("Final npmos=%2d/%2d --> spur=%u, noise=%u\n",
		             p_wl_params->nmos, p_wl_params->pmos, p_wl_params->spur,
		             p_wl_params->noise));
	}

	return BCME_OK;
}

#endif // endif

#endif /* PHY_XTAL_SPUR_CAL */

#endif /* ACCONF != 0 */
