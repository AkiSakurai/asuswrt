# Back-end subdir level makefile for hndrte based standalone programs
#
# Broadcom Proprietary and Confidential. Copyright (C) 2017,
# All Rights Reserved.
# 
# This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom;
# the contents of this file may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior
# written permission of Broadcom.
#
# $Id: Makefile.top 669846 2016-11-11 10:24:12Z $
#
# Usage:
# 	gmake SUBDIR=<subdir> [<brand> | <brand>/{usb|sdio}-{g|ag}-{cdc|rndis}...]
#
# Use V=[1|2|3] to display verbose output (all compile lines)
#
# Targets consisting of build specifications in the above form are built if
# specified on the command line. Otherwise, the list of TARGETS are built
# for the brand.
#
# Example 1: all default targets of all brands
#	gmake SUBDIR=<subdir>
#
# Example 2: all default targets of a particular brand
#	gmake SUBDIR=<subdir> <brand>
#
# Example 3: a paricular target of a particular brand
#       gmake SUBDIR=<subdir> <brand>/usb-ag-rndis-reclaim-ccx
#
# The first section of this Makefile runs in the <subdir> directory.
# For each brand it creates a directory of the same name, descends
# into it, and re-runs itself to start the brand build with INBRANDDIR
# variable defined to 'true'.
#
# The second section of this Makefile handles the brand build inside
# the brand directory in which it starts the target build if the brand
# make file specifies a single target (without TARGETS variable defined
# in the brand make file), or it performs the similar build process to
# the first section in that it creates a directory, descends into it,
# and re-run itself to start the target build with INTARGETDIR variable
# defined to 'true'.
#
# The third section of this Makefile handles the target build inside
# the brand directory or the target directory in which images are built.
#

# sanity checks
ifeq ($(TOPDIR),)
$(error TOPDIR is not defined)
endif

ifeq ($(TOPMK),)
$(error TOPMK is not defined)
endif

ifeq ($(SUBDIR),)
$(error SUBDIR is not defined)
endif

ifeq ($(TOPBLDDIR),)
$(error TOPBLDDIR is not defined)
endif

ifeq ($(SUBBLDDIR),)
$(error SUBBLDDIR is not defined)
endif

# things may be needed by all steps of make/build
MAKEFILE ?= $(TOPDIR)/$(TOPMK)

# Used for verbosity, keep the formatting in one place
define ANNOUNCE
echo "-------- $1: $2 from $(subst $(abspath $(TOPDIR)/..)/,,$(CURDIR)) --------"
endef

################################################################################
################# section 1. invoked from the top level directory ##############
################################################################################
ifeq ($(INBRANDDIR),)

BRANDS := $(patsubst $(TOPDIR)/$(SUBDIR)/%.mk,%,$(wildcard $(TOPDIR)/$(SUBDIR)/*.mk))

ifeq ($(SUBBLDDIR),.)
BLDDIR := $(TOPBLDDIR)
else
BLDDIR := $(TOPBLDDIR)/$(SUBBLDDIR)
endif

# remove all brands
# make clean
.PHONY: clean
clean: $(BRANDS:=/clean)

empty :=
1space := $(empty) $(empty)
4space := $(empty)    $(empty)

# remove all targets in a brand
# make <brand>/clean
.PHONY: $(BRANDS:=/clean)
$(BRANDS:=/clean): _BLDDIR=$(BLDDIR)/$(@:/clean=)
$(BRANDS:=/clean): _BLDTGT=$(patsubst $(_BLDDIR)/%,%,$(wildcard $(_BLDDIR)/*))
$(BRANDS:=/clean):
	if [ -d $(_BLDDIR) ]; then \
		echo "Removing $(_BLDDIR)"; \
		$(if $(_BLDTGT),echo -e "$(4space)$(subst $(1space),\n$(4space),$(_BLDTGT))";) \
		$(RM) -r $(_BLDDIR); \
	fi

# remove a target in a brand
# make <brand>/<target>/clean
.PHONY: $(BRANDS:=/%/clean)
$(BRANDS:=/%/clean): _BLDDIR=$(BLDDIR)/$(@:/clean=)
$(BRANDS:=/%/clean):
	if [ -d $(_BLDDIR) ]; then \
		echo "Removing $(_BLDDIR)"; \
		$(RM) -r $(_BLDDIR); \
	fi

# show all brands
# make showbrands
.PHONY: showbrands
showbrands:
	@$(foreach _BRAND,$(BRANDS),echo "$(SUBDIR)/$(_BRAND)";)

# show all targets in brands
# make showtgts
.PHONY: showtgts
showtgts: $(BRANDS:=/showtgts)
# show all targets in a brand
# make <brand>/showtgts
.PHONY: $(BRANDS:=/showtgts)
$(BRANDS:=/showtgts): _BRAND = $(firstword $(subst /, ,$@))
$(BRANDS:=/showtgts):
	$(MAKE) -f $(MAKEFILE) INBRANDDIR=true CBRAND=$(_BRAND) $(@:$(_BRAND)/%=%)

# show all brands that need maxsize checked
# make showmaxsize_tgts
.PHONY: showmaxsize_tgts
showmaxsize_tgts: $(BRANDS:=/showmaxsize_tgts)
# show all targets in a brand
# make <brand>/showmaxsize_tgts
.PHONY: $(BRANDS:=/showmaxsize_tgts)
$(BRANDS:=/showmaxsize_tgts): _BRAND = $(firstword $(subst /, ,$@))
$(BRANDS:=/showmaxsize_tgts):
	$(MAKE) -f $(MAKEFILE) INBRANDDIR=true CBRAND=$(_BRAND) $(@:$(_BRAND)/%=%)

# build all brands
# make [all]
.PHONY: all
all: | $(BRANDS)

# build all targets in a brand
# make <brand>
$(BRANDS): FORCE
	@$(call ANNOUNCE,Building,$(BLDDIR)/$@)
	@install -d $(BLDDIR)/$@
	$(MAKE) -C $(BLDDIR)/$@ -f $(MAKEFILE) INBRANDDIR=true CBRAND=$@
	@$(call ANNOUNCE,Done,$(BLDDIR)/$@)

# build a target in a brand
# NOTE: This target is built on parallel cluster, so temporary files and dirs
# NOTE: need to be created conditionally
# make <brand>/<target>
$(BRANDS:=/%): _BRAND = $(firstword $(subst /, ,$@))
$(BRANDS:=/%): _TARGET = $(@:$(_BRAND)/%=%)
$(BRANDS:=/%): FORCE
	@$(call ANNOUNCE,Building,$(BLDDIR)/$@)
	@install -d $(BLDDIR)/$(_BRAND)
	$(MAKE) -C $(BLDDIR)/$(_BRAND) -f $(MAKEFILE) INBRANDDIR=true CBRAND=$(_BRAND) TARGET=$(_TARGET) $(_TARGET)
	@$(call ANNOUNCE,Done,$(BLDDIR)/$@)

################################################################################
################ section 2. invoked from the brand directory ###################
################################################################################
else	# ifeq ($(INBRANDDIR),true)

ifeq ($(CBRAND),)
$(error CBRAND is not defined)
endif


ifneq ($(TARGET),)
  # 'TARGET_OPTIONS' is a '-' delimited string of features included in the target, e.g. sdio-ag-p2p.
  # For backwards compatibility, this defaults to the user specified target.
  TARGET_OPTIONS := $(firstword $(subst /, ,$(TARGET)))

  # Check for user specified config based target (e.g. 'config_sdio_release'). Must be named
  # 'config_[bus-type]_xxx'. These are an alternative to the '-' delimited string of features
  # target names.
  TARGET_CONFIG_WORDS := $(subst _, ,$(TARGET))
  ifeq ($(firstword $(TARGET_CONFIG_WORDS)),config)
    TARGET_CONFIG_NAME := $(TARGET_OPTIONS)

    # Validate that bus type is specified - 'config_[bus-type]_xxx'.
    VALID_HBUS_TYPES := sdio usb pcie m2m
    HBUS_TYPE := $(word 2,$(TARGET_CONFIG_WORDS))
    ifneq ($(filter $(HBUS_TYPE),$(VALID_HBUS_TYPES)),$(HBUS_TYPE))
      $(error "Target name must be config_[bus-type]_xxx")
    endif

    # Include the config makefile that maps config based target names to features.
    TARGET_CONFIG_FILE := $(TOPDIR)/$(SUBDIR)/config/$(CBRAND)-config.mk
    include $(TARGET_CONFIG_FILE)

    # The config makefile should have a list of variables that map config names to features.
    # The variables should be named 'TARGET_OPTIONS_config_[bus-type]_xxx', e.g.
    #    TARGET_OPTIONS_config_sdio_release := sdio-g-p2p
    #    TARGET_OPTIONS_config_sdio_debug   := sdio-g-p2p-err-assert
    ifeq ($(TARGET_OPTIONS_$(TARGET_CONFIG_NAME)),)
      $(error "'TARGET_OPTIONS_$(TARGET_CONFIG_NAME)' does not exist in '$(TARGET_CONFIG_FILE)'")
    endif
    TARGET_OPTIONS := $(TARGET_OPTIONS_$(TARGET_CONFIG_NAME))
    $(info SK_DBG-TOP FW CHIP=$(CHIP) TARGET_CONFIG_NAME=$(TARGET_CONFIG_NAME) )
    $(info SK_DBG-TOP FW CHIP=$(CHIP) TARGET_OPTIONS=$(TARGET_OPTIONS_$(TARGET_CONFIG_NAME)) )
  endif # config_xxx TARGET
endif # TARGET

# Define function to return 1 if TARGET_OPTIONS string contains specified option, 0 otherwise
opt = $(if $(findstring -$1-,-$(TARGET_OPTIONS)-),1,0)


# include brand makefile
include $(TOPDIR)/$(SUBDIR)/$(CBRAND).mk

# include subdir common config
ifneq ($(wildcard $(TOPDIR)/$(SUBDIR)/rules.cmn),)
include $(TOPDIR)/$(SUBDIR)/rules.cmn
endif

# CHIP must be defined by each brand
ifeq ($(CHIP),)
.PHONY: nochip
nochip:
	@echo "ignore $(CBRAND)$(if $(TARGET),/$(TARGET)), CHIP variable is not defined"
endif
# CHIP must be single chip
ifneq ($(words $(CHIP)),1)
.PHONY: multichip
multichip:
	@echo "ignore $(CBRAND)$(if $(TARGET),/$(TARGET)), CHIP variable is defined for more than one chip"
endif
ifeq ($(RXOE),1)
CHIP_SUFFIX := $(firstword $(subst -, ,$(CBRAND)))
endif
#*******************************************************************************
#*************************** single target brand *******************************
#*******************************************************************************
ifeq ($(INTARGETDIR),)

ifeq ($(TARGETS),)

# build the single target specified in the brand make file
ifeq ($(TARGET),)
.PHONY: all
all:
	@$(call ANNOUNCE,Building,$(CBRAND))
	$(MAKE) -f $(MAKEFILE) INTARGETDIR=true MAXSIZE=$(MAXSIZE)
	@$(call ANNOUNCE,Done,$(CBRAND))
else
$(TARGET): FORCE
	@$(call ANNOUNCE,Building,$@)
	$(MAKE) -f $(MAKEFILE) INTARGETDIR=true MAXSIZE=$(MAXSIZE) $@
	@$(call ANNOUNCE,Done,$@)
endif
# show target
.PHONY: showtgts
showtgts:
#	@echo "$(SUBDIR)/$(CBRAND)"
	@echo "$(CBRAND)"

.PHONY: showmaxsize_tgts
showmaxsize_tgts:

#*******************************************************************************
#************************* multiple targets brand ******************************
#*******************************************************************************
else	# ifneq ($(TARGETS),)

# build all targets specified in the brand make file
.PHONY: all
all:  $(TARGETS)

# show targets
.PHONY: showtgts
showtgts:
#	@$(foreach _TARGET,$(TARGETS),echo "$(SUBDIR)/$(CBRAND)/$(_TARGET)";)
	@$(foreach _TARGET,$(TARGETS),echo "$(CBRAND)/$(_TARGET)";)

# show targets that have maxsize limit set
.PHONY: showmaxsize_tgts
showmaxsize_tgts:
	@$(foreach _TARGET,$(TARGETS),$(if $($(_TARGET)-maxsize),echo "$(SUBDIR)/$(CBRAND)/$(_TARGET)";))

# build one target specified in the brand make file
$(sort $(TARGET) $(TARGETS)): _TARGET=$(firstword $(subst /, ,$@))
$(sort $(TARGET) $(TARGETS)): _REMAIN=$(@:$(_TARGET)%=%)
$(sort $(TARGET) $(TARGETS)): FORCE
	@$(call ANNOUNCE,Building,$(if $(_REMAIN),$(_REMAIN:/%=%),$(_TARGET)))
	install -d $(_TARGET)
	$(MAKE) -C $(_TARGET) -f $(MAKEFILE) INTARGETDIR=true TARGET=$(_TARGET) \
		$(if $(_REMAIN),$(_REMAIN:/%=%),MAXSIZE=$($@-maxsize) WARNLIMIT=$($@-warnlimit))
	@$(call ANNOUNCE,Done,$(if $(_REMAIN),$(_REMAIN:/%=%),$(_TARGET)))
ifndef ECLOUD_BUILD_ID
	@if [ -e $@ -a -d $@ ]; then \
		rmdir --ignore-fail-on-non-empty $@; \
	fi
endif # ECLOUD_BUILD_ID

endif	# ifneq ($(TARGETS),)

################################################################################
############## section 3. invoked from the brand/target directory ##############
################################################################################
else	# ifeq ($(INTARGETDIR),true)


# source tree base starting from src
SRCBASE := $(TOPDIR)/../../..

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++ target string parsing ++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# host bus specific objects and flags and paths.
# TARGET_HBUS variable precedes target string -usb- or -sdio- option
# in which case TARGET_HBUS is config and target string is enable.

TARGET_HBUSCFG := $(findstring usb,$(TARGET_HBUS))+$(findstring sdio,$(TARGET_HBUS))+$(findstring pcie,$(TARGET_HBUS))+$(findstring m2m,$(TARGET_HBUS))
STRING_TARGET_HBUSCFG := $(call opt,usb)+$(call opt,sdio)+$(call opt,pcie)+$(call opt,m2m)

# XXX Treat it as an error when both -sdio- and -usb- are specified in target string
ifneq ($(GENROMTBL),1)
ifeq ($(STRING_TARGET_HBUSCFG),1+1)
$(error Two buses are enabled)
endif
endif

# XXX Treat it as an error when TARGET_HBUS is one and target string is another
ifeq ($(TARGET_HBUSCFG),usb+++)
ifeq ($(STRING_TARGET_HBUSCFG),0+1+0+0)
$(error TARGET_HBUS $(TARGET_HBUS) does not support SDIO)
endif
endif
ifeq ($(TARGET_HBUSCFG),+sdio++)
ifeq ($(STRING_TARGET_HBUSCFG),1+0+0+0)
$(error TARGET_HBUS $(TARGET_HBUS) does not support USB)
endif
endif
ifeq ($(TARGET_HBUSCFG),++pcie+)
ifeq ($(STRING_TARGET_HBUSCFG),1+0+0+0)
$(error TARGET_HBUS $(TARGET_HBUS) does not support USB)
endif
ifeq ($(STRING_TARGET_HBUSCFG),0+1+0+0)
$(error TARGET_HBUS $(TARGET_HBUS) does not support SDIO)
endif
endif
# HBUS for nic offloads
ifeq ($(TARGET_HBUS),pciol)
	HBUS_ENAB := pciol
ifneq ($(STRING_TARGET_HBUSCFG),0+0+0+0)
$(error TARGET_HBUS $(TARGET_HBUS) does not support USB or SDIO/PCIE/M2M)
endif
endif

# HBUS for M2M dma
ifeq ($(TARGET_HBUS),m2m)
	HBUS_ENAB := m2m
ifneq ($(STRING_TARGET_HBUSCFG),0+0+0+1)
$(error TARGET_HBUS $(TARGET_HBUS) does not support USB or SDIO/PCIE)
endif
endif

# derive TARGET_HBUS (if not defined) from target string
ifeq ($(STRING_TARGET_HBUSCFG),1+0+0+0)
	HBUS_ENAB := usb
endif
ifeq ($(STRING_TARGET_HBUSCFG),0+1+0+0)
	HBUS_ENAB := sdio
endif
ifeq ($(STRING_TARGET_HBUSCFG),0+0+1+0)
	HBUS_ENAB := pcie
endif
ifeq ($(STRING_TARGET_HBUSCFG),0+0+0+1)
	HBUS_ENAB := m2m
endif

ifeq ($(STRING_TARGET_HBUSCFG),0+0+0+0)
ifeq ($(TARGET_HBUSCFG),usb+++)
	HBUS_ENAB := usb
endif
ifeq ($(TARGET_HBUSCFG),+sdio++)
	HBUS_ENAB := sdio
endif
# pcie full dongle HBUS
ifeq ($(TARGET_HBUSCFG),++pcie+)
	HBUS_ENAB := pcie
endif
ifeq ($(TARGET_HBUSCFG),+++m2m)
	HBUS_ENAB := m2m
endif
endif	# STRING_TARGET_HBUSCFG 0+0
ifeq ($(HBUS_ENAB),usb)
	TARGET_HBUS ?= usb
	EXTRA_DFLAGS += -DBCMUSBDEV_ENABLED
endif
ifeq ($(HBUS_ENAB),sdio)
	TARGET_HBUS ?= sdio
	HBUS_PROTO  := cdc
	EXTRA_DFLAGS += -DBCMSDIODEV_ENABLED
endif
ifeq ($(HBUS_ENAB),pciol)
	TARGET_HBUS ?= pciol
	BCM_OL_DEV :=1
	EXTRA_DFLAGS += -DBCM_OL_DEV
endif
ifeq ($(HBUS_ENAB),pcie)
	TARGET_HBUS ?= pcie
	HBUS_PROTO  := msgbuf
	EXTRA_DFLAGS += -DBCMPCIEDEV_ENABLED
	ifeq ($(call opt,txpush),1)
		EXTRA_DFLAGS += -DBCMPCIE_SUPPORT_TX_PUSH_RING
	endif
endif

ifeq ($(HBUS_ENAB),m2m)
	TARGET_HBUS ?= m2m
	HBUS_PROTO  := cdc
	EXTRA_DFLAGS += -DBCMM2MDEV_ENABLED
endif

ifeq ($(TARGET_HBUS),)
$(error TARGET_HBUS is unknown or empty)
endif

ifndef HBUS_ENAB
# it's likely something fancy is being built so enable both SDIO and USB
ifeq ($(GENROMTBL),1)
ifeq ($(TARGET_HBUSCFG),usb+sdio+)
	EXTRA_DFLAGS += -DBCMUSBDEV_ENABLED -DBCMSDIODEV_ENABLED
else ifeq ($(TARGET_HBUSCFG),+sdio+pcie+)
	EXTRA_DFLAGS += -DBCMPCIEDEV_ENABLED -DBCMSDIODEV_ENABLED
else ifeq ($(TARGET_HBUSCFG),usb+sdio+pcie)
	EXTRA_DFLAGS += -DBCMUSBDEV_ENABLED -DBCMSDIODEV_ENABLED -DBCMPCIEDEV_ENABLED
else ifeq ($(TARGET_HBUSCFG),+sdio++m2m)
	EXTRA_DFLAGS += -DBCMSDIODEV_ENABLED -DBCMM2MDEV_ENABLED
else
$(error Invalid TARGET_HBUSCFG $(TARGET_HBUSCFG))
endif
endif
endif	# !HBUS_ENAB

# CPU specific objects and flags
ifeq ($(call opt,mips),1)
	TARGET_ARCH := mips
	TARGET_CPU := mips
endif
ifeq ($(call opt,arm),1)
	TARGET_ARCH := arm
endif
ifeq ($(TARGET_ARCH),)
$(error TARGET_ARCH is unknown)
endif

ifeq ($(call opt,cm3),1)
	TARGET_CPU := cm3
endif
ifeq ($(call opt,cr4),1)
	TARGET_CPU := cr4
endif
ifeq ($(call opt,ca7),1)
	TARGET_CPU := ca7
endif
ifeq ($(TARGET_CPU),)
$(error TARGET_CPU is unknown)
endif

ifeq ($(call opt,thumb),1)
	THUMB := 1
endif

# ThreadX
THREADX ?= 1
HNDRTE ?= 0
ifeq ($(call opt,threadx),1)
	THREADX := 1
	HNDRTE := 0
endif

ifeq ($(call opt,srvsdb),1)
	SRHWVSDB := 1
	# Makefile variable PHY_WLSRVSDB influences PHY cpp define WLSRVSDB only
	PHY_WLSRVSDB := 1
	SR_ESSENTIALS := 1
	SR_ESSENTIALS_DISABLED := 0
else
	SRHWVSDB_DISABLED := 1
	PHY_WLSRVSDB := 0
endif

ifeq ($(call opt,sr),1)
	SAVERESTORE := 1
	SAVERESTORE_DISABLED := 0
	SR_ESSENTIALS_DISABLED := 0
else
	ifeq ($(call opt,srfast),1)
		SRFAST := 1
		SAVERESTORE := 1
		SAVERESTORE_DISABLED := 0
	else
		SAVERESTORE_DISABLED := 1
	endif
endif

SR_ESSENTIALS_DISABLED ?= 1
# Host BUS protocol
ifeq ($(call opt,rndis),1)
	HBUS_PROTO := rndis
endif
ifeq ($(call opt,cdc),1)
	HBUS_PROTO := cdc
endif
ifeq ($(call opt,msgbuf),1)
	HBUS_PROTO := msgbuf
endif

# Check for invalid bus and protocol combinations
ifeq ($(HBUS_ENAB)+$(HBUS_PROTO),pcie+cdc)
$(error HBUS_PROTO cdc not supported by pcie)
endif
ifeq ($(HBUS_ENAB)+$(HBUS_PROTO),sdio+msgbuf)
$(error HBUS_PROTO msgbuf not supported by sdio)
endif

ifeq ($(HBUS_PROTO),)
$(error HBUS_PROTO is unknown)
endif

# 2.4G/5G band support
ifeq ($(call opt,g),1)
	BAND := g
endif
ifeq ($(call opt,ag),1)
	BAND := ag
endif
ifeq ($(BAND),)
$(error BAND is unknown)
endif

# interconnect/backplane specific objects and flags
ifeq ($(call opt,pci),1)
	TARGET_IBUS := pci
endif

# startup specific objects and flags
ifeq ($(call opt,boot),1)
	STARTUP := boot
endif

# use ROM library
ifeq ($(call opt,roml),1)
	ROMOFFLOAD := 1
	EXTRA_DFLAGS += -DBCMROMOFFLOAD_EXCLUDE_STDLIB_FUNCS
	EXTRA_DFLAGS += -DBCMROMOFFLOAD_EXCLUDE_BCMUTILS_FUNCS
endif

# enable mfgtest specific stuff
ifeq ($(call opt,mfgtest),1)
	MFGTEST := 1
	CAC_DISABLED := 1
	#OTP Unification
	ifeq ($(call opt,uotp),1)
		EXTRA_DFLAGS += -DUSBSDIOUNIFIEDOTP
	endif
else
	ifeq ($(ROMOFFLOAD),1)
		ifeq ($(call opt,ate),1)
			EXTRA_DFLAGS += -DBCMDBG_DUMP
		else
			EXTRA_DFLAGS += -DWLTEST_DISABLED
		endif
	endif
#OTP Unification: fail if mfgtest not included
ifeq ($(call opt,uotp),1)
$(error mfgtest not included)
endif
endif

ifeq ($(call opt,dfsradar),1)
	AP := 1
	WLC_DISABLE_DFS_RADAR_SUPPORT := 0
else
	ifneq ($(GENROMTBL),1)
		ifneq ($(call opt,slvradar),1)
			WLC_DISABLE_DFS_RADAR_SUPPORT ?= 1
		else
			WLC_DISABLE_DFS_RADAR_SUPPORT := 0
		endif
	endif
endif

# include stuff under BCMINTERNAL conditional
ifeq ($(call opt,internal),1)
	INTERNAL := 1
	WL_PROT_OBSS := 1
endif

# enable image update in flash capability
ifeq ($(call opt,upgrade),1)
	UPGRADE := 1
	FLASH := 1
endif

# enable flash memory support nvram variables read in FLASH
ifeq ($(call opt,flash),1)
	FLASH := 1
endif

# enable nvram variables read in SPROM/OTP
ifeq ($(call opt,nvram),1)
	NVRAM := 1
endif

# disable nvram variables from SPROM/OTP
ifeq ($(call opt,nocis),1)
	NVRAM := 0
endif

# enable retail specific stuff
ifeq ($(call opt,retail),1)
	RETAIL := 1
endif

# enable memory reclaim for init/up/down routines
# (attach functions are reclaimed regardless)
ifeq ($(call opt,reclaim),1)
	RECLAIM := 1
endif

# enable console support
ifeq ($(call opt,cons),1)
	CONSOLE := 1
endif

# enable inband trace
ifeq ($(call opt,msgtrace),1)
	MSGTRACE := 1
endif

# AUTH Shared Open
ifeq ($(call opt,wepso),1)
	WL_AUTH_METHOD_SHARED_OPEN := 1
	EXTRA_DFLAGS += -DWL_AUTH_METHOD_SHARED_OPEN
endif

# Reply AUTH Response according to mac filter
ifeq ($(call opt,authrmf),1)
	WLAUTHRESP_MAC_FILTER := 1
endif

# Ack suppression enable
ifeq ($(call opt,acksupr),1)
	ACKSUPR_MAC_FILTER := 1
endif

# Enable to control txpower
ifeq ($(call opt,txpwr),1)
	IOCTL_RESP_LARGE := 1
	WL_EXPORT_CURPOWER := 1
	WL_EXPORT_TXPOWER := 1
	EXTRA_DFLAGS += -DWL_EXPORT_CURPOWER
	EXTRA_DFLAGS += -DWL_EXPORT_TXPOWER
endif

# Enable APCS
ifeq ($(call opt,apcs),1)
	APCS := 1
	APCS_DISABLED := 0
else
	APCS_DISABLED := 1
endif

# enable FMC specific changes
ifeq ($(call opt,fmc),1)
	WLFMC := 1
	WLFMC_DISABLED := 0
else
	WLFMC_DISABLED := 1
endif

ifeq ($(call opt,okc),1)
	WL_OKC := 1
	EXTRA_DFLAGS += -DWL_OKC
endif

ifeq ($(call opt,rcc),1)
	WLRCC := 1
	WLRCC_DISABLED := 0
else
	WLRCC_DISABLED := 1
endif

ifeq ($(call opt,abt),1)
	WLABT := 1
	WLABT_DISABLED := 0
else
	WLABT_DISABLED := 1
endif

# build small image
ifeq ($(call opt,small),1)
	SMALL := 1
endif

# enable polling mode
ifeq ($(call opt,poll),1)
	POLL := 1
endif

# enable remotewl support with wifi only
ifeq ($(call opt,rwlwifi),1)
	RWL_WIFI := 1
	WLRWL := 1
	WIFI_ACT_FRAME := 1
	SEQ_CMDS := 1
endif

# enable d0 coalescing
ifeq ($(call opt,d0c),1)
	D0_COALESCING := 1
endif

# enable remotewl support with wifi and dongle driver
ifeq ($(call opt,wifireflector),1)
	WIFI_REFLECTOR := 1
	WLRWL := 1
	WIFI_ACT_FRAME := 1
	SEQ_CMDS := 1
endif

# enable remotewl support with wifi and dongle driver
ifeq ($(call opt,uartreflector),1)
	UART_REFLECTOR := 1
	UART := 1
	SEQ_CMDS := 1
endif

ifeq ($(call opt,rwl),1)
	RWL_WIFI := 1
	WLRWL := 1
	WIFI_ACT_FRAME := 1
	RWL_DONGLE := 1
	WLTEST := 1
	BAND := g
	UART := 1
endif

# enable remote sockets
ifeq ($(call opt,rsock),1)
	RSOCK := 1
endif

ifeq ($(call opt,pool),1)
	BCMPKTPOOL := 1
	EXTRA_DFLAGS += -DBCMPKTPOOL_ENABLED
endif

ifeq ($(call opt,dmatxrc),1)
	DMATXRC := 1
	DMATXRC_DISABLED := 0
else
	DMATXRC_DISABLED := 1
endif


ifeq ($(call opt,overthrust),1)
	WLOVERTHRUSTER := 1
	WLOVERTHRUSTER_DISABLED := 0
else
	WLOVERTHRUSTER_DISABLED := 1
endif

ifeq ($(call opt,rxov),1)
	WLRXOV := 1
	WLRXOV_DISABLED := 0
else
	WLRXOV_DISABLED := 1
endif

ifeq ($(call opt,fbt),1)
	WLFBT := 1
	WLFBT_DISABLED := 0
	WLCAC := 1
	CAC_DISABLED := 0
else
	WLFBT_DISABLED := 1
endif

ifeq ($(call opt,mbss),1)
	MBSS := 1
	MBSS_DISABLED := 0
else
	MBSS_DISABLED := 1
endif

ifeq ($(call opt,ndoe),1)
	WLNDOE := 1
	WLNDOE_DISABLED := 0
else
	WLNDOE_DISABLED := 1
endif

ifeq ($(call opt,tdls),1)
	WLTDLS := 1
	WLTDLS_DISABLED := 0
else
	WLTDLS_DISABLED := 1
endif

ifeq ($(call opt,wnm),1)
	WLWNM := 1
	WLWNM_DISABLED := 0
else
	WLWNM_DISABLED := 1
endif

ifeq ($(call opt,wl11k),1)
	WL11K := 1
	WL11K_DISABLED := 0
else
	WL11K_DISABLED := 1
endif

ifeq ($(call opt,pmmt),1)
        WL_PM_MUTE_TX := 1
endif

ifeq ($(call opt,scancache),1)
	WLSCANCACHE := 1
	WLSCANCACHE_DISABLED := 0
else
	WLSCANCACHE_DISABLED := 1
endif

ifeq ($(call opt,lpas),1)
	LPAS := 1
endif

# include stuff under BCM_BUZZZ conditional
ifeq ($(call opt,buzzz),1)
	BCM_BUZZZ := 1
endif

# include stuff under BCMDBG conditional
ifeq ($(call opt,debug),1)
	BCMDBG := 1
endif

# include stuff under BCMDBG_ASSERT conditional
ifeq ($(call opt,assert),1)
	DBG_ASSERT := 1
endif

# include stuff under BCMDBG_ERR conditional
ifeq ($(call opt,err),1)
	DBG_ERROR := 1
endif

# include stuff under BCMDBG_MEM conditional
ifeq ($(call opt,mem),1)
	DBG_MEM := 1
endif

ifeq ($(call opt,duration),1)
	WLDURATION := 1
endif

ifeq ($(call opt,sdlat),1)
	DBG_SDLAT := 1
endif

ifeq ($(call opt,memf),1)
	DBG_MEMFAIL := 1
endif

# include stuff under WLMSG_PRHDRS conditional
ifeq ($(call opt,prhdrs),1)
	PRHDRS := 1
endif

# include stuff under WLMSG_PRPKT conditional
ifeq ($(call opt,prpkt),1)
	PRPKT := 1
endif

# include stuff under WLMSG_INFORM conditional
ifeq ($(call opt,inform),1)
	INFORM := 1
endif

# include stuff under WLMSG_ASSOC conditional
ifeq ($(call opt,assoc),1)
	ASSOC := 1
endif

# include stuff under WLMSG_SRSCAN conditional
ifeq ($(call opt,srscan),1)
	SRSCAN := 1
	SRSCAN_DISABLED	:= 0
else
	SRSCAN_DISABLED	:= 1
endif

# include stuff under WLMSG_PS conditional
ifeq ($(call opt,ps),1)
	PS := 1
endif

# include stuff under WLMSG_WSEC conditional
ifeq ($(call opt,wsec),1)
	WSEC := 1
endif

# include stuff under WLMSG_MPC conditional
ifeq ($(call opt,mpc),1)
	MPC := 1
endif

# include stuff under WLMSG_SCAN conditional
ifeq ($(call opt,scan),1)
	SCAN := 1
endif

# include stuff under WLMSG_OID conditional
ifeq ($(call opt,oid),1)
	OID := 1
endif

# include stuff under WLMSG_BTA conditional
ifeq ($(call opt,bta),1)
	BTA := 1
endif

# include stuff under BCMDBG_DUMP conditional
ifeq ($(call opt,dump),1)
	DUMP := 1
endif

# PHYDUMP utility
ifeq ($(call opt,phydump),1)
	PHYDUMP := 1
	ifeq ($(call opt,pcie),1)
		PCIEDEV_MAX_IOCTLRSP_BUF_SIZE := 8192
	endif
	IOCTL_RESP_LARGE := 1
endif

# include stuff under WLMSG_ROAM conditional
ifeq ($(call opt,roamdbg),1)
	ROAM := 1
endif

# Loop back transmit packets
ifeq ($(call opt,lb),1)
	EXTRA_DFLAGS += -DDNGL_LB
endif

# QT
ifeq ($(call opt,qt),1)
	BCMQT := 1
endif

# WME
ifeq ($(call opt,wme),1)
	WME := 1
	WLCAC := 1
	CAC_DISABLED := 0
endif

# enable out-of-driver supplicant services, don't use with -idsup-
# (-ccx- is currently required with -extsup-)
ifeq ($(call opt,extsup),1)
	BCMEXTSUP := 1
endif

# CCX
CCX_DISABLED := 1
WLRM_DISABLED  :=1
ifeq ($(call opt,ccx),1)
	CCX := 1
	CCX_DISABLED := 0
	WLCAC := 1
	CAC_DISABLED := 0
	WLRM := 1
	WLRM_DISABLED := 0
endif

CCX_AP_KEEP_ALIVE_DISABLED :=0
# disable AP_KEEP_ALIVE when CCX enabled
ifeq ($(call opt,noccxaka),1)
	CCX_AP_KEEP_ALIVE_DISABLED := 1
endif

# RM
ifeq ($(call opt,rm),1)
	WLRM := 1
	WLRM_DISABLED  := 0
endif

# in-driver supplicants (WPA-PSK/WPA2-PSK), don't use with -extsup-
ifeq ($(call opt,idsup),1)
	IDSUP := 1
	IDSUP_DISABLED := 0
else
	IDSUP_DISABLED := 1
endif

# in-driver authenticators (WPA-PSK/WPA2-PSK)
ifeq ($(call opt,idauth),1)
	IDAUTH := 1
endif

# LED
ifeq ($(call opt,led),1)
	LED := 1
endif

# MONITOR
ifeq ($(call opt,monitor),1)
	WL_MONITOR := 1
	PROMISC := 1
endif

# STA MONITOR
ifeq ($(call opt,stamon),1)
	WL_MONITOR := 1
	PROMISC := 1
	WL_RADIOTAP := 1
	WL_STA_MONITOR := 1
	WL_STA_MONITOR_COMP := 1
endif

# PROMISC is normally enabled; target -nopromisc- disables it
ifeq ($(call opt,nopromisc),0)
	PROMISC := 1
endif

# BUS disconnect/reenumeration, must on for NDIS to avoid installation problem
ifeq ($(call opt,nodis),1)
	NODIS := 1
else
	ifeq ($(BCMUSBDEV_EP_FOR_RPCRETURN),1)
		EXTRA_DFLAGS += -DBCMUSBDEV_EP_FOR_RPCRETURN
	endif
endif

# NDIS, for full dongle model
ifeq ($(call opt,ndis),1)
	NDIS := 1
	ifeq ($(call opt,vista),1)
		VISTA := 1
	endif
	DHDOID := 1
	HOSTOIDS_DISABLED := 0
else
	HOSTOIDS_DISABLED := 1
endif

# NDIS OID offload feature
ifeq ($(call opt,dhdoid),1)
	DHDOID := 1
endif

# PNO
WLPFN_DISABLED := 1
ifeq ($(call opt,pno),1)
	PNO := 1
	ifeq ($(call opt,acn),1)
		ACN := 1
	endif
	WLPFN_DISABLED := 0
endif

ifeq ($(call opt,gci),1)
	HNDGCI := 1
endif

ifeq ($(PNO),1)
	WLPFN := 1
	WLPFN_AUTO_CONNECT := 0
endif
ifeq ($(ACN),1)
	WLPFN_AUTO_CONNECT := 1
endif

# MFP
ifeq ($(call opt,mfp),1)
	MFP := 1
	MFP_DISABLED := 0
	BCMCCMP := 1
else
	MFP_DISABLED := 1
endif

# DYN160
ifeq ($(call opt,dyn160),1)
	DYN160 := 1
	DYN160_DISABLED := 0
else
	DYN160_DISABLED := 1
endif

# SLAVE_RADAR
ifeq ($(call opt,slvradar),1)
	SLAVE_RADAR := 1
else
	SLAVE_RADAR := 0
endif

ifeq ($(call opt,stb),1)
	WLSTB := 1
else
	WLSTB := 0
endif

# BGDFS
ifeq ($(call opt,bgdfs),1)
	BGDFS := 1
	BGDFS_DISABLED := 0
	WL_MODESW := 1
	WL_MODESW_DISABLED := 0
else
	BGDFS_DISABLED := 1
endif

# ARP offload
ifeq ($(call opt,aoe),1)
	AOE := 1
	ARPOE_DISABLED := 0
else
	ARPOE_DISABLED := 1
endif

# Network Offload Engine
ifeq ($(call opt,noe),1)
	NWOE := 1
	NWOE_DISABLED := 0
else
	NWOE_DISABLED := 1
endif

# TCP checksum offload
ifeq ($(call opt,toe),1)
	TOE := 1
	TOE_DISABLED := 0
else
	TOE_DISABLED := 1
endif

# NAT keep-alive offload
ifeq ($(call opt,keepalive),1)
	KEEP_ALIVE := 1
endif

# Dongle packet filter engine
ifeq ($(call opt,pktfilter),1)
	PACKET_FILTER := 1
endif

# wowlpf specific flags
ifeq ($(call opt,wowlpf),1)
	WOWLPF := 1
endif

# secwowl specific flags
ifeq ($(call opt,secwowl),1)
	SECURE_WOWL := 1
endif

# sswowl specific flags
ifeq ($(call opt,sswowl),1)
	AOE := 1
	ARPOE_DISABLED := 0
	PACKET_FILTER := 1
	WOWLPF := 1
	SECURE_WOWL := 1
	SS_WOWL := 1
endif

# Sequence commands - used for "batching" IOCTLs
ifeq ($(call opt,seqcmds),1)
	SEQ_CMDS := 1
endif

# wlota test feature
ifeq ($(call opt,wlota),1)
	OTA_TEST := 1
endif

# Production Line Test module
ifeq ($(call opt,plt),1)
	PLT := 1
	MFGTEST := 1
endif

# Propagate TXSTATUS to host
ifeq ($(call opt,proptxstatus),1)
	PROP_TXSTATUS := 1
	EXTRA_DFLAGS += -DPROP_TXSTATUS_ENABLED
endif
ifeq ($(PROP_TXSTATUS),1)
	ifeq ($(call opt,dbgwlfc),1)
		EXTRA_DFLAGS += -DPROP_TXSTATUS_DEBUG
	endif
	ifeq ($(call opt,wlfcts),1)
		WLFCTS := 1
		WLFCTS_DISABLED := 0
	else
		WLFCTS_DISABLED := 1
	endif
endif

# Power Stats
WL_PWRSTATS_DISABLED := 1
ifeq ($(call opt,pwrstats),1)
     WL_PWRSTATS := 1
     WL_PWRSTATS_DISABLED := 0
endif

# Excess PMwake is dependent on pwrstats
ifeq ($(call opt,epm),1)
     WL_EXCESS_PMWAKE := 1
     WL_PWRSTATS := 1
     WL_PWRSTATS_DISABLED := 0
endif

#Ampdu Host Reorder
ifeq ($(call opt,ampduhostreorder),1)
   AMPDU_HOSTREORDER := 1
   AMPDU_HOSTREORDER_DISABLED := 0
else
   AMPDU_HOSTREORDER_DISABLED := 1
endif

# Include option to append bss_info_t to select events
ifeq ($(call opt,bssinfo),1)
	EVDATA_BSSINFO := 1
	EVDATA_BSSINFO_DISABLED := 0
else
	EVDATA_BSSINFO_DISABLED := 1
endif

#Firmware Debug
ifeq ($(call opt,errmsg),1)
	EXTRA_DFLAGS += -DBCMDBG_ERR
endif

#ifdef WLBTAMP
# BTAMP
ifeq ($(call opt,btamp),1)
	BTAMP := 1
endif
#endif

# P2P
ifeq ($(call opt,p2p),1)
	P2P := 1
	WLMCHAN := 1
	WLMULTIQUEUE := 1
	WLP2P_DISABLED := 0
else
	WLP2P_DISABLED := 1
endif

# P2PO
ifeq ($(call opt,p2po),1)
	P2P := 1
	P2PO := 1
	P2PO_DISABLED := 0
else
	P2PO_DISABLED := 1
endif

#RSDB
ifeq ($(call opt,rsdb),1)
	RSDB := 1
endif
ifneq ($(call opt,norsdb),1)
	WL_RSDB_DISABLED := 0
else
	WL_RSDB_DISABLED := 1
	EXTRA_DFLAGS	+= -DNUMD11CORES=1
endif

ifeq ($(call opt,80p80),1)
	EXTRA_DFLAGS    += -DRSDB_MODE_80P80
else
	EXTRA_DFLAGS    += -DRSDB_MODE_MIMO
endif

# ANQPO
ifeq ($(call opt,anqpo),1)
	ANQPO := 1
	ANQPO_DISABLED := 0
else
	ANQPO_DISABLED := 1
endif

# WLMCHAN
ifeq ($(call opt,mchan),1)
	P2P := 1
	WLMCHAN := 1
	WLMULTIQUEUE := 1
	WLMCHAN_DISABLED := 0
else
	WLMCHAN_DISABLED := 1
endif
# MCHAN_MINIDUMP
ifeq ($(call opt,mchandump),1)
	EXTRA_DFLAGS += -DMCHAN_MINIDUMP
endif

# MODESW_TIMECAL
ifeq ($(call opt,mswtime),1)
	EXTRA_DFLAGS += -DWL_MODESW_TIMECAL
endif

# NIC
ifeq ($(call opt,nic),1)
	NIC := 1
	WLMULTIQUEUE := 1
endif

# Vanilla AP
ifeq ($(call opt,ap),1)
	APONLY := 1
endif

# Vanilla APSTA
ifeq ($(call opt,apsta),1)
	BASIC_APSTA := 1
endif

# Receive Throttle Duty Cycle
ifeq ($(call opt,rtdc),1)
	RECEIVE_THROTTLE := 1
endif

# Asynchronous Timestamped Logs
ifeq ($(call opt,tslog),1)
	ASYNC_TSTAMPED_LOGS := 1
endif

# overlay support: downloaded code & data
ifeq ($(call opt,overlay),1)
	DONGLEOVERLAYS := 1
	EXTRA_DFLAGS += -DDONGLEOVERLAYS
#Force image to be nodisconect image if overlays are enabled in USB.
ifeq ($(call opt,usb),1)
	EXTRA_DFLAGS += -DBCMUSB_NODISCONNECT
endif
# temporary define for overlay sanity testing
# remove if real overlays are to be supported
	EXTRA_DFLAGS += -DDONGLEOVERLAYTEST
# overlay image can't have a crc at the end of it
	CRC32BIN := 0
endif

# Nintendo
ifeq ($(call opt,nintendo2),1)
	EXTRA_DFLAGS += -DWLNINTENDO2
	EXTRA_DFLAGS += -DWL_MULTIQUEUE
endif


# Media specific flags
ifeq ($(call opt,media),1)
	EXTRA_DFLAGS += -DWL_PHYACIARGS
endif

# Media specific flags
ifeq ($(call opt,ucd),1)
	UCDOWNLOAD := 1
endif

# DevRam with 1MB RAM
ifeq ($(call opt,remap),1)
	DEVRAM_REMAP            := 1
	MEMSIZE                 := 1048576

	# Must be <= 0x80000 since > 0x80000 is not DMA-able
	RELOC_TEXT_START        ?= 0x50000

	# Disable
	GENROMTBL		:= 0
endif

ifeq ($(call opt,srdebug),1)
	SR_DEBUG := 1
endif

ifeq ($(call opt,srfast),1)
	SRFAST := 1
endif

# NEIGHBOR ADVERTISEMENT offload
ifeq ($(call opt,ndoe),1)
	WLNDOE := 1
endif

# ATE build
ifeq ($(call opt,ate),1)
	ATE := 1
	EXTRA_DFLAGS    += -DWLPKTENG
	EXTRA_DFLAGS    += -DSAMPLE_COLLECT
	EXTRA_DFLAGS    += -DWLTEST
	EXTRA_DFLAGS    += -DBCMDBG_PHYDUMP
	EXTRA_DFLAGS    += -DBCMNVRAMW
	EXTRA_DFLAGS    += -DBCMNVRAMR
else
	ATE := 0
endif

# WLWFDS
ifeq ($(call opt,wfds),1)
        WLWFDS := 1
	WLWFDS_DISABLED := 0
else
	WLWFDS_DISABLED	:= 1
endif

# 11U
ifeq ($(call opt,wl11u),1)
	WL11U := 1
	WL11U_DISABLED := 0
else
	WL11U_DISABLED := 1
endif

# TXBF
ifeq ($(call opt,txbf),1)
        WLTXBF := 1
        WLTXBF_DISABLED := 0
else
        WLTXBF_DISABLED := 1
endif

# LMTPC (LPC) Trigger via command line
ifeq ($(call opt,lpc),1)
	LPC := 1
endif

ifeq ($(call opt,lpcdebug),1)
	LPC_DEBUG := 1
endif

ifeq ($(call opt,sarctrl),1)
	EXTRA_DFLAGS += -DWL_SAR_SIMPLE_CONTROL
endif

# Reliable multicast
ifeq ($(call opt,relmcast),1)
	WL_RELMCAST := 1
	WL_RELMCAST_DISABLED := 0
else
	WL_RELMCAST_DISABLED := 1
endif

# Dictionary interface
ifeq ($(call opt,objreg),1)
	WL_OBJ_REGISTRY := 1
endif


# ROM auto abandon feature.
ifeq ($(call opt,autoabn),1)
	BCM_ROM_AUTO_ABANDON := 1
endif

# PSPRETEND
ifeq ($(call opt,pspretend),1)
	PSPRETEND := 1
endif

# BWTE
ifeq ($(call opt,bwte),1)
        WL_BWTE := 1
	WL_BWTE_DISABLED := 0
else
	WL_BWTE_DISABLED := 1
endif

# TBOW
ifeq ($(call opt,tbow),1)
        WL_TBOW := 1
        WL_TBOW_DISABLED := 0
        WL_BWTE := 1
        WL_BWTE_DISABLED := 0
else
        WL_TBOW_DISABLED := 1
endif

# Voice Enterprise: adds FBT (11r), RRM (11k), and WNM (11v).
ifeq ($(call opt,ve),1)
	WLFBT := 1
	WLFBT_DISABLED := 0
	WL11K := 1
	WL11K_DISABLED := 0
	WLWNM := 1
	WLWNM_DISABLED := 0
#SCANCACHE is required for 802.11K table mode beacon report
	WLSCANCACHE := 1
	WLSCANCACHE_DISABLED := 0
	WLCAC := 1
	CAC_DISABLED := 0
endif

# XXX this is a temporary build option which is going to be got rid of
# once this additional feature is proven to be stable
# It is to minimize impact to existing firmware during transition period.
# Eventualy this feature is going to be compiled in default for the dongle build.
ifeq ($(call opt,pktctx),1)
	PKTC_TX_DONGLE := 1
	WLAMSDU_TX := 1
	WLAMSDU_TX_DISABLED := 0
else
	WLAMSDU_TX_DISABLED := 1
endif

# Proximity detection.
ifeq ($(call opt,proxd),1)
	WL_PROXDETECT := 1
	WL_PROXDETECT_DISABLED := 0
else
	WL_PROXDETECT_DISABLED := 1
endif

# BCM NAN implementation
ifeq ($(call opt,nan),1)
	WL_NAN := 1
	WL_NAN_DISABLED := 0
# nan requires scancache
	WLSCANCACHE := 1
	WLSCANCACHE_DISABLED := 0
else
	WL_NAN_DISABLED := 1
endif

# RSSI refinement
ifeq ($(call opt,rssirf),1)
	WL_RSSIREFINE := 1
	WL_PROXDETECT := 1
	WL_PROXDETECT_DISABLED := 0
endif

# Event logging
ifeq ($(call opt,eventlog),1)
	BCM_EVENT_LOG := 1
endif

ifeq ($(call opt,logtrace),1)
	BCM_LOGTRACE := 1
endif

# AMPDU retry
ifeq ($(call opt,ampduretry),1)
	WL_EXPORT_AMPDU_RETRY := 1
endif

ifeq ($(call opt,awdl),1)
	WLAWDL := 1
	VDEV := 2
	WLAWDL_DISABLED := 0
else
	WLAWDL_DISABLED := 1
endif

ifeq ($(call opt,sysmon),1)
	SYSMON := 1
endif

# CCA_STATS
ifeq ($(call opt,cca),1)
	CCA_STATS := 1
endif

# Stack frame overflow protection
ifeq ($(call opt,stack_prot),1)
	STACK_PROT := 1
endif

ifeq ($(call opt,frwdreorder),1)
	WL_FRWD_REORDER := 1
	WL_FRWD_REORDER_DISABLED := 0
else
	WL_FRWD_REORDER_DISABLED := 1
endif

ifeq ($(call opt,ipfo),1)
	WLIPFO := 1
	WLIPFO_DISABLED := 0
	WL_FRWD_REORDER := 1
	WL_FRWD_REORDER_DISABLED := 0
else
	WLIPFO_DISABLED := 1
endif

ifeq ($(call opt,ulb),1)
	WL11ULB := 1
	WL11ULB_DISABLED := 0
else
	WL11ULB_DISABLED := 1
endif

ifeq ($(call opt,taf),1)
	WLTAF := 1
	WLTAF_DISABLED := 0
else
	WLTAF_DISABLED := 1
endif

ifeq ($(call opt,aibss),1)
	WLAIBSS := 1
	WLAIBSS_DISABLED := 0
	WLIPFO := 1
	WLIPFO_DISABLED := 0
	WL_FRWD_REORDER := 1
	WL_FRWD_REORDER_DISABLED := 0
	AP := 1
	WLMULTIQUEUE := 1
else
	WLAIBSS_DISABLED := 1
endif

ifeq ($(call opt,rxdesens),1)
        EXTRA_DFLAGS += -DRXDESENS_EN
endif

# lfrag $ lfrag pool
ifeq ($(call opt,pcie),1)
# enable BCMFRAGPOOL  BCMLFRAG BCMSPLITRX in rom while roming for next pcie chip
	BCMFRAGPOOL := 1
	BCMLFRAG := 1
	BCMSPLITRX := 1
	BCMSPLITRX_DISABLED := 0

	BCMLFRAG_DISABLED := 0
	BCMFRAGPOOL_DISABLED := 0

	EXTRA_DFLAGS += -DWLFC_CONTROL_TO_HOST_DISABLED
else
	BCMLFRAG_DISABLED := 1
	BCMFRAGPOOL_DISABLED := 1
	BCMSPLITRX_DISABLED := 1

	WLFC_CONTROL_TO_HOST_DISABLED := 0
	EXTRA_DFLAGS += -DWLFC_INFO_TO_BUS_DISABLED
endif

#Below check is commented out as splitrx is default for pcie builds
#ifeq ($(call opt,splitrx),1)
#	BCMSPLITRX := 1
#	BCMSPLITRX_DISABLED := 0
#else
#	BCMSPLITRX_DISABLED := 1
#endif

ifeq ($(call opt,pcierev1),1)
	#for rev1 API no split buf support
	BCM_SPLITBUF := 0
	BCM_SPLITBUF_DISABLED := 1
	EXTRA_DFLAGS    += -DPCIE_API_REV1
else
	ifeq ($(call opt,splitbuf),1)
		BCM_SPLITBUF := 1
		BCM_SPLITBUF_DISABLED := 0
	else
		BCM_SPLITBUF_DISABLED := 1
	endif
endif

ifeq ($(call opt,splitassoc),1)
	WL_SPLIT_ASSOC := 1
endif

ifeq ($(call opt,dbgam),1)
	DBG_AMPDU := 1
endif

ifeq ($(call opt,dbgams),1)
	DBG_AMSDU := 1
endif

ifeq ($(call opt,phybu),1)
	DBG_PHYBU := 1
endif

ifeq ($(call opt,dbgmu),1)
	DBG_MU := 1
endif

ifeq ($(call opt,roamprof),1)
	WLROAMPROF := 1
endif

ifeq ($(call opt,ltecx),1)
	BCMLTECOEX := 1
	BCMLTECOEX_DISABLED := 0
else
	BCMLTECOEX_DISABLED := 1
endif

# Enable large buffer for pcie specific targets
ifeq ($(call opt,pcie),1)
ifeq ($(call opt,mfgtest),1)
	IOCTL_RESP_LARGE := 1
endif
ifeq ($(call opt,dump),1)
	IOCTL_RESP_LARGE := 1
endif
ifeq ($(call opt,phydump),1)
	IOCTL_RESP_LARGE := 1
endif
ifeq ($(call opt,dbgam),1)
	IOCTL_RESP_LARGE := 1
endif
ifeq ($(call opt,dbgams),1)
	IOCTL_RESP_LARGE := 1
endif
ifeq ($(call opt,phybu),1)
	IOCTL_RESP_LARGE := 1
endif
endif # pcie

# CLM no incremental option
ifeq ($(call opt,noclminc),1)
	WLCLMINC := 0
endif

# CLM incremental option
ifeq ($(call opt,clminc),1)
	WLCLMINC := 1
endif

# CLM_TYPE option (simple file name after a "clm_" prefix)
target_options = $(subst -, ,$(TARGET_OPTIONS))
clm_option = $(filter clm_%,$(target_options))
ifneq ($(clm_option),)
	CLM_TYPE := $(patsubst clm_%,%,$(clm_option))
endif

ifeq ($(call opt,pwropt),1)
   WLSCAN_PS := 1
   WLSCAN_PS_DISABLED := 0
else
   WLSCAN_PS_DISABLED := 1
endif

# Secure WiFi through NFC
ifeq ($(call opt,nfc),1)
	WLNFC          := 1
	WLNFC_DISABLED := 0
	BCM_NFCIF      := 1
else
	WLNFC_DISABLED := 1
endif

ifeq ($(call opt,bssloadrep),1)
	WLBSSLOAD_REPORT := 1
	WLBSSLOAD_REPORT_DISABLED := 0
else
	WLBSSLOAD_REPORT_DISABLED := 1
endif

# hotspot STA
ifeq ($(call opt,hs20sta),1)
	WIFI_ACT_FRAME := 1
	MFP := 1
	MFP_DISABLED := 0
	WLWNM := 1
	WLWNM_DISABLED := 0
	WL11U := 1
	WL11U_DISABLED := 0
	WLOSEN := 1
	WLOSEN_DISABLED := 0
else
	WLOSEN_DISABLED := 1
endif

# hotspot AP-OSEN
ifeq ($(call opt,osen),1)
	WLOSEN := 1
	WLOSEN_DISABLED := 0
else
	WLOSEN_DISABLED := 1
endif

# 11n proprietary rates support
ifeq ($(call opt,11nprop),1)
	PROPRIETARY_11N_RATES := 1
	PROPRIETARY_11N_RATES_DISABLED := 0
else
	PROPRIETARY_11N_RATES_DISABLED := 1
endif

# TX ePA DPD
ifeq ($(call opt,epapd),1)
	PHY_EPAPD := 1
endif

ifeq ($(call opt,obss),1)
	WL_PROT_OBSS := 1
	WL_PROT_OBSS_DISABLED := 0
else
	WL_PROT_OBSS_DISABLED := 1
endif

ifeq ($(call opt,macdbg),1)
	MACDBG := 1
endif

ifeq ($(call opt,dbwsw),1)
	WL_OBSS_DYNBW := 1
	WL_OBSS_DYNBW_DISABLED := 0
	WL_MODESW := 1
	WL_MODESW_DISABLED := 0
else
	WL_OBSS_DYNBW_DISABLED := 1
endif

ifeq ($(call opt,bcntrim),1)
	WL_BCNTRIM := 1
	WL_BCNTRIM_DISABLED := 0
else
	WL_BCNTRIM_DISABLED := 1
endif

# Audit the DHD packet Id, when DHD uses PKTID as request ids in workitems.
ifeq ($(call opt,pktidaudit),1)
	BCMPKTIDAUDIT := 1
endif

# Check the sanity of h2d messages using a modulo 253 sequence number
ifeq ($(call opt,h2dseqnum),1)
	BCMH2DCHECKSEQNUM := 1
endif

### One of the following mechanisms must be supported to ensure that D2H DMA
# indeed completes to Host system memory, before posting an interrupt.
#
# 1. BCMCHKD2HDMA places a modulo-253 sequence number marker on every D2H msg
ifeq ($(call opt,chkd2hdma),1)
	BCMCHKD2HDMA := 1
endif
#
# 2. BCMXORCSUM places an xor checksum on every D2H msg
ifeq ($(call opt,xorcsum),1)
	BCMXORCSUM := 1
endif
#
# 3. DMA read barrier
#   BCMM2MREADBARRIER enables a read barrier access to host to force the flush
#   of pending D2H RX DMAs before updating the WR index for Msgs posted to host.
ifeq ($(call opt,dma_rbarrier),1)
	BCMM2MREADBARRIER := 1
endif
#
# 4. Dongle DMA's the D2H RD/WR indices using M2M DMA
#
###

### Support DONGLE DMAing of WR/RD H2D and D2H Indices, using 16bit or 32bit
ifeq ($(call opt,dmaindex16),1)
	BCMDMAINDEX16 := 1
endif
ifeq ($(call opt,dmaindex32),1)
	BCMDMAINDEX32 := 1
endif

# BCMHOSTRINGER enables a soft doorbell, wherein dongle will write a value into
# a host address to wakeup a thread for D2H PCIE FD rings
ifeq ($(call opt,ringer),1)
	BCMHOSTRINGER := 1
endif

# BCM_DHDHDR 
# Advertize to DHD to support SubFrame Header insertion, and,
# Request DHD to allocate storage for TxHeader buffer to be offloaded to host.
#
ifeq ($(call opt,dhdhdr),1)
	EXTRA_DFLAGS += -DBCM_DHDHDR
	EXTRA_DFLAGS += -DD3_BUFFER_LEN=$(FRAG_D3_BUFFER_LEN)
	EXTRA_DFLAGS += -DD11_BUFFER_LEN=$(FRAG_D11_BUFFER_LEN)
endif

# Use the minimum set of ucode regs to dump
ifeq ($(call opt,minmaclist),1)
	EXTRA_DFLAGS += -DWLC_MINMACLIST
endif

# enable ucode regs dump by DHD
ifeq ($(call opt,hostpmac),1)
	EXTRA_DFLAGS += -DWLC_HOSTPMAC
endif

# MURX
ifeq ($(call opt,murx),1)
	WL_MU_RX := 1
endif

# HOST_MEM_UCODE
ifeq ($(call opt,pcie),1)
ifeq ($(call opt,hostmemucode),1)
	EXTRA_DFLAGS += -DBCM_HOST_MEM
	EXTRA_DFLAGS += -DBCM_HOST_MEM_UCODE
endif
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++ dongle config/mk options  +++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# include dongle configuration
include $(TOPDIR)/../Makeconf

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++ wlconfig/wltunable options  ++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# wlconfig (target -> bus proto -> default)
ifneq ($($(TARGET)-wlconfig),)
	WLCONFFILE := $($(TARGET)-wlconfig)
endif
ifneq ($($(HBUS_PROTO)-wlconfig),)
	WLCONFFILE := $($(HBUS_PROTO)-wlconfig)
endif

WLCFGDIR := $(SRCBASE)/wl/config

# Include config file; disallow white space except in full-line comments.
# This is because with line like "VAR=1 ", ifeq ($(VAR),1) evaluates to false.
ifdef WLCONFFILE
$(if $(wildcard $(WLCFGDIR)/$(WLCONFFILE)),\
,\
$(error $(WLCFGDIR)/$(WLCONFFILE) does not exist))
ifneq ($(shell egrep '^[^\#].*=.*[[:space:]]' $(WLCFGDIR)/$(WLCONFFILE)),)
$(error Configuration file $(WLCONFFILE) contains white space or comment at end of line)
endif
include $(WLCFGDIR)/$(WLCONFFILE)
endif

include $(WLCFGDIR)/wl.mk

ifeq ($(WLFILES),)
$(error WLFILES is undefined)
endif

WLAN_ComponentsInUse := bcmwifi clm ppr keymgmt iocv dump phymods dongle rte
#WLAN_ComponentsInUse += olpc lwip
ifeq ($(CCX),1)
# XXX -seqcmds- requires wl_oid.h, why?
WLAN_ComponentsInUse += ndis
endif
ifeq ($(ATE),1)
WLAN_ComponentsInUse += ate
endif
ifeq ($(P2PO),1)
WLAN_ComponentsInUse += gas encode
endif
ifeq ($(WL_RELMCAST),1)
WLAN_ComponentsInUse += rel_mcast
endif
ifeq ($(WL_PROXDETECT),1)
WLAN_ComponentsInUse += proxd
endif
ifeq ($(WL_NAN),1)
WLAN_ComponentsInUse += nan
endif
ifeq ($(CONFIG_DHDAP),y)
    WLAN_TreeBaseA := $(abspath $(TOPDIR)/../../../..)
endif
include $(TOPDIR)/../../../makefiles/WLAN_Common.mk

vpath %.c $(WLAN_StdSrcDirsR) $(WLAN_ComponentSrcDirsR)
ifeq ($(THREADX),1)
vpath %.c $(SRCBASE)/dongle/threadx/wl
endif
ifeq ($(HNDRTE),1)
vpath %.c $(SRCBASE)/dongle/hndrte/wl
endif

EXTRA_IFLAGS	+= $(WLAN_ComponentIncPathR) $(WLAN_IncPathR)

EXTRA_DFLAGS	+= $(WLFLAGS)

# OBJECTS variable lists all object files we need for the target
OBJECTS		+= $(WLFILES:.c=.o)

# wltunable (target -> band -> default)
ifneq ($($(TARGET)-wltunable),)
	WLTUNEFILE := $($(TARGET)-wltunable)
endif
ifneq ($($(BAND)-wltunable),)
	WLTUNEFILE := $($(BAND)-wltunable)
endif

# check the existance of tunable file
ifdef WLTUNEFILE
ifeq ($(wildcard $(WLCFGDIR)/$(WLTUNEFILE)),)
$(error Tunable file $(WLTUNEFILE) does not exist)
endif
endif

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++ final build targets +++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# DLARRAY_SUFFIX = $(CHIP)_$(if $(REVID),$(REVID),all)
DLARRAY_SUFFIX := _$(firstword $(subst -, ,$(CBRAND)))

# IMAGES variable lists all binary files we need for the target
# Some of these image builds can be skipped by particular chip/brands
# by including image name in SKIP_IMAGES variable
EXE		:= $(PROJECT).exe
BIN		:= $(PROJECT).bin
MAP		:= $(PROJECT).map
DIS		:= $(PROJECT).dis
TRX		:= $(PROJECT).trx
LOGSTRS		:= logstrs
UPG		:= $(PROJECT).upg
NOE		:= $(PROJECT).noe
EMBED_SUFFIX	:= $(PROJECT)$(DLARRAY_SUFFIX).h
EMBED		:= $(PROJECT).h
NVM_TRX		:= $(PROJECT).nvm.trx
ROM_TRX		:= $(PROJECT).romlsim.trx
BIN_TRX		:= $(PROJECT).bin.trx
OVL_TRX		:= $(PROJECT).ovl.trx
BINQT		:= $(PROJECT).qt
OPT		:= $(PROJECT).opt
SZ		:= $(PROJECT).sz
NOPT_OPT	:= $(PROJECT).nopt_opt
MAP_SIZE	:= $(PROJECT).map-size

# always build these images
IMAGES += $(OPT) $(EXE) $(MAP) $(DIS) $(SZ) $(BIN_TRX) $(LOGSTRS).bin $(MAP_SIZE)

# Write unoptimized compiler options to file
ifeq ($(BCM_ROM_AUTO_ABANDON),1)
	IMAGES += $(NOPT_OPT)
endif

# Binary/Embedded image
# xxx fixme: both usb and sdio can be enabled
ifeq ($(HBUS_ENAB),usb)
	ifeq ($(filter $(TRX),$(SKIP_IMAGES)),)
		BINDL	?= $(TRX)
	else
		BINDL	?= $(BIN_TRX)
	endif
	NVM_FILE := $(wildcard $(TOPDIR)/nvm.txt)
	ifneq ($(findstring nvm.txt,$(NVM_FILE)),)
		IMAGES	+= $(NVM_TRX)
	endif
endif
ifeq ($(HBUS_ENAB),sdio)
	BINDL	?= $(BIN)
endif

ifeq ($(HBUS_ENAB),pcie)
	BINDL	?= $(BIN)
endif

ifeq ($(HBUS_ENAB),m2m)
	BINDL	?= $(BIN)
endif

ifneq ($(BINDL),)
IMAGES	+= $(BINDL)
# XXX should not always include EMBED but some release scripts use its
# XXX existance as the way to check if the build is done or not...
IMAGES += $(EMBED)
endif

# create a embed suffix file
ifeq ($(SUFFIX_ENAB),1)
	IMAGES  += $(EMBED_SUFFIX)
endif

# create upgrade images for retail & flash upgrade builds
ifeq ($(UPGRADE),1)
	IMAGES 	+= $(UPG) $(NOE)
endif

#if romlsim is defined add the ROM_TRX to the image list
ifeq ($(ROMLSIM),1)
	IMAGES 	+= $(ROM_TRX)
endif

# build standalone nvram files if a particular build specifies it
ifneq ($(NVM_IMGS),)
	IMAGES += $(NVM_IMGS)
endif

# create a dongle image supporting code overlays
ifeq ($(DONGLEOVERLAYS),1)
	IMAGES 	+= $(OVL_TRX)
	EXTERN_OBJECTS += overlaytags.o
endif

# create uncompressed TRX image
ifeq ($(UCDOWNLOAD),1)
	IMAGES  += $(BIN_TRX)
endif

# CLM_BLOBS can be defined to create CLM download files, i.e. "CLM BLOBS".  CLM_BLOBS
# is a list of .clm files from the src/wl/clm/types directory, without the .clm suffix.
# The resulting CLM blob files will have a .clm_bin suffix.
CLM_BLOB_IMAGES := $(CLM_BLOBS:=.clm_bin)

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++ rules ++++++++++++++++++++++++++++++++++++++++++
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

# include common rules after all configuration is setup
include $(TOPDIR)/../Makerules

BLDTGTNAME := $(SUBBLDDIR)/$(CBRAND)$(if $(TARGET),/$(TARGET))

# build these targets when no make target or 'all' make target is given
.PHONY: all
# Do not build CLM blobs if private xml is missing (full/partial source releases)
ifneq ($(wildcard $(SRCBASE)/wl/clm/private/wlc_clm_data*.xml),)
all: $(CLM_BLOB_IMAGES) $(IMAGES)
else
all: $(IMAGES)
endif

SZ_OPTS := --bin $(BIN) --image $(EXE) --size-prog $(SIZE) --mapfile $(MAP)	\
	--memsize $(MEMSIZE) --textstart $(TEXT_START)				\
	--heapmin 20480 --stack 8192						\
	--sizing-info-yaml sizing_info.yaml					\
	--romtbl-sizing-yaml romtbl.sizing_info.yaml

ifdef MAXSIZE
SZ_OPTS += --maxsize $(MAXSIZE) --nomaxsize $(NOMAXSIZE)		\
	--target "$(BLDTGTNAME)" --bin $(BIN)
ifdef WARNLIMIT
SZ_OPTS += --warnlimit $(WARNLIMIT)
endif # WARNLIMIT
endif # MAXSIZE

# send image size to stdout and build image size file
# Size check (gmake NOMAXSIZE=1 to skip (i.e. report error and continue))
$(SZ): BLDTGTNAME = $(SUBBLDDIR)/$(CBRAND)$(if $(TARGET),/$(TARGET))
$(SZ): $(EXE) $(BIN) $(MAP) FORCE
	/usr/bin/python $(IMGSIZESCRIPT) --sizing-out $@ $(SZ_OPTS)

#
# special make targets/rules
#

# convert to C array for embedding in the host driver
ifneq ($(BINDL),)
$(EMBED) $(EMBED_SUFFIX): $(BINDL)
	@( \
	TMPFILE="tmp_$@"; \
	rm -rf $$TMPFILE && \
	IMAGEVER="$(if $(RELNUM),$(RELNUM),$(strip $(shell date '+%Y.%m.%d.%H%M%S')))" && \
	IMAGEDATE="$(strip $(shell date '+%Y/%m/%d %H:%M:%S'))" && \
	SUFFIX="$(if $(findstring $(DLARRAY_SUFFIX),$(basename $@)),$(DLARRAY_SUFFIX))" && \
	ACTIVECONS="$(word 1,$(shell grep -s -i active_cons $(MAP)))" && \
	DEBUGPARAMS="$(word 1,$(shell grep -s -i debug_params $(MAP)))" && \
	{ \
	echo '/* Makefile converted dongle image $< */'; \
	echo ''; \
	echo "char dlimagename$$SUFFIX[] = \"$(if $(CBRAND),$(CBRAND))$(if $(TARGET),/$(TARGET))\";"; \
	echo "char dlimagever$$SUFFIX[]  = \"$$IMAGEVER\";"; \
	echo "char dlimagedate$$SUFFIX[] = \"$$IMAGEDATE\";"; \
	echo "char dlimagetag$$SUFFIX[] = \"\";"; \
	echo ''; \
	if [ -n "$$ACTIVECONS" ]; then \
	echo "unsigned int active_cons$$SUFFIX = 0x$$ACTIVECONS;"; \
	else \
	echo "unsigned int active_cons$$SUFFIX = 0x0;"; \
	fi; \
	if [ -n "$$DEBUGPARAMS" ]; then \
	echo "unsigned int debug_params$$SUFFIX = 0x$$DEBUGPARAMS;"; \
	else \
	echo "unsigned int debug_params$$SUFFIX = 0x0;"; \
	fi; \
	echo ''; \
	} > $@ && \
	echo "bin2c $< $$TMPFILE dlarray$$SUFFIX" && \
	bin2c $< $$TMPFILE dlarray$$SUFFIX && \
	echo "cat $$TMPFILE >> $@" && \
	cat $$TMPFILE >> $@ && \
	rm $$TMPFILE \
	)
#	# $(EMBED) are needed in dhd->firmware build/release process
#	@if [ "$@" != "$(EMBED)" ]; then cp -pv $@ $(EMBED); fi
ifneq ($(filter $(SKIP_IMAGES),$<),)
#	# Removing $(SKIP_IMAGES) for brand $(CBRAND)
	-@rm -fv $(filter $(SKIP_IMAGES),$<)
endif
endif	# BINDL

# check toolchain path
.PHONY: tcchk
tcchk:
	echo "ToolChain Checking TOOLSDIR=$(TOOLSDIR)"
	@if [ -d $(TOOLSDIR) ]; then \
		touch .tcchked; \
	fi

# XXX move to the make file that needs this...
%.upg:	%.bin
	nvserial -i $< -o upgrade.bin -s 57005 $(SRCBASE)/shared/nvram/bcm94320r.txt
	trx -f noheader -o $@ upgrade.bin
	rm upgrade.bin

# build trx with nvram
$(NVM_TRX): $(NVM_FILE)
%.nvm.trx: %.bin.gz
	( \
	TMPFILE="tmp_$@"; \
	rm -rf $$TMPFILE && \
	nvserial -a -s 4660 -o $@ $(NVM_FILE) && \
	cat $< $@ >> $$TMPFILE && \
	NVMSIZE="`stat -c %s $@`" && \
	trx $(TRX_OPTIONS) -x $$NVMSIZE -o $@ $$TMPFILE && \
	rm $$TMPFILE \
	)

# serialize nvram template
%.nvm: $(SRCBASE)/shared/nvram/%.txt
	nvserial -a -s 57005 -o $@ $<

endif	# ifneq ($(INTARGETDIR),)
endif	# ifneq ($(INBRANDDIR),)

.PHONY: FORCE
FORCE:

# Tell emacs to use Makefile mode since it does not know from the filename:
#       Local Variables:
#       mode: makefile
#       End:
