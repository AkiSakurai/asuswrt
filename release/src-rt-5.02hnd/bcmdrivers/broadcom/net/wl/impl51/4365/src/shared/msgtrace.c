/*
 * Trace messages sent over HBUS
 *
 * Broadcom Proprietary and Confidential. Copyright (C) 2017,
 * All Rights Reserved.
 * 
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom;
 * the contents of this file may not be disclosed to third parties, copied
 * or duplicated in any form, in whole or in part, without the prior
 * written permission of Broadcom.
 *
 * $Id: msgtrace.c 481727 2014-05-30 09:59:18Z $
 */

#include <typedefs.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmendian.h>
#include <msgtrace.h>
#include <bcmsdpcm.h>
#include <bcmpcie.h>
#include <rte_timer.h>


/* LOG_BUf_LEN must be a power of 2 */
#define LOG_BUF_LEN (2 * 1024)
#define LOG_BUF_MASK (LOG_BUF_LEN-1)

/* Retry timeout value to handle the retry of lost message */
#define RETRY_TIMEOUT_VALUE	100

/* Send timeout value to trigger immmediately the sending by leaving the context of caller */
#define SEND_TIMEOUT_VALUE	0

#define MSG_MAX_SIZE  (1500 - MSGTRACE_HDRLEN)


/* Definition of trace buffer for sending trace over host bus */
typedef struct msgtrace {
	void	*hdl1;			/* hdl1 : handler used to send trace event */
	void	*hdl2;			/* hdl2 : handler used to send trace event */
	uint8	log_buf[LOG_BUF_LEN];  	/* trace buffer     */
	uint16	write_idx;   		/* Write index to the trace buffer */
	uint16	read_idx;     		/* Read index to the trace buffer  */
	uint16	read_get_idx; 		/* Read index to the trace buffer at retrieve time  */
	uint32 	discarded_bytes;    	/* Number of discarded bytes when trace buffer is full */
	uint32 	discarded_bytes_saved; 	/* Save of discarded_bytes when sending trace event */
	uint32 	discarded_printf;    	/* Number of discarded printf when trace buffer is full */
	uint32	discarded_printf_saved;	/* Save of discarded_printf when sending trace event */
	uint32	seqnum;			/* Sequence number of event sent */
	hnd_timer_t *timer;		/* Timer used to trigger the sending  of trace buffer and
					 * used to handle the retry of lost event
					 */
	bool	sending;		/* Indicate that the sending is in progress */
	bool	pending;		/* A msg has been sent but not ackd */
	bool	filter_hbus;		/* Filter the hbus trace generated from the sending of
					 *  traces messages to its release
					 */
	bool	filter_cb;		/* Filter the trace generated by the execution callback of
					 *  sending
					 */
	msgtrace_func_send_t func_send; /* Function pointer to send trace event */
	bool event_trace_enabled;   /* EVENT_TRACE enabled/disabled flag */
	uint16 retry_count;
} msgtrace_t;


msgtrace_t msgtrace = {
	NULL,	/* hdl1 */
	NULL,	/* hdl2 */
	"",	/* log_buf */
	0,	/* write_idx */
	0,	/* read_idx */
	0,	/* read_get_idx */
	0,	/* discarded_bytes */
	0,	/* discarded_bytes_saved */
	0,	/* discarded_printf */
	0,	/* discarded_printf_saved */
	0,	/* seqnum */
	NULL,	/* timer */
	FALSE,	/* sending */
	FALSE,	/* pending */
	FALSE,	/* filter_hbus */
	FALSE,	/* filter_cb */
	NULL	/* func_send */
};

bool
msgtrace_event_enabled(void)
{
	return msgtrace.event_trace_enabled;
}

/* Flags used to avoid endless trace from hbus device code */
bool msgtrace_hbus_trace = FALSE;

void
msgtrace_stop(void)
{
	if (msgtrace.event_trace_enabled) {
		/* Stop the timer since EVENT tracing is disabled */
		hnd_timer_stop(msgtrace.timer);
		msgtrace.event_trace_enabled = FALSE;
	}
}

void
msgtrace_start(void)
{
	if (!msgtrace.event_trace_enabled) {
		/* Start the timer since EVENT tracing is enabled */
		hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
		msgtrace.event_trace_enabled = TRUE;
	}
}

/* Called when the trace has been sent over the HBUS. After this call, the HBUS device code
 *  shall not generated traces related the sent messsage, otherwise, there are endless traces.
 *  Retrieve len and update the read index of trace buffer
 *  The pointer must be aligned on 32 bits
 */
int
msgtrace_sent(void)
{
	msgtrace.read_idx = msgtrace.read_get_idx;

	if (msgtrace.event_trace_enabled) {
		/* Stop the timer started with RETRY_TIMEOUT_VALUE for handling retry */
		hnd_timer_stop(msgtrace.timer);
	}

	if (msgtrace.pending == FALSE) {
		/* Not sending anything - just return */
		return 0;
	}

	msgtrace.pending = FALSE;

	if ((msgtrace.read_idx != msgtrace.write_idx) && msgtrace.event_trace_enabled) {
		/* Traces has been added during the sending. Send again */
		hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
	}
	else {
		msgtrace.sending      = FALSE;
		msgtrace.filter_hbus  = FALSE;
	}

	/* Substract msgtrace.discarded_bytes_saved since the message has been sent
	 * with or without retry
	 */
	msgtrace.discarded_bytes   -= msgtrace.discarded_bytes_saved;
	msgtrace.discarded_printf  -= msgtrace.discarded_printf_saved;

	return 1;
}

/* Extract the trace from the buffer
 * Return two buffers address to handle the wrap
 */
static uint16
msgtrace_get(uint8 **trace)
{
	uint32 len;

	*trace = &msgtrace.log_buf[msgtrace.read_get_idx];

	if (msgtrace.read_get_idx <= msgtrace.write_idx)
		len = msgtrace.write_idx - msgtrace.read_get_idx;
	else if (msgtrace.read_get_idx > msgtrace.write_idx)
	    /* Only return up to the end of buffer to provide contiguous
	     * memory. Another call is required to retrieve the rest
	     */
		len = LOG_BUF_LEN - msgtrace.read_get_idx;

	/* Retrieved traces must not be greater than the message max size */
	if (len > MSG_MAX_SIZE)
		len = MSG_MAX_SIZE;

	msgtrace.read_get_idx = (msgtrace.read_get_idx + len) & LOG_BUF_MASK;

	return len;
}

static void
msgtrace_timeout(hnd_timer_t *t)
{
	msgtrace_hdr_t hdr;
	uint8 *trace;
	uint16 len;

	if (t->interval == RETRY_TIMEOUT_VALUE) {
		if (msgtrace.retry_count++ > 1) {
			msgtrace.read_idx = msgtrace.read_get_idx;
			msgtrace.retry_count = 0;
			return;
		}
		/* Restore read_get_idx to resend lost traces */
		msgtrace.read_get_idx = msgtrace.read_idx;
	} else {
		/* First send of the event. Save discarded_bytes / discarded_printf */
		msgtrace.discarded_bytes_saved  = msgtrace.discarded_bytes;
		msgtrace.discarded_printf_saved = msgtrace.discarded_printf;
		msgtrace.seqnum++;
		msgtrace.retry_count = 0;
	}

	if ((len = msgtrace_get(&trace)) > 0) {
		/* Fill the trace header */
		hdr.version	     = MSGTRACE_VERSION;
		hdr.trace_type	     = MSGTRACE_HDR_TYPE_MSG;
		hdr.len              = hton16(len);
		hdr.discarded_bytes  = hton32(msgtrace.discarded_bytes_saved);
		hdr.discarded_printf = hton32(msgtrace.discarded_printf_saved);
		hdr.seqnum           = hton32(msgtrace.seqnum);

		/* Filter the HBUS device traces */
		msgtrace.filter_hbus  = TRUE;
		/* Filter the traces generated by function_send callback */
		msgtrace.filter_cb    = TRUE;

		msgtrace.pending = TRUE;
		msgtrace.func_send(msgtrace.hdl1, msgtrace.hdl2,
		                   (uint8*)&hdr, sizeof(msgtrace_hdr_t),
		                   trace, len);

		msgtrace.filter_cb    = FALSE;

		if (msgtrace.event_trace_enabled) {
			/* Restart timer if the message is lost due to lack of resources */
			hnd_timer_start(msgtrace.timer, RETRY_TIMEOUT_VALUE, FALSE);
		}
	}
}

void
msgtrace_put(char *buf, int count)
{
	uint16 freebytes;
	bool hbus_trace = msgtrace_hbus_trace;

	msgtrace_hbus_trace = FALSE;

	/* Filter the HBUS device traces generating during the sending of HBUS messages */
	if (msgtrace.filter_cb || (msgtrace.filter_hbus && hbus_trace)) {
		msgtrace.discarded_bytes += count;
		msgtrace.discarded_printf++;
		return;
	}

	freebytes = (msgtrace.read_idx == msgtrace.write_idx)
			? LOG_BUF_LEN
			: (msgtrace.read_idx - msgtrace.write_idx) & LOG_BUF_MASK;

	if (freebytes > 1) {
		/* Let 1 byte in the trace buffer so that the condition (read_idx == write_idx) is
		 *  only tied to empty buffer (not to full buffer)
		 */
		if (count > (freebytes-1)) {
			msgtrace.discarded_bytes += count - freebytes + 1;
			count = freebytes - 1;
		}

		/*  Copy the buffer */
		if (msgtrace.write_idx + count <= LOG_BUF_LEN)
			memcpy(&(msgtrace.log_buf[msgtrace.write_idx]), buf, count);
		else {
			uint16 bytes = LOG_BUF_LEN - msgtrace.write_idx;
			memcpy(&(msgtrace.log_buf[msgtrace.write_idx]), &(buf[0]), bytes);
			memcpy(&(msgtrace.log_buf[0]), &(buf[bytes]), count - bytes);
		}

		msgtrace.write_idx = (msgtrace.write_idx + count) & LOG_BUF_MASK;

		if (msgtrace.timer != NULL &&
		    !msgtrace.sending &&
		    msgtrace.event_trace_enabled) {
			/* Trigger immediately the sending by setting the timer to 0 */
			hnd_timer_start(msgtrace.timer, SEND_TIMEOUT_VALUE, FALSE);
			msgtrace.sending = TRUE;
		}
	} else {
		msgtrace.discarded_bytes += count;
		msgtrace.discarded_printf++;
	}
}

void
BCMATTACHFN(msgtrace_init)(void *hdl1, void *hdl2, msgtrace_func_send_t func_send)
{
	ASSERT(func_send != NULL);

	msgtrace.hdl1 = hdl1;
	msgtrace.hdl2 = hdl2;
	msgtrace.func_send = func_send;
	msgtrace.retry_count = 0;

	msgtrace.timer  = hnd_timer_create(NULL, NULL, msgtrace_timeout,  NULL);

#if defined(BCMSDIODEV_ENABLED) && defined(_RTE_)
	/* Let the host known the address of msgtrace.
	 * If there is a crash before sending the first event, then the host can download
	 * msgtrace.
	 */
	sdpcm_shared.msgtrace_addr = (uint32)&msgtrace;
#endif
#if defined(BCMPCIEDEV) && defined(_RTE_)
	if (BCMPCIEDEV_ENAB()) {
		pciedev_shared.msgtrace_addr = (uint32)&msgtrace;
	}
#endif /* BCMPCIEDEV && _RTE_ */

}
