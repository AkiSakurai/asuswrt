/*
 * Common (OS-independent) portion of
 * Broadcom 802.11bang Networking Device Driver
 *
 * Copyright (C) 2010, Broadcom Corporation
 * All Rights Reserved.
 * 
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Broadcom Corporation;
 * the contents of this file may not be disclosed to third parties, copied
 * or duplicated in any form, in whole or in part, without the prior
 * written permission of Broadcom Corporation.
 *
 * $Id: wlc.c,v 1.6183.2.453 2011-02-10 15:12:24 Exp $
 */

#include <wlc_cfg.h>
#include <typedefs.h>
#include <bcmdefs.h>
#include <osl.h>
#include <bcmutils.h>
#include <bcmwifi.h>
#include <siutils.h>
#include <bcmendian.h>
#include <proto/802.1d.h>
#include <proto/802.11.h>
#include <proto/802.11e.h>
#include <proto/bcmip.h>
#include <proto/wpa.h>
#include <proto/vlan.h>
#include <hndsoc.h>
#include <sbchipc.h>
#include <pcicfg.h>
#include <bcmsrom.h>
#if defined(WLTEST) || defined(BCMDBG_DUMP)
#include <bcmnvram.h>
#endif
#include <wlioctl.h>
#include <epivers.h>
#if defined(BCMSUP_PSK) || defined(STA) || defined(LINUX_CRYPTO)
#include <proto/eapol.h>
#endif
#include <bcmwpa.h>
#include <sbhndpio.h>
#include <sbhnddma.h>
#include <hnddma.h>
#include <hndpmu.h>
#include <d11.h>
#include <wlc_rate.h>
#include <wlc_pub.h>
#include <wlc_key.h>
#include <wlc_bsscfg.h>
#include <wlc_channel.h>
#include <wlc.h>
#include <wlc_bmac.h>
#include <wlc_apps.h>
#include <wlc_scb.h>
#include <wlc_phy_hal.h>
#include <wlc_phy_shim.h>
#include <wlc_antsel.h>
#include <wlc_led.h>
#include <wlc_frmutil.h>
#include <wlc_stf.h>
#ifdef WLBA
#include <wlc_ba.h>
#endif
#include <wlc_security.h>
#ifdef WLAMSDU
#include <wlc_amsdu.h>
#endif
#ifdef WLAMPDU
#include <wlc_ampdu.h>
#endif
#ifdef WLP2P
#include <wlc_p2p.h>
#endif
#ifdef WLMCHAN
#include <wlc_mchan.h>
#endif
#ifdef WLBTAMP
#include <proto/802.11_bta.h>
#include <wlc_bta.h>
#endif
#include <wlc_rate_sel.h>
#ifdef CRAM
#include <wlc_cram.h>
#endif
#include <wlc_event.h>
#ifdef WOWL
#include <wlc_wowl.h>
#endif
#include <wlc_seq_cmds.h>
#ifdef WLDIAG
#include <wlc_diag.h>
#endif
#include <wl_export.h>
#include "d11ucode.h"
#if defined(BCMSUP_PSK)
#include <wlc_sup.h>
#endif
#if defined(BCMAUTH_PSK)
#include <wlc_auth.h>
#endif
#ifdef WET
#include <wlc_wet.h>
#endif
#ifdef WET_TUNNEL
#include <wlc_wet_tunnel.h>
#endif
#ifdef WMF
#include <wlc_wmf.h>
#endif
#if defined(BCMNVRAMW) || defined(WLTEST)
#include <bcmotp.h>
#endif
#ifdef BCMCCMP
#include <bcmcrypto/aes.h>
#endif
#include <wlc_rm.h>
#include "wlc_cac.h"
#include <wllmacctl.h>
#include <wlc_lmac.h>
#include <wlc_ap.h>
#ifdef AP
#include <wlc_apcs.h>
#endif
#include <wlc_scan.h>
#ifdef WLPLT
#include <wlc_plt.h>
#endif
#ifdef WL11K
#include <wlc_rrm.h>
#endif
#ifdef WLWNM
#include <wlc_wnm.h>
#endif
#ifdef WLC_HIGH_ONLY
#include <bcm_rpc_tp.h>
#include <bcm_rpc.h>
#include <bcm_xdr.h>
#include <wlc_rpc.h>
#include <wlc_rpctx.h>
#endif /* WLC_HIGH_ONLY */
#if defined(RWL_DONGLE) || defined(UART_REFLECTOR)
#include <rwl_shared.h>
#include <rwl_uart.h>
#endif /* RWL_DONGLE || UART_REFLECTOR */
#include <wlc_extlog.h>
#include <wlc_alloc.h>
#include <wlc_mfg.h>
#include <wlc_assoc.h>
#if defined(RWL_WIFI) || defined(WIFI_REFLECTOR)
#include <wlc_rwl.h>
#endif
#ifdef WLC_HOSTOID
#include <wlc_hostoid.h>
#endif /* WLC_HOSTOID */
#ifdef WLPFN
#include <wl_pfn.h>
#endif
#ifdef STA
#include <wlc_wpa.h>
#endif /* STA */

#ifdef WL_MULTIQUEUE
#define WL_MQ(x) do {} while (0)
#endif /* WL_MULTIQUEUE */

#if defined(DSLCPE_DELAY)
#undef SPINWAIT
#define SPINWAIT(exp, us) { \
	uint countdown = (us) + 9; \
	while ((exp) && (countdown >= 10)) { \
		OSL_YIELD_EXEC(wlc->osh, 10); \
		countdown -= 10; \
	} \
}
#endif

#ifdef MFP
#define MFP_TEST 1
#endif

/*
 * buffer length needed for wlc_format_ssid
 * 32 SSID chars, max of 4 chars for each SSID char "\xFF", plus NULL.
 */
#define SSID_FMT_BUF_LEN	((4 * DOT11_MAX_SSID_LEN) + 1)

#define	TIMER_INTERVAL_WATCHDOG	1000	/* watchdog timer, in unit of ms */
#define	TIMER_INTERVAL_RADIOCHK	800	/* radio monitor timer, in unit of ms */

#if defined(WL_DNGL_WD) && !defined(WLC_HIGH_ONLY)
#error "WL_DNGL_WD needs WLC_HIGH_ONLY"
#endif
#ifdef WL_DNGL_WD
#ifndef WL_DNGL_WD_DEFAULT_TIMEOUT
#define WL_DNGL_WD_DEFAULT_TIMEOUT	2 /* default 2 sec */
#endif
#endif /* WL_DNGL_WD */
#ifndef AP_KEEP_ALIVE_INTERVAL
#define AP_KEEP_ALIVE_INTERVAL  10 /* seconds */
#endif /* AP_KEEP_ALIVE_INTERVAL */

#ifndef WLC_MPC_MAX_DELAYCNT
#define	WLC_MPC_MAX_DELAYCNT	10	/* Max MPC timeout, in unit of watchdog */
#endif
#define	WLC_MPC_MIN_DELAYCNT	0	/* Min MPC timeout, in unit of watchdog */
#define	WLC_MPC_THRESHOLD	3	/* MPC count threshold level */

#define	BEACON_INTERVAL_DEFAULT	100	/* beacon interval, in unit of 1024TU */
#define	DTIM_INTERVAL_DEFAULT	3	/* DTIM interval, in unit of beacon interval */

#define CSA_PRE_SWITCH_TIME	10	/* pre-csa switch time, in unit of ms */

/* Scale down delays to accommodate QT slow speed */
#define	BEACON_INTERVAL_DEF_QT	20	/* beacon interval, in unit of 1024TU */
#define	DTIM_INTERVAL_DEF_QT	1	/* DTIM interval, in unit of beacon interval */



/* antenna swap threshold */
#define	ANTCNT			10	/* vanilla M_MAX_ANTCNT value */
#ifdef WLAFTERBURNER
#define	ANTCNT_AB		5	/* afterburner M_MAX_ANTCNT value */
#endif

#define	PRETBTT_PHY_US_QT	10	/* phy pretbtt time in us on QT(no radio) */

#define	PRETBTT_APHY_US		120	/* a phy pretbtt time in us */
#define	PRETBTT_BPHY_US		250	/* b/g phy pretbtt time in us */
#define	PRETBTT_NPHY_US		512	/* n phy REV3 pretbtt time in us */
#define	PRETBTT_LPPHY_US	100	/* lpphy pretbtt time in us */
#define	PRETBTT_SSLPNPHY_US	250	/* sslpnphy pretbtt time in us */
#define	PRETBTT_HTPHY_US	512	/* ht phy pretbtt time in us */
#define	PRETBTT_LCNPHY_US	512	/* lcn phy pretbtt time in us */

#define	TBTT_ALIGN_LEEWAY_US	100	/* min leeway before first TBTT in us */
#define	TBTT_ALIGN_LEEWAY_US_QT	2	/* min leeway before first TBTT in us */

#define BT_AMPDU_THRESH		10000	/* if BT period < this threshold, turn off ampdu */

/*
 * driver maintains internal 'tick'(wlc->pub->now) which increments in 1s OS timer(soft
 * watchdog) it is not a wall clock and won't increment when driver is in "down" state
 * this low resolution driver tick can be used for maintenance tasks such as phy
 * calibration and scb update
 */
#define	SW_TIMER_IBSS_GMODE_RATEPROBE	60	/* periodic IBSS gmode rate probing */

/* watchdog trigger mode: OSL timer or TBTT */
#define WLC_WATCHDOG_TBTT(wlc) \
	(wlc->cfg->associated && wlc->cfg->pm->PM != PM_OFF && wlc->pub->align_wd_tbtt)

/* To inform the ucode of the last mcast frame posted so that it can clear moredata bit */
#define BCMCFID(wlc, fid) wlc_bmac_write_shm((wlc)->hw, M_BCMC_FID, (fid))

#ifdef WLC_LOW
#define WLC_WAR16165(wlc) (BUSTYPE(wlc->pub->sih->bustype) == PCI_BUS && \
			   (!AP_ENAB(wlc->pub)) && (wlc->war16165))
#else
#define WLC_WAR16165(wlc) (FALSE)
#endif /* WLC_HIGH_ONLY */

/* debug/trace */
uint wl_msg_level =
#if defined(BCMDBG) || defined(BCMDBG_ERR)
	WL_ERROR_VAL;
#else
	0;
#endif /* BCMDBG */

uint wl_msg_level2 =
#if defined(BCMDBG)
	0;
#else
	0;
#endif /* BCMDBG */

#ifdef RWL_DONGLE
int g_rwl_dongle_flag = 0;
#endif

/* Find basic rate for a given rate */
#define WLC_BASIC_RATE(wlc, rspec)	(IS_MCS(rspec) ? \
			(wlc)->band->basic_rate[mcs_table[rspec & RSPEC_RATE_MASK].leg_ofdm] : \
			(wlc)->band->basic_rate[rspec & RSPEC_RATE_MASK])

#define WLC_BSS_CONNECTED(cfg) \
			((cfg)->associated && (!(cfg)->BSS || !ETHER_ISNULLADDR(&(cfg)->BSSID)))

#define FRAMETYPE(r, mimoframe)	(IS_MCS(r) ? mimoframe	: (IS_CCK(r) ? FT_CCK : FT_OFDM))

#define D11N_MMPLCPLen(rxs)	((rxs)->PhyRxStatus_3 & PRXS3_nphy_MMPLCPLen_MASK)

#define D11HT_MMPLCPLen(rxs)	((((rxs)->PhyRxStatus_1 & PRXS1_HTPHY_MMPLCPLenL_MASK) >> 8) | \
				(((rxs)->PhyRxStatus_2 & PRXS2_HTPHY_MMPLCPLenH_MASK) << 8))

#define RFDISABLE_DEFAULT	10000000 /* rfdisable delay timer 500 ms, runs of ALP clock */

/* Increment interface stat */
#define WLCIFCNTINCR(_scb, _stat)					\
	if (_scb) {							\
		if (SCB_WDS(_scb)) {					\
			WLCNTINCR(_scb->wds->_cnt._stat);		\
		} else {						\
			wlc_bsscfg_t *_bsscfg = SCB_BSSCFG(_scb);	\
			if (_bsscfg)					\
				WLCNTINCR(_bsscfg->wlcif->_cnt._stat);	\
		}							\
	}

#ifdef BCMDBG
uint32 wl_apsta_dbg = WL_APSTA_UPDN_VAL;
/* pointer to most recently allocated wl/wlc */
static wlc_info_t *wlc_info_dbg = (wlc_info_t *)(NULL);
#endif

#if defined(BCMDBG) || defined(WLMSG_PRPKT) || defined(BCMDBG_DUMP)
struct wlc_id_name_entry {
	int id;
	const char *name;
};
typedef struct wlc_id_name_entry wlc_id_name_table_t[];
#endif

typedef struct wlc_pdu_tx_params {
	uint flags;
	uint fifo;
	wsec_key_t *key;
	ratespec_t rspec_override;
} wlc_pdu_tx_params_t;

/* wlc_pdu_tx_params.flags */
#define	WLC_TX_PARAMS_SHORTPRE	0x01

/* txheader cache related data structure and macros */
#ifndef WLMULTITXC
#define MAX_TXC_ENTRIES 1
#else
#define MAX_TXC_ENTRIES 2
#endif /* WLMULTITXC */

typedef struct txhdr_cache {
	uint	txhlen;		/* #bytes txh[] valid, 0=invalid */
	uint	pktlen;		/* tag: original user packet length */
	uint	fifo;           /* fifo for the pkt */
	uint	flags;		/* pkt flags */
	uint8	prio;           /* pkt prio */
	uint8	ps_on;		/* the scb was in power save mode when cache was built */
	uint	gen;		/* generation number (compare to wlc->txcgen) */
	uchar	txh[TXOFF];	/* cached tx header */
} txc_t;

typedef struct txhdr_cache_params {
	uint8 txc_avail_idx; /* txc index available for use */
	txc_t *scb_cubby[MAX_TXC_ENTRIES];
} txc_params_t;

struct txc_cubby {
	txc_params_t *txc;
};

#define SCB_TXC_INFO(wlc, scb) ((SCB_CUBBY((scb), (wlc)->txc_scb_handle)))
#define SCB_TXC_PARAMS(wlc, scb) (((struct txc_cubby *)SCB_TXC_INFO(wlc, scb))->txc)
#define SCB_TXC_CUBBY(wlc, scb, idx)\
	(((struct txc_cubby *)SCB_TXC_INFO(wlc, scb))->txc->scb_cubby[idx])

static int wlc_txc_scb_init(void *ctx, struct scb *scb);
static void wlc_txc_scb_free(void *ctx, struct scb *scb);
static uint8 wlc_txc_get_avail_idx(wlc_info_t *wlc, struct scb *scb);
static void wlc_txc_upd_avail_idx(wlc_info_t *wlc, struct scb *scb);

/* IOVar table */

/* Parameter IDs, for use only internally to wlc -- in the wlc_iovars
 * table and by the wlc_doiovar() function.  No ordering is imposed:
 * the table is keyed by name, and the function uses a switch.
 */
enum {
	IOV_RTSTHRESH = 1,
	IOV_D11_AUTH,
	IOV_STA_RETRY_TIME,
	IOV_ASSOC_RETRY_MAX,
	IOV_ASSOC_CACHE_ASSIST,
	IOV_RM_REQ,
	IOV_RM_REP,
	IOV_SUP_AUTH_STATUS,
	IOV_SUP_AUTH_STATUS_EXT,	/* Extended supplicant authentication status */
	IOV_SUP_WPA,
	IOV_VLAN_MODE,
	IOV_WME,
	IOV_WME_BSS_DISABLE,
	IOV_WME_NOACK,
	IOV_WME_APSD,
	IOV_WME_APSD_TRIGGER,	/* APSD Trigger Frame interval in ms */
	IOV_WME_AUTO_TRIGGER,	/* enable/disable APSD AUTO Trigger frame */
	IOV_WME_TRIGGER_AC,	/* APSD trigger frame AC */
	IOV_SEND_NULLDATA,	/* Used to tx a null frame to the given mac addr */
	IOV_WME_QOSINFO,
	IOV_WME_DP,
	IOV_WME_COUNTERS,
	IOV_WME_CLEAR_COUNTERS,
	IOV_WME_PREC_QUEUING,
#ifdef WMF
	IOV_WMF_BSS_ENABLE,
	IOV_WMF_UCAST_IGMP,
#endif
#ifdef MCAST_REGEN
	IOV_MCAST_REGEN_BSS_ENABLE,
#endif
	IOV_TXC,
	IOV_TXC_POLICY,
	IOV_TXC_STICKY,
#ifdef WLAFTERBURNER
	IOV_AFTERBURNER,
	IOV_AFTERBURNER_OVERRIDE,
#endif /* WLAFTERBURNER */
	IOV_WLFEATUREFLAG,
	IOV_DBGSEL,
	IOV_HWKEYS,
	IOV_WME_AC_STA,
	IOV_PER_CHAN_INFO,
	IOV_STA_INFO,
	IOV_CAP,
	IOV_WPA_CAP,
	IOV_MALLOCED,
	IOV_VNDR_IE,
	IOV_WPAIE,
	IOV_WSEC,
	IOV_WSEC_KEY,
	IOV_WSEC_RESTRICT,
	IOV_WET,
#ifdef MAC_SPOOF
	IOV_MAC_SPOOF,
#endif /* MAC_SPOOF */
	IOV_EAP_RESTRICT,
	IOV_IBSS_JOIN_ONLY,
	IOV_FRAGTHRESH,
	IOV_5G_RATE,
	IOV_5G_MRATE,
	IOV_2G_RATE,
	IOV_2G_MRATE,
	IOV_QTXPOWER,
	IOV_WPA_MSGS,
	IOV_WPA_AUTH,
	IOV_EIRP,
	IOV_CUR_ETHERADDR,
	IOV_PERM_ETHERADDR,
	IOV_RAND,
	IOV_MPC,
	IOV_WATCHDOG_DISABLE,
	IOV_MPC_DUR,
	IOV_JOIN_PREF,
	IOV_BCMERRORSTR,
	IOV_BCMERROR,
	IOV_FREQTRACK,
	IOV_COUNTERS,
	IOV_ASSOC_INFO,
	IOV_APSTA_DBG,
	IOV_DIAG,
	IOV_ASSOC_REQ_IES,
	IOV_ASSOC_RESP_IES,
	IOV_EVENT_MSGS,
	IOV_PMKID_INFO,
	IOV_SBGPIOTIMERVAL,
	IOV_SBGPIOTIMERMASK,
	IOV_SBGPIOOUT,
	IOV_RFDISABLEDLY,
	IOV_ABMINRATE,
	IOV_ANTSEL_TYPE,
	IOV_COUNTRY_LIST_EXTENDED,
	IOV_RESET_D11CNTS,
	IOV_SCANABORT,
	IOV_IBSS_ALLOWED,
	IOV_MCAST_LIST,
	IOV_NRATE,		/* legacy rate/mcs and stf mode */
	IOV_MIMO_FT,		/* MIMO frametype */
	IOV_RIFS,		/* MIMO, RIFS */
	IOV_RIFS_ADVERT,	/* MIMO, RIFS mode advertisement */
	IOV_SGI_RX,		/* MIMO, SGI RX */
	IOV_SGI_TX,		/* MIMO, SGI TX */
	IOV_MIMO_BW_CAP,	/* set the advertised ch widths */
	IOV_OBSS_COEX,		/* 20/40MHz BSS Coexistence setting */
	IOV_OBSS_SCAN_PARAMS,	/* Overlapping BSS scan parameter */
	IOV_40_INTOLERANT,	/* set 40 Mhz intolerant bit */
	IOV_40_INTOLERANT_DET,	/* 40 Mhz intolerant device detected */
	IOV_OBSS_COEX_ACTIVE,	/* get current support of 20/40MHz BSS Coexistence */
	IOV_OBSS_WIDTH20,	/* set 20Mhz BSS Width bit */
	IOV_OBSS_WIDTH20_DET,	/* 20MHz BSS Width device detected */
	IOV_OBSS_COEX_ACTION,	/* send 20/40 OBSS Coexistence action frame */
	IOV_OBSS_TE_MASK,		/* get/set the trigger event mask */
	IOV_NMODE,              /* enable/disable support for 802.11N */
	IOV_NREQD,              /* require support for 802.11N */
	IOV_N_PROTECTION,
	IOV_N_PROTECTION_OVERRIDE,
	IOV_GF_PROTECTION,
	IOV_GF_PROTECTION_OVERRIDE,
	IOV_PREAMBLE_OVERRIDE,
	IOV_TXBURST_LIM,
	IOV_GF_CAP,		/* get/set Green Field Cap bit in HT cap IE */
	IOV_LDPC_CAP,		/* HTPHY, enable/disable LDPC RX */
	IOV_LDPC_TX,		/* HTPHY, enable/disable/auto LDPC TX */
	IOV_OFDM_ASSOC,		/* get status of ofdm_assoc */
	IOV_NONERP_ASSOC,	/* get status of nonerp_assoc */
	IOV_PKTENG,
	IOV_PKTENG_MAXLEN,  /* max packet size limit for packet engine */
	IOV_BOARDFLAGS,
	IOV_BOARDFLAGS2,
	IOV_ANTGAIN,
	IOV_NVRAM_GET,
	IOV_NVRAM_DUMP,
	IOV_CISWRITE,
	IOV_CISDUMP,
	IOV_LIFETIME,		/* Packet lifetime */
	IOV_BCN_TIMEOUT,	/* Beacon timeout */
	IOV_TXMAXPKTS,		/* max txpkts that can be pending in txfifo */
	IOV_NOBCNSSID,		/* No SSID in Beacons */
	IOV_NOBCPRBRESP,	/* No response to Broadcast Probes */
	IOV_CHANSPEC,		/* return the current chanspec */
	IOV_CHANSPECS,		/* return the available chanspecs (all or based on options) */
	IOV_CURR_MCSSET,	/* return current MCS set */
	IOV_CCK_TXBW,		/* 11N, cck tx b/w override */
	IOV_OFDM_TXBW,		/* 11N, ofdm tx b/w override */
	IOV_MIMO_TXBW,		/* 11N, mimo tx b/w override */
	IOV_BTC_MODE,		/* BT CoExistence mode */
	IOV_BTC_WIRE,		/* BTC number of wires */
	IOV_DUTY_CYCLE_CCK,	/* maximum allowed duty cycle for CCK */
	IOV_DUTY_CYCLE_OFDM,	/* maximum allowed duty cycle for OFDM */
	IOV_DUTY_CYCLE_PWR,	/* maximum allowed duty cycle for power throttle feature */
	IOV_BTC_STUCK_WAR,	/* BTC stuck WAR */
	IOV_DUMP,		/* Dump iovar */
	IOV_COUNTRY,
	IOV_AUTOCOUNTRY_DEFAULT,
	IOV_COUNTRY_IE_OVERRIDE,
	IOV_TXFIFO_SZ,		/* size of tx fifo */
	IOV_HTPHY_MEMBERSHIP,	/* set HT PHY Membership */
	IOV_VER,
	IOV_ANTENNAS,		/* num of antennas to be used */
	IOV_SDCIS,
	IOV_SDIO_DRIVE,		/* SDIO drive strength in mA */
	IOV_BCN_THRESH,
	IOV_SCANRESULTS_MINRSSI,
	IOV_TOE,
	IOV_ARPOE,
#ifdef PLC
	IOV_PLC,
#endif /* PLC */
#if defined(MACOSX)
	IOV_SENDUP_MGMT,	/* Send up management packet per packet filter setting */
#endif
	IOV_ISCAN,
	IOV_ISCANRESULTS,
#if defined(WME_PER_AC_TUNING) && defined(WME_PER_AC_TX_PARAMS)
	IOV_WME_TX_PARAMS,
#endif
	IOV_IBSS_COALESCE_ALLOWED,
	IOV_PSPOLL_PRD,		/* PS poll interval in milliseconds */
	IOV_BCN_LI_BCN,		/* Beacon listen interval in # of beacons */
	IOV_BCN_LI_DTIM,	/* Beacon listen interval in # of DTIMs */
	IOV_ASSOC_LISTEN,	/* Request this listen interval frm AP */
	IOV_MSGLEVEL2,
	IOV_ASSOC_RECREATE,
	IOV_PRESERVE_ASSOC,
	IOV_ASSOC_PRESERVED,
	IOV_ASSOC_VERIFY_TIMEOUT,
	IOV_RECREATE_BI_TIMEOUT,
	IOV_INFRA_CONFIGURATION, /* Reads the configured infra mode */
	IOV_DOWN_OVERRIDE,
	IOV_ALLMULTI,
	IOV_LEGACY_PROBE,
	IOV_WOWL_PKT, 		/* Generate a wakup packet */
	IOV_ASSOCROAM,
	IOV_ROAM_OFF,		/* Disable/Enable roaming */
	IOV_FULLROAM_PERIOD,
	IOV_ROAM_PERIOD,
	IOV_TXMIN_ROAMTHRESH,	/* Roam threshold for too many pkts at min rate */
	IOV_AP_ENV_DETECT,	/* Auto-detect the environment for optimal roaming */
	IOV_TXFAIL_ROAMTHRESH,	/* Roam threshold for tx failures at min rate */
	IOV_MOTION_RSSI_DELTA,	/* enable/disable motion detection and set threshold */
	IOV_SCAN_PIGGYBACK,	/* Build roam cache from periodic upper-layer scans */
	IOV_ROAM_RSSI_CANCEL_HYSTERESIS,
	IOV_BANDUNIT,		/* Get the bandunit from dongle */
#if defined(DSLCPE_DELAY)
	IOV_DELAYMODE,		/* mode of running phy watchdog */
#endif
	IOV_BTC_FLAGS,		/* BT Coex ucode flags */
	IOV_BTC_PARAMS,		/* BT Coex shared memory parameters */
#if defined(RIM) || defined(BCMDBG) || defined(WLNINTENDO2)
	IOV_RATE_HISTO,		/* Rate Histogram */
#endif
#if defined(WL_PM2_RCV_DUR_LIMIT)
	IOV_PM2_RCV_DUR,	/* PM=2 burst receive duration limit, in ms */
#endif /* WL_PM2_RCV_DUR_LIMIT */
#if defined(BCMDBG) && defined(MBSS)
	IOV_SRCHMEM,	/* ucode search engine memory */
#endif	/* BCMDBG && MBSS */
	IOV_PM2_SLEEP_RET,	/* PM=2 inactivity return to PS mode time, in ms */
#ifdef BRCMAPIVTW
	IOV_BRCMAPIVTW_OVERRIDE,
#endif
#if defined(DELTASTATS)
	IOV_DELTA_STATS_INTERVAL,
	IOV_DELTA_STATS,
#endif
	IOV_BMAC_REBOOT,
	IOV_BMAC_DNGL_SUSPEND_ENABLE, /* enable USB suspend, linux only */
	IOV_AGGDBG,
	IOV_RPC_AGG,
	IOV_RPC_MSGLEVEL,
	IOV_RPC_DNGL_TXQ_WM,
	IOV_RPC_DNGL_AGG_LIMIT,
	IOV_RPC_HOST_AGG_LIMIT,
	IOV_RPCHIST_RPCQ_CLEAR,
	IOV_RPCHIST_TXQ_CLEAR,
	IOV_RSSI_ANT,
	IOV_SNR,
#ifdef RWL_DONGLE
	IOV_RWLDONGLE_DATA,
	IOV_DONGLE_FLAG,
#endif /* RWL_DONGLE */
#ifdef WIFI_ACT_FRAME
	IOV_ACTION_FRAME,	/* Wifi protocol action frame */
	IOV_AF,			/* Wifi protocol action frame send */
#endif /* #ifdef WIFI_ACT_FRAME */
	IOV_NAV_RESET_WAR_DISABLE,	/* WAR to reset NAV on 0 dur ack reception */
	IOV_TXMCSSET,
	IOV_RXMCSSET,
	IOV_RSSI_EVENT,
	IOV_RSSI_WINDOW_SZ,
	IOV_SUP_WPA2_EAPVER,
	IOV_SUP_M3SEC_OK,
	IOV_RFAWARE_LIFETIME,
	IOV_ASSERTLOG,
	IOV_ASSERT_TYPE,
#ifdef ADV_PS_POLL
	IOV_ADV_PS_POLL,
#endif
#ifdef PHYCAL_CACHING
	IOV_PHYCAL_CACHE,
	IOV_CACHE_CHANSWEEP,
#endif /* PHYCAL_CACHING */
	IOV_HT_WSEC_RESTRICT,
	IOV_PM2_RADIO_SHUTOFF_DLY,	/* PM2 Radio Shutoff delay after NULL PM=1 */
	IOV_CHANIM_ENAB,
	IOV_CHANIM_STATE, /* chan interference detect */
	IOV_CHANIM_MODE,
	IOV_CCASTATS_THRES,
	IOV_CRSGLITCH_THRES, /* chan interference threshold */
	IOV_BGNOISE_THRES,  /* background noise threshold */
	IOV_SEND_FRAME,		/* send a frame */
	IOV_CCA_STATS,		/* report ucode cca stats */
#ifdef ISID_STATS
	IOV_ITFR_STATS,		/* report interference source state */
	IOV_ITFR_ENAB,		/* interference source detection and identification */
	IOV_ITFR_DETECT,	/* trigger detection for interference on different channel */
	IOV_ITFR_ABORT,		/* abort current detection */
	IOV_ITFR_THRES,		/* interference threshold */
	IOV_ITFR_NET_THRES,	/* max allowed num of networks in working environment */
	IOV_ITFR_STOP_TM,	/* stop duration(in second) when num of AP over limit */
	IOV_ITFR_ID_HOLD_TM,	/* hold duration(in second) for identified source */
	IOV_ITFR_NON_ID_HOLD_TM,	/* hold duration(in second) fo non-identified source */
	IOV_ITFR_CLEAN_TM,	/* clean duration(in second) before changing state to clean */
#endif /* ISID_STATS */
#if defined(WLTEST)
	IOV_MANF_INFO,
#endif 
	IOV_SMF_STATS,  /* selected management frames (smf) stats */
	IOV_SMF_STATS_ENABLE, /* SMFS enable */
#ifdef BCMWAPI_WAI
	IOV_WAI_RESTRICT,
	IOV_WAI_REKEY,
#endif /* BCMWAPI_WAI */
	IOV_ROAM_TBTT,
	IOV_EXEMPT_M4,
	IOV_ESCAN,
	IOV_POOL,
	IOV_CURR_RATESET,
	IOV_RATESET,
	IOV_BRCM_DCS_REQ, /* BRCM DCS (RFAware feature) */
	IOV_PM2_REFRESH_BADIV,	/* Refresh PM2 timeout with bad iv frames */
	IOV_WAKEUP_SCAN,
	IOV_SAMPLE_PERIOD,
	IOV_THRESHOLD_TIME,
	IOV_MAX_ACS,
	IOV_LOCKOUT_PERIOD,
	IOV_ACS_RECORD,
	IOV_CHANIM_STATS,
	IOV_PM_DUR,	/* Retrieve accumulated PM duration and reset accumulator */
	IOV_AUTHOPS,
	IOV_NOLINKUP,
#ifdef WL_DNGL_WD
	IOV_DNGL_WD,
#endif /* WL_DNGL_WD */
	IOV_SAFE_MODE_ENABLE, /* safe_mode for EXT_STA */
	IOV_TSF,
	IOV_TSF_ADJUST,
	IOV_WLIF_BSSCFG_IDX,
	IOV_SSID,
	IOV_JOIN,
#ifdef MFP
	IOV_MFP,
	IOV_MFP_SHA256,
	IOV_MFP_SA_QUERY,
	IOV_MFP_DISASSOC,
	IOV_MFP_DEAUTH,
	IOV_MFP_ASSOC,
	IOV_MFP_AUTH,
	IOV_MFP_REASSOC,
	IOV_MFP_BIP_TEST,
#endif
#ifdef WLNINTENDO2
	IOV_LINKQUAL_ONOFF,
	IOV_GET_LINKQUAL_STATS,
	IOV_FLUSH_SELECTED_TX_FIFOS,
#endif /* WLNINTENDO2 */
	IOV_RPT_HITXRATE,	/* report highest tx rate from tx rate history */
	IOV_AUTOCOUNTRY,
#if defined(WLTEST)
	IOV_TPC_RPT_OVERRIDE,
#endif 
	IOV_BUF_KEY_B4_M4,
	IOV_RPMT,		/* Rapid PM transition */
	IOV_CHAN_BLOCK,
	IOV_IE,
	IOV_LAST 		/* In case of a need to check max ID number */
};

const bcm_iovar_t wlc_iovars[] = {
#ifdef STA
	{"escan", IOV_ESCAN,
	(0), IOVT_BUFFER, WL_ESCAN_PARAMS_FIXED_SIZE
	},
#endif
	{"rtsthresh", IOV_RTSTHRESH,
	(IOVF_WHL|IOVF_OPEN_ALLOW), IOVT_UINT16, 0
	},
	{"auth", IOV_D11_AUTH,
	IOVF_OPEN_ALLOW, IOVT_INT32, 0
	},
#ifdef STA
	{"sta_retry_time", IOV_STA_RETRY_TIME,
	(IOVF_WHL|IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"assoc_retry_max", IOV_ASSOC_RETRY_MAX,
	(IOVF_WHL), IOVT_UINT8, 0
	},
#ifdef WLSCANCACHE
	{"assoc_cache_assist", IOV_ASSOC_CACHE_ASSIST,
	(0), IOVT_BOOL, 0
	},
#endif

#if defined(BCMSUP_PSK)
	{"sup_auth_status", IOV_SUP_AUTH_STATUS,
	(0), IOVT_UINT32, 0
	},
	{"sup_auth_status_ext", IOV_SUP_AUTH_STATUS_EXT,
	(0), IOVT_UINT32, 0
	},
#endif 
#ifdef BCMSUP_PSK
	{"sup_wpa", IOV_SUP_WPA,
	(0), IOVT_BOOL, 0
	},
	{"sup_wpa2_eapver", IOV_SUP_WPA2_EAPVER,
	(0), IOVT_BOOL, 0
	},
#endif	/* BCMSUP_PSK */
#if defined(BCMSUP_PSK)
	{"sup_m3sec_ok", IOV_SUP_M3SEC_OK,
	(0), IOVT_BOOL, 0
	},
#endif 
	{"join_pref", IOV_JOIN_PREF,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"freqtrack", IOV_FREQTRACK,
	(IOVF_SET_DOWN), IOVT_INT8, 0
	},
#endif	/* STA */
	{"vlan_mode", IOV_VLAN_MODE,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"wme", IOV_WME,
	(IOVF_SET_DOWN | IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"wme_bss_disable", IOV_WME_BSS_DISABLE,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"wme_noack", IOV_WME_NOACK,
	(IOVF_OPEN_ALLOW), IOVT_BOOL,	0
	},
	{"wme_apsd", IOV_WME_APSD,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
#ifdef STA
	{"wme_apsd_trigger", IOV_WME_APSD_TRIGGER,
	(IOVF_OPEN_ALLOW|IOVF_BSSCFG_STA_ONLY), IOVT_UINT32, 0
	},
	{"wme_trigger_ac", IOV_WME_TRIGGER_AC,
	(IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"wme_auto_trigger", IOV_WME_AUTO_TRIGGER,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"send_nulldata", IOV_SEND_NULLDATA,
	(IOVF_SET_UP), IOVT_BUFFER, ETHER_ADDR_LEN
	},
#endif /* STA */
	{"wme_qosinfo", IOV_WME_QOSINFO,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"wme_dp", IOV_WME_DP,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"wme_prec_queuing", IOV_WME_PREC_QUEUING,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0},
#if defined(WLCNT)
	{"wme_counters", IOV_WME_COUNTERS,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, sizeof(wl_wme_cnt_t)
	},
	{"wme_clear_counters", IOV_WME_CLEAR_COUNTERS,
	(IOVF_OPEN_ALLOW), IOVT_VOID, 0
	},
#endif
#ifdef WMF
	{"wmf_bss_enable", IOV_WMF_BSS_ENABLE,
	(0), IOVT_BOOL, 0
	},
	{"wmf_ucast_igmp", IOV_WMF_UCAST_IGMP,
	(0), IOVT_BOOL, 0
	},
#endif
#ifdef MCAST_REGEN
	{"mcast_regen_bss_enable", IOV_MCAST_REGEN_BSS_ENABLE,
	(0), IOVT_BOOL, 0
	},
#endif
	{"txc_policy", IOV_TXC_POLICY,
	(0), IOVT_BOOL, 0
	},
#ifdef BCMDBG
	{"txc", IOV_TXC,
	(0), IOVT_BOOL, 0
	},
	{"txc_sticky", IOV_TXC_STICKY,
	(0), IOVT_BOOL, 0
	},
#endif /* BCMDBG */
#ifdef WLAFTERBURNER
	{"afterburner", IOV_AFTERBURNER,
	(0), IOVT_BOOL,	0
	},
	{"afterburner_override", IOV_AFTERBURNER_OVERRIDE,
	(0), IOVT_INT32, 0
	},
#endif /* WLAFTERBURNER */
	{"wlfeatureflag", IOV_WLFEATUREFLAG,
	(IOVF_SET_DOWN), IOVT_INT32, 0
	},
	{"wme_ac_sta", IOV_WME_AC_STA,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER,
	(AC_COUNT * sizeof(edcf_acparam_t))
	},
	/* it is required for regulatory testing */
	{"per_chan_info", IOV_PER_CHAN_INFO,
	(0), IOVT_UINT16, 0
	},
	{"sta_info", IOV_STA_INFO,
	(IOVF_SET_UP|IOVF_OPEN_ALLOW), IOVT_BUFFER, WL_OLD_STAINFO_SIZE
	},
	{"cap", IOV_CAP,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, WLC_IOCTL_SMLEN
	},
	{"wpa_msgs", IOV_WPA_MSGS,
	(0), IOVT_BOOL, 0
	},
	{"wpa_auth", IOV_WPA_AUTH,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"wpa_cap", IOV_WPA_CAP,
	(IOVF_OPEN_ALLOW), IOVT_UINT16, 0
	},
	{"malloced", IOV_MALLOCED,
	(IOVF_WHL), IOVT_UINT32, 0
	},
	{"vndr_ie", IOV_VNDR_IE,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, (sizeof(int))
	},
	{"wpaie", IOV_WPAIE,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0,
	},
	{"wsec", IOV_WSEC,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"wsec_key", IOV_WSEC_KEY,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, sizeof(wl_wsec_key_t)
	},
	{"wsec_restrict", IOV_WSEC_RESTRICT,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
#ifdef WET
	{"wet", IOV_WET,
	(0), IOVT_BOOL, 0
	},
#endif
#ifdef MAC_SPOOF
	{"mac_spoof", IOV_MAC_SPOOF,
	(0), IOVT_BOOL, 0
	},
#endif /* MAC_SPOOF */
#if defined(BCMDBG) || defined(WLTEST)
	{"eirp", IOV_EIRP,
	(IOVF_MFG), IOVT_UINT32, 0
	},
#endif /* defined(BCMDBG) || defined(WLTEST) */
	{"eap_restrict", IOV_EAP_RESTRICT,
	(0), IOVT_BOOL, 0
	},
	{"fragthresh", IOV_FRAGTHRESH,
	(IOVF_OPEN_ALLOW), IOVT_UINT16, 0
	},
	/* a_rate and bg_rate are superseded by 5g_rate and 2g_rate */
	{"a_rate", IOV_5G_RATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"a_mrate", IOV_5G_MRATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"bg_rate", IOV_2G_RATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"bg_mrate", IOV_2G_MRATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"5g_rate", IOV_5G_RATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"5g_mrate", IOV_5G_MRATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"2g_rate", IOV_2G_RATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"2g_mrate", IOV_2G_MRATE,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"qtxpower", IOV_QTXPOWER,
	(IOVF_WHL|IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},      /* constructed in wlu.c with txpwr or txpwr1 */
#if defined(WLP2P)
	{"cur_etheraddr", IOV_CUR_ETHERADDR,
	(0), IOVT_BUFFER, ETHER_ADDR_LEN
	},
#else
	{"cur_etheraddr", IOV_CUR_ETHERADDR,
	(IOVF_SET_DOWN), IOVT_BUFFER, ETHER_ADDR_LEN
	},
#endif 
	{"perm_etheraddr", IOV_PERM_ETHERADDR,
	(0), IOVT_BUFFER, ETHER_ADDR_LEN
	},
#ifdef BCMDBG
	{"rand", IOV_RAND,
	(IOVF_GET_UP), IOVT_UINT16, 0
	},
#endif
	{"mpc", IOV_MPC,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"wd_disable", IOV_WATCHDOG_DISABLE,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},

#ifdef STA
	{"mpc_dur", IOV_MPC_DUR,
	(0), IOVT_UINT32, 0
	},
	{"apsta_dbg", IOV_APSTA_DBG,
	(0), IOVT_UINT32, sizeof(uint32)
	},
	{"IBSS_join_only", IOV_IBSS_JOIN_ONLY,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
#endif /* STA */
	{"bcmerrorstr", IOV_BCMERRORSTR,
	(0), IOVT_BUFFER, BCME_STRLEN
	},
	{"bcmerror", IOV_BCMERROR,
	(0), IOVT_INT8, 0
	},
	{"counters", IOV_COUNTERS,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, sizeof(wl_cnt_t)
	},

	{"assoc_info", IOV_ASSOC_INFO,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, (sizeof(wl_assoc_info_t))
	},
	{"assoc_req_ies", IOV_ASSOC_REQ_IES,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"assoc_resp_ies", IOV_ASSOC_RESP_IES,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"event_msgs", IOV_EVENT_MSGS,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, WL_EVENTING_MASK_LEN
	},
	{"pmkid_info", IOV_PMKID_INFO,
	(0), IOVT_BUFFER, sizeof(uint)
	},
#if defined(MACOSX)
	{"txfifo_sz", IOV_TXFIFO_SZ,
	(IOVF_SET_DOWN), IOVT_BUFFER, sizeof(wl_txfifo_sz_t)
	},
#endif 
	{"abminrate", IOV_ABMINRATE,
	0, IOVT_UINT8, 0
	},
	{"antsel_type", IOV_ANTSEL_TYPE,
	0, IOVT_UINT8, 0
	},
	{"dutycycle_cck", IOV_DUTY_CYCLE_CCK,
	0, IOVT_UINT8, 0
	},
	{"dutycycle_ofdm", IOV_DUTY_CYCLE_OFDM,
	0, IOVT_UINT8, 0
	},
	{"dutycycle_pwr", IOV_DUTY_CYCLE_PWR,
	0, IOVT_UINT8, 0
	},
	{"reset_d11cnts", IOV_RESET_D11CNTS,
	0, IOVT_VOID, 0
	},
	{"scanabort", IOV_SCANABORT,
	0, IOVT_VOID, 0
	},
	{"ibss_allowed", IOV_IBSS_ALLOWED,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"country_list_extended", IOV_COUNTRY_LIST_EXTENDED,
	(0), IOVT_BOOL, 0
	},
	{"mcast_list", IOV_MCAST_LIST,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, sizeof(uint32)
	},
	{"chanspec", IOV_CHANSPEC,
	(IOVF_OPEN_ALLOW), IOVT_UINT16, 0
	},
	{"chanspecs", IOV_CHANSPECS,
	(0), IOVT_BUFFER, (sizeof(uint32)*(WL_NUMCHANSPECS+1))
	},
#if defined(WL11N) || defined(WLTEST)
	{"nrate", IOV_NRATE,
	(IOVF_OPEN_ALLOW | IOVF_MFG), IOVT_UINT32, 0
	},
#endif /* defined(WL11N) || defined(WLTEST) */
#ifdef WL11N
	{"cur_mcsset", IOV_CURR_MCSSET,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, MCSSET_LEN
	},
#if defined(BCMDBG) || defined(WLTEST)
	{"mimo_txbw", IOV_MIMO_TXBW,
	(IOVF_MFG), IOVT_INT32, 0
	},
#endif /* BCMDBG || WLTEST */
#if defined(BCMDBG)
	{"aggdbg", IOV_AGGDBG,
	(0), IOVT_INT32, 0
	},
#endif
	{"mimo_ft", IOV_MIMO_FT,
	(IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"obss_coex", IOV_OBSS_COEX,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"obss_scan_params", IOV_OBSS_SCAN_PARAMS,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, sizeof(wl_obss_scan_arg_t)
	},
	{"intol40", IOV_40_INTOLERANT,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"intol40_det", IOV_40_INTOLERANT_DET,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"obss_coex_action", IOV_OBSS_COEX_ACTION,
	(IOVF_SET_UP|IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"obss_te_mask", IOV_OBSS_TE_MASK,
	(0), IOVT_INT32, 0
	},
	{"nmode", IOV_NMODE,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"nreqd", IOV_NREQD,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"nmode_protection", IOV_N_PROTECTION,
	(IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"nmode_protection_override", IOV_N_PROTECTION_OVERRIDE,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"gf_protection", IOV_GF_PROTECTION,
	(IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"gf_protection_override", IOV_GF_PROTECTION_OVERRIDE,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"mimo_preamble", IOV_PREAMBLE_OVERRIDE,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_INT8, 0
	},
	{"mimo_bw_cap", IOV_MIMO_BW_CAP,
	(IOVF_SET_DOWN|IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"rifs", IOV_RIFS,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"rifs_advert", IOV_RIFS_ADVERT,
	(IOVF_OPEN_ALLOW), IOVT_INT32, 0
	},
	{"sgi_rx", IOV_SGI_RX,
	(IOVF_OPEN_ALLOW), IOVT_UINT8, 0
	},
	{"sgi_tx", IOV_SGI_TX,
	(IOVF_OPEN_ALLOW), IOVT_INT8, 0
	},
	{"obss_coex_enab", IOV_OBSS_COEX_ACTIVE,
	(0), IOVT_BOOL, 0
	},
	{"obss_width20", IOV_OBSS_WIDTH20,
	(0), IOVT_BOOL, 0
	},
	{"obss_width20_det", IOV_OBSS_WIDTH20_DET,
	(0), IOVT_BOOL, 0
	},
	{"gf_cap", IOV_GF_CAP,
	(0), IOVT_BOOL, 0
	},
	{"ldpc_cap", IOV_LDPC_CAP,
	(0), IOVT_INT32, 0
	},
#ifdef BCMDBG
	{"ldpc_tx", IOV_LDPC_TX,
	(0), IOVT_INT32, 0
	},
	{"ofdm_txbw", IOV_OFDM_TXBW,
	(0), IOVT_INT32, 0
	},
	{"cck_txbw", IOV_CCK_TXBW,
	(0), IOVT_INT32, 0
	},
	{"ofdm_present", IOV_OFDM_ASSOC,
	(0), IOVT_BOOL, 0
	},
	{"nonerp_present", IOV_NONERP_ASSOC,
	(0), IOVT_BOOL, 0
	},
	{"txburst_limit", IOV_TXBURST_LIM,
	(0), IOVT_INT32, 0
	},
	{"htphy_membership", IOV_HTPHY_MEMBERSHIP,
	(IOVF_SET_DOWN), IOVT_BOOL, 0
	},
#endif /* BCMDBG */
#endif /* WL11N */
//#if	defined(WLTEST)
	{"pkteng", IOV_PKTENG,
	IOVF_SET_UP | IOVF_MFG, IOVT_BUFFER, sizeof(wl_pkteng_t)
	},
	{"pkteng_maxlen", IOV_PKTENG_MAXLEN,
	IOVF_SET_UP | IOVF_MFG, IOVT_UINT32, 0
	},
#if	defined(WLTEST)
	{"boardflags", IOV_BOARDFLAGS,
	(IOVF_SET_DOWN | IOVF_MFG), IOVT_UINT32, 0
	},
	{"boardflags2", IOV_BOARDFLAGS2,
	(IOVF_SET_DOWN | IOVF_MFG), IOVT_UINT32, 0
	},
	{"antgain", IOV_ANTGAIN,
	(IOVF_SET_DOWN | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"nvram_get", IOV_NVRAM_GET,
	(IOVF_MFG), IOVT_BUFFER, WLC_IOCTL_MAXLEN
	},
	{"nvram_dump", IOV_NVRAM_DUMP,
	(IOVF_MFG), IOVT_BUFFER, WLC_IOCTL_MAXLEN
	},
	{"cis_source", IOV_BMAC_CIS_SOURCE,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_INT32, 0
	},
	{"ciswrite", IOV_CISWRITE,
	(IOVF_MFG), IOVT_BUFFER, sizeof(cis_rw_t)
	},
	{"cisdump", IOV_CISDUMP,
	(IOVF_MFG), IOVT_BUFFER, sizeof(cis_rw_t)
	},
	{"devpath", IOV_BMAC_DEVPATH,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
#endif 
	{"lifetime", IOV_LIFETIME,
	(0), IOVT_BUFFER, sizeof(wl_lifetime_t)
	},
#ifdef STA
	{"bcn_timeout", IOV_BCN_TIMEOUT,
	(IOVF_NTRL), IOVT_UINT32, 0
	},
#endif /* STA */
	{"dump", IOV_DUMP,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"country", IOV_COUNTRY,
	(0), IOVT_BUFFER, WLC_CNTRY_BUF_SZ
	},
	{"autocountry_default", IOV_AUTOCOUNTRY_DEFAULT,
	(0), IOVT_BUFFER, 0
	},
#ifdef BCMDBG
	{"country_ie_override", IOV_COUNTRY_IE_OVERRIDE,
	(0), IOVT_BUFFER, 5
	},
#endif /* BCMDBG */
	{"ver", IOV_VER,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, 0
	},
	{"antennas", IOV_ANTENNAS,
	(0), IOVT_UINT8, 0
	},
#ifdef TOE
	{"toe", IOV_TOE,
	(0), IOVT_BOOL, 0
	},
#endif /* TOE */
#ifdef ARPOE
	{"arpoe", IOV_ARPOE,
	(0), IOVT_BOOL, 0
	},
#endif /* ARPOE */
#ifdef PLC
	{"plc", IOV_PLC,
	(0), IOVT_BOOL, 0
	},
#endif /* PLC */
#ifdef STA
	{"scanresults_minrssi", IOV_SCANRESULTS_MINRSSI,
	0, IOVT_INT32, 0
	},
	{"iscan", IOV_ISCAN,
	(0), IOVT_BUFFER, WL_ISCAN_PARAMS_FIXED_SIZE
	},
	{"iscanresults", IOV_ISCANRESULTS,
	(0), IOVT_BUFFER, WL_ISCAN_RESULTS_FIXED_SIZE
	},
#endif /* STA */
#if defined(MACOSX)
	{"sendup_mgmt", IOV_SENDUP_MGMT,
	(0), IOVT_BOOL, 0
	},
#endif
#if defined(WME_PER_AC_TUNING) && defined(WME_PER_AC_TX_PARAMS)
	{"wme_tx_params", IOV_WME_TX_PARAMS,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, WL_WME_TX_PARAMS_IO_BYTES
	},
#endif
	{"ibss_coalesce_allowed", IOV_IBSS_COALESCE_ALLOWED,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
#ifdef STA
	{"pspoll_prd", IOV_PSPOLL_PRD, IOVF_BSSCFG_STA_ONLY, IOVT_UINT8, 0},
	{"bcn_li_bcn", IOV_BCN_LI_BCN, 0, IOVT_UINT8, 0},
	{"bcn_li_dtim", IOV_BCN_LI_DTIM, 0, IOVT_UINT8, 0},
	{"assoc_listen", IOV_ASSOC_LISTEN, 0, IOVT_UINT16, 0},
#endif
	{"msglevel", IOV_MSGLEVEL2, 0, IOVT_BUFFER, sizeof(struct wl_msglevel2)},
#ifdef WL_ASSOC_RECREATE
	{"assoc_recreate", IOV_ASSOC_RECREATE, IOVF_OPEN_ALLOW, IOVT_BOOL, 0},
	{"preserve_assoc", IOV_PRESERVE_ASSOC, IOVF_OPEN_ALLOW, IOVT_BOOL, 0},
	{"assoc_preserved", IOV_ASSOC_PRESERVED, IOVF_OPEN_ALLOW, IOVT_BOOL, 0},
	{"assoc_verify_timeout", IOV_ASSOC_VERIFY_TIMEOUT, IOVF_OPEN_ALLOW, IOVT_UINT32, 0},
	{"recreate_bi_timeout", IOV_RECREATE_BI_TIMEOUT, IOVF_OPEN_ALLOW, IOVT_UINT32, 0},
#endif
#ifdef STA
	{"infra_configuration", IOV_INFRA_CONFIGURATION, IOVF_OPEN_ALLOW, IOVT_UINT32, 0},
#endif /* STA */
	{"down_override", IOV_DOWN_OVERRIDE,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"allmulti", IOV_ALLMULTI,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
	{"legacy_probe", IOV_LEGACY_PROBE,
	(IOVF_OPEN_ALLOW), IOVT_BOOL, 0
	},
#ifdef AP
	{"wowl_pkt", IOV_WOWL_PKT,
	(0), IOVT_BUFFER, 0
	},
#endif /* AP */
	/* roam related params */
#ifdef STA
	{"roam_off", IOV_ROAM_OFF,
	(IOVF_OPEN_ALLOW), IOVT_BOOL,   0
	},
	{"assocroam", IOV_ASSOCROAM,
	(0), IOVT_BOOL, 0
	},
	{"fullroamperiod", IOV_FULLROAM_PERIOD,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"roamperiod", IOV_ROAM_PERIOD,
	(IOVF_OPEN_ALLOW), IOVT_UINT32, 0
	},
	{"txfail_roamthresh", IOV_TXFAIL_ROAMTHRESH,
	0, IOVT_UINT8, 0
	},
	{"txmin_roamthresh", IOV_TXMIN_ROAMTHRESH,
	0, IOVT_UINT8, 0
	},
	{"roam_env_detection", IOV_AP_ENV_DETECT,
	0, IOVT_BOOL, 0
	},
	{"roam_motion_detection", IOV_MOTION_RSSI_DELTA,
	0, IOVT_UINT8, 0
	},
	{"roam_scan_piggyback", IOV_SCAN_PIGGYBACK,
	0, IOVT_BOOL, 0
	},
	{"roam_rssi_cancel_hysteresis", IOV_ROAM_RSSI_CANCEL_HYSTERESIS,
	0, IOVT_UINT8, 0
	},
#endif /* STA */
	{"bandunit", IOV_BANDUNIT,
	(0), IOVT_UINT32, 0
	},
#if defined(DSLCPE_DELAY)
	{"delaymode", IOV_DELAYMODE,
	(0), IOVT_UINT32, 0
	},
#endif
	{"btc_mode", IOV_BTC_MODE,
	0, IOVT_UINT32, 0
	},
	{"btc_stuck_war", IOV_BTC_STUCK_WAR,
	0, IOVT_BOOL, 0
	},
	{"btc_flags", IOV_BTC_FLAGS,
	(IOVF_SET_UP | IOVF_GET_UP), IOVT_BUFFER, 0
	},
	{"btc_params", IOV_BTC_PARAMS,
	(IOVF_SET_UP | IOVF_GET_UP), IOVT_BUFFER, 0
	},
#if defined(RIM) || defined(BCMDBG) || defined(WLNINTENDO2)
	{"rate_histo", IOV_RATE_HISTO,
	(IOVF_GET_UP), IOVT_BUFFER, (WLC_MAXRATE + 1 + WLC_MAXMCS + 1) * sizeof(ratespec_t)
	},
#endif

#ifdef STA
#if defined(WL_PM2_RCV_DUR_LIMIT)
	{"pm2_rcv_dur", IOV_PM2_RCV_DUR,
	(0), IOVT_UINT16, 0
	},
#endif /* WL_PM2_RCV_DUR_LIMIT */

	{"pm2_sleep_ret", IOV_PM2_SLEEP_RET,
	(0), IOVT_INT16, 0
	},

	{"nolinkup", IOV_NOLINKUP,
	(0), IOVT_BOOL, 0
	},
#endif /* STA */


#ifdef BRCMAPIVTW
	{"brcmapivtwo", IOV_BRCMAPIVTW_OVERRIDE, 0, IOVT_INT8, 0},
#endif

#if defined(DELTASTATS)
	{"delta_stats_interval", IOV_DELTA_STATS_INTERVAL,
	(0), IOVT_INT32, 0
	},
	{"delta_stats", IOV_DELTA_STATS,
	(0), IOVT_BUFFER, sizeof(wl_delta_stats_t)
	},
#endif
#if defined(BCMDBG) && defined(MBSS)
	{"srchmem", IOV_SRCHMEM,
	(IOVF_SET_UP | IOVF_GET_UP), IOVT_BUFFER, DOT11_MAX_SSID_LEN + 2 * sizeof(uint32)
	},
#endif	/* BCMDBG && MBSS */
	{"bmac_reboot", IOV_BMAC_REBOOT,
	(IOVF_SET_DOWN), IOVT_VOID, 0
	},
	{"bmac_dngl_suspend_enable", IOV_BMAC_DNGL_SUSPEND_ENABLE,
	(0), IOVT_UINT32, 0
	},
	{"rpc_agg", IOV_RPC_AGG,
	(0), IOVT_UINT32, 0
	},
	{"rpc_msglevel", IOV_RPC_MSGLEVEL,
	(0), IOVT_UINT32, 0
	},
	{"rpc_dngl_txqwm", IOV_RPC_DNGL_TXQ_WM,
	(0), IOVT_UINT32, 0
	},
	{"rpc_dngl_agglimit", IOV_RPC_DNGL_AGG_LIMIT,
	(0), IOVT_UINT32, 0
	},
	{"rpc_host_agglimit", IOV_RPC_HOST_AGG_LIMIT,
	(0), IOVT_UINT32, 0
	},
	{"phy_rssi_ant", IOV_RSSI_ANT,
	(0), IOVT_BUFFER, sizeof(wl_rssi_ant_t)
	},
	{"snr", IOV_SNR,
	(0), IOVT_INT32, 0
	},
	/* BMAC iovars */
#ifdef WLDIAG
	{"diag", IOV_BMAC_DIAG,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
#endif /* WLDIAG */
#ifdef WLLED
	{"gpiotimerval", IOV_BMAC_SBGPIOTIMERVAL,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, sizeof(uint32)
	},
	{"leddc", IOV_BMAC_SBGPIOTIMERVAL,
	(IOVF_BMAC_IOVAR|IOVF_OPEN_ALLOW), IOVT_UINT32, sizeof(uint32)
	},
#endif /* WLLED */
	{"wpsgpio", IOV_BMAC_WPSGPIO,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
	{"wpsled", IOV_BMAC_WPSLED,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
	{"btclock_tune_war", IOV_BMAC_BTCLOCK_TUNE_WAR,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
	{"ccgpioin", IOV_BMAC_CCGPIOIN,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
#if defined(WLTEST)
	{"gpioout", IOV_BMAC_SBGPIOOUT,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"ccgpioctrl", IOV_BMAC_CCGPIOCTRL,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_UINT32, 0
	},
	{"ccgpioout", IOV_BMAC_CCGPIOOUT,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_UINT32, 0
	},
	{"ccgpioouten", IOV_BMAC_CCGPIOOUTEN,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_UINT32, 0
	},
#endif	
#if (defined(BCMNVRAMR) || defined(BCMNVRAMW)) && defined(WLTEST)
	{"otpdump", IOV_BMAC_OTPDUMP,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, WLC_IOCTL_MAXLEN
	},
	{"otpstat", IOV_BMAC_OTPSTAT,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, WLC_IOCTL_MAXLEN
	},
#endif /* (defined(BCMNVRAMR) || defined (BCMNVRAMW)) && (defined(WLTEST) */
	/* || defined (BCMINTERNAL)) */
	{"aspm", IOV_BMAC_PCIEASPM,
	(IOVF_BMAC_IOVAR), IOVT_INT16, 0
	},
	{"correrrmask", IOV_BMAC_PCIEADVCORRMASK,
	(IOVF_BMAC_IOVAR), IOVT_INT16, 0
	},
#ifdef BCMDBG
	{"pcieclkreq", IOV_BMAC_PCIECLKREQ,
	(IOVF_BMAC_IOVAR), IOVT_INT8, 0
	},
	{"pcielcreg", IOV_BMAC_PCIELCREG,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
#endif /* BCMDBG */
	{"pciereg", IOV_BMAC_PCIEREG,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
#ifdef ROUTER_COMA
	{"jtagureg", IOV_BMAC_JTAGUREG,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
	{"coma", IOV_BMAC_COMA,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
#endif
	{"pcieserdesreg", IOV_BMAC_PCIESERDESREG,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
#ifdef BCMDBG
	{"dmalpbk", IOV_BMAC_DMALPBK,
	(IOVF_SET_UP | IOVF_BMAC_IOVAR), IOVT_BOOL, 0
	},
#endif
#if defined(WLTEST)
	{"pllreset", IOV_BMAC_PLLRESET,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
#ifdef BCMNVRAMW
	{"otpw", IOV_BMAC_OTPW,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"nvotpw", IOV_BMAC_NVOTPW,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"cisvar", IOV_BMAC_CISVAR,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"otplock", IOV_BMAC_OTPLOCK,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_INT32, 0
	},
	{"otprawr", IOV_BMAC_OTP_RAW_READ,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_INT32, 0
	},
#endif /* BCMNVRAMW */
#endif 
	{"srom", IOV_BMAC_SROM,
	(IOVF_BMAC_IOVAR), IOVT_BUFFER, 0
	},
#if defined(BCMDBG) || defined(WLTEST)
	{"srcrc", IOV_BMAC_SRCRC,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_BUFFER, 0
	},
	{"nvram_source", IOV_BMAC_NVRAM_SOURCE,
	(IOVF_BMAC_IOVAR | IOVF_MFG), IOVT_UINT8, 0
	},
#endif 
#ifdef RWL_DONGLE
	{"remote", IOV_RWLDONGLE_DATA,
	(0), IOVT_BUFFER, 1040
	},
	{"dongleset", IOV_DONGLE_FLAG,
	0, IOVT_UINT32, 0
	},
#endif /* RWL_DONGLE */
#ifdef WIFI_ACT_FRAME
	{"wifiaction", IOV_ACTION_FRAME,
	(0), IOVT_BUFFER, WL_WIFI_ACTION_FRAME_SIZE
	},
	{"actframe", IOV_AF,
	(0), IOVT_BUFFER, OFFSETOF(wl_af_params_t, action_frame) +
	OFFSETOF(wl_action_frame_t, data)
	},
#endif /* WIFI_ACT_FRAME */
#if defined(STA) && defined(ADV_PS_POLL)
	{"adv_ps_poll", IOV_ADV_PS_POLL,
	(IOVF_BSSCFG_STA_ONLY), IOVT_BOOL, 0
	},
#endif
	{"nav_reset_war_disable", IOV_NAV_RESET_WAR_DISABLE,
	0, IOVT_BOOL, 0
	},
#ifdef BCMDBG
#ifdef WL11N
	{"txmcsset", IOV_TXMCSSET,
	(0), IOVT_BUFFER, 0
	},
	{"rxmcsset", IOV_RXMCSSET,
	(0), IOVT_BUFFER, 0
	},
#endif /* WL11N */
#endif /* BCMDBG */
	{"customvar1", IOV_BMAC_CUSTOMVAR1,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
	{"rfaware_lifetime", IOV_RFAWARE_LIFETIME,
	(0), IOVT_UINT16, 0
	},
	{"rssi_event", IOV_RSSI_EVENT,
	(0), IOVT_BUFFER, sizeof(wl_rssi_event_t)
	},
#ifdef STA
	{"rssi_win", IOV_RSSI_WINDOW_SZ,
	(0), IOVT_UINT16, 0
	},
#endif /* STA */
	{"assert_type", IOV_ASSERT_TYPE,
	(0), IOVT_UINT32, 0,
	},
#ifdef PHYCAL_CACHING
	{"phycal_caching", IOV_PHYCAL_CACHE,
	0, IOVT_BOOL, 0
	},
	{"cachedcal_scan", IOV_CACHE_CHANSWEEP,
	0, IOVT_UINT16, 0
	},
#endif /* PHYCAL_CACHING */
	{"ht_wsec_restrict", IOV_HT_WSEC_RESTRICT,
	(0), IOVT_INT32, 0,
	},
	{"pm2_radio_shutoff_dly", IOV_PM2_RADIO_SHUTOFF_DLY,
	(0), IOVT_UINT16, 0
	},
	{"chanim_enab", IOV_CHANIM_ENAB,
	(0), IOVT_UINT32, 0
	},
#ifdef WLCHANIM
	{"chanim_state", IOV_CHANIM_STATE,
	(0), IOVT_BOOL, 0
	},
	{"chanim_mode", IOV_CHANIM_MODE,
	(0), IOVT_UINT8, 0
	},
	{"chanim_ccathres", IOV_CCASTATS_THRES,
	(0), IOVT_UINT8, 0
	},
	{"chanim_glitchthres", IOV_CRSGLITCH_THRES,
	(0), IOVT_UINT32, 0
	},
	{"chanim_bgnoisethres", IOV_BGNOISE_THRES,
	(0), IOVT_INT8, 0
	},
	{"chanim_sample_period", IOV_SAMPLE_PERIOD,
	(0), IOVT_UINT8, 0
	},
	{"chanim_threshold_time", IOV_THRESHOLD_TIME,
	(0), IOVT_UINT8, 0
	},
	{"chanim_max_acs", IOV_MAX_ACS,
	(0), IOVT_UINT8, 0
	},
	{"chanim_lockout_period", IOV_LOCKOUT_PERIOD,
	(0), IOVT_UINT32, 0
	},
	{"chanim_acs_record", IOV_ACS_RECORD,
	(0), IOVT_BUFFER, sizeof(wl_acs_record_t),
	},
	{"chanim_stats", IOV_CHANIM_STATS,
	(0), IOVT_BUFFER, sizeof(wl_chanim_stats_t),
	},
#endif /* WLCHANIM */
	{"send_frame", IOV_SEND_FRAME,
	(IOVF_SET_UP), IOVT_BUFFER, 0
	},
#ifdef CCA_STATS
	{"cca_get_stats", IOV_CCA_STATS,
	(0), IOVT_BUFFER, sizeof(cca_congest_channel_req_t),
	},
#ifdef ISID_STATS
	{"itfr_get_stats", IOV_ITFR_STATS,
	(0), IOVT_BUFFER, sizeof(interference_source_rep_t),
	},
	{"itfr_enab", IOV_ITFR_ENAB,
	(0), IOVT_UINT32, 0,
	},
	{"itfr_detect", IOV_ITFR_DETECT,
	(0), IOVT_VOID, 0,
	},
	{"itfr_abort", IOV_ITFR_ABORT,
	(0), IOVT_VOID, 0,
	},
	{"itfr_thres", IOV_ITFR_THRES,
	0, IOVT_UINT32, 0
	},
	{"itfr_net_thres", IOV_ITFR_NET_THRES,
	0, IOVT_UINT32, 0
	},
	{"itfr_stop_tm", IOV_ITFR_STOP_TM,
	0, IOVT_UINT32, 0
	},
	{"itfr_id_hold_tm", IOV_ITFR_ID_HOLD_TM,
	0, IOVT_UINT32, 0
	},
	{"itfr_non_id_hold_tm", IOV_ITFR_NON_ID_HOLD_TM,
	0, IOVT_UINT32, 0
	},
	{"itfr_clean_tm", IOV_ITFR_CLEAN_TM,
	0, IOVT_UINT32, 0
	},
#endif /* ISID_STATS */
#endif /* CCA_STATS */
#ifdef SMF_STATS
	{"smfstats", IOV_SMF_STATS,
	(0), IOVT_INT32, 0,
	},
	{"smfstats_enable", IOV_SMF_STATS_ENABLE,
	(0), IOVT_INT32, 0
	},
#endif /* SMF_STATS */
#ifdef BCMWAPI_WAI
	{"wai_restrict", IOV_WAI_RESTRICT,
	(0), IOVT_BOOL, 0
	},
	{"wai_rekey", IOV_WAI_REKEY,
	(0), IOVT_BUFFER, ETHER_ADDR_LEN
	},
#endif /* BCMWAPI_WAI */
#ifdef STA
	{"roam_tbtt", IOV_ROAM_TBTT,
	(0), IOVT_INT32, 0
	},
	{"pm2_refresh_badiv", IOV_PM2_REFRESH_BADIV,
	(IOVF_BSSCFG_STA_ONLY), IOVT_INT16, 0
	},
#endif /* STA */
#if defined(WLTEST)
	{"manfinfo", IOV_MANF_INFO,
	(0), IOVT_BUFFER, WLC_IOCTL_MAXLEN
	},
#endif 
	{"pool", IOV_POOL,
	(0), IOVT_UINT8, 0
	},
	{"cur_rateset", IOV_CURR_RATESET,
	(0), IOVT_BUFFER, sizeof(wl_rateset_args_t)
	},
	{"rateset", IOV_RATESET,
	(IOVF_SET_DOWN), IOVT_BUFFER, sizeof(wl_rateset_args_t)
	},
	{"dcs_req", IOV_BRCM_DCS_REQ,
	(IOVF_SET_UP), IOVT_UINT16, 0
	},
	{"pm_dur", IOV_PM_DUR,
	(0), IOVT_UINT32, 0
	},
	{"auth_ops", IOV_AUTHOPS,
	(IOVF_SET_UP), IOVT_BUFFER, 0
	},
#ifdef WL_DNGL_WD
	{"dngl_wd", IOV_DNGL_WD,
	(IOVF_SET_UP), IOVT_UINT32, 0
	},
#endif /* WL_DNGL_WD */
#if defined(BCMDBG) || defined(WLNINTENDO2)
	{"tsf", IOV_TSF,
	(IOVF_SET_UP | IOVF_GET_UP), IOVT_UINT32, 0
	},
	{"tsf_adj", IOV_TSF_ADJUST,
	(IOVF_SET_UP), IOVT_UINT32, 0
	},
#endif /* BCMDBG */
	{"bsscfg_idx", IOV_WLIF_BSSCFG_IDX,
	(0), IOVT_UINT8, 0
	},
	{"ssid", IOV_SSID,
	(0), IOVT_INT32, 0
	},
#ifdef STA
	{"join", IOV_JOIN, IOVF_BSSCFG_STA_ONLY, IOVT_BUFFER, WL_EXTJOIN_PARAMS_FIXED_SIZE},
#endif
#ifdef MFP_TEST
	{"mfp", IOV_MFP,
	(0), IOVT_INT32, 0
	},
	{"mfp_sha256", IOV_MFP_SHA256,
	(0), IOVT_INT32, 0
	},
	{"mfp_sa_query", IOV_MFP_SA_QUERY,
	(0), IOVT_INT32, 0
	},
	{"mfp_disassoc", IOV_MFP_DISASSOC,
	(0), IOVT_INT32, 0
	},
	{"mfp_deauth", IOV_MFP_DEAUTH,
	(0), IOVT_INT32, 0
	},
	{"mfp_assoc", IOV_MFP_ASSOC,
	(0), IOVT_INT32, 0
	},
	{"mfp_auth", IOV_MFP_AUTH,
	(0), IOVT_INT32, 0
	},
	{"mfp_reassoc", IOV_MFP_REASSOC,
	(0), IOVT_INT32, 0
	},
	{"mfp_bip_test", IOV_MFP_BIP_TEST,
	(0), IOVT_INT32, 0
	},
#endif /* MFP_TEST */
#ifdef WLNINTENDO2
	{"monitor_lq", IOV_LINKQUAL_ONOFF,
	(0), IOVT_UINT32, 0
	},
	{"monitor_lq_status", IOV_GET_LINKQUAL_STATS,
	(0), IOVT_UINT32, sizeof(wl_lq_t),
	},
#ifdef WL_MULTIQUEUE
	{"flush_txfifo", IOV_FLUSH_SELECTED_TX_FIFOS,
	(0), IOVT_UINT32, 0
	},
#endif
#endif /* WLNINTENDO2 */
	{"rpt_hitxrate", IOV_RPT_HITXRATE,
	(0), IOVT_INT32, 0
	},

#ifdef STA
	{"autocountry", IOV_AUTOCOUNTRY,
	(0), IOVT_BOOL, 0
	},
#endif /* STA */
#if defined(WLTEST)
	{"tpc_rpt_override", IOV_TPC_RPT_OVERRIDE,
	(0), IOVT_UINT16, 0
	},
#endif 

#ifdef STA
	{"buf_key_b4_m4", IOV_BUF_KEY_B4_M4,
	(0), IOVT_BOOL, 0
	},
#endif
#ifdef BCMDBG
#ifdef STA
	{"rpmt", IOV_RPMT, IOVF_BSSCFG_STA_ONLY, IOVT_BUFFER, 8},
#endif
#endif /* BCMDBG */
	{"noise_metric", IOV_BMAC_NOISE_METRIC,
	(IOVF_BMAC_IOVAR), IOVT_UINT16, 0
	},
	{"chan_block", IOV_CHAN_BLOCK,
	(0), IOVT_UINT32, 0
	},
	{"avoidance_cnt", IOV_BMAC_AVIODCNT,
	(IOVF_BMAC_IOVAR), IOVT_UINT32, 0
	},
#ifdef BCMDBG
	{"filter_war", IOV_BMAC_FILT_WAR,
	(IOVF_BMAC_IOVAR), IOVT_BOOL, 0
	},
#endif /* BCMDBG */
	{"ie", IOV_IE,
	(IOVF_OPEN_ALLOW), IOVT_BUFFER, (sizeof(int))
	},
	{NULL, 0, 0, 0, 0}
};

static const uint8 WPA_info_element[] = {
	DOT11_MNG_WPA_ID, 0x18,
	0x00, 0x50, 0xf2, 0x01, 0x01, 0x00,
	0x00, 0x50, 0xf2, 0xff,
	0x01, 0x00, 0x00, 0x50, 0xf2, 0xff,
	0x01, 0x00, 0x00, 0x50, 0xf2, 0xff,
	0x00, 0x00
};
#ifdef STA
static const uint8 WPA2_info_element[] = {
	DOT11_MNG_RSN_ID, 0x14, 0x01, 0x00,
	0x00, 0x0F, 0xAC, 0xff,
	0x01, 0x00, 0x00, 0x0F, 0xAC, 0xff,
	0x01, 0x00, 0x00, 0x0F, 0xAC, 0xff,
	0x00, 0x00
};
#endif /* STA */

#ifdef MFP
/* read only data, should be ROMmed */
static const uint8 MFP_robustable_cat[] = {
	0x6f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#define	IS_ROBUSTABLE_CAT(cat) mboolisset(MFP_robustable_cat[(cat)>>3], 1<<((cat)&0x7))
#else
#define	IS_ROBUSTABLE_CAT(cat) FALSE
#endif /* MFP */

const uint8 prio2fifo[NUMPRIO] = {
	TX_AC_BE_FIFO,	/* 0	BE	AC_BE	Best Effort */
	TX_AC_BK_FIFO,	/* 1	BK	AC_BK	Background */
	TX_AC_BK_FIFO,	/* 2	--	AC_BK	Background */
	TX_AC_BE_FIFO,	/* 3	EE	AC_BE	Best Effort */
	TX_AC_VI_FIFO,	/* 4	CL	AC_VI	Video */
	TX_AC_VI_FIFO,	/* 5	VI	AC_VI	Video */
	TX_AC_VO_FIFO,	/* 6	VO	AC_VO	Voice */
	TX_AC_VO_FIFO	/* 7	NC	AC_VO	Voice */
};

/* precedences numbers for wlc queues. These are twice as may levels as
 * 802.1D priorities.
 * Odd numbers are used for HI priority traffic at same precedence levels
 * These constants are used ONLY by wlc_prio2prec_map.  Do not use them elsewhere.
 */
#define	_WLC_PREC_NONE		0	/* None = - */
#define	_WLC_PREC_BK		2	/* BK - Background */
#define	_WLC_PREC_BE		4	/* BE - Best-effort */
#define	_WLC_PREC_EE		6	/* EE - Excellent-effort */
#define	_WLC_PREC_CL		8	/* CL - Controlled Load */
#define	_WLC_PREC_VI		10	/* Vi - Video */
#define	_WLC_PREC_VO		12	/* Vo - Voice */
#define	_WLC_PREC_NC		14	/* NC - Network Control */

/* 802.1D Priority to precedence queue mapping */
const uint8 wlc_prio2prec_map[] = {
	_WLC_PREC_BE,		/* 0 BE - Best-effort */
	_WLC_PREC_BK,		/* 1 BK - Background */
	_WLC_PREC_NONE,		/* 2 None = - */
	_WLC_PREC_EE,		/* 3 EE - Excellent-effort */
	_WLC_PREC_CL,		/* 4 CL - Controlled Load */
	_WLC_PREC_VI,		/* 5 Vi - Video */
	_WLC_PREC_VO,		/* 6 Vo - Voice */
	_WLC_PREC_NC,		/* 7 NC - Network Control */
};

/* Sanity check for tx_prec_map and fifo synchup
 * Either there are some packets pending for the fifo, else if fifo is empty then
 * all the corresponding precmap bits should be set
 */
#define WLC_TX_FIFO_CHECK(wlc, fifo) (TXPKTPENDGET((wlc), (fifo)) ||	\
	(TXPKTPENDGET((wlc), (fifo)) == 0 && \
	((wlc)->tx_prec_map & (wlc)->fifo2prec_map[(fifo)]) == \
	(wlc)->fifo2prec_map[(fifo)]) || \
	(PIO_ENAB((wlc->pub)) && (wlc->tx_suspended || \
		 !wlc_pio_txavailable((wlc)->hw->pio[fifo], 1, 1))))

/* TX FIFO number to WME/802.1E Access Category */
const uint8 wme_fifo2ac[] = { AC_BK, AC_BE, AC_VI, AC_VO, AC_BE, AC_BE };

/* WME/802.1E Access Category to TX FIFO number */
static const uint8 wme_ac2fifo[] = { 1, 0, 2, 3 };

static bool in_send_q = FALSE;

/* Shared memory location index for various AC params */
#define wme_shmemacindex(ac)	wme_ac2fifo[ac]

#ifdef BCMDBG_ERR
static const char *fifo_names[] = { "AC_BK", "AC_BE", "AC_VI", "AC_VO", "BCMC", "ATIM" };
#endif

#if defined(BCMDBG) || defined(WLMSG_INFORM) || defined(BCMDBG_DUMP)
const char *aci_names[] = { "AC_BE", "AC_BK", "AC_VI", "AC_VO"};
#endif

#if defined(WLTEST)
#define MANF_INFO_LEN			8
#define MANF_INFO_ROW_WIDTH		64
struct wlc_otp_manf_info {
	const char *name;	/* name for the segment */
	uint16	bit_pos_start;	/* start position for the segment */
	uint16	bit_pos_end;	/* end position for the segment */
	uint16	len;		/* length of the segment */
};

/* MFG OTP info twiki: Mwgroup/OtpProgramming#ATE_test_flow */
static const struct wlc_otp_manf_info wlc_manf_info[] = {
	/* row0: wafer sort data */
	{"OTP_LOT_NUM", 0, 16, 17},
	{"WAFER_NUM", 17, 21, 5},
	{"WAFER_X", 22, 30, 9},
	{"WAFER_Y", 31, 39, 9},
	{"PROG_REL_DATE", 40, 55, 16},
	{"PROG_REV_CRTL_0", 56, 60, 5},
	{"MEM_REP_0", 61, 61, 1},
	{"PROBED_BIN1", 62, 62, 1},
	{"LOCK_BIT_0", 63, 63, 1},

	/* row1: final(packaging) test data */
	{"FT1_PROG_REL", 0, 15, 16},
	{"FT2_PROG_REL", 16, 31, 16},
	{"FT_PROG_RESCRN", 32, 47, 16},
	{"PROG_REV_CTRL_1", 48, 52, 5},
	{"MEM_REP_1", 53, 53, 1},
	{"ANALOG_TRIM", 54, 54, 1},
	{"SCREEN_BIT", 55, 59, 5},
	{"QA_SAMP_TEST", 60, 61, 2},
	{"FT_BIN1", 62, 62, 1},
	{"LOCK_BIT_1", 63, 63, 1},

	{NULL, 0, 0, 0},
	};

#endif 
static void wlc_rssi_event_timeout(void *arg);


/* currently the best mechanism for determining SIFS is the band in use */
#define SIFS(band) ((band)->bandtype == WLC_BAND_5G ? APHY_SIFS_TIME : BPHY_SIFS_TIME);

/* conversion between auth values set externally and 802.11 auth type values */
#define DOT11AUTH2WLAUTH(bsscfg) (bsscfg->openshared ? WL_AUTH_OPEN_SHARED :\
	(bsscfg->auth == DOT11_OPEN_SYSTEM ? WL_AUTH_OPEN_SYSTEM : WL_AUTH_SHARED_KEY))
#define WLAUTH2DOT11AUTH(val) (val == WL_AUTH_OPEN_SYSTEM ? DOT11_OPEN_SYSTEM : DOT11_SHARED_KEY)

/* local prototypes */
static void wlc_txc_iv_update(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct scb *scb, wsec_key_t *key,
	void *sdu, uint pktlen, txc_t *txc);
static void wlc_monitor(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, void *p, struct wlc_if *wlcif);
static void wlc_bss_default_init(wlc_info_t *wlc);

#ifdef WME
static int wlc_wme_downgrade_fifo(wlc_info_t *wlc, uint* p_fifo, struct scb *scb);
#endif /* WME */
static void wlc_ucode_mac_upd(wlc_info_t *wlc);

static int  wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks);
#if defined(MACOSX)
static int  wlc_xmtfifo_sz_set(wlc_info_t *wlc, uint fifo, uint16 blocks);
#endif
static void wlc_xmtfifo_sz_upd_high(wlc_info_t *wlc, uint fifo, uint16 blocks);

static void wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec);
static uint wlc_txq_txpktcnt(void *ctx);

static const txmod_fns_t txq_txmod_fns = {
	wlc_txq_enq,
	wlc_txq_txpktcnt,
	NULL,
	NULL
};

static void wlc_tx_prec_map_init(wlc_info_t *wlc);
#ifdef WLAFTERBURNER
static void wlc_afterburner_nack(wlc_info_t *wlc, uint queue, tx_status_t *txs);
static bool wlc_abcap(wlc_info_t *wlc);
#endif /* WLAFTERBURNER */
static void wlc_frameburst_size(wlc_info_t *wlc, bool aburn);
static char *wlc_cap(wlc_info_t *wlc, char *buf, uint bufsize);

static void wlc_watchdog(void *arg);
static void wlc_watchdog_timer(void *arg);
static int wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg);
static int wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val, const bcm_iovar_t *vi);
static int wlc_iovar_check(wlc_info_t *wlc, const bcm_iovar_t *vi, void *arg, int len, bool set,
	wlc_if_t *wlcif);
uint8 wlc_local_constraint_qdbm(wlc_info_t *wlc);
#ifndef WLLMAC_ONLY
#if defined(BCMDBG_DUMP)
static int wlc_dump_shmem(wlc_info_t *wlc, struct bcmstrbuf *b);
#endif
#if defined(BCMDBG) || defined(BCMDBG_DUMP)
static int wlc_dump_bcntpls(wlc_info_t *wlc, struct bcmstrbuf *b);
#endif
#if defined(BCMDBG_DUMP)
static int wlc_tsf_dump(wlc_info_t *wlc, struct bcmstrbuf *b);
#endif
#endif /* WLLMAC_ONLY */
#if defined(BCMDBG) || defined(WLNINTENDO2)
static void wlc_tsf_set(wlc_info_t *wlc, uint32 tsf_l, uint32 tsf_h);
#endif

#ifdef WLCNT
static void wlc_ctrupd_cache(uint16 cur_stat, uint16 *macstat_snapshot, uint32 *macstat);
#endif

#ifdef WLCHANIM
static void wlc_chanim_update(wlc_info_t *wlc, chanspec_t chanspec, uint32 flags);
static void wlc_chanim_init(chanim_info_t *c_info);
static void wlc_chanim_acc_reset(wlc_info_t *wlc);
static wlc_chanim_stats_t *chanim_chanspec_to_stats(chanim_info_t *c_info, chanspec_t chanspec);
static int chanim_get_acs_record(chanim_info_t *c_info, int buf_len, void *output);
static int chanim_get_stats(chanim_info_t *c_info, wl_chanim_stats_t* iob, int *len, int count);
#endif /* WLCHANIM */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST)
#ifndef WLLMAC_ONLY
static int wlc_dump_list(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_rssi(wlc_info_t *wlc, struct bcmstrbuf *b);
#endif /* WLLMAC_ONLY */
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) || defined(WLNINTENDO2)
#ifndef WLLMAC_ONLY
static char* wlc_dump_next_name(char **buf);
static int wlc_dump_registered_name(wlc_info_t *wlc, char *name, struct bcmstrbuf *b);
int wlc_iovar_dump(wlc_info_t *wlc, const char *params, int p_len, char *out_buf, int out_len);
#endif /* WLLMAC_ONLY */

#ifdef WLTINYDUMP
static int wlc_tinydump(wlc_info_t *wlc, struct bcmstrbuf *b);
#endif /* WLTINYDUMP */
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) || defined (WLNINTENDO2) */

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
static int wlc_dump_default(wlc_info_t *wlc, struct bcmstrbuf *b);
#ifndef WLLMAC_ONLY
static int wlc_bsscfg_dump(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_bssinfo_dump(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_bsscfg(wlc_info_t *wlc, wlc_bsscfg_t *cfg, int bsscfg_idx, struct bcmstrbuf *b);
static int wlc_dump_wlc(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_ratestuff(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_mac(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_pio(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_dma(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_wme(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_stats(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_btc(wlc_info_t *wlc, struct bcmstrbuf *b);
static int wlc_dump_bss_info(const char *name, wlc_bss_info_t *bi, struct bcmstrbuf *b);
#endif /* WLLMAC_ONLY */
#endif /* BCMDBG || BCMDBG_DUMP */

#ifdef BCMDBG
static void wlc_print_measure_req_rep(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8
	*body, int body_len);
/* static void wlc_dump_ucode_fatal(wlc_info_t *wlc); */
#endif

#if defined(BCMDBG) || defined(BCMDBG_ERR)
static void wlc_print_event(wlc_info_t* wlc, wlc_event_t *e);
#endif

static void _wlc_event_if(wlc_info_t *wlc, wlc_event_t *e,
	wlc_bsscfg_t *src_bsscfg, wlc_if_t *src_wlfif, wlc_if_t *dst_wlcif);

#if defined(BCMDBG) || defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || \
	defined(WLMSG_ASSOC)
static void wlc_print_dot11hdr(uint8 *buf, int len);
#endif

#ifdef MCAST_REGEN
int wlc_mcast_reverse_translation(struct ether_header *eh);
#endif

#ifdef CCA_STATS
static void cca_stats_tsf_upd(wlc_info_t *wlc);
#endif

/* send and receive */
static void wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, int prio);
static void wlc_txflowcontrol_reset(wlc_info_t *wlc);
static txc_t * wlc_txc_hit(wlc_info_t *wlc, struct scb *scb, void *sdu, uint pktlen, uint fifo,
	uint8 prio);
static void wlc_txfast(wlc_info_t *wlc, struct scb *scb, void *sdu, uint pktlen, txc_t *txc);
static void* wlc_allocfrag(osl_t *osh, void *sdu, uint offset, uint headroom, uint frag_length,
	uint tailroom);
static void wlc_dofrag(wlc_info_t *wlc, void *p, uint frag, uint nfrags, uint next_payload_len,
	struct scb *scb, bool is8021x,
	uint fifo, wsec_key_t *key, uint8 prio, uint frag_length);
static struct dot11_header *wlc_80211hdr(wlc_info_t *wlc, void *p,
	struct scb *scb, bool MoreFrag, wsec_key_t *key, uint8 prio, uint16 *pushlen);
static void wlc_pdu_push_txparams(wlc_info_t *wlc, void *p,
	uint32 flags, wsec_key_t *key, ratespec_t rate_override, uint fifo);
static void wlc_pdu_txhdr(wlc_info_t *wlc, void *p, struct scb *scb);

static bool sstlookup(wlc_info_t *wlc, uint16 proto);

static uint16 wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec, uint length);
static void wlc_compute_cck_plcp(ratespec_t rate, uint length, uint8 *plcp);
static void wlc_compute_ofdm_plcp(ratespec_t rate, uint length, uint8 *plcp);
static void wlc_compute_mimo_plcp(ratespec_t rate, uint length, uint8 *plcp);
static uint16 wlc_d11hdrs(wlc_info_t *wlc, void *p, struct scb *scb, bool short_preamble,
	uint frag, uint nfrags, uint queue, uint next_frag_len, wsec_key_t *key,
	ratespec_t rspec_override);
static uint16 wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type,
	uint next_frag_len);

static uint16 wlc_recvfilter(wlc_info_t *wlc, struct dot11_header *h, wlc_d11rxhdr_t *wrxh,
	struct scb **pscb, int body_len);
static bool wlc_bsscfg_mcastfilter(wlc_bsscfg_t *cfg, struct dot11_header *h);
static void wlc_recvctl(wlc_info_t *wlc, osl_t *osh, wlc_d11rxhdr_t *wrxh, void *p);
static uint16 wlc_recv_mgmt_rx_channel_get(wlc_d11rxhdr_t *wrxh);
static void wlc_recv_mgmtact(wlc_info_t *wlc, struct scb *scb, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh, uint8 *plcp);
static void wlc_recv_process_beacon(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, wlc_d11rxhdr_t *wrxh,
	uint8 *plcp, struct dot11_management_header *hdr, uint8 *body, int body_len);
static int wlc_find_nominal_req_pwr(ratespec_t rspec);
static void wlc_frameaction_public(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh);
static void wlc_frameaction_vs(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
static bool wlc_is_vsaction(uint8 *hdr, int len);
static void wlc_recv_frameaction_specmgmt(uint action_id, wlc_info_t *wlc,
	struct dot11_management_header *hdr, uint8 *body, int body_len, int8 rssi,
	ratespec_t rspec);
static void wlc_recv_tpc_request(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len, int8 rssi, ratespec_t rspec);
static void wlc_recv_tpc_report(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len, int8 rssi, ratespec_t rspec);
static void wlc_recv_measure_request(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
static void wlc_recv_measure_report(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
static void wlc_recv_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
static void wlc_recv_ext_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
#ifdef WL11N
static void wlc_recv_public_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len);
#endif

static void wlc_send_tpc_report(wlc_info_t *wlc, struct ether_addr *da, struct ether_addr *bssid,
	uint8 token, int8 rssi, ratespec_t rspec);
static void wlc_send_measure_request(wlc_info_t *wlc, struct ether_addr *da, uint8 measure_type);
static void wlc_send_measure_report(wlc_info_t *wlc, struct ether_addr *da,
	struct ether_addr *bssid, uint8 token, uint8 *report, uint report_len);


static void wlc_appendfrag(wlc_info_t *wlc, void *fragbuf, uint *fragresid, uchar *body,
	uint body_len, void* osh);
static int wlc_validate_mac(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct ether_addr *addr);

static uint wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type, uint dur);
static uint wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type);
static uint wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type);

static void wlc_bcn_prb_template(wlc_info_t *wlc, uint type, ratespec_t bcn_rate, wlc_bsscfg_t *cfg,
	uint16 *buf, int *len);
#ifdef MBSS
static void wlc_mbss_ssid_len_set(wlc_info_t *wlc, int idx, uint8 in_val);
#endif
static uint8* wlc_write_country_ie(wlc_info_t *wlc, uint8 *cp, int buflen);
static uint16 wlc_create_tim(wlc_info_t *wlc, uchar *tim, int timlen, uint bss_idx);

#ifdef WLCQ
static int wlc_lq_channel_qa_start(wlc_info_t *wlc);
static int wlc_lq_channel_qa_eval(wlc_info_t *wlc);
static void wlc_lq_channel_qa_sample_cb(wlc_info_t *wlc, uint8 channel, int8 noise_dbm);
#endif /* WLCQ */

/* interrupt, up/down, band */
static void wlc_setband(wlc_info_t *wlc, uint bandunit);
static chanspec_t wlc_init_chanspec(wlc_info_t *wlc);
static void wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec);
static void wlc_bsinit(wlc_info_t *wlc);

static void wlc_radio_hwdisable_upd(wlc_info_t* wlc);
static bool wlc_radio_monitor_start(wlc_info_t *wlc);
static void wlc_radio_timer(void *arg);
static void wlc_radio_enable(wlc_info_t *wlc);
static bool wlc_mpccap(wlc_info_t* wlc);

#ifdef WLNINTENDO2
static bool wlc_lq_stats_on(wlc_info_t *wlc);
static bool wlc_lq_stats_off(wlc_info_t *wlc);
void wlc_rcvlog(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, void *p, int len);
void wlc_get_lq_stats(wlc_info_t *wlc, wl_lq_t *xs);
void wlc_clear_lq_stats(wlc_info_t *wlc);
#endif

static uint8 wlc_get_antennas(wlc_info_t *wlc);

/* scan, association, BSS */
static void wlc_recv_scan_parse(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, uint8 *plcp,
	struct dot11_management_header *hdr, uint8 *body, int body_len);

static wlc_bss_info_t *wlc_BSSadd(wlc_info_t *wlc);
static wlc_bss_info_t *wlc_BSSlookup(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec,
	uchar ssid[], uint ssid_len);

static ht_cap_ie_t *wlc_read_brcm_ht_cap_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len);
static ht_add_ie_t *wlc_read_brcm_ht_add_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len);

#ifdef WL11N
#ifdef NOT_YET
static void wlc_send_action_ht_chan_width(wlc_info_t *wlc, bool chan_width);
#endif
static void wlc_frameaction_ht(wlc_info_t *wlc, uint action_id, struct scb *scb,
	struct dot11_management_header *hdr, uint8 *body, int body_len);
static void wlc_ht_publicaction(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh);
static int wlc_ht_send_action_obss_coex(wlc_info_t *wlc, uint8 coex_bits,
	uint8 *coex_map, struct scb *scb);

static uint wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type);
static void wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap);

static void wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val);
static void wlc_protection_n_nongf_sync(wlc_bsscfg_t *cfg);

static void wlc_mimops_action_ht_complete(wlc_info_t *wlc, uint txstatus, void *arg);
static void wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val);
#endif /* WL11N */


#if defined(BCMDBG) || defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC)
static void wlc_print_bcn_prb(uint8 *frame, int len);
#endif

static int wlc_bss2wl_bss(wlc_info_t *wlc, wlc_bss_info_t *bi, wl_bss_info_t *to_bi, int to_bi_len,
                          bool need_ies);

static int wlc_wpa_cap(wlc_info_t *wlc, wlc_bsscfg_t *cfg, uint8 *cap, int len);

static void wlc_war16165(wlc_info_t *wlc, bool tx);
static void wlc_nav_reset_war(wlc_info_t *wlc, bool enable);

static uint8 wlc_bss_scb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg,
	bool (*scb_test_cb)(struct scb *scb));

static void wlc_btc_rssi_threshold_get(wlc_info_t *wlc);
static uint wlc_btc_frag_threshold(wlc_info_t *wlc, struct scb *scb);
static void wlc_btc_stuck_war50943(wlc_info_t *wlc, bool enable);

#if ((defined(BCMDBG) || defined(WLMSG_PRPKT)) && defined(STA)) || ((defined(BCMDBG) || \
	defined(BCMDBG_DUMP)) && !defined(WLLMAC_ONLY))
static const char* wlc_lookup_name(const wlc_id_name_table_t tbl, int id);
#endif

/* ** STA-only routines ** */
#ifdef STA

static int wlc_is_4way_msg(wlc_info_t *wlc, void *pkt, int offset, wpa_msg_t msg);

/* regular scan */
static int wlc_BSSignorelookup(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec,
                               uchar ssid[], uint ssid_len, bool add);
static bool wlc_BSSignore(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec,
                          uchar ssid[], uint ssid_len);

/* power save and tbtt sync */
static void wlc_recv_PSpoll_resp(wlc_bsscfg_t *cfg, uint16 fc);
static void wlc_tbtt_adopt(wlc_bsscfg_t *cfg, struct dot11_bcn_prb *bcn);
static uint32 wlc_tbtt_calc(wlc_info_t *wlc, bool short_preamble, ratespec_t rspec,
	struct dot11_bcn_prb *bcn, bool adopt);
static void wlc_sendpspoll_complete(wlc_info_t *wlc, void *pkt, uint txstatus);

static void wlc_radio_shutoff_dly_timer_upd(wlc_info_t *wlc);

static void wlc_pm2_radio_shutoff_dly_timer(void *arg);

static void wlc_bss_pm_pending_upd(wlc_bsscfg_t *cfg, uint txstatus);

static const uint8 acbitmap2maxprio[] = {
	PRIO_8021D_BE, PRIO_8021D_BE, PRIO_8021D_BK, PRIO_8021D_BK,
	PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI, PRIO_8021D_VI,
	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO,
	PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO, PRIO_8021D_VO
};

static void wlc_iscan_timeout(void *arg);

/* PM2 tick timer functions.
 * Some are inline because they are used in the time-critical tx path
 */
static void wlc_pm2_sleep_ret_timeout_cb(void *arg);
static void wlc_pm2_sleep_ret_timeout(wlc_bsscfg_t *cfg);

#if defined(WL_PM2_RCV_DUR_LIMIT)
static void wlc_pm2_rcv_timeout_cb(void *arg);
static void wlc_pm2_rcv_timeout(wlc_bsscfg_t *cfg);
#endif /* WL_PM2_RCV_DUR_LIMIT */


/* PM2 Fast Return to Sleep */
static void wlc_pm2_enter_ps(wlc_bsscfg_t *cfg);

/* PM2 Receive Throttle Duty Cycle */
#if defined(WL_PM2_RCV_DUR_LIMIT)
static void wlc_pm2_rcv_timer_start(wlc_bsscfg_t *cfg);
static void wlc_pm2_rcv_timer_stop(wlc_bsscfg_t *cfg);
#else
#define wlc_pm2_rcv_timer_stop(cfg)
#define wlc_pm2_rcv_timer_start(cfg)
#endif /* WL_PM2_RCV_DUR_LIMIT */
static int wlc_set_pm_mode(wlc_info_t *wlc, int val, wlc_bsscfg_t *bsscfg);
static void wlc_btc_pm_adjust(wlc_info_t *wlc,  bool bt_active);

static void _wlc_set_wake_ctrl(wlc_info_t *wlc);

static void wlc_rateprobe_complete(wlc_info_t *wlc, void *pkt, uint txs);
static void wlc_rateprobe_scan(wlc_bsscfg_t *cfg);
static void wlc_tkip_countermeasures(wlc_info_t *wlc, void *pkt, uint txs);
static void wlc_csa_channel_switch(wlc_info_t *wlc, wlc_bsscfg_t *cfg);
static void wlc_11h_pwr(wlc_info_t *wlc, dot11_power_cnst_t *local_pwr);
static void wlc_11h_quiet(wlc_info_t *wlc, dot11_quiet_t *tag, struct dot11_bcn_prb *bcn);
static void wlc_start_quiet0(wlc_info_t *wlc);
static void wlc_start_quiet1(wlc_info_t *wlc);
/* static void wlc_start_quiet2(wlc_info_t *wlc); */
static void wlc_start_quiet3(wlc_info_t *wlc);
static void wlc_quiet_timer(void *arg);

static void wlc_freqtrack(wlc_info_t *wlc);
static void wlc_freqtrack_verify(wlc_info_t *wlc);

static uint8 wlc_bss_wdsscb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg);

#ifdef BCMDBG
static void wlc_11h_ibss(wlc_info_t *wlc, dot11_ibss_dfs_t *tag);
static void wlc_tpc_report(wlc_info_t *wlc, dot11_tpc_rep_t *ie);
#endif
#if defined(BCMDBG) || defined(WLMSG_PRPKT)
static void wlc_print_assoc(wlc_info_t *wlc, struct dot11_management_header *mng, int len);
#endif
static void wlc_parse_11h(wlc_info_t *wlc, uint8 *params, int len, struct dot11_bcn_prb *bcn);
static bool wlc_parse_csa_ie(wlc_bsscfg_t *cfg, uint8 *params, int len);
#ifdef WL11H
static uint8 *wlc_write_sup_chan_ie(wlc_info_t* wlc, uint8 *cp);
#endif /* WL11H */
static void *wlc_frame_get_ps_ctl(wlc_info_t *wlc, const struct ether_addr *bssid,
	const struct ether_addr *da);

static int wlc_assoc_chanspec_sanitize(wlc_info_t *wlc,
	chanspec_t *chanspec_list, int chanspec_num);

#ifdef PHYCAL_CACHING
static int wlc_cache_cals(wlc_info_t *wlc);
static int wlc_cachedcal_sweep(wlc_info_t *wlc);
static int wlc_cachedcal_tune(wlc_info_t *wlc, uint16 chanspec);
#endif /* PHYCAL_CACHING */

#endif	/* STA */

static uint8 * wlc_write_wpa_ie_safe(wlc_info_t *wlc,
	uint8 *cp, int buflen, uint16 WPA_auth,
	uint32 wsec, wlc_bsscfg_t *bsscfg,
	wlc_bss_info_t *current_bss);
static uint8 * wlc_write_rsn_ie_safe(wlc_info_t *wlc,
                                     uint8 *cp, int buflen, uint16 WPA_auth,
                                     uint32 wsec, wlc_bsscfg_t *bsscfg);

static void wlc_process_eventq(void *arg);


static void wlc_update_txpktsuccess_stats(wlc_info_t *wlc, struct scb *scb, uint pkt_len,
	uint8 prio);
static void wlc_update_txpktfail_stats(wlc_info_t *wlc, uint pkt_len, uint8 prio);


static void wlc_wme_retries_write(wlc_info_t *wlc);

static void wlc_get_rate_histo_bsscfg(wlc_bsscfg_t *bsscfg, ratespec_t hw_rates[],
      ratespec_t hw_mcs[], ratespec_t *most_used_ratespec, ratespec_t *highest_used_ratespec);

#ifdef WL11N
#ifdef STA
static void wlc_ht_obss_scan_timer(wlc_info_t *wlc);
#endif /* STA */
static void wlc_ht_obss_coex_watchdog(wlc_info_t *wlc);
static void wlc_ht_chanlist_2g_init(wlc_info_t *wlc);
static void wlc_ht_obss_scanparam_init(obss_params_t * params);
static void wlc_ht_coex_trigger_chk(wlc_info_t *wlc, struct scb *scb);
static void wlc_ht_update_coex_support(wlc_info_t *wlc, int8 setting);
static int wlc_ht_upd_coex_bits(wlc_info_t *wlc, uint8 bits, uint8 mask);
static uint8 wlc_ht_coex_ie_chk(wlc_info_t *wlc, bcm_tlv_t *tlv);
static bool wlc_ht_obss_scanparams_upd(wlc_info_t *wlc, obss_params_t *obss_param,
	wlc_bsscfg_t * bsscfg);
#else
#define wlc_ht_obss_scanparam_init(a)	do {} while (0)
#define wlc_ht_update_coex_support(a, b)	do {} while (0)
#endif /* WL11N */

static chanspec_t wlc_ht_chanspec(wlc_info_t *wlc, uint8 chan, uint8 extch);

#if defined(DELTASTATS)
static void wlc_delta_stats_update(wlc_info_t *wlc);
static int wlc_get_delta_stats(wlc_info_t *wlc, wl_delta_stats_t *stats);
#endif

#ifdef WIFI_ACT_FRAME
static void *wlc_prepare_action_frame(wlc_info_t *wlc, wlc_bsscfg_t *cfg,
	const struct ether_addr *bssid, void *action_frame);
static void wlc_actionframetx_complete(wlc_info_t *wlc, void *pkt, uint txstatus);
#endif

static bool wlc_attach_stf_ant_init(wlc_info_t *wlc);
static uint wlc_attach_module(wlc_info_t *wlc);

static void wlc_detach_module(wlc_info_t *wlc);
static void wlc_timers_deinit(wlc_info_t *wlc);

static void wlc_down_led_upd(wlc_info_t *wlc);
static uint wlc_down_del_timer(wlc_info_t *wlc);

#ifdef BCMDBG
#ifdef WL11N
static void wlc_get_mcsset(wlc_info_t *wlc, void *arg, bool istx);
#endif /* WL11N */
#endif /* BCMDBG */

static void wlc_rssi_ant_get(wlc_info_t *wlc, int8 *rssi);

static void wlc_ofdm_rateset_war(wlc_info_t *wlc);
static int _wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif);

#ifdef BCMWAPI_WAI
static void wlc_wai_rekey(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct ether_addr *addr);
#endif

#if defined(BCM_DCS) && defined(STA)
static int wlc_send_action_brcm_dcs(wlc_info_t *wlc, wl_bcmdcs_data_t *data, struct scb *scb);
#endif


#ifdef WL11K
static uint8* wlc_write_brcm_tpc_ie(wlc_info_t *wlc, uint8 *cp, int buflen);
#endif

#ifdef MFP_TEST
void *wlc_bypass_send_action_sa_query(wlc_info_t *wlc, struct scb *scb,
	uint8 action, uint16 id);
void *
wlc_send_disassoc_deauth(wlc_info_t *wlc, const struct ether_addr *da,
	const struct ether_addr *bssid, const struct ether_addr *sa,
	struct scb *scb,  uint16 fc, uint16 reason_code, int flag);
static void
wlc_disassociate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag, int flag2);
static void
wlc_deauth_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag, int flag2);
static void
wlc_associate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag);
static void
wlc_auth_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag);
static void
wlc_reassociate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag);
#endif /* MFP_TEST */

/* local functions for multiplexed hw gptimer use */
#ifdef BCMDBG
static void wlc_hwtimer_print_timers(wlc_hwtimer_info_t *hwtmr);
#endif
static void wlc_hwtimer_run_timeouts(wlc_hwtimer_info_t *hwtmr);
static uint wlc_hwtimer_gptimer_gettime(void *arg);
static void wlc_hwtimer_gptimer_set_timeout(void *arg, uint timeout);
static void wlc_hwtimer_gptimer_ack(void *arg);

static void wlc_convert_restricted_chanspec(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
	wlc_d11rxhdr_t *wrxh, struct dot11_management_header *hdr, uint8 *body, int bcn_len);

static void wlc_pkt_type_cb(void *ctx, void *pkt, uint txs);
static void wlc_pkt_free_cb(void *ctx, void *pkt, uint txs);

static void wlc_read_rt_dirmap(wlc_info_t *wlc);

#if defined(BCMDBG_MEM) && defined(BCMDBG)
static int
wlc_malloc_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	MALLOC_DUMP(wlc->osh, b);

	return 0;
}
#endif /* defined(BCMDBG_MEM) && defined(BCMDBG) */

#if defined(WLTEST) || defined(BCMDBG_DUMP)
static int
wlc_nvram_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	char *nvram_vars;
	char *q = NULL;
	int err;

	/* per-device vars first, if any */
	if (wlc->pub->vars) {
		q = wlc->pub->vars;
		/* loop to copy vars which contain null separated strings */
		while (*q != '\0') {
			bcm_bprintf(b, "%s\n", q);
			q += strlen(q) + 1;
		}
	}

	/* followed by global nvram vars second, if any */
	if ((nvram_vars = MALLOC(wlc->osh, MAXSZ_NVRAM_VARS)) == NULL) {
		err = BCME_NOMEM;
		goto exit;
	}
	if ((err = nvram_getall(nvram_vars, MAXSZ_NVRAM_VARS)) != BCME_OK)
		goto exit;
	if (nvram_vars[0]) {
		q = nvram_vars;
		/* loop to copy vars which contain null separated strings */
		while (*q != '\0') {
			bcm_bprintf(b, "%s\n", q);
			q += strlen(q) + 1;
		}
	}

	/* check empty nvram */
	if (q == NULL)
		err = BCME_NOTFOUND;
exit:
	if (nvram_vars)
		MFREE(wlc->osh, nvram_vars, MAXSZ_NVRAM_VARS);

	return err;
}
#endif	

#ifndef WLLMAC_ONLY
#if defined(BCMDBG_DUMP)
static void
wlc_dump_pm(wlc_info_t *wlc, struct bcmstrbuf *b)
{
#ifdef STA
	int idx;
	wlc_bsscfg_t *cfg;
	bcm_bprintf(b, "STAY_AWAKE() %d "
	            "SCAN_IN_PROGRESS() %d WLC_RM_IN_PROGRESS() %d AS_IN_PROGRESS() %d "
	            "wlc->wake %d wlc->PMpending %d wlc->PSpoll %d wlc->apsd_sta_usp %d\n",
	            STAY_AWAKE(wlc),
	            SCAN_IN_PROGRESS(wlc->scan), WLC_RM_IN_PROGRESS(wlc), AS_IN_PROGRESS(wlc),
	            wlc->wake, wlc->PMpending, wlc->PSpoll, wlc->apsd_sta_usp);
#ifdef WLC_LOW
	bcm_bprintf(b, "wlc->hw->forcefastclk %d wlc->hw->wake_override 0x%x\n",
	            wlc->hw->forcefastclk, wlc->hw->wake_override);
#endif
	bcm_bprintf(b, "wlc->PMawakebcn %d wlc->PMblocked %d wlc->txpend16165war %d "
	            "wlc->check_for_unaligned_tbtt %d\n",
	            wlc->PMawakebcn, wlc->PMblocked, wlc->txpend16165war,
	            wlc->check_for_unaligned_tbtt);
	FOREACH_AS_STA(wlc, idx, cfg) {
		wlc_pm_st_t *pm = cfg->pm;
		bcm_bprintf(b, "bsscfg %d BSS %d PS_ALLOWED() %d WLC_PORTOPEN() %d "
		            "dtim_programmed %d PMpending %d priorPMstate %d PMawakebcn %d "
		            "WME_PM_blocked %d PM %d PMenabled %d PSpoll %d apsd_sta_usp %d "
		            "check_for_unaligned_tbtt %d\n",
		            WLC_BSSCFG_IDX(cfg), cfg->BSS, PS_ALLOWED(cfg), WLC_PORTOPEN(cfg),
		            cfg->dtim_programmed, pm->PMpending, pm->priorPMstate, pm->PMawakebcn,
		            pm->WME_PM_blocked, pm->PM, pm->PMenabled, pm->PSpoll, pm->PMpending,
		            pm->check_for_unaligned_tbtt);
	}
#endif /* STA */
}

static int
wlc_dump_htcap(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint16 val = wlc->ht_cap.cap;
	uint16 stbc_val, mimo_ps_val;

	bcm_bprintf(b, "HT dump:\n");

	bcm_bprintf(b, "HT Cap 0X%04x\n", wlc->ht_cap.cap);
	if (val & HT_CAP_LDPC_CODING)
		bcm_bprintf(b, "LDPC ");
	if (val & HT_CAP_40MHZ)
		bcm_bprintf(b, "40MHz ");

	mimo_ps_val = (val & HT_CAP_MIMO_PS_MASK) >> HT_CAP_MIMO_PS_SHIFT;
	if (mimo_ps_val == HT_CAP_MIMO_PS_ON)
		bcm_bprintf(b, "MIMO-PS-ON ");
	else if (mimo_ps_val == HT_CAP_MIMO_PS_RTS)
		bcm_bprintf(b, "MIMO-PS-RTS ");
	else if (mimo_ps_val == HT_CAP_MIMO_PS_OFF)
		bcm_bprintf(b, "MIMO-PS-OFF ");

	if (val & HT_CAP_GF)
		bcm_bprintf(b, "GF ");
	if (val & HT_CAP_SHORT_GI_20)
		bcm_bprintf(b, "SGI-20 ");
	if (val & HT_CAP_SHORT_GI_40)
		bcm_bprintf(b, "SGI-40 ");
	if (val & HT_CAP_TX_STBC)
		bcm_bprintf(b, "STBC-TX ");

	stbc_val = (val & HT_CAP_RX_STBC_MASK) >> HT_CAP_RX_STBC_SHIFT;
	if (stbc_val == HT_CAP_RX_STBC_ONE_STREAM)
		bcm_bprintf(b, "STBC-RX-1SS ");
	else if (stbc_val == HT_CAP_RX_STBC_TWO_STREAM)
		bcm_bprintf(b, "STBC-RX-2SS ");
	else if (stbc_val == HT_CAP_RX_STBC_THREE_STREAM)
		bcm_bprintf(b, "STBC-RX-3SS ");

	if (val & HT_CAP_DELAYED_BA)
		bcm_bprintf(b, "Delay-BA ");
	if (val & HT_CAP_MAX_AMSDU)
		bcm_bprintf(b, "AMSDU-Max ");
	if (val & HT_CAP_DSSS_CCK)
		bcm_bprintf(b, "DSSS-CCK ");
	if (val & HT_CAP_PSMP)
		bcm_bprintf(b, "PSMP ");
	if (val & HT_CAP_40MHZ_INTOLERANT)
		bcm_bprintf(b, "40-Intol ");
	if (val & HT_CAP_LSIG_TXOP)
		bcm_bprintf(b, "LSIG-TXOP ");
	wlc_dump_mcsset("\nhw_mcsset ", &wlc->band->hw_rateset.mcs[0], b);
	bcm_bprintf(b, "\n");
	return 0;
}
#endif	

#if defined(BCMDBG_DUMP)
static int
wlc_gpio_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_GPIO_ID);
	return 0;
}

static int
wlc_dump_siid(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_SI_ID);
	return 0;
}

static int
wlc_dump_siclk(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_SICLK_ID);
	return 0;
}

static int
wlc_dump_sireg(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_SIREG_ID);
	return 0;
}

static int
wlc_dump_ccreg(wlc_info_t *wlc, struct bcmstrbuf *b)
{

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_CCREG_ID);
	return 0;
}

static int
wlc_pciereg_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PCIEREG_ID);
	return 0;
}

static int
wlc_dump_secalgo(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int i;

	if (!wlc->clk)
		return BCME_NOCLK;

	for (i = 0; i < WLC_MAX_WSEC_HW_KEYS(wlc); i ++) {
		uint16 v16 = wlc_read_shm(wlc, M_SECKINDXALGO_BLK + (i * 2));
		if ((v16 & SKL_ALGO_MASK) != CRYPTO_ALGO_OFF)
			bcm_bprintf(b, "%d %04x\n", i, v16);
	}
	return 0;
}

#ifdef WLP2P
static const bcm_bit_desc_t at_flags[] = {
	{ADDR_BMP_RA, "RA"},
	{ADDR_BMP_TA, "TA"},
	{ADDR_BMP_BSSID, "BSSID"},
	{ADDR_BMP_AP, "AP"},
	{ADDR_BMP_STA, "STA"},
	{ADDR_BMP_P2P_GO, "GO"},
	{ADDR_BMP_P2P_GC, "GC"},
	{ADDR_BMP_P2P_DISC, "DISC"},
	{0, NULL}
};
#endif

static int
wlc_dump_rcmta(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int i;
	struct ether_addr ea;
	char eabuf[ETHER_ADDR_STR_LEN];
	int limit;

	if (!wlc->clk)
		return BCME_NOCLK;

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub))
		limit = P2P_ADDR_STRT_INDX;
	else
#endif
	limit = RCMTA_SIZE;

	for (i = 0; i < limit; i ++) {
		wlc_get_rcmta(wlc, i, &ea);
		if (!ETHER_ISNULLADDR(&ea)) {
			bcm_bprintf(b, "%d %s\n", i, bcm_ether_ntoa(&ea, eabuf));
		}
	}

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub)) {
		for (i = limit; i < RCMTA_SIZE; i ++) {
			wlc_get_rcmta(wlc, i, &ea);
			if (!ETHER_ISNULLADDR(&ea)) {
				uint offset = M_ADDR_BMP_BLK(i - P2P_ADDR_STRT_INDX);
				uint16 type = wlc_p2p_read_shm(wlc->p2p, offset);
				char typestr[64];

				bcm_format_flags(at_flags, type, typestr, sizeof(typestr));
				bcm_bprintf(b, "%d %s %d 0x%04x[%s]\n",
				            i, bcm_ether_ntoa(&ea, eabuf),
				            i - P2P_ADDR_STRT_INDX, type, typestr);
			}
		}
	}
#endif /* WLP2P */
	return 0;
}
#endif 


#if defined(BCMDBG) || defined(BCMDBG_DUMP)
void
wlc_get_rcmta(wlc_info_t *wlc, int idx, struct ether_addr *addr)
{
	d11regs_t *regs = wlc->regs;
	uint32 v32;
	osl_t *osh;

	WL_TRACE(("wl%d: %s\n", WLCWLUNIT(wlc), __FUNCTION__));

	ASSERT(wlc->pub->corerev > 4);

	osh = wlc->osh;

	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | (idx * 2)));
	(void)R_REG(osh, &regs->objaddr);
	v32 = R_REG(osh, &regs->objdata);
	addr->octet[0] = (uint8)v32;
	addr->octet[1] = (uint8)(v32 >> 8);
	addr->octet[2] = (uint8)(v32 >> 16);
	addr->octet[3] = (uint8)(v32 >> 24);
	W_REG(osh, &regs->objaddr, (OBJADDR_RCMTA_SEL | ((idx * 2) + 1)));
	(void)R_REG(osh, &regs->objaddr);
	v32 = R_REG(osh, (volatile uint16*)(uintptr)&regs->objdata);
	addr->octet[4] = (uint8)v32;
	addr->octet[5] = (uint8)(v32 >> 8);
}


static int
wlc_dump_phy_cal(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_PHYCAL_ID);
	return 0;
}


static int
wlc_dump_phy_aci(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_ACI_ID);
	return 0;
}

static int
wlc_dump_phy_papd(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_PAPD_ID);

	if (b->size == b->origsize)
		return BCME_UNSUPPORTED;

	return 0;
}

static int
wlc_dump_phy_noise(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_NOISE_ID);
	return 0;
}

static int
wlc_dump_phy_state(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_STATE_ID);
	return 0;
}

static int
wlc_dump_phy_measlo(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!WLCISGPHY(wlc->band))
		return BCME_UNSUPPORTED;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_MEASLO_ID);
	return 0;
}

static int
wlc_dump_phy_lnagain(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!wlc->clk)
		return BCME_NOCLK;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_LNAGAIN_ID);
	return 0;
}

static int
wlc_dump_phy_initgain(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!wlc->clk)
		return BCME_NOCLK;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_INITGAIN_ID);
	return 0;
}

static int
wlc_dump_phy_hpf1tbl(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!(WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band)))
		return BCME_UNSUPPORTED;

	if (!wlc->clk)
		return BCME_NOCLK;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_HPF1TBL_ID);
	return 0;
}

static int
wlc_dump_phy_lpphytbl0(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!WLCISLPPHY(wlc->band))
		return BCME_UNSUPPORTED;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_LPPHYTBL0_ID);
	return 0;
}


static int
wlc_dump_phy_chanest(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	if (!wlc->clk)
		return BCME_NOCLK;

	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_PHY_CHANEST_ID);
	return 0;
}

#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) */
#endif /* WLLMAC_ONLY */

static void
wlc_dump_register_phy(wlc_info_t *wlc)
{
#ifndef WLLMAC_ONLY
#if defined(BCMDBG) || defined(BCMDBG_DUMP)
	wlc_dump_register(wlc->pub, "phycal", (dump_fn_t)wlc_dump_phy_cal, (void *)wlc);
	wlc_dump_register(wlc->pub, "phyaci", (dump_fn_t)wlc_dump_phy_aci, (void *)wlc);
	wlc_dump_register(wlc->pub, "phypapd",	(dump_fn_t)wlc_dump_phy_papd, (void *)wlc);
	wlc_dump_register(wlc->pub, "phynoise", (dump_fn_t)wlc_dump_phy_noise, (void *)wlc);
	wlc_dump_register(wlc->pub, "phystate",	(dump_fn_t)wlc_dump_phy_state, (void *)wlc);
	wlc_dump_register(wlc->pub, "phylo", (dump_fn_t)wlc_dump_phy_measlo, (void *)wlc);
	wlc_dump_register(wlc->pub, "phylnagain", (dump_fn_t)wlc_dump_phy_lnagain, (void *)wlc);
	wlc_dump_register(wlc->pub, "phyinitgain", (dump_fn_t)wlc_dump_phy_initgain, (void *)wlc);
	wlc_dump_register(wlc->pub, "phyhpf1tbl", (dump_fn_t)wlc_dump_phy_hpf1tbl, (void *)wlc);
	wlc_dump_register(wlc->pub, "phylpphytbl0", (dump_fn_t)wlc_dump_phy_lpphytbl0, (void *)wlc);
	wlc_dump_register(wlc->pub, "phychanest", (dump_fn_t)wlc_dump_phy_chanest, (void *)wlc);
#endif /* BCMDBG || BCMDBG_DUMP */
#endif /* WLLMAC_ONLY */
	return;
}


#if defined(BCMDBG) || defined(BCMDBG_DUMP)
#define SHOW_SHM(wlc, bf, addr, name) do { \
		uint16 tmpval; \
		tmpval = wlc_read_shm((wlc), (addr)); \
		bcm_bprintf(bf, "%15s     offset: 0x%04x (0x%04x)     0x%04x (%6d)\n", \
			name, addr / 2, addr, tmpval, tmpval); \
	} while (0)

/* Set this definition to 1 for additional verbosity */
#define BSSCFG_EXTRA_VERBOSE 1

#ifndef WLLMAC_ONLY
static int
wlc_bsscfg_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int i;
	wlc_bsscfg_t *bsscfg;

#ifdef MBSS
	bcm_bprintf(b, "MBSS Build.  MBSS is %s. SW MBSS MHF band 0: %s; band 1: %s\n",
		MBSS_ENAB(wlc->pub) ? "enabled" : "disabled",
		(wlc_bmac_mhf_get(wlc->hw, MHF1, WLC_BAND_2G) & MHF1_MBSS_EN) ? "set" : "clear",
		(wlc_bmac_mhf_get(wlc->hw, MHF1, WLC_BAND_5G) & MHF1_MBSS_EN) ? "set" : "clear");
	bcm_bprintf(b, "Pkts suppressed from ATIM:  %d. Bcn Tmpl not ready/done %d/%d\n",
		WLCNTVAL(wlc->pub->_cnt->atim_suppress_count),
		WLCNTVAL(wlc->pub->_cnt->bcn_template_not_ready),
		WLCNTVAL(wlc->pub->_cnt->bcn_template_not_ready_done));
#if defined(WLC_HIGH) && defined(WLC_LOW)
	bcm_bprintf(b, "WLC: cached prq base 0x%x, current prq rd 0x%x\n", wlc->prq_base,
		wlc->prq_rd_ptr);
#endif /* WLC_HIGH && WLC_LOW */
	bcm_bprintf(b, "Late TBTT counter %d\n",
		WLCNTVAL(wlc->pub->_cnt->late_tbtt_dpc));
	if (BSSCFG_EXTRA_VERBOSE && wlc->clk) {
		bcm_bprintf(b, "MBSS shared memory offsets and values:\n");
		SHOW_SHM(wlc, b, SHM_MBSS_BSSID0, "BSSID0");
		SHOW_SHM(wlc, b, SHM_MBSS_BSSID1, "BSSID1");
		SHOW_SHM(wlc, b, SHM_MBSS_BSSID2, "BSSID2");
		SHOW_SHM(wlc, b, SHM_MBSS_BCN_COUNT, "BCN_COUNT");
		SHOW_SHM(wlc, b, SHM_MBSS_PRQ_BASE, "PRQ_BASE");
		SHOW_SHM(wlc, b, SHM_MBSS_BC_FID0, "BC_FID0");
		SHOW_SHM(wlc, b, SHM_MBSS_BC_FID1, "BC_FID1");
		SHOW_SHM(wlc, b, SHM_MBSS_BC_FID2, "BC_FID2");
		SHOW_SHM(wlc, b, SHM_MBSS_BC_FID3, "BC_FID3");
		SHOW_SHM(wlc, b, SHM_MBSS_PRE_TBTT, "PRE_TBTT");
		SHOW_SHM(wlc, b, SHM_MBSS_SSID_LEN0, "SSID_LEN0");
		SHOW_SHM(wlc, b, SHM_MBSS_SSID_LEN1, "SSID_LEN1");
		SHOW_SHM(wlc, b, SHM_MBSS_PRQ_READ_PTR, "PRQ_RD");
		SHOW_SHM(wlc, b, SHM_MBSS_PRQ_WRITE_PTR, "PRQ_WR");
		SHOW_SHM(wlc, b, M_HOST_FLAGS1, "M_HOST1");
		SHOW_SHM(wlc, b, M_HOST_FLAGS2, "M_HOST2");
	}
	/* Dump out data at current PRQ ptrs */
	bcm_bprintf(b, "PRQ entries handled %d. Undirected %d. Bad %d\n",
		WLCNTVAL(wlc->pub->_cnt->prq_entries_handled),
		WLCNTVAL(wlc->pub->_cnt->prq_undirected_entries),
		WLCNTVAL(wlc->pub->_cnt->prq_bad_entries));

	if (BSSCFG_EXTRA_VERBOSE && wlc->clk) {
		uint16 rdptr, wrptr, base, totbytes, offset;
		int j;
		shm_mbss_prq_entry_t entry;
		char ea_buf[ETHER_ADDR_STR_LEN];

		base = wlc_read_shm(wlc, SHM_MBSS_PRQ_BASE);
		rdptr = wlc_read_shm(wlc, SHM_MBSS_PRQ_READ_PTR);
		wrptr = wlc_read_shm(wlc, SHM_MBSS_PRQ_WRITE_PTR);
		totbytes = SHM_MBSS_PRQ_ENTRY_BYTES * SHM_MBSS_PRQ_ENTRY_COUNT;
		if (rdptr < base || (rdptr >= base + totbytes)) {
			bcm_bprintf(b, "WARNING: PRQ read pointer out of range\n");
		}
		if (wrptr < base || (wrptr >= base + totbytes)) {
			bcm_bprintf(b, "WARNING: PRQ write pointer out of range\n");
		}

		bcm_bprintf(b, "PRQ data at %8s %25s\n", "TA", "PLCP0  Time");
		for (offset = base * 2, j = 0; j < SHM_MBSS_PRQ_ENTRY_COUNT;
			j++, offset += SHM_MBSS_PRQ_ENTRY_BYTES) {
			wlc_copyfrom_shm(wlc, offset, &entry, sizeof(entry));
			bcm_bprintf(b, "  0x%04x:", offset);
			bcm_bprintf(b, "  %s ", bcm_ether_ntoa(&entry.ta, ea_buf));
			bcm_bprintf(b, " 0x%0x 0x%02x 0x%04x", entry.prq_info[0],
				entry.prq_info[1], entry.time_stamp);
			if (SHM_MBSS_PRQ_ENT_DIR_SSID(&entry) ||
				SHM_MBSS_PRQ_ENT_DIR_BSSID(&entry)) {
				int uc, sw;

				uc = SHM_MBSS_PRQ_ENT_UC_BSS_IDX(&entry);
				sw = WLC_BSSCFG_HW2SW_IDX(wlc, uc);
				bcm_bprintf(b, "  (bss uc %d/sw %d)", uc, sw);
			}
			bcm_bprintf(b, "\n");
		}
	}
#endif /* MBSS */

	FOREACH_BSS(wlc, i, bsscfg) {
		bcm_bprintf(b, "\n");
		wlc_dump_bsscfg(wlc, bsscfg, i, b);
	}

	return 0;
}

static int
wlc_bssinfo_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int idx;
	wlc_bsscfg_t *cfg;

	bcm_bprintf(b, "\n");
	wlc_dump_bss_info("default_bss", wlc->default_bss, b);
	bcm_bprintf(b, "\n");
	FOREACH_BSS(wlc, idx, cfg) {
		bcm_bprintf(b, "bsscfg %d (0x%p):\n", idx, cfg);
		bcm_bprintf(b, "\n");
		wlc_dump_bss_info("target_bss", cfg->target_bss, b);
		bcm_bprintf(b, "\n");
		wlc_dump_bss_info("current_bss", cfg->current_bss, b);
	}
	return 0;
}


/*
* This function calls all dumps.
*/
static int
wlc_dump_all(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int bcmerror = 0;
	dumpcb_t *d;

	for (d = wlc->dumpcb_head; d != NULL; d = d->next) {
		/* don't parse "all", else it will recurse */
		if ((strncmp(d->name, "all", strlen("all")) == 0))
			continue;
		/* don't print "list" option in "all" */
		if ((strncmp(d->name, "list", strlen("list")) == 0))
			continue;
		/* don't print "default" option in "all" */
		if ((strncmp(d->name, "default", strlen("default")) == 0))
			continue;
		/* phytbl & phytbl2 are too big to be included in all */
		if ((strncmp(d->name, "phytbl", strlen("phytbl")) == 0))
			continue;
		/* phytbl & phytbl2 are too big to be included in all */
		if ((strncmp(d->name, "phytbl2", strlen("phytbl2")) == 0))
			continue;

		bcm_bprintf(b, "\n%s:------\n", d->name);

		/* Continue if there's no BCME_BUFTOOSHORT error */
		bcmerror = d->dump_fn(d->dump_fn_arg, b);
		if (bcmerror == BCME_BUFTOOSHORT)
			return bcmerror;
	}

	return 0;
}
#endif /* !WLLMAC_ONLY */

#if defined(WLC_HIGH_ONLY) && defined(BCMDBG)
static int
wlc_dump_rpcpktlog(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint32 buf[RPC_PKTLOG_DUMP_SIZE];
	int ret;
	int i;

	ASSERT(wlc->rpc);

	ret = bcm_rpc_pktlog_get(wlc->rpc, buf, RPC_PKTLOG_DUMP_SIZE, TRUE);
	if (ret < 0)
		return ret;

	bcm_bprintf(b, "Transmit log %d:\n", ret);
	for (i = 0; i < ret; i++) {
		bcm_bprintf(b, "[%d] trans 0x%x len %d ID %s\n", i,
			buf[i*RPC_PKTLOG_RD_LEN+1], buf[i*RPC_PKTLOG_RD_LEN+2],
			WLC_RPC_ID_LOOKUP(rpc_name_tbl, buf[i*RPC_PKTLOG_RD_LEN]));
	}

	ret = bcm_rpc_pktlog_get(wlc->rpc, buf, RPC_PKTLOG_DUMP_SIZE, FALSE);

	if (ret <= 0)
		return ret;

	bcm_bprintf(b, "Recv log %d:\n", ret);
	for (i = 0; i < ret; i++) {
		bcm_bprintf(b, "[%d] trans 0x%x len %d ID %s\n", i,
			buf[i*RPC_PKTLOG_RD_LEN+1], buf[i*RPC_PKTLOG_RD_LEN+2],
			WLC_RPC_ID_LOOKUP(rpc_name_tbl, buf[i*RPC_PKTLOG_RD_LEN]));
	}

	return 0;
}

static int
wlc_dump_rpc(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	return bcm_rpc_dump(wlc->rpc, b);
}
#endif /* WLC_HIGH_ONLY && BCMDBG */

/* Format a general info dump */
static int
wlc_dump_default(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	char *name_list;
	int name_list_len;
	struct bcmstrbuf names;
	char *name;
	char *p;
	int err = 0;

	/* create the name list for a default dump */
	name_list_len = 128;
	name_list = (char*)MALLOC(wlc->osh, name_list_len);
	if (!name_list)
		return BCME_NOMEM;

	bcm_binit(&names, name_list, name_list_len);

	bcm_bprintf(&names, "wlc phystate bsscfg bssinfo ratestuff stats ");

	if (wlc->clk)
		bcm_bprintf(&names, "pio dma ");

	if (EDCF_ENAB(wlc->pub) && wlc->pub->up)
		bcm_bprintf(&names, "wme ");

	if (WLBA_ENAB(wlc->pub))
		bcm_bprintf(&names, "ba ");

	if (AMPDU_ENAB(wlc->pub))
		bcm_bprintf(&names, "ampdu ");
#ifdef WET
	if (wlc->wet)
		bcm_bprintf(&names, "wet ");
#endif /* WET */

	if (TOE_ENAB(wlc->pub))
		bcm_bprintf(&names, "toe ");

#ifdef WLLED
	if (wlc->ledh)
		bcm_bprintf(&names, "led ");
#endif

#ifdef WLAMSDU
	/* only dump amsdu if we were handed a large dump buffer */
	if (b->size > 8000 &&
	    (AMSDU_ENAB(wlc->pub) || wlc->_amsdu_rx))
		bcm_bprintf(&names, "amsdu ");
#endif


	if (CAC_ENAB(wlc->pub))
		bcm_bprintf(&names, "cac ");

	/* dump the list */
	p = name_list;
	while ((name = wlc_dump_next_name(&p)) != NULL) {
		bcm_bprintf(b, "\n%s:------\n", name);
		err = wlc_dump_registered_name(wlc, name, b);
		if (err)
			break;
	}

	MFREE(wlc->osh, name_list, name_list_len);

	return err;
}
#endif /* BCMDBG || BCMDBG_DUMP */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST)
#ifndef WLLMAC_ONLY
/*
* This function lists all dump option.
*/
static int
wlc_dump_list(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	dumpcb_t *ptr;

	bcm_bprintf(b, "\nRegistered dumps:\n");

	for (ptr = wlc->dumpcb_head; ptr != NULL; ptr = ptr->next) {
		bcm_bprintf(b, "%s\n", ptr->name);
	}

	return 0;
}
#endif /* WLLMAC_ONLY */
#endif /* BCMDBG || BCMDBG_DUMP || WLTEST */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) || defined(WLNINTENDO2)
#ifndef WLLMAC_ONLY
int
wlc_iovar_dump(wlc_info_t *wlc, const char *params, int p_len, char *out_buf, int out_len)
{
	struct bcmstrbuf b;
	char *name_list;
	int name_list_len;
	char *name1;
	char *name;
	const char *p;
	const char *endp;
	int err = 0;
	char *name_list_ptr;

	bcm_binit(&b, out_buf, out_len);
	p = params;
	endp = p + p_len;

	/* find the dump name list length to make a copy */
	while (p != endp && *p != '\0')
		p++;

	/* return an err if the name list was not null terminated */
	if (p == endp)
		return BCME_BADARG;

	/* copy the dump name list to a new buffer since the output buffer
	 * may be the same memory as the dump name list
	 */
	name_list_len = (int) ((const uint8*)p - (const uint8*)params + 1);
	name_list = (char*)MALLOC(wlc->osh, name_list_len);
	if (!name_list)
	      return BCME_NOMEM;
	bcopy(params, name_list, name_list_len);

	name_list_ptr = name_list;

	/* get the first two dump names */
	name1 = wlc_dump_next_name(&name_list_ptr);
	name = wlc_dump_next_name(&name_list_ptr);

	/* if the dump list was empty, return the default dump */
	if (name1 == NULL) {
		WL_ERROR(("doing default dump\n"));
#if defined(WLTEST) && defined(WLTINYDUMP)
		err = wlc_tinydump(wlc, &b);
#elif defined(BCMDBG) || defined(BCMDBG_DUMP)
		err = wlc_dump_default(wlc, &b);
#endif /* defined(WLTEST) && defined(WLTINYDUMP) */
		goto exit;
	}

	/* dump the first section
	 * only print the separator if there are more than one dump
	 */
	if (name != NULL)
		bcm_bprintf(&b, "\n%s:------\n", name1);
	err = wlc_dump_registered_name(wlc, name1, &b);
	if (err)
		goto exit;

	/* dump the rest */
	while (name != NULL) {
		bcm_bprintf(&b, "\n%s:------\n", name);
		err = wlc_dump_registered_name(wlc, name, &b);
		if (err)
			break;

		name = wlc_dump_next_name(&name_list_ptr);
	}

exit:
	MFREE(wlc->osh, name_list, name_list_len);

	/* make sure the output is at least a null terminated empty string */
	if (b.origbuf == b.buf && b.size > 0)
		b.buf[0] = '\0';

	return err;
}

static char*
wlc_dump_next_name(char **buf)
{
	char *p;
	char *name;

	p = *buf;

	if (p == NULL)
		return NULL;

	/* skip leading space */
	while (bcm_isspace(*p) && *p != '\0')
		p++;

	/* remember the name start position */
	if (*p != '\0')
		name = p;
	else
		name = NULL;

	/* find the end of the name
	 * name is terminated by space or null
	 */
	while (!bcm_isspace(*p) && *p != '\0')
		p++;

	/* replace the delimiter (or '\0' character) with '\0'
	 * and set the buffer pointer to the character past the delimiter
	 * (or to NULL if the end of the string was reached)
	 */
	if (*p != '\0') {
		*p++ = '\0';
		*buf = p;
	} else {
		*buf = NULL;
	}

	/* return the pointer to the name */
	return name;
}

/* Dump all matching the given name */
static int
wlc_dump_registered_name(wlc_info_t *wlc, char *name, struct bcmstrbuf *b)
{
	dumpcb_t *dumpcb;
	int err = 0;
	int rv = BCME_UNSUPPORTED; /* If nothing found, return this. */

	/* find the given dump name */
	for (dumpcb = wlc->dumpcb_head; dumpcb != NULL; dumpcb = dumpcb->next) {
		if (!strcmp(name, dumpcb->name)) {
			if (rv == BCME_UNSUPPORTED) { /* Found one */
				rv = BCME_OK;
			}
			err = dumpcb->dump_fn(dumpcb->dump_fn_arg, b);
			if (b->size == 0) { /* check for output buffer overflow */
				rv = BCME_BUFTOOSHORT;
				break;
			}
			if (err != 0) { /* Record last non successful error code */
				rv = err;
			}
		}
	}

	return rv;
}
#endif /* WLLMAC_ONLY */
#endif /* BCMDBG || BCMDBG_DUMP || WLTEST || WLNINTENDO2 */

bool
wlc_rminprog(wlc_info_t *wlc)
{
	return WLC_RM_IN_PROGRESS(wlc);
}

#ifdef STA
/* conditions under which the chip is kept awake */
bool
wlc_stay_awake(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;

	/* stay awake when one of these global conditions meets */
	if (wlc->wake ||
	    wlc->PMawakebcn ||
	    BTA_ACTIVE(wlc) ||
	    SCAN_IN_PROGRESS(wlc->scan) || WLC_RM_IN_PROGRESS(wlc) || AS_IN_PROGRESS(wlc) ||
	    wlc->PMpending ||
	    wlc->PSpoll ||
	    wlc->check_for_unaligned_tbtt ||
	    wlc->apsd_sta_usp ||
	    wlc->txpend16165war ||
	    wlc->pm2_radio_shutoff_pending ||
	    wlc->gptimer_stay_awake_req ||
	    wlc->monitor != 0)
		return TRUE;

	/* stay awake as soon as we bring up a non-P2P AP bsscfg */
	FOREACH_UP_AP(wlc, idx, cfg) {
#ifdef WLP2P
		if (!BSS_P2P_ENAB(wlc, cfg))
#endif
			return TRUE;
	}

	/* stay awake as soon as we bring up a non-primary and non-P2P STA bsscfg */
	FOREACH_AS_STA(wlc, idx, cfg) {
		if (cfg != wlc->cfg &&
#ifdef WLP2P
		    !BSS_P2P_ENAB(wlc, cfg) &&
#endif
		    TRUE)
			return TRUE;
	}

	return FALSE;
}

/* conditions under which the PM bit should be set in outgoing frames. */
bool
wlc_ps_allowed(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	(void)wlc;

	if (AP_ACTIVE(wlc))
		return FALSE;
	/* disallow PS when one of the following bsscfg specific conditions meets */
	if (!cfg->BSS ||
	    !cfg->associated ||
	    !pm->PMenabled ||
	    pm->PM_override ||
	    !cfg->dtim_programmed ||
	    !WLC_PORTOPEN(cfg))
		return FALSE;

	/* disallow PS when it is a non-primary and non-P2P STA bsscfg */
	if (cfg != wlc->cfg &&
#ifdef WLP2P
	    !BSS_P2P_ENAB(wlc, cfg) &&
#endif
	    TRUE)
		return FALSE;

	return TRUE;
}

bool
wlc_associnprog(wlc_info_t *wlc)
{
#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return (wlc->lmac_info->lmac_assoc_in_progress);
#endif /* WLLMAC */
	return AS_IN_PROGRESS(wlc);
}
#endif /* STA */

#if defined(WLTINYDUMP)
static int
wlc_tinydump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	char perm[32], cur[32];
	char ssidbuf[SSID_FMT_BUF_LEN];
	int i;
	wlc_bsscfg_t *bsscfg;

	wl_dump_ver(wlc->wl, b);

	bcm_bprintf(b, "\n");

	bcm_bprintf(b, "resets %d\n", WLCNTVAL(wlc->pub->_cnt->reset));

	bcm_bprintf(b, "perm_etheraddr %s cur_etheraddr %s\n",
		bcm_ether_ntoa(&wlc->perm_etheraddr, perm),
		bcm_ether_ntoa(&wlc->pub->cur_etheraddr, cur));

	bcm_bprintf(b, "board 0x%x, board rev %s", wlc->pub->sih->boardtype,
	            bcm_brev_str(wlc->pub->boardrev, cur));
	if (wlc->pub->boardrev == BOARDREV_PROMOTED)
		bcm_bprintf(b, " (actually 0x%02x)", BOARDREV_PROMOTABLE);
	bcm_bprintf(b, "\n");

	bcm_bprintf(b, "rate_override: A %d, B %d\n",
		wlc->bandstate[BAND_5G_INDEX]->rspec_override,
		wlc->bandstate[BAND_2G_INDEX]->rspec_override);

	bcm_bprintf(b, "ant_rx_ovr %d txant %d\n", wlc->stf->ant_rx_ovr, wlc->stf->txant);

	FOREACH_BSS(wlc, i, bsscfg) {
		char ifname[32];

		bcm_bprintf(b, "\n");

		wlc_format_ssid(ssidbuf, bsscfg->SSID, bsscfg->SSID_len);
		strncpy(ifname, wl_ifname(wlc->wl, bsscfg->wlcif->wlif), sizeof(ifname));
		ifname[sizeof(ifname) - 1] = '\0';
		bcm_bprintf(b, "BSS Config %d: \"%s\"\n", i, ssidbuf);

		bcm_bprintf(b, "enable %d up %d wlif 0x%p \"%s\"\n",
		            bsscfg->enable,
		            bsscfg->up, bsscfg->wlcif->wlif, ifname);
		bcm_bprintf(b, "wsec 0x%x auth %d wsec_index %d wep_algo %d\n",
		            bsscfg->wsec,
		            bsscfg->auth, bsscfg->wsec_index,
		            WSEC_BSS_DEFAULT_KEY(bsscfg) ?
		            WSEC_BSS_DEFAULT_KEY(bsscfg)->algo : 0);

		bcm_bprintf(b, "current_bss->BSSID %s\n",
		            bcm_ether_ntoa(&bsscfg->current_bss->BSSID, (char*)perm));

		wlc_format_ssid(ssidbuf, bsscfg->current_bss->SSID,
		                bsscfg->current_bss->SSID_len);
		bcm_bprintf(b, "current_bss->SSID \"%s\"\n", ssidbuf);

#ifdef STA
		/* STA ONLY */
		if (!BSSCFG_STA(bsscfg))
			continue;

		bcm_bprintf(b, "bsscfg %d assoc_state %d\n", WLC_BSSCFG_IDX(bsscfg),
		            bsscfg->assoc->state);
#endif /* STA */
	}
	bcm_bprintf(b, "\n");

#ifdef STA
	bcm_bprintf(b, "AS_IN_PROGRESS() %d stas_associated %d\n", AS_IN_PROGRESS(wlc),
	            wlc->stas_associated);
#endif /* STA */

	bcm_bprintf(b, "aps_associated %d\n", wlc->aps_associated);
	FOREACH_UP_AP(wlc, i, bsscfg)
	        bcm_bprintf(b, "BSSID %s\n", bcm_ether_ntoa(&bsscfg->BSSID, (char*)perm));

	return 0;
}
#endif /* WLTINYDUMP */

#if defined(BCMDBG_DUMP)
#ifdef WLCHANIM
static void
wlc_dump_chanim(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	chanim_info_t* c_info = wlc->chanim_info;
	wlc_chanim_stats_t *stats = c_info->stats;

	bcm_bprintf(b, "CHAN Interference Measurement:\n");
	bcm_bprintf(b, "Stats during last scan:\n");
	while (stats) {
		bcm_bprintf(b, " chanspec: 0x%x crsglitch cnt: %d bad plcp: %d noise: %d\n",
			stats->chanim_stats.chanspec, stats->chanim_stats.glitchcnt,
			stats->chanim_stats.badplcp, stats->chanim_stats.bgnoise);

		if (WLC_CCASTATS_CAP(wlc))
			bcm_bprintf(b, "\t cca_txdur: %d cca_inbss: %d cca_obss:"
			  "%d cca_nocat: %d cca_nopkt: %d cca_txop: %d\n",
			  stats->chanim_stats.ccastats[CCASTATS_TXDUR],
			  stats->chanim_stats.ccastats[CCASTATS_INBSS],
			  stats->chanim_stats.ccastats[CCASTATS_OBSS],
			  stats->chanim_stats.ccastats[CCASTATS_NOCTG],
			  stats->chanim_stats.ccastats[CCASTATS_NOPKT],
			  stats->chanim_stats.ccastats[CCASTATS_TXOP]);
		stats = stats->next;
	}

	bcm_bprintf(b, "curent stats:\n");

	stats = &c_info->cur_stats;

	bcm_bprintf(b, " chanspec: 0x%x crsglitch cnt: %d bad plcp: %d noise: %d\n",
		stats->chanim_stats.chanspec, stats->chanim_stats.glitchcnt,
		stats->chanim_stats.badplcp, stats->chanim_stats.bgnoise);

	if (WLC_CCASTATS_CAP(wlc))
		bcm_bprintf(b, "\t cca_txdur: %d cca_inbss: %d cca_obss:"
			"%d cca_nocat: %d cca_nopkt: %d cca_txop: %d\n",
			stats->chanim_stats.ccastats[CCASTATS_TXDUR],
			stats->chanim_stats.ccastats[CCASTATS_INBSS],
			stats->chanim_stats.ccastats[CCASTATS_OBSS],
			stats->chanim_stats.ccastats[CCASTATS_NOCTG],
			stats->chanim_stats.ccastats[CCASTATS_NOPKT],
			stats->chanim_stats.ccastats[CCASTATS_TXOP]);
}
#endif /* WLCHANIM */

#ifdef SMF_STATS
static void
wlc_dump_smfs_type(wlc_smf_stats_t *smf_stats, struct bcmstrbuf *b)
{
	static const struct {uint8 type; char name[32];} type_names[] = {
		{SMFS_TYPE_AUTH, "Authentication_Request"},
		{SMFS_TYPE_ASSOC, "Association_Request"},
		{SMFS_TYPE_REASSOC, "Reassociation_Request"},
		{SMFS_TYPE_DISASSOC_TX, "Disassociation_Request_TX"},
		{SMFS_TYPE_DISASSOC_RX, "Disassociation_Request_RX"},
		{SMFS_TYPE_DEAUTH_TX, "Deauthentication_Request_TX"},
		{SMFS_TYPE_DEAUTH_RX, "Deauthentication_Request_RX"}
	};
	const char *tname = "UNKNOWN";
	uint i;

	for (i = 0; i < ARRAYSIZE(type_names); i++) {
		if (type_names[i].type == smf_stats->smfs_main.type)
		    tname = type_names[i].name;
	}

	bcm_bprintf(b, "\tFrame Type: ");
	bcm_bprintf(b, "%s\n", tname);
}

static void
wlc_dump_smf_stats(wlc_smf_stats_t *smf_stats, struct bcmstrbuf *b)
{
	wlc_smfs_elem_t *elemt;

	ASSERT(smf_stats);

	wlc_dump_smfs_type(smf_stats, b);
	bcm_bprintf(b, "\tIgnored Count: %d\n", smf_stats->smfs_main.ignored_cnt);
	bcm_bprintf(b, "\tMalformed Count: %d\n", smf_stats->smfs_main.malformed_cnt);
	bcm_bprintf(b, "\tSuccessful/Failed Count with status or reason code:\n");

	elemt = smf_stats->stats;

	while (elemt) {
		bcm_bprintf(b, "\t\t SC/RC: %d Count: %d\n",
		  elemt->smfs_elem.code, elemt->smfs_elem.count);
		elemt = elemt->next;
	}
	bcm_bprintf(b, "\n");
}

static void
wlc_dump_bss_smfs(wlc_bsscfg_t *cfg, int bsscfg_idx, struct bcmstrbuf *b)
{
	char bssbuf[ETHER_ADDR_STR_LEN];
	int i;

	bcm_bprintf(b, "BSS Config %d: BSSID: %s\n", bsscfg_idx,
		bcm_ether_ntoa(&cfg->BSSID, bssbuf));

	for (i = 0; i < SMFS_TYPE_MAX; i++) {
		wlc_dump_smf_stats(&cfg->smfs_info->smf_stats[i], b);
	}
}

static void
wlc_dump_smfs(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint i;

	bcm_bprintf(b, "Selected Management Frame Stats for each BSS:\n");
	for (i = 0; i < WLC_MAXBSSCFG; i++) {
		if (wlc->bsscfg[i] == NULL)
			continue;
		bcm_bprintf(b, "\n");
		wlc_dump_bss_smfs(wlc->bsscfg[i], i, b);
	}
}
#endif /* SMF_STATS */
#endif 
#if defined(BCMDBG)
static void
wlc_dump_perf_stats(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_perf_stats_t *cnt = &wlc->perf_stats;
	wlc_isr_stats_t *ints = &cnt->isr_stats;
	uint32 i;

	const char * int_names[32] =
	{
		"MACSSPNDD     ",
		"BCNTPL        ",
		"TBTT          ",
		"BCNSUCCESS    ",
		"BCNCANCLD     ",
		"ATIMWINEND    ",
		"PMQ           ",
		"NSPECGEN_0    ",
		"NSPECGEN_1    ",
		"MACTXERR      ",
		"NSPECGEN_3    ",
		"PHYTXERR      ",
		"PME           ",
		"GP0           ",
		"GP1           ",
		"DMAINT        ",
		"TXSTOP        ",
		"CCA           ",
		"BG_NOISE      ",
		"DTIM_TBTT     ",
		"PRQ           ",
		"PWRUP         ",
		"BT_RFACT_STUCK",
		"BT_PRED_REQ   ",
		"INT_24        ",
		"P2P           ",
		"INT_26        ",
		"INT_27        ",
		"RFDISABLE     ",
		"TFS           ",
		"PHYCHANGED    ",
		"TO            "
	};

	/* Print perf stats */

	bcm_bprintf(b, "\nGeneral Stats:-\n");

	bcm_bprintf(b,
		"\nisr       : %d"
		"\ndpc       : %d"
		"\ntmier dpc : %d"
		"\ngptimer   : %d"
		"\nbeacons   : %d"
		"\nprobe req : %d\n",
			cnt->n_isr, cnt->n_dpc, cnt->n_timer_dpc, cnt->n_gptimer,
			cnt->n_beacon, cnt->n_probe_req);

	/* Print perf stats */

	bcm_bprintf(b, "\nInterrupt       num  percent");

	for (i = 0; i < 32; i++) {
		if (ints->n_counts[i]) {
			bcm_bprintf(b, "\n%s	%d	%d", int_names[i], ints->n_counts[i],
				((ints->n_counts[i])*100)/(cnt->n_isr));
		}
	}

	bcm_bprintf(b, "\n");
}

#endif /* BCMDBG */

static uint
wlc_btc_frag_threshold(wlc_info_t *wlc, struct scb *scb)
{
	ratespec_t rspec;
	uint rate, thresh;
	wlc_bsscfg_t *cfg;

	/* Make sure period is known */
	if (wlc->btch->bth_period == 0)
		return 0;

	ASSERT(scb != NULL);

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

	/* if BT SCO is ongoing, packet length should not exceed 1/2 of SCO period */
	rspec = wlc_get_rspec_history(cfg);
	rate = RSPEC2KBPS(rspec);

	/*  use one half of the duration as threshold.  convert from usec to bytes */
	/* thresh = (bt_period * rate) / 1000 / 8 / 2  */
	thresh = (wlc->btch->bth_period * rate) >> 14;

	if (thresh < DOT11_MIN_FRAG_LEN)
		thresh = DOT11_MIN_FRAG_LEN;
	return thresh;
}

static INLINE uint
wlc_frag(wlc_info_t *wlc, struct scb *scb, uint fifo, uint plen, uint *flen)
{
	uint payload, thresh, nfrags, bt_thresh = 0;
	int btc_mode;

	plen -= ETHER_HDR_LEN;

	ASSERT(fifo < NFIFO);

	thresh = wlc->fragthresh[fifo];

	btc_mode = wlc_btc_mode_get(wlc);

	if (WL_BTC_FULLTDM == btc_mode)
		bt_thresh = wlc_btc_frag_threshold(wlc, scb);

	if (bt_thresh)
		thresh = thresh > bt_thresh ? bt_thresh : thresh;

	/* optimize for non-fragmented case */
	if (plen < (thresh - (DOT11_A4_HDR_LEN + DOT11_QOS_LEN +
		DOT11_FCS_LEN + ETHER_ADDR_LEN))) {
		*flen = plen;
		return (1);
	}

	/* account for 802.11 MAC header */
	thresh -= DOT11_A3_HDR_LEN + DOT11_FCS_LEN;

	/* account for A4 */
	if (SCB_WDS(scb))
		thresh -= ETHER_ADDR_LEN;

	/* SCB_QOS: account for QoS Control Field */
	if (SCB_QOS(scb))
		thresh -= DOT11_QOS_LEN;

	/*
	 * Spec says broadcast and multicast frames are not fragmented.
	 * LLC/SNAP considered part of packet payload.
	 * Fragment length must be even per 9.4 .
	 */
	if ((plen > thresh) && !SCB_ISMULTI(scb)) {
		*flen = payload = thresh & ~1;
		nfrags = (plen + payload - 1) / payload;
	} else {
		*flen = plen;
		nfrags = 1;
	}

	ASSERT(nfrags <= DOT11_MAXNUMFRAGS);

	return (nfrags);
}

void
BCMINITFN(wlc_reset)(wlc_info_t *wlc)
{
	WL_TRACE(("wl%d: wlc_reset\n", wlc->pub->unit));

	wlc->check_for_unaligned_tbtt = FALSE;

#ifdef STA
	/* Turn off PM mode for any stations that are up so we can utilize
	   unaligned tbtt to recover tsf related values.
	   With PM enabled before wlc_reset() is called, it seems that the
	   driver does not come out of PM mode properly afterwards and is
	   unable to receive beacons when wlc_phy_chanspec_set() doesn't get called.
	*/
	if (wlc->pub->associated) {
		int i;
		wlc_bsscfg_t *bsscfg;

		FOREACH_AS_STA(wlc, i, bsscfg) {
			if (bsscfg->up) {
				wlc_set_pmstate(bsscfg, FALSE);
				wlc_set_uatbtt(bsscfg, TRUE);
				WL_PS(("%s: turn off pm mode\n", __FUNCTION__));
				wlc->reset_triggered_pmoff = TRUE;
			}
		}
	}
#endif /* STA */

#ifdef CRAM
	/* Close cram before resetting the core. CRAM depends on gptimer in MAC */
	wlc_cram_close(wlc->crami, NULL);
#endif


	/* slurp up hw mac counters before core reset */
	if (WLC_UPDATE_STATS(wlc)) {
		wlc_statsupd(wlc);

		/* reset our snapshot of macstat counters */
		bzero((char*)wlc->core->macstat_snapshot, sizeof(macstat_t));
	}

	wlc_bmac_reset(wlc->hw);

#ifdef WLAMPDU
	wlc_ampdu_reset(wlc->ampdu);
#endif /* WLAMPDU */

	wlc->txretried = 0;

#ifdef WLC_HIGH_ONLY
	/* Need to set a flag(to be cleared asynchronously by BMAC driver with high call)
	 *  in order to prevent wlc_rpctx_txreclaim() from screwing wlc_rpctx_getnexttxp(),
	 *  which could be invoked by already QUEUED high call(s) from BMAC driver before
	 *  wlc_bmac_reset() finishes.
	 * It's not needed before in monolithic driver model because d11core interrupts would
	 *  have been cleared instantly in wlc_bmac_reset() and no txstatus interrupt
	 *  will come to driver to fetch those flushed dma pkt pointers.
	 */
	wlc->reset_bmac_pending = TRUE;

	wlc_rpctx_txreclaim(wlc->rpctx);

	wlc_stf_phy_txant_upd(wlc);
	wlc_phy_ant_rxdiv_set(wlc->band->pi, wlc->stf->ant_rx_ovr);
#endif
}

void
wlc_fatal_error(wlc_info_t *wlc)
{
	WL_ERROR(("wl%d: fatal error, reinitializing\n", wlc->pub->unit));
	wl_init(wlc->wl);
}

/* Return the channel the driver should initialize during wlc_init.
 * the channel may have to be changed from the currently configured channel
 * if other configurations are in conflict (bandlocked, 11n mode disabled,
 * invalid channel for current country, etc.)
 */
static chanspec_t
BCMINITFN(wlc_init_chanspec)(wlc_info_t *wlc)
{
	chanspec_t chanspec;

	/* start with the default_bss channel since it store the last
	 * channel set by ioctl or iovar, or default to 2G
	 */
	chanspec = wlc->default_bss->chanspec;

	/* Sanitize user setting for 40MHz against current settings */
	if (CHSPEC_IS40_UNCOND(chanspec) &&
	    (!N_ENAB(wlc->pub) || !VALID_40CHANSPEC_IN_BAND(wlc, CHSPEC_WLCBANDUNIT(chanspec))))
		chanspec = CH20MHZ_CHSPEC(wf_chspec_ctlchan(chanspec));

	/* make sure the channel is on the supported band if we are band-restricted */
	if (wlc->bandlocked || NBANDS(wlc) == 1) {
		/* driver is configured for the current band only,
		 * pick another channel if the chanspec is not on the current band.
		 */
		if (CHSPEC_WLCBANDUNIT(chanspec) != wlc->band->bandunit)
			chanspec = wlc_default_chanspec(wlc->cmi, TRUE);
	}

	/* validate channel */
	if (!wlc_valid_chanspec_db(wlc->cmi, chanspec)) {
		wlcband_t *save_band = wlc->band;

		wlc->band = wlc->bandstate[CHSPEC_WLCBANDUNIT(chanspec)];
		chanspec = wlc_default_chanspec(wlc->cmi, TRUE);
		wlc->band = save_band;
	}

	return chanspec;
}

void
BCMINITFN(wlc_init)(wlc_info_t *wlc)
{
	d11regs_t *regs;
	chanspec_t chanspec;
	int i;
	uint bandunit;
	wlc_bsscfg_t *bsscfg;
	bool mute = FALSE;
	bool isx21;

	WL_TRACE(("wl%d: wlc_init\n", wlc->pub->unit));

	regs = wlc->regs;

	/* This will happen if a big-hammer was executed. In that case, we want to go back
	 * to the channel that we were on and not new channel
	 */
	if (wlc->pub->associated)
		chanspec = wlc->home_chanspec;
	else
		chanspec = wlc_init_chanspec(wlc);

	bandunit = CHSPEC_WLCBANDUNIT(chanspec);
	/* Update bss rates to the band specific default rate set */
	wlc_rateset_default(&wlc->default_bss->rateset,
		&wlc->bandstate[bandunit]->defrateset,
		wlc->band->phytype, wlc->band->bandtype,
		FALSE, RATE_MASK_FULL, (bool)N_ENAB(wlc->pub),
		CHSPEC_WLC_BW(chanspec), wlc->stf->op_rxstreams);

	/* Mute the phy when 11h is enabled and we are operating on radar
	 * sensitive channel.
	 */
	if (WL11H_AP_ENAB(wlc) && wlc_radar_chanspec(wlc->cmi, chanspec))
		mute = TRUE;

	wlc_bmac_init(wlc->hw, chanspec, mute, wlc->defmacintmask);

	/* read rate table direct address maps from shm */
	wlc_read_rt_dirmap(wlc);

	/* sync up btc mode between high and low driver */
	wlc->btch->mode = wlc_bmac_btc_mode_get(wlc->hw);
	wlc->btch->wire = wlc_bmac_btc_wire_get(wlc->hw);

	wlc->seckeys = wlc_bmac_read_shm(wlc->hw, M_SECRXKEYS_PTR) * 2;
	if (D11REV_GE(wlc->pub->corerev, 13) && (wlc->machwcap & MCAP_TKIPMIC))
		wlc->tkmickeys = wlc_bmac_read_shm(wlc->hw, M_TKMICKEYS_PTR) * 2;
#ifdef BCMWAPI_WPI
	if (D11REV_GE(wlc->pub->corerev, 24))
		wlc->wapimickeys = wlc_bmac_read_shm(wlc->hw, M_WAPIMICKEYS_PTR) * 2;
#endif /* BCMWAPI_WPI */

#ifdef STA
	/* update beacon listen interval */
	wlc_bcn_li_upd(wlc);
	/* maximum time to wait for beacon after wakeup from doze (at pretbtt).
	 * read the initial ucode config only...
	 * SHM init value is in 8us unit.
	 */
	if (wlc->bcn_wait_prd == 0) {
		wlc->bcn_wait_prd = wlc_bmac_read_shm(wlc->hw, M_NOSLPZNATDTIM) << 3 >> 10;
		ASSERT(wlc->bcn_wait_prd > 0);
	}
#endif

	/* the world is new again, so is our reported rate */
	wlc_reprate_init(wlc);

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub))
		wlc_p2p_init(wlc->p2p);
#endif

	wlc_key_hw_init_all(wlc);

	/* write ethernet address to core */
	FOREACH_BSS(wlc, i, bsscfg) {
		wlc_set_mac(bsscfg);
		wlc_set_bssid(bsscfg);
	}

#ifdef STA
#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub)) {
		/* clear all mchan timer and schedule elements */
		wlc_mchan_stop_timer(wlc->mchan);
		wlc_mchan_sched_delete_all(wlc->mchan);
	}
#endif /* WLMCHAN */
	/* Update tsf_cfprep if associated and up */
	if (wlc->pub->associated) {
		FOREACH_AS_STA(wlc, i, bsscfg) {
			if (bsscfg->up) {
#ifdef WLP2P
				if (P2P_ENAB(wlc->pub)) {
					WL_P2P(("%s: set p2p assoc state for bss %d\n",
					        __FUNCTION__, bsscfg->_idx));
					/* set p2p assoc state
					 * since a reset would have cleared the p2p
					 * shm values.
					 * This would reprogram part of the p2p shm
					 * values.  The rest of the tbtt based shm
					 * values will get reprogrammed upon first
					 * reception of beacons.
					 */
					wlc_p2p_assoc_upd(wlc->p2p, bsscfg, TRUE);
					/* Update maccontrol PM related bits */
					wlc_set_ps_ctrl(bsscfg);
				}
				else
#endif /* WLP2P */
				{
				uint32 bi;

				/* get beacon period from bsscfg and convert to uS */
				bi = bsscfg->current_bss->beacon_period << 10;
				/* update the tsf_cfprep register */
				/* since init path would reset to default value */
				W_REG(wlc->osh, &regs->tsf_cfprep, (bi << CFPREP_CBI_SHIFT));

				/* Update maccontrol PM related bits */
				wlc_set_ps_ctrl(bsscfg);

				break;
				}
			}
		}
	}
#endif /* STA */

	wlc_bandinit_ordered(wlc, chanspec);

	/* init probe response timeout */
	wlc_write_shm(wlc, M_PRS_MAXTIME, wlc->prb_resp_timeout);

	/* init max burst txop (framebursting) */
	wlc_write_shm(wlc, M_MBURST_TXOP,
	              (wlc->_rifs ? (EDCF_AC_VO_TXOP_AP << 5) : MAXFRAMEBURST_TXOP));
	/* in case rifs was set when not up, need to run war here */
	wlc_phy_tkip_rifs_war(wlc->band->pi, wlc->_rifs);

	/* initialize maximum allowed duty cycle */
	isx21 = ((wlc->pub->sih->boardtype == BCM943224X21) ||
	         (wlc->pub->sih->boardvendor == VENDOR_APPLE &&
	          ((wlc->pub->sih->boardtype == BCM943224X21_FCC) ||
	           (wlc->pub->sih->boardtype == BCM943224X21B))));

	if (wlc->stf->pwr_throttle_state == WLC_PWRTHROTTLE_ON && isx21) {
		wlc_duty_cycle_set(wlc, wlc->stf->tx_duty_cycle_pwr, TRUE, TRUE);
		wlc_duty_cycle_set(wlc, wlc->stf->tx_duty_cycle_pwr, FALSE, TRUE);
	} else {
		wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_ofdm, TRUE, TRUE);
		wlc_duty_cycle_set(wlc, wlc->tx_duty_cycle_cck, FALSE, TRUE);
	}


#ifdef WLAMPDU
	/* Update some shared memory locations related to max AMPDU size allowed to received */
	wlc_ampdu_shm_upd(wlc->ampdu);
#endif

#ifdef WL11N
	/* Update txcore-mask and spatial-mapping in shared memory */
	if (N_ENAB(wlc->pub)) {
		wlc_stf_txcore_shmem_write(wlc, M_COREMASK_BLK, FALSE);
	}
#endif

	/* band-specific inits */
	wlc_bsinit(wlc);

	/* Enable EDCF mode (while the MAC is suspended) */
	if (EDCF_ENAB(wlc->pub)) {
		OR_REG(wlc->osh, &regs->ifs_ctl, IFS_USEEDCF);
		wlc_edcf_setparams(wlc->cfg, FALSE);
	}

	/* Init precedence maps for empty FIFOs */
	wlc_tx_prec_map_init(wlc);

	/* read the ucode version if we have not yet done so */
	if (wlc->ucode_rev == 0) {
		wlc->ucode_rev = wlc_read_shm(wlc, M_BOM_REV_MAJOR) << NBITS(uint16);
		wlc->ucode_rev |= wlc_read_shm(wlc, M_BOM_REV_MINOR);
	}

#ifdef WLAMPDU_MAC
	/* Enable ucode AMPDU aggregation */
	wlc_sidechannel_init(wlc->ampdu);
#endif

	/* ..now really unleash hell (allow the MAC out of suspend) */
	wlc_enable_mac(wlc);

#ifdef STA
	_wlc_set_wake_ctrl(wlc);
#endif

	/* Propagate rfaware_lifetime setting to ucode */
	wlc_rfaware_lifetime_set(wlc, wlc->rfaware_lifetime);

	/* clear tx flow control */
	wlc_txflowcontrol_reset(wlc);

	/* clear tx data fifo suspends */
	wlc->tx_suspended = FALSE;

	/* enable the RF Disable Delay timer */
	if (D11REV_GE(wlc->pub->corerev, 10))
		W_REG(wlc->osh, &wlc->regs->rfdisabledly, RFDISABLE_DEFAULT);

#if defined(MBSS)
	/* Initialize the HW to SW BSS configuration index map */
	for (i = 0; i < WLC_MAXBSSCFG; i++) {
		wlc->hw2sw_idx[i] = WLC_BSSCFG_IDX_INVALID;
	}

#if defined(WLC_HIGH) && defined(WLC_LOW)
	if (D11REV_ISMBSS4(wlc->pub->corerev)) {
	/* Initialize the cached PRQ base pointer */
		wlc->prq_base = wlc_read_shm(wlc, SHM_MBSS_PRQ_BASE);
		wlc->prq_rd_ptr = wlc->prq_base;
	}
#endif /* WLC_HIGH && WLC_LOW */
#endif /* MBSS */

	/*
	 * Initialize WME parameters; if they haven't been set by some other
	 * mechanism (IOVar, etc) then read them from the hardware.
	 */
	if (WLC_WME_RETRY_SHORT_GET(wlc, 0) == 0) { /* Unintialized; read from HW */
		int ac;

		ASSERT(wlc->clk);
		for (ac = 0; ac < AC_COUNT; ac++) {
			wlc->wme_retries[ac] = wlc_read_shm(wlc, M_AC_TXLMT_ADDR(ac));
		}
	}

	wlc_ht_update_coex_support(wlc, wlc->pub->_coex);

#ifdef CCA_STATS
	cca_stats_upd(wlc, 0);
#endif

#ifdef WLCHANIM
	wlc_chanim_update(wlc, wlc->chanspec, CHANIM_CHANSPEC);
#endif


	/* Restart the AP if we are up and reiniting due to a big-hammer.
	 * If we are not yet up (and being called within wlc_up) do not call wlc_restart_ap()
	 *   since it calls wlc_set_chanspec() which may attempt to switch to a band
	 *   that has not yet been initialized.
	 * Clear aps_associated to force the first AP up to re-init core
	 * information, in particular the TSF (since we reset it above).
	 */
	if (wlc->pub->up && AP_ENAB(wlc->pub)) {
		FOREACH_BSS(wlc, i, bsscfg) {
			if (BSSCFG_AP(bsscfg)) {
#ifdef MBSS
				wlc_spt_deinit(wlc, bsscfg->bcn_template, FALSE);
#endif /* MBSS */
				bsscfg->associated = FALSE;
			}
		}
		wlc->aps_associated = 0;
		wlc_restart_ap(wlc->ap);
	}

#ifdef WLBTAMP
	wlc_bta_radio_status_upd(wlc->bta);
#endif /* WLBTAMP */

#ifdef STA
	/* Possibly resync scan state machine as channel and mac status would have changed */
	wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);
#endif
}

void
wlc_mac_bcn_promisc(wlc_info_t *wlc)
{
	if ((AP_ENAB(wlc->pub) && (N_ENAB(wlc->pub) || wlc->band->gmode)) ||
	    wlc->bcnmisc_ibss || wlc->bcnmisc_scan || wlc->bcnmisc_monitor)
		wlc_mctrl(wlc, MCTL_BCNS_PROMISC, MCTL_BCNS_PROMISC);
	else
		wlc_mctrl(wlc, MCTL_BCNS_PROMISC, 0);
        /* enable edcrs for EU Adaptivity for both bands and both both bandwidths */
		wlc_write_shm(wlc, BPHY_FREQ_CONTROL, 0x3f);
}

/* set or clear maccontrol bits MCTL_PROMISC, MCTL_KEEPCONTROL and MCTL_KEEPBADFCS */
void
wlc_mac_promisc(wlc_info_t *wlc)
{
	uint32 promisc_bits = 0, mask = 0;

	/* promiscuous mode just sets MCTL_PROMISC
	 * Note: APs get all BSS traffic without the need to set the MCTL_PROMISC bit
	 * since all BSS data traffic is directed at the AP
	 */
	if (PROMISC_ENAB(wlc->pub) && !AP_ENAB(wlc->pub) && !wlc->wet)
		promisc_bits |= MCTL_PROMISC;

	/* monitor mode needs MCTL_PROMISC, MCTL_KEEPCONTROL, and MCTL_KEEPBADFCS
	 * Note: monitor mode also needs MCTL_BCNS_PROMISC, but that is
	 * handled in wlc_mac_bcn_promisc()
	 */
#if defined(MACOSX)
	if (MONITOR_ENAB(wlc))
		promisc_bits |= MCTL_PROMISC | MCTL_KEEPCONTROL | MCTL_KEEPBADFCS;
	mask = MCTL_PROMISC | MCTL_KEEPCONTROL | MCTL_KEEPBADFCS;
#else
	if (MONITOR_ENAB(wlc))
		promisc_bits |= MCTL_PROMISC | MCTL_KEEPCONTROL;
	mask = MCTL_PROMISC | MCTL_KEEPCONTROL;
#endif
	wlc_mctrl(wlc, mask, promisc_bits);
}

#ifdef BCMASSERT_SUPPORT
/* check if hps and wake states of sw and hw are in sync */
bool
wlc_ps_check(wlc_info_t *wlc)
{
#ifdef STA
	bool hps, wake;
	bool wake_ok;
	volatile uint32 tmp;
	int idx;
	wlc_bsscfg_t *cfg;

	FOREACH_AS_STA(wlc, idx, cfg) {
		bool hw_hps = FALSE;

		if (cfg == wlc->cfg) {
			tmp = R_REG(wlc->osh, &wlc->regs->maccontrol);

			/* If deviceremoved is detected, then don't take any action
			 * as this can be called in any context. Assume that caller
			 * will take care of the condition. This is just to avoid assert
			 */
			if (tmp == 0xffffffff) {
				WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
				return DEVICEREMOVED(wlc);
			}

			hw_hps = ((tmp & MCTL_HPS) != 0);
		}
#ifdef WLP2P
		else if (P2P_ENAB(wlc->pub)) {
			tmp = wlc_p2p_hps_get(wlc->p2p, cfg);
			hw_hps = (tmp != 0);
		}
#endif

		hps = PS_ALLOWED(cfg);

		if (hps != hw_hps) {
			WL_ERROR(("wl%d.%d: hps not sync, sw %d, hw %d\n",
			          wlc->pub->unit, WLC_BSSCFG_IDX(cfg), hps, hw_hps));
			WL_PS(("PM %d PMenabled %d PM_override %d "
			       "dtim_programmed %d PORTOPEN() %d\n",
			       cfg->pm->PM, cfg->pm->PMenabled, cfg->pm->PM_override,
			       cfg->dtim_programmed, WLC_PORTOPEN(cfg)));

			ASSERT(hps == hw_hps);
			return FALSE;
		}
	}

	tmp = R_REG(wlc->osh, &wlc->regs->maccontrol);

	/* If deviceremoved is detected, then don't take any action
	 * as this can be called in any context. Assume that caller
	 * will take care of the condition. This is just to avoid assert
	 */
	if (tmp == 0xffffffff) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		return DEVICEREMOVED(wlc);
	}

#ifdef WLC_LOW
	/* For a monolithic build the wake check can be exact since it looks at wake
	 * override bits. The MCTL_WAKE bit should match the 'wake' value.
	 */
	wake = STAY_AWAKE(wlc) || (wlc->hw->wake_override != 0);
	wake_ok = (wake == ((tmp & MCTL_WAKE) != 0));
#else
	/* For a split build we will not have access to any wake overrides from the low
	 * level. The check can only make sure the MCTL_WAKE bit is on if the high
	 * level 'wake' value is true. If the high level 'wake' is false, the MCTL_WAKE
	 * may be either true or false due to the low level override.
	 */
	wake = STAY_AWAKE(wlc);
	wake_ok = (wake && ((tmp & MCTL_WAKE) != 0)) || !wake;
#endif
	if (!wake_ok) {
		WL_ERROR(("wl%d: wake not sync, sw %d maccontrol 0x%x\n",
		          wlc->pub->unit, wake, tmp));
		WL_PS(("wake %d PMawakebcn %d BTA_ACTIVE() %d "
		       "SCAN_IN_PROGRESS() %d WLC_RM_IN_PROGRESS() %d AS_IN_PROGRESS() %d "
		       "PMpending %d PSpoll %d check_for_unaligned_tbtt %d apsd_sta_usp %d "
		       "txpend16165war %d pm2_radio_shutoff_pending %d monitor %d\n",
		       wlc->wake, wlc->PMawakebcn, BTA_ACTIVE(wlc),
		       SCAN_IN_PROGRESS(wlc->scan), WLC_RM_IN_PROGRESS(wlc),
		       AS_IN_PROGRESS(wlc),
		       wlc->PMpending, wlc->PSpoll, wlc->check_for_unaligned_tbtt,
		       wlc->apsd_sta_usp,
		       wlc->txpend16165war, wlc->pm2_radio_shutoff_pending, wlc->monitor));

		FOREACH_BSS(wlc, idx, cfg) {
			if (!cfg->BSS ||
			    !cfg->associated)
				continue;
			WL_PS(("bsscfg %d PMenabled %d "
			       "PMpending %d PSpoll %d apsd_sta_usp %d "
			       "check_for_unaligned_tbtt %d\n",
			       WLC_BSSCFG_IDX(cfg), cfg->pm->PMenabled,
			       cfg->pm->PMpending, cfg->pm->PSpoll, cfg->pm->apsd_sta_usp,
			       cfg->pm->check_for_unaligned_tbtt));
#ifdef WLP2P
			WL_PS(("P2P %d\n", BSS_P2P_ENAB(wlc, cfg)));
#endif
		}

		ASSERT(wake_ok);
		return FALSE;
	}
#endif /* STA */
	return TRUE;
}
#endif /* BCMDBG_ASSERT */

/* push sw wake state through hardware */
static void
__wlc_set_wake_ctrl(wlc_info_t *wlc, uint32 mc)
{
	uint32 new_mc;
	bool wake;
	bool awake_before;

	wake = STAY_AWAKE(wlc);

	WL_TRACE(("wl%d: __wlc_set_wake_ctrl: wake %d\n", wlc->pub->unit, wake));
	WL_RTDC2(wlc, wake ? "__wlc_set_wake_ctrl: wake=%02u PS---" :
	         "__wlc_set_wake_ctrl: wake=%02u PS+++", (wake ? 1 : 0), 0);

	new_mc = wake ? MCTL_WAKE : 0;

#if defined(BCMDBG) || defined(WLMSG_PS)
	if ((mc & MCTL_WAKE) && !wake)
		WL_PS(("wl%d: PS mode: clear WAKE (sleep if permitted)\n", wlc->pub->unit));
	if (!(mc & MCTL_WAKE) && wake)
		WL_PS(("wl%d: PS mode: set WAKE (stay awake)\n", wlc->pub->unit));
#endif	/* BCMDBG || WLMSG_PS */

	wlc_mctrl(wlc, MCTL_WAKE, new_mc);

	awake_before = (mc & MCTL_WAKE);

	if (wake && !awake_before)
		wlc_bmac_wait_for_wake(wlc->hw);
}

static void
_wlc_set_wake_ctrl(wlc_info_t *wlc)
{
	volatile uint32 mc;

	mc = R_REG(wlc->osh, &wlc->regs->maccontrol);

	__wlc_set_wake_ctrl(wlc, mc);
}

/* push sw hps and wake state through hardware */
void
wlc_set_ps_ctrl(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	volatile uint32 mc;
	bool hps;

	if (!wlc->clk)
		return;

	hps = PS_ALLOWED(cfg);

	mc = R_REG(wlc->osh, &wlc->regs->maccontrol);

	if (cfg == wlc->cfg) {
		uint32 new_mc;

		WL_TRACE(("wl%d.%d: wlc_set_ps_ctrl: hps %d\n",
		          wlc->pub->unit, WLC_BSSCFG_IDX(cfg), hps));
		WL_RTDC2(wlc, wake ? "wlc_set_ps_ctrl: ps=%02u PS---" :
		         "wlc_set_ps_ctrl: ps=%02u PS+++", (hps ? 10 : 0), 0);

		new_mc = hps ? MCTL_HPS : 0;
#if defined(BCMDBG) || defined(WLMSG_PS)
		if ((mc & MCTL_HPS) && !hps)
			WL_PS(("wl%d.%d: PM-MODE: clear HPS (no sleep and no PM)\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		if (!(mc & MCTL_HPS) && hps)
			WL_PS(("wl%d.%d: PM-MODE: set HPS (permit sleep and enable PM)\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
#endif	/* BCMDBG || WLMSG_PS */

		wlc_mctrl(wlc, MCTL_HPS, new_mc);
	}
#ifdef WLP2P
	else if (P2P_ENAB(wlc->pub)) {
#if defined(BCMDBG) || defined(WLMSG_PS)
		if (!hps)
			WL_PS(("wl%d.%d: PM-MODE: clear HPS (P2P no sleep and no PM)\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		if (hps)
			WL_PS(("wl%d.%d: PM-MODE: set HPS (P2P permit sleep and enable PM)\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
#endif	/* BCMDBG || WLMSG_PS */
		wlc_p2p_hps_upd(wlc->p2p, cfg, hps);
	}
#endif /* WLP2P */

	__wlc_set_wake_ctrl(wlc, mc);

#ifdef CCA_STATS
	cca_stats_upd(wlc, 0);
#endif
}

void
wlc_set_wake_ctrl(wlc_info_t *wlc)
{
	if (!wlc->pub->up)
		return;

	_wlc_set_wake_ctrl(wlc);

#ifdef CCA_STATS
	cca_stats_upd(wlc, 0);
#endif
}

/*
 * Validate the MAC address for this bsscfg.
 * If valid, the MAC address will be set in the bsscfg's cur_etheraddr.
 */
static int
wlc_validate_mac(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct ether_addr *addr)
{
	int err = 0;
#ifdef MBSS
	struct ether_addr temp;
	int ucidx;
	int ii;
	wlc_bsscfg_t *bsscfg;
#endif

	/* don't let a broadcast address be set */
	if (ETHER_ISMULTI(addr))
		return BCME_BADADDR;

	if (cfg == wlc->cfg) {
		bcopy(addr, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN);
		wlc_bmac_set_hw_etheraddr(wlc->hw, addr);

#ifdef MBSS
		if (MBSS_ENAB(wlc->pub)) {
			/* regardless of a clash, every time the user sets
			 * the primary config's cur_etheraddr, we will clear all
			 * all of the secondary config ethernet addresses.  If we
			 * don't do this, we'll have to prevent the user from
			 * configuring a MAC for the primary that collides(ucidx)
			 * with secondary configs.  this is way easier and is
			 * documented this way in the IOCTL/IOVAR manual.
			 */
			FOREACH_BSS(wlc, ii, bsscfg) {
				if (BSSCFG_AP(bsscfg))
					bcopy(&ether_null, &bsscfg->cur_etheraddr, ETHER_ADDR_LEN);
			}
		}

		/* also clear the base address for MBSS */
		bcopy(&ether_null, &wlc->vether_base, ETHER_ADDR_LEN);
#endif /* MBSS */
	}
#ifdef MBSS
	else {
		if (MBSS_ENAB(wlc->pub) && BSSCFG_AP(cfg)) {

			/* Has the primary config's address been set? */
			if (ETHER_ISNULLADDR(&wlc->cfg->cur_etheraddr))
				return BCME_BADADDR;

			if (ETHER_ISNULLADDR(&wlc->vether_base)) {
				/* setting first VIF addr, start by checking
				 * for collision with primary config
				 */
				if (EADDR_TO_UC_IDX(*addr, wlc->mbss_ucidx_mask) ==
				    EADDR_TO_UC_IDX(wlc->cfg->cur_etheraddr, wlc->mbss_ucidx_mask))
					return BCME_BADADDR;

				/* Apply mask and save the base */
				bcopy(addr, &temp, ETHER_ADDR_LEN);
				temp.octet[5] &= ~(wlc->mbss_ucidx_mask);
				bcopy(&temp, &wlc->vether_base, ETHER_ADDR_LEN);
			}
			else {
				/* verify that the upper bits of the address
				 * match our base
				 */
				bcopy(addr, &temp, ETHER_ADDR_LEN);
				temp.octet[5] &= ~(wlc->mbss_ucidx_mask);
				if (bcmp(&temp, &wlc->vether_base, ETHER_ADDR_LEN))
					return BCME_BADADDR;

				/* verify that there isn't a
				 * collision with any other configs.
				 */
				ucidx = EADDR_TO_UC_IDX(*addr, wlc->mbss_ucidx_mask);

				FOREACH_BSS(wlc, ii, bsscfg) {
					if ((bsscfg == cfg) ||
					    (ETHER_ISNULLADDR(&bsscfg->cur_etheraddr)))
						continue;
					if (ucidx == EADDR_TO_UC_IDX(bsscfg->cur_etheraddr,
						wlc->mbss_ucidx_mask))
						return BCME_BADADDR;
				}

				/* make sure the index is in bound */
				if (MBSS_ENAB16(wlc->pub) &&
				    ((uint32)AP_BSS_UP_COUNT(wlc) >= wlc->max_ap_bss))
					return BCME_BADADDR;
			}
		}
	}
#endif /* MBSS */

	if (!err) {
		/* Accept the user's MAC address */
		bcopy(addr, &cfg->cur_etheraddr, ETHER_ADDR_LEN);
#ifdef WLP2P
		if (P2P_ENAB(wlc->pub) && cfg != wlc->cfg) {
			/* Takes effect immediately. Note that it's still recommended that
			 * the BSS be down before doing this to avoid having frames in transit
			 * with this as TA, but that's a corner case.
			 */
			if (bcmp(addr, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN) != 0 &&
			    cfg->rcmta_ra_idx >= RCMTA_SIZE)
				wlc_p2p_d11ra_alloc(wlc->p2p, &cfg->rcmta_ra_idx);
			if (wlc->clk &&
			    (R_REG(wlc->osh, &wlc->regs->maccontrol) & MCTL_EN_MAC)) {
				wlc_suspend_mac_and_wait(wlc);
				wlc_set_mac(cfg);
				wlc_enable_mac(wlc);
			}
			if (bcmp(addr, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN) == 0 &&
			    cfg->rcmta_ra_idx < RCMTA_SIZE) {
				wlc_p2p_d11ra_free(wlc->p2p, cfg->rcmta_ra_idx);
				cfg->rcmta_ra_idx = RCMTA_SIZE;
			}
		}
#endif /* WLP2P */
	}

	return err;
}

/*
 * Write this BSS config's MAC address to core.
 * Updates RXE match engine.
 */
int
wlc_set_mac(wlc_bsscfg_t *cfg)
{
	int err = 0;
	wlc_info_t *wlc = cfg->wlc;

	WL_APSTA_UPDN(("wl%d: wlc_set_mac for config %d\n", wlc->pub->unit,
	          WLC_BSSCFG_IDX(cfg)));

	if (cfg == wlc->cfg) {
		/* enter the MAC addr into the RXE match registers */
		wlc_set_addrmatch(wlc, RCM_MAC_OFFSET, &cfg->cur_etheraddr);
	}
#ifdef MBSS
	else if (MBSS_ENAB(wlc->pub) && BSSCFG_AP(cfg)) {
		wlc_write_mbss_basemac(wlc, &wlc->vether_base);
	}
#endif /* MBSS */
#ifdef WLP2P
	else if (P2P_ENAB(wlc->pub) &&
	         cfg->rcmta_ra_idx >= P2P_ADDR_STRT_INDX && cfg->rcmta_ra_idx < RCMTA_SIZE) {
		const struct ether_addr *addr;
		uint16 mask, val;

		/* make sure NOT to set the primary MAC address in RCMTA */
		if (bcmp(&cfg->cur_etheraddr, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN) == 0) {
			addr = &ether_null;
			mask = ~0;
			val = 0;
		}
		else {
			addr = &cfg->cur_etheraddr;
			mask = ADDR_BMP_RA;
			val = ADDR_BMP_RA;
			if (BSS_P2P_DISC_ENAB(wlc, cfg)) {
				mask |= ADDR_BMP_P2P_DISC;
				val |= ADDR_BMP_P2P_DISC;
			}
			else if (BSS_P2P_ENAB(wlc, cfg)) {
				if (BSSCFG_AP(cfg)) {
					mask |= ADDR_BMP_P2P_GO|ADDR_BMP_P2P_GC;
					val |= ADDR_BMP_P2P_GO;
				} else {
					mask |= ADDR_BMP_P2P_GC|ADDR_BMP_P2P_GO;
					val |= ADDR_BMP_P2P_GC;
				}
			}
			else {
				if (BSSCFG_AP(cfg)) {
					mask |= ADDR_BMP_AP|ADDR_BMP_STA;
					val |= ADDR_BMP_AP;
				} else {
					mask |= ADDR_BMP_STA|ADDR_BMP_AP;
					val |= ADDR_BMP_STA;
				}
			}
			mask |= ADDR_BMP_BSS_IDX_MASK;
			val |= wlc_p2p_d11cb_idx(wlc->p2p, cfg) << ADDR_BMP_BSS_IDX_SHIFT;
		}
		if ((cfg->wlcif->flags & WLC_IF_VIRTUAL) && !cfg->up) {
			wlc_set_rcmta(wlc, cfg->rcmta_ra_idx, &ether_null);
			wlc_set_rcmta_type(wlc, cfg->rcmta_ra_idx, ~0, 0);
		}
		else {
			wlc_set_rcmta(wlc, cfg->rcmta_ra_idx, addr);
			wlc_set_rcmta_type(wlc, cfg->rcmta_ra_idx, mask, val);
		}
	}
#endif /* WLP2P */

#ifdef WLAMPDU
	wlc_ampdu_macaddr_upd(wlc);
#endif

	return err;
}

void
wlc_clear_bssid(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	if (cfg == wlc->cfg) {
		wlc_set_addrmatch(wlc, RCM_BSSID_OFFSET, &ether_null);
	}
	else if ((BSSCFG_STA(cfg) ||
#ifdef WLP2P
	          P2P_ENAB(wlc->pub) ||
#endif
	          FALSE) && cfg->BSS) {
		wlc_rcmta_del_bssid(wlc, cfg);
	}
}

/* Write the BSS config's BSSID address to core (set_bssid in d11procs.tcl).
 * Updates RXE match engine.
 */
void
wlc_set_bssid(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	/* if primary config, we need to update BSSID in RXE match registers */
	if (cfg == wlc->cfg) {
		wlc_set_addrmatch(wlc, RCM_BSSID_OFFSET, &cfg->BSSID);
	}
	else if ((BSSCFG_STA(cfg) ||
#ifdef WLP2P
	          P2P_ENAB(wlc->pub) ||
#endif
	          FALSE) && cfg->BSS) {
		wlc_rcmta_add_bssid(wlc, cfg);
	}

}

/*
 * Suspend the the MAC and update the slot timing
 * for standard 11b/g (20us slots) or shortslot 11g (9us slots).
 */
void
wlc_switch_shortslot(wlc_info_t *wlc, bool shortslot)
{
	int idx;
	wlc_bsscfg_t *cfg;

	ASSERT(wlc->band->gmode);

	/* use the override if it is set */
	if (wlc->shortslot_override != WLC_SHORTSLOT_AUTO)
		shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);

	if (wlc->shortslot == shortslot)
		return;

	wlc->shortslot = shortslot;

	/* update the capability based on current shortslot mode */
	FOREACH_BSS(wlc, idx, cfg) {
		if (!cfg->associated)
			continue;
		cfg->current_bss->capability &= ~DOT11_CAP_SHORTSLOT;
		if (wlc->shortslot)
			cfg->current_bss->capability |= DOT11_CAP_SHORTSLOT;
	}

	wlc_bmac_set_shortslot(wlc->hw, shortslot);
}

/*
 * Update aCWmin based on supported rates.
 * 11g sec 9.2.12, 19.8.4, supported rates are all in the
 * set 1, 2, 5.5, and 11 use B PHY aCWmin == 31,
 * The PSM needs to be suspended for this call.
 */
void
wlc_cwmin_gphy_update(wlc_info_t *wlc, wlc_rateset_t *rs, bool associated)
{
	uint16 cwmin;
	uint i;
	uint r;

	if (associated) {
		/* use the BSS supported rates to determine aCWmin */
		cwmin = BPHY_CWMIN;
		for (i = 0; i < rs->count; i++) {
			r = rs->rates[i] & RATE_MASK;
			/*
			 * Checking for IS_OFDM(rate) is not sufficient.
			 * If the rateset includes PBCC rates 22 or 33Mbps,
			 * we should also use APHY_CWMIN,
			 * but the PBCC rates are not OFDM.
			 */
			if (!IS_CCK(r)) {
				cwmin = APHY_CWMIN;
				break;
			}
		}
	} else {
		/* unassociated aCWmin A phy value (11g sec 9.2.12, 19.8.4) */
		cwmin = APHY_CWMIN;
	}

	WL_INFORM(("wl%d: wlc_cwmin_gphy_update(): setting aCWmin = %d\n", wlc->pub->unit, cwmin));

	wlc_set_cwmin(wlc, cwmin);
}

uint8
wlc_local_constraint_qdbm(wlc_info_t *wlc)
{
	uint8 local;
	int16 local_max;

	local = WLC_TXPWR_MAX;
	if (wlc->pub->associated &&
	    (wf_chspec_ctlchan(wlc->chanspec) == wf_chspec_ctlchan(wlc->home_chanspec))) {

		/* get the local power constraint if we are on the AP's
		 * channel [802.11h, 7.3.2.13]
		 */
		/* Clamp the value between 0 and WLC_TXPWR_MAX w/o overflowing the target */
		local_max = (wlc->txpwr_local_max - wlc->txpwr_local_constraint) *
			WLC_TXPWR_DB_FACTOR;
		if (local_max > 0 && local_max < WLC_TXPWR_MAX)
			return (uint8)local_max;
		if (local_max < 0)
			return 0;
	}

	return local;
}

/* propagate home chanspec to all bsscfgs in case bsscfg->current_bss->chanspec is referenced */
void
wlc_set_home_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
{
	if (wlc->home_chanspec != chanspec) {
		int idx;
		wlc_bsscfg_t *cfg;

		WL_INFORM(("wl%d: change shared chanspec wlc->home_chanspec from "
		           "0x%04x to 0x%04x\n", wlc->pub->unit, wlc->home_chanspec, chanspec));

		wlc->home_chanspec = chanspec;

		FOREACH_BSS(wlc, idx, cfg) {
			if (!cfg->associated)
				continue;
#ifdef WLMCHAN
			if (!MCHAN_ENAB(wlc->pub) || cfg->chan_context->chanspec == chanspec)
#endif
			{
			cfg->target_bss->chanspec = chanspec;
			cfg->current_bss->chanspec = chanspec;
			}
		}

		if ((WLCISNPHY(wlc->band) && NREV_GE(wlc->band->phyrev, 3)) ||
			WLCISHTPHY(wlc->band)) {
			wlc_phy_interference_set(wlc->band->pi, TRUE);

			wlc_phy_acimode_noisemode_reset(wlc->band->pi,
				CHSPEC_CHANNEL(chanspec), FALSE, TRUE, FALSE);
		}

	}
}

/* helper function for per-port code to call to query the "current" chanspec of a BSS */
chanspec_t
wlc_get_home_chanspec(wlc_bsscfg_t *cfg)
{
	ASSERT(cfg != NULL);

	if (cfg->associated)
		return cfg->current_bss->chanspec;

	return cfg->wlc->home_chanspec;
}

/* helper function for per-port code to call to query the "current" bss info of a BSS */
wlc_bss_info_t *
wlc_get_current_bss(wlc_bsscfg_t *cfg)
{
	ASSERT(cfg != NULL);

	return cfg->current_bss;
}

/* full phy cal when start or join a network */
void
wlc_full_phy_cal(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, uint8 reason)
{
	int idx;
	wlc_bsscfg_t *cfg;
	chanspec_t chanspec;

	chanspec = bsscfg->associated ?
		bsscfg->current_bss->chanspec : bsscfg->target_bss->chanspec;

	/* check if channel in bsscfg is a channel to share */
	FOREACH_BSS(wlc, idx, cfg) {
		if (!cfg->associated || cfg == bsscfg)
			continue;
		if (cfg->current_bss->chanspec == chanspec)
			/* skip full phy cal if already did by other interface */
			return;
	}

	wlc_phy_cal_perical(wlc->band->pi, reason);
}
#ifdef WL11N
#if defined(WLC_HIGH) && defined(WLC_LOW)
/* update bandwidth */
static void
wlc_txbw_update(wlc_info_t *wlc)
{
	wlc_bmac_txbw_update(wlc->hw);

}
#endif
#endif /* WL11N */
static void
wlc_set_phy_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
{
	WL_TMP(("wl%d: wlc_set_phy_chanspec 0x%x\n", wlc->pub->unit, chanspec));

	/* Save our copy of the chanspec */
	wlc->chanspec = chanspec;

	/* Set the chanspec and power limits for this locale after computing
	 * any 11h local tx power constraints.
	 */
	wlc_channel_set_chanspec(wlc->cmi, chanspec, wlc_local_constraint_qdbm(wlc));

#ifdef WL11N
#if !(defined(WLMCHAN) && defined(WLC_HIGH_ONLY))
	/* following code brings ~3ms delay for split driver */
	if (wlc->stf->ss_algosel_auto)
		wlc_stf_ss_algo_channel_get(wlc, &wlc->stf->ss_algo_channel, chanspec);

	wlc_stf_ss_update(wlc, wlc->band);
#if defined(WLC_HIGH) && defined(WLC_LOW)
		wlc_txbw_update(wlc);
#endif
#endif /* !(defined(WLMCHAN) && defined(WLC_HIGH_ONLY)) */
#endif /* WL11N */

#ifdef WLBTAMP
	if (wlc->pub->up && wlc_phy_txpower_hw_ctrl_get(wlc->band->pi)) {
		uint8 txpwr;

		if (WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band))
			txpwr = wlc_phy_txpower_get_target_max(wlc->band->pi);
		else
			txpwr = wlc_phy_txpower_get_target_min(wlc->band->pi);
		/* short range mode txpwr is 4dbm */
		wlc_write_shm(wlc, M_ALT_TXPWR_IDX, txpwr - 16);
	}
#endif /* WLBTAMP */
}

void
wlc_update_txba_burst_war(wlc_info_t *wlc, struct scb *scb)
{
	if ((D11REV_IS(wlc->pub->corerev, 26) || D11REV_IS(wlc->pub->corerev, 29)) &&
		AP_ENAB(wlc->pub)) {
		uint16 mhf5 = 0;

		if (wlc->frameburst) {
			struct scb_iter scbiter;
			struct scb *lscb;
			uint bcm_scb = 0, nonbcm_scb = 0;

			FOREACHSCB(wlc->scbstate, &scbiter, lscb) {
				if (SCB_ASSOCIATED(lscb)) {
					if (lscb->flags & SCB_BRCM) {
						bcm_scb++;
						mhf5 = 0;
					} else  {
						nonbcm_scb++;
						if (!bcm_scb)
							 mhf5 = MHF5_TXBA_BURST;
					}
				}
			}

			/* Handle the TXBA_BURST state during disassoc */
			if (scb) {
				mhf5 = 0;
				/* If this is the last BCM STA leaving,
				 *  and we have nonbcm STA associated.
				 */
				if ((scb->flags & SCB_BRCM) &&
				   (bcm_scb == 1) && nonbcm_scb)
						mhf5 = MHF5_TXBA_BURST;
			}
		}

		/* Force TXBA BURST disabled for Intel6300 IOT testing */
	}
}


void
wlc_set_chanspec(wlc_info_t *wlc, chanspec_t chanspec)
{
	uint bandunit;
#ifdef STA
	bool switchband = FALSE;
#endif
	chanspec_t old_chanspec = wlc->chanspec;
#ifdef CCA_STATS
	int idx;
	wlc_bsscfg_t *cfg;
	bool roaming = FALSE;
#endif /* CCA_STATS */
	uint32 tsf_l;

	tsf_l = 0;
	if (WL_MCHAN_ON()) {
		tsf_l = R_REG(wlc->osh, &wlc->regs->tsf_timerlow);
		WL_MCHAN(("wl%d: %s - changing chanspec(channel) from 0x%x(%d) to 0x%x(%d)\n",
		         wlc->pub->unit, __FUNCTION__,
		         wlc->chanspec, CHSPEC_CHANNEL(wlc->chanspec),
		         chanspec, CHSPEC_CHANNEL(chanspec)));
	}

	if (!wlc_valid_chanspec_db(wlc->cmi, chanspec) &&
		!(wlc->scan->state & SCAN_STATE_PROHIBIT)) {
		WL_ERROR(("wl%d: %s: Bad channel %d\n",
		          wlc->pub->unit, __FUNCTION__, CHSPEC_CHANNEL(chanspec)));
		ASSERT(wlc_valid_chanspec_db(wlc->cmi, chanspec));
		goto set_chanspec_done;
	}

#ifdef CCA_STATS
	FOREACH_AS_STA(wlc, idx, cfg) {
		if (cfg->BSS && cfg->assoc->type == AS_ROAM) {
			roaming = TRUE;
			break;
		}
	}

	/* to speed up roaming process, especially in dongle case, do not read
	 * counters from shared memory for cca during roaming scan
	 */
	if (!roaming)
		/* About to leave this channel, so calculate cca stats from this channel */
		cca_stats_upd(wlc, 1);
#endif

#ifdef WLCHANIM
	wlc_chanim_update(wlc, wlc->chanspec, CHANIM_CHANSPEC);
#endif /* WLCHANIM */

	if (old_chanspec == chanspec)
		return;

	/* Switch bands if necessary */
	if (NBANDS(wlc) > 1) {
		bandunit = CHSPEC_WLCBANDUNIT(chanspec);
		if (wlc->band->bandunit != bandunit || wlc->bandinit_pending) {
#ifdef STA
			switchband = TRUE;
#endif
			if (wlc->bandlocked) {
				WL_ERROR(("wl%d: %s: chspec %d band is locked!\n",
				          wlc->pub->unit, __FUNCTION__, CHSPEC_CHANNEL(chanspec)));
				goto set_chanspec_done;
			}
			/* BMAC_NOTE: should the setband call come after the wlc_bmac_chanspec() ?
			 * if the setband updates (wlc_bsinit) use low level calls to inspect and
			 * set state, the state inspected may be from the wrong band, or the
			 * following wlc_bmac_set_chanspec() may undo the work.
			 */
			wlc_setband(wlc, bandunit);
		}
	}

	ASSERT(N_ENAB(wlc->pub) || !CHSPEC_IS40(chanspec));


	/* sync up phy/radio chanspec */
	wlc_set_phy_chanspec(wlc, chanspec);

#ifdef WL11N
	/* init antenna selection */
	if (CHSPEC_WLC_BW(old_chanspec) != CHSPEC_WLC_BW(chanspec)) {
		if (WLANTSEL_ENAB(wlc))
			wlc_antsel_init(wlc->asi);

		/* Fix the hardware rateset based on bw.
		 * Mainly add MCS32 for 40Mhz, remove MCS 32 for 20Mhz
		 */
		wlc_rateset_bw_mcs_filter(&wlc->band->hw_rateset,
			wlc->band->mimo_cap_40?CHSPEC_WLC_BW(chanspec):0);
	}
#endif /* WL11N */

	/* update some mac configuration since chanspec changed */
	wlc_ucode_mac_upd(wlc);

#ifdef STA
	if (NBANDS(wlc) > 1) {
		if (switchband && wlc->pub->up) {
			if ((wlc->freqtrack || (wlc->freqtrack_override == FREQTRACK_ON)) &&
			    WLCISGPHY(wlc->band))
				wlc_phy_freqtrack_start(wlc->band->pi);
		}
	}
#endif

#ifdef CCA_STATS
	if (!roaming)
		/* update cca time */
		cca_stats_tsf_upd(wlc);
#endif

	/* invalidate txcache as transmit b/w may have changed */
	if (N_ENAB(wlc->pub))
		wlc->txcgen++;

set_chanspec_done:
	if (WL_MCHAN_ON()) {
		uint32 now_l = R_REG(wlc->osh, &wlc->regs->tsf_timerlow);
		/* Use ABS here in case of wrap around */
		tsf_l = (uint32)ABS((int32)(now_l - tsf_l));
		WL_MCHAN(("wl%d: %s - completed in %d uS at 0x%x\n",
		          wlc->pub->unit, __FUNCTION__, tsf_l, now_l));
	}
}

int
wlc_get_last_txpwr(wlc_info_t *wlc, wlc_txchain_pwr_t *last_pwr)
{
	tx_power_t *power;
	uint i;

	if (!wlc->pub->up)
		return BCME_NOTUP;

	if ((power = (tx_power_t*)MALLOC(wlc->osh, sizeof(tx_power_t))) == NULL) {
		ASSERT("OUT-OF-MEMORY" && 0);
		return BCME_NOMEM;
	}

	memset(last_pwr, 0, sizeof(wlc_txchain_pwr_t));

	memset(power, 0, sizeof(tx_power_t));
	wlc_phy_txpower_get_current(wlc->band->pi, power, CHSPEC_CHANNEL(wlc->chanspec));

	for (i = 0; i < power->rf_cores && i < WLC_NUM_TXCHAIN_MAX; i++) {
		last_pwr->chain[i] = power->est_Pout[i];
	}

	MFREE(wlc->osh, power, sizeof(tx_power_t));
	return BCME_OK;
}

//#if defined(BCMDBG) || defined(WLTEST)
static int
wlc_get_current_txpwr(wlc_info_t *wlc, void *pwr, uint len)
{
	txppr_t txpwr;
	tx_power_t *power;
	tx_power_legacy_t *old_power = NULL;
	uint r, c;
	uint qdbm;
	bool override;
	bool ishtphy = WLCISHTPHY(wlc->band);
	uint offset;
	uint8 *ptxpwr;

	if (len == sizeof(tx_power_legacy_t))
		old_power = (tx_power_legacy_t*)pwr;
	else if (len < sizeof(tx_power_t))
		return BCME_BUFTOOSHORT;

	if (!(power = (tx_power_t*)MALLOC(wlc->osh, sizeof(tx_power_t))))
		return BCME_NOMEM;

	bzero(power, sizeof(tx_power_t));

	power->chanspec = WLC_BAND_PI_RADIO_CHANSPEC;
	if (wlc->pub->associated)
		power->local_chanspec = wlc->home_chanspec;

	/* Return the user target tx power limits for the various rates.  Note  wlc_phy.c's
	 * public interface only implements getting and setting a single value for all of
	 * rates, so we need to fill the array ourselves.
	 */
	wlc_phy_txpower_get(wlc->band->pi, &qdbm, &override);
	for (r = 0; r < WL_TX_POWER_RATES; r++) {
		power->user_limit[r] = (uint8)qdbm;
	}

	power->local_max = wlc->txpwr_local_max * WLC_TXPWR_DB_FACTOR;
	power->local_constraint = wlc->txpwr_local_constraint * WLC_TXPWR_DB_FACTOR;

	power->antgain[0] = wlc->bandstate[BAND_2G_INDEX]->antgain;
	power->antgain[1] = wlc->bandstate[BAND_5G_INDEX]->antgain;

	wlc_channel_reg_limits(wlc->cmi, power->chanspec, &txpwr);

	/* CCK tx power limits */
	for (c = 0, r = WL_TX_POWER_CCK_FIRST; c < WL_NUM_RATES_CCK; c++, r++)
		power->reg_limit[r] = txpwr.cck[c];

	/* 20 MHz OFDM SISO tx power limits */
	for (c = 0, r = WL_TX_POWER_OFDM20_FIRST; c < WL_NUM_RATES_OFDM; c++, r++)
		power->reg_limit[r] = txpwr.ofdm[c];

	if (WLC_PHY_11N_CAP(wlc->band)) {
		/* 20 MHz OFDM CDD tx power limits */
		for (c = 0, r = WL_TX_POWER_OFDM20_CDD_FIRST; c < WL_NUM_RATES_OFDM; c++, r++)
			power->reg_limit[r] = txpwr.ofdm_cdd[c];

		/* 40 MHz OFDM SISO tx power limits */
		for (c = 0, r = WL_TX_POWER_OFDM40_FIRST; c < WL_NUM_RATES_OFDM; c++, r++)
			power->reg_limit[r] = txpwr.u40.n.siso[c];

		/* tx power limits for 20MHz MCS0-7 SISO or 1 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_20_S1x1_FIRST : WL_TX_POWER_MCS20_SISO_FIRST;
		ptxpwr = ishtphy ? txpwr.u20.ht.s1x1 : txpwr.u20.n.siso;
		for (c = 0, r = WL_TX_POWER_MCS20_SISO_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			 c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 20MHz MCS0-7 CDD or 2 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_20_S1x2_FIRST : WL_TX_POWER_MCS20_CDD_FIRST;
		ptxpwr = ishtphy ? txpwr.u20.ht.s1x2 : txpwr.u20.n.cdd;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 20MHz MCS0-7 STBC or 3 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_20_S1x3_FIRST : WL_TX_POWER_MCS20_STBC_FIRST;
		ptxpwr = ishtphy ? txpwr.ht.u20s1x3 : txpwr.u20.n.stbc;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 20MHz MCS8-15 SDM or 2 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_20_S2x2_FIRST : WL_TX_POWER_MCS20_SDM_FIRST;
		ptxpwr = ishtphy ? txpwr.u20.ht.s2x2 : txpwr.u20.n.sdm;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* 40 MHz OFDM CDD tx power limits */
		for (c = 0, r = WL_TX_POWER_OFDM40_CDD_FIRST; c < WL_NUM_RATES_OFDM; c++, r++)
			power->reg_limit[r] = txpwr.u40.n.cdd[c];

		/* tx power limits for 40MHz MCS0-7 SISO or 1 Tx Chain */
		offset = ishtphy ? WL_TX_POWER_40_S1x1_FIRST : WL_TX_POWER_MCS40_SISO_FIRST;
		ptxpwr = ishtphy ? txpwr.u40.ht.s1x1 : txpwr.u40.n.siso;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 40MHz MCS0-7 CDD or 2 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_40_S1x2_FIRST : WL_TX_POWER_MCS40_CDD_FIRST;
		ptxpwr = ishtphy ? txpwr.u40.ht.s1x2 : txpwr.u40.n.cdd;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 40MHz MCS0-7 STBC or 3 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_40_S1x3_FIRST : WL_TX_POWER_MCS40_STBC_FIRST;
		ptxpwr = ishtphy ? txpwr.ht.u40s1x3 : txpwr.u40.n.stbc;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* tx power limits for 40MHz MCS8-15 SDM or 2 Tx Chains */
		offset = ishtphy ? WL_TX_POWER_40_S2x2_FIRST : WL_TX_POWER_MCS40_SDM_FIRST;
		ptxpwr = ishtphy ? txpwr.u40.ht.s2x2 : txpwr.u40.n.sdm;
		for (c = 0, r = offset; c < WL_NUM_RATES_MCS_1STREAM; c++, r++)
			power->reg_limit[r] = ptxpwr[c];

		/* MCS 32 */
		power->reg_limit[WL_TX_POWER_MCS_32] = txpwr.mcs32;
#ifdef HTCONF
		if (ishtphy) {
			power->flags |= WL_TX_POWER_F_HT;

			/* tx power limits for 20MHz MCS8-15 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20_S2x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht.u20s2x3[c];

			/* tx power limits for 20MHz MCS16-23 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20_S3x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.u20.ht.s3x3[c];

			/* tx power limits for 40MHz MCS8-15 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_40_S2x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht.u40s2x3[c];

			/* tx power limits for 40MHz MCS16-23 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_40_S3x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.u40.ht.s3x3[c];

			/* CCK tx power limits */
			for (c = 0, r = WL_TX_POWER_20UL_CCK_FIRST; c < WL_NUM_RATES_CCK;
			     c++, r++)
				power->reg_limit[r] = txpwr.cck_20ul[c];
			/* 20 in 40MHz OFDM tx power limits */
			for (c = 0, r = WL_TX_POWER_20UL_OFDM_FIRST; c < WL_NUM_RATES_OFDM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ofdm_20ul[c];

			/* 20 in 40MHz OFDM tx power limits */
			for (c = 0, r = WL_TX_POWER_20UL_OFDM_CDD_FIRST; c < WL_NUM_RATES_OFDM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ofdm_20ul_cdd[c];

			/* tx power limits for 20 in 40MHz MCS0-7 with 1 Tx Chain */
			for (c = 0, r = WL_TX_POWER_20UL_S1x1_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht20ul.s1x1[c];

			/* tx power limits for 20 in 40MHz MCS0-7 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20UL_S1x2_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht20ul.s1x2[c];

			/* tx power limits for 20 in 40MHz MCS0-7 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20UL_S1x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht.ul20s1x3[c];

			/* tx power limits for 20 in 40MHz MCS8-15 with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20UL_S2x2_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht20ul.s2x2[c];
			/* tx power limits for 20 in 40MHz MCS8-15 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20UL_S2x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht.ul20s2x3[c];
			/* tx power limits for 20 in 40MHz MCS8-15 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_20UL_S3x3_FIRST; c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.ht20ul.s3x3[c];
			/* tx power limits for 20 MHz CCK CDD with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_CCK_CDD_S1x2_FIRST; c < WL_NUM_RATES_CCK;
			     c++, r++)
				power->reg_limit[r] = txpwr.cck_cdd.s1x2[c];
			/* tx power limits for 20 MHz CCK CDD with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_CCK_CDD_S1x3_FIRST; c < WL_NUM_RATES_CCK;
			     c++, r++)
				power->reg_limit[r] = txpwr.cck_cdd.s1x3[c];
			/* tx power limits for 20 in 40MHz CCK CDD with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_CCK_20U_CDD_S1x2_FIRST; c < WL_NUM_RATES_CCK;
			     c++, r++)
				power->reg_limit[r] = txpwr.cck_20ul_cdd.s1x2[c];
			/* tx power limits for 20 in 40MHz CCK CDD with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_CCK_20U_CDD_S1x3_FIRST; c < WL_NUM_RATES_CCK;
			     c++, r++)
				power->reg_limit[r] = txpwr.cck_20ul_cdd.s1x3[c];
#ifdef NOT_YET
			/* tx power limits for 20 MHz STBC MCS0-7 with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_S2x2_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.s2x2[c];
			/* tx power limits for 20 MHz STBC MCS0-7 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_S2x3_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.s2x3[c];
			/* tx power limits for 40 MHz STBC MCS0-7 with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_40_S2x2_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.u40_s2x2[c];
			/* tx power limits for 40 MHz STBC MCS0-7 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_40_S2x3_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.u40_s2x3[c];
			/* tx power limits for 20 in 40MHz STBC MCS0-7 with 2 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_UL20_S2x2_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.ul20_s2x2[c];
			/* tx power limits for 20 in 40MHz STBC MCS0-7 with 3 Tx Chains */
			for (c = 0, r = WL_TX_POWER_HT_STBC_UL20_S2x3_FIRST;
				c < WL_NUM_RATES_MCS_1STREAM;
			     c++, r++)
				power->reg_limit[r] = txpwr.stbc.ul20_s2x3[c];
#endif /* NOT_YET */
		}
#endif /* HTCONF */
	}

	wlc_phy_txpower_get_current(wlc->band->pi, power, CHSPEC_CHANNEL(power->chanspec));

	/* copy the tx_power_t struct to the return buffer,
	 * or convert to a tx_power_legacy_t struct
	 */
	if (!old_power) {
		bcopy(power, pwr, sizeof(tx_power_t));
	} else {
		int band_idx = CHSPEC_IS2G(power->chanspec) ? 0 : 1;

		bzero(old_power, sizeof(tx_power_legacy_t));

		old_power->txpwr_local_max = power->local_max;
		old_power->txpwr_local_constraint = power->local_constraint;
		if (CHSPEC_IS2G(power->chanspec)) {
			old_power->txpwr_chan_reg_max = txpwr.cck[0];
			old_power->txpwr_est_Pout[band_idx] = power->est_Pout_cck;
			old_power->txpwr_est_Pout_gofdm = power->est_Pout[0];
		} else {
			old_power->txpwr_chan_reg_max = txpwr.ofdm[0];
			old_power->txpwr_est_Pout[band_idx] = power->est_Pout[0];
		}
		old_power->txpwr_antgain[0] = power->antgain[0];
		old_power->txpwr_antgain[1] = power->antgain[1];

		for (r = 0; r < NUM_PWRCTRL_RATES; r++) {
			old_power->txpwr_band_max[r] = power->user_limit[r];
			old_power->txpwr_limit[r] = power->reg_limit[r];
			old_power->txpwr_target[band_idx][r] = power->target[r];
			if (CHSPEC_IS2G(power->chanspec))
				old_power->txpwr_bphy_cck_max[r] = power->board_limit[r];
			else
				old_power->txpwr_aphy_max[r] = power->board_limit[r];
		}
	}

	MFREE(wlc->osh, power, sizeof(tx_power_t));
	return 0;
}
//#endif 

static uint32
wlc_get_chan_info(wlc_info_t *wlc, uint16 old_chanspec)
{
	uint32 result;
	uint channel = CHSPEC_CHANNEL(old_chanspec);
	chanspec_t chspec = CH20MHZ_CHSPEC(channel);

	result = 0;
	if (channel && channel < MAXCHANNEL) {
		if ((channel <= CH_MAX_2G_CHANNEL) && isset(chanvec_all_2G.vec, channel))
			result |= WL_CHAN_VALID_HW;
		else if ((channel > CH_MAX_2G_CHANNEL) && isset(chanvec_all_5G.vec, channel))
			result |= WL_CHAN_VALID_HW | WL_CHAN_BAND_5G;
	}

	if (result & WL_CHAN_VALID_HW) {
		if (wlc_valid_chanspec_db(wlc->cmi, chspec))
			result |= WL_CHAN_VALID_SW;

		if (AP_ENAB(wlc->pub)) {
			if (wlc->ap->chan_blocked[channel]) {
				int minutes;

				result |= WL_CHAN_INACTIVE;

				/* Store remaining minutes until channel comes
				 * in-service in high 8 bits.
				 */
				minutes = ROUNDUP(wlc->ap->chan_blocked[channel], 60) / 60;
				result |= ((minutes & 0xff) << 24);
			}
		}

		if (result & WL_CHAN_VALID_SW) {
			if (wlc_radar_chanspec(wlc->cmi, chspec) == TRUE)
				result |= WL_CHAN_RADAR;
			if (wlc_restricted_chanspec(wlc->cmi, chspec))
				result |= WL_CHAN_RESTRICTED;
			if (wlc_quiet_chanspec(wlc->cmi, chspec))
				result |= WL_CHAN_PASSIVE;
		}
	}

	return (result);
}

#ifdef CCA_STATS
static void
BCMATTACHFN(cca_init_stats)(wlc_info_t *wlc)
{
	int i;
	cca_info_t *cca;

	static const chanspec_t chanlist[] = {
		0x2b01, 0x2b02, 0x2b03, 0x2b04, 0x2b05, 0x2b06,
		0x2b07, 0x2b08, 0x2b09, 0x2b0a, 0x2b0b, 0x2b0c, 0x2b0d, 0x2b0e, /*   1 - 11  */
		0x1b24, 0x1b28, 0x1b2c, 0x1b30, 0x1b34, 0x1b38, 0x1b3c, 0x1b40, /*  36 - 64  */
		0x1b64, 0x1b68, 0x1b6c, 0x1b70, 0x1b74, 0x1b78, 0x1b7c, 0x1b80, /* 100 - 128 */
		0x1b84, 0x1b88, 0x1b8c,						/* 132 - 140 */
		0x1b95, 0x1b99, 0x1b9d, 0x1ba1, 0x1ba5				/* 149 - 165 */
	};

	if (!wlc->cca_info)
		return;

	/* Not supported in revs < 15 */
	if (D11REV_LT(wlc->pub->corerev, 15)) {
		MFREE(wlc->osh, wlc->cca_info, sizeof(cca_info_t));
		wlc->cca_info = NULL;
		return;
	}

	cca = wlc->cca_info;
	cca->wlc = wlc;
	cca->cca_second_max = MAX_CCA_SECS;
	cca->cca_second = 0;
	bzero(&cca->last_cca_stats, sizeof(cca->last_cca_stats));

	for (i = 0; i < MAX_CCA_CHANNELS; i++)
		cca->chan_stats[i].chanspec = chanlist[i];
	for (i = 0; i < CCA_POOL_MAX; i++)
		cca->cca_pool[i].congest_ibss = CCA_FREE_BUF;
}

/* Setup a new second for this chanspec_idx */
static void
cca_alloc_pool(cca_info_t *cca, int ch_idx, int second)
{
	int i;

	/* The zero'th entry is reserved, Its like a NULL pointer, give it out for failure */
	for (i = 1; i < CCA_POOL_MAX && cca->cca_pool[i].congest_ibss != CCA_FREE_BUF; i++)
		;
	if (i == CCA_POOL_MAX) {
		WL_ERROR(("%s: allocate an entry failed!\n", __FUNCTION__));
		/* Just leave the current bucket in place, nothing else we can do */
		/* Wait til watchdog ages out soem buckets */
		cca->alloc_fail++;
		return;
	}
#ifdef BCMDBG
	if (cca->cca_pool[i].congest_ibss != CCA_FREE_BUF)
		WL_ERROR(("%s:  NULL IDX but not CCA_FREE_BUF ch_idx = %d, dur = 0x%x\n",
			__FUNCTION__, i, cca->cca_pool[i].congest_ibss));
#endif
	bzero(&cca->cca_pool[i], sizeof(wlc_congest_t));
	CCA_POOL_IDX(cca, ch_idx, second) = (cca_idx_t)i & 0xffff;
	return;
}

/* Delete this second from given chanspec_idx */
static void
cca_free_pool(cca_info_t *cca, int ch_idx, int second)
{
	cca_idx_t pool_index = CCA_POOL_IDX(cca, ch_idx, second);
#ifdef BCMDBG
	if (cca->cca_pool[pool_index].congest_ibss == CCA_FREE_BUF)
		WL_ERROR(("%s: Freeing a free buffer\n", __FUNCTION__));
#endif
	cca->cca_pool[pool_index].congest_ibss = CCA_FREE_BUF;
	CCA_POOL_IDX(cca, ch_idx, second) = 0;
}

static int
cca_chanspec_to_index(cca_info_t *cca, chanspec_t chanspec)
{
	int i;
	for (i = 0; i < MAX_CCA_CHANNELS; i++) {
		if (cca->chan_stats[i].chanspec == chanspec)
			return (i);
	}
	return (-1);
}

void
cca_stats_upd(wlc_info_t *wlc, int calculate)
{
	cca_ucode_counts_t tmp;
	int chan;
	chanspec_t chanspec = wf_chspec_ctlchspec(wlc->chanspec);
	cca_info_t *cca = wlc->cca_info;

	if (!cca)
		return;

	if ((chan = cca_chanspec_to_index(cca, chanspec)) < 0) {
		WL_INFORM(("%s: Invalid chanspec 0x%x\n",
			__FUNCTION__, chanspec));
		return;
	}

	if (wlc_bmac_cca_stats_read(wlc->hw, &tmp))
		return;

	if (calculate) {
		/* alloc a new second if needed. */
		if (CCA_POOL_IDX(cca, chan, cca->cca_second) == 0)
			cca_alloc_pool(cca, chan, cca->cca_second);

		if (CCA_POOL_IDX(cca, chan, cca->cca_second) != 0) {
			cca_ucode_counts_t delta;
			wlc_congest_t *stats;

			/* Calc delta */
			delta.txdur = tmp.txdur  - cca->last_cca_stats.txdur;
			delta.ibss  = tmp.ibss   - cca->last_cca_stats.ibss;
			delta.obss  = tmp.obss   - cca->last_cca_stats.obss;
			delta.noctg = tmp.noctg  - cca->last_cca_stats.noctg;
			delta.nopkt = tmp.nopkt  - cca->last_cca_stats.nopkt;
			delta.usecs = tmp.usecs  - cca->last_cca_stats.usecs;
			delta.PM    = tmp.PM     - cca->last_cca_stats.PM;
#ifdef ISID_STATS
			delta.crsglitch = tmp.crsglitch - cca->last_cca_stats.crsglitch;
			delta.badplcp = tmp.badplcp - cca->last_cca_stats.badplcp;
#endif /* ISID_STATS */

			/* Update stats */
			stats = CCA_POOL_DATA(cca, chan, cca->cca_second);
			stats->duration += delta.usecs;
			/* Factor in time MAC was powered down */
			if (BSSCFG_STA(wlc->cfg) && wlc->cfg->pm->PMenabled)
				stats->duration -= delta.PM;
			stats->congest_ibss += delta.ibss + delta.txdur;
			stats->congest_obss += delta.obss + delta.noctg;
			stats->interference += delta.nopkt;
#ifdef ISID_STATS
			stats->crsglitch += delta.crsglitch;
			stats->badplcp += delta.badplcp;
#endif /* ISID_STATS */
			stats->timestamp = OSL_SYSUPTIME();
		}
	}
	/* Store raw values for next read */
	cca->last_cca_stats.txdur = tmp.txdur;
	cca->last_cca_stats.ibss  = tmp.ibss;
	cca->last_cca_stats.obss  = tmp.obss;
	cca->last_cca_stats.noctg = tmp.noctg;
	cca->last_cca_stats.nopkt = tmp.nopkt;
	cca->last_cca_stats.usecs = tmp.usecs;
	cca->last_cca_stats.PM = tmp.PM;
#ifdef ISID_STATS
	cca->last_cca_stats.crsglitch = tmp.crsglitch;
	cca->last_cca_stats.badplcp = tmp.badplcp;
#endif /* ISID_STATS */
}

static void
cca_stats_tsf_upd(wlc_info_t *wlc)
{
	uint32 tsf_l, tsf_h;
	cca_info_t *cca = wlc->cca_info;

	if (!cca)
		return;

	wlc_read_tsf(wlc, &tsf_l, &tsf_h);
	cca->last_cca_stats.usecs = tsf_l;
}

#if defined(BCMDBG_DUMP)
static void
wlc_dump_cca_stats(cca_info_t *cca, struct bcmstrbuf *b)
{
	int chanspec, second;
	char smallbuf[16];
	wlc_congest_t *stats;
	int i, num_free, num_alloced;

	if (!cca)
		return;

	/* Dump the last completed second */
	second = MODDEC(cca->cca_second, cca->cca_second_max);

	num_free = 0;
	num_alloced = 1; /* Count the spare, NULL buffer at index 0 */
	for (i = 1; i < CCA_POOL_MAX; i++) {
		if (cca->cca_pool[i].congest_ibss == CCA_FREE_BUF)
			num_free++;
		if (cca->cca_pool[i].congest_ibss != CCA_FREE_BUF)
			num_alloced++;
	}

	bcm_bprintf(b, "CCA Stats: second %d\n", second);
	bcm_bprintf(b, "  total bufs %d  free %d  alloced %d failures %d\n",
		CCA_POOL_MAX, num_free, num_alloced, cca->alloc_fail);
	bcm_bprintf(b, "chan      ibss          obss         interfere        ts     duration\n");

	for (chanspec = 0; chanspec < MAX_CCA_CHANNELS; chanspec++) {
		if (CCA_POOL_IDX(cca, chanspec, second) == 0)
			continue;
		stats = CCA_POOL_DATA(cca, chanspec, second);
		if (stats->congest_ibss == CCA_FREE_BUF)
			WL_ERROR(("%s: Should not be CCA_FREE_BUF\n", __FUNCTION__));
		if (stats->duration) {
			bcm_bprintf(b, "%-4s %10u %2d%% %10u %2d%% %10u %2d%%      %d     %u \n",
				wf_chspec_ntoa(cca->chan_stats[chanspec].chanspec, smallbuf),
				stats->congest_ibss,
				(stats->congest_ibss * 100)/stats->duration,
				stats->congest_obss,
				(stats->congest_obss * 100)/stats->duration,
				stats->interference,
				(stats->interference * 100)/stats->duration,
				stats->timestamp, stats->duration);
		}
	}
}
#endif 

static void
cca_free_stats(wlc_info_t *wlc)
{
	int secs;
	chanspec_t chanspec;
	cca_info_t *cca = wlc->cca_info;

	if (!cca)
		return;
	for (secs = 0; secs < cca->cca_second_max; secs++) {
		for (chanspec = 0; chanspec < MAX_CCA_CHANNELS; chanspec++) {
			if (CCA_POOL_IDX(cca, chanspec, secs) != 0)
				cca_free_pool(cca, chanspec, secs);
		}
	}
}

static void
cca_stats_watchdog(cca_info_t *cca, chanspec_t cur_chanspec)
{
	int ch_idx;
	chanspec_t chanspec = wf_chspec_ctlchspec(cur_chanspec);

	if (!cca)
		return;

	/* Bump the global 'second' pointer */
	cca->cca_second = MODINC(cca->cca_second, cca->cca_second_max);

	if ((ch_idx = cca_chanspec_to_index(cca, chanspec)) < 0) {
		WL_ERROR(("%s: Bad chanspec!!\n", __FUNCTION__));
		return;
	}

	/* The 'seconds' buffer wraps, so if we are coming to this particular
	   second again, free the previous contents.  Essentially this frees
	   buffers that are 61 seconds old
	*/
	for (chanspec = 0; chanspec < MAX_CCA_CHANNELS; chanspec++) {
		if (CCA_POOL_IDX(cca, chanspec, cca->cca_second) != 0)
			cca_free_pool(cca, chanspec, cca->cca_second);
	}

	/* Allocate new second for current channel */
	cca_alloc_pool(cca, ch_idx, cca->cca_second);
}

static int
cca_query_stats(cca_info_t *cca, chanspec_t chanspec, int nsecs,
	wlc_congest_channel_req_t *stats_results, int buflen)
{
	int secs_done, ch_idx, second;
	wlc_congest_t *congest;

	if (!cca)
		return 0;

	second = cca->cca_second;
	nsecs = MIN(cca->cca_second_max, nsecs);

	if ((ch_idx = cca_chanspec_to_index(cca, chanspec)) < 0) {
		stats_results->num_secs = 0;
		stats_results->chanspec = 0;
		return 0;
	}

	stats_results->chanspec = chanspec;
	buflen -= OFFSETOF(cca_congest_channel_req_t, secs);

	/* Retreive the last x secs of measurements */
	for (secs_done = 0; (secs_done < nsecs) && buflen >= sizeof(wlc_congest_t); secs_done++) {
		second = MODDEC(second, cca->cca_second_max);

		/* If the entry for this second/channel is empty, CCA_POOL_IDX
		   will be zero, and CCA_POOL_DATA will be the zero'th entry
		   which we keep empty for this purpose
		*/
		congest = CCA_POOL_DATA(cca, ch_idx, second);

		stats_results->secs[secs_done].duration =
			(congest->duration + 500)/1000;
		stats_results->secs[secs_done].congest_ibss =
			(congest->congest_ibss + 500)/1000;
		stats_results->secs[secs_done].congest_obss =
			(congest->congest_obss + 500)/1000;
		stats_results->secs[secs_done].interference =
			(congest->interference + 500)/1000;
		stats_results->secs[secs_done].timestamp =
			(congest->timestamp + 500)/1000;
#ifdef ISID_STATS
		stats_results->secs[secs_done].crsglitch =
			congest->crsglitch;
		stats_results->secs[secs_done].badplcp =
			congest->badplcp;
#endif /* ISID_STATS */

		buflen -= sizeof(wlc_congest_t);
	}
	stats_results->num_secs = (uint8)(secs_done & 0xff);
	return 0;
}

static int
cca_get_stats(cca_info_t *cca, void *input, int buf_len, void *output)
{
	int nsecs;
	chanspec_t chanspec;
	cca_congest_channel_req_t *req = (cca_congest_channel_req_t *)input;
	cca_congest_channel_req_t *stats_results = (cca_congest_channel_req_t *)output;
	wlc_congest_channel_req_t *results;
	int result_len;
	int status;

	if (!cca)
		return BCME_UNSUPPORTED;

	if (wf_chspec_malformed(req->chanspec))
		return BCME_BADCHAN;

	chanspec = wf_chspec_ctlchspec(req->chanspec);
	nsecs = req->num_secs;

	result_len = sizeof(wlc_congest_channel_req_t) +
		((nsecs ? nsecs - 1 : nsecs) * sizeof(wlc_congest_t));
	if (!(results = (wlc_congest_channel_req_t*)MALLOC(cca->wlc->osh, result_len)))
		return BCME_NOMEM;
	bzero(results, result_len);

	status = cca_query_stats(cca, chanspec, nsecs, results, result_len);

	if (status == 0) {
		int i;
		wlc_congest_t *wlc_congest = results->secs;
		cca_congest_t *cca_congest = stats_results->secs;
		stats_results->chanspec = results->chanspec;
		stats_results->num_secs = results->num_secs;
		for (i = 0; i < nsecs; i++) {
			cca_congest[i].duration = wlc_congest[i].duration;
			cca_congest[i].congest_ibss = wlc_congest[i].congest_ibss;
			cca_congest[i].congest_obss = wlc_congest[i].congest_obss;
			cca_congest[i].interference = wlc_congest[i].interference;
			cca_congest[i].timestamp = wlc_congest[i].timestamp;
		}
	}

	MFREE(cca->wlc->osh, results, result_len);

	return status;
}

#ifdef ISID_STATS
/* state */
typedef enum {
	ITFR_STATE_CLEAN,
	ITFR_STATE_SCAN,
	ITFR_STATE_SCAN_COMPLETED,
	ITFR_STATE_IDENTIFIED,
	ITFR_STATE_STOPPED
} itfr_state_t;

#ifdef BCMDBG
/* need keeping sync with interference_source in wlioctl.h */
static char *itf_source_str[] = {
	"no interference",
	"wireless phone",
	"video camera",
	"microwave oven",
	"baby monitor",
	"bluetooth",
	"video camera or baby monitor",
	"bluetooth or baby monitor",
	"video camera or phone",
	"unidentified"
};

static char *itfr_state_str[] =
	{"clean", "scan", "scan completed", "identified", "stopped"};
#endif /* BCMDBG */

/* interference data pattern */
typedef struct {
	uint32 source;	/* interference source */
	uint32 min_intensity;	/* min interference intensity to trigger matching */
	uint32 max_intensity;	/* max valid interference intensity */
	uint32 intensity_floor;	/* clean interference intensity gap below min_intensity */
	uint32 min_intensity_diff;	/* min min-max interference intensity diff */
	uint32 min_crsglitch;	/* min CRS glitchs */
	uint32 max_crsglitch;	/* max CRS glitchs */
	uint32 min_badplcp;		/* min bad plcp */
	uint32 max_badplcp;		/* max bad plcp */
	uint8 min_trigger_chs;	/* min num of chs interference over min intensity */
	uint8 max_trigger_chs;	/* max num of chs interference over min intensity */
	uint8 min_passing_chs;	/* min num of chs passing all checks */
	bool max_intensity_on_passing_ch;	/* max intensity must be on a passing channel */
	bool seq_passing_chs;	/* passing channels must be sequential */
} itfr_data_pattern_t;

/* 4312 interference data pattern */
static itfr_data_pattern_t itfr_4312_pattern[] = {
/* Uniden phone */
{ITFR_PHONE, 800, 1500, 200, 700, 300, 1000, 0, 300, 1, 2, 1, FALSE, TRUE},
/* Lorex and Swann video camera or Vtech phone */
{ITFR_VIDEO_CAMERA_OR_PHONE, 700, 1500, 700, 0, 10, (uint32)(-1), 0, (uint32)(-1), 3, 8, 3,
FALSE, TRUE},
/* Microwave oven */
{ITFR_MICROWAVE_OVEN, 300, 700, 300, 250, 150, 3000, 0, (uint32)(-1), 2, 4, 2, FALSE, TRUE},
/* Baby monitor */
{ITFR_BABY_MONITOR, 200, 1500, 200, 0, 200, (uint32)(-1), 0, (uint32)(-1), 4, CH_MAX_2G_CHANNEL,
5, FALSE, FALSE},
/* Bluetooth */
{ITFR_BLUETOOTH, 100, 400, 100, 0, 100, 500, 0, 1000, 1, CH_MAX_2G_CHANNEL, 1, FALSE, FALSE},
/* Unidentified */
{ITFR_UNIDENTIFIED, 0, 1500, (uint32)(-1), 0, 0, (uint32)(-1), 0, (uint32)(-1), 0,
CH_MAX_2G_CHANNEL, 0, FALSE, FALSE}
};

/* 4313 interference data pattern */
static itfr_data_pattern_t itfr_4313_pattern[] = {
/* Uniden phone */
{ITFR_PHONE, 850, 1500, 150, 700, 300, 1000, 0, 10, 1, 1, 1, FALSE, FALSE},
/* VTech phone */
{ITFR_PHONE, 800, 1500, 100, 700, 300, 1000, 0, 100, 3, 3, 3, FALSE, TRUE},
/* Lorex and Swann video camera */
{ITFR_VIDEO_CAMERA, 700, 1500, 700, 0, 10, (uint32)(-1), 0, (uint32)(-1), 3, 8, 3, FALSE, TRUE},
/* Microwave oven */
{ITFR_MICROWAVE_OVEN, 500, 900, 500, 250, 150, 20000, 0, 1000, 2, 6, 2, FALSE, TRUE},
/* Microwave oven */
{ITFR_MICROWAVE_OVEN, 350, 700, 350, 250, 50, 3000, 0, (uint32)(-1), 2, 4, 2, FALSE, TRUE},
/* Baby monitor */
{ITFR_BABY_MONITOR, 200, 1500, 200, 0, 200, (uint32)(-1), 0, (uint32)(-1), 5, CH_MAX_2G_CHANNEL,
5, FALSE, FALSE},
/* Bluetooth */
{ITFR_BLUETOOTH, 100, 400, 100, 0, 100, 500, 0, 1000, 1, CH_MAX_2G_CHANNEL, 1, FALSE, FALSE},
/* Unidentified */
{ITFR_UNIDENTIFIED, 0, 1500, (uint32)(-1), 0, 0, (uint32)(-1), 0, (uint32)(-1), 0,
CH_MAX_2G_CHANNEL, 0, FALSE, FALSE}
};

/* 43224 interference data pattern */
static itfr_data_pattern_t itfr_43224_pattern[] = {
/* Uniden phone */
{ITFR_PHONE, 250, 1500, 100, 200, 8000, (uint32)(-1), 0, 100, 1, 1, 1, FALSE, FALSE},
/* VTech phone */
{ITFR_PHONE, 250, 1500, 250, 200, 1000, (uint32)(-1), 0, 1000, 2, 3, 2, FALSE, TRUE},
/* Microwave oven */
{ITFR_MICROWAVE_OVEN, 100, 500, 100, 100, 9000, (uint32)(-1), 0, 1000, 1, 5, 1, TRUE, TRUE},
/* Microwave oven */
{ITFR_MICROWAVE_OVEN, 300, 600, 300, 200, 10000, (uint32)(-1), 1000, (uint32)(-1), 1, 2, 1,
TRUE, TRUE},
/* Video camera or baby monitor */
{ITFR_VIDEO_CAMERA_OR_BABY_MONITOR, 300, 1500, 300, 0, 400, 1000000, 300, (uint32)(-1), 1,
CH_MAX_2G_CHANNEL, 1, FALSE, FALSE},
/* Bluetooth or baby video monitor */
{ITFR_BLUETOOTH_OR_BABY_MONITOR, 50, 400, 50, 0, 400, 1000000, 300, (uint32)(-1), 1,
CH_MAX_2G_CHANNEL, 1, FALSE, FALSE},
/* Unidentified */
{ITFR_UNIDENTIFIED, 0, 1500, (uint32)(-1), 0, 0, (uint32)(-1), 0, (uint32)(-1), 0,
CH_MAX_2G_CHANNEL, 0, FALSE, FALSE}
};

/* interference info collected from a channel */
typedef struct {
	uint32 intensity;	/* interference intensity */
	uint32 crsglitch;	/* CRS glitchs */
	uint32 badplcp;		/* bad plcps */
	bool interference;	/* set if intesity over value in data pattern */
} itfr_sample_t;

/* default definitions.  time definitions are in seconds except specified */
#define ITFR_SAMPLE_TM		5	/* sample time */
#define ITFR_SCAN_SAMPLE_TM	50	/* sample time in ms per channel during detection scan */
#define ITFR_MAX_VERIFIES	3	/* max number of verifies */
#define ITFR_THRESHOLD		50	/* interference threshold to trigger source detection */
#define ITFR_ID_HOLD_TM		60	/* hold time for identified source before re-detection */
#define ITFR_NON_ID_HOLD_TM	10	/* hold time for non-identified interference source */
#define ITFR_STOP_HOLD_TM	180	/* hold time for stop before restart */
#define ITFR_MAX_NETS		20	/* max nets allowed or feature disabled */
#define ITFR_MIN_CLEAN_TM	10	/* min clean time before changing state to clean */

/* min/max settings for iovars */
#define ITFR_MAX_MODE	ITFR_MODE_AUTO_ENABLE
#define ITFR_MIN_THRESHOLD	30
#define ITFR_MAX_THRESHOLD	0xffff
#define ITFR_MIN_ID_HOLD_TM	1
#define ITFR_MAX_ID_HOLD_TM	0xffff
#define ITFR_MIN_NON_ID_HOLD_TM	1
#define ITFR_MAX_NON_ID_HOLD_TM	0xffff
#define ITFR_MIN_STOP_HOLD_TM	1
#define ITFR_MAX_STOP_HOLD_TM	0xffff

static void
itfr_init_stats(wlc_info_t *wlc)
{
	cca_info_t *cca = wlc->cca_info;
	itfr_info_t *itfr = wlc->itfr_info;
	uint8 i, j;

	/* check if feature is supported */
	if (!cca || !itfr || D11REV_LT(wlc->pub->corerev, 15) ||
		CHIPID(wlc->pub->sih->chip) == BCM4312_CHIP_ID) {
		if (itfr) {
			MFREE(wlc->osh, itfr, sizeof(itfr_info_t));
			wlc->itfr_info = NULL;
		}
		return;
	}

	/* init variables */
	itfr->source = ITFR_NONE;
	itfr->last_source = ITFR_NONE;
	itfr->state = ITFR_STATE_CLEAN;
	itfr->threshold = ITFR_THRESHOLD;
	itfr->max_nets = ITFR_MAX_NETS;
	itfr->min_clean_tm = ITFR_MIN_CLEAN_TM;
	itfr->id_hold_tm = ITFR_ID_HOLD_TM;
	itfr->non_id_hold_tm = ITFR_NON_ID_HOLD_TM;
	itfr->stop_hold_tm = ITFR_STOP_HOLD_TM;
	if (CHIPID(wlc->pub->sih->chip) == BCM4312_CHIP_ID)
		itfr->no_aci = TRUE;

	/* init report */
	itfr->report.flags = 0;
	itfr->report.source = ITFR_NONE;
	itfr->report.timestamp = OSL_SYSUPTIME();

	/* feature is disabled by default */
	itfr->op_mode = ITFR_MODE_DISABLE;
}

/* reset interference detection and identification state */
static void
itfr_reset_state(wlc_info_t *wlc, bool verify)
{
	itfr_info_t *itfr = wlc->itfr_info;

	itfr->detect_req = FALSE;

	/* if in scan, abort it */
	if (itfr->state == ITFR_STATE_SCAN)
		wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);

	/* reset variables */
	itfr->clean_tm = 0;
	itfr->reset_tm = 0;
	itfr->source = ITFR_NONE;
	if (!verify) {
		/* clean verifying variables */
		itfr->verify_pending = 0;
		itfr->last_source = ITFR_NONE;
		if (itfr->no_aci && itfr->aci_mode_configed) {
			/* restore aci setting */
			wlc_set(wlc, WLC_SET_INTERFERENCE_MODE, itfr->org_aci_val);
			itfr->aci_mode_configed = FALSE;
		}
	}
	/* reset state */
	itfr->state = ITFR_STATE_CLEAN;
}

/* set operation mode */
static int
itfr_set_mode(wlc_info_t *wlc, int mode)
{
	itfr_info_t *itfr = wlc->itfr_info;

	if (!itfr)
		return BCME_UNSUPPORTED;
	else if (mode > ITFR_MAX_MODE)
		return BCME_BADARG;

	/* reset state */
	itfr_reset_state(wlc, FALSE);
	/* set mode */
	itfr->op_mode = mode;

	return BCME_OK;
}

/* handle interference detection request from iovar */
static int
itfr_detect_req(wlc_info_t *wlc)
{
	itfr_info_t *itfr = wlc->itfr_info;

	if (!itfr || itfr->op_mode == ITFR_MODE_DISABLE)
		return BCME_UNSUPPORTED;

	/* reset state */
	itfr_reset_state(wlc, FALSE);
	/* set flag for pending detection */
	itfr->detect_req = TRUE;

	wlc->mpc_scan = TRUE;

	if (!wlc->pub->up)
		/* make wlc up for scan and watchdog */
		wlc_radio_mpc_upd(wlc);

	if (!wlc->pub->up) {
		WL_ERROR(("itfr_detect_req: wl up failed\n"));
		return BCME_NOTUP;
	}

	WL_ITFR(("itfr_detect_req: detect interference per user's request\n"));

	return BCME_OK;
}

/* handle interference detection abortion request from iovar */
static int
itfr_abort_req(wlc_info_t *wlc)
{
	itfr_info_t *itfr = wlc->itfr_info;

	if (!itfr || itfr->op_mode == ITFR_MODE_DISABLE)
		return BCME_UNSUPPORTED;

	/* reset state to abort any activities */
	itfr_reset_state(wlc, FALSE);

	return BCME_OK;
}

static int
itfr_set_net_thres_req(wlc_info_t *wlc, int val)
{
	itfr_info_t *itfr = wlc->itfr_info;

	if (!itfr)
		return BCME_UNSUPPORTED;

	/* reset state */
	itfr_reset_state(wlc, FALSE);
	/* set net threshold */
	itfr->max_nets = (uint16)val;

	return BCME_OK;
}

static int
itfr_get_stats(itfr_info_t *itfr, interference_source_rep_t* rep)
{
	if (!itfr || itfr->op_mode == ITFR_MODE_DISABLE)
		return BCME_UNSUPPORTED;

	/* if request is not completed */
	if (itfr->detect_req)
		return BCME_BUSY;

	*rep = itfr->report;

	return BCME_OK;
}

/* interference detection scan completion handler */
static void
itfr_scan_complete(void *arg, int status, wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = (wlc_info_t*)arg;
	itfr_info_t *itfr = wlc->itfr_info;

	if (itfr->state != ITFR_STATE_SCAN)
		return;

	itfr->state = ITFR_STATE_SCAN_COMPLETED;

	if (status == WLC_E_STATUS_SUCCESS) {
		/* check num of networks */
		if (wlc->scan_results->count > itfr->max_nets) {
			itfr_reset_state(wlc, FALSE);
			itfr->reset_tm = wlc->pub->now + itfr->stop_hold_tm;
			itfr->state = ITFR_STATE_STOPPED;
			/* report noisy environment */
			itfr->report.flags |= ITFR_NOISY_ENVIRONMENT;
		}
	} else {
		if (itfr->detect_req)
			/* re-issue request */
			itfr_detect_req(wlc);
		else
			/* restart */
			itfr_reset_state(wlc, (itfr->verify_pending != 0));
	}
}

static int
itfr_scan_request(wlc_info_t *wlc)
{
	itfr_info_t *itfr = wlc->itfr_info;
	wlc_ssid_t req_ssid;

	/* disable aci if needed */
	if (itfr->no_aci && !itfr->aci_mode_configed) {
		if (!wlc_get(wlc, WLC_GET_INTERFERENCE_MODE, &itfr->org_aci_val)) {
			if (itfr->org_aci_val == NON_WLAN ||
				((itfr->org_aci_val == WLAN_AUTO ||
				itfr->org_aci_val == WLAN_AUTO_W_NOISE) &&
				itfr->org_aci_val & AUTO_ACTIVE)) {
				itfr->org_aci_val &= ~AUTO_ACTIVE;
				/* disable aci */
				wlc_set(wlc, WLC_SET_INTERFERENCE_MODE, INTERFERE_NONE);
				itfr->aci_mode_configed = TRUE;
			}
		} else {
			WL_ERROR(("itfr_scan_request: get aci mode error\n"));
			return BCME_ERROR;
		}
	}

	bzero(&req_ssid, sizeof(req_ssid));
	/* start active scan to collect interference info and ap info */
	return wlc_scan_request(wlc, DOT11_BSSTYPE_ANY, &ether_bcast, 1,
		&req_ssid, DOT11_SCANTYPE_ACTIVE, -1, ITFR_SCAN_SAMPLE_TM,
		ITFR_SCAN_SAMPLE_TM, ITFR_SCAN_SAMPLE_TM, itfr->chanlist,
		itfr->chan_num, FALSE, itfr_scan_complete, wlc);
}

/* fill out interference report */
static void
itfr_report(wlc_info_t *wlc, bool interference, bool home_channel,
	uint32 source)
{
	itfr_info_t *itfr = wlc->itfr_info;
	interference_source_rep_t *report = &itfr->report;

	if (itfr->report.flags & ITFR_NOISY_ENVIRONMENT)
		/* clear noisy environment flag since we have report */
		itfr->report.flags &= ~ITFR_NOISY_ENVIRONMENT;
	/* done if no change */
	else if ((interference && (report->flags & ITFR_INTERFERENCED) &&
		source == report->source &&
		(home_channel == ((report->flags & ITFR_HOME_CHANNEL) != 0))) ||
		(!interference && !(report->flags & ITFR_INTERFERENCED)))
		return;

	/* if not interference, update interference flag and timestamp only
	 * and keep last report info
	 */
	if (interference) {
		report->source = source;
		report->flags |= ITFR_INTERFERENCED;
		if (home_channel)
			report->flags |= ITFR_HOME_CHANNEL;
		else
			report->flags &= ~ITFR_HOME_CHANNEL;
	} else
		report->flags &= ~ITFR_INTERFERENCED;

	report->timestamp = OSL_SYSUPTIME();

	WL_ITFR(("wl%d: itfr_report: interference %s. last source is %s on %s channel"
		" at time %d\n", wlc->pub->unit,
		(report->flags & ITFR_INTERFERENCED) ? "detected" : "not detected",
		itf_source_str[source], (report->flags & ITFR_HOME_CHANNEL) ? "home" : "non-home",
		report->timestamp));
}

static void
itfr_get_valid_2g_channels(wlc_info_t *wlc)
{
	cca_info_t *cca = wlc->cca_info;
	itfr_info_t *itfr = wlc->itfr_info;
	uint8 i, j;

	/* init scan channels */
	for (i = 0, j = 0; i < MAX_CCA_CHANNELS; i++) {
		if (CHSPEC_IS2G(cca->chan_stats[i].chanspec) &&
			wlc_valid_chanspec_db(wlc->cmi, cca->chan_stats[i].chanspec)) {
			itfr->chanlist[j] = cca->chan_stats[i].chanspec;
			j++;
		}
	}
	itfr->chan_num = j;
}

static bool
itfr_get_sample(wlc_info_t *wlc, itfr_sample_t *itfr_sample, uint sample_time)
{
	cca_info_t *cca = wlc->cca_info;
	itfr_info_t *itfr = wlc->itfr_info;
	wlc_congest_channel_req_t *result;
	uint result_len;
	uint i, j;

	result_len = sizeof(wlc_congest_channel_req_t) +
		((sample_time - 1) * sizeof(wlc_congest_t));
	if (!(result = (wlc_congest_channel_req_t*)MALLOC(wlc->osh, result_len))) {
		itfr_reset_state(wlc, FALSE);
		WL_ERROR(("wl%d: itfr_get_sample: out of memory, malloced %d bytes\n",
			wlc->pub->unit, MALLOCED(wlc->osh)));
		return BCME_NOMEM;
	}

	/* sample channels */
	for (i = 0; i < itfr->chan_num; i++) {
		uint32 interference_sum = 0;
		uint32 crsglitch_sum = 0;
		uint32 badplcp_sum = 0;
		uint32 duration_sum = 0;
		uint8 ch = CHSPEC_CHANNEL(itfr->chanlist[i]);
		bzero(result, result_len);
		cca_query_stats(cca, CH20MHZ_CHSPEC(ch), sample_time, result, result_len);

		for (j = 0; j < sample_time; j++) {
			/* update sumaries for this channel */
			interference_sum += result->secs[j].interference;
			crsglitch_sum += result->secs[j].crsglitch;
			badplcp_sum += result->secs[j].badplcp;
			duration_sum += result->secs[j].duration;
		}
		if (duration_sum) {
			/* save averaged values for this channel */
			itfr_sample[ch - 1].intensity = (interference_sum * 1000) / duration_sum;
			itfr_sample[ch - 1].crsglitch = (crsglitch_sum * 1000) / duration_sum;
			itfr_sample[ch - 1].badplcp = (badplcp_sum * 1000) / duration_sum;
		} else
			itfr_sample[ch - 1].intensity = 0;
		itfr_sample[ch - 1].interference =
			(itfr_sample[ch - 1].intensity > itfr->threshold) ? TRUE : FALSE;
		if (itfr->state == ITFR_STATE_SCAN_COMPLETED)
			WL_ITFR(("wl%d: itfr_get_sample: ch %d: intensity %d, crsglitch %d,"
				" badplcp %d, interferenced %d\n", wlc->pub->unit, ch,
				itfr_sample[ch - 1].intensity, itfr_sample[ch - 1].crsglitch,
				itfr_sample[ch - 1].badplcp, itfr_sample[ch - 1].interference));
	}
	MFREE(wlc->osh, result, result_len);

	return BCME_OK;
}

static bool
itfr_match_pattern(itfr_info_t *itfr, itfr_sample_t *itfr_sample,
	itfr_data_pattern_t *itfr_pattern)
{
	uint i, max_match_ch;
	bool ch_source_identified = FALSE, source_identified = FALSE;
	uint32 last_passing_channel = 0, trigger_channels = 0;
	uint32 passing_channels = 0, zero_itfr_channels = 0;
	uint32 min_intensity = (uint32)(-1), max_intensity = 0;
	uint32 max_intensity_on_passing_chs = 0;

	/* limit pattern match up to channel 11 */
	max_match_ch = MIN(11, itfr->chan_num);
	for (i = 0; i < max_match_ch; i++) {
		uint8 ch = CHSPEC_CHANNEL(itfr->chanlist[i]);
		uint32 intensity = itfr_sample[ch - 1].intensity;
		uint32 crsglitch = itfr_sample[ch - 1].crsglitch;
		uint32 badplcp = itfr_sample[ch - 1].badplcp;
		bool interference = itfr_sample[ch - 1].interference;
		if (interference && intensity >= itfr_pattern->min_intensity) {
			if (intensity > itfr_pattern->max_intensity) {
				/* check failed.  check next interference type */
				ch_source_identified = FALSE;
				break;
			}

			/* check if meet per channel pattern */
			if (crsglitch >= itfr_pattern->min_crsglitch &&
				crsglitch <= itfr_pattern->max_crsglitch &&
				badplcp >= itfr_pattern->min_badplcp &&
				badplcp <= itfr_pattern->max_badplcp) {
				if (itfr_pattern->seq_passing_chs &&
					last_passing_channel != 0 &&
					(last_passing_channel + 1) != ch) {
					/* check failed.  check next interference type */
					ch_source_identified = FALSE;
					break;
				}
				last_passing_channel = ch;
				passing_channels++;
				if (intensity > max_intensity_on_passing_chs)
					max_intensity_on_passing_chs = intensity;
				ch_source_identified = TRUE;
			}
			trigger_channels++;
		} else if (intensity > itfr_pattern->intensity_floor) {
			/* check failed.  check next interference type */
			ch_source_identified = FALSE;
			break;
		} else if (intensity == 0)
			zero_itfr_channels++;

		/* update min and max interference intensity variables */
		if (intensity) {
			if (intensity < min_intensity)
				min_intensity = intensity;
			if (intensity > max_intensity)
				max_intensity = intensity;
		}
	}

	/* check if meet per source pattern in addtion to channel pattern */
	if (ch_source_identified &&
		trigger_channels >= itfr_pattern->min_trigger_chs &&
		trigger_channels <= itfr_pattern->max_trigger_chs &&
		passing_channels >= itfr_pattern->min_passing_chs &&
		(max_intensity - min_intensity) >= itfr_pattern->min_intensity_diff &&
		(!itfr_pattern->max_intensity_on_passing_ch ||
		max_intensity == max_intensity_on_passing_chs) &&
		(itfr_pattern->source == ITFR_UNIDENTIFIED ||
		zero_itfr_channels < ((uint32)itfr->chan_num - 2))) {
		itfr->source = (uint8)itfr_pattern->source;
		source_identified = TRUE;
	}

	return source_identified;
}

/* return true if home channel has interference */
static void
itfr_identify_source(wlc_info_t *wlc, itfr_sample_t *itfr_sample)
{
	itfr_info_t *itfr = wlc->itfr_info;
	uint8 ch;
	uint i, patterns;
	itfr_data_pattern_t *itfr_pattern;

	if (CHIPID(wlc->pub->sih->chip) == BCM4312_CHIP_ID) {
		itfr_pattern = itfr_4312_pattern;
		patterns = ARRAYSIZE(itfr_4312_pattern);
	} else if (CHIPID(wlc->pub->sih->chip) == BCM4313_CHIP_ID) {
		itfr_pattern = itfr_4313_pattern;
		patterns = ARRAYSIZE(itfr_4313_pattern);
	} else {
		itfr_pattern = itfr_43224_pattern;
		patterns = ARRAYSIZE(itfr_43224_pattern);
	}
	/* detecting interference source */
	for (i = 0; i < patterns; i++) {
		if (itfr_match_pattern(itfr, itfr_sample, &itfr_pattern[i]))
			break;
	}
}

/* monitor interference on b/g band */
static void
itfr_stats_wd(wlc_info_t *wlc)
{
	itfr_info_t *itfr = wlc->itfr_info;
	itfr_sample_t *itfr_sample;
	uint sample_time;
	uint8 ch, home_ch;
	bool home_ch_interference;
	uint8 interference_chs = 0, zero_interference_chs = 0;
	uint i;

	/* give time to collect cca info when power on */
	if (!itfr || (wlc->pub->now < MAX_CCA_SECS && !itfr->detect_req))
		return;

	if (itfr->op_mode == ITFR_MODE_DISABLE || (!itfr->detect_req &&
		((itfr->op_mode == ITFR_MODE_AUTO_ENABLE && !wlc->pub->associated) ||
		(itfr->op_mode == ITFR_MODE_MANUAL_ENABLE))) ||
		(home_ch = wf_chspec_ctlchan(wlc->home_chanspec)) == 0 ||
		home_ch > CH_MAX_2G_CHANNEL) {
		if (itfr->state != ITFR_STATE_CLEAN || itfr->verify_pending)
			itfr_reset_state(wlc, FALSE);
		return;
	}

	WL_ITFR(("wl%d: itfr_stats_wd: state is %s\n", wlc->pub->unit,
		itfr_state_str[itfr->state]));

	if (itfr->state == ITFR_STATE_IDENTIFIED || itfr->state == ITFR_STATE_STOPPED) {
		/* if holding time expired */
		if (itfr->reset_tm == wlc->pub->now) {
			if (itfr->state == ITFR_STATE_STOPPED)
				/* clear noisy environment flag */
				itfr->report.flags &= ~ITFR_NOISY_ENVIRONMENT;
			/* allow restarting operation */
			itfr_reset_state(wlc, FALSE);
		}

		if (itfr->no_aci && itfr->aci_mode_configed) {
			/* restore aci setting */
			wlc_set(wlc, WLC_SET_INTERFERENCE_MODE, itfr->org_aci_val);
			itfr->aci_mode_configed = FALSE;
		}

		if (itfr->state == ITFR_STATE_STOPPED)
			return;
	}

	if (itfr->state == ITFR_STATE_SCAN)
		/* if scan not complete, wait */
		return;

	/* no interference detection when scan in progress */
	if (itfr->state == ITFR_STATE_CLEAN &&
		(AS_IN_PROGRESS(wlc) || SCAN_IN_PROGRESS(wlc->scan) ||
		WLC_RM_IN_PROGRESS(wlc))) {
		WL_ITFR(("itfr_stats_wd: exit due to other scan in progress\n"));
		return;
	}

	/* get current valid b/g channels */
	itfr_get_valid_2g_channels(wlc);

	/* allocate buffer for interference sample */
	if (!(itfr_sample = (itfr_sample_t*)
		MALLOC(wlc->osh, sizeof(itfr_sample_t) * itfr->chan_num))) {
		itfr_reset_state(wlc, FALSE);
		WL_ERROR(("wl%d: itfr_stats_wd: out of memory, malloced %d bytes\n",
			wlc->pub->unit, MALLOCED(wlc->osh)));
		return;
	}
	bzero(itfr_sample, sizeof(itfr_sample_t) * itfr->chan_num);

	/* select sample time for interference */
	sample_time = (itfr->state == ITFR_STATE_SCAN_COMPLETED) ? 2 : ITFR_SAMPLE_TM;

	/* get interference sample */
	if (itfr_get_sample(wlc, itfr_sample, sample_time) != BCME_OK)
		goto itfr_exit;

	/* collect affected and non-affected channel info */
	for (i = 0; i < itfr->chan_num; i++) {
		ch = CHSPEC_CHANNEL(itfr->chanlist[i]);
		if (itfr_sample[ch - 1].interference)
			interference_chs++;
		if (itfr_sample[ch - 1].intensity == 0)
			zero_interference_chs++;
	}
	home_ch_interference = itfr_sample[home_ch - 1].interference;

	if (itfr->state == ITFR_STATE_SCAN_COMPLETED) {
		/* if sample is invalid */
		if (zero_interference_chs >= (itfr->chan_num - 1)) {
			if (itfr->detect_req)
				/* re-issue request */
				itfr_detect_req(wlc);
			else
				itfr_reset_state(wlc, (itfr->verify_pending != 0));
			goto itfr_exit;
		}

		/* if no interference detected on user request,
		 * report and complete the request
		 */
		if (itfr->detect_req && interference_chs == 0) {
			itfr_report(wlc, FALSE, FALSE, ITFR_NONE);
			itfr_reset_state(wlc, FALSE);
			goto itfr_exit;
		}
	}

	/* check if interference source removed after report interference */
	if (itfr->report.flags & ITFR_INTERFERENCED) {
		/* update clean count */
		if (itfr->report.flags & ITFR_HOME_CHANNEL) {
			if (home_ch_interference)
				itfr->clean_tm = 0;
			else
				itfr->clean_tm++;
		} else if (itfr->state == ITFR_STATE_SCAN_COMPLETED) {
			if ((interference_chs - (home_ch_interference ? 1 : 0)) != 0)
				itfr->clean_tm = 0;
			else
				itfr->clean_tm++;
		}

		/* report and reset state if interference gone for given amount of time */
		if (itfr->clean_tm == itfr->min_clean_tm) {
			itfr_report(wlc, FALSE, FALSE, ITFR_NONE);
			itfr_reset_state(wlc, FALSE);
			goto itfr_exit;
		}
	}

	/* exit if in identified state */
	if (itfr->state == ITFR_STATE_IDENTIFIED)
		goto itfr_exit;

	/* exit if no interference */
	if (interference_chs == 0 && !itfr->detect_req) {
		itfr_reset_state(wlc, FALSE);
		goto itfr_exit;
	}

	/* issue scan if interference detected or on user request */
	if ((itfr_sample[home_ch - 1].interference || itfr->detect_req) &&
		itfr->state == ITFR_STATE_CLEAN) {
		if (itfr_scan_request(wlc) == BCME_OK)
			itfr->state = ITFR_STATE_SCAN;

		goto itfr_exit;
	}

	/* detecting interference source after scan */
	if (itfr->state == ITFR_STATE_SCAN_COMPLETED) {
		/* identify interference source based on samples */
		itfr_identify_source(wlc, itfr_sample);

		/* verify result or identified */
		if (itfr->verify_pending == 0) {
			itfr->verify_pending = ITFR_MAX_VERIFIES;
		} else {
			if (itfr->last_source == itfr->source) {
				itfr->state = ITFR_STATE_IDENTIFIED;
			} else if (--itfr->verify_pending == 0) {
				itfr->source = ITFR_UNIDENTIFIED;
				itfr->state = ITFR_STATE_IDENTIFIED;
			}
		}

		if (itfr->state == ITFR_STATE_IDENTIFIED) {
			/* update report */
			itfr_report(wlc, TRUE, home_ch_interference, itfr->source);
			itfr->verify_pending = 0;
			itfr->clean_tm = 0;
			itfr->detect_req = FALSE;
			if (itfr->op_mode == ITFR_MODE_AUTO_ENABLE) {
				/* hold result for a while */
				if (itfr->source == ITFR_UNIDENTIFIED)
					itfr->reset_tm = wlc->pub->now + itfr->non_id_hold_tm;
				else
					itfr->reset_tm = wlc->pub->now + itfr->id_hold_tm;
			}
			WL_ITFR(("wl%d: itfr_stats_wd: interference source is %s\n",
				wlc->pub->unit, itf_source_str[itfr->source]));
		} else {
			bool detect_req = itfr->detect_req;
			/* verify result */
			itfr->last_source = itfr->source;
			itfr_reset_state(wlc, TRUE);
			/* restore flag cleared when reset state */
			itfr->detect_req = detect_req;
			/* issue scan request */
			WL_ITFR(("wl%d: itfr_stats_wd: interference source"
				" could be %s. verify again\n",
				wlc->pub->unit, itf_source_str[itfr->last_source]));
		}
	}

itfr_exit:
	MFREE(wlc->osh, itfr_sample, sizeof(itfr_sample_t) * itfr->chan_num);
}
#endif /* ISID_STATS */
#endif /* CCA_STATS */


#ifdef STA
bool
wlc_rsn_ucast_lookup(struct rsn_parms *rsn, uint8 auth)
{
	uint i;

	for (i = 0; i < rsn->ucount; i++)
		if (rsn->unicast[i] == auth)
			return TRUE;

	return FALSE;
}

/* validate and sanitize chanspecs passed with assoc params */
static int
wlc_assoc_chanspec_sanitize(wlc_info_t *wlc, chanspec_t *chanspec_list, int chanspec_num)
{
	int i;

	for (i = 0; i < chanspec_num; i++) {
		if (wf_chspec_malformed(chanspec_list[i]))
			return BCME_BADCHAN;
		/* get the control channel from the chanspec */
		chanspec_list[i] = CH20MHZ_CHSPEC(wf_chspec_ctlchan(chanspec_list[i]));
		if (!wlc_valid_chanspec_db(wlc->cmi, chanspec_list[i]))
			return BCME_BADCHAN;
	}

	return BCME_OK;
}

#ifdef PHYCAL_CACHING
static int
wlc_cache_cals(wlc_info_t *wlc)
{
	chanspec_t chanspec = wlc_default_chanspec(wlc->cmi, TRUE);
	uint i;
	char abbrev[WLC_CNTRY_BUF_SZ];
	wl_uint32_list_t *list;

	if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE) ||
	    mboolisset(wlc->pub->radio_disabled, WL_RADIO_SW_DISABLE))
		return BCME_RADIOOFF;

	list = (wl_uint32_list_t *)MALLOC(wlc->osh, (WL_NUMCHANSPECS+1) * sizeof(uint32));

	if (!list) {
		WL_ERROR(("wl%d: %s: out of memory, %d bytes malloced\n", wlc->pub->unit,
		          __FUNCTION__, MALLOCED(wlc->osh)));
		return BCME_NOMEM;
	}

	bzero(list, sizeof(WL_NUMCHANSPECS+1) * sizeof(uint32));
	bzero(abbrev, WLC_CNTRY_BUF_SZ);
	list->count = 0;
	wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, TRUE, abbrev);
	wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, FALSE, abbrev);

	/* 20MHz only for now
	 * wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, TRUE, abbrev);
	 * wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, FALSE, abbrev);
	 */

	/* need this to be set */
	wlc_iovar_setint(wlc, "phy_percal", PHY_PERICAL_SPHASE);

	/* we'll assert in PHY code if we are in MPC */
	wlc->mpc = FALSE;
	wlc_radio_mpc_upd(wlc);

	wl_up(wlc->wl);

	wlc_bmac_set_phycal_cache_flag(wlc->hw, TRUE);

	wlc_suspend_mac_and_wait(wlc);

	for (i = 0; i < list->count; i++) {
		chanspec = (chanspec_t) list->element[i];
		WL_INFORM(("wl%d: %s: setting chanspec to 0x%04x and running a periodic cal\n",
		           wlc->pub->unit, __FUNCTION__, chanspec));
		wlc_phy_create_chanctx(wlc->band->pi, chanspec);
		wlc_set_chanspec(wlc, chanspec);
		wlc_phy_cal_perical(wlc->band->pi, PHY_PERICAL_JOIN_BSS);
	}

	wlc_enable_mac(wlc);

	wlc_iovar_setint(wlc, "phy_percal", PHY_PERICAL_MANUAL);

	if (list)
		MFREE(wlc->osh, list, (WL_NUMCHANSPECS+1) * sizeof(uint32));

	return BCME_OK;
}

static int
wlc_cachedcal_sweep(wlc_info_t *wlc)
{
	chanspec_t chanspec = wlc_default_chanspec(wlc->cmi, TRUE);
	uint i;
	char abbrev[WLC_CNTRY_BUF_SZ];
	wl_uint32_list_t *list = (wl_uint32_list_t *)
	        MALLOC(wlc->osh, (WL_NUMCHANSPECS+1) * sizeof(uint32));

	if (!list) {
		WL_ERROR(("wl%d: %s: out of memory, %d bytes malloced\n", wlc->pub->unit,
		          __FUNCTION__, MALLOCED(wlc->osh)));
		return BCME_NOMEM;
	}

	bzero(list, sizeof(WL_NUMCHANSPECS+1) * sizeof(uint32));
	bzero(abbrev, WLC_CNTRY_BUF_SZ);
	list->count = 0;

	wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, TRUE, abbrev);
	wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, FALSE, abbrev);

	/* 20MHz only for now
	 * wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, TRUE, abbrev);
	 * wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, FALSE, abbrev);
	 */

	/* we'll assert in PHY code if we are in MPC */
	wlc->mpc = FALSE;
	wlc_radio_mpc_upd(wlc);

	wlc_suspend_mac_and_wait(wlc);

	for (i = 0; i < list->count; i++) {
		chanspec = (chanspec_t) list->element[i];
		WL_INFORM(("wl%d: %s: setting chanspec to 0x%04x and running a periodic cal\n",
		           wlc->pub->unit, __FUNCTION__, chanspec));
		wlc_phy_create_chanctx(wlc->band->pi, chanspec);
		wlc_set_chanspec(wlc, chanspec);
		wlc_phy_cal_perical(wlc->band->pi, PHY_PERICAL_JOIN_BSS);
	}

	wlc_enable_mac(wlc);

	if (list)
		MFREE(wlc->osh, list, (WL_NUMCHANSPECS+1) * sizeof(uint32));

	return BCME_OK;
}

static int
wlc_cachedcal_tune(wlc_info_t *wlc, uint16 channel)
{
	uint16 chanspec = (channel | WL_CHANSPEC_BW_20 | WL_CHANSPEC_CTL_SB_NONE);
	channel <= CH_MAX_2G_CHANNEL ? (chanspec |= WL_CHANSPEC_BAND_2G) :
	        (chanspec |= WL_CHANSPEC_BAND_5G);

	if (wf_chspec_malformed(chanspec)) {
		WL_ERROR(("wl%d: %s: Malformed chanspec 0x%x\n", wlc->pub->unit, __FUNCTION__,
		          chanspec));
		return BCME_BADCHAN;
	}

	if (!VALID_CHANNEL20_IN_BAND(wlc, CHANNEL_BANDUNIT(wlc, channel), channel)) {
		WL_ERROR(("wl%d: %s: Bad channel %d\n", wlc->pub->unit, __FUNCTION__, channel));
		return BCME_BADCHAN;
	}

	/* we'll assert in PHY code if we are in MPC */
	wlc->mpc = FALSE;
	wlc_radio_mpc_upd(wlc);

	wlc_suspend_mac_and_wait(wlc);
	WL_INFORM(("wl%d: %s: setting chanspec to 0x%04x and running a periodic cal\n",
	          wlc->pub->unit, __FUNCTION__, chanspec));
	wlc_set_chanspec(wlc, chanspec);
	wlc_phy_cal_perical(wlc->band->pi, PHY_PERICAL_JOIN_BSS);
	wlc_enable_mac(wlc);

	return BCME_OK;
}
#endif /* PHYCAL_CACHING */

#ifdef WL11D
void
wlc_11d_scan_complete(wlc_info_t *wlc, int status)
{
	wlcband_t *band;
	wlc_bss_info_t *bi;
	bcm_tlv_t *country_ie;
	bcm_tlv_t *best_country_ie = NULL;
	char best_country_abbrev[WLC_CNTRY_BUF_SZ];
	uint8 *tags;
	uint tag_len;
	uint i, j;
	char country_abbrev[WLC_CNTRY_BUF_SZ];
	chanvec_t supported_channels;
	chanvec_t channels;
	int8 ie_tx_pwr[MAXCHANNEL];
	const country_info_t *ci;
	const locale_info_t *locale;
	int a_max, b_max;
	int a_band, b_band;
	int err;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
	char ssidbuf[SSID_FMT_BUF_LEN];
	wlc_bss_info_t *best_bi = NULL;
#endif	/* BCMDBG || WLMSG_INFORM */

	if (status != WLC_E_STATUS_SUCCESS)
		return;

	/* This routine should only be called if we are still looking for country information. */
	ASSERT(wlc->awaiting_cntry_info);

	/* get all the phy supported channels */
	bzero(&supported_channels, sizeof(chanvec_t));
	band = wlc->band;
	for (i = 0; i < NBANDS(wlc); i++, band = wlc->bandstate[OTHERBANDUNIT(wlc)]) {
		wlc_phy_chanspec_band_validch(band->pi, band->bandtype, &channels);
		for (j = 0; j < sizeof(chanvec_t); j++)
			supported_channels.vec[j] |= channels.vec[j];
		if (!IS_MBAND_UNLOCKED(wlc))
			break;
	}

	/* Walk the list of APs, finding the ones with Country IEs.
	 * Keep the best choice so far as we go
	 */
	a_max = b_max = 0;
	for (i = 0; i < wlc->scan_results->count; i++) {

		a_band = b_band = 0;

		bi = wlc->scan_results->ptrs[i];
		ASSERT(bi != NULL);

		/* skip IBSS bcn/prb, or scan results with no bcn/prb */
		if (bi->infra == 0 || !bi->bcn_prb || (bi->bcn_prb_len <= DOT11_BCN_PRB_LEN))
			continue;

		tag_len = bi->bcn_prb_len - sizeof(struct dot11_bcn_prb);
		tags = (uint8 *)bi->bcn_prb + sizeof(struct dot11_bcn_prb);

		/* skip if no Country IE */
		country_ie = bcm_parse_tlvs(tags, tag_len, DOT11_MNG_COUNTRY_ID);
		if (!country_ie)
			continue;

		bzero(ie_tx_pwr, sizeof(ie_tx_pwr));
		bzero(channels.vec, sizeof(channels.vec));
		err = wlc_parse_country_ie(wlc, country_ie, country_abbrev, &channels, ie_tx_pwr);
		if (err) {
			WL_REGULATORY(("wl%d: %s: skipping malformed Country IE on "
			               "AP %s \"%s\" channel %d\n",
			               wlc->pub->unit, __FUNCTION__,
			               bcm_ether_ntoa(&bi->BSSID, eabuf),
			               (wlc_format_ssid(ssidbuf, bi->SSID, bi->SSID_len), ssidbuf),
			               wf_chspec_ctlchan(bi->chanspec)));
			continue;
		}

		/* skip if the Country IE does not have a known country code */
		ci = wlc_country_lookup_ext(wlc, country_abbrev);
		if (!ci) {
			WL_REGULATORY(("wl%d: %s: skipping unknown country code \"%s\" from "
			               "AP %s \"%s\" channel %d\n",
			               wlc->pub->unit, __FUNCTION__,
			               country_abbrev, bcm_ether_ntoa(&bi->BSSID, eabuf),
			               (wlc_format_ssid(ssidbuf, bi->SSID, bi->SSID_len), ssidbuf),
			               wf_chspec_ctlchan(bi->chanspec)));
			continue;
		}

		/* count the channels in each band */
		locale = wlc_get_locale_2g(ci->locale_2G);
		if (locale) {
			wlc_locale_get_channels(locale, &channels);
			for (j = 0; j < sizeof(chanvec_t); j++)
				channels.vec[j] &= supported_channels.vec[j];
			b_band = bcm_bitcount(channels.vec, sizeof(chanvec_t));
		}
		locale = wlc_get_locale_5g(ci->locale_5G);
		if (locale) {
			wlc_locale_get_channels(locale, &channels);
			for (j = 0; j < sizeof(chanvec_t); j++)
				channels.vec[j] &= supported_channels.vec[j];
			a_band = bcm_bitcount(channels.vec, sizeof(chanvec_t));
		}
		WL_REGULATORY(("wl%d: %s: AP %s \"%s\" with Country IE: "
		               "\"%s\" %d 2GHz, %d 5GHz channels\n",
		               wlc->pub->unit, __FUNCTION__,
		               bcm_ether_ntoa(&bi->BSSID, eabuf),
		               (wlc_format_ssid(ssidbuf, bi->SSID, bi->SSID_len), ssidbuf),
		               country_abbrev, b_band, a_band));

		/* Pick the best by most channels */
		if ((a_band + b_band) > (a_max + b_max)) {
			if (best_country_ie)
				WL_REGULATORY(("wl%d: %s: Country IE \"%s\" with "
				               "%d 2GHz, %d 5GHz channels preferred over "
				               "\"%s\" with %d 2GHz, %d 5GHz channels.\n",
				               wlc->pub->unit, __FUNCTION__,
				               country_abbrev, a_band, b_band,
				               best_country_abbrev, a_max, b_max));
			a_max = a_band;
			b_max = b_band;
			best_country_ie = country_ie;
			strncpy(best_country_abbrev, country_abbrev,
			        sizeof(best_country_abbrev) - 1);
#if defined(BCMDBG) || defined(WLMSG_INFORM)
			best_bi = bi;
#endif
		}
	}

	if (!best_country_ie)
		return;

	/* keep only the 2 char ISO code for our country setting,
	 * dropping the Indoor/Outdoor/Either specification in the 3rd char
	 */
	best_country_abbrev[2] = '\0';

	if (wlc->pub->associated && !wlc_compatible_country(wlc, best_country_abbrev)) {
		WL_REGULATORY(("wl%d: %s: Not adopting best choice Country \"%s\" from "
			"AP %s \"%s\" channel %d since it is incompatible with our "
			"current association on channel %d\n",
			wlc->pub->unit, __FUNCTION__, best_country_abbrev,
			bcm_ether_ntoa(&best_bi->BSSID, eabuf),
			(wlc_format_ssid(ssidbuf, best_bi->SSID, best_bi->SSID_len), ssidbuf),
			wf_chspec_ctlchan(best_bi->chanspec),
			wf_chspec_ctlchan(wlc->home_chanspec)));
		return;
	}

	/* Adopt the best choice */
	WL_INFORM(("wl%d: %s: Adopting Country IE \"%s\" from AP %s \"%s\" channel %d\n",
	           wlc->pub->unit, __FUNCTION__, best_country_abbrev,
	           bcm_ether_ntoa(&best_bi->BSSID, eabuf),
	           (wlc_format_ssid(ssidbuf, best_bi->SSID, best_bi->SSID_len), ssidbuf),
	           wf_chspec_ctlchan(best_bi->chanspec)));

	wlc_set_countrycode(wlc->cmi, best_country_abbrev);
	wlc->awaiting_cntry_info = FALSE;
	/* The current channel could be chatty in the new country code */
	if (wlc->pub->up && !wlc_quiet_chanspec(wlc->cmi, WLC_BAND_PI_RADIO_CHANSPEC))
		wlc_mute(wlc, OFF, 0);
}

/* Determine if the country channel information is compatible with the current association.
 * Returns TRUE if the country setting includes the channel of the currently associated AP
 * or IBSS, FALSE otherwise.
 */
int
wlc_compatible_country(wlc_info_t *wlc, const char *country_abbrev)
{
	chanvec_t channels;
	chanspec_t chanspec;

	/* should only be called if associated to an AP */
	ASSERT(wlc->pub->associated);
	if (!wlc->pub->associated)
		return TRUE;

	chanspec = wlc->home_chanspec;
	if (wlc_channel_get_chanvec(wlc, country_abbrev,
		(CHSPEC_IS2G(chanspec) ? WLC_BAND_2G : WLC_BAND_5G), &channels) == FALSE)
		return FALSE;

	if (CHSPEC_IS40(chanspec))
		return isset(channels.vec, LOWER_20_SB(CHSPEC_CHANNEL(chanspec))) &&
		        isset(channels.vec, UPPER_20_SB(CHSPEC_CHANNEL(chanspec)));
	else
		return isset(channels.vec, CHSPEC_CHANNEL(chanspec));
}
#endif /* WL11D */

#if defined(WL11H) || defined(WL11D)
bool
wlc_adopt_country_ie(wlc_info_t *wlc, const bcm_tlv_t *country_ie)
{
	char country_str[WLC_CNTRY_BUF_SZ];
	chanvec_t channels;
	int8 ie_tx_pwr[MAXCHANNEL];
	int err;
	bool cie_adopted = FALSE;

	/* Init the array to max value */
	memset(ie_tx_pwr, WLC_TXPWR_MAX, sizeof(ie_tx_pwr));

	bzero(channels.vec, sizeof(channels.vec));

	err = wlc_parse_country_ie(wlc, country_ie, country_str, &channels, ie_tx_pwr);
	if (err) {
		WL_REGULATORY(("wl%d: %s: malformed Country IE\n",
		               wlc->pub->unit, __FUNCTION__));
		return FALSE;
	}

#if defined(WL11D)
	if (WLC_AUTOCOUNTRY_ENAB(wlc)) {
		const country_info_t *ci;
		char country_abbrev[WLC_CNTRY_BUF_SZ];

		/* create the 2 char country code from the ISO country code */
		strncpy(country_abbrev, country_str, sizeof(country_abbrev) - 1);
		country_abbrev[2] = '\0';

		ci = wlc_country_lookup_ext(wlc, country_str);
		if (!ci) {
			WL_REGULATORY(("wl%d: Ignoring associated AP's Country IE \"%s\" since "
			               "no match was found in built-in table\n",
			               wlc->pub->unit, country_str));
		} else if (!wlc_compatible_country(wlc, country_abbrev)) {
			WL_REGULATORY(("wl%d: Ignoring associated AP's Country IE \"%s\" "
				"since it is incompatible with the associated channel %d\n",
				wlc->pub->unit, country_str,
				wf_chspec_ctlchan(wlc->home_chanspec)));
		} else {
			WL_INFORM(("wl%d: setting regulatory information from built-in "
				"country \"%s\" matching associated AP's Country IE\n",
				wlc->pub->unit, country_abbrev));

			wlc_set_countrycode(wlc->cmi, country_abbrev);
			wlc->awaiting_cntry_info = FALSE;
			/* The current channel could be chatty in the new country code */
			if (!wlc_quiet_chanspec(wlc->cmi, WLC_BAND_PI_RADIO_CHANSPEC))
				wlc_mute(wlc, OFF, 0);

			cie_adopted = TRUE;
		}
	}
#endif /* WL11D */
	if (WL11H_ENAB(wlc) && wlc->pub->associated) {
		wlc->txpwr_local_max =
		        ie_tx_pwr[wf_chspec_ctlchan(wlc->home_chanspec)];
		WL_REGULATORY(("wl%d: Adopting Country IE \"%s\" "
		               "channel %d txpwr local max %d dBm\n", wlc->pub->unit,
		               country_str, wf_chspec_ctlchan(wlc->home_chanspec),
		               wlc->txpwr_local_max));
	}

	return cie_adopted;
}
#endif /* WL11H || WL11D */
#endif	/* STA */

/* "extended" scan request */
int
wlc_scan_request_ex(
	wlc_info_t *wlc,
	int bss_type,
	const struct ether_addr* bssid,
	int nssid,
	wlc_ssid_t *ssids,
	int scan_type,
	int nprobes,
	int active_time,
	int passive_time,
	int home_time,
	const chanspec_t* chanspec_list,
	int chanspec_num,
	chanspec_t chanspec_start,
	bool save_prb,
	scancb_fn_t fn, void* arg,
	int macreq,
	bool chan_prohibit,
	wlc_bsscfg_t *cfg)
{
	int err = 0;
	bool cb = TRUE;

	ASSERT((ssids != NULL) && (nssid != 0));
	ASSERT(ssids->SSID_len <= DOT11_MAX_SSID_LEN);

	/* if radio is disabled due to unassociation, turn it on */
	wlc->mpc_scan = TRUE;
#ifdef STA
	wlc_radio_mpc_upd(wlc);
#endif /* STA */

	if (!wlc->pub->up) {
		WL_ERROR(("wl%d: wlc_scan_request_ex, can not scan while driver is down\n",
			wlc->pub->unit));
		err = BCME_NOTUP;
	}
	else if ((err = wlc_mac_request_entry(wlc, NULL, macreq)) == BCME_OK) {
		err = wlc_scan(wlc->scan, bss_type, bssid, nssid, ssids,
		               scan_type, nprobes, active_time, passive_time, home_time,
		               chanspec_list, chanspec_num, chanspec_start, save_prb,
		               fn, arg, 0, FALSE, FALSE, SCANCACHE_ENAB(wlc->scan),
		               chan_prohibit, cfg);
		/* wlc_scan() invokes 'fn' even in error cases */
		cb = FALSE;
	}
	else {
		WL_INFORM(("wl%d: scan is blocked by others\n", wlc->pub->unit));
	}

	/* make it consistent with wlc_scan() w.r.t. invoking callback */
	if (cb && fn != NULL) {
		WL_ERROR(("wl%d: wlc_scan_request_ex, can not scan due to error %d\n",
		          wlc->pub->unit, err));
		(fn)(arg, WLC_E_STATUS_ERROR, cfg);
	}

	wlc->mpc_scan = FALSE;
#ifdef STA
	wlc_radio_mpc_upd(wlc);
#endif /* STA */

	return err;
}

void
wlc_custom_scan_complete(void *arg, int status, wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = (wlc_info_t*)arg;

	/* This scan is blocked by other existing scan of equal or higher priority */
	/* Do this at the beginning of this function to avoid sending unnecessary events */
	if (status == WLC_E_STATUS_ERROR)
		return;

#ifdef STA
	if (ESCAN_IN_PROGRESS(wlc->scan)) {
		wl_escan_result_t escan_result;

		escan_result.sync_id = wlc->escan_sync_id;
		escan_result.version = WL_BSS_INFO_VERSION;
		escan_result.bss_count = 0;
		escan_result.buflen = WL_ESCAN_RESULTS_FIXED_SIZE;

		ASSERT(status != WLC_E_STATUS_PARTIAL);

		wlc_bss_mac_event(wlc, cfg, WLC_E_ESCAN_RESULT, NULL, status,
		                  0, 0, &escan_result, escan_result.buflen);
	}
	else
		wlc_bss_mac_event(wlc, cfg, WLC_E_SCAN_COMPLETE, NULL, status, 0, 0, 0, 0);

	if (ISCAN_IN_PROGRESS(wlc))
		wl_del_timer(wlc->wl, wlc->iscan_timer);
#endif /* STA */

	if (status == WLC_E_STATUS_PARTIAL)
		status = WL_SCAN_RESULTS_PARTIAL;
	else if (status != WLC_E_STATUS_SUCCESS) {
		if (ISCAN_IN_PROGRESS(wlc))
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_ABORTED;
		else
			wlc->custom_scan_results_state = WL_SCAN_RESULTS_ABORTED;
		return;
	}

	/* release old BSS information */
	wlc_bss_list_free(wlc, wlc->custom_scan_results);

	/* copy scan results to custom_scan_results for reporting via ioctl */
	wlc_bss_list_xfer(wlc->scan_results, wlc->custom_scan_results);

	if (ISCAN_IN_PROGRESS(wlc)) {
		wlc->custom_iscan_results_state = status;
	} else if (wlc->custom_scan_results_state == WL_SCAN_RESULTS_PENDING)
		wlc->custom_scan_results_state = status;
}

static int
wlc_custom_scan(wlc_info_t *wlc, char *arg, int arg_len,
	chanspec_t chanspec_start, int macreq, wlc_bsscfg_t *cfg)
{
	wl_scan_params_t params;
	uint nssid = 0;
	wlc_ssid_t *ssids = NULL;
	int bss_type = DOT11_BSSTYPE_ANY;
	const struct ether_addr* bssid = &ether_bcast;
	int scan_type = -1;
	int nprobes = -1;
	int active_time = -1;
	int passive_time = -1;
	int home_time = -1;
	chanspec_t* chanspec_list = NULL;
	uint chanspec_num = 0;
	int bcmerror = BCME_OK;
	uint i;
	bool chan_prohibit = FALSE;

	/* default to single fixed-part ssid */
	ssids = &params.ssid;

	/* irrelevant to 802.11h-enabled AP */
	if (BSSCFG_AP(cfg) && WL11H_AP_ENAB(wlc)) {
		WL_REGULATORY(("wl%d: %s: WLC_SCAN ignored\n", wlc->pub->unit,
		               __FUNCTION__));
		goto done;
	}

	if (arg_len >= WL_SCAN_PARAMS_FIXED_SIZE) {
		/* full wl_scan_params_t provided */
		bcopy(arg, &params, WL_SCAN_PARAMS_FIXED_SIZE);
		bssid = &params.bssid;
		bss_type = (int)params.bss_type;
		nprobes = (int)params.nprobes;
		active_time = (int)params.active_time;
		passive_time = (int)params.passive_time;
		home_time = (int)params.home_time;

		if (params.scan_type == (uint8)-1)
			scan_type = -1;
		else if (params.scan_type == 0)
			scan_type = DOT11_SCANTYPE_ACTIVE;
		else {
			if (params.scan_type & WL_SCANFLAGS_PASSIVE)
				scan_type = DOT11_SCANTYPE_PASSIVE;
			if (params.scan_type & WL_SCANFLAGS_PROHIBITED)
				chan_prohibit = TRUE;
		}

		chanspec_num = (uint)(params.channel_num & WL_SCAN_PARAMS_COUNT_MASK);
		nssid = (uint)((params.channel_num >> WL_SCAN_PARAMS_NSSID_SHIFT) &
		               WL_SCAN_PARAMS_COUNT_MASK);
		if ((int)(WL_SCAN_PARAMS_FIXED_SIZE + chanspec_num * sizeof(uint16)) > arg_len) {
			bcmerror = BCME_BUFTOOSHORT; /* arg buffer too short */
			goto done;
		}

		/* Optional remainder (chanspecs/ssids) will be used in place but
		 * may be unaligned.  Fixed portion copied out above, so use that
		 * space to copy remainder to max required alignment boundary.
		 */
		ASSERT(OFFSETOF(wl_scan_params_t, channel_list) >= sizeof(uint32));
		arg += OFFSETOF(wl_scan_params_t, channel_list);
		arg_len -= OFFSETOF(wl_scan_params_t, channel_list);
		chanspec_list = (chanspec_t*)((uintptr)arg & ~(sizeof(uint32) - 1));
		bcopy(arg, (char*)chanspec_list, arg_len);

		if (chanspec_num > 0) {
			ASSERT(ISALIGNED((uintptr)chanspec_list, sizeof(uint16)));
			/* if chanspec is valid leave it alone, if not assume its really
			 * just a 20Mhz channel number and convert it to a chanspec
			 */
			for (i = 0; i < chanspec_num; i++) {
				uint16 ch = chanspec_list[i] & WL_CHANSPEC_CHAN_MASK;

				/* Magic value of -1 to abort an existing scan, else just return */
				if (chanspec_list[i] == (uint16) -1) {
					wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);
					bcmerror = WL_SCAN_RESULTS_ABORTED;
					goto done;
				}

				if (wf_chspec_malformed(chanspec_list[i]))
					chanspec_list[i] = CH20MHZ_CHSPEC(ch);
			}
		}

		/* locate appended ssids */
		if (nssid) {
			uint offset = chanspec_num * sizeof(uint16);
			offset = ROUNDUP(offset, sizeof(uint32));
			if ((uint)arg_len < (offset + nssid * sizeof(wlc_ssid_t))) {
				bcmerror = BCME_BUFTOOSHORT;
				goto done;
			}
			ssids = (wlc_ssid_t *)((char*)chanspec_list + offset);
			ASSERT(ISALIGNED((uintptr)ssids, sizeof(uint32)));
		}
	} else if (arg_len >= (int)sizeof(uint32)) {
		/* just an SSID provided */
		bcopy(arg, &params.ssid, MIN((int)sizeof(wlc_ssid_t), arg_len));
		if ((uint)arg_len < params.ssid.SSID_len) {
			bcmerror = BCME_BUFTOOSHORT;
			goto done;
		}
	}

	if (nssid == 0) {
		nssid = 1;
		ssids = &params.ssid;
	}

	for (i = 0; i < nssid; i++) {
		if (ssids[i].SSID_len > DOT11_MAX_SSID_LEN) {
			bcmerror = BCME_BADSSIDLEN;
			goto done;
		}
	}

	WL_ASSOC(("SCAN: WLC_SCAN custom scan\n"));
	bcmerror = wlc_scan_request_ex(wlc, bss_type, bssid, nssid, ssids,
	                               scan_type, nprobes, active_time, passive_time,
	                               home_time, chanspec_list, chanspec_num,
	                               chanspec_start, TRUE, wlc_custom_scan_complete,
	                               wlc, macreq, chan_prohibit, cfg);
	if (!bcmerror)
		wlc_bss_list_free(wlc, wlc->custom_scan_results);
done:
	return bcmerror;
}

static int
wlc_scan_results(wlc_info_t *wlc, wl_scan_results_t *iob, int *len, uint results_state)
{
	wl_bss_info_t *wl_bi;
	uint32 totallen = 0;
	uint32 datalen;
	wlc_bss_info_t **scan_results = 0;
	uint scan_results_num = 0;
	int bcmerror = BCME_OK;
	uint i = 0;
	int buflen = *len;

	iob->version = WL_BSS_INFO_VERSION;
	datalen = WL_SCAN_RESULTS_FIXED_SIZE;

	if (results_state == WL_SCAN_RESULTS_PENDING) {
		bcmerror = BCME_NOTREADY;
		goto done;
	}

	if (results_state == WL_SCAN_RESULTS_ABORTED) {
		bcmerror = BCME_NOTFOUND;
		goto done;
	}

	scan_results_num = wlc->custom_scan_results->count;

	scan_results = wlc->custom_scan_results->ptrs;

	/* calc buffer length: fixed + IEs */
	totallen = WL_SCAN_RESULTS_FIXED_SIZE +
	    scan_results_num * sizeof(wl_bss_info_t);
	for (i = 0; i < scan_results_num; i ++) {
		ASSERT(scan_results[i] != NULL);
		if (scan_results[i]->bcn_prb_len > DOT11_BCN_PRB_LEN)
			totallen += ROUNDUP(scan_results[i]->bcn_prb_len -
			                    DOT11_BCN_PRB_LEN, 4);
	}

	/* convert each wlc_bss_info_t, writing into buffer */
	wl_bi = iob->bss_info;
	for (i = 0; i < scan_results_num; i++) {
		if (wlc_bss2wl_bss(wlc, scan_results[i], wl_bi, buflen, TRUE) == BCME_BUFTOOSHORT) {
#ifdef STA
			if (ISCAN_RESULTS_OK(wlc)) {
				int indx;

				wlc->custom_iscan_results_state = WL_SCAN_RESULTS_PARTIAL;
				if (i == 0)
					break;

				indx = wlc_BSSignorelookup(wlc,
				                            scan_results[i]->BSSID.octet,
				                            scan_results[i]->chanspec,
				                            scan_results[i]->SSID,
				                            scan_results[i]->SSID_len,
				                            FALSE);
				if (indx >= 0) {
					wlc->iscan_ignore_count = indx;
					wlc->iscan_chanspec_last =
					    wlc->iscan_ignore_list[indx].chanspec;
					WL_TRACE(("wlc_scan_results ending iscan on channel %d;"
					          " ignore count %d\n",
					          CHSPEC_CHANNEL(wlc->iscan_chanspec_last), indx));
				}
			}
#endif /* STA */
			break;
		}
		datalen += wl_bi->length;
		buflen -= wl_bi->length;
		wl_bi = (wl_bss_info_t *)((char *)wl_bi + wl_bi->length);
	}

done:
	/* buffer too short */
	if (iob->buflen < totallen) {
		/* return bytes needed if buffer is too short */
		iob->buflen = totallen;
		bcmerror = BCME_BUFTOOSHORT;
	} else
		iob->buflen = datalen;
	*len = datalen;
	iob->count = i;

	return bcmerror;
}

/* common AP/STA funnel function to perform operations when scb disassocs */
void
wlc_scb_disassoc_cleanup(wlc_info_t *wlc, struct scb *scb)
{
#if defined(BCMDBG) || defined(WLMSG_WSEC) || defined(WLMSG_BTA)
	char eabuf[ETHER_ADDR_STR_LEN];

	bcm_ether_ntoa(&scb->ea, eabuf);
#endif

	/* delete pairwise key on disassociate */
	if (scb->key) {
		WL_WSEC(("wl%d: %s: deleting pairwise key for %s\n",
		         wlc->pub->unit, __FUNCTION__, eabuf));
		wlc_key_scb_delete(wlc, scb);
	}

	scb->flags &= ~SCB_PENDING_PSPOLL;

#ifdef WLAMPDU
	/* cleanup ampdu at end of association */
	if (SCB_AMPDU(scb)) {
		WL_AMPDU(("wl%d: scb ampdu cleanup for %s\n", wlc->pub->unit, eabuf));
		scb_ampdu_cleanup(wlc->ampdu, scb);
	}
#endif

#ifdef WLBTAMP
	/* cleanup BT-AMP physical link */
	if (BSS_BTA_ENAB(wlc, SCB_BSSCFG(scb))) {
		WL_BTA(("wl%d: BT-AMP scb cleanup for %s\n", wlc->pub->unit, eabuf));
		wlc_bta_scb_cleanup(wlc->bta, scb);
	}
#endif

	if (BSSCFG_AP(SCB_BSSCFG(scb))) {
		if (scb->wpaie) {
			MFREE(wlc->osh, scb->wpaie, scb->wpaie_len);
			scb->wpaie = NULL;
			scb->wpaie_len = 0;
		}
	}

	/* Reset PS state if needed */
	if (SCB_PS(scb))
		wlc_apps_scb_ps_off(wlc, scb, TRUE);

	wlc_update_txba_burst_war(wlc, scb);

#ifdef MFP
	scb->flags2 &= ~SCB2_MFP;
	scb->flags2 &= ~SCB2_SHA256;
#endif

}

#ifdef STA
/*
 * callback function for the APSD Trigger Frame Timer
 * This is also used by WME_AUTO_TRIGGER routine
 * to send out QoS NULL DATA frame as trigger to AP
 */
void
wlc_apsd_trigger_timeout(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;
	wlc_info_t *wlc = cfg->wlc;
	struct scb *scb;

	WL_INFORM(("wl%d: %s, entering\n", wlc->pub->unit, __FUNCTION__));

	ASSERT(cfg->pm->PMenabled);
	ASSERT(cfg->associated);

	/*
	 * The Trigger Frame Timer has expired, so send a QoS NULL
	 * data packet of the highest WMM APSD-enabled AC priority.
	 * The Trigger Frame Timer will be reloaded elsewhere.
	 */
	if ((scb = wlc_scbfind(wlc, &cfg->BSSID)) == NULL) {
		WL_ERROR(("wl%d: %s : failed to find scb\n", wlc->pub->unit, __FUNCTION__));
		/* Link is down so clear the timer */
		wlc_apsd_trigger_upd(cfg, FALSE);
		return;
	}

	/*
	 * Don't send excessive null frames. Bail out if a QoS Data/Null frame
	 * was send out recently.
	 */
	if (scb->flags & SCB_SENT_APSD_TRIG) {
		scb->flags &= ~SCB_SENT_APSD_TRIG;
		WL_PS(("wl%d.%d: %s: trigger frame was recently send out\n",
		       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__));
		return;
	}

	if (wlc_sendapsdtrigger(wlc, scb) == NULL) {
		WL_ERROR(("wl%d: failed to send apsd trigger frame\n", wlc->pub->unit));
		return;
	}

	return;
}

/* Configure the WMM U-APSD trigger frame timer */
int
wlc_apsd_trigger_upd(wlc_bsscfg_t *cfg, bool allow)
{
	wlc_info_t *wlc = cfg->wlc;
	struct scb *scb;
	wlc_pm_st_t *pm = cfg->pm;
	int callbacks = 0;

	WL_TRACE(("wl%d: %s : state %d, timeout %d\n",
		wlc->pub->unit, __FUNCTION__, allow, pm->apsd_trigger_timeout));

	if (!wl_del_timer(wlc->wl, pm->apsd_trigger_timer))
		callbacks ++;

	if (!allow || !cfg->associated || !pm->PMenabled ||
	    pm->apsd_trigger_timeout == 0)
		return callbacks;

	/*
	 * - check for WMM
	 * - check for APSD trigger- & delivery- enabled ACs
	 * - set timeout
	 * - enable timer as necessary
	 */
	if ((scb = wlc_scbfind(wlc, &cfg->BSSID)) != NULL &&
	    SCB_WME(scb) && scb->apsd.ac_trig) {

		/* set timer for half the requested period so that we send frame
		 * only if there was no tx activity (in the APSD ac for the last
		 * 1/2 of the trigger timeout period.
		 */
		wl_add_timer(wlc->wl, pm->apsd_trigger_timer, pm->apsd_trigger_timeout / 2, TRUE);
	} else {
		WL_PS(("wl%d.%d: %s: apsd trigger timer not set\n",
		       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__));
	}

	return 0;
}

void
wlc_bss_clear_bssid(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	bzero(&cfg->BSSID, ETHER_ADDR_LEN);
	bzero(&cfg->current_bss->BSSID, ETHER_ADDR_LEN);
	wlc_clear_bssid(cfg);

	wlc->stas_connected = wlc_stas_connected(wlc);

	wlc_enable_btc_ps_protection(wlc, cfg, FALSE);

	if (cfg->pm->PMpending)
		wlc_update_pmstate(cfg, TX_STATUS_NO_ACK);

	/* Clear the quiet flag and transfer the packets */
	wlc_bsscfg_tx_start(cfg);
}

static uint32
wlc_watchdog_backup_bi(wlc_info_t * wlc)
{
	uint32 bi;
	bi = 2*wlc->cfg->current_bss->dtim_period * wlc->cfg->current_bss->beacon_period;
	if (wlc->bcn_li_dtim)
		bi *= wlc->bcn_li_dtim;
	else if (wlc->bcn_li_bcn)
		/* recalculate bi based on bcn_li_bcn */
		bi = 2*wlc->bcn_li_bcn*wlc->cfg->current_bss->beacon_period;

	if (bi < 2*TIMER_INTERVAL_WATCHDOG) bi = 2*TIMER_INTERVAL_WATCHDOG;
	return bi;
}

/* Change to run the watchdog either from a periodic timer or from tbtt handler.
 * Call watchdog from tbtt handler if tbtt is TRUE, watchdog timer otherwise.
 */
void
wlc_watchdog_upd(wlc_bsscfg_t *cfg, bool tbtt)
{
	wlc_info_t *wlc = cfg->wlc;

	if (cfg != wlc->cfg)
		return;

	/* make sure changing watchdog driver is allowed */
	if (!wlc->pub->up || !wlc->pub->align_wd_tbtt)
		return;
	if (!tbtt && wlc->WDarmed) {
		wl_del_timer(wlc->wl, wlc->wdtimer);
		wlc->WDarmed = FALSE;
	}

	/* stop watchdog timer and use tbtt interrupt to drive watchdog */
	if (tbtt && wlc->WDarmed) {
		wl_del_timer(wlc->wl, wlc->wdtimer);
		wlc->WDarmed = FALSE;
		wlc->WDlast = OSL_SYSUPTIME();
		WL_INFORM(("wl%d: wlc_watchdog_upd: tbtt handler is chosen\n", WLCWLUNIT(wlc)));
	}
	/* arm watchdog timer and drive the watchdog there */
	else if (!tbtt && !wlc->WDarmed) {
		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
		wlc->WDarmed = TRUE;
		WL_INFORM(("wl%d: wlc_watchdog_upd: watchdog timer is armed\n", WLCWLUNIT(wlc)));
	}
	if (tbtt && !wlc->WDarmed) {
		wl_add_timer(wlc->wl, wlc->wdtimer, wlc_watchdog_backup_bi(wlc), TRUE);
		wlc->WDarmed = TRUE;
	}
}
#endif /* STA */

/* return true if the rateset contains an OFDM rate */
bool
wlc_rateset_isofdm(uint count, uint8 *rates)
{
	int i;

	for (i = count - 1; i >= 0; i--)
		if (IS_OFDM(rates[i]))
			return (TRUE);
	return (FALSE);
}

ratespec_t
wlc_lowest_basic_rspec(wlc_info_t *wlc, wlc_rateset_t *rs)
{
	ratespec_t lowest_basic_rspec;
	uint i;

	/* Use the lowest basic rate */
	lowest_basic_rspec = rs->rates[0] & RATE_MASK;
	for (i = 0; i < rs->count; i++) {
		if (rs->rates[i] & WLC_RATE_FLAG) {
			lowest_basic_rspec = rs->rates[i] & RATE_MASK;
			break;
		}
	}
#if NCONF
	/* pick siso/cdd as default for OFDM (note no basic rate MCSs are supported yet) */
	if (IS_OFDM(lowest_basic_rspec)) {
		lowest_basic_rspec |= (wlc->stf->ss_opmode << RSPEC_STF_SHIFT);
	}
#endif

	return (lowest_basic_rspec);
}

/* This function changes the phytxctl for beacon based on current beacon ratespec AND txant
 * setting as per this table:
 *  ratespec     CCK		ant = wlc->stf->txant
 *  		OFDM		ant = 3
 */
void
wlc_beacon_phytxctl_txant_upd(wlc_info_t *wlc, ratespec_t bcn_rspec)
{
	uint16 phyctl;
	uint16 phytxant = wlc->stf->phytxant;
	uint16 mask = PHY_TXC_ANT_MASK;

	/* for non-siso rates or default setting, use the available chains */
	if (WLC_PHY_11N_CAP(wlc->band)) {
		if (WLCISHTPHY(wlc->band)) {
			mask = PHY_TXC_HTANT_MASK;
			if (bcn_rspec == 0)
				bcn_rspec = wlc->bcn_rspec;
		}
		phytxant = wlc_stf_phytxchain_sel(wlc, bcn_rspec);
	}
	WL_NONE(("wl%d: wlc_beacon_phytxctl_txant_upd: beacon txant 0x%04x mask 0x%04x\n",
		wlc->pub->unit, phytxant, mask));
	phyctl = wlc_read_shm(wlc, M_BCN_PCTLWD);
	phyctl = (phyctl & ~mask) | phytxant;
	wlc_write_shm(wlc, M_BCN_PCTLWD, phyctl);
}

/*
 * This function doesn't change beacon body(plcp, mac hdr). It only updates the
 *   phyctl0 and phyctl1 with the exception of tx antenna,
 *   which is handled in wlc_stf_phy_txant_upd() and wlc_beacon_phytxctl_txant_upd()
 */
void
wlc_beacon_phytxctl(wlc_info_t *wlc, ratespec_t bcn_rspec)
{
	uint16 phyctl;
	int rate;

	phyctl = wlc_read_shm(wlc, M_BCN_PCTLWD);

	phyctl &= ~PHY_TXC_FT_MASK;
	phyctl |= FRAMETYPE(bcn_rspec, wlc->mimoft) & PHY_TXC_FT_MASK;
	/* ??? If ever beacons use short headers or phy pwr override, add the proper bits here. */

	rate = RSPEC2RATE(bcn_rspec);
	if ((WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band)) && IS_CCK(bcn_rspec))
		phyctl |= ((rate * 5) << 10);

	wlc_write_shm(wlc, M_BCN_PCTLWD, phyctl);

	if (WLC_PHY_11N_CAP(wlc->band) || WLCISLPPHY(wlc->band)) {
		uint16 phyctl1;
		uint16 mimo_txbw;

		if (!WLCISLPPHY(wlc->band) && !WLCISLCNPHY(wlc->band)) {
			mimo_txbw = CHSPEC_SB_UPPER(WLC_BAND_PI_RADIO_CHANSPEC) ?
				PHY_TXC1_BW_20MHZ_UP :
				PHY_TXC1_BW_20MHZ;
			bcn_rspec &= ~RSPEC_BW_MASK;
			bcn_rspec |= (mimo_txbw << RSPEC_BW_SHIFT);
		}

		phyctl1 = wlc_phytxctl1_calc(wlc, bcn_rspec);
		wlc_write_shm(wlc, M_BCN_PCTL1WD, phyctl1);
	}
}

#ifdef BCMASSERT_SUPPORT
/* Validate the beacon phytxctl given current band */
bool
wlc_valid_beacon_phytxctl(wlc_info_t *wlc)
{
	uint16 phyctl;

	phyctl = wlc_read_shm(wlc, M_BCN_PCTLWD);

	return ((phyctl & PHY_TXC_FT_MASK) ==
	        (FRAMETYPE(wlc->bcn_rspec, wlc->mimoft) & PHY_TXC_FT_MASK));
}
#endif /* BCMASSERT_SUPPORT */

static void
wlc_BSSinit_rateset_filter(wlc_bsscfg_t *cfg)
{
	uint i, val;
	wlc_info_t *wlc = cfg->wlc;
	wlc_bss_info_t *current_bss = cfg->current_bss;

	/* Japan Channel 14 restrictions */
	if ((CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC) == 14) && (wlc_japan(wlc) == TRUE)) {
		/* Japan does not allow OFDM or MIMO on channel 14 */
		if (wlc->band->gmode) {
			/* filter-out OFDM rates and MCS set */
			wlc_rateset_filter(&current_bss->rateset, &current_bss->rateset,
			                   FALSE, WLC_RATES_CCK, RATE_MASK_FULL, FALSE);
		}
	}


	/* filter-out unsupported rates */
	wlc_rate_hwrs_filter_sort_validate(&current_bss->rateset,
		&wlc->band->hw_rateset, FALSE, wlc->stf->txstreams);

	/* Keep only CCK if gmode == GMODE_LEGACY_B */
	if (BAND_2G(wlc->band->bandtype) && (wlc->band->gmode == GMODE_LEGACY_B))
		wlc_rateset_filter(&current_bss->rateset, &current_bss->rateset,
		                   FALSE, WLC_RATES_CCK, RATE_MASK_FULL, FALSE);

	/* if empty or no basic rates - use driver default rateset */
	/* ??? should fixup all WLC_RATE_FLAG reference to remove this requirement */
	val = 0;
	for (i = 0; i < current_bss->rateset.count; i++)
		if (current_bss->rateset.rates[i] & WLC_RATE_FLAG)
			val = 1;

	if (val == 0) {
		wlc_default_rateset(wlc, &current_bss->rateset);
		/* Keep only CCK if gmode == GMODE_LEGACY_B */
		if (BAND_2G(wlc->band->bandtype) && (wlc->band->gmode == GMODE_LEGACY_B))
			wlc_rateset_filter(&current_bss->rateset, &current_bss->rateset,
			                   FALSE, WLC_RATES_CCK, RATE_MASK_FULL, FALSE);
	}

#ifdef WLP2P
	/* OFDM rates only */
	if (BSS_P2P_ENAB(wlc, cfg)) {
		wlc_rateset_filter(&current_bss->rateset, &current_bss->rateset,
		                   FALSE, WLC_RATES_OFDM, RATE_MASK_FULL,
		                   BSS_N_ENAB(wlc, cfg));
	}
#endif

	wlc_rate_lookup_init(wlc, &current_bss->rateset);
}

/* update PRETBTT: use the maximum value of all needs */
uint16
wlc_pretbtt_calc(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	uint16 mbss_pretbtt = 0, bss_pretbtt = 0;
	uint16 pretbtt;


	/* MBSS pretbtt needs */
	if (MBSS_ENAB(wlc->pub) && BSSCFG_AP(cfg)) {
		mbss_pretbtt = MBSS_PRE_TBTT_DEFAULT_us;
	}


	/* BSS pretbtt needs */
	if (cfg->BSS) {

		if (ISSIM_ENAB(wlc->pub->sih))
			bss_pretbtt = PRETBTT_PHY_US_QT;
		else if (WLCISAPHY(wlc->band))
			bss_pretbtt = PRETBTT_APHY_US;
		else if (WLCISLPPHY(wlc->band) && LPREV_GE(wlc->band->phyrev, 2))
			bss_pretbtt = PRETBTT_LPPHY_US;
		else if (WLCISSSLPNPHY(wlc->band))
			bss_pretbtt = PRETBTT_SSLPNPHY_US;
		else if (WLCISNPHY(wlc->band) && NREV_GE(wlc->band->phyrev, 3))
			bss_pretbtt = PRETBTT_NPHY_US;
		else if (WLCISHTPHY(wlc->band))
			bss_pretbtt = PRETBTT_HTPHY_US;
		else if (WLCISLCNPHY(wlc->band))
			bss_pretbtt = PRETBTT_LCNPHY_US;
		else
			bss_pretbtt = PRETBTT_BPHY_US;
#ifdef WLP2P
		/* ucode requires to double the pre tbtt for P2P, why??? */
		if (BSS_P2P_ENAB(wlc, cfg))
			bss_pretbtt <<= 1;
#endif
	}

	pretbtt = MAX(mbss_pretbtt, bss_pretbtt);
	if (pretbtt == 0)
		pretbtt = 2;

#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub))
		return pretbtt + wlc_mchan_get_pretbtt_time(wlc->mchan);
#endif
	return pretbtt;
}

/* mac is assumed to be suspended at this point */
void
wlc_pretbtt_set(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	uint16 phyctl = wlc_pretbtt_calc(cfg);

	W_REG(wlc->osh, &wlc->regs->tsf_cfppretbtt, phyctl);	/* IHR */
	wlc_write_shm(wlc, M_PRETBTT, phyctl);		/* SHM */
}

#ifdef WLP2P
static void
wlc_dtimnoslp_set(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	uint16 noslp = wlc_pretbtt_calc(cfg);

	noslp += wlc->bcn_wait_prd << 10;

	wlc_write_shm(wlc, M_NOSLPZNATDTIM, noslp >> 3);
}
#endif	/* WLP2P */

void
wlc_macctrl_init(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	uint32 mask = (MCTL_AP | MCTL_INFRA | MCTL_DISCARD_PMQ | MCTL_CLOSED_NETWORK);
	uint32 val = 0;
	int idx;
	wlc_bsscfg_t *bc = NULL;

	ASSERT((cfg->BSS && wlc->ibss_bsscfgs == 0) ||
	       (!cfg->BSS && !AP_ACTIVE(wlc) && wlc->stas_associated == wlc->ibss_bsscfgs));

	/* infrastructure vs ad-hoc, STA vs AP, and PMQ use */
	/* Set AP if this BSS is AP, or an AP BSS is up */
	if (BSSCFG_AP(cfg) || AP_ACTIVE(wlc)) {
		ASSERT(wlc_valid_beacon_phytxctl(wlc));
		val |= MCTL_AP;
	}
	/* As PMQ entries are currently used only by AP for detecting PM Mode transitions
	 * for STA, instruct ucode not to fill up entries in PMQ
	 * CAUTION: For STA, this bit will need to be cleared if we ever support IBSS using
	 * PMQ. Also, validate the phytxctl for the beacon
	 */
	else
		val |= MCTL_DISCARD_PMQ;

	/* Set infrastructure mode if this BSS is INFRA, or other INFRA BSS are up */
	if (cfg->BSS || AP_ACTIVE(wlc) || (wlc->stas_associated > 0 && wlc->ibss_bsscfgs == 0))
		val |= MCTL_INFRA;

	/* if this is the bsscfg for ucode beacon/probe responses,
	 * indicate whether this is a closed network
	 */
	if (HWPRB_ENAB(cfg) && cfg->closednet_nobcprbresp)
		bc = cfg;
	else {
		FOREACH_BSS(wlc, idx, bc) {
			if (bc != cfg && bc->associated &&
			    HWPRB_ENAB(bc) && bc->closednet_nobcprbresp)
				break;
			bc = NULL;
		}
	}
	if (bc != NULL) {
#if defined(BCMDBG) || defined(WLMSG_INFORM)
		char eabuf[ETHER_ADDR_STR_LEN];
#endif
		WL_INFORM(("wl%d: BSS %s is configured as a Closed Network, "
		           "enable MCTL bit in PSM\n", wlc->pub->unit,
		           bcm_ether_ntoa(&cfg->BSSID, eabuf)));
		val |= MCTL_CLOSED_NETWORK;
	}

	wlc_mctrl(wlc, mask, val);
}

void
wlc_BSSinit(wlc_info_t *wlc, wlc_bss_info_t *bi, wlc_bsscfg_t *cfg, char *bcn, int len, int type)
{
	d11regs_t *regs;
	uint bcnint, bcnint_us, cfpp = 0;
	uint16 tim_offset;
	const bool restricted_ap = BSSCFG_AP(cfg) && (wlc->stas_associated > 0);
	osl_t *osh;
	struct scb *scb;
#ifdef STA
	wlc_roam_t *roam = cfg->roam;
#endif
	wlc_bss_info_t *current_bss = cfg->current_bss;
	wlc_prot_cond_t *cond = cfg->prot_cond;
	wlc_prot_cfg_t *prot = cfg->prot_cfg;
	wlc_prot_to_t *to = cfg->prot_to;


	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __FUNCTION__));

	WL_APSTA_UPDN(("wl%d: wlc_BSSinit(), %s, %s, stas/aps/associated %d/%d/%d\n",
		wlc->pub->unit, (BSSCFG_AP(cfg) ? "AP" : "STA"),
		(type == WLC_BSS_START ? "START" : "JOIN"),
		wlc->stas_associated, wlc->aps_associated, wlc->pub->associated));

	regs = wlc->regs;
	osh = wlc->osh;

	/* update our infrastructure mode */
	cfg->BSS = (bi->infra == 1);

	/* clear out bookkeeping */
#ifdef STA
	/* Only clear when STA (re)joins a BSS */
	if (BSSCFG_STA(cfg)) {
		roam->time_since_bcn = 0;
		roam->bcns_lost = FALSE;
		roam->tsf_l = roam->tsf_h = 0;
		roam->tbtt_since_bcn = 0;
	}
#endif /* STA */

	/* 11g/11n protections */
	bzero(cond, sizeof(*cond));
	bzero(to, sizeof(*to));

	if (wlc->aps_associated == 0 || !cfg->BSS) {
#ifdef WLAFTERBURNER
		wlc->protection->nonabcap_assoc = FALSE;
#endif /* WLAFTERBURNER */
		/* reset BSS local power limits */
		wlc->txpwr_local_max = WLC_TXPWR_MAX;

		/* Need to set the txpwr_local_max to external reg max for
		 * this channel as per the locale selected for AP.
		 */
		if (AP_ONLY(wlc->pub)) {
			wlc->txpwr_local_max = wlc_get_reg_max_power_for_channel(wlc->cmi,
				CHSPEC_CHANNEL(wlc->chanspec), TRUE);
		}
		wlc->txpwr_local_constraint = 0;
	}

#ifdef STA
	/* Reset the frequency tracking b/w to default values */
	if (BSSCFG_STA(cfg))
		wlc_freqtrack_reset(wlc);
#endif /* STA */

	/* update current BSS information */
	if (bi != current_bss) {
		if (current_bss->bcn_prb)
			MFREE(osh, current_bss->bcn_prb, current_bss->bcn_prb_len);
		current_bss->bcn_prb = NULL;
		current_bss->bcn_prb_len = 0;
		bcopy((char*)bi, (char*)current_bss, sizeof(wlc_bss_info_t));
		if (bi->bcn_prb) {
			/* need to copy bcn_prb, too */
			current_bss->bcn_prb =
			        (struct dot11_bcn_prb *)MALLOC(osh, bi->bcn_prb_len);
			if (current_bss->bcn_prb) {
				bcopy((char*)bi->bcn_prb, (char*)current_bss->bcn_prb,
					bi->bcn_prb_len);
				current_bss->bcn_prb_len = bi->bcn_prb_len;
			} else {
				WL_ERROR(("wl%d: wlc_BSSinit: out of memory, malloced %d bytes\n",
					wlc->pub->unit, MALLOCED(osh)));
			}
		}
	}

#ifdef STA
	/* apply the capability and additional IE params stored in wlc_join_BSS() */
	if (N_ENAB(wlc->pub) && type == WLC_BSS_JOIN) {

	}
#endif

	/* Validate chanspec in case the locale has changed */
	if (BSSCFG_AP(cfg) &&
	    !wlc_valid_chanspec_db(wlc->cmi, current_bss->chanspec)) {
		ASSERT(!cfg->associated);
		current_bss->chanspec = wlc_default_chanspec(wlc->cmi, FALSE);
		ASSERT(current_bss->chanspec != INVCHANSPEC);
	}

	/* Set the shared wlc->home_chanspec */
#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub) && BSSCFG_AP(cfg) && (cfg->chan_context != NULL)) {
		/* AP has a channel context so let multichannel switcher take care
		 * of the channel switch.
		 */
		WL_MCHAN(("MCHAN: AP cfg has chan_context, don't change channel\n"));
	}
	/* May be we want to set the context anyway here */
	else
#endif
	{
	wlc_set_home_chanspec(wlc, current_bss->chanspec);

	/*
	 * Set the radio channel to current_bss->chanspec.
	 * Must do this before the rate calculations below.
	 */
	if (WLC_BAND_PI_RADIO_CHANSPEC != current_bss->chanspec) {
		wlc_set_chanspec(wlc, current_bss->chanspec);
	}
	}

	wlc_BSSinit_rateset_filter(cfg);

	/* Validate beacon interval, we should never create a 0 beacon period BSS/IBSS */
	if (type == WLC_BSS_START) {
		ASSERT(current_bss->beacon_period);
	}
	/* don't adopt a illegal beacon_period IBSS */
	if (current_bss->beacon_period == 0) {
		current_bss->beacon_period = ISSIM_ENAB(wlc->pub->sih) ?
			BEACON_INTERVAL_DEF_QT : BEACON_INTERVAL_DEFAULT;
	}

	/* initialize BSSID information */
	cfg->BSSID = current_bss->BSSID;
	cfg->prev_BSSID = current_bss->BSSID;

	/* clear all old non-permanent scbs for IBSS only if assoc recreate is not enabled */
	/* and WLC_BSSCFG_PRESERVE cfg flag is not set */
	if (!cfg->BSS &&
	    !(ASSOC_RECREATE_ENAB(wlc->pub) && (cfg->flags & WLC_BSSCFG_PRESERVE)))
		wlc_bsscfg_scbclear(wlc, cfg, FALSE);

	/* write the BSSID (to RXE) */
	wlc_set_bssid(cfg);

	/* Update shared memory with MAC */
	wlc_set_mac(cfg);

	/* write to SHM to adjust the ucode ACK/CTS rate tables... */
	wlc_set_ratetable(wlc);

	/* the world is new again, so is our reported rate */
	if (!wlc->pub->associated)
		wlc_bsscfg_reprate_init(cfg);

	/* update the CCK preamble mode for STAs joining an AP */
	if (BSSCFG_STA(cfg) && cfg->BSS)
		prot->shortpreamble = ((current_bss->capability & DOT11_CAP_SHORT) != 0);

	/* Update the gmode protection state */
	if (wlc->band->gmode &&
	    (BSSCFG_AP(cfg) || !cfg->BSS)) {
		wlc_protection_g_sync(cfg);
		prot->erp_ie_use_protection = prot->_g;
	}

	if (wlc->band->gmode && !restricted_ap) {

		/* update shortslot state now before founding or joining a BSS */
		if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
			if (type == WLC_BSS_JOIN)
				/* STA JOIN: adopt the 11g shortslot mode of the network */
				wlc->shortslot =
				        (current_bss->capability & DOT11_CAP_SHORTSLOT) != 0;
			else if (BSSCFG_AP(cfg))	/* AP START: in short slot mode */
				wlc->shortslot = TRUE;
			else	/* IBSS START: depending on user setting in advanced tab. */
				wlc->shortslot =
				        (wlc->default_bss->capability & DOT11_CAP_SHORTSLOT) != 0;
		} else {
			/* Switch to long or short slot mode based on the override */
			wlc->shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
		}
		wlc_bmac_set_shortslot(wlc->hw, wlc->shortslot);
	}

	/* Legacy B update */
	if (BAND_2G(wlc->band->bandtype) &&
	    (wlc->band->gmode == GMODE_LEGACY_B) && BSSCFG_AP(cfg)) {
		ASSERT(wlc->shortslot_override == WLC_SHORTSLOT_OFF);
		wlc->shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
		wlc_bmac_set_shortslot(wlc->hw, wlc->shortslot);

		/* Update aCWmin based on basic rates. */
		wlc_cwmin_gphy_update(wlc, &current_bss->rateset, TRUE);
	}

#ifdef WL11N
	/* set default n-protection */
	if (N_ENAB(wlc->pub)) {
		wlc_protection_ncfg_sync(cfg);
		wlc_protection_n_nongf_sync(cfg);
	}
#endif /* WL11N */

	if (BSSCFG_AP(cfg) || !cfg->BSS) {
		/* Create a Beacon and Probe Response template */
		ratespec_t bcn_rspec;

		/* update our capability */
		current_bss->capability &= ~DOT11_CAP_SHORT;
		if (BSSCFG_AP(cfg)) {
			if (cfg->PLCPHdr_override == WLC_PLCP_SHORT)
				current_bss->capability |= DOT11_CAP_SHORT;
		} else {
			/* use IBSSGmode setting for bcn and prb cap */
			if (wlc->default_bss->capability & DOT11_CAP_SHORT)
				current_bss->capability |= DOT11_CAP_SHORT;
		}

		/* update the capability based on current shortslot mode */
		current_bss->capability &= ~DOT11_CAP_SHORTSLOT;
		if (wlc->shortslot && wlc->band->gmode)
			current_bss->capability |= DOT11_CAP_SHORTSLOT;

		/* default ERP bits */
		prot->erp_ie_nonerp = FALSE;
		prot->barker_preamble = WLC_BARKER_SHORT_ALLOWED;

		/* Use the lowest basic rate for beacons */
		bcn_rspec = wlc_lowest_basic_rspec(wlc, &current_bss->rateset);
		ASSERT(wlc_valid_rate(wlc, bcn_rspec,
		                      CHSPEC_IS2G(current_bss->chanspec) ?
		                      WLC_BAND_2G : WLC_BAND_5G, TRUE));
		wlc->bcn_rspec = bcn_rspec;

		if (restricted_ap)
			/* bcn rspec changes if sta connects in different band */
			wlc_beacon_phytxctl(wlc, bcn_rspec);

		/* create a beacon template */
		wlc_bcn_prb_template(wlc, FC_BEACON, bcn_rspec, cfg, (uint16 *) bcn, &len);

		/* set a default bcn_prb for IBSS */
		if (BSSCFG_STA(cfg) && current_bss->bcn_prb == NULL) {
			uint hdr_len = D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN;
			current_bss->bcn_prb =
			        (struct dot11_bcn_prb *)MALLOC(osh, len - hdr_len);
			if (current_bss->bcn_prb) {
				bcopy((char*)bcn + hdr_len, (char*)current_bss->bcn_prb,
				      len - hdr_len);
				current_bss->bcn_prb_len = len - hdr_len;
			} else {
				WL_ERROR(("wl%d: wlc_BSSinit: out of memory, malloced %d bytes\n",
					wlc->pub->unit, MALLOCED(osh)));
				current_bss->bcn_prb_len = 0;
			}
		}

		/* write template to hardware if this is the designated beaconing bsscfg */
		if (HWBCN_ENAB(cfg)) {
			/* copy beacon into both template 0 and 1, since we don't know which the
			 * ucode will use next
			 */

			wlc_write_hw_bcntemplates(wlc, bcn, len, TRUE);

			if (cfg->BSS) {
				uint8* cp;

				/* find the TIM elt offset in the bcn template */
				cp = (uint8*)bcn + D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN +
					DOT11_BCN_PRB_LEN;
				cp = (uint8*)bcm_parse_tlvs(cp, len, DOT11_MNG_TIM_ID);
				/* catch preparation bug; the bcn should have a TIM */
				ASSERT(cp != NULL);

				tim_offset = (uint16)(cp - (uint8*)bcn);
				wlc_write_shm(wlc, M_TIMBPOS_INBEACON, tim_offset);
			}
		}

		/* For IBSS, update the beacon phytxctl */
		if (!cfg->associated || !cfg->BSS) {
			wlc->band->bcntsfoff = wlc_compute_bcntsfoff(wlc, bcn_rspec, FALSE, TRUE);
			ASSERT(wlc->band->bcntsfoff != 0);

			wlc_write_shm(wlc, M_BCN_TXTSF_OFFSET, wlc->band->bcntsfoff);
			wlc_beacon_phytxctl(wlc, bcn_rspec);

			/* DTIM changes are not applicable to IBSS of course */
			if (cfg->BSS) {
				/* set DTIM count to 0 in SCR */
				W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL + S_DOT11_DTIMCOUNT);
				(void)R_REG(osh, &regs->objaddr);
				W_REG(osh, &regs->objdata, 0);

				/* set DTIM period: using default_bss works for
				 * any AP mode (APONLY and APSTA)
				 */
				wlc_write_shm(wlc, M_DOT11_DTIMPERIOD,
				              wlc->default_bss->dtim_period);
			}
		}

		wlc_bss_update_probe_resp(wlc, cfg, FALSE);
	}

#ifdef STA
	if (BSSCFG_STA(cfg)) {
		if (!cfg->BSS) {
			/* program the ATIM window */
			if (current_bss->atim_window) {
				/* note that CFP is present */
				cfpp = CFPREP_CFPP;
			}
			/* set CFP duration */
			W_REG(osh, &regs->tsf_cfpmaxdur32, (uint32)current_bss->atim_window);
		}

		/* set initial RSSI value */
		wlc_lq_rssi_reset_ma(cfg, WLC_RSSI_EXCELLENT);
		wlc_phy_BSSinit(wlc->band->pi, FALSE, WLC_RSSI_EXCELLENT);
		wlc_lq_rssi_init(wlc, WLC_RSSI_EXCELLENT);
	}
#endif /* STA */

	/* First AP starting a BSS, or STA starting an IBSS */
	if (type == WLC_BSS_START && wlc->aps_associated == 0) {
#ifdef WLMCHAN
		/* If already have stations associated, need to move STA to per bss
		 * tbtt and reset tsf for AP to make AP tbtt land in the middle of
		 * STA's bcn period
		 */
		if (MCHAN_ENAB(wlc->pub) && BSSCFG_AP(cfg) &&
		    STA_ACTIVE(wlc))
			wlc_bsscfg_ap_tbtt_setup(wlc, cfg);
		else
#endif
		{
			uint32 new_l = 0, new_h = 0;
#ifdef WLP2P
			uint32 old_l, old_h;
#endif

			/* Program the next TBTT and adjust TSF timer.
			 * If we are not starting the BSS, then the TSF timer adjust is done
			 * at beacon reception time.
			 */
			/* Using upstream beacon period will make APSTA 11H easier */
			bcnint = current_bss->beacon_period;
			bcnint_us = ((uint32)bcnint << 10);

			WL_APSTA_TSF(("wl%d: wlc_BSSinit(): starting TSF, bcnint %d\n",
			              wlc->pub->unit, bcnint));

#ifdef WLP2P
			if (P2P_ENAB(wlc->pub) && BSSCFG_AP(cfg))
				wlc_read_tsf(wlc, &old_l, &old_h);
#endif

			/* reset the TSF timer */
			W_REG(osh, &regs->tsf_timerlow, new_l);
			W_REG(osh, &regs->tsf_timerhigh, new_h);

#ifdef WLP2P
			/* update P2P links' tbtt */
			if (P2P_ENAB(wlc->pub) && BSSCFG_AP(cfg)) {
				int32 off_l = (int32)new_l;
				int32 off_h = (int32)new_h;
				wlc_uint64_sub((uint32 *)&off_h, (uint32 *)&off_l, old_h, old_l);
				wlc_p2p_tbtt_adj(wlc->p2p, off_h, off_l);
			}
#endif

			/* write the beacon interval (to TSF) */
			W_REG(osh, &regs->tsf_cfprep, (bcnint_us << CFPREP_CBI_SHIFT) | cfpp);

			/* CFP start is the next beacon interval after timestamp */
			W_REG(osh, &regs->tsf_cfpstart, bcnint_us);
		}

	}

	wlc_macctrl_init(cfg);

#ifdef WLP2P
		/* update GO's channel */
		if (P2P_ENAB(wlc->pub) && (BSSCFG_AP(cfg) || BSSCFG_IBSS(cfg))) {
			chanspec_t chanspec =
#ifdef WLMCHAN
			        (MCHAN_ENAB(wlc->pub) && cfg->chan_context != NULL) ?
			        cfg->chan_context->chanspec :
#endif
			        current_bss->chanspec;
			uint16 go_chan = CHSPEC_CHANNEL(chanspec);
			if (CHSPEC_IS5G(chanspec))
				go_chan |= D11_CURCHANNEL_5G;
			if (CHSPEC_IS40(chanspec))
				go_chan |= D11_CURCHANNEL_40;
			wlc_p2p_write_shm(wlc->p2p, M_P2P_GO_CHANNEL, go_chan);
		}
#endif /* WLP2P */

#ifdef STA
	/* Entering IBSS: make sure bcn promisc is on */
	if (!cfg->BSS) {
		wlc_ibss_enable(cfg);
	}
#endif /* STA */

	/* update bcast/mcast rateset */
	if (!(cfg->flags & WLC_BSSCFG_NOBCMC)) {
		scb = WLC_BCMCSCB_GET(wlc, cfg);
		ASSERT(scb != NULL);
		wlc_rateset_filter(&current_bss->rateset, &scb->rateset,
		                   FALSE, WLC_RATES_CCK_OFDM, RATE_MASK, BSS_N_ENAB(wlc, cfg));
	}

	wlc_pretbtt_set(cfg);

#ifdef WLP2P
	/* extend beacon timeout to cover possible long pretbtt */
	if (P2P_ENAB(wlc->pub)) {
		if (BSSCFG_STA(cfg) && cfg->BSS)
			wlc_dtimnoslp_set(cfg);
	}
#endif

#if defined(STA) && defined(WLCAC)
	if (BSSCFG_STA(cfg) && cfg->BSS && CAC_ENAB(wlc->pub)) {
		wlc_cac_on_join_bss(wlc->cac, &current_bss->BSSID, (cfg->assoc->type == AS_ROAM));
	}
#endif /* STA && WLCAC */
}

/* centralized protection config change function to simplify debugging, no consistency checking
 * this should be called only on changes to avoid overhead in periodic function
*/
static void
wlc_protection_set(wlc_info_t *wlc, uint idx, int val)
{
	wlc_protection_t *prot = wlc->protection;

	WL_TRACE(("wlc_protection_set: idx %d, val %d\n", idx, val));

	switch (idx) {
	case WLC_PROT_G_USER:	prot->gmode_user = (uint8)val; break;
	case WLC_PROT_N_USER:	prot->nmode_user = (int8)val; break;
	case WLC_PROT_N_PAM_OVR:	prot->n_pam_override = (int8)val; break;

	default:
		ASSERT(0);
		break;
	}
}

void
wlc_protection_upd(wlc_bsscfg_t *cfg, uint idx, int val)
{
	wlc_prot_cfg_t *prot = cfg->prot_cfg;

	WL_TRACE(("wlc_protection_upd: cfg %d, idx %d, val %d\n", WLC_BSSCFG_IDX(cfg), idx, val));

	switch (idx) {
	case WLC_PROT_G_SPEC:	prot->_g = (bool)val; break;
	case WLC_PROT_G_OVR:	prot->g_override = (int8)val; break;
	case WLC_PROT_OVERLAP:	prot->overlap = (int8)val; break;
	case WLC_PROT_N_CFG:		prot->n_cfg = (int8)val; break;
	case WLC_PROT_N_CFG_OVR:	prot->n_cfg_override = (int8)val; break;
	case WLC_PROT_N_NONGF:		prot->nongf = (bool)val; break;
	case WLC_PROT_N_NONGF_OVR:	prot->nongf_override = (int8)val; break;
	case WLC_PROT_N_OBSS:		prot->n_obss = (bool)val; break;

	default:
		ASSERT(0);
		break;
	}

}

/* update g_cfg, but comply with its override */
void
wlc_protection_g_sync(wlc_bsscfg_t *cfg)
{
	wlc_prot_cfg_t *prot = cfg->prot_cfg;

	/* don't update if there is no change */
	if (prot->g_override == WLC_PROTECTION_AUTO) {
		if (prot->_g)
			wlc_protection_upd(cfg, WLC_PROT_G_SPEC, (int)FALSE);
	} else {
		if (prot->_g != (prot->g_override == WLC_PROTECTION_ON))
			wlc_protection_upd(cfg, WLC_PROT_G_SPEC,
				(prot->g_override == WLC_PROTECTION_ON));
	}
}

#ifdef WL11N
/* update n_cfg, but comply with its override */
void
wlc_protection_ncfg_sync(wlc_bsscfg_t *cfg)
{
	wlc_prot_cfg_t *prot = cfg->prot_cfg;

	wlc_protection_upd(cfg, WLC_PROT_N_OBSS, FALSE);

	if (prot->n_cfg_override == WLC_PROTECTION_AUTO) {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, WLC_N_PROTECTION_OFF);
	} else if (prot->n_cfg_override == WLC_PROTECTION_ON) {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, WLC_N_PROTECTION_MIXEDMODE);
		wlc_protection_upd(cfg, WLC_PROT_N_OBSS, TRUE);
	} else if (prot->n_cfg_override == WLC_PROTECTION_MMHDR_ONLY) {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, WLC_N_PROTECTION_OPTIONAL);
	} else if (prot->n_cfg_override == WLC_PROTECTION_CTS_ONLY) {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, WLC_N_PROTECTION_20IN40);
	} else {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, WLC_N_PROTECTION_OFF);
	}
}

static void
wlc_protection_n_nongf_sync(wlc_bsscfg_t *cfg)
{
	wlc_prot_cfg_t *prot = cfg->prot_cfg;

	if (prot->nongf_override == WLC_PROTECTION_AUTO)
		wlc_protection_upd(cfg, WLC_PROT_N_NONGF, FALSE);
	else
		wlc_protection_upd(cfg, WLC_PROT_N_NONGF,
			(prot->nongf_override == WLC_PROTECTION_ON));
}

static void
wlc_ht_update_sgi_rx(wlc_info_t *wlc, int val)
{
	wlc->ht_cap.cap &= ~(HT_CAP_SHORT_GI_20 | HT_CAP_SHORT_GI_40);
	wlc->ht_cap.cap |= (val & WLC_N_SGI_20) ? HT_CAP_SHORT_GI_20 : 0;
	wlc->ht_cap.cap |= (val & WLC_N_SGI_40) ? HT_CAP_SHORT_GI_40 : 0;

	if (wlc->pub->up) {
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, TRUE);
	}
}

static void
wlc_ht_update_ldpc(wlc_info_t *wlc, int8 val)
{
	wlc->stf->ldpc = val;

	wlc->ht_cap.cap &= ~HT_CAP_LDPC_CODING;
	if (wlc->stf->ldpc != OFF)
		wlc->ht_cap.cap |= HT_CAP_LDPC_CODING;

	if (wlc->pub->up) {
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, TRUE);
		wlc_phy_ldpc_override_set(wlc->band->pi, (val ? TRUE : FALSE));
	}
}
#endif /* WL11N */

#ifdef STA
void
wlc_tsf_adopt_bcn(wlc_bsscfg_t *cfg, wlc_d11rxhdr_t *wrxh, uint8 *plcp, struct dot11_bcn_prb *bcn)
{
	wlc_info_t *wlc = cfg->wlc;
	d11regs_t *regs = wlc->regs;
	uint32 bi;
	uint32 tsf_l, tsf_h;
	osl_t *osh;

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub) && cfg->BSS)
		return;
#endif

	if (cfg != wlc->cfg)
		return;

	/* APSTA If an AP, don't sync to upstream TSF */
	if (AP_ACTIVE(wlc))
		return;

	osh = wlc->osh;

	tsf_l = ltoh32_ua(&bcn->timestamp[0]);
	tsf_h = ltoh32_ua(&bcn->timestamp[1]);

	bi = ltoh16(bcn->beacon_interval);
	if (bi == 0)	/* bad AP, change to a valid value */
		bi = 1024;

	/* write beacon's timestamp directly to TSF timer */

	/* Hold TBTTs */
	wlc_mctrl(wlc, MCTL_TBTT_HOLD, MCTL_TBTT_HOLD);

	/* low first, then high so the 64bit write is atomic */
	W_REG(osh, &regs->tsf_timerlow, tsf_l);
	W_REG(osh, &regs->tsf_timerhigh, tsf_h);

	/* write the beacon interval (to TSF) */
	W_REG(osh, &regs->tsf_cfprep, (bi << NBITS(uint16)));

	/* update the TBTT in the core */
	wlc_tbtt_adopt(cfg, bcn);

	/* Release hold on TBTTs */
	wlc_mctrl(wlc, MCTL_TBTT_HOLD, 0);
}

static bool
wlc_check_tbtt(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	d11regs_t *regs = wlc->regs;
	uint32 bi;
	uint32 tsf_l, tbtt;

	if (cfg != wlc->cfg)
		return FALSE;

	/* APSTA If an AP, don't sync to upstream TSF */
	if (AP_ACTIVE(wlc))
		return FALSE;

	if (cfg->pm->check_for_unaligned_tbtt)
		return FALSE;

	/* set threshold to be twice the target tbtt */
	bi = 2 * wlc->cfg->current_bss->beacon_period;
	if (wlc->cfg->BSS) {
		bi *= wlc->cfg->current_bss->dtim_period;

		if (wlc->bcn_li_dtim)
			bi *= wlc->bcn_li_dtim;
		else if (wlc->bcn_li_bcn)
			/* re-calculate bi based on bcn_li_bcn */
			bi = 2*wlc->bcn_li_bcn*wlc->cfg->current_bss->beacon_period;
	}

	bi <<= 10; /* convert TU into us */

	tsf_l = R_REG(wlc->osh, &regs->tsf_timerlow);
	tbtt = R_REG(wlc->osh, &regs->tsf_cfpstart);

	/*
	 * There is a rare case when tbtt wrap around and this check become true even
	 * though the value is in range. But a misfire in hours should be ok as this is
	 * a safety check anyway
	*/
	if ((tbtt < tsf_l) || (tbtt > tsf_l + bi)) {
		WL_ASSOC(("wl%d: %s: cfpstart = 0x%x, tsf = 0x%x, bi = 0x%x\n",
		          wlc->pub->unit, __FUNCTION__, tbtt, tsf_l, bi));
		return TRUE;
	}
	return FALSE;
}
#endif /* STA */

/*
 * ucode, hwmac update
 *    Channel dependent updates for ucode and hw
 */
static void
wlc_ucode_mac_upd(wlc_info_t *wlc)
{
#ifdef STA
	int idx;
	wlc_bsscfg_t *cfg;

	/* enable or disable any active IBSSs depending on whether or not
	 * we are on the home channel
	 */
	if (wlc->home_chanspec == WLC_BAND_PI_RADIO_CHANSPEC) {
		FOREACH_AS_STA(wlc, idx, cfg) {
			if (!cfg->BSS && cfg->up) {
				wlc_ibss_enable(cfg);
			}
		}
		if (wlc->pub->associated) {
			/* BMAC_NOTE: This is something that should be fixed in ucode inits.
			 * I think that the ucode inits set up the bcn templates and shm values
			 * with a bogus beacon. This should not be done in the inits. If ucode needs
			 * to set up a beacon for testing, the test routines should write it down,
			 * not expect the inits to populate a bogus beacon.
			 */
			if (WLC_PHY_11N_CAP(wlc->band)) {
				wlc_write_shm(wlc, M_BCN_TXTSF_OFFSET, wlc->band->bcntsfoff);
			}
		}
	} else {
		/* disable an active IBSS if we are not on the home channel */
		FOREACH_AS_STA(wlc, idx, cfg) {
			if (!cfg->BSS && cfg->up) {
				wlc_ibss_disable(cfg);
			}
		}
	}
#endif /* STA */

	/* update the various promisc bits */
	wlc_mac_bcn_promisc(wlc);
	wlc_mac_promisc(wlc);
}

static void
wlc_bandinit_ordered(wlc_info_t *wlc, chanspec_t chanspec)
{
	wlc_rateset_t default_rateset;
	uint parkband;
	uint i, band_order[2];

	WL_TRACE(("wl%d: wlc_bandinit_ordered\n", wlc->pub->unit));
	/*
	 * We might have been bandlocked during down and the chip power-cycled (hibernate).
	 * figure out the right band to park on
	 */
	if (wlc->bandlocked || NBANDS(wlc) == 1) {
		ASSERT(CHSPEC_WLCBANDUNIT(chanspec) == wlc->band->bandunit);

		parkband = wlc->band->bandunit;	/* updated in wlc_bandlock() */
		band_order[0] = band_order[1] = parkband;
	} else {
		/* park on the band of the specified chanspec */
		parkband = CHSPEC_WLCBANDUNIT(chanspec);

		/* order so that parkband initialize last */
		band_order[0] = parkband ^ 1;
		band_order[1] = parkband;
	}

	/* make each band operational, software state init */
	for (i = 0; i < NBANDS(wlc); i++) {
		uint j = band_order[i];

		wlc->band = wlc->bandstate[j];

		ASSERT(wlc->bandstate[j]->hwrs_scb != NULL);

		wlc_default_rateset(wlc, &default_rateset);

		/* fill in hw_rate */
		wlc_rateset_filter(&default_rateset, &wlc->band->hw_rateset,
			FALSE, WLC_RATES_CCK_OFDM, RATE_MASK, (bool)N_ENAB(wlc->pub));

		/* init basic rate lookup */
		wlc_rate_lookup_init(wlc, &default_rateset);
	}

	wlc_set_home_chanspec(wlc, chanspec);

#ifdef WLCHANIM
	wlc_chanim_acc_reset(wlc);
	wlc_set_home_chanspec(wlc, chanspec);
	wlc_chanim_update(wlc, wlc->chanspec, CHANIM_CHANSPEC);
#endif

	/* sync up phy/radio chanspec */
	wlc_set_phy_chanspec(wlc, chanspec);
}

/* band-specific init */
static void
WLBANDINITFN(wlc_bsinit)(wlc_info_t *wlc)
{
	WL_TRACE(("wl%d: wlc_bsinit: bandunit %d\n", wlc->pub->unit, wlc->band->bandunit));

	/* write ucode ACK/CTS rate table */
	wlc_set_ratetable(wlc);

	/* update some band specific mac configuration */
	wlc_ucode_mac_upd(wlc);

#ifdef WL11N
	/* init antenna selection */
	if (WLANTSEL_ENAB(wlc))
		wlc_antsel_init(wlc->asi);
#endif

#ifdef STA
#ifdef WLC_LOW
	/* If we just switched to the B/G band and we had enabled wideband frequency
	 * tracking OR if wideband frequency tracking is always on, then ensure that
	 * the PHY registers have the right settings
	 */
	if (wlc->band->bandunit == wlc->hw->band->bandunit) {
		if ((wlc->freqtrack || (wlc->freqtrack_override == FREQTRACK_ON)) &&
		    WLCISGPHY(wlc->band)) {
			wlc_phy_freqtrack_start(wlc->band->pi);
		}
	}
#endif /* WLC_LOW */
#endif /* STA */
}

/* switch to and initialize new band */
static void
WLBANDINITFN(wlc_setband)(wlc_info_t *wlc, uint bandunit)
{
#ifdef STA
	int idx;
	wlc_bsscfg_t *cfg;
#endif

	ASSERT(NBANDS(wlc) > 1);
	ASSERT(!wlc->bandlocked);
	ASSERT(bandunit != wlc->band->bandunit || wlc->bandinit_pending);

	WL_DUAL(("DUALBAND: wlc_setband: bandunit %d\n", bandunit));

	wlc->band = wlc->bandstate[bandunit];

	if (!wlc->pub->up)
		return;

#ifdef STA
	/* wait for at least one beacon before entering sleeping state */
	FOREACH_AS_STA(wlc, idx, cfg)
	        wlc_set_pmawakebcn(cfg, TRUE);
#endif

	/* band-specific initializations */
	wlc_bsinit(wlc);
}

#ifdef WME
/* Initialize a WME Parameter Info Element with default STA parameters from WMM Spec, Table 12 */
void
wlc_wme_initparams_sta(wlc_info_t *wlc, wme_param_ie_t *pe)
{
	static const wme_param_ie_t stadef = {
		WME_OUI,
		WME_TYPE,
		WME_SUBTYPE_PARAM_IE,
		WME_VER,
		0,
		0,
		{
			{ EDCF_AC_BE_ACI_STA, EDCF_AC_BE_ECW_STA, HTOL16(EDCF_AC_BE_TXOP_STA) },
			{ EDCF_AC_BK_ACI_STA, EDCF_AC_BK_ECW_STA, HTOL16(EDCF_AC_BK_TXOP_STA) },
			{ EDCF_AC_VI_ACI_STA, EDCF_AC_VI_ECW_STA, HTOL16(EDCF_AC_VI_TXOP_STA) },
			{ EDCF_AC_VO_ACI_STA, EDCF_AC_VO_ECW_STA, HTOL16(EDCF_AC_VO_TXOP_STA) }
		}
	};

	ASSERT(sizeof(*pe) == WME_PARAM_IE_LEN);
	memcpy(pe, &stadef, sizeof(*pe));
}
#endif /* WME */

/*
 * Check if this TLVS entry is a WME IE or params IE entry.
 * If not, move the tlvs pointer/length to indicate the next TLVS entry.
 */
bool
wlc_is_wme_ie(wlc_info_t *wlc, uint8 *ie, uint8 **tlvs, uint *tlvs_len)
{
	/* If the contents match the WME_OUI, type=2, and supported subtype */
	if ((ie[TLV_LEN_OFF] == WME_IE_LEN &&
	     !bcmp(&ie[TLV_BODY_OFF], WME_OUI "\x02\x00", 5)) ||	/* WMM IE */
	    (ie[TLV_LEN_OFF] == WME_PARAM_IE_LEN &&
	     !bcmp(&ie[TLV_BODY_OFF], WME_OUI "\x02\x01", 5))) {	/* WMM PE */
		return TRUE;
	}

	/* point to the next ie */
	ie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;
	/* calculate the length of the rest of the buffer */
	*tlvs_len -= (uint)(ie - *tlvs);
	/* update the pointer to the start of the buffer */
	*tlvs = ie;

	return FALSE;
}

void
wlc_edcf_setparams(wlc_bsscfg_t *cfg, bool suspend)
{
	wlc_info_t *wlc = cfg->wlc;
	uint aci, i, j;
	edcf_acparam_t *edcf_acp;
	shm_acparams_t acp_shm;
	uint16 *shm_entry;

	WL_INFORM(("wl%d: %s\n", wlc->pub->unit, __FUNCTION__));

	/* Only apply params if the core is out of reset and has clocks */
	if (!wlc->clk)
		return;

	/*
	 * AP uses AC params from wme_param_ie_ap.
	 * AP advertises AC params from wme_param_ie.
	 * STA uses AC params from wme_param_ie.
	 */

	/* APSTA: Caller should copy intended params to ap_params */
	if (AP_ENAB(wlc->pub))
		edcf_acp = (edcf_acparam_t *)&wlc->ap->wme_param_ie_ap.acparam[0];
	else
		edcf_acp = (edcf_acparam_t *)&wlc->wme_param_ie.acparam[0];

	wlc->wme_admctl = 0;

	for (i = 0; i < AC_COUNT; i++, edcf_acp++) {
		bzero((char*)&acp_shm, sizeof(shm_acparams_t));
		/* find out which ac this set of params applies to */
		aci = (edcf_acp->ACI & EDCF_ACI_MASK) >> EDCF_ACI_SHIFT;
		ASSERT(aci < AC_COUNT);
		/* set the admission control policy for this AC */
		if (edcf_acp->ACI & EDCF_ACM_MASK) {
			wlc->wme_admctl |= 1 << aci;
		}

		/* fill in shm ac params struct */
		acp_shm.txop = ltoh16(edcf_acp->TXOP);
		/* convert from units of 32us to us for ucode */
		wlc->edcf_txop[aci] = acp_shm.txop = EDCF_TXOP2USEC(acp_shm.txop);
		acp_shm.aifs = (edcf_acp->ACI & EDCF_AIFSN_MASK);

#ifdef STA
		if (aci == AC_VI && acp_shm.txop == 0 && acp_shm.aifs < EDCF_AIFSN_MAX)
			acp_shm.aifs++;
#endif /* STA */

		if (acp_shm.aifs < EDCF_AIFSN_MIN || acp_shm.aifs > EDCF_AIFSN_MAX) {
			WL_ERROR(("wl%d: wlc_edcf_setparams: bad aifs %d\n", wlc->pub->unit,
				acp_shm.aifs));
			continue;
		}


		/* CWmin = 2^(ECWmin) - 1 */
		acp_shm.cwmin = EDCF_ECW2CW(edcf_acp->ECW & EDCF_ECWMIN_MASK);
		/* CWmax = 2^(ECWmax) - 1 */
		acp_shm.cwmax = EDCF_ECW2CW((edcf_acp->ECW & EDCF_ECWMAX_MASK)
					    >> EDCF_ECWMAX_SHIFT);
		acp_shm.cwcur = acp_shm.cwmin;
		acp_shm.bslots = R_REG(wlc->osh, &wlc->regs->tsf_random) & acp_shm.cwcur;
		acp_shm.reggap = acp_shm.bslots + acp_shm.aifs;
		/* Indicate the new params to the ucode */
		acp_shm.status = wlc_read_shm(wlc, (M_EDCF_QINFO +
		                                    wme_shmemacindex(aci) * M_EDCF_QLEN +
		                                    M_EDCF_STATUS_OFF));
		acp_shm.status |= WME_STATUS_NEWAC;

		/* Fill in shm acparam table */
		shm_entry = (uint16*)&acp_shm;
		for (j = 0; j < (int)sizeof(shm_acparams_t); j += 2)
			wlc_write_shm(wlc,
			              M_EDCF_QINFO + wme_shmemacindex(aci) * M_EDCF_QLEN + j,
			              *shm_entry++);

		WL_INFORM(("wl%d: Setting %s: txop 0x%x cwmin 0x%x cwmax 0x%x "
		           "cwcur 0x%x aifs 0x%x bslots 0x%x reggap 0x%x status 0x%x\n",
		           wlc->pub->unit, aci_names[aci], acp_shm.txop, acp_shm.cwmin,
		           acp_shm.cwmax, acp_shm.cwcur, acp_shm.aifs,
		           acp_shm.bslots, acp_shm.reggap, acp_shm.status));

	}

	if (suspend)
		wlc_suspend_mac_and_wait(wlc);

	if (AP_ENAB(wlc->pub) && WME_ENAB(wlc->pub)) {
		WL_APSTA_BCN(("wl%d: wlc_edcf_setparams() -> wlc_update_beacon()\n",
		              wlc->pub->unit));
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, FALSE);
	}

	if (suspend)
		wlc_enable_mac(wlc);

}

/* Functions used by ioctl/iovar code to change AC parameters */
void
wlc_wme_acp_get_all(wlc_info_t *wlc, wme_param_ie_t *wlp, edcf_acparam_t *acparams)
{
	uint i;
	edcf_acparam_t *acp_ie = wlp->acparam;
	for (i = 0; i < AC_COUNT; i++, acp_ie++, acparams++) {
		WL_INFORM(("wl%d: RAW AC Params ACI 0x%0x, ECW 0x%0x, TXOP 0x%x\n",
		           wlc->pub->unit, acp_ie->ACI, acp_ie->ECW, acp_ie->TXOP));
		acparams->ACI = acp_ie->ACI;
		acparams->ECW = acp_ie->ECW;
		/* convert to host order */
		acparams->TXOP = ltoh16(acp_ie->TXOP);
	}
}

int
wlc_wme_acp_set(wlc_info_t *wlc, wme_param_ie_t *wlp, edcf_acparam_t *acparams)
{
	uint aci_in;
	edcf_acparam_t *acp_ie;

	/* Determine requested entry */
	aci_in = (acparams->ACI & EDCF_ACI_MASK) >> EDCF_ACI_SHIFT;
	if (aci_in >= AC_COUNT) {
		WL_ERROR(("Set of AC Params with bad ACI %d\n", aci_in));
		return BCME_RANGE;
	}

	/* Set the contents as specified */
	acp_ie = &wlp->acparam[aci_in];
	acp_ie->ACI = acparams->ACI;
	acp_ie->ECW = acparams->ECW;
	/* convert to network order */
	acp_ie->TXOP = htol16(acparams->TXOP);
	WL_INFORM(("wl%d: setting RAW AC Params ACI 0x%x ECW 0x%x TXOP 0x%x\n",
	           wlc->pub->unit, acp_ie->ACI, acp_ie->ECW, acp_ie->TXOP));

	/* APs need to notify any clients */
	if (wlc->pub->up) {
		if (AP_ENAB(wlc->pub)) {
			/* Increment count field to notify associated STAs of parameter change */
			wme_param_ie_t *pe = &wlc->wme_param_ie;
			int count = pe->qosinfo & WME_QI_AP_COUNT_MASK;
			pe->qosinfo &= ~WME_QI_AP_COUNT_MASK;
			pe->qosinfo |= (count + 1) & WME_QI_AP_COUNT_MASK;
		}
		wlc_edcf_setparams(wlc->cfg, TRUE);
	}
	return 0;
}

bool
BCMATTACHFN(wlc_timers_init)(wlc_info_t *wlc, int unit)
{
	if (!(wlc->wdtimer = wl_init_timer(wlc->wl, wlc_watchdog_timer, wlc, "watchdog"))) {
		WL_ERROR(("wl%d:  wl_init_timer for wdtimer failed\n", unit));
		goto fail;
	}

	if (!(wlc->radio_timer = wl_init_timer(wlc->wl, wlc_radio_timer, wlc, "radio"))) {
		WL_ERROR(("wl%d:  wl_init_timer for radio_timer failed\n", unit));
		goto fail;
	}

#ifdef STA
	if (!(wlc->quiet->timer = wl_init_timer(wlc->wl, wlc_quiet_timer, wlc, "quiet"))) {
		WL_ERROR(("wl%d:  wl_init_timer for quiet-timer failed\n", unit));
		goto fail;
	}

	if (!(wlc->iscan_timer = wl_init_timer(wlc->wl, wlc_iscan_timeout, wlc, "iscan_timeout"))) {
		WL_ERROR(("wl%d:  wl_init_timer for iscan_timeout failed\n", unit));
		goto fail;
	}

	if (!(wlc->pm2_radio_shutoff_dly_timer = wl_init_timer(wlc->wl,
		wlc_pm2_radio_shutoff_dly_timer, wlc, "radioshutoffdly"))) {
		WL_ERROR(("wl%d:  wl_init_timer for radio_shutoff_dly_timer failed\n", unit));
		goto fail;
	}
#endif	/* STA */
	return TRUE;

fail:
	return FALSE;
}

/*
 * Initialize wlc_info default values ...
 * may get overrides later in this function
 */
void
BCMATTACHFN(wlc_info_init)(wlc_info_t *wlc, int unit)
{
	int i;

	/* Assume the device is there until proven otherwise */
	wlc->device_present = TRUE;

	/* set default power output percentage to 100 percent */
	wlc->txpwr_percent = 100;

	/* Save our copy of the chanspec */
	wlc->chanspec = CH20MHZ_CHSPEC(1);

	wlc->legacy_probe = TRUE;

	/* various 802.11g modes */
	wlc->shortslot = FALSE;
	wlc->shortslot_override = WLC_SHORTSLOT_AUTO;

	wlc->txburst_limit_override = AUTO;

	wlc_protection_set(wlc, WLC_PROT_N_PAM_OVR, AUTO);

	wlc->stf->ant_rx_ovr = ANT_RX_DIV_DEF;
	wlc->stf->txant = ANT_TX_DEF;

	wlc->prb_resp_timeout = WLC_PRB_RESP_TIMEOUT;

	wlc->usr_fragthresh = DOT11_DEFAULT_FRAG_LEN;
	for (i = 0; i < NFIFO; i++)
		wlc->fragthresh[i] = DOT11_DEFAULT_FRAG_LEN;
	wlc->RTSThresh = DOT11_DEFAULT_RTS_LEN;

#if defined(AP) && !defined(STA)
	wlc->pub->_ap = TRUE;
#endif

	/* default rate fallback retry limits */
	wlc->SFBL = RETRY_SHORT_FB;
	wlc->LFBL = RETRY_LONG_FB;

	/* default mac retry limits */
	wlc->SRL = RETRY_SHORT_DEF;
	wlc->LRL = RETRY_LONG_DEF;

	/* init PM state */
	wlc->PMpending = FALSE;		/* Tracks whether STA indicated PM in the last attempt */
	wlc->PMblocked = FALSE;		/* To allow blocking going into PM during RM and scans */


	/* Init wme queuing method */
	wlc->wme_prec_queuing = FALSE;

	/* Overrides for the core to stay awake under zillion conditions Look for STAY_AWAKE */
	wlc->wake = FALSE;
	/* Are we waiting for a response to PS-Poll that we sent */
	wlc->PSpoll = FALSE;

	/* APSD defaults */
	wlc->wme_apsd = TRUE;
#ifdef STA
	wlc->apsd_sta_usp = FALSE;
	wlc->apsd_trigger_ac = AC_BITMAP_ALL;
#endif

	/* Set flag to indicate that hw keys should be used when available. */
	wlc->wsec_swkeys = FALSE;

	/* init the 4 static WEP default keys */
	for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i++) {
		wlc->wsec_keys[i] = wlc->wsec_def_keys[i];
		wlc->wsec_keys[i]->idx = (uint8)i;
	}

#ifdef BRCMAPIVTW
	wlc->brcm_ap_iv_tw = FALSE;
	wlc->brcm_ap_iv_tw_override = AUTO;
#endif

	wlc->_regulatory_domain = FALSE;			/* 802.11d */
#ifdef WL11H
	wlc->_spect_management = SPECT_MNGMT_LOOSE_11H;	/* 802.11h */
#endif

	/* WME QoS mode is Auto by default */
#if defined(WME)
	wlc->pub->_wme = AUTO;
#else
	wlc->pub->_wme = OFF;
#endif

#ifdef BCMSDIODEV_ENABLED
	wlc->pub->_priofc = TRUE;	/* enable priority flow control for sdio dongle */
#endif

#ifdef WLBA
	/* disable block ack by default */
	wlc->pub->_ba = FALSE;
#endif

#ifdef WLAMPDU
	/* enable AMPDU by default */
	wlc->pub->_ampdu = TRUE;
#endif

#ifdef WLAMSDU
	/* disable AMSDU agg by default */
	wlc->pub->_amsdu_tx = FALSE;

	/* AMSDU deagg will be rechecked later */
	wlc->_amsdu_rx = FALSE;
#endif


#if defined(WLFBT)
	wlc->pub->_fbt = TRUE;
#endif

#ifdef WLAFTERBURNER
	wlc->afterburner = FALSE;
	wlc->ab_wds_timeout = AB_WDS_TIMEOUT_MIN;
	wlc->afterburner_override = OFF;
	wlc->abminrate = WLC_ABMINRATE;
#endif /* WLAFTERBURNER */

#ifdef WL11K
	wlc->pub->_rrm = TRUE;
#endif

#if defined(WLWNM) && !defined(WLWNM_DISABLED)
	wlc->pub->_wnm = TRUE;
#endif

	wlc->txc = FALSE;
	wlc->txc_policy = ON;
	wlc->txcgen = 0;
	/* debug builds should not invalidate the txc per watchdog */
#ifdef BCMDBG
	wlc->txc_sticky = TRUE;
#else
	wlc->txc_sticky = FALSE;
#endif

	wlc->pub->bcmerror = 0;

	wlc->ibss_allowed = TRUE;
	wlc->ibss_coalesce_allowed = TRUE;

	if (N_ENAB(wlc->pub))
		wlc->pub->_coex = ON;

#ifdef STA
	wlc->pm2_radio_shutoff_pending = FALSE;
	wlc->pm2_radio_shutoff_dly = 0; /* disable radio shutoff delay feature */

	/* initialize mpc delay (it should be non-zero value) */
	wlc->mpc_delay_off = wlc->mpc_dlycnt = WLC_MPC_THRESHOLD;
#endif

	if (N_ENAB(wlc->pub) && COEX_ENAB(wlc->pub)) {
		wlc_ht_obss_scanparam_init(&wlc->obss->ap_params);
		wlc_ht_obss_scanparam_init(&wlc->obss->sta_params);
	}

	wlc->rfaware_lifetime = WLC_RFAWARE_LIFETIME_DEFAULT;

	wlc->pr80838_war = TRUE;
#ifdef STA
#if defined(AP_KEEP_ALIVE)
	wlc_ap_keep_alive_count_default(wlc);
#endif 
#endif /* STA */
	wlc->roam_rssi_cancel_hysteresis = ROAM_RSSITHRASHDIFF;
}

static bool
wlc_state_bmac_sync(wlc_info_t *wlc)
{
	wlc_bmac_state_t state_bmac;

	if (wlc_bmac_state_get(wlc->hw, &state_bmac) != 0)
		return FALSE;

	wlc->machwcap = state_bmac.machwcap;
	wlc_protection_set(wlc, WLC_PROT_N_PAM_OVR, (int8)state_bmac.preamble_ovr);

	return TRUE;
}

static uint
BCMATTACHFN(wlc_attach_module)(wlc_info_t *wlc)
{
	uint err = 0;
	uint unit;
	unit = wlc->pub->unit;

	/* Need to attach scbstate before wlc_ap_attach() */
	if ((wlc->scbstate = wlc_scb_attach(wlc->pub, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_scb_attach failed\n", unit));
		err = 41;
		goto fail;
	}

	/* PHY is no longer a wlc.c module(slave to wlc_bmac.c). But pulling phy iovar
	 * preprocessing out to high driver save space in BMAC build.
	 */
	wlc_phy_iovar_attach(wlc->pub);

	/* wlc_ap_attach() depends on wlc->scbstate being attached */
	if ((wlc->ap = wlc_ap_attach(wlc->pub, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_ap_attach failed\n", unit));
		err = 42;
		goto fail;
	}

#ifdef WLLED
	/* allocate the led info structure */
	if ((wlc->ledh = wlc_led_attach(wlc->pub, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_led_attach failed\n", unit));
		err = 43;
		goto fail;
	}
#endif

#ifdef WL11N
	if ((wlc->asi = wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_antsel_attach failed\n", unit));
		err = 44;
		goto fail;
	}
#endif /* WL11N */

#if defined(STA) && defined(WLRM)
	if ((wlc->rm_info = wlc_rm_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_rm_attach failed\n", unit));
		err = 71;
		goto fail;
	}
#endif /* defined(STA) && defined(WLRM) */


#ifdef WLBA
	if ((wlc->bastate = wlc_ba_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_ba_attach failed\n", unit));
		err = 46;
		goto fail;
	}
#endif

#ifdef WET
	/* allocate the wet info struct */
	if ((wlc->weth = wlc_wet_attach(wlc->pub)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_wet_attach failed\n", unit));
		err = 47;
		goto fail;
	}
#endif	/* #ifdef WET */

#ifdef WET_TUNNEL
	/* allocate the wet tunnel info struct */
	if ((wlc->wetth = wlc_wet_tunnel_attach(wlc->pub)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_wet_tunnel_attach failed\n", unit));
		err = 47;
		goto fail;
	}
#endif /* #ifdef WET_TUNNEL */

#ifdef CRAM
	if ((wlc->crami = wlc_cram_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_cram_attach failed\n", unit));
		err = 48;
		goto fail;
	}
#endif

#ifdef WLAMSDU
	/*
	 * assume core->xmtfifo_sz have been initialized and is not band specfic
	 *   otherwise need to call wlc_amsdu_agg_limit_upd() whenever that changes
	 */
	if ((wlc->ami = wlc_amsdu_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_amsdu_attach failed\n", unit));
		err = 49;
		goto fail;
	}
#endif

#ifdef WLAMPDU
	if ((wlc->ampdu = wlc_ampdu_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_ampdu_attach failed\n", unit));
		err = 50;
		goto fail;
	}
#endif



#ifdef WMF
	if ((wlc->wmfi = wlc_wmf_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_wmf_attach failed\n", unit));
		err = 52;
		goto fail;
	}
#endif

	if ((wlc->rsi = wlc_ratesel_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_ratesel_attach failed\n", unit));
		err = 53;
		goto fail;
	}

#ifdef WLPLT
	if (WLPLT_ENAB(wlc->pub) && ((wlc->plt = wlc_plt_attach(wlc)) == NULL)) {
		WL_ERROR(("wl%d: wlc_attach: wlc_pltu_attach failed\n", unit));
		err = 54;
		goto fail;
	}
#endif /* WLPLT */



	/* Initialize event queue; needed before following calls */
	wlc->eventq = wlc_eventq_attach(wlc->pub, wlc, wlc->wl, wlc_process_eventq);
	if (wlc->eventq == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_eventq_attachfailed\n", unit));
		err = 57;
		goto fail;
	}


#if defined(WLBTAMP) && !defined(WLBTAMP_DISABLED)
	/* Requires wlc_eventq_attach to be called already */
	ASSERT(wlc->eventq != NULL);
	if ((wlc->bta = wlc_bta_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_bta_attach failed\n", unit));
		err = 59;
		goto fail;
	}
#endif

#ifdef	WLCAC
	if ((wlc->cac = wlc_cac_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_cac_attach failed\n", unit));
		err = 60;
		goto fail;
	}
#endif	/* WLCAC */

	/* allocate the sequence commands info struct */
	if ((wlc->seq_cmds_info = wlc_seq_cmds_attach(wlc, wlc_ioctl)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_seq_cmds_attach failed\n", unit));
		err = 61;
		goto fail;
	}

#if defined(WLP2P) && !defined(WLP2P_DISABLED)
	/* Requires wlc_eventq_attach to be called already */
	ASSERT(wlc->eventq != NULL);
	if ((wlc->p2p = wlc_p2p_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_p2p_attach failed\n", unit));
		err = 63;
		goto fail;
	}
#endif

#ifdef WOWL
	/* If hw is capable, then attempt to start wowl feature */
	if (wlc_wowl_cap(wlc)) {
		if ((wlc->wowl = wlc_wowl_attach(wlc)) == NULL) {
			WL_ERROR(("wl%d: wlc_attach: wlc_wowl_attach failed\n", unit));
			err = 64;
			goto fail;
		} else
			wlc->pub->_wowl = TRUE;
	} else
		wlc->pub->_wowl = FALSE;
#endif

#ifdef WLEXTLOG
	if ((wlc->extlog = wlc_extlog_attach(wlc->osh, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_extlog_attach failed!\n", unit));
			err = 65;
			goto fail;
	}
#endif /* WLEXTLOG */

#ifdef WLMFG
	/* allocate the mfg info structure */
	if ((wlc->mfg = wlc_mfg_attach(wlc->pub, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_mfg_attach failed\n", unit));
		err = 66;
		goto fail;
	}
#endif /* WLMFG */

#ifdef BCMAUTH_PSK
	if ((wlc->authi = wlc_auth_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_auth_attach failed\n", unit));
		err = 67;
		goto fail;
	}
#endif

#if defined(IBSS_PEER_GROUP_KEY) && !defined(IBSS_PEER_GROUP_KEY_DISABLED)
	wlc->pub->_ibss_peer_group_key = TRUE;
#endif

#if defined(IBSS_PEER_DISCOVERY_EVENT) && !defined(IBSS_PEER_DISCOVERY_EVENT_DISABLED)
	wlc->pub->_ibss_peer_discovery_event = TRUE;
#endif

#if defined(IBSS_PEER_MGMT) && !defined(IBSS_PEER_MGMT_DISABLED)
	wlc->pub->_ibss_peer_mgmt = TRUE;
#endif

#if defined(RWL_WIFI) || defined(WIFI_REFLECTOR)
	if ((wlc->rwl = wlc_rwl_attach(wlc->pub, wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_rwl_attach failed\n", unit));
		err = 68;
		goto fail;
	}
#endif

#if defined(WLC_HOSTOID)
	if (wlc_hostoid_attach(wlc->pub, wlc) != BCME_OK) {
		WL_ERROR(("wl%d: wlc_hostoid_attach failed\n", unit));
		err = 69;
		goto fail;
	}
#endif /* WLC_HOSTOID */

#ifdef WL11K
	if ((wlc->rrm_info = wlc_rrm_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_rrm_attach failed\n", unit));
		err = 70;
		goto fail;
	}

#endif

#if defined(WLWNM)
	if ((wlc->wnm_info = wlc_wnm_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: %s: wlc_wnm_attach failed\n", unit, __FUNCTION__));
		err = 70;
		goto fail;
	}

#endif

	if ((wlc_stf_attach(wlc) != 0)) {
		WL_ERROR(("wl%d: wlc_attach: wlc_stf_attach failed\n", unit));
		err = 68;
		goto fail;
	}

#if defined(WLMCHAN) && !defined(WLMCHAN_DISABLED)
	if ((wlc->mchan = wlc_mchan_attach(wlc)) == NULL) {
		WL_ERROR(("wl%d: wlc_attach: wlc_mchan_attach failed\n", unit));
		err = 71;
		goto fail;
	}
#endif
#ifdef WL_DNGL_WD
	wlc->dngl_wd_high = TRUE;
	wlc->dngl_wd_high_exptime = WL_DNGL_WD_DEFAULT_TIMEOUT; /* 2 secs by default */

#endif

#if defined(WLNINTENDO2) && !defined(WLNINTENDO2_DISABLED)
	wlc->pub->_nintendo2 = TRUE;
#endif /* defined(WLNINTENDO2) && !defined(WLNINTENDO2_DISABLED) */

fail:
	return err;
}

wlc_pub_t *
wlc_pub(void *wlc)
{
	return ((wlc_info_t *)wlc)->pub;
}

#define CHIP_BCM5356_NON_NMODE(sih) \
	(CHIPID((sih)->chip) == BCM5356_CHIP_ID && ((sih)->chippkg & BCM5356_PKG_NONMODE) != 0)

#define CHIP_SUPPORTS_11N(wlc) \
	(!CHIP_BCM5356_NON_NMODE((wlc)->pub->sih))

/*
 * The common driver entry routine. Error codes should be unique
 */
void *
BCMATTACHFN(wlc_attach)(void *wl, uint16 vendor, uint16 device, uint unit, bool piomode,
                      osl_t *osh, void *regsva, uint bustype, void *btparam, uint *perr)
{
	wlc_info_t *wlc;
	uint err = 0;
	uint j;
	wlc_pub_t *pub;
	wlc_txq_info_t *qi;
	uint n_disabled;

	WL_TRACE(("wl%d: %s: vendor 0x%x device 0x%x\n", unit, __FUNCTION__, vendor, device));

	ASSERT(WSEC_MAX_RCMTA_KEYS <= WSEC_MAX_KEYS);
	ASSERT(WSEC_MAX_DEFAULT_KEYS == WLC_DEFAULT_KEYS);

	/* some code depends on packed structures */
	ASSERT(sizeof(struct ether_addr) == ETHER_ADDR_LEN);
	ASSERT(sizeof(struct ether_header) == ETHER_HDR_LEN);
	ASSERT(sizeof(d11regs_t) == SI_CORE_SIZE);
	ASSERT(sizeof(ofdm_phy_hdr_t) == D11_PHY_HDR_LEN);
	ASSERT(sizeof(cck_phy_hdr_t) == D11_PHY_HDR_LEN);
	ASSERT(sizeof(d11txh_t) == D11_TXH_LEN);
	ASSERT(sizeof(d11rxhdr_t) == RXHDR_LEN);
	ASSERT(sizeof(wlc_d11rxhdr_t) == WRXHDR_LEN);
	ASSERT(sizeof(struct dot11_llc_snap_header) == DOT11_LLC_SNAP_HDR_LEN);
	ASSERT(sizeof(struct dot11_header) == DOT11_A4_HDR_LEN);
	ASSERT(sizeof(struct dot11_rts_frame) == DOT11_RTS_LEN);
	ASSERT(sizeof(struct dot11_cts_frame) == DOT11_CTS_LEN);
	ASSERT(sizeof(struct dot11_ack_frame) == DOT11_ACK_LEN);
	ASSERT(sizeof(struct dot11_ps_poll_frame) == DOT11_PS_POLL_LEN);
	ASSERT(sizeof(struct dot11_cf_end_frame) == DOT11_CS_END_LEN);
	ASSERT(sizeof(struct dot11_management_header) == DOT11_MGMT_HDR_LEN);
	ASSERT(sizeof(struct dot11_auth) == DOT11_AUTH_FIXED_LEN);
	ASSERT(sizeof(struct dot11_bcn_prb) == DOT11_BCN_PRB_LEN);
	ASSERT(sizeof(tx_status_t) == TXSTATUS_LEN);
	ASSERT(sizeof(brcm_ie_t) == BRCM_IE_LEN);
	ASSERT(sizeof(ht_add_ie_t) == HT_ADD_IE_LEN);
	ASSERT(sizeof(ht_cap_ie_t) == HT_CAP_IE_LEN);
	ASSERT(OFFSETOF(wl_scan_params_t, channel_list) == WL_SCAN_PARAMS_FIXED_SIZE);
	ASSERT(TKIP_MIC_SIZE == (2 * sizeof(uint32)));	/* some tkip code expects this */
	ASSERT(ISALIGNED(OFFSETOF(wsec_key_t, data), sizeof(uint32)));
	ASSERT(ISPOWEROF2(MA_WINDOW_SZ));
	ASSERT(OSL_PKTTAG_SZ >= sizeof(wlc_pkttag_t));
	ASSERT(BRCM_IE_LEN <= WLC_MAX_BRCM_ELT);

	ASSERT(sizeof(wlc_d11rxhdr_t) <= WL_HWRXOFF);

	/*
	 * Number of replay counters value used in WPA IE must match # rxivs
	 * supported in wsec_key_t struct. See 802.11i/D3.0 sect. 7.3.2.17
	 * 'RSN Information Element' figure 8 for this mapping.
	 */
#if defined(MFP)
	ASSERT((WPA_CAP_16_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE && 17 == WLC_NUMRXIVS) ||
		(WPA_CAP_4_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE && 5 == WLC_NUMRXIVS));
#else
	ASSERT((WPA_CAP_16_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE && 16 == WLC_NUMRXIVS) ||
		(WPA_CAP_4_REPLAY_CNTRS == WLC_REPLAY_CNTRS_VALUE && 4 == WLC_NUMRXIVS));
#endif 


	/* allocate wlc_info_t state and its substructures */
	if ((wlc = (wlc_info_t*) wlc_attach_malloc(osh, unit, &err, device)) == NULL) {
		WL_ERROR(("wl%d: %s: wlc_attach_malloc failed\n", unit, __FUNCTION__));
		goto fail;
	}
	wlc->osh = osh;
	pub = wlc->pub;

#if defined(BCMDBG)
	wlc_info_dbg = wlc;
#endif

	wlc->core = wlc->corestate;
	wlc->wl = wl;
	pub->unit = unit;
	pub->osh = osh;
	wlc->btparam = btparam;


	pub->_piomode = piomode;
	wlc->bandinit_pending = FALSE;

	/* By default restrict TKIP/WEP associations from 11n STA's */
	wlc->ht_wsec_restriction = WLC_HT_TKIP_RESTRICT|WLC_HT_WEP_RESTRICT;

	/* populate wlc_info_t with default values  */
	wlc_info_init(wlc, unit);

	/* update sta/ap related parameters */
	wlc_ap_upd(wlc, NULL);

	/* 11n_disable nvram */
	n_disabled = getintvar(pub->vars, "11n_disable");

	/* construct scan data */
	wlc->scan = wlc_scan_attach(wlc, wl, osh, unit);
	if (!wlc->scan) {
		WL_ERROR(("wl%d: %s: failed to malloc scan struct\n", unit, __FUNCTION__));
		err = 31;
		goto fail;
	}
#ifndef WLLMAC_ONLY
	if (!LMAC_ENAB(wlc->pub)) {
		/* register a module (to handle iovars) */
		wlc_module_register(wlc->pub, wlc_iovars, "wlc_iovars", wlc,
			wlc_doiovar, NULL, NULL, NULL);
#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST)
		wlc_dump_register(wlc->pub, "list", (dump_fn_t)wlc_dump_list, (void *)wlc);
		wlc_dump_register(wlc->pub, "rssi", (dump_fn_t)wlc_dump_rssi, (void *)wlc);
#endif /* BCMDBG || BCMDBG_DUMP || WLTSET */

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
		wlc_dump_register(wlc->pub, "default", (dump_fn_t)wlc_dump_default, (void *)wlc);
		wlc_dump_register(wlc->pub, "all", (dump_fn_t)wlc_dump_all, (void *)wlc);
		wlc_dump_register(wlc->pub, "wlc", (dump_fn_t)wlc_dump_wlc, (void *)wlc);
		wlc_dump_register(wlc->pub, "ratestuff", (dump_fn_t)wlc_dump_ratestuff,
			(void *)wlc);
		wlc_dump_register(wlc->pub, "bsscfg", (dump_fn_t)wlc_bsscfg_dump, (void *)wlc);
		wlc_dump_register(wlc->pub, "bssinfo", (dump_fn_t)wlc_bssinfo_dump, (void *)wlc);
		wlc_dump_register(wlc->pub, "locale", wlc_channel_dump_locale, wlc);
		wlc_dump_register(wlc->pub, "wme", (dump_fn_t)wlc_dump_wme, (void *)wlc);
		wlc_dump_register(wlc->pub, "mac", (dump_fn_t)wlc_dump_mac, (void *)wlc);
		wlc_dump_register(wlc->pub, "pio", (dump_fn_t)wlc_dump_pio, (void *)wlc);
		wlc_dump_register(wlc->pub, "dma", (dump_fn_t)wlc_dump_dma, (void *)wlc);
		wlc_dump_register(wlc->pub, "stats", (dump_fn_t)wlc_dump_stats, (void *)wlc);
		wlc_dump_register(wlc->pub, "btc", (dump_fn_t)wlc_dump_btc, (void *)wlc);
#if defined(BCMDBG_DUMP)
		wlc_dump_register(wlc->pub, "shmem", (dump_fn_t)wlc_dump_shmem, (void *)wlc);
		wlc_dump_register(wlc->pub, "hwkeys", (dump_fn_t)wlc_key_dump_hw, (void *)wlc);
		wlc_dump_register(wlc->pub, "swkeys", (dump_fn_t)wlc_key_dump_sw, (void *)wlc);
		wlc_dump_register(wlc->pub, "tsf", (dump_fn_t)wlc_tsf_dump, (void *)wlc);
		wlc_dump_register(wlc->pub, "gpio", (dump_fn_t)wlc_gpio_dump, (void *)wlc);
		wlc_dump_register(wlc->pub, "siid", (dump_fn_t)wlc_dump_siid, (void *)wlc);
		wlc_dump_register(wlc->pub, "sireg", (dump_fn_t)wlc_dump_sireg, (void *)wlc);
		wlc_dump_register(wlc->pub, "siclk", (dump_fn_t)wlc_dump_siclk, (void *)wlc);
		wlc_dump_register(wlc->pub, "regcc", (dump_fn_t)wlc_dump_ccreg, (void *)wlc);
		wlc_dump_register(wlc->pub, "rcmta", (dump_fn_t)wlc_dump_rcmta, (void *)wlc);
		wlc_dump_register(wlc->pub, "secalgo", (dump_fn_t)wlc_dump_secalgo, (void *)wlc);
		wlc_dump_register(wlc->pub, "pcieregs", (dump_fn_t)wlc_pciereg_dump, (void *)wlc);
#ifdef WLAMPDU_MAC
		wlc_dump_register(wlc->pub, "aggfifo", (dump_fn_t)wlc_dump_aggfifo, (void*)wlc);
#endif
#endif 
#ifdef BCMDBG_MEM
		wlc_dump_register(wlc->pub, "malloc", (dump_fn_t)wlc_malloc_dump, (void *)wlc);
#endif
		wlc_dump_register(wlc->pub, "bcntpl", (dump_fn_t)wlc_dump_bcntpls, (void *)wlc);
#endif /* BCMDBG || BCMDBG_DUMP */

#ifdef WLTINYDUMP
		wlc_dump_register(wlc->pub, "tiny", (dump_fn_t)wlc_tinydump, (void *)wlc);
#endif
#if defined(WLTEST) || defined(BCMDBG_DUMP)
		wlc_dump_register(wlc->pub, "nvram", (dump_fn_t)wlc_nvram_dump, (void *)wlc);
#endif
#if defined(BCMDBG_DUMP)
		wlc_dump_register(wlc->pub, "pm", (dump_fn_t)wlc_dump_pm, (void *)wlc);
		wlc_dump_register(wlc->pub, "htcap", (dump_fn_t)wlc_dump_htcap, (void *)wlc);
#endif
	}
#endif /* !WLLMAC_ONLY */

#if defined(WLC_HIGH_ONLY) && defined(BCMDBG)
	wlc_dump_register(wlc->pub, "rpcpkt", (dump_fn_t)wlc_dump_rpcpktlog, (void *)wlc);
	wlc_dump_register(wlc->pub, "rpc", (dump_fn_t)wlc_dump_rpc, (void *)wlc);
#endif /* WLC_HIGH_ONLY && BCMDBG */

#if defined(BCMDBG_DUMP)
#ifdef WLCHANIM
	wlc_dump_register(wlc->pub, "chanim", (dump_fn_t)wlc_dump_chanim, (void *)wlc);
#endif
#ifdef CCA_STATS
	if (wlc->cca_info)
		wlc_dump_register(wlc->pub, "cca_stats", (dump_fn_t)wlc_dump_cca_stats,
			(void *)wlc->cca_info);
#endif
#ifdef SMF_STATS
	wlc_dump_register(wlc->pub, "smfstats", (dump_fn_t)wlc_dump_smfs, (void *)wlc);
#endif
#endif 
#if defined(BCMDBG)
	wlc_dump_register(wlc->pub, "perf_stats", (dump_fn_t)wlc_dump_perf_stats, (void *)wlc);
#endif /* BCMDBG */

	/* low level attach steps(all hw accesses go inside, no more in rest of the attach) */
	err = wlc_bmac_attach(wlc->hw, vendor, device, unit, piomode, osh, regsva,
		bustype, btparam);
	if (err) {
		WL_ERROR(("wl%d: %s: wlc_bmac_attach failed\n", unit, __FUNCTION__));
		goto fail;
	}

	wlc->band = wlc->bandstate[IS_SINGLEBAND_5G(wlc->deviceid) ? BAND_5G_INDEX : BAND_2G_INDEX];

	/* PULL BMAC states
	 * for some states, due to different info pointer(e,g, wlc, wlc_hw) or master/slave split,
	 * HIGH driver(both monolithic and HIGH_ONLY) needs to sync states FROM BMAC portion driver
	 */
	if (!wlc_state_bmac_sync(wlc)) {
		WL_ERROR(("wl%d: %s: wlc_state_bmac_sync failed\n", unit, __FUNCTION__));
		err = 20;
		goto fail;
	}

	for (j = 0; j < NFIFO; j++) {
		uint fifo_size;
		wlc_xmtfifo_sz_get(wlc, j, &fifo_size);
		wlc_xmtfifo_sz_upd_high(wlc, j, (uint16)fifo_size);
	}

	wlc_dump_register_phy(wlc);
	pub->phy_11ncapable = WLC_PHY_11N_CAP(wlc->band);

	/* propagate *vars* from BMAC driver to high driver */
	wlc_bmac_copyfrom_vars(wlc->hw, &pub->vars, &wlc->vars_size);

	/* set maximum allowed duty cycle */
	wlc->tx_duty_cycle_ofdm = (uint16)getintvar(pub->vars, "tx_duty_cycle_ofdm");
	wlc->tx_duty_cycle_cck = (uint16)getintvar(pub->vars, "tx_duty_cycle_cck");

	if ((wlc->pub->sih->boardtype == BCM943224X21) ||
	    (wlc->pub->sih->boardvendor == VENDOR_APPLE &&
	     ((wlc->pub->sih->boardtype == BCM943224X21_FCC) ||
	      (wlc->pub->sih->boardtype == BCM943224X21B)))) {
		wlc->stf->tx_duty_cycle_pwr = WLC_DUTY_CYCLE_PWR_DEF;
		wlc->stf->pwr_throttle = AUTO;
	} else if ((wlc->pub->sih->boardvendor == VENDOR_APPLE) &&
	           (wlc->pub->sih->boardtype == BCM94331X19)) {
		wlc->stf->tx_duty_cycle_pwr = 0;
		wlc->stf->pwr_throttle = AUTO;
	}

	wlc_stf_phy_chain_calc(wlc);

	/* txchain 1: txant 0, txchain 2: txant 1 */
	if (WLCISNPHY(wlc->band) && (wlc->stf->txstreams == 1))
		wlc->stf->txant = wlc->stf->hw_txchain - 1;

#ifdef BCMWAPI_WPI
	/* Hardware WAPI capability */
	if (D11REV_GE(wlc->hw->corerev, 24)) {
		wlc->hw_wapi_capable = TRUE;
	}
	/* default enable wapi */
	wlc->hw_wapi_enabled = wlc->hw_wapi_capable;
#endif /* BCMWAPI_WPI */

	/* push to BMAC driver */
	wlc_phy_stf_chain_init(wlc->band->pi, wlc->stf->hw_txchain, wlc->stf->hw_rxchain);

#ifdef WLC_LOW
	/* pull up some info resulting from the low attach */
	{
		int i;
		for (i = 0; i < NFIFO; i++)
			wlc->core->txavail[i] = wlc->hw->txavail[i];
	}
#endif /* WLC_LOW */

	wlc->stf->ipaon = wlc_phy_txpower_ipa_ison(wlc->band->pi);

	wlc_bmac_hw_etheraddr(wlc->hw, &wlc->perm_etheraddr);

	bcopy((char *)&wlc->perm_etheraddr, (char *)&pub->cur_etheraddr, ETHER_ADDR_LEN);

	for (j = 0; j < NBANDS(wlc); j++) {
		/* Use band 1 for single band 11a */
		if (IS_SINGLEBAND_5G(wlc->deviceid))
			j = BAND_5G_INDEX;

		wlc->band = wlc->bandstate[j];

		if (!wlc_attach_stf_ant_init(wlc)) {
			WL_ERROR(("wl%d: %s: wlc_attach_stf_ant_init failed\n",
			          unit, __FUNCTION__));
			err = 24;
			goto fail;
		}

		/* default contention windows size limits */
		wlc->band->CWmin = APHY_CWMIN;
		wlc->band->CWmax = PHY_CWMAX;

		/* set default roam parameters */
		wlc_roam_defaults(wlc, wlc->band, &wlc->band->roam_trigger_def,
			&wlc->band->roam_delta_def);
		wlc->band->roam_trigger_init_def = wlc->band->roam_trigger_def;
		wlc->band->roam_trigger = wlc->band->roam_trigger_def;
		wlc->band->roam_delta = wlc->band->roam_delta_def;

		/* init gmode value */
		if (BAND_2G(wlc->band->bandtype)) {
			wlc->band->gmode = GMODE_AUTO;
			wlc_protection_set(wlc, WLC_PROT_G_USER, wlc->band->gmode);
		}

		/* init _n_enab supported mode */
		if (WLC_PHY_11N_CAP(wlc->band) && CHIP_SUPPORTS_11N(wlc)) {
			if (n_disabled & WLFEATURE_DISABLE_11N) {
				pub->_n_enab = OFF;
				wlc_protection_set(wlc, WLC_PROT_N_USER, OFF);
			} else {
				pub->_n_enab = SUPPORT_11N;
				if ((WLCISHTPHY(wlc->band)) && HTREV_LT(wlc->band->phyrev, 2))
					pub->_n_enab = SUPPORT_HT;
				wlc_protection_set(wlc, WLC_PROT_N_USER,
					(pub->_n_enab == SUPPORT_11N) ? WL_11N_2x2 : WL_11N_3x3);
			}
		}

		/* init per-band default rateset, depend on band->gmode */
		wlc_default_rateset(wlc, &wlc->band->defrateset);

		/* fill in hw_rateset (used early by WLC_SET_RATESET) */
		wlc_rateset_filter(&wlc->band->defrateset, &wlc->band->hw_rateset,
			FALSE, WLC_RATES_CCK_OFDM, RATE_MASK, (bool)N_ENAB(wlc->pub));
	}

	/* update antenna config due to wlc->stf->txant/txchain/ant_rx_ovr change */
	wlc_stf_phy_txant_upd(wlc);

	/* allocate gptimer object for high resolution timer use */
	wlc->gptimer = wlc_hwtimer_init(wlc, wlc_hwtimer_gptimer_gettime,
	                                wlc_hwtimer_gptimer_set_timeout,
	                                wlc_hwtimer_gptimer_ack,
	                                (uint)((uint32)(-1)));
	if (!wlc->gptimer) {
		WL_ERROR(("wl%d: wl_init_timer for gptimer failed\n", unit));
		goto fail;
	}
	/* set maximum packet length */
	wlc->pkteng_maxlen = PKTBUFSZ - TXOFF;

	/* attach each modules */
	err = wlc_attach_module(wlc);
	if (err != 0) {
		WL_ERROR(("wl%d: %s: wlc_attach_module failed\n", unit, __FUNCTION__));
		goto fail;
	}

	/* PUSH down states to BMAC after all modules are attached */
#ifdef WLP2P
	if (P2P_ENAB(wlc->pub)) {
		wlc_bmac_set_ucode_loaded(wlc->hw, FALSE);
		wlc_bmac_p2p_set(wlc->hw, pub->_p2p);
	}
#endif


#ifndef WLLMAC_ONLY
	if (!LMAC_ENAB(wlc->pub)) {
		if (!wlc_timers_init(wlc, unit)) {
			WL_ERROR(("wl%d: %s: wlc_init_timer failed\n", unit, __FUNCTION__));
			err = 32;
			goto fail;
		}
	}
#endif /* !WLLMAC_ONLY */

	/* depend on rateset, gmode */
	wlc->cmi = wlc_channel_mgr_attach(wlc);
	if (!wlc->cmi) {
		WL_ERROR(("wl%d: %s: wlc_channel_mgr_attach failed\n", unit, __FUNCTION__));
		err = 33;
		goto fail;
	}

	/* init default when all parameters are ready, i.e. ->rateset */
	wlc_bss_default_init(wlc);

	/*
	 * Complete the wlc default state initializations..
	 */
	/* Get notified when an SCB is freed */
	wlc_scb_cubby_reserve(wlc, 0, wlc_txq_scb_init, wlc_txq_scb_free_notify, NULL, wlc);
	wlc_txmod_fn_register(wlc, TXMOD_TRANSMIT, wlc, txq_txmod_fns);

	wlc->txc_scb_handle = wlc_scb_cubby_reserve(wlc, sizeof(struct txc_cubby),
		wlc_txc_scb_init, wlc_txc_scb_free, NULL, wlc);
	if (wlc->txc_scb_handle < 0) {
		WL_ERROR(("wl%d: %s: cubby register for txc failed\n", unit, __FUNCTION__));
		err = 34;
		goto fail;
	}

	/* allocate our initial queue */
	qi = wlc_txq_alloc(wlc, osh);
	if (qi == NULL) {
		WL_ERROR(("wl%d: %s: failed to malloc tx queue\n", unit, __FUNCTION__));
		err = 100;
		goto fail;
	}
	wlc->active_queue = qi;

#ifdef WL_MULTIQUEUE
	wlc->primary_queue = qi;

	/* allocate the excursion queue */
	qi = wlc_txq_alloc(wlc, osh);
	if (qi == NULL) {
		WL_ERROR(("wl%d: %s: failed to malloc excursion queue\n", unit, __FUNCTION__));
		err = 101;
		goto fail;
	}
	wlc->excursion_queue = qi;

#endif /* WL_MULTIQUEUE */

	/* Initialize default bsscfg structure */
	if (wlc_bsscfg_primary_init(wlc)) {
		WL_ERROR(("wl%d: %s: init primary bsscfg failed\n", unit, __FUNCTION__));
		err = 35;
		goto fail;
	}

	pub->txmaxpkts = MAXTXPKTS;

#ifdef WLAMPDU_MAC
	if (AMPDU_MAC_ENAB(wlc->pub))
		pub->txmaxpkts = MAXTXPKTS_AMPDUMAC;
#endif

#ifdef WLCNT
	WLCNTSET(pub->_cnt->version, WL_CNT_T_VERSION);
	WLCNTSET(pub->_cnt->length, sizeof(wl_cnt_t));

	WLCNTSET(pub->_wme_cnt->version, WL_WME_CNT_VERSION);
	WLCNTSET(pub->_wme_cnt->length, sizeof(wl_wme_cnt_t));
#endif

#ifdef WME
	wlc_wme_initparams_sta(wlc, &wlc->wme_param_ie);
#endif

#ifdef WLAMSDU
	/* check hw AMSDU deagg capability */
	if (wlc_amsdurx_cap(wlc->ami))
		wlc->_amsdu_rx = TRUE;
#ifdef WL11N
	if ((wlc->ht_cap.cap & HT_CAP_MAX_AMSDU) && (WLC_PHY_11N_CAP(wlc->band))) {
		/* HW rcv fifo should be big enough */
		ASSERT(wlc_amsdu_mtu_get(wlc->ami) >= HT_MAX_AMSDU);
	}
#endif /* WL11N */
#endif	/* WLAMSDU */

#ifdef WL11N
	wlc->mimoft = FT_HT;
	wlc->ht_cap.cap = HT_CAP;
	if (WLCISHTPHY(wlc->band)) {
		wlc->stf->ldpc = ON;
		wlc->stf->ldpc_tx = AUTO;
	}

	if (CHIPID(wlc->pub->sih->chip) == BCM4313_CHIP_ID) {
		wlc->ht_cap.cap &= ~HT_CAP_GF;
	}

	if (CHIPID(wlc->pub->sih->chip) == BCM4319_CHIP_ID) {
		wlc->ht_cap.cap &= ~HT_CAP_GF;
	}

	wlc->mimo_40txbw = AUTO;
	wlc->ofdm_40txbw = AUTO;
	wlc->cck_40txbw = AUTO;
	wlc_update_mimo_band_bwcap(wlc, WLC_N_BW_20IN2G_40IN5G);

	/* Enable setting the RIFS Mode bit by default in HT Info IE */
	wlc->rifs_advert = AUTO;

	/* Set default values of SGI */
	if (WLC_SGI_CAP_PHY(wlc)) {
		if (WLCISLCNPHY(wlc->band))
			wlc_ht_update_sgi_rx(wlc, WLC_N_SGI_20);
		else
			wlc_ht_update_sgi_rx(wlc, (WLC_N_SGI_20 | WLC_N_SGI_40));
		wlc->sgi_tx = AUTO;
	} else {
		wlc_ht_update_sgi_rx(wlc, 0);
		wlc->sgi_tx = OFF;
	}

	/* *******nvram 11n config overrides Start ********* */

	/* apply the sgi override from nvram conf */
	if (n_disabled & WLFEATURE_DISABLE_11N_SGI_TX)
		wlc->sgi_tx = OFF;

	if (n_disabled & WLFEATURE_DISABLE_11N_SGI_RX)
		wlc_ht_update_sgi_rx(wlc, 0);

	/* apply the stbc override from nvram conf */
	if (n_disabled & WLFEATURE_DISABLE_11N_STBC_TX) {
		wlc->bandstate[BAND_2G_INDEX]->band_stf_stbc_tx = OFF;
		wlc->bandstate[BAND_5G_INDEX]->band_stf_stbc_tx = OFF;
		wlc->ht_cap.cap &= ~HT_CAP_TX_STBC;
	}
	if (n_disabled & WLFEATURE_DISABLE_11N_STBC_RX)
		wlc_stf_stbc_rx_set(wlc, HT_CAP_RX_STBC_NO);

	/* apply the GF override from nvram conf */
	if (n_disabled & WLFEATURE_DISABLE_11N_GF)
		wlc->ht_cap.cap &= ~HT_CAP_GF;

#ifdef WLAMPDU
	/* apply the ampdu tx override from nvram conf */
	if (AMPDU_ENAB(wlc->pub) &&
		(n_disabled & (WLFEATURE_DISABLE_11N_AMPDU_TX | WLFEATURE_DISABLE_11N_AMPDU_RX))) {
		wlc_ampdu_agg_state_override(wlc,
			((n_disabled & WLFEATURE_DISABLE_11N_AMPDU_TX) ? 0 : AUTO),
			((n_disabled & WLFEATURE_DISABLE_11N_AMPDU_RX) ? 0 : AUTO));
	}
#endif /* WLAMPDU */
#endif	/* WL11N */

	/* allocate the perm scbs after everybody has reserved their cubby
	 *  can this be merged with early loop, where gmode/nmode has to before all module attach ?
	 */
	for (j = 0; j < NBANDS(wlc); j++) {
		const struct ether_addr ether_local = {{2, 0, 0, 0, 0, 0}};

		/* Use band 1 for single band 11a */
		if (IS_SINGLEBAND_5G(wlc->deviceid))
			j = BAND_5G_INDEX;

		wlc->bandstate[j]->hwrs_scb =
			wlc_internalscb_alloc(wlc, &ether_local, wlc->bandstate[j]);
		if (!wlc->bandstate[j]->hwrs_scb) {
			WL_ERROR(("wl%d: %s: wlc_internalscb_alloc failed\n", unit, __FUNCTION__));
			err = 55;
			goto fail;
		}
		bcopy(&wlc->bandstate[j]->hw_rateset, &wlc->bandstate[j]->hwrs_scb->rateset,
			sizeof(wlc_rateset_t));
		wlc->bandstate[j]->hwrs_scb->bandunit = j;
	}

#ifdef BCMUSBDEV_ENABLED
	/* USB does not have native per-AC flow control */
	pub->wlfeatureflag |= WL_SWFL_FLOWCONTROL;
#endif

	/* Register a callback with OSL to be called when a PKTFREE is done for transmit packets */
	PKTFREESETCB(osh, wlc_pkt_free_cb, wlc);


#ifdef WLCHANIM
	wlc_chanim_init(wlc->chanim_info);
#endif

#ifdef CCA_STATS
	cca_init_stats(wlc);

#ifdef ISID_STATS
	itfr_init_stats(wlc);
#endif /* ISID_STATS */
#endif /* CCA_STATS */

#ifdef STA
	/* initialize radio_mpc_disable according to wlc->mpc */
	wlc_radio_mpc_upd(wlc);
#endif


	if (WLANTSEL_ENAB(wlc)) {
		if ((wlc->pub->sih->chip == BCM43234_CHIP_ID) ||
			(wlc->pub->sih->chip == BCM43235_CHIP_ID) ||
			(wlc->pub->sih->chip == BCM43236_CHIP_ID) ||
			(wlc->pub->sih->chip == BCM43238_CHIP_ID) ||
			((CHIPID(wlc->pub->sih->chip)) == BCM5357_CHIP_ID) ||
			((CHIPID(wlc->pub->sih->chip)) == BCM43237_CHIP_ID) ||
			((CHIPID(wlc->pub->sih->chip)) == BCM4749_CHIP_ID)) {
			if ((getintvar(wlc->pub->vars, "aa2g") == 7) ||
				(getintvar(wlc->pub->vars, "aa5g") == 7)) {
				wlc_bmac_antsel_set(wlc->hw, 1);
			}
		}
		else
			wlc_bmac_antsel_set(wlc->hw, wlc->asi->antsel_avail);
	}

#ifdef WLNINTENDO2
	wlc_clear_lq_stats(wlc);
	wlc->flush_txfifo_bitmap = BITMAP_FLUSH_NO_TX_FIFOS;
#endif /* WLNINTENDO2 */
	WL_MPC(("wl%d: ATTACHED\n", unit));

	if (perr)
		*perr = 0;

	return ((void*)wlc);

fail:
	WL_ERROR(("wl%d: %s: failed with err %d\n", unit, __FUNCTION__, err));
	if (wlc)
		wlc_detach(wlc);

	if (perr)
		*perr = err;
	return (NULL);
}

static void
BCMNMIATTACHFN(wlc_attach_antgain_init)(wlc_info_t *wlc)
{
	uint unit;
	unit = wlc->pub->unit;

	if ((wlc->band->antgain == -1) && (wlc->pub->sromrev == 1)) {
		/* default antenna gain for srom rev 1 is 2 dBm (8 qdbm) */
		wlc->band->antgain = 8;
	} else if (wlc->band->antgain == -1) {
		WL_ERROR(("wl%d: %s: Invalid antennas available in srom, using 2dB\n",
		          unit, __FUNCTION__));
		wlc->band->antgain = 8;
	} else {
		int8 gain, fract;
		/* Older sroms specified gain in whole dbm only.  In order
		 * be able to specify qdbm granularity and remain backward compatible
		 * the whole dbms are now encoded in only low 6 bits and remaining qdbms
		 * are encoded in the hi 2 bits. 6 bit signed number ranges from
		 * -32 - 31. Examples: 0x1 = 1 db,
		 * 0xc1 = 1.75 db (1 + 3 quarters),
		 * 0x3f = -1 (-1 + 0 quarters),
		 * 0x7f = -.75 (-1 in low 6 bits + 1 quarters in hi 2 bits) = -3 qdbm.
		 * 0xbf = -.50 (-1 in low 6 bits + 2 quarters in hi 2 bits) = -2 qdbm.
		 */
		gain = wlc->band->antgain & 0x3f;
		gain <<= 2;	/* Sign extend */
		gain >>= 2;
		fract = (wlc->band->antgain & 0xc0) >> 6;
		wlc->band->antgain = 4 * gain + fract;
	}
}

static bool
BCMATTACHFN(wlc_attach_stf_ant_init)(wlc_info_t *wlc)
{
	int aa;
	uint unit;
	char* vars;
	int bandtype;

	unit = wlc->pub->unit;
	vars = wlc->pub->vars;
	bandtype = wlc->band->bandtype;

	/* get antennas available */
	aa = (int8)getintvar(vars, (BAND_5G(bandtype) ? "aa5g" : "aa2g"));
	if (aa == 0)
		aa = (int8)getintvar(vars, (BAND_5G(bandtype) ? "aa1" : "aa0"));
	if ((aa < 1) || (aa > 15)) {
		WL_ERROR(("wl%d: %s: Invalid antennas available in srom (0x%x), using 3.\n",
			unit, __FUNCTION__, aa));
		aa = 3;
	}

	if (CHIPID(wlc->pub->sih->chip) == BCM4325_CHIP_ID)
		aa = 1;

	/* reset the defaults if we have a single antenna */
	if (aa == 1) {
		WL_INFORM(("wl%d: %s: Single antenna available (aa = %d) forcing 0(main)\n",
			unit, __FUNCTION__, aa));
		wlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_0;
		wlc->stf->txant = ANT_TX_FORCE_0;
	} else if (aa == 2) {
		WL_INFORM(("wl%d: %s: Single antenna available (aa = %d) forcing 1(aux)\n",
			unit, __FUNCTION__, aa));
		wlc->stf->ant_rx_ovr = ANT_RX_DIV_FORCE_1;
		wlc->stf->txant = ANT_TX_FORCE_1;
	} else  {
	}

	/* Compute Antenna Gain */
	wlc->band->antgain = (int8)getintvar(vars, (BAND_5G(bandtype) ? "ag1" : "ag0"));
	wlc_attach_antgain_init(wlc);

	return TRUE;
}

#ifdef WLC_HIGH_ONLY
/* HIGH_ONLY bmac_attach, which sync over LOW_ONLY bmac_attach states */
int
BCMATTACHFN(wlc_bmac_attach)(wlc_hw_info_t *wlc_hw, uint16 vendor, uint16 device, uint unit,
	bool piomode, osl_t *osh, void *regsva, uint bustype, void *btparam)
{
	wlc_bmac_revinfo_t revinfo;
	uint idx = 0;
	rpc_info_t *rpc = (rpc_info_t*)btparam;
	wlc_info_t *wlc = wlc_hw->wlc;

	ASSERT(bustype == RPC_BUS);

	/* install the rpc handle in the various state structures used by stub RPC functions */
	wlc->rpc = rpc;
	wlc->hw->rpc = rpc;
	wlc->hw->osh = osh;

	if ((wlc->rpctx = wlc_rpctx_attach(wlc->pub, wlc)) == NULL)
		return -1;

	/*
	 * FIFO 0
	 * TX: TX_AC_BK_FIFO (TX AC Background data packets)
	 */
	/* Always initialized */
	ASSERT(wlc->pub->tunables->rpctxbufpost <= wlc->pub->tunables->ntxd);
	wlc_rpctx_fifoinit(wlc->rpctx, TX_DATA_FIFO, wlc->pub->tunables->rpctxbufpost);
	wlc_rpctx_fifoinit(wlc->rpctx, TX_CTL_FIFO, wlc->pub->tunables->rpctxbufpost);
	wlc_rpctx_fifoinit(wlc->rpctx, TX_BCMC_FIFO, wlc->pub->tunables->rpctxbufpost);

	/* VI and BK inited only if WME */
	if (WME_ENAB(wlc->pub)) {
		wlc_rpctx_fifoinit(wlc->rpctx, TX_AC_BK_FIFO, wlc->pub->tunables->rpctxbufpost);
		wlc_rpctx_fifoinit(wlc->rpctx, TX_AC_VI_FIFO, wlc->pub->tunables->rpctxbufpost);
	}

#if defined(MBSS)
	/* Bcn/Proberesp pkts */
	wlc_rpctx_fifoinit(wlc->rpctx, TX_ATIM_FIFO, wlc->pub->tunables->rpctxbufpost);
#endif

	/* Allocate SB handle */
	wlc->pub->sih = MALLOC(wlc->osh, sizeof(si_t));
	if (!wlc->pub->sih)
		return -1;
	bzero(wlc->pub->sih, sizeof(si_t));

	/* sync up revinfo with BMAC */
	bzero(&revinfo, sizeof(wlc_bmac_revinfo_t));
	if (wlc_bmac_revinfo_get(wlc->hw, &revinfo) != 0)
		return -1;
	wlc->vendorid = (uint16)revinfo.vendorid;
	wlc->deviceid = (uint16)revinfo.deviceid;

	wlc->pub->boardrev = (uint16)revinfo.boardrev;
	wlc->pub->corerev = revinfo.corerev;
	wlc->pub->sromrev = (uint8)revinfo.sromrev;
	wlc->pub->sih->chiprev = revinfo.chiprev;
	wlc->pub->sih->chip = revinfo.chip;
	wlc->pub->sih->chippkg = revinfo.chippkg;
	wlc->pub->sih->boardtype = revinfo.boardtype;
	wlc->pub->sih->boardvendor = revinfo.boardvendor;
	wlc->pub->sih->bustype = revinfo.bustype;
	wlc->pub->sih->buscoretype = revinfo.buscoretype;
	wlc->pub->sih->buscorerev = revinfo.buscorerev;
	wlc->pub->sih->issim = (bool)revinfo.issim;
	wlc->pub->sih->rpc = rpc;

	if (revinfo.nbands == 0 || revinfo.nbands > 2)
		return -1;
	wlc->pub->_nbands = revinfo.nbands;

	for (idx = 0; idx < wlc->pub->_nbands; idx++) {
		uint bandunit, bandtype; /* To access bandstate */
		wlc_phy_t *pi = MALLOC(wlc->osh, sizeof(wlc_phy_t));

		if (!pi)
			return -1;
		bzero(pi, sizeof(wlc_phy_t));
		pi->rpc = rpc;

		/* Use band 1 for single band 11a */
		if (IS_SINGLEBAND_5G(wlc->deviceid))
			idx = BAND_5G_INDEX;

		bandunit = revinfo.band[idx].bandunit;
		bandtype = revinfo.band[idx].bandtype;
		wlc->bandstate[bandunit]->radiorev = (uint8)revinfo.band[idx].radiorev;
		wlc->bandstate[bandunit]->phytype = (uint16)revinfo.band[idx].phytype;
		wlc->bandstate[bandunit]->phyrev = (uint16)revinfo.band[idx].phyrev;
		wlc->bandstate[bandunit]->radioid = (uint16)revinfo.band[idx].radioid;
		wlc->bandstate[bandunit]->abgphy_encore = revinfo.band[idx].abgphy_encore;

		wlc->bandstate[bandunit]->pi = pi;
		wlc->bandstate[bandunit]->bandunit = bandunit;
		wlc->bandstate[bandunit]->bandtype = bandtype;
	}

	/* misc stuff */

#ifdef MBSS
	/* MBSS4 requires SW PRQ processing, which is not supported by bmac driver */
	if (D11REV_ISMBSS4(wlc->pub->corerev)) {
		WL_ERROR(("bmac driver doesn't support MBSS4"));
		return -1;
	}

	/* This needs to be the same with the one in wlc_bmac.c */
	if (D11REV_ISMBSS16(wlc->pub->corerev)) {
		wlc->max_ap_bss = wlc->pub->tunables->maxucodebss;

		/* 4313 has total fifo space of 128 blocks. if we enable
		 * all 16 MBSSs we will not be left with enough fifo space to
		 * support max thru'put. so we only allow configuring/enabling
		 * max of 4 BSSs. Rest of the space is distributed acorss
		 * the tx fifos.
		 */
		if (D11REV_IS(wlc->pub->corerev, 24)) {
			wlc->max_ap_bss = 4;
			wlc->mbss_ucidx_mask = wlc->max_ap_bss - 1;
		}
	}
#endif /* MBSS */

	return 0;
}

/* Free the convenience handles */
int
wlc_bmac_detach(wlc_hw_info_t *wlc_hw)
{
	uint idx;
	wlc_info_t *wlc = wlc_hw->wlc;

	if (wlc->pub->sih) {
		MFREE(wlc->osh, (void *)wlc->pub->sih, sizeof(si_t));
		wlc->pub->sih = NULL;
	}

	for (idx = 0; idx < MAXBANDS; idx++)
		if (wlc->bandstate[idx]->pi) {
			MFREE(wlc->osh, wlc->bandstate[idx]->pi, sizeof(wlc_phy_t));
			wlc->bandstate[idx]->pi = NULL;
		}

	if (wlc->rpctx) {
		wlc_rpctx_detach(wlc->rpctx);
		wlc->rpctx = NULL;
	}

	return 0;

}

#endif /* WLC_HIGH_ONLY */

static void
BCMATTACHFN(wlc_timers_deinit)(wlc_info_t *wlc)
{
	/* free timer state */
	if (wlc->wdtimer) {
		wl_free_timer(wlc->wl, wlc->wdtimer);
		wlc->wdtimer = NULL;
	}
	if (wlc->radio_timer) {
		wl_free_timer(wlc->wl, wlc->radio_timer);
		wlc->radio_timer = NULL;
	}

#ifdef STA
	if (wlc->quiet->timer) {
		wl_free_timer(wlc->wl, wlc->quiet->timer);
		wlc->quiet->timer = NULL;
	}

	if (wlc->iscan_timer) {
		wl_free_timer(wlc->wl, wlc->iscan_timer);
		wlc->iscan_timer = NULL;
	}

	if (wlc->pm2_radio_shutoff_dly_timer) {
		wl_free_timer(wlc->wl, wlc->pm2_radio_shutoff_dly_timer);
		wlc->pm2_radio_shutoff_dly_timer = NULL;
	}
#endif /* STA */
}

static void
BCMATTACHFN(wlc_detach_module)(wlc_info_t *wlc)
{
	wlc_phy_iovar_detach(wlc->pub);


#ifdef BCMAUTH_PSK
	if (wlc->authi) {
		wlc_auth_detach(wlc->authi);
		wlc->authi = NULL;
	}
#endif	/* BCMAUTH_PSK */



#ifdef WL11N
	if (wlc->asi) {
		wlc_antsel_detach(wlc->asi);
		wlc->asi = NULL;
	}
#endif /* WL11N */

#ifdef WLBA
	if (wlc->bastate) {
		wlc_ba_detach(wlc->bastate);
		wlc->bastate = NULL;
	}
#endif

#ifdef WET
	/* free private wet info */
	if (wlc->weth) {
		wlc_wet_detach(wlc->weth);
		wlc->weth = NULL;
	}
#endif /* WET */

#ifdef WET_TUNNEL
	/* free private wet tunnel info */
	if (wlc->wetth) {
		wlc_wet_tunnel_detach(wlc->wetth);
		wlc->wetth = NULL;
	}
#endif /* WET_TUNNEL */

#ifdef CRAM
	if (wlc->crami) {
		wlc_cram_detach(wlc->crami);
		wlc->crami = NULL;
	}
#endif

#ifdef WLAMSDU
	if (wlc->ami) {
		wlc_amsdu_detach(wlc->ami);
		wlc->ami = NULL;
	}
#endif

#ifdef WLAMPDU
	if (wlc->ampdu) {
		wlc_ampdu_detach(wlc->ampdu);
		wlc->ampdu = NULL;
	}
#endif


#ifdef WLP2P
	if (wlc->p2p) {
		wlc_p2p_detach(wlc->p2p);
		wlc->p2p = NULL;
	}
#endif

#ifdef WLBTAMP
	if (wlc->bta) {
		wlc_bta_detach(wlc->bta);
		wlc->bta = NULL;
	}
#endif

	if (wlc->rsi) {
		wlc_ratesel_detach(wlc->rsi);
		wlc->rsi = NULL;
	}

#ifdef WLPLT
	if (WLPLT_ENAB(wlc->pub) && wlc->plt) {
		wlc_plt_detach(wlc->plt);
		wlc->plt = NULL;
	}
#endif /* WLPLT */


#ifdef WOWL
	if (wlc->wowl) {
		wlc_wowl_detach(wlc->wowl);
		wlc->wowl = NULL;
	}
#endif


	if (wlc->seq_cmds_info) {
		wlc_seq_cmds_detach(wlc->seq_cmds_info);
		wlc->seq_cmds_info = NULL;
	}

#ifdef	WLCAC
	if (wlc->cac) {
		wlc_cac_detach(wlc->cac);
		wlc->cac = NULL;
	}
#endif	/* WLCAC */


#ifdef WMF
	if (wlc->wmfi) {
		wlc_wmf_detach(wlc->wmfi);
		wlc->wmfi = NULL;
	}
#endif

	/* free scb state */
	if (wlc->scbstate) {
		wlc_scb_detach(wlc->scbstate);
		wlc->scbstate = NULL;
	}

#ifdef WLEXTLOG
	if (wlc->extlog) {
		wlc_extlog_detach(wlc->extlog);
		wlc->extlog = NULL;
	}
#endif /* WLEXTLOG */

#ifdef WLMFG
	if (wlc->mfg) {
		wlc_mfg_detach(wlc->mfg);
		wlc->mfg = NULL;
	}
#endif /* WLMFG */

#ifdef WL11K
	if (wlc->rrm_info) {
		wlc_rrm_detach(wlc->rrm_info);
		wlc->rrm_info = NULL;
	}
#endif

#if defined(WLWNM)
	if (wlc->wnm_info) {
		wlc_wnm_detach(wlc->wnm_info);
		wlc->wnm_info = NULL;
	}
#endif

#ifdef WLC_HOSTOID
	wlc_hostoid_detach(wlc);
#endif /* WLC_HOSTOID */

	wlc_stf_detach(wlc);

#if defined(STA) && defined(WLRM)
	if (wlc->rm_info) {
		wlc_rm_detach(wlc->rm_info);
		wlc->rm_info = NULL;
	}
#endif /* defined(STA) && defined(WLRM) */

#ifdef WLMCHAN
	if (wlc->mchan) {
		wlc_mchan_detach(wlc->mchan);
		wlc->mchan = NULL;
	}
#endif
}

/*
 * Return a count of the number of driver callbacks still pending.
 *
 * General policy is that wlc_detach can only dealloc/free software states. It can NOT
 *  touch hardware registers since the d11core may be in reset and clock may not be available.
 *    One exception is sb register access, which is possible if crystal is turned on
 * After "down" state, driver should avoid software timer with the exception of radio_monitor.
 */
uint
BCMATTACHFN(wlc_detach)(wlc_info_t *wlc)
{
	uint i;
	uint callbacks = 0;
	wlc_bsscfg_t *bsscfg;

	if (wlc == NULL)
		return 0;

	WL_TRACE(("wl%d: %s\n", wlc->pub->unit, __FUNCTION__));

	ASSERT(!wlc->pub->up);

#ifdef WLLED
	if (wlc->ledh) {
		wlc_led_deinit(wlc->ledh);
	}
#endif

	callbacks += wlc_bmac_detach(wlc->hw);

	/* delete software timers */
	if (!wlc_radio_monitor_stop(wlc))
		callbacks++;

#ifdef STA
	/* free bcn_prb in wlc_bss_info_t in case they haven't been */
	wlc_bss_list_free(wlc, wlc->scan_results);
	wlc_bss_list_free(wlc, wlc->join_targets);
	wlc_bss_list_free(wlc, wlc->custom_scan_results);

	if (wlc->iscan_ignore_list)
		MFREE(wlc->osh, wlc->iscan_ignore_list, WLC_ISCAN_IGNORE_LIST_SZ);
#endif /* STA */

#ifndef WLLMAC_ONLY
	if (!LMAC_ENAB(wlc->pub)) {
		if (wlc->eventq) {
			wlc_eventq_detach(wlc->eventq);
			wlc->eventq = NULL;
		}
	}
#endif /* !WLLMAC_ONLY */

#ifdef WLLED
	if (wlc->ledh) {
		callbacks += wlc_led_detach(wlc->ledh);
		wlc->ledh = NULL;
	}
#endif

	/* Free memory for bsscfg structs */
	FOREACH_BSS(wlc, i, bsscfg) {
		wlc_bsscfg_free(wlc, bsscfg);
	}

	/* free all scbs, including permanent ones */
	wlc_scbclear(wlc, TRUE);

	/* free the primary bsscfg resources, like the bcmc_scbs */
	wlc_bsscfg_primary_cleanup(wlc);

	/* free the internal scb */
	for (i = 0; i < NBANDS(wlc); i++) {
		wlcband_t *bandstate = (NBANDS(wlc) == 1) ? wlc->band:wlc->bandstate[i];

		if (bandstate->hwrs_scb) {
			WL_INFORM(("hwrs_scb: band %d: free internal scb for 0x%p\n",
				i, bandstate->hwrs_scb));
			wlc_internalscb_free(wlc, bandstate->hwrs_scb);
		}
		bandstate->hwrs_scb = NULL;
	}

	wlc_channel_mgr_detach(wlc->cmi);

	wlc_timers_deinit(wlc);

	wlc_detach_module(wlc);

	/* free gptimer object for high resolution timer use */
	if (wlc->gptimer != NULL) {
		wlc_hwtimer_deinit(wlc, wlc->gptimer);
		wlc->gptimer = NULL;
	}

	/* free other state */

#ifdef WLC_HIGH_ONLY
	/* High-Only driver has an allocated copy of vars, monolithic just
	 * references the wlc->hw->vars which is freed in wlc_bmac_detach()
	 */
	if (wlc->pub->vars) {
		MFREE(wlc->osh, wlc->pub->vars, wlc->vars_size);
		wlc->pub->vars = NULL;
	}
#endif

#ifdef BCMDBG
	if (wlc->country_ie_override) {
		MFREE(wlc->osh, wlc->country_ie_override,
		      wlc->country_ie_override->len + TLV_HDR_LEN);
		wlc->country_ie_override = NULL;
	}
#endif	/* BCMDBG */

	{
		/* free dumpcb list */
		dumpcb_t *prev, *ptr;
		prev = ptr = wlc->dumpcb_head;
		while (ptr) {
			ptr = prev->next;
			MFREE(wlc->osh, prev, sizeof(dumpcb_t));
			prev = ptr;
		}
		wlc->dumpcb_head = NULL;
	}

	/* Detach from iovar manager */
	wlc_module_unregister(wlc->pub, "wlc_iovars", wlc);

	if (wlc->ap) {
		wlc_ap_detach(wlc->ap);
		wlc->ap = NULL;
	}

	if (wlc->scan) {
		wlc_scan_detach(wlc->scan);
		wlc->scan = NULL;
	}

	/* Cleaner to leave this as if with AP defined, Also, for dongle size consideration */
#ifdef AP
	if (wlc->scan_chanspec_list) {
		MFREE(wlc->osh, wlc->scan_chanspec_list,
		      wlc->scan_chanspec_list_size);
		wlc->scan_chanspec_list = NULL;
	}
#endif /* AP */

#if defined(RWL_WIFI) || defined(WIFI_REFLECTOR)
	if (wlc->rwl) {
		wlc_rwl_detach(wlc->rwl);
		wlc->rwl = NULL;
	}
#endif /* RWL_WIFI || WIFI_REFLECTOR */

	while (wlc->tx_queues != NULL) {
		wlc_txq_free(wlc, wlc->osh, wlc->tx_queues);
	}

	/*
	 * consistency check: wlc_module_register/wlc_module_unregister calls
	 * should match therefore nothing should be left here.
	 */
	for (i = 0; i < WLC_MAXMODULES; i ++)
		ASSERT(wlc->modulecb[i].name[0] == '\0');

	WL_MPC(("wl%d: DETACHED, callbacks %d\n", wlc->pub->unit, callbacks));

	wlc_detach_mfree(wlc, wlc->osh);
	return (callbacks);
}

/* update state that depends on the current value of "ap" */
void
wlc_ap_upd(wlc_info_t* wlc, wlc_bsscfg_t *bsscfg)
{
	/* force AUTO where AP uses it. */
	if (bsscfg && BSSCFG_AP(bsscfg))
		/* AP: short not allowed, but not enforced */
		bsscfg->PLCPHdr_override = WLC_PLCP_AUTO;

#ifdef CRAM
	/* enable cram only if AP for now */
	wlc->pub->_cram = AP_ONLY(wlc->pub)? TRUE : FALSE;
#endif

	/* disable vlan_mode on AP since some legacy STAs cannot rx tagged pkts */
	wlc->vlan_mode = AP_ENAB(wlc->pub) ? OFF : AUTO;

	/* fixup mpc */
	wlc->mpc = wlc_mpccap(wlc);

}

/* read hwdisable state and propagate to wlc flag */
static void
wlc_radio_hwdisable_upd(wlc_info_t* wlc)
{
	if (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO ||
	    wlc->pub->hw_off)
		return;

	if (wlc_bmac_radio_read_hwdisabled(wlc->hw)) {
#ifdef WLEXTLOG
		if (!mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE))
			WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_HW_OFF_ID,
				WL_LOG_LEVEL_ERR, 0, 0, NULL);
#endif
		mboolset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);
	} else {
#ifdef WLEXTLOG
		if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE))
			WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_HW_ON_ID,
				WL_LOG_LEVEL_ERR, 0, 0, NULL);
#endif
		mboolclr(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);
	}
}

static bool
wlc_mpccap(wlc_info_t* wlc)
{
	bool mpc_capable = TRUE;

	if ((D11REV_IS(wlc->pub->corerev, 4)) && (wlc->deviceid == BCM4306_D11DUAL_ID))
		mpc_capable = FALSE;

	return mpc_capable;
}

/* return TRUE if Minimum Power Consumption should be entered, FALSE otherwise */
#ifdef STA
static bool
wlc_is_non_delay_mpc(wlc_info_t* wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;

	/* mpc feature must be enabled when this function is called! */
	ASSERT(wlc->mpc);

	/* force mpc off when any of these global conditions meet */
	if (wlc->pub->associated ||
	    SCAN_IN_PROGRESS(wlc->scan) ||
	    MONITOR_ENAB(wlc) ||
	    wlc->mpc_out || wlc->mpc_scan || wlc->mpc_join ||
	    wlc->mpc_oidscan || wlc->mpc_oidjoin || wlc->mpc_oidnettype ||
	    wlc->pub->delayed_down ||
	    BTA_IN_PROGRESS(wlc))
		return FALSE;

	/* force mpc off when any of these per bsscfg conditions meet */
	FOREACH_BSS(wlc, idx, cfg) {
		if ((BSSCFG_STA(cfg) &&
		     (cfg->assoc->state != AS_IDLE ||
		      cfg->tk_cm_dt || cfg->tk_cm_bt || cfg->as_rt)) ||
		    (BSSCFG_AP(cfg) &&
		     wlc_bss_wdsscb_getcnt(wlc, cfg) > 0))
		    return FALSE;
	}

	return TRUE;
}

bool
wlc_ismpc(wlc_info_t* wlc)
{
	return ((wlc->mpc_delay_off == 0) && (wlc_is_non_delay_mpc(wlc)));
}

void
wlc_radio_mpc_upd(wlc_info_t* wlc)
{
	bool radio_state;

	/*
	* Clear the WL_RADIO_MPC_DISABLE bit when mpc feature is disabled
	* in case the WL_RADIO_MPC_DISABLE bit was set. Stop the radio
	* monitor also when WL_RADIO_MPC_DISABLE is the only reason that
	* the radio is going down.
	*/
	if (!wlc->mpc) {
		WL_MPC(("wl%d: radio_disabled %x radio_monitor %d\n", wlc->pub->unit,
			wlc->pub->radio_disabled, wlc->radio_monitor));
		if (!wlc->pub->radio_disabled)
			return;
		mboolclr(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE);
		wlc_radio_upd(wlc);
		if (!wlc->pub->radio_disabled)
			wlc_radio_monitor_stop(wlc);
		return;
	}

	/*
	 * sync ismpc logic with WL_RADIO_MPC_DISABLE bit in wlc->pub->radio_disabled
	 * to go ON, always call radio_upd synchronously
	 * to go OFF, postpone radio_upd to later when context is safe(e.g. watchdog)
	 */
	radio_state = (mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE) ? OFF : ON);

	WL_MPC(("radio_state %d, non-del-mpc %d, delay_off %d, delay_cnt %d, offcnt %d\n",
		radio_state, wlc_is_non_delay_mpc(wlc),
		wlc->mpc_delay_off, wlc->mpc_dlycnt, wlc->mpc_offcnt));

	if (wlc_ismpc(wlc) == TRUE) {
		/* Just change the state here. Let later context bring down the radio */
		mboolset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE);
	} else {
		if (radio_state == OFF) {
			/* Clear the stae and bring up radio immediately */
			mboolclr(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE);
			wlc_radio_upd(wlc);

			/* Calculate the mpc_dlycnt based on how long radio was off */
			if (wlc->mpc_offcnt < WLC_MPC_THRESHOLD) {
				wlc->mpc_dlycnt = WLC_MPC_MAX_DELAYCNT;
			} else	{
				wlc->mpc_dlycnt = WLC_MPC_MIN_DELAYCNT;
			}

			/* Clear the offcnt as we have already used it and radio is up. */
			wlc->mpc_offcnt = 0;

			WL_MPC(("wl%d: mpc delay %d\n", wlc->pub->unit, wlc->mpc_dlycnt));
			wlc->mpc_dur += OSL_SYSUPTIME() - wlc->mpc_laston_ts;
		}
		if (wlc_is_non_delay_mpc(wlc) == FALSE)
			wlc->mpc_delay_off = wlc->mpc_dlycnt;
	}
}

static bool
wlc_scb_wds_cb(struct scb *scb)
{
	return SCB_WDS(scb) != NULL ? TRUE : FALSE;
}

static uint8
wlc_bss_wdsscb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	return wlc_bss_scb_getcnt(wlc, cfg, wlc_scb_wds_cb);
}
#endif /* STA */

static bool
wlc_scb_ps_cb(struct scb *scb)
{
	return (SCB_PS(scb) != 0) ? TRUE : FALSE;
}

uint8
wlc_bss_psscb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	return wlc_bss_scb_getcnt(wlc, cfg, wlc_scb_ps_cb);
}

/*
 * centralized radio disable/enable function,
 * invoke radio enable/disable after updating hwradio status
 */
void
wlc_radio_upd(wlc_info_t* wlc)
{
	WL_MPC(("wl%d, wlc_radio_upd, radio_disabled 0x%x\n", wlc->pub->unit,
		wlc->pub->radio_disabled));

	if (wlc->pub->radio_disabled)
		wlc_radio_disable(wlc);
	else
		wlc_radio_enable(wlc);

#ifdef WLBTAMP
	wlc_bta_radio_status_upd(wlc->bta);
#endif
#ifdef STA
	wlc_mac_event(wlc, WLC_E_RADIO, NULL, 0, 0, 0, 0, 0);
#endif
}

/* maintain LED behavior in down state */
static void
wlc_down_led_upd(wlc_info_t *wlc)
{
#ifdef STA
	int idx;
	wlc_bsscfg_t *cfg;
#endif
	ASSERT(!wlc->pub->up);

#ifdef STA
	/* maintain LEDs while in down state, turn on sbclk if not available yet */
	FOREACH_BSS(wlc, idx, cfg) {
		if (BSSCFG_STA(cfg)) {
			/* turn on sbclk if necessary */
			wlc_pllreq(wlc, TRUE, WLC_PLLREQ_FLIP);

#ifdef WLLED
			wlc_led_event(wlc->ledh);
#endif

			wlc_pllreq(wlc, FALSE, WLC_PLLREQ_FLIP);

			break;
		}
	}
#endif /* STA */
}

void
wlc_radio_disable(wlc_info_t *wlc)
{
	if (!wlc->pub->up) {
		wlc_down_led_upd(wlc);
		return;
	}

	WL_MPC(("wl%d: wlc_radio_disable, radio off\n", wlc->pub->unit));
	wlc_radio_monitor_start(wlc);
	WL_APSTA_UPDN(("wl%d: wlc_radio_disable() -> wl_down()\n", wlc->pub->unit));
	wl_down(wlc->wl);
}

static void
wlc_radio_enable(wlc_info_t *wlc)
{
	if (wlc->pub->up)
		return;

	if (DEVICEREMOVED(wlc))
		return;

	if (!wlc->down_override) {	/* imposed by wl down/out ioctl */
		WL_MPC(("wl%d: wlc_radio_enable, radio on\n", wlc->pub->unit));
		WL_APSTA_UPDN(("wl%d: wlc_radio_enable() -> wl_up()\n", wlc->pub->unit));
		wl_up(wlc->wl);
	}
}

/* periodical query hw radio button while driver is "down" */
static void
wlc_radio_timer(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t*)arg;

	if (DEVICEREMOVED(wlc)) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		wl_down(wlc->wl);
		return;
	}

	/* cap mpc off count */
	if (wlc->mpc_offcnt < WLC_MPC_MAX_DELAYCNT)
		wlc->mpc_offcnt++;

	/* validate all the reasons driver could be down and running this radio_timer */
	ASSERT(wlc->pub->radio_disabled || wlc->down_override);
	wlc_radio_hwdisable_upd(wlc);
	wlc_radio_upd(wlc);
}

static bool
wlc_radio_monitor_start(wlc_info_t *wlc)
{
	/* Don't start the timer if HWRADIO feature is disabled */
	if (wlc->radio_monitor || (wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO))
		return TRUE;

	wlc->radio_monitor = TRUE;
#ifdef WLC_LOW
	wlc_pllreq(wlc, TRUE, WLC_PLLREQ_RADIO_MON);
#endif /* WLC_HIGH_ONLY */
	wl_add_timer(wlc->wl, wlc->radio_timer, TIMER_INTERVAL_RADIOCHK, TRUE);
	return TRUE;
}

bool
wlc_radio_monitor_stop(wlc_info_t *wlc)
{
	if (!wlc->radio_monitor)
		return TRUE;

	ASSERT((wlc->pub->wlfeatureflag & WL_SWFL_NOHWRADIO) != WL_SWFL_NOHWRADIO);

	wlc->radio_monitor = FALSE;
#ifdef WLC_LOW
	wlc_pllreq(wlc, FALSE, WLC_PLLREQ_RADIO_MON);
#endif /* WLC_HIGH_ONLY */
	return (wl_del_timer(wlc->wl, wlc->radio_timer));
}

bool
wlc_down_for_mpc(wlc_info_t *wlc)
{
	if (!wlc->pub->up && !wlc->down_override &&
	    mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE) &&
	    !mboolisset(wlc->pub->radio_disabled, ~WL_RADIO_MPC_DISABLE))
		return TRUE;

	return FALSE;
}

#ifdef WLNINTENDO2
static bool
wlc_lq_stats_on(wlc_info_t *wlc)
{
	wlc_clear_lq_stats(wlc);
	wlc->_lqstats.enable = TRUE;

	return TRUE;
} /* wlc_lq_stats_on */

static bool
wlc_lq_stats_off(wlc_info_t *wlc)
{
	wlc->_lqstats.enable = FALSE;
	return TRUE;
} /* wlc_lq_stats_off */
#endif /* WLNINTENDO2 */

/* bring the driver down, but don't reset hardware */
void
wlc_out(wlc_info_t *wlc)
{
	wlc_bmac_set_noreset(wlc->hw, TRUE);
	wlc_radio_upd(wlc);
	wl_down(wlc->wl);
	wlc_bmac_set_noreset(wlc->hw, FALSE);

	/* core clk is TRUE in BMAC driver due to noreset, need to mirror it in HIGH */
	wlc->clk = TRUE;

	/* This will make sure that when 'up' is done
	 * after 'out' it'll restore hardware (especially gpios)
	 */
	wlc->pub->hw_up = FALSE;
}

#ifdef BCMASSERT_SUPPORT
/* Verify the sanity of wlc->tx_prec_map. This can be done only by making sure that
 * if there is no packet pending for the FIFO, then the corresponding prec bits should be set
 * in prec_map. Of course, ignore this rule when block_datafifo is set
 */
static bool
wlc_tx_prec_map_verify(wlc_info_t *wlc)
{
	/* For non-WME, both fifos have overlapping prec_map. So it's an error only if both
	 * fail the check.
	 */
	if (!EDCF_ENAB(wlc->pub)) {
		if (!(WLC_TX_FIFO_CHECK(wlc, TX_DATA_FIFO) ||
		      WLC_TX_FIFO_CHECK(wlc, TX_CTL_FIFO)))
			return FALSE;
		else
			return TRUE;
	}

	return (WLC_TX_FIFO_CHECK(wlc, TX_AC_BK_FIFO) && WLC_TX_FIFO_CHECK(wlc, TX_AC_BE_FIFO) &&
	        WLC_TX_FIFO_CHECK(wlc, TX_AC_VI_FIFO) && WLC_TX_FIFO_CHECK(wlc, TX_AC_VO_FIFO));
}
#endif /* BCMASSERT_SUPPORT */

static void
wlc_watchdog_timer(void *arg)
{
#ifdef STA
	wlc_info_t *wlc = (wlc_info_t *)arg;
#endif /* STA */

	wlc_watchdog(arg);

#ifdef STA
	if (WLC_WATCHDOG_TBTT(wlc)) {
		/* set to normal osl watchdog period */
		wl_del_timer(wlc->wl, wlc->wdtimer);
		wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
	}
#endif /* STA */
}

#ifdef STA
void
wlc_handle_ap_lost(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	wlc_roam_t *roam = cfg->roam;
	wlc_bss_info_t *current_bss = cfg->current_bss;

	/*
	 * Clear software BSSID information so that we do not
	 * process future beacons from this AP so that the roam
	 * code will continue attempting to join
	 */
	wlc_bss_clear_bssid(cfg);

	/* If we are in spectrum management mode and this channel is
	 * subject to radar detection rules, or this is a restricted
	 * channel, restore the channel's quiet bit until we
	 * reestablish contact with our AP
	 */
	if ((WL11H_ENAB(wlc) && wlc_radar_chanspec(wlc->cmi, current_bss->chanspec)) ||
	     wlc_restricted_chanspec(wlc->cmi, current_bss->chanspec))
		wlc_set_quiet_chanspec(wlc->cmi, current_bss->chanspec);

	/* Restore the frequency tracking bandwidth if we lost our AP */
	wlc_freqtrack_reset(wlc);

	WL_ASSOC(("wl%d: ROAM: tbtt_since_bcn %d, "
	          "time_since_bcn %d > bcn_timeout %d : "
	          "link down\n", WLCWLUNIT(wlc), roam->tbtt_since_bcn,
	          roam->time_since_bcn, roam->bcn_timeout));

	WL_APSTA_UPDN(("wl%d: Reporting link down on config 0"
	               " (STA lost beacons)\n", WLCWLUNIT(wlc)));
	wlc_link(wlc, FALSE, &cfg->prev_BSSID, cfg, WLC_E_LINK_BCN_LOSS);
	roam->bcns_lost = TRUE;

	/* reset rssi moving average */
	wlc_lq_rssi_reset_ma(cfg, WLC_RSSI_INVALID);
	wlc_lq_rssi_event_update(cfg);

}
#endif /* STA */

#ifdef STA
#if defined(AP_KEEP_ALIVE)
void
wlc_ap_keep_alive_count_default(wlc_info_t *wlc)
{
	wlc->keep_alive_time = AP_KEEP_ALIVE_INTERVAL;
	wlc->keep_alive_count = wlc->keep_alive_time;
}

void
wlc_ap_keep_alive_count_update(wlc_info_t *wlc, uint16 keep_alive_time)
{
	wlc->keep_alive_time = keep_alive_time;
	wlc->keep_alive_count = MIN(wlc->keep_alive_time, wlc->keep_alive_count);
}

static void
wlc_ap_keep_alive(wlc_info_t *wlc)
{
	wlc_bsscfg_t *cfg = wlc->cfg;

		if (wlc->keep_alive_count) {
			wlc->keep_alive_count--;
		}
		if (wlc->keep_alive_count == 0) {
			if (!(wlc_sendnulldata(wlc, &cfg->BSSID, 0, 0, PRIO_8021D_BE)))
				WL_INFORM(("wl%d: wlc_ccx_keep_alive: keep-alive pkt failed\n",
					wlc->pub->unit));
			/* reload count */
			wlc->keep_alive_count = wlc->keep_alive_time;
		}
}
#endif /* defined(AP_KEEP_ALIVE) || defined(CCX) */

static void
wlc_btc_pm_adjust(wlc_info_t *wlc,  bool bt_active)
{
	wlc_bsscfg_t *cfg = wlc->cfg;
	/* only bt is not active, set PM to host requested mode */
	if (wlc->btch->host_requested_pm != PM_FORCE_OFF) {
		if (bt_active) {
			if (PM_OFF == wlc->btch->host_requested_pm &&
				cfg->pm->PM != PM_FAST)
				wlc_set_pm_mode(wlc, PM_FAST, cfg);
		} else {
			if (wlc->btch->host_requested_pm != cfg->pm->PM)
				wlc_set_pm_mode(wlc, wlc->btch->host_requested_pm, cfg);
		}
	}
}
#endif /* STA */

/* common watchdog code */
static void
wlc_watchdog(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t*)arg;
	int i;
	wlc_bsscfg_t *cfg;
	int btc_mode = wlc_btc_mode_get(wlc);
#if defined(STA) && defined(WLMCHAN)
	uint32 end_time = 0;
#endif

	WL_TRACE(("wl%d: wlc_watchdog\n", wlc->pub->unit));

	if (!wlc->pub->up)
		return;

	if (DEVICEREMOVED(wlc)) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		wl_down(wlc->wl);
		return;
	}

#if defined(WLTEST)
	if (wlc->watchdog_disable)
		return;
#endif

	/* increment second count */
	wlc->pub->now++;
#ifdef ROUTER_TINY
	if (pktq_full(&wlc->active_queue->q)) {
		WL_ERROR(("wl%d: %s: max txq full. HAMMERING!\n",
			wlc->pub->unit, __FUNCTION__));
		wl_init(wlc->wl);
		return;
	}
#endif
#ifdef WL_DNGL_WD
	if (wlc->dngl_wd_high) {
		wlc_bmac_dngl_wd_set(wlc->hw, wlc->dngl_wd_high, wlc->dngl_wd_high_exptime);
	}
#endif

	if (WLC_TXC_ENAB(wlc)) {
#ifdef BCMDBG
		bool txc;
		/* check for missing call to wlc_txc_upd() */
		txc = wlc->txc;
		wlc_txc_upd(wlc);
		ASSERT(wlc->txc == txc);
#endif /* BCMDBG */

		/* invalidate tx header cache once per second if not sticky */
		if (!wlc->txc_sticky)
			wlc->txcgen++;
	}

#ifdef STA
	/* delay radio disable */
	if (wlc->mpc && wlc_is_non_delay_mpc(wlc)) {
		if (wlc->mpc_delay_off) wlc->mpc_delay_off--;
	}

	WL_MPC(("wlc_watchdog: wlc->mpc_delay_off %d\n", wlc->mpc_delay_off));

	/* mpc sync */
	wlc_radio_mpc_upd(wlc);
#endif /* STA */

	/* radio sync: sw/hw/mpc --> radio_disable/radio_enable */
	wlc_radio_hwdisable_upd(wlc);
	wlc_radio_upd(wlc);
#if defined(STA)
	/* if ismpc, driver should be in down state if up/down is allowed */
	if (wlc->mpc && wlc_ismpc(wlc))
		ASSERT(!wlc->pub->up);
#endif 
	/* if radio is disable, driver may be down, quit here */
	if (wlc->pub->radio_disabled)
		return;
	/* update critical BT state, only for 2G band */
	if (btc_mode && btc_mode != WL_BTC_PARALLEL &&
		BAND_2G(wlc->band->bandtype)) {
		wlc_enable_btc_ps_protection(wlc, wlc->cfg, TRUE);
		if (D11REV_GE(wlc->pub->corerev, 15))
			wlc_bmac_btc_period_get(wlc->hw, &wlc->btch->bth_period,
				&wlc->btch->bth_active);
#ifdef STA
		wlc_btc_pm_adjust(wlc, wlc->btch->bth_active);
#endif /* STA */
	}

#ifdef WLAMPDU
	if (D11REV_GE(wlc->pub->corerev, 15) && BAND_2G(wlc->band->bandtype)) {
		if (btc_mode && btc_mode != WL_BTC_PARALLEL) {
			/* Make sure STA is on the home channel to avoid changing AMPDU
			 * state during scanning
			 */

			if (AMPDU_ENAB(wlc->pub) && !SCAN_IN_PROGRESS(wlc->scan) &&
			    wlc->pub->associated &&
			    (wlc->chanspec == wlc->cfg->current_bss->chanspec))  {
				/* rssi too low, give up */
				if (wlc->btch->ampdutx_rssi_thresh &&
					-wlc->cfg->link->rssi >
					wlc->btch->ampdutx_rssi_thresh) {
					if (btc_mode != WL_BTC_FULLTDM) {
						wlc->btch->mode_overriden = (uint8)btc_mode;
						wlc_btc_mode_set(wlc, WL_BTC_FULLTDM);
					}
				} else {
					if (wlc->btch->mode_overriden) {
						wlc_btc_mode_set(wlc, wlc->btch->mode_overriden);
						wlc->btch->mode_overriden = 0;
					}
				}
				/* process all bt related disabling/enabling here */
				if (wlc->btch->bth_period &&
				    wlc->btch->bth_period < BT_AMPDU_THRESH) {
					/* shutoff one rxchain to avoid steep rate drop */
					if ((btc_mode == WL_BTC_HYBRID) &&
						(CHIPID(wlc->pub->sih->chip) == BCM43225_CHIP_ID)) {
						wlc_stf_rxchain_set(wlc, 1);
						wlc->stf->rxchain_restore_delay = 0;
					}
					/* rssi too low, give up */
					if ((wlc->btch->ampdutx_rssi_thresh &&
						-wlc->cfg->link->rssi >
						wlc->btch->ampdutx_rssi_thresh) ||
						btc_mode == WL_BTC_FULLTDM)
						wlc_ampdu_agg_state_update_tx(wlc, OFF);
					else
						wlc_ampdu_agg_state_update_tx(wlc, ON);

					if ((wlc->btch->ampdurx_rssi_thresh &&
						-wlc->cfg->link->rssi >
						wlc->btch->ampdurx_rssi_thresh) ||
						btc_mode == WL_BTC_FULLTDM)
						wlc_ampdu_agg_state_update_rx(wlc, OFF);
				} else {
					wlc_ampdu_agg_state_update_tx(wlc, ON);
					if ((btc_mode == WL_BTC_HYBRID) &&
						(CHIPID(wlc->pub->sih->chip) == BCM43225_CHIP_ID) &&
						(++wlc->stf->rxchain_restore_delay > 5)) {
						/* restore rxchain. */
						wlc_stf_rxchain_set(wlc, wlc->stf->hw_rxchain);
						wlc->stf->rxchain_restore_delay = 0;
					}
				}
			}
		} else {
			/* Dynamic BTC mode requires this */
#ifdef MFP
			if (!BSSCFG_AP(wlc->cfg)) {
				struct scb *scb = wlc_scbfind(wlc, &wlc->cfg->BSSID);
				if (scb && SCB_AUTHORIZED(scb)) {
					wlc_ampdu_agg_state_update_tx(wlc, ON);
				}
			} else
#endif /* MFP */
			wlc_ampdu_agg_state_update_tx(wlc, ON);
		}
	}
#endif /* WLAMPDU */

#ifdef STA
#ifdef DEBUG_TBTT
	{
	uint32 tsf_l, tsf_h;

	/* read the tsf from our chip */
	wlc_read_tsf(wlc, &tsf_l, &tsf_h);

	WL_ASSOC(("wl%d: TBTT: wlc_watchdog: tsf time: %08x:%08x\n", WLCWLUNIT(wlc), tsf_h, tsf_l));
	}
#endif /* DEBUG_TBTT */
#endif /* STA */

#ifdef WLC_LOW
	wlc_bmac_watchdog(wlc);
#endif
#ifdef WLC_HIGH_ONLY
	/* maintenance */
	wlc_bmac_rpc_watchdog(wlc);
#endif

#if defined(STA) && defined(AP)
	/* start AP if operation were pending on SCAN_IN_PROGRESS() or WLC_RM_IN_PROGRESS() */
	/* Find AP's that are enabled but not up to restart */
	if (AP_ENAB(wlc->pub) && APSTA_ENAB(wlc->pub) && wlc_apup_allowed(wlc)) {
		bool startap = FALSE;

		FOREACH_AP(wlc, i, cfg) {
			/* find the first ap that is enabled but not up */
			if (cfg->enable && !cfg->up) {
				startap = TRUE;
				break;
			}
		}

		if (startap) {
			WL_APSTA_UPDN(("wl%d: wlc_watchdog -> restart downed ap\n",
			       wlc->pub->unit));
			wlc_restart_ap(wlc->ap);
		}
	}
#endif /* STA && AP */

	/* occasionally sample mac stat counters to detect 16-bit counter wrap */
	if ((WLC_UPDATE_STATS(wlc)) && (!(wlc->pub->now % SW_TIMER_MAC_STAT_UPD)))
		wlc_statsupd(wlc);

#ifdef WLCHANIM
	wlc_chanim_update(wlc, wlc->chanspec, CHANIM_WD);
#endif /* WLCHANIM */

#if defined(DELTASTATS)
	/* check if delta stats enabled */
	if (wlc->delta_stats->interval != 0) {

		/* check if interval has elapsed */
		if (wlc->delta_stats->seconds % wlc->delta_stats->interval == 0) {
			wlc_delta_stats_update(wlc);
		}

		/* seconds is zeroed only when delta stats is enabled so
		 * that it can be used to determine when delta stats are valid
		 */
		wlc->delta_stats->seconds++;
	}
#endif

#ifdef CCA_STATS
	cca_stats_watchdog(wlc->cca_info, wlc->chanspec);
	cca_stats_upd(wlc, 1);
#ifdef ISID_STATS
	itfr_stats_wd(wlc);
#endif /* ISID_STATS */
#endif /* CCA_STATS */

#ifdef STA
	/* If we had increased the frequency tracking b/w to track beacons,
	 * verify that it is working
	 */
	if (wlc->stas_associated > 0) {
		if ((wlc->freqtrack_attempts > 0) &&
		    (wlc->freqtrack_attempts <= WLC_FREQTRACK_MIN_ATTEMPTS))
			wlc_freqtrack_verify(wlc);
	}

	/* Ensure that the PM state is in sync. between the STA and AP */
	FOREACH_AS_STA(wlc, i, cfg) {
		if (cfg->pm->PMpending && PS_ALLOWED(cfg)) {
			if (!cfg->BSS ||
			    !cfg->pm->PMpending ||
			    !WLC_BSS_CONNECTED(cfg))
				continue;
			WL_RTDC(wlc, "wlc_watchdog: tx PMep=%02u AW=%02u",
			        (cfg->pm->PMenabled ? 10 : 0) | cfg->pm->PMpending,
			        (PS_ALLOWED(cfg) ? 10 : 0) | STAY_AWAKE(wlc));
			WL_RTDC(wlc, "            : PMb=%u", wlc->PMblocked, 0);
			/* send another NULL data frame to communicate PM state */
			if (!(wlc_sendnulldata(wlc, &cfg->BSSID, 0, 0, -1)))
				WL_ERROR(("wl%d: wlc_watchdog: PM state pkt failed\n",
				          wlc->pub->unit));
		}
	}

	/* link monitor, roam, ... */
	FOREACH_AS_STA(wlc, i, cfg) {
		wlc_roam_t *roam = cfg->roam;
		wlc_bss_info_t *current_bss = cfg->current_bss;

		/* Monitor connection to a network */
		if (cfg->BSS) {
			struct scb *scb = wlc_scbfind(wlc, &cfg->BSSID);

			/* Increment the time since the last full scan, if caching is desired */
			if (roam->partialscan_period && roam->active) {
				roam->time_since_upd++;
			}

			if (roam->motion_rssi_delta > 0 && scb != NULL &&
			    (wlc->pub->now - scb->assoctime) > WLC_ROAM_SCAN_PERIOD) {
				/* Don't activate motion detection code until we are at a
				 * "moderate" RSSI or lower
				 */
				if (!roam->RSSIref && current_bss->RSSI < MOTION_DETECT_RSSI) {
					WL_ASSOC(("wl%d: %s: Setting reference RSSI in this bss "
					          "to %d\n", wlc->pub->unit, __FUNCTION__,
					          current_bss->RSSI));
					roam->RSSIref = current_bss->RSSI;
				}
				if (roam->RSSIref)
					wlc_roam_motion_detect(cfg);
			}


			/*
			 * Too many lost beacons. Perhaps, this is one of those old
			 * 802.11b Linksys APs which has a carrier frequency jitter.
			 * If we are currently associated with a B/G band AP and the
			 * link hasn't gone down yet, increase the frequency tracking
			 * bandwidth of the 802.11b demodulator and check if we get
			 * any beacons.
			 */
			if (roam->time_since_bcn > WLC_FREQTRACK_THRESHOLD &&
			    !roam->bcns_lost)
				wlc_freqtrack(wlc);

			/* If the link was down and we got a beacon, mark it 'up' */
			/* bcns_lost indicates whether the link is marked 'down' or not */
			if (roam->time_since_bcn == 0 &&
			    roam->bcns_lost) {
				roam->bcns_lost = FALSE;
				bcopy(&cfg->prev_BSSID, &cfg->BSSID, ETHER_ADDR_LEN);
				bcopy(&cfg->prev_BSSID, &current_bss->BSSID,
				      ETHER_ADDR_LEN);
				WL_APSTA_UPDN(("wl%d: Reporting link up on config 0 (STA"
				               " recovered beacons)\n", WLCWLUNIT(wlc)));
				wlc_link(wlc, TRUE, &cfg->BSSID, cfg, 0);
				WL_ASSOC(("wl%d: ROAM: new beacon: called link_up() \n",
				            WLCWLUNIT(wlc)));
			}

			/* No beacon for too long time. indicate the link is down */
			if (roam->time_since_bcn > roam->bcn_timeout &&
			    !roam->bcns_lost) {
				wlc_handle_ap_lost(wlc, cfg);
			}

			if (roam->scan_block)
				roam->scan_block--;

			if (roam->ratebased_roam_block)
				roam->ratebased_roam_block--;
		}

		/* monitor IBSS link state */
		if (!cfg->BSS) {
#if defined(IBSS_PEER_MGMT)
			if (IBSS_PEER_MGMT_ENAB(wlc->pub)) {
				struct scb *scb;
				struct scb_iter scbiter;

				/* age out inactive IBSS peers */
				FOREACHSCB(wlc->scbstate, &scbiter, scb) {
					if (SCB_IS_IBSS_PEER(scb) &&
					    ((wlc->pub->now - scb->used) > SCB_ACTIVITY_TIME)) {
						SCB_UNSET_IBSS_PEER(scb);
						wlc_scb_disassoc_cleanup(wlc, scb);
						wlc_disassoc_complete(cfg, WLC_E_STATUS_SUCCESS,
						                      &scb->ea,
						                      DOT11_RC_INACTIVITY,
						                      DOT11_BSSTYPE_INDEPENDENT);
					}
				}
			}
#endif /* defined(IBSS_PEER_MGMT) */

			/* if no beacon for too long time, indicate the link is down */
			if (roam->time_since_bcn > roam->bcn_timeout &&
			    !roam->bcns_lost) {
#ifdef WLAMPDU
				/* detect link up/down for IBSS so that ba sm can be cleaned up */
				scb_ampdu_cleanup_all(wlc->ampdu);
#endif
				wlc_bss_mac_event(wlc, cfg, WLC_E_BEACON_RX, NULL,
				                  WLC_E_STATUS_FAIL, 0, 0, 0, 0);
				roam->bcns_lost = TRUE;
			}
		}

		/* Increment time since last bcn if we are associated (Infra or IBSS)
		 * Avoid wrapping by maxing count to bcn_timeout + 1
		 * Do not increment during an assoc recreate since we have not yet
		 * reestablished the connection to the AP.
		 */
		if (roam->time_since_bcn <= roam->bcn_timeout &&
		    !(ASSOC_RECREATE_ENAB(wlc->pub) && cfg->assoc->type == AS_RECREATE) &&
		    (FALSE ||
#ifdef BCMQT_CPU
		     TRUE ||
#endif
		     !ISSIM_ENAB(wlc->pub->sih))) {
#ifdef BCMDBG
			if (roam->time_since_bcn > 0) {
				if (P2P_ENAB(wlc->pub)) {
					WL_ASSOC(("wl%d.%d: "
					          "ROAM: time_since_bcn %d tbtt_sinc_bcn %d\n",
					          wlc->pub->unit, WLC_BSSCFG_IDX(cfg),
					          roam->time_since_bcn, roam->tbtt_since_bcn));
				}
				else if (cfg == wlc->cfg) {
#ifdef WLCNT
					WL_ASSOC(("wl%d.%d: "
					          "ROAM: time_since_bcn %d, tbtt %u\n",
					          wlc->pub->unit, WLC_BSSCFG_IDX(cfg),
					          roam->time_since_bcn, wlc->pub->_cnt->tbtt));
#endif /* WLCNT */
					WL_ASSOC(("wl%d.%d: "
					          "TSF: 0x%08x 0x%08x CFPSTART: 0x%08x "
					          "CFPREP: 0x%08x\n",
					          wlc->pub->unit, WLC_BSSCFG_IDX(cfg),
					          R_REG(wlc->osh, &wlc->regs->tsf_timerhigh),
					          R_REG(wlc->osh, &wlc->regs->tsf_timerlow),
					          R_REG(wlc->osh, &wlc->regs->tsf_cfpstart),
					          R_REG(wlc->osh, &wlc->regs->tsf_cfprep)));
				}
			}
#endif	/* BCMDBG */
			roam->time_since_bcn++;
		}

		if (cfg->BSS &&
#ifdef WLP2P
		    !P2P_ENAB(wlc->pub) &&
#endif
		    cfg != wlc->cfg &&
		    roam->time_since_bcn * 1000 > MAX(2000, wlc->pub->roam_time_thresh))
			wlc_roam_bcns_lost(cfg);

		if (roam->thrash_block_active) {
			bool still_blocked = FALSE;
			for (i = 0; i < (int) roam->cache_numentries; i++) {
#if defined(BCMDBG) || defined(WLMSG_ASSOC)
				char eabuf[ETHER_ADDR_STR_LEN];
#endif
				if (roam->cached_ap[i].time_left_to_next_assoc == 0)
					continue;
				roam->cached_ap[i].time_left_to_next_assoc--;
				if (roam->cached_ap[i].time_left_to_next_assoc == 0) {
					WL_ASSOC(("wl%d: %s: ROAM: AP with BSSID %s on "
						  "chanspec 0x%x available for "
						  "reassociation\n", wlc->pub->unit,
						  __FUNCTION__,
						  bcm_ether_ntoa(&roam->cached_ap[i].BSSID, eabuf),
						  roam->cached_ap[i].chanspec));
				} else {
					WL_ASSOC(("wl%d: %s: ROAM: AP with BSSID %s on "
						  "chanspec 0x%x blocked for %d seconds\n",
						  wlc->pub->unit, __FUNCTION__,
						  bcm_ether_ntoa(&roam->cached_ap[i].BSSID, eabuf),
						  roam->cached_ap[i].chanspec,
						  roam->cached_ap[i].time_left_to_next_assoc));
					still_blocked = TRUE;
					break;
				}
			}
			if (!still_blocked)
				roam->thrash_block_active = FALSE;
		}
	}

	/* periodic IBSS gmode rate probing */
	if (wlc->band->gmode && (wlc->pub->now % SW_TIMER_IBSS_GMODE_RATEPROBE) == 0) {
		FOREACH_AS_STA(wlc, i, cfg) {
			if (cfg->BSS)
				continue;
			wlc_rateprobe_scan(cfg);
		}
	}
#endif /* STA */

	FOREACH_AS_BSS(wlc, i, cfg) {
		wlc_prot_to_t *to = cfg->prot_to;

		/* decrement beacon detection timeouts */

		/* overlapping NonERP (legacy, non-11g) bcn */
		if (to->nonerp_ovlp_timeout)
			to->nonerp_ovlp_timeout--;
		/* member NonERP IBSS bcn */
		if (to->nonerp_ibss_timeout)
			to->nonerp_ibss_timeout--;
		/* overlapping OFDM BSS */
		if (to->ofdm_ovlp_timeout)
			to->ofdm_ovlp_timeout--;
		/* overlapping 20MHz Operating BSS */
		if (to->ht20in40_ovlp_timeout)
			to->ht20in40_ovlp_timeout--;
		/* member OFDM IBSS bcn */
		if (to->ofdm_ibss_timeout)
			to->ofdm_ibss_timeout--;
		/* member non-GF IBSS bcn */
		if (to->non_gf_ibss_timeout)
			to->non_gf_ibss_timeout--;
		/* member 20MHz-only IBSS bcn */
		if (to->ht20in40_ibss_timeout)
			to->ht20in40_ibss_timeout--;
		/* Beacon from a long-only preamble STA detected */
		if (to->longpre_detect_timeout)
			to->longpre_detect_timeout--;
		/* Beacon signaling Barker long preamble only mode detected */
		if (to->barker_detect_timeout)
			to->barker_detect_timeout--;
		/* Beacon signaling Use_Protection detected */
		if (to->g_ibss_timeout)
			to->g_ibss_timeout--;
		/* Beacon in IBSS signaling Use_OFDM_Protection detected */
		if (to->n_ibss_timeout)
			to->n_ibss_timeout--;

		if (BSSCFG_AP(cfg) || !cfg->BSS) {
			if (wlc->band->gmode)
				wlc_update_gbss_modes(cfg);
			if (N_ENAB(wlc->pub))
				wlc_update_n_protection(cfg);
		}
	}

	/* Manage TKIP countermeasures timers */
	FOREACH_BSS(wlc, i, cfg) {
		if (cfg->tk_cm_dt) {
			cfg->tk_cm_dt--;
			WL_WSEC(("wl%d: wlc_watchdog: TKIP countermeasures: cfg(%d) detect timer ="
				" %d\n",
				wlc->pub->unit, i, cfg->tk_cm_dt));
		}
		if (cfg->tk_cm_bt) {
			cfg->tk_cm_bt--;
			WL_WSEC(("wl%d: wlc_watchdog: TKIP countermeasures: cfg(%d) blocking timer"
				" = %d\n",
				wlc->pub->unit, i, cfg->tk_cm_bt));
		}
	}


#ifdef WL11N
	/* check obss scan timeout if feature is enabled */
	if (N_ENAB(wlc->pub) && COEX_ACTIVE(wlc)) {
#ifdef STA
		if (!AP_ENAB(wlc->pub))
			wlc_ht_obss_scan_timer(wlc);
#endif /* STA */
		/* check if switch was deferred or bss 20/40 restore time is up */
		if (AP_ENAB(wlc->pub) || wlc->obss->switch_bw_deferred)
			wlc_ht_obss_coex_watchdog(wlc);
	}
#endif /* WL11N */

#ifdef STA
#if defined(AP_KEEP_ALIVE)
	cfg = wlc->cfg;
	if (BSSCFG_STA(cfg) && cfg->BSS) {
		if (cfg->associated && !ETHER_ISNULLADDR(&cfg->BSSID)) {
			wlc_ap_keep_alive(wlc);
		}
	}

#endif 
#endif /* STA */

#if defined(DSLCPE_DELAY)
	/* Call any registered watchdog handlers */
	for (i = 0; i < WLC_MAXMODULES; i ++) {
		extern void wl_schedule_fn(void *, void (*fn)(void *), void *);
		if (wlc->modulecb[i].watchdog_fn) {
			if (!(wlc->pub->delaymode == WL_DELAYMODE_FORCE ||
			      (wlc->pub->delaymode == WL_DELAYMODE_AUTO &&
			       wlc_assocscb_getcnt(wlc))))
				wl_schedule_fn(wlc->wl,
				               (void (*)(void *))
				               wlc->modulecb[i].watchdog_fn,
				               wlc->modulecb[i].hdl);
			else
				wlc->modulecb[i].watchdog_fn(wlc->modulecb[i].hdl);
		}
	}
#else
	/* Call any registered watchdog handlers */
	for (i = 0; i < WLC_MAXMODULES; i ++) {
		if (wlc->modulecb[i].watchdog_fn)
			if (wlc->modulecb[i].watchdog_fn(wlc->modulecb[i].hdl) != BCME_OK) {
				WL_ERROR(("wl%d: %s watchdog handler error\n",
				          wlc->pub->unit, wlc->modulecb[i].name));
				return;
			}
	}
#endif /* DSLCPE_DELAY */

#ifdef WL11N
#if defined(WLC_LOW) && defined(WLC_HIGH)
	wlc_pwrthrottle_upd(wlc);
#endif
#endif /* WL11N */

#ifdef STA
	/* sync up SM PS mode */
#if defined(WLMCHAN)
	if (MCHAN_ENAB(wlc->pub) && MCHAN_ACTIVE(wlc->pub) &&
	    wlc->reset_triggered_pmoff) {
		end_time = R_REG(wlc->osh, &wlc->regs->tsf_timerlow);
	}
#endif /* WLMCHAN */
	FOREACH_AS_STA(wlc, i, cfg) {
#ifdef WL11N
		if (cfg->mimops_ActionRetry & WLC_MIMOPS_RETRY_SEND)
			wlc_mimops_action_ht_send(wlc, cfg, cfg->mimops_PM);
		else if (cfg->mimops_ActionRetry & WLC_MIMOPS_RETRY_NOACK)
			wlc_mimops_action_ht_send(wlc, cfg, cfg->mimops_ActionPM);
#endif /* WL11N */

		if (wlc->reset_triggered_pmoff && cfg->up) {
			/* resync pm mode */
			wlc_set_pm_mode(wlc, cfg->pm->PM, cfg);
			WL_PS(("wl%d.%d: resync PM mode to %d\n", wlc->pub->unit,
			       WLC_BSSCFG_IDX(cfg), cfg->pm->PM != PM_OFF));
#ifdef WLMCHAN
			/* If mchan is active and a reset was triggered,
			 * we need to schedule channel switches manually
			 * to allow every bsscfg to receive their beacons.
			 * During reset, all p2p shm blocks would get reset
			 * so we need the reception of beacons to reprogram
			 * the p2p shm blocks again in order for regular tbtt
			 * based channel switches to continue.
			 */
			if (MCHAN_ENAB(wlc->pub) && MCHAN_ACTIVE(wlc->pub)) {
				uint32 bcn_per;

				/* get beacon period for current bss in uS */
				bcn_per = cfg->current_bss->beacon_period << 10;
				/* stay on each channel for (bcn_per * (dtim_per+1)) uS */
				bcn_per *= (cfg->current_bss->dtim_period + 1);
				/* schedule a channel switch to rx other beacon */
				wlc_mchan_sched_add(wlc->mchan, cfg->_idx,
				                    bcn_per,
				                    end_time);
				end_time += bcn_per;
			}
#endif /* WLMCHAN */
		}
	}

#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub) && MCHAN_ACTIVE(wlc->pub) &&
	    wlc->reset_triggered_pmoff) {
		wlc_mchan_start_timer(wlc->mchan, 1);
	}
#endif /* WLMCHAN */
	/* clear reset variable */
	wlc->reset_triggered_pmoff = FALSE;
#endif /* STA */

#ifdef WL11N
	wlc_stf_tempsense_upd(wlc);
#endif /* WL11N */

#if defined(WL_AP_TPC)
	if ((wlc->ap_tpc_interval) && (wlc->pub->now % wlc->ap_tpc_interval) == 0) {
		wlc_ap_tpc(wlc);
	}
#endif

#ifdef WLC_LOW
	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
	ASSERT(wlc_bmac_taclear(wlc->hw, TRUE));
#endif

	/* Verify that tx_prec_map and fifos are in sync to avoid lock ups */
	ASSERT(wlc_tx_prec_map_verify(wlc));

	ASSERT(wlc_ps_check(wlc));

#ifdef WLBTAMP
	if (BTA_ENAB(wlc->pub)) {
		wlc_bta_dump_stats(wlc->bta);
	}
#endif /* WLBTAMP */
}

/* update g_protection, barker_preamble and shortslot_override
 * parameters.
 * g_protection gets update based on protection control and override
 * setting.
 * whenever the state of protection changed, the beacon and probe also
 * gets updated with new protection setting.
 */
bool
wlc_update_gbss_modes(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	bool update = FALSE;
	bool nonerp;
	bool erp_ie_use_protection = FALSE;
	int8 barker_preamble;
	bool shortslot = wlc->shortslot;
	bool g_prot;
	wlc_prot_cond_t *cond = cfg->prot_cond;
	wlc_prot_cfg_t *prot = cfg->prot_cfg;
	wlc_prot_to_t *to = cfg->prot_to;

	ASSERT(wlc->band->gmode);

	nonerp = (cond->nonerp_assoc || to->nonerp_ibss_timeout > 0);

	if (prot->erp_ie_nonerp != nonerp) {
		prot->erp_ie_nonerp = nonerp;
		update = TRUE;
	}

	/* Update current 11g protection */
	if (prot->g_override == WLC_PROTECTION_AUTO) {
		/* Turn 11g protection on if NonERP STA associated or legacy BSSs on our channel */
		if (((prot->overlap == WLC_PROTECTION_CTL_LOCAL ||
		      prot->overlap == WLC_PROTECTION_CTL_OVERLAP) &&
		     nonerp) ||
		    (prot->overlap == WLC_PROTECTION_CTL_OVERLAP &&
		     to->nonerp_ovlp_timeout != 0)) {

			erp_ie_use_protection = TRUE;
		}

		/* Use 11g protection if we are advertising protection or
		 * we have seen Use_Protection signaled in our IBSS
		 */
		g_prot = (erp_ie_use_protection || to->g_ibss_timeout);

	} else {
		g_prot = (prot->g_override == WLC_PROTECTION_ON);
		erp_ie_use_protection = g_prot;
	}

	if (prot->_g != g_prot)
		wlc_protection_upd(cfg, WLC_PROT_G_SPEC, g_prot);

	if (prot->erp_ie_use_protection != erp_ie_use_protection) {
		prot->erp_ie_use_protection = erp_ie_use_protection;
		update = TRUE;
	}

	/* Update current 11g Barker Preamble Mode (short/long CCK preamble indications) */
	if (cond->longpre_assoc || to->longpre_detect_timeout > 0)
		barker_preamble = WLC_BARKER_LONG_ONLY;
	else
		barker_preamble = WLC_BARKER_SHORT_ALLOWED;

	if (prot->barker_preamble != barker_preamble) {
		prot->barker_preamble = barker_preamble;
		update = TRUE;
	}

	/* decide short slot/long slot mode */
	if (BSSCFG_AP(cfg)) {
		if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
			shortslot = TRUE;
			if (cond->longslot_assoc) {
				shortslot = FALSE;
			} else if (!wlc->ignore_bcns && to->nonerp_ovlp_timeout) {
				shortslot = FALSE;
			}
		} else {
			/* an override has been specified for shortslot mode */
			shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
		}
	} else if (!cfg->BSS) {	/* IBSS shortslot setting */
		/* apply shortslot setting if override */
		if (wlc->shortslot_override != WLC_SHORTSLOT_AUTO)
			shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
	}

	if (wlc->shortslot != shortslot) {
		wlc_switch_shortslot(wlc, shortslot);
		update = TRUE;
	}

	if (update) {
		wlc_bss_update_brcm_ie(wlc, cfg);
		WL_APSTA_BCN(("wl%d.%d: wlc_update_gbss_modes() -> wlc_update_beacon()\n",
		              wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		wlc_bss_update_beacon(wlc, cfg);
		wlc_bss_update_probe_resp(wlc, cfg, TRUE);
	}

	if ((prot->barker_preamble == WLC_BARKER_LONG_ONLY) ||
	    (to->barker_detect_timeout > 0))
		prot->shortpreamble = FALSE;
	else
		prot->shortpreamble = TRUE;

	return (update);
}

/* n_cfg policy routine
 *  - honor n_cfg_override
 *  - update only when there is change, this can be called by process_beacon()
 *  - may update ucode when necessary
 *  - Overlap is not supported due to protection propagate
 */
bool
wlc_update_n_protection(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	bool update_ucode = FALSE;
	bool ofdm_protect, nongf_protect, ht20in40_protect;
	bool n_protect = FALSE;
	bool obss_protect;
	int8 use_n_protection;
	wlc_prot_cond_t *cond = cfg->prot_cond;
	wlc_prot_cfg_t *prot = cfg->prot_cfg;
	wlc_prot_to_t *to = cfg->prot_to;

	ASSERT(N_ENAB(wlc->pub));

	ofdm_protect = (cond->ofdm_assoc || to->ofdm_ibss_timeout > 0);
	nongf_protect = (cond->non_gf_assoc || to->non_gf_ibss_timeout > 0);
	ht20in40_protect = (cond->ht20in40_assoc || to->ht20in40_ibss_timeout > 0);

	obss_protect = FALSE;
	/* Update current OFDM protection */
	if (prot->n_cfg_override == WLC_PROTECTION_AUTO) {

		if ((prot->overlap == WLC_PROTECTION_CTL_LOCAL ||
		     prot->overlap == WLC_PROTECTION_CTL_OVERLAP) &&
		    (ofdm_protect || ht20in40_protect)) {
			/* Use protection if OFDM STAs associated */
			n_protect = TRUE;
			obss_protect = TRUE;
		}
		else if (prot->overlap == WLC_PROTECTION_CTL_OVERLAP &&
			to->ofdm_ovlp_timeout != 0) {
			n_protect = TRUE;
			obss_protect = TRUE;
		}

		/* Use Mixed Mode protection if we are advertising protection or
		 * we have seen Use_Protection signaled in our IBSS
		 */
		use_n_protection = WLC_N_PROTECTION_OFF;
		if (n_protect || to->n_ibss_timeout ||
		    (prot->_g && CHSPEC_IS2G(wlc->home_chanspec))) {
			if (ofdm_protect ||
			    (prot->_g && CHSPEC_IS2G(wlc->home_chanspec)))
				use_n_protection = WLC_N_PROTECTION_MIXEDMODE;
			else if (ht20in40_protect)
				/* use CTS-to-self if operate in 40MHz with
				 * Legacy OFDM associated or 20MHz operation
				 * overlapped or g-mode protection enabled
				 */
				use_n_protection = WLC_N_PROTECTION_20IN40;
			else if (to->ofdm_ovlp_timeout)
				use_n_protection = WLC_N_PROTECTION_OPTIONAL;
		}
	} else {
		/* the logic is the same as wlc_protection_ncfg_sync() */
		if (prot->n_cfg_override == WLC_PROTECTION_ON) {
			use_n_protection = WLC_N_PROTECTION_MIXEDMODE;
			obss_protect = TRUE;
		}
		else if (prot->n_cfg_override == WLC_PROTECTION_MMHDR_ONLY)
			use_n_protection = WLC_N_PROTECTION_OPTIONAL;
		else if (prot->n_cfg_override == WLC_PROTECTION_CTS_ONLY)
			use_n_protection = WLC_N_PROTECTION_20IN40;
		else
			use_n_protection = WLC_N_PROTECTION_OFF;
	}

	if (prot->n_cfg != use_n_protection) {
		wlc_protection_upd(cfg, WLC_PROT_N_CFG, use_n_protection);
		update_ucode = TRUE;
	}

	if (prot->nongf_override != WLC_PROTECTION_AUTO)
		nongf_protect =	(prot->nongf_override == WLC_PROTECTION_ON);

	if (prot->nongf != nongf_protect) {
		wlc_protection_upd(cfg, WLC_PROT_N_NONGF, nongf_protect);
		update_ucode = TRUE;
	}

	if (prot->n_obss != obss_protect) {
		wlc_protection_upd(cfg, WLC_PROT_N_OBSS, obss_protect);
		update_ucode = TRUE;
	}

	if (update_ucode) {
		WL_APSTA_BCN(("wl%d: wlc_update_n_protection() -> wlc_update_beacon()\n",
			wlc->pub->unit));
		wlc_bss_update_beacon(wlc, cfg);
		wlc_bss_update_probe_resp(wlc, cfg, TRUE);
	}

	return update_ucode;
}

/* make interface operational */
int
BCMINITFN(wlc_up)(wlc_info_t *wlc)
{
	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __FUNCTION__));

	/* HW is turned off so don't try to access it */
	if (wlc->pub->hw_off || DEVICEREMOVED(wlc))
		return BCME_RADIOOFF;

	wlc_bmac_set_epa_default_state(wlc->hw);

	if (!wlc->pub->hw_up) {
#ifdef WLLED
		/* Do basic GPIO initializations for LED. This just sets up LED mask */
		wlc_led_init(wlc->ledh);
#endif
		wlc_bmac_hw_up(wlc->hw);
		wlc->pub->hw_up = TRUE;
	}

	if (CHIPID(wlc->pub->sih->chip) == BCM4313_CHIP_ID) {
		/* ePA 4313 brds */
		if (wlc->pub->boardflags & BFL_FEM) {
			if (wlc->pub->boardrev >= 0x1250 && (wlc->pub->boardflags & BFL_FEM_BT)) {
				wlc_mhf(wlc, MHF5, MHF5_4313_BTCX_GPIOCTRL, MHF5_4313_BTCX_GPIOCTRL,
					WLC_BAND_ALL);
			} else
				wlc_mhf(wlc, MHF4, MHF4_EXTPA_ENABLE,
					MHF4_EXTPA_ENABLE, WLC_BAND_ALL);
		/* iPA 4313 brds */
		} else {
			if (wlc->pub->boardflags & BFL_FEM_BT)
				wlc_mhf(wlc, MHF5, MHF5_4313_BTCX_GPIOCTRL, MHF5_4313_BTCX_GPIOCTRL,
					WLC_BAND_ALL);
		}
	}


	{
	/* disable/enable RSSI power down feature */
	uint16 flags = wlc->stf->rssi_pwrdn_disable ? MHF5_HTPHY_RSSI_PWRDN : 0;
	wlc_mhf(wlc, MHF5, MHF5_HTPHY_RSSI_PWRDN, flags, WLC_BAND_ALL);
	}

	/*
	 * Need to read the hwradio status here to cover the case where the system
	 * is loaded with the hw radio disabled. We do not want to bring the driver up in this case.
	 * if radio is disabled, abort up, lower power, start radio timer and return 0(for NDIS)
	 * don't call radio_update to avoid looping wlc_up.
	 *
	 * wlc_bmac_up_prep() returns either 0 or BCME_RADIOOFF only
	 */
	if (!wlc->pub->radio_disabled) {
		int status = wlc_bmac_up_prep(wlc->hw);
		if (status == BCME_RADIOOFF) {
			if (!mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE)) {
				int idx;
				wlc_bsscfg_t *bsscfg;
#ifdef WLEXTLOG
				WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_HW_OFF_ID,
					WL_LOG_LEVEL_ERR, 0, 0, NULL);
#endif
				mboolset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE);

				FOREACH_BSS(wlc, idx, bsscfg) {
					/* all bsscfg including AP's for Win7 */
					if ((!WIN7_OS(wlc->pub) && !BSSCFG_STA(bsscfg)) ||
					    !bsscfg->enable || !bsscfg->BSS)
						continue;
					WL_ERROR(("wl%d.%d: wlc_up: rfdisable -> "
						"wlc_bsscfg_disable()\n",
						wlc->pub->unit, idx));
					wlc_bsscfg_disable(wlc, bsscfg);
				}
			}
		} else
			ASSERT(!status);
	}

	if (wlc->pub->radio_disabled) {
		wlc_radio_monitor_start(wlc);
		return 0;
	}

	wlc_bmac_set_ctrl_ePA(wlc->hw);

	/* wlc_bmac_up_prep has done wlc_corereset(). so clk is on, set it */
	wlc->clk = TRUE;

	wlc_radio_monitor_stop(wlc);

#if defined(AP) && defined(RADAR)
	/* Start radar timer if there are any quiet channels */
	if (AP_ENAB(wlc->pub) && wlc->radar) {
		uint j;
		for (j = 0; j < MAXCHANNEL; j++) {
			if (wlc_quiet_chanspec(wlc->cmi, CH20MHZ_CHSPEC(j))) {
				wlc_dfs_timer_add(wlc->ap);
				break;
			}
		}
	}
#endif /* defined(AP) && defined(RADAR) */

	/* Set EDCF hostflags */
	if (EDCF_ENAB(wlc->pub)) {
		wlc_mhf(wlc, MHF1, MHF1_EDCF, MHF1_EDCF, WLC_BAND_ALL);
#if defined(WME_PER_AC_TX_PARAMS)
		{
			int ac;
			bool enab = FALSE;

			for (ac = 0; ac < AC_COUNT; ac++) {
				if (wlc->wme_max_rate[ac] != 0) {
					enab = TRUE;
					break;
				}
			}
			WL_RATE(("Setting per ac maxrate to %d\n", enab));
			wlc->pub->_per_ac_maxrate = enab;
		}
#endif /* WME_PER_AC_TX_PARAMS */
	} else {
		wlc_mhf(wlc, MHF1, MHF1_EDCF, 0, WLC_BAND_ALL);
	}

#ifdef WLPROBRESP_SW
	/* disable ucode ProbeResp */
	wlc_mhf(wlc, MHF2, MHF2_MBSSIDMODE, MHF2_MBSSIDMODE, WLC_BAND_ALL);
#endif /* WLPROBRESP_SW */

	if (WLC_WAR16165(wlc))
		wlc_mhf(wlc, MHF2, MHF2_PCISLOWCLKWAR, MHF2_PCISLOWCLKWAR, WLC_BAND_ALL);

	wl_init(wlc->wl);
	wlc->pub->up = TRUE;

	if (wlc->bandinit_pending) {
		wlc_suspend_mac_and_wait(wlc);
		wlc_set_chanspec(wlc, wlc->default_bss->chanspec);
		wlc->bandinit_pending = FALSE;
		wlc_enable_mac(wlc);
	}

	/* Propagate rfaware_lifetime setting to ucode */
	wlc_rfaware_lifetime_set(wlc, wlc->rfaware_lifetime);

	wlc_bmac_up_finish(wlc->hw);

	wlc_update_txba_burst_war(wlc, NULL);

	/* other software states up after ISR is running */
	/* start APs that were to be brought up but are not up  yet */
	if (AP_ENAB(wlc->pub))
		wlc_restart_ap(wlc->ap);

#ifdef STA
	if (ASSOC_RECREATE_ENAB(wlc->pub)) {
		int idx;
		wlc_bsscfg_t *cfg;
		FOREACH_BSS(wlc, idx, cfg) {
			if (BSSCFG_STA(cfg) && cfg->enable && (cfg->flags & WLC_BSSCFG_PRESERVE)) {
#if defined(BCMDBG) || defined(WLMSG_ASSOC)
				char ssidbuf[SSID_FMT_BUF_LEN];
				wlc_format_ssid(ssidbuf, cfg->SSID, cfg->SSID_len);
#endif
				WL_ASSOC(("wl%d: wlc_up: restarting STA bsscfg 0 \"%s\"\n",
				          wlc->pub->unit, ssidbuf));
				wlc_join_recreate(wlc, cfg);
			}
		}
	}
#endif /* STA */

	/* Program the TX wme params with the current settings */
	wlc_wme_retries_write(wlc);

	/* sanitize any existing scb rates */
	wlc_scblist_validaterates(wlc);

	/* start one second watchdog timer */
	ASSERT(!wlc->WDarmed);
	wl_add_timer(wlc->wl, wlc->wdtimer, TIMER_INTERVAL_WATCHDOG, TRUE);
	wlc->WDarmed = TRUE;

	/* ensure txc is up to date */
	if (WLC_TXC_ENAB(wlc))
		wlc_txc_upd(wlc);

	/* ensure antenna config is up to date */
	wlc_stf_phy_txant_upd(wlc);
#ifdef WL11N
	/* ensure LDPC config is in sync */
	wlc_ht_update_ldpc(wlc, wlc->stf->ldpc);
#endif
	/* ensure the brcm ie is up to date */
	wlc_update_brcm_ie(wlc);
	WL_APSTA_BCN(("wl%d: wlc_up() -> wlc_update_beacon()\n", wlc->pub->unit));
	wlc_update_beacon(wlc);
	wlc_update_probe_resp(wlc, TRUE);

#ifdef WLLED
	/* start led timer module */
	wlc_led_up(wlc);
	wlc_led_event(wlc->ledh);
#endif

#ifdef STA
	/* BMAC_NOTE: Ignore freqtrack support in LOW driver since it's for GPHY only */
	/* If the user wants wideband freq tracking to be always ON, set the PHY regs */
	if ((wlc->freqtrack_override == FREQTRACK_ON) && WLCISGPHY(wlc->band))
		wlc_phy_freqtrack_start(wlc->band->pi);
#endif /* STA */

	WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_DRIVER_UP_ID, WL_LOG_LEVEL_INFO, 0, 0, NULL);

#ifdef WL_DNGL_WD
	if (wlc->dngl_wd_high)
		wlc_bmac_dngl_wd_set(wlc->hw, wlc->dngl_wd_high, wlc->dngl_wd_high_exptime);
#endif
	WL_MPC(("wl%d: UP\n", wlc->pub->unit));
	return (0);
}

/* Initialize the base precedence map for dequeueing from txq based on WME settings */
static void
BCMINITFN(wlc_tx_prec_map_init)(wlc_info_t *wlc)
{
	wlc->tx_prec_map = WLC_PREC_BMP_ALL;
	bzero(wlc->fifo2prec_map, sizeof(uint16) * NFIFO);

	/* For non-WME, both fifos have overlapping MAXPRIO. So just disable all precedences
	 * if either is full.
	 */
	if (!EDCF_ENAB(wlc->pub)) {
		wlc->fifo2prec_map[TX_DATA_FIFO] = WLC_PREC_BMP_ALL;
		wlc->fifo2prec_map[TX_CTL_FIFO] = WLC_PREC_BMP_ALL;
	} else {
		wlc->fifo2prec_map[TX_AC_BK_FIFO] = WLC_PREC_BMP_AC_BK;
		wlc->fifo2prec_map[TX_AC_BE_FIFO] = WLC_PREC_BMP_AC_BE;
		wlc->fifo2prec_map[TX_AC_VI_FIFO] = WLC_PREC_BMP_AC_VI;
		wlc->fifo2prec_map[TX_AC_VO_FIFO] = WLC_PREC_BMP_AC_VO;
	}
}

static uint
BCMUNINITFN(wlc_down_del_timer)(wlc_info_t *wlc)
{
	uint callbacks = 0;

#ifdef STA
	/* cancel quiet period */
	if (!wl_del_timer(wlc->wl, wlc->quiet->timer))
		callbacks++;
	wlc->quiet->_state = 0;

	if (!wl_del_timer(wlc->wl, wlc->iscan_timer))
		callbacks++;

	/* cancel any radio_shutoff_dly timer */
	if (!wl_del_timer(wlc->wl, wlc->pm2_radio_shutoff_dly_timer))
		callbacks ++;

#endif /* STA */

	return callbacks;
}



/*
 * Mark the interface nonoperational, stop the software mechanisms,
 * disable the hardware, free any transient buffer state.
 * Return a count of the number of driver callbacks still pending.
 */
uint
BCMUNINITFN(wlc_down)(wlc_info_t *wlc)
{

	uint callbacks = 0;
	int i;
	bool dev_gone = FALSE;
	wlc_bsscfg_t *bsscfg;
	wlc_txq_info_t *qi;

	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __FUNCTION__));

	/* check if we are already in the going down path */
	if (wlc->going_down) {
		WL_ERROR(("wl%d: %s: Driver going down so return\n", wlc->pub->unit, __FUNCTION__));
		return 0;
	}
	if (!wlc->pub->up)
		return (callbacks);


	/* in between, mpc could try to bring down again.. */
	wlc->going_down = TRUE;

/* disable dngl watchdog timer while going down */
#ifdef WL_DNGL_WD
	if (wlc->dngl_wd_high)
		wlc_bmac_dngl_wd_set(wlc->hw, 0, 0);
#endif

	callbacks += wlc_bmac_down_prep(wlc->hw);

	dev_gone = DEVICEREMOVED(wlc);

	/* disable interrupts */
	if (!dev_gone) {
		/* abort any scan in progress */
		wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);

#ifdef STA

		FOREACH_BSS(wlc, i, bsscfg) {
			/* Perform STA down operations if needed */
			if (!BSSCFG_STA(bsscfg))
				continue;

			/* abort any association in progress */
			callbacks += wlc_assoc_abort(bsscfg);

			/* if config is enabled, take care of deactivating */
			if (bsscfg->enable) {
				/* For WOWL or Assoc Recreate, don't disassociate,
				 * just down the bsscfg.
				 * Otherwise,
				 * disable the config (STA requires active restart)
				 */
				/* WOWL_ACTIVE does not mean association needs to be recreated!
				 * ASSOC_RECREATE_ENAB is meant for that
				 */
				if (
#ifdef WOWL
				    WOWL_ACTIVE(wlc->pub) ||
#endif
				    (ASSOC_RECREATE_ENAB(wlc->pub) &&
				     (bsscfg->flags & WLC_BSSCFG_PRESERVE))) {
					WL_APSTA_UPDN(("wl%d: %s: wlc_bsscfg_down(STA)\n",
					               wlc->pub->unit, __FUNCTION__));
					callbacks += wlc_bsscfg_down(wlc, bsscfg);

					if (WLEXTSTA_ENAB(wlc->pub) && !WOWL_ACTIVE(wlc->pub)) {
						struct scb *scb =
							wlc_scbfind(wlc, &wlc->cfg->BSSID);
						if (scb) {
							wlc_scb_disassoc_cleanup(wlc, scb);
							if (SCB_ASSOCIATED(scb)) {
							wlc_scb_clearstatebit(scb, ASSOCIATED);
							wlc_bss_mac_event(wlc, bsscfg,
								WLC_E_DISASSOC,
								&wlc->cfg->BSSID,
								WLC_E_STATUS_SUCCESS,
								DOT11_RC_DISASSOC_LEAVING,
								WLC_DOT11_BSSTYPE(bsscfg->BSS),
								0, 0);
							}
							wlc->cfg->ar_disassoc = TRUE;
						}
					}
				} else {
					WL_APSTA_UPDN(("wl%d: %s: wlc_bsscfg_disable(STA)\n",
					               wlc->pub->unit, __FUNCTION__));
					callbacks += wlc_bsscfg_disable(wlc, bsscfg);
					/* allow time for disassociation packet to
					 * notify associated AP of our departure
					 */
					OSL_DELAY(4 * 1000);
				}
			}
		}
#endif /* STA */
	} else {
		/* handle the case of device gone */
#ifdef STA
#if defined(BCMSUP_PSK) && defined(BCMINTSUP)
			FOREACH_BSS(wlc, i, bsscfg) {
				callbacks += wlc_sup_down(bsscfg->sup);
			}
#endif 
#endif /* STA */
	}

	/* Call any registered down handlers */
	for (i = 0; i < WLC_MAXMODULES; i ++) {
		if (wlc->modulecb[i].down_fn)
			callbacks += wlc->modulecb[i].down_fn(wlc->modulecb[i].hdl);
	}

	/* cancel the watchdog timer */
	if (wlc->WDarmed) {
		if (!wl_del_timer(wlc->wl, wlc->wdtimer))
			callbacks++;
		wlc->WDarmed = FALSE;
	}
	/* cancel all other timers */
	callbacks += wlc_down_del_timer(wlc);

	/* interrupt must have been blocked */
	ASSERT((wlc->macintmask == 0) || !wlc->pub->up);

	wlc->pub->up = FALSE;

	wlc_phy_mute_upd(wlc->band->pi, FALSE, PHY_MUTE_ALL);

#ifdef WLLED
	/* this has to be done after state change above for LEDs to turn off properly */
	callbacks += wlc_led_down(wlc);
#endif

	/* clear txq flow control */
	wlc_txflowcontrol_reset(wlc);

#ifdef CRAM
	/* stop cram mechanism */
	if (!dev_gone)
		wlc_cram_stop(wlc->crami);
#endif

	/* flush tx queues */
	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
		pktq_flush(wlc->osh, &qi->q, TRUE, NULL, 0);
		ASSERT(pktq_empty(&qi->q));
	}

	if (AP_ENAB(wlc->pub)) {
		/* down any AP BSSs, but leave them enabled */
		FOREACH_BSS(wlc, i, bsscfg) {
			if (BSSCFG_AP(bsscfg) && bsscfg->up) {
				WL_APSTA_UPDN(("wl%d: wlc_down -> wlc_bsscfg_down %p (%d)\n",
				               wlc->pub->unit, bsscfg, i));
				callbacks += wlc_bsscfg_down(wlc, bsscfg);
			}
		}
	}

	/* flush event queue.
	 * Should be the last thing done after all the events are generated
	 * Just delivers the events synchronously instead of waiting for a timer
	 */
	if (!LMAC_ENAB(wlc->pub) && wlc->eventq)
		callbacks += wlc_eventq_down(wlc->eventq);

	callbacks += wlc_bmac_down_finish(wlc->hw);

	/* wlc_bmac_down_finish has done wlc_coredisable(). so clk is off */
	wlc->clk = FALSE;

#ifdef WLC_HIGH_ONLY
	wlc_rpctx_txreclaim(wlc->rpctx);
#endif

	/* Verify all packets are flushed from the driver */
	if (PKTALLOCED(wlc->osh) > 0) {
		WL_ERROR(("%d packets not freed at wlc_down\n", PKTALLOCED(wlc->osh)));
		PKTLIST_DUMP(wlc->osh, NULL);
#if !(defined(WLMCHAN) && defined(WLC_HIGH_ONLY))
		ASSERT(PKTALLOCED(wlc->osh) == 0);
#endif
	}

#ifdef BCMDBG
	/* Since all the packets should have been freed,
	 * all callbacks should have been called
	 */
	for (i = 1; i <= wlc->pub->tunables->maxpktcb; i++)
		ASSERT(wlc->pkt_callback[i].fn == NULL);
#endif

#ifdef CCA_STATS
	cca_free_stats(wlc);
#endif

	WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_DRIVER_DOWN_ID, WL_LOG_LEVEL_INFO, 0, 0, NULL);

	WL_MPC(("wl%d: DOWN  callbacks %d\n", wlc->pub->unit, callbacks));
	wlc->going_down = FALSE;
	return (callbacks);
}

#ifdef WLC_HIGH_ONLY
int
BCMINITFN(wlc_sleep)(wlc_info_t *wlc)
{
	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __FUNCTION__));
	return bcm_rpc_sleep(wlc->rpc);
}

int
BCMINITFN(wlc_resume)(wlc_info_t *wlc)
{
	int err, fw_reload;
	WL_TRACE(("wl%d: %s:\n", wlc->pub->unit, __FUNCTION__));
	err = bcm_rpc_resume(wlc->rpc, &fw_reload);
	if (fw_reload) {
		wlc_phy_stf_chain_init(wlc->band->pi, wlc->stf->hw_txchain,
			wlc->stf->hw_rxchain);
	}
	return err;
}
#endif	/* WLC_HIGH_ONLY */

/* Set the current gmode configuration */
int
wlc_set_gmode(wlc_info_t *wlc, uint8 gmode, bool config)
{
	int ret = 0;
	uint i;
	wlc_rateset_t rs;
	/* Default to 54g Auto */
	int8 shortslot = WLC_SHORTSLOT_AUTO; /* Advertise and use shortslot (-1/0/1 Auto/Off/On) */
	bool shortslot_restrict = FALSE; /* Restrict association to stations that support shortslot
					  */
	bool ignore_bcns = TRUE;		/* Ignore legacy beacons on the same channel */
	bool ofdm_basic = FALSE;		/* Make 6, 12, and 24 basic rates */
	int preamble = WLC_PLCP_LONG; /* Advertise and use short preambles (-1/0/1 Auto/Off/On) */
	bool preamble_restrict = FALSE; /* Restrict association to stations that support short
					 * preambles
					 */
	wlcband_t* band;

	/* if N-support is enabled, allow Gmode set as long as requested
	 * Gmode is not GMODE_LEGACY_B
	 */
	if (N_ENAB(wlc->pub) && gmode == GMODE_LEGACY_B)
		return BCME_UNSUPPORTED;

#ifdef WLP2P
	/* if P2P is enabled no GMODE_LEGACY_B is allowed */
	if (P2P_ACTIVE(wlc) && gmode == GMODE_LEGACY_B)
		return BCME_UNSUPPORTED;
#endif

	/* verify that we are dealing with 2G band and grab the band pointer */
	if (wlc->band->bandtype == WLC_BAND_2G)
		band = wlc->band;
	else if ((NBANDS(wlc) > 1) &&
	         (wlc->bandstate[OTHERBANDUNIT(wlc)]->bandtype == WLC_BAND_2G))
		band = wlc->bandstate[OTHERBANDUNIT(wlc)];
	else
		return BCME_BADBAND;

	/* Legacy or bust when no OFDM is supported by regulatory */
	if ((wlc_channel_locale_flags_in_band(wlc->cmi, band->bandunit) & WLC_NO_OFDM) &&
	    (gmode != GMODE_LEGACY_B))
		return BCME_RANGE;

	/* update configuration value */
	if (config == TRUE)
		wlc_protection_set(wlc, WLC_PROT_G_USER, gmode);

	/* Clear supported rates filter */
	bzero(&wlc->sup_rates_override, sizeof(wlc_rateset_t));

	/* Clear rateset override */
	bzero(&rs, sizeof(wlc_rateset_t));

	switch (gmode) {
	case GMODE_LEGACY_B:
		shortslot = WLC_SHORTSLOT_OFF;
		wlc_rateset_copy(&gphy_legacy_rates, &rs);
		break;

	case GMODE_LRS:
		if (AP_ENAB(wlc->pub))
			wlc_rateset_copy(&cck_rates, &wlc->sup_rates_override);
		break;

	case GMODE_AUTO:
		/* Accept defaults */
		break;

	case GMODE_ONLY:
		ofdm_basic = TRUE;
		preamble = WLC_PLCP_SHORT;
		preamble_restrict = TRUE;
		break;


	case GMODE_PERFORMANCE:
		if (AP_ENAB(wlc->pub))	/* Put all rates into the Supported Rates element */
			wlc_rateset_copy(&cck_ofdm_rates, &wlc->sup_rates_override);

		shortslot = WLC_SHORTSLOT_ON;
		shortslot_restrict = TRUE;
		ofdm_basic = TRUE;
		preamble = WLC_PLCP_SHORT;
		preamble_restrict = TRUE;
		break;

	default:
		/* Error */
		WL_ERROR(("wl%d: %s: invalid gmode %d\n", wlc->pub->unit, __FUNCTION__, gmode));
		return BCME_UNSUPPORTED;
	}

	WL_INFORM(("wl%d: %s: 0x%x 0x%x\n", wlc->pub->unit, __FUNCTION__, gmode, config));

	/*
	 * If we are switching to gmode == GMODE_LEGACY_B,
	 * clean up rate info that may refer to OFDM rates.
	 */
	if ((gmode == GMODE_LEGACY_B) && (band->gmode != GMODE_LEGACY_B)) {
		band->gmode = gmode;
		wlc_scb_reinit(wlc);
		if (band->rspec_override && !IS_CCK(band->rspec_override)) {
			band->rspec_override = 0;
			wlc_reprate_init(wlc);
		}
		if (band->mrspec_override && !IS_CCK(band->mrspec_override)) {
			band->mrspec_override = 0;
		}
	}

	band->gmode = gmode;

	wlc->ignore_bcns = ignore_bcns;

	wlc->shortslot_override = shortslot;
	if (AP_ENAB(wlc->pub))
		wlc->ap->shortslot_restrict = shortslot_restrict;

	if (AP_ENAB(wlc->pub)) {
		wlc_bsscfg_t *bsscfg;
		FOREACH_BSS(wlc, i, bsscfg) {
			bsscfg->PLCPHdr_override =
				(preamble != WLC_PLCP_LONG) ? WLC_PLCP_SHORT : WLC_PLCP_AUTO;
		}
	}

	if ((AP_ENAB(wlc->pub) && preamble != WLC_PLCP_LONG) || preamble == WLC_PLCP_SHORT)
		wlc->default_bss->capability |= DOT11_CAP_SHORT;
	else
		wlc->default_bss->capability &= ~DOT11_CAP_SHORT;

	/* Update shortslot capability bit for AP and IBSS */
	if ((AP_ENAB(wlc->pub) && shortslot == WLC_SHORTSLOT_AUTO) ||
		shortslot == WLC_SHORTSLOT_ON)
		wlc->default_bss->capability |= DOT11_CAP_SHORTSLOT;
	else
		wlc->default_bss->capability &= ~DOT11_CAP_SHORTSLOT;

	/* Use the default 11g rateset */
	if (!rs.count)
		wlc_rateset_copy(&cck_ofdm_rates, &rs);

	if (ofdm_basic) {
		for (i = 0; i < rs.count; i++) {
			if (rs.rates[i] == WLC_RATE_6M || rs.rates[i] == WLC_RATE_12M ||
			    rs.rates[i] == WLC_RATE_24M)
				rs.rates[i] |= WLC_RATE_FLAG;
		}
	}

	/* Set default bss rateset */
	wlc->default_bss->rateset.count = rs.count;
	bcopy((char*)rs.rates, (char*)wlc->default_bss->rateset.rates,
		sizeof(wlc->default_bss->rateset.rates));
	band->defrateset.count = rs.count;
	bcopy((char*)rs.rates, (char*)band->defrateset.rates,
	      sizeof(band->defrateset.rates));

	wlc_update_brcm_ie(wlc);

	return ret;
}

#ifdef WL11N
static int
wlc_nmode_validate(wlc_info_t *wlc, int32 nmode)
{
	int err = 0;

	switch (nmode) {

	case OFF:
		break;

	case AUTO:
	case WL_11N_2x2:
	case WL_11N_3x3:
		if (!(WLC_PHY_11N_CAP(wlc->band)))
			err = BCME_BADBAND;
		break;

	default:
		err = BCME_RANGE;
		break;
	}

	return err;
}

int
wlc_set_nmode(wlc_info_t *wlc, int32 nmode)
{
	uint i;
	int err;
	struct scb *scb;
	struct scb_iter scbiter;

	err = wlc_nmode_validate(wlc, nmode);
	ASSERT(err == 0);
	if (err)
		return err;

	switch (nmode) {
	case OFF:
		wlc->pub->_n_enab = OFF;
		wlc->default_bss->flags &= ~WLC_BSS_HT;
		/* delete the mcs rates from the default and hw ratesets */
		wlc_rateset_mcs_clear(&wlc->default_bss->rateset);
		for (i = 0; i < NBANDS(wlc); i++) {
			memset(wlc->bandstate[i]->hw_rateset.mcs, 0, MCSSET_LEN);
			if (IS_MCS(wlc->band->rspec_override)) {
				wlc->bandstate[i]->rspec_override = 0;
				wlc_reprate_init(wlc);
			}
			if (IS_MCS(wlc->band->mrspec_override))
				wlc->bandstate[i]->mrspec_override = 0;
		}

		/* Clear HT related state for SCBs */
		FOREACHSCB(wlc->scbstate, &scbiter, scb)
		        wlc_ht_update_scbstate(wlc, scb, NULL, NULL, NULL);

		break;

	case AUTO:
		if (wlc->stf->txstreams == WL_11N_3x3)
			nmode = WL_11N_3x3;
		else
			nmode = WL_11N_2x2;
	case WL_11N_2x2:
	case WL_11N_3x3:
		ASSERT(WLC_PHY_11N_CAP(wlc->band));
		/* force GMODE_AUTO if NMODE is ON */
		wlc_set_gmode(wlc, GMODE_AUTO, TRUE);
		if (nmode == WL_11N_3x3)
			wlc->pub->_n_enab = SUPPORT_HT;
		else
			wlc->pub->_n_enab = SUPPORT_11N;
		wlc->default_bss->flags |= WLC_BSS_HT;
		/* add the mcs rates to the default and hw ratesets */
		wlc_rateset_mcs_build(&wlc->default_bss->rateset, wlc->stf->op_rxstreams);
		for (i = 0; i < NBANDS(wlc); i++)
			memcpy(wlc->bandstate[i]->hw_rateset.mcs,
				wlc->default_bss->rateset.mcs, MCSSET_LEN);
		break;

	default:
		ASSERT(0);
		break;
	}

	return err;
}

static int
wlc_setup_nmode(wlc_info_t *wlc, int nmode)
{
	int err;

	err = wlc_nmode_validate(wlc, nmode);
	if (err)
		return err;

	/* save user pref */
	wlc_protection_set(wlc, WLC_PROT_N_USER, nmode);

	/* do not update our current operating nmode if country regulations
	 * force nmode off
	 */
	if (wlc_channel_locale_flags(wlc->cmi) & WLC_NO_MIMO) {
		ASSERT(!N_ENAB(wlc->pub));
		return 0;
	}

	err = wlc_set_nmode(wlc, nmode);
	/* wlc_set_nmode() should only return an error if the call
	 * to wlc_nmode_validate() above returned an error. Make an
	 * assertion that the two functions remain in sync.
	 */
	ASSERT(!err);

	return err;
}
#endif	/* WL11N */

static int
wlc_set_rateset(wlc_info_t *wlc, wlc_rateset_t *rs_arg)
{
	wlc_rateset_t rs, new;
	uint bandunit;

	bcopy((char*)rs_arg, (char*)&rs, sizeof(wlc_rateset_t));

	/* check for bad count value */
	if ((rs.count == 0) || (rs.count > WLC_NUMRATES))
		return BCME_BADRATESET;

	/* try the current band */
	bandunit = wlc->band->bandunit;
	bcopy((char*)&rs, (char*)&new, sizeof(wlc_rateset_t));
	if (wlc_rate_hwrs_filter_sort_validate(&new, &wlc->bandstate[bandunit]->hw_rateset, TRUE,
		wlc->stf->txstreams))
		goto good;

	/* try the other band */
	if (IS_MBAND_UNLOCKED(wlc)) {
		bandunit = OTHERBANDUNIT(wlc);
		bcopy((char*)&rs, (char*)&new, sizeof(wlc_rateset_t));
		if (wlc_rate_hwrs_filter_sort_validate(&new,
			&wlc->bandstate[bandunit]->hw_rateset, TRUE,
			wlc->stf->txstreams))
			goto good;
	}

	return BCME_ERROR;

good:
	/* apply new rateset */
	bcopy((char*)&new, (char*)&wlc->default_bss->rateset, sizeof(wlc_rateset_t));
	bcopy((char*)&new, (char*)&wlc->bandstate[bandunit]->defrateset, sizeof(wlc_rateset_t));
	return (0);
}

#ifdef BCMDBG
void
wlc_rateset_show(wlc_info_t *wlc, wlc_rateset_t *rs, struct ether_addr *ea)
{
	uint idx;
	uint r;
	bool b;

	if (WL_RATE_ON()) {
		if (ea != NULL) {
			char eabuf[ETHER_ADDR_STR_LEN];
			WL_RATE(("wl%d: %s: %s: ", wlc->pub->unit, __FUNCTION__,
			         bcm_ether_ntoa(ea, eabuf)));
		}
		WL_RATE(("[ "));
		for (idx = 0; idx < rs->count; idx++) {
			r = rs->rates[idx] & RATE_MASK;
			b = rs->rates[idx] & (~RATE_MASK);
			if (r == 0)
				break;
			WL_RATE(("%d%s%s ", (r / 2), (r % 2)?".5":"", b?"(b)":""));
		}
		WL_RATE(("]\n"));
	}
}
#endif /* BCMDBG */

/* bandlock ioctl */
int
wlc_bandlock(wlc_info_t *wlc, int val)
{
	chanspec_t chspec;
	bool move;
	uint bandunit, j;

	WL_TRACE(("wl%d: wlc_bandlock: wlc %p val %d\n", wlc->pub->unit, wlc, val));

	/* sanity check arg */
	if ((val < WLC_BAND_AUTO) || (val > WLC_BAND_2G))
		return BCME_RANGE;


	/* single band is easy */
	if (NBANDS(wlc) == 1) {
		if ((val != WLC_BAND_AUTO) && (val != wlc->band->bandtype))
			return BCME_BADBAND;

		wlc->bandlocked = (val == WLC_BAND_AUTO)? FALSE : TRUE;
#ifdef WLLED
		if (wlc->pub->up)
			wlc_led_event(wlc->ledh);
#endif
		return 0;
	}

	/* multiband */
	move = (wlc->band->bandtype != val);
	bandunit = (val == WLC_BAND_5G) ? 1 : 0;

	switch (val) {
	case WLC_BAND_AUTO:
		wlc->bandlocked = FALSE;
		break;

	case WLC_BAND_5G:
	case WLC_BAND_2G: {
		bool valid_channels = FALSE;

		/* make sure new band has at least one hw supported channel */
		for (j = 0; j < MAXCHANNEL; j++) {
			if (VALID_CHANNEL20_IN_BAND(wlc, bandunit, j)) {
				valid_channels = TRUE;
				break;
			}
		}
		if (valid_channels == FALSE) {
			WL_ERROR(("wl%d: can't change band since no valid channels in new band\n",
				wlc->pub->unit));
			return BCME_BADBAND;
		}

		/* prepare to set one band, allow core switching */
		wlc->bandlocked = FALSE;


		if (wlc->pub->up)
			wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);

		if (move) {
#ifdef STA
			if (wlc->pub->up) {
				int idx;
				wlc_bsscfg_t *cfg;
				FOREACH_BSS(wlc, idx, cfg) {
					if (BSSCFG_STA(cfg) && cfg->enable) {
						WL_APSTA_UPDN(("wl%d: wlc_bandlock() ->"
						               " wlc_bsscfg_disable()\n",
						               wlc->pub->unit));
						wlc_disassociate_client(cfg, FALSE, NULL, NULL);
						wlc_bsscfg_disable(wlc, cfg);
					}
				}
			}
#endif /* STA */
#ifdef AP
			if (wlc->pub->up && AP_ENAB(wlc->pub) && wlc->pub->associated) {
				/* do not switch band if the interface is associated in AP mode.
				 * We need do wlc_BSSinit() to sanitize the rateset
				 * otherwise we will fail the wlc_valid_rate checking
				 */
				WL_ERROR(("wl%d: can't change band when associated\n",
					wlc->pub->unit));
				return BCME_ASSOCIATED;
			}
#endif
			/* On changing the band, delete the WDS nodes by freeing the scb
			 * and deleting the wds interface (done by wlc_scbfree). This is
			 * required because the scb is looked up off of the hash table
			 * associated with band and wds scbs will not be found on a band
			 * change in wlc_send.
			 */
			if (AP_ENAB(wlc->pub))
				wlc_scb_wds_free(wlc);

			/* switch to first channel in the new band */
			wlc->band = wlc->bandstate[bandunit];
			chspec = wlc_default_chanspec(wlc->cmi, FALSE);
			ASSERT(chspec != INVCHANSPEC);
			wlc->band = wlc->bandstate[OTHERBANDUNIT(wlc)];
			wlc->home_chanspec = chspec;

			if (wlc->pub->up) {
				wlc_suspend_mac_and_wait(wlc);
				wlc_set_chanspec(wlc, chspec);
				wlc_enable_mac(wlc);
			} else {
				/* In down state, only update the software chanspec. Don't call
				 * wlc_set_chanspec(), which touches the hardware. In high driver,
				 * there's no concept of band switch, which is encapsulated inside
				 * the chanspec change.
				 */
				wlc->band = wlc->bandstate[bandunit];
				/* sync up phy/radio chanspec */
				wlc_set_phy_chanspec(wlc, chspec);
			}

		}

		/* If the default bss chanspec is now invalid then pick a valid one */
		if (!wlc_valid_chanspec(wlc->cmi, wlc->default_bss->chanspec))
			wlc->default_bss->chanspec = wlc_default_chanspec(wlc->cmi, TRUE);

		/* Update bss rates to the band specific default rate set */
		wlc_default_rateset(wlc, &wlc->default_bss->rateset);

		wlc->bandlocked = TRUE;
		break;
	}
	default:
		ASSERT(0);
		break;
	}

#ifdef WLLED
	/* fixup LEDs */
	if (wlc->pub->up)
		wlc_led_event(wlc->ledh);
#endif

	return 0;
}

/* return WPA capabilities */
static int
wlc_wpa_cap(wlc_info_t *wlc, wlc_bsscfg_t *cfg, uint8 *cap, int len)
{
	ASSERT(len >= WPA_CAP_LEN);

	if (len < WPA_CAP_LEN)
		return -1;

	/* RSN capabilities */
	cap[0] = ((BSS_WME_ENAB(wlc, cfg) ?
		WLC_REPLAY_CNTRS_VALUE : 0) << WPA_CAP_REPLAY_CNTR_SHIFT);
	if (BSSCFG_AP(cfg) && (cfg->WPA_auth & WPA2_AUTH_UNSPECIFIED) &&
	    (cfg->wpa2_preauth == TRUE))
		cap[0] |= WPA_CAP_WPA2_PREAUTH;
	cap[1] = 0;

#ifdef MFP
	if (cfg->wsec & MFP_CAPABLE)
		cap[0] |= RSN_CAP_MFPC;
	if (cfg->wsec & MFP_REQUIRED)
		cap[0] |= RSN_CAP_MFPR;
#endif /* MFP */

	return 0;
}

/* simplified integer set interface for common ioctl handler */
int
wlc_set(wlc_info_t *wlc, int cmd, int arg)
{
	return wlc_ioctl(wlc, cmd, (void *)&arg, sizeof(arg), NULL);
}

/* simplified integer get interface for common ioctl handler */
int
wlc_get(wlc_info_t *wlc, int cmd, int *arg)
{
	return wlc_ioctl(wlc, cmd, arg, sizeof(int), NULL);
}

#if defined(OPENSRC_IOV_IOCTL) && !defined(BCMDBG)
/*  list of command supported by linux sta hybrid module */
static int
wlc_ioctl_filter(wlc_info_t *wlc, int cmd, void *arg, int len)
{
	switch (cmd) {
		case WLC_SET_DTIMPRD:
		case WLC_SET_REGULATORY:
		case WLC_SET_CLOSED:
		case WLC_SET_COUNTRY:
		case WLC_FREQ_ACCURACY:
		case WLC_CARRIER_SUPPRESS:
//		case WLC_GET_PHYREG:
//		case WLC_SET_PHYREG:
		case WLC_GET_RADIOREG:
		case WLC_SET_RADIOREG:
		case WLC_SET_MACMODE:
		case WLC_SET_WDSLIST:
		case WLC_SET_CLK:
		case WLC_SET_SUP_RATESET_OVERRIDE:
		case WLC_SET_ASSOC_PREFER:
		case WLC_SET_BAD_FRAME_PREEMPT:
		case WLC_SET_SPECT_MANAGMENT:
			return -1;
		default:
			return 0;
	}
}
#endif /* defined(OPENSRC_IOV_IOCTL) && !defined(BCMDBG) */

static int
wlc_phy_ioctl_chk(wlc_info_t *wlc, int cmd, int len, void *arg)
{
	int bcmerror;
	uint band;

	bcmerror = BCME_OK;
	/* optional band is stored in the second integer of incoming buffer */
	band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];

	switch (cmd) {
#if defined(BCMDBG) || defined(WLTEST)
		case WLC_GET_RADIOREG:
		case WLC_SET_RADIOREG:
			bcmerror = wlc_iocregchk(wlc, band);
			break;

#endif 

//#if defined(BCMDBG) || defined(WLTEST)
		case WLC_GET_PHYREG:
		case WLC_SET_PHYREG:
			bcmerror = wlc_iocregchk(wlc, band);
			break;

//#endif 

#if defined(BCMDBG) || defined(WLTEST)
		case WLC_GET_TSSI:
		case WLC_GET_ATTEN:
		case WLC_LONGTRAIN:
		case WLC_EVM:
		case WLC_FREQ_ACCURACY:
		case WLC_CARRIER_SUPPRESS:
			bcmerror = wlc_iocregchk(wlc, WLC_BAND_AUTO);
			break;

		case WLC_SET_ATTEN:
		case WLC_GET_PWRIDX:
		case WLC_SET_PWRIDX:
			bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE);
			break;

#endif 

#if defined(BCMDBG)
		case WLC_GET_TX_PATH_PWR:
		case WLC_SET_TX_PATH_PWR:
			/* check for bandlock */
			if (wlc->band->radioid != BCM2050_ID)
				bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE);

			break;
#endif /* BCMDBG */

		default:
			break;
	}

	return bcmerror;
}

void
wlc_if_event(wlc_info_t *wlc, uint8 what, struct wlc_if *wlcif)
{
	wlc_event_t *e;
	wlc_bsscfg_t *cfg;
	wl_event_data_if_t *d;
	uint8 r;

	if ((cfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif)) == NULL) {
		WL_ERROR(("wl%d: wlc_if_event: wlc_bsscfg_find_by_wlcif failed\n", WLCWLUNIT(wlc)));
		return;
	}

	/* Don't do anything if the eventing system has been shutdown */
	if (wlc->eventq == NULL) {
		WL_ERROR(("wl%d: wlc_if_event: eventing subsystem is down\n", WLCWLUNIT(wlc)));
		return;
	}

	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_if_event: wlc_event_alloc failed\n", WLCWLUNIT(wlc)));
		return;
	}

	bcopy(&cfg->cur_etheraddr.octet, e->event.addr.octet, ETHER_ADDR_LEN);
	e->addr = &(e->event.addr);

	e->event.event_type = WLC_E_IF;
	e->event.datalen = sizeof(wl_event_data_if_t);
	e->data = MALLOC(wlc->osh, e->event.datalen);
	if (e->data == NULL) {
		WL_ERROR(("wl%d: wlc_if_event MALLOC failed\n", WLCWLUNIT(wlc)));
		wlc_event_free(wlc->eventq, e);
		return;
	}

	d = (wl_event_data_if_t *)e->data;
	d->ifidx = wlcif->index;
	d->opcode = what;
	d->reserved = BSSCFG_HAS_NOIF(cfg);
	d->bssidx = WLC_BSSCFG_IDX(cfg);
	if (wlcif->type == WLC_IFTYPE_BSS) {
		if (BSSCFG_AP(cfg)) {
#ifdef WLP2P
			if (BSS_P2P_ENAB(wlc, cfg))
				r = WLC_E_IF_ROLE_P2P_GO;
			else
#endif
#ifdef WLBTAMP
			if (BSS_BTA_ENAB(wlc, cfg))
				r = WLC_E_IF_ROLE_BTA_CREATOR;
			else
#endif
				r = WLC_E_IF_ROLE_AP;
		}
		else {
#ifdef WLP2P
			if (BSS_P2P_ENAB(wlc, cfg))
				r = WLC_E_IF_ROLE_P2P_CLIENT;
			else
#endif
#ifdef WLBTAMP
			if (BSS_BTA_ENAB(wlc, cfg))
				r = WLC_E_IF_ROLE_BTA_ACCEPTOR;
			else
#endif
				r = WLC_E_IF_ROLE_STA;
		}
	}
	else
		r = WLC_E_IF_ROLE_WDS;
	d->role = r;

	/* always send the WLC_E_IF event to the main interface */
	_wlc_event_if(wlc, e, cfg, cfg->wlcif, wlc->cfg->wlcif);

	wlc_process_event(wlc, e);
}

static void
wlc_ofdm_rateset_war(wlc_info_t *wlc)
{
	uint8 r;
	bool war = FALSE;

	if (wlc->cfg->associated)
		r = wlc->cfg->current_bss->rateset.rates[0];
	else
		r = wlc->default_bss->rateset.rates[0];

	if (WLCISGPHY(wlc->band) && (r != 0x82) && (r != 0x84) && (r != 0x8b) && (r != 0x96))
		war = TRUE;

	wlc_phy_ofdm_rateset_war(wlc->band->pi, war);

	return;
}

int
wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
{
	return (_wlc_ioctl(wlc, cmd, arg, len, wlcif));
}

#ifdef STA
static int
wlc_set_pm_mode(wlc_info_t *wlc, int val, wlc_bsscfg_t *bsscfg)
{
	wlc_pm_st_t *pm = bsscfg->pm;

	if ((val < PM_OFF) || (val > PM_FAST)) {
		return BCME_ERROR;
	}

	WL_INFORM(("wl%d.%d: setting PM to %d\n",
		WLCWLUNIT(wlc), WLC_BSSCFG_IDX(bsscfg), val));

	pm->PM = (uint8)val;
	/* if entering or exiting Fast PM mode, reset the PM2 features,
	 * stop any timers, and restore the TBTT wakeup interval.
	 */
	if (wlc->pub->up) {
		wlc_pm2_sleep_ret_timer_stop(bsscfg);
		if (PM2_RCV_DUR_ENAB(bsscfg)) {
			wlc_pm2_rcv_reset(bsscfg);
		}
		WL_RTDC(wlc, "WLC_SET_PM: %d\n", pm->PM, 0);
	}
	/* Set pmstate only if coming out of PM mode or PM is allowed */
	if (!pm->WME_PM_blocked || val == PM_OFF)
		wlc_set_pmstate(bsscfg, val != PM_OFF);
	/* Change watchdog driver to align watchdog with tbtt if possible */
	wlc_watchdog_upd(bsscfg, PS_ALLOWED(bsscfg));
	wlc_roam_thresh_upd(bsscfg);
	return 0;
}

#endif /* STA */

/* common ioctl handler. return: 0=ok, -1=error, positive=particular error */
static int
_wlc_ioctl(wlc_info_t *wlc, int cmd, void *arg, int len, struct wlc_if *wlcif)
{
	int val, *pval;
	bool bool_val;
	int bcmerror;
	d11regs_t *regs;
	uint i;
	struct scb *scb = NULL;
	struct scb *nextscb;
	struct maclist *maclist;
	scb_val_t *scb_val = (scb_val_t*)arg;
	bool ta_ok;
	uint band;
	rw_reg_t *r;
	wlc_bsscfg_t *bsscfg;
	struct scb_iter scbiter;
	osl_t *osh;
	int seq_cmd_rc;
	wlc_bss_info_t *current_bss;
	wlc_assoc_t *as;
#ifdef STA
	wlc_roam_t *roam;
	wlc_pm_st_t *pm;
#endif
	wlc_prot_cfg_t *prot;

	/* update bsscfg pointer */
	bsscfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif);
	ASSERT(bsscfg != NULL);

	current_bss = bsscfg->current_bss;
	as = bsscfg->assoc;
#ifdef STA
	roam = bsscfg->roam;
	pm = bsscfg->pm;
#endif
	prot = bsscfg->prot_cfg;

	/* update wlcif pointer */
	if (wlcif == NULL)
		wlcif = bsscfg->wlcif;

	/* initialize the following to get rid of compiler warning */
	nextscb = NULL;
	ta_ok = FALSE;
	band = 0;
	r = NULL;

	/* If the IOCTL is part of a "batched" sequence command, simply queue it
	 * for future execution, and return a dummy success response. If not,
	 * process it immediately.
	 */
	seq_cmd_rc = wlc_seq_cmds_process(wlc->seq_cmds_info, cmd, arg, len, wlcif);
	if (SEQ_CMDS_BUFFERED == seq_cmd_rc)
		return (BCME_OK);
	else if (SEQ_CMDS_NOT_BUFFERED != seq_cmd_rc) {
		bcmerror = seq_cmd_rc;
		goto done;
	}

#if defined(OPENSRC_IOV_IOCTL) && !defined(BCMDBG)
	bcmerror = wlc_ioctl_filter(wlc, cmd, arg, len);
	if (bcmerror < 0)
		return BCME_UNSUPPORTED;
#endif

	bcmerror = wlc_mfg_ioctl_filter(wlc->pub, cmd);
	if (bcmerror < 0)
		return BCME_UNSUPPORTED;

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return (wlc_lmac_ioctl(wlc->lmac_info, cmd, arg, len, wlcif));
#endif

	/* If the device is turned off, then it's not "removed" */
	if (!wlc->pub->hw_off && DEVICEREMOVED(wlc)) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		wl_down(wlc->wl);
		return BCME_ERROR;
	}

	ASSERT(!(wlc->pub->hw_off && wlc->pub->up));

	/* default argument is generic integer */
	pval = arg ? (int *) arg : NULL;

	/* This will prevent the misaligned access */
	if (pval && (uint32)len >= sizeof(val))
		bcopy(pval, &val, sizeof(val));
	else
		val = 0;

	/* bool conversion to avoid duplication below */
	bool_val = val != 0;

	WL_TRACE(("wl%d: wlc_ioctl: interface %s cmd %d val 0x%x (%d) len %d\n",
		wlc->pub->unit, wl_ifname(wlc->wl, wlcif->wlif), cmd, (uint)val, val, len));
	WL_OID(("wl%d: wlc_ioctl: interface %s cmd %d val 0x%x (%d) len %d\n",
		wlc->pub->unit, wl_ifname(wlc->wl, wlcif->wlif), cmd, (uint)val, val, len));

	bcmerror = 0;
	regs = wlc->regs;
	osh = wlc->osh;

	/* A few commands don't need any arguments; all the others do. */
	switch (cmd) {
	case WLC_UP:
	case WLC_OUT:
	case WLC_DOWN:
	case WLC_DISASSOC:
	case WLC_RESTART:
	case WLC_REBOOT:
	case WLC_START_CHANNEL_QA:
	case WLC_INIT:
		break;

	default:
		if ((arg == NULL) || (len <= 0)) {
			WL_ERROR(("wl%d: %s: Command %d needs arguments\n",
			          wlc->pub->unit, __FUNCTION__, cmd));
			bcmerror = BCME_BADARG;
			goto done;
		}
	}

	switch (cmd) {

	case WLC_GET_MAGIC:
		*pval = WLC_IOCTL_MAGIC;
		break;

	case WLC_GET_VERSION:
		*pval = WLC_IOCTL_VERSION;
		break;

	case WLC_UP:
		/* Don't access the hardware if hw is off */
		if (wlc->pub->hw_off)
			return BCME_RADIOOFF;

		wlc->down_override = FALSE;
		wlc->mpc_out = FALSE;
#ifdef STA
		wlc_radio_mpc_upd(wlc);
#endif /* STA */

#ifdef WLC_LOW
		/* BMAC_NOTES, TBD */
		wlc_radio_hwdisable_upd(wlc);
#endif

		wlc_radio_upd(wlc);

		if (!wlc->pub->up) {
			if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE) ||
			    mboolisset(wlc->pub->radio_disabled, WL_RADIO_SW_DISABLE)) {
				bcmerror = BCME_RADIOOFF;
			} else if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE)) {
				WL_INFORM(("wl%d: up failed: mpc radio is disabled\n",
					wlc->pub->unit));
			} else if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_COUNTRY_DISABLE)) {
				WL_INFORM(("wl%d: up failed: radio is disabled for country %s\n",
					wlc->pub->unit, wlc_channel_country_abbrev(wlc->cmi)));
			} else {
				/* something is wrong */
				bcmerror = BCME_ERROR;
#ifdef WLC_LOW     /* for BMAC dongle WLC_UP  may fail if timeout when resume */
				ASSERT(0);
#endif /* WLC_HIGH_ONLY */
			}
		}
		break;

	case WLC_OUT:

		/* Don't access the hardware if hw is off */
		if (wlc->pub->hw_off)
			return BCME_RADIOOFF;

		/* make MPC transparent to "wl out", bring driver up if MPC made it down */
		wlc->mpc_out = TRUE;
#ifdef STA
		wlc_radio_mpc_upd(wlc);	/* this may cause interrupts and queued dpc */
		if (!wlc->pub->up)
			WL_MPC(("wl%d: WLC_OUT, driver was down, but not due to MPC\n",
			        wlc->pub->unit));
#endif /* STA */

		wlc->down_override = TRUE;
		wlc_out(wlc);
		break;

	case WLC_DOWN:
		wlc->down_override = TRUE;
		WL_APSTA_UPDN(("wl%d: wlc_ioctl(WLC_DOWN) -> wl_down()\n",
			wlc->pub->unit));

		/* Don't access the hardware if hw is off */
		if (wlc->pub->hw_off)
			break;

		wl_down(wlc->wl);
		break;


	case WLC_GET_UP:
		*pval = (int)wlc->pub->up;
		break;

	case WLC_GET_CLK:
		*pval = wlc->clk;
		break;

	case WLC_SET_CLK:
		if (wlc->pub->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}

		/* Don't access the hardware if hw is off */
		if (wlc->pub->hw_off) {
			bcmerror = BCME_RADIOOFF;
			break;
		}

#ifdef BCMRECLAIM
		if (bcmreclaimed) {
			bcmerror = val ? 0 : BCME_EPERM;
			break;
		}
#endif /* BCMRECLAIM */

		wlc_bmac_set_clk(wlc->hw, bool_val);
		wlc->clk = bool_val;

		break;

#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_MSGLEVEL:
		*pval = wl_msg_level;
		break;

	case WLC_SET_MSGLEVEL:
		wl_msg_level = val;
		break;
#endif /* BCMDBG || WLTEST */

#if defined(WL_PROMISC) || defined(BCMSPACE)
	case WLC_GET_PROMISC:
		*pval = (int)wlc->pub->promisc;
		break;

	case WLC_SET_PROMISC:
		wlc->pub->promisc = (val != 0);

		if (!wlc->clk) {
			bcmerror = 0;
			break;
		}

		wlc_mac_promisc(wlc);
		break;
#endif /* WL_PROMISC || BCMSPACE */

#if defined(WL_MONITOR) || defined(BCMSPACE)
	case WLC_GET_MONITOR:
		*pval = (int)wlc->monitor;
		break;

	case WLC_SET_MONITOR:
		wlc->monitor = val;
		wlc->bcnmisc_monitor = (wlc->monitor != 0);
#ifdef STA
		/* disable mpc if monitor is on, enable mpc if monitor is off */
		wlc_radio_mpc_upd(wlc);
#endif
		if (!wlc->clk) {
			bcmerror = 0;
			break;
		}

		wlc_mac_bcn_promisc(wlc);
		wlc_mac_promisc(wlc);

		wl_set_monitor(wlc->wl, val);

#ifdef STA
		/* Update PM state based on Monitor mode */
		wlc_set_wake_ctrl(wlc);
#endif /* STA */
		break;
#endif 

	case WLC_GET_RATE: {
		/* return raw datarate in units of 500 Kbit/s, other parameters are translated */
		ratespec_t rspec = wlc_get_rspec_history(bsscfg);
		*pval = RSPEC2KBPS(rspec)/500;
		break;
	}

	case WLC_GET_MAX_RATE: {
		/* return max raw datarate in units of 500 Kbit/s */
		ratespec_t rspec = wlc_get_current_highest_rate(bsscfg);
		*pval = RSPEC2KBPS(rspec)/500;
		break;
	}

	case WLC_GET_INSTANCE:
		*pval = wlc->pub->unit;
		break;

	case WLC_GET_INFRA:
		*pval = bsscfg->BSS;
		break;

	case WLC_SET_INFRA:
		if (BSSCFG_AP(bsscfg) && val == 0) {
			bcmerror = BCME_NOTSTA;
		}
		else
			wlc->default_bss->infra = val?1:0;
		break;

	case WLC_GET_AUTH:
		*pval = DOT11AUTH2WLAUTH(bsscfg);
		break;

	case WLC_SET_AUTH:
		if (val == WL_AUTH_OPEN_SHARED) {
			bsscfg->auth = DOT11_OPEN_SYSTEM;
			bsscfg->openshared = 1;
		} else {
			bsscfg->auth = WLAUTH2DOT11AUTH(val);
			bsscfg->openshared = 0;
		}
		break;

	case WLC_GET_BSSID:

		/* Report on primary config */
		if ((BSSCFG_STA(bsscfg) && !bsscfg->associated)) {
			bcmerror = BCME_NOTASSOCIATED;
			break;
		}
		if (len < ETHER_ADDR_LEN) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(bsscfg->BSSID.octet, arg, ETHER_ADDR_LEN);
		break;

	case WLC_SET_BSSID:
		if (bsscfg->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}

		if (len < ETHER_ADDR_LEN) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(arg, bsscfg->BSSID.octet, ETHER_ADDR_LEN);
		if (!wlc->clk) {
			bcmerror = 0;
			break;
		}

		wlc_set_bssid(bsscfg);
		break;

	case WLC_GET_SSID: {
		wlc_ssid_t *ssid = (wlc_ssid_t *) arg;
		if (len < (int)sizeof(wlc_ssid_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bzero((char*)ssid, sizeof(wlc_ssid_t));
		if (BSSCFG_AP(bsscfg)) {
			ssid->SSID_len = bsscfg->SSID_len;
			bcopy(bsscfg->SSID, ssid->SSID, ssid->SSID_len);
		} else if (bsscfg->associated) {
			ssid->SSID_len = current_bss->SSID_len;
			bcopy(current_bss->SSID, ssid->SSID, current_bss->SSID_len);
		} else {
			ssid->SSID_len = wlc->default_bss->SSID_len;
			bcopy(wlc->default_bss->SSID, ssid->SSID, wlc->default_bss->SSID_len);
		}

		break;
	}

	case WLC_SET_SSID: {
		wlc_ssid_t *ssid = (wlc_ssid_t *)arg;

		if (len < (int)sizeof(ssid->SSID_len)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		if (len < (int)(sizeof(ssid->SSID_len))+(int)ssid->SSID_len) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		if (ssid->SSID_len > DOT11_MAX_SSID_LEN) {
			bcmerror = BCME_BADSSIDLEN;
			break;
		}

		/* keep old behavior of WLC_SET_SSID by restarting the AP's BSS
		 * if the SSID is non-null
		 */
		if (BSSCFG_AP(bsscfg)) {
			wlc_bsscfg_SSID_set(bsscfg, ssid->SSID, ssid->SSID_len);

			WL_APSTA_UPDN(("wl%d: SET_SSID -> wlc_bsscfg_disable()\n",
			               wlc->pub->unit));
			wlc_bsscfg_disable(wlc, bsscfg);

			/* only bring up the BSS if SSID is non-null */
			if (bsscfg->SSID_len != 0) {
				WL_APSTA_UPDN(("wl%d: SET_SSID -> wlc_bsscfg_enable()\n",
					wlc->pub->unit));
				bcmerror = wlc_bsscfg_enable(wlc, bsscfg);
				if (bcmerror)
					break;
#if defined(RADAR)
				if (WL11H_AP_ENAB(wlc)) {
					/* no radar detection if sta is associated since
					 * AP shares the same channel which is selected
					 * by an external AP sta associates with
					 */
					if (!(BSSCFG_SRADAR_ENAB(bsscfg) ||
					      BSSCFG_AP_NORADAR_CHAN_ENAB(bsscfg)))
						wlc_set_dfs_cacstate(wlc->ap, ON);
				}
#endif /* defined(RADAR) */
			}
		}

#ifdef STA
		/* Behavior of WLC_SET_SSID for STA is different from that for AP */
		if (BSSCFG_STA(bsscfg)) {
			wl_join_assoc_params_t *assoc_params = NULL;
			int assoc_params_len = 0;

			if ((uint)len >= WL_JOIN_PARAMS_FIXED_SIZE) {
				assoc_params = &((wl_join_params_t *)arg)->params;
				assoc_params_len = len - OFFSETOF(wl_join_params_t, params);
				if ((uint)len < WL_JOIN_PARAMS_FIXED_SIZE +
				    assoc_params->chanspec_num * sizeof(chanspec_t)) {
					bcmerror = BCME_BUFTOOSHORT;
					break;
				}
				bcmerror = wlc_assoc_chanspec_sanitize(wlc,
				                                      assoc_params->chanspec_list,
				                                      assoc_params->chanspec_num);
				if (bcmerror != BCME_OK)
					break;
			}
			WL_APSTA_UPDN(("wl%d: SET_SSID(STA) -> wlc_join()\n",
			               wlc->pub->unit));
			wlc_join(wlc, bsscfg, ssid->SSID, ssid->SSID_len,
			         NULL,
			         assoc_params, assoc_params_len);
			bcmerror = BCME_OK;
		}
#endif /* STA */

		break;
	}


	case WLC_GET_CHANNEL: {
		channel_info_t *ci = (channel_info_t*)arg;

		ASSERT(len > (int)sizeof(ci));

		ci->hw_channel = CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC);

		if (bsscfg->associated)
			ci->target_channel = CHSPEC_CHANNEL(current_bss->chanspec);
		else
			ci->target_channel = CHSPEC_CHANNEL(wlc->default_bss->chanspec);

		ci->scan_channel = 0;

		if (SCAN_IN_PROGRESS(wlc->scan))
			ci->scan_channel = CHSPEC_CHANNEL(wlc_scan_get_current_chanspec(wlc->scan));
		break;
	}

	case WLC_SET_CHANNEL:  {
		chanspec_t chspec = CH20MHZ_CHSPEC(val);

		if (val < 0 || val > MAXCHANNEL) {
			bcmerror = BCME_OUTOFRANGECHAN;
			break;
		}

		if (!wlc_valid_chanspec_db(wlc->cmi, chspec)) {
			bcmerror = BCME_BADCHAN;
			break;
		}

#if defined(AP) && defined(RADAR)
		/* allow channel override for BCMINTERNAL and WLTEST build */
		if (AP_ENAB(wlc->pub))
			wlc_dfs_setchanspec(wlc->ap, chspec);
#endif /* defined(AP) && defined(RADAR) */

		if (!wlc->pub->up && IS_MBAND_UNLOCKED(wlc)) {
			if (wlc->band->bandunit != CHSPEC_WLCBANDUNIT(chspec))
				wlc->bandinit_pending = TRUE;
			else
				wlc->bandinit_pending = FALSE;
		}

		/* want to migrate to use bsscfg->chanspec as the configured chanspec
		 * and wlc->chanspec as the current chanspec.
		 * wlc->default_bss->chanspec would have no meaning
		 */
		wlc->default_bss->chanspec = chspec;
#ifdef WLMCHAN
		if (MCHAN_ENAB(wlc->pub))
			bsscfg->chanspec = chspec;
#endif /* WLMCHAN */

		/* wlc_BSSinit() will sanitize the rateset before using it.. */
		if (wlc->pub->up && !wlc->pub->associated &&
		    (WLC_BAND_PI_RADIO_CHANSPEC != chspec)) {
			wlc_set_home_chanspec(wlc, chspec);
			wlc_suspend_mac_and_wait(wlc);
			wlc_set_chanspec(wlc, chspec);
			wlc_enable_mac(wlc);
		}
		break;
	}

	case WLC_GET_PWROUT_PERCENTAGE:
		*pval = wlc->txpwr_percent;
		break;

	case WLC_SET_PWROUT_PERCENTAGE:
		if ((uint)val > 100) {
			bcmerror = BCME_RANGE;
			break;
		}

		wlc->txpwr_percent = (uint8)val;
		wlc_bmac_set_txpwr_percent(wlc->hw, (uint8)val);
		if (wlc->pub->up) {
			if (SCAN_IN_PROGRESS(wlc->scan)) {
				WL_INFORM(("wl%d: Scan in progress, skipping txpower control\n",
					wlc->pub->unit));
			} else {
				wlc_suspend_mac_and_wait(wlc);

				/* Set the power limits for this locale after computing
				 * any 11h local tx power constraints.
				 */
				wlc_channel_set_txpower_limit(wlc->cmi,
					wlc_local_constraint_qdbm(wlc));

				wlc_enable_mac(wlc);
			}
		}
		break;

#if defined(BCMDBG)
	case WLC_GET_UCFLAGS:
		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		/* optional band is stored in the second integer of incoming buffer */
		band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		if (val >= MHFMAX) {
			bcmerror = BCME_RANGE;
			break;
		}

		*pval = wlc_bmac_mhf_get(wlc->hw, (uint8)val, WLC_BAND_AUTO);
		break;

	case WLC_SET_UCFLAGS:
		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		/* optional band is stored in the second integer of incoming buffer */
		band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		i = (uint16)val;
		if (i >= MHFMAX) {
			bcmerror = BCME_RANGE;
			break;
		}

		wlc_mhf(wlc, (uint8)i, 0xffff, (uint16)(val >> NBITS(uint16)), WLC_BAND_AUTO);
		break;

	case WLC_GET_SHMEM:
		ta_ok = TRUE;

		/* optional band is stored in the second integer of incoming buffer */
		band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		if (val & 1) {
			bcmerror = BCME_BADADDR;
			break;
		}

		*pval = wlc_read_shm(wlc, (uint16)val);
		break;

	case WLC_SET_SHMEM:
		ta_ok = TRUE;

		/* optional band is stored in the second integer of incoming buffer */
		band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : ((int *)arg)[1];

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		if (val & 1) {
			bcmerror = BCME_BADADDR;
			break;
		}

		wlc_write_shm(wlc, (uint16)val, (uint16)(val >> NBITS(uint16)));
		break;

	case WLC_R_REG:	/* MAC registers */
		ta_ok = TRUE;
		r = (rw_reg_t*)arg;
		band = WLC_BAND_AUTO;

		if (len < (int)(sizeof(rw_reg_t) - sizeof(uint))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		if (len >= (int)sizeof(rw_reg_t))
			band = r->band;

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		if ((r->byteoff + r->size) > sizeof(d11regs_t)) {
			bcmerror = BCME_BADADDR;
			break;
		}
		if (r->size == sizeof(uint32))
			r->val = R_REG(osh, (uint32 *)((uchar *)(uintptr)regs + r->byteoff));
		else if (r->size == sizeof(uint16))
			r->val = R_REG(osh, (uint16 *)((uchar *)(uintptr)regs + r->byteoff));
		else
			bcmerror = BCME_BADADDR;
		break;

	case WLC_W_REG:
		ta_ok = TRUE;
		r = (rw_reg_t*)arg;
		band = WLC_BAND_AUTO;

		if (len < (int)(sizeof(rw_reg_t) - sizeof(uint))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		if (len >= (int)sizeof(rw_reg_t))
			band = r->band;

		/* bcmerror checking */
		if ((bcmerror = wlc_iocregchk(wlc, band)))
			break;

		if (r->byteoff + r->size > sizeof(d11regs_t)) {
			bcmerror = BCME_BADADDR;
			break;
		}
		if (r->size == sizeof(uint32))
			W_REG(osh, (uint32 *)((uchar *)(uintptr)regs + r->byteoff), r->val);
		else if (r->size == sizeof(uint16))
			W_REG(osh, (uint16 *)((uchar *)(uintptr)regs + r->byteoff), r->val);
		else
			bcmerror = BCME_BADADDR;
		break;
#endif /* BCMDBG */

	case WLC_GET_TXANT:
		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}
		*pval = wlc->stf->txant;
		break;

	case WLC_SET_TXANT:
		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}
		bcmerror = wlc_stf_ant_txant_validate(wlc, (int8)val);
		if (bcmerror < 0)
			break;

		wlc->stf->txant = (int8)val;

		/* if down, we are done */
		if (!wlc->pub->up)
			break;

		wlc_suspend_mac_and_wait(wlc);

		wlc_stf_phy_txant_upd(wlc);
		wlc_beacon_phytxctl_txant_upd(wlc, wlc->bcn_rspec);

		wlc_enable_mac(wlc);

		break;

	case WLC_GET_ANTDIV: {
		uint8 phy_antdiv;

		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}

		/* return configured value if core is down */
		if (!wlc->pub->up) {
			*pval = wlc->stf->ant_rx_ovr;

		} else {
			if (wlc_phy_ant_rxdiv_get(wlc->band->pi, &phy_antdiv))
				*pval = (int)phy_antdiv;
			else
				*pval = (int)wlc->stf->ant_rx_ovr;
		}

		break;
	}
	case WLC_SET_ANTDIV:
		/* values are -1=driver default, 0=force0, 1=force1, 2=start1, 3=start0 */
		if ((val < -1) || (val > 3)) {
			bcmerror = BCME_RANGE;
			break;
		}

		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}

		if (val == -1)
			val = ANT_RX_DIV_DEF;

		wlc->stf->ant_rx_ovr = (uint8)val;
		wlc_phy_ant_rxdiv_set(wlc->band->pi, (uint8)val);
		break;

	case WLC_GET_RX_ANT: {	/* get latest used rx antenna */
		uint16 rxstatus;

		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		rxstatus = R_REG(wlc->osh, &wlc->regs->phyrxstatus0);
		if (rxstatus == 0xdead || rxstatus == (uint16)-1) {
			bcmerror = BCME_ERROR;
			break;
		}
		*pval = (rxstatus & PRXS0_RXANT_UPSUBBAND) ? 1 : 0;
		break;
	}

#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_UCANTDIV:
		if (!wlc->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}

		*pval = (wlc_bmac_mhf_get(wlc->hw, MHF1, WLC_BAND_AUTO) & MHF1_ANTDIV);
		break;

	case WLC_SET_UCANTDIV: {
		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		/* if multiband, band must be locked */
		if (IS_MBAND_UNLOCKED(wlc)) {
			bcmerror = BCME_NOTBANDLOCKED;
			break;
		}

		if (WLCISHTPHY(wlc->band)) {
			bcmerror = BCME_UNSUPPORTED;
			break;
		}

		/* 4322 supports antdiv in phy, no need to set it to ucode */
		if (WLCISNPHY(wlc->band) && D11REV_IS(wlc->pub->corerev, 16)) {
			WL_ERROR(("wl%d: can't set ucantdiv for 4322\n", wlc->pub->unit));
			bcmerror = BCME_UNSUPPORTED;
		} else
			wlc_mhf(wlc, MHF1, MHF1_ANTDIV, (val? MHF1_ANTDIV : 0), WLC_BAND_AUTO);
		break;
	}
#endif /* BCMDBG || WLTEST */

	case WLC_GET_SRL:
		*pval = wlc->SRL;
		break;

	case WLC_SET_SRL:
		if (val >= 1 && val <= RETRY_SHORT_MAX) {
			int ac;
			wlc->SRL = (uint16)val;

			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);

			for (ac = 0; ac < AC_COUNT; ac++) {
				WLC_WME_RETRY_SHORT_SET(wlc, ac, wlc->SRL);
			}
			wlc_wme_retries_write(wlc);
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_LRL:
		*pval = wlc->LRL;
		break;

	case WLC_SET_LRL:
		if (val >= 1 && val <= 255) {
			int ac;
			wlc->LRL = (uint16)val;

			wlc_bmac_retrylimit_upd(wlc->hw, wlc->SRL, wlc->LRL);

			for (ac = 0; ac < AC_COUNT; ac++) {
				WLC_WME_RETRY_LONG_SET(wlc, ac, wlc->LRL);
			}
			wlc_wme_retries_write(wlc);
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_CWMIN:
		*pval = wlc->band->CWmin;
		break;

	case WLC_SET_CWMIN:
		if (!wlc->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		if (val >= 1 && val <= 255) {
			wlc_set_cwmin(wlc, (uint16)val);
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_CWMAX:
		*pval = wlc->band->CWmax;
		break;

	case WLC_SET_CWMAX:
		if (!wlc->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}

		if (val >= 255 && val <= 2047) {
			wlc_set_cwmax(wlc, (uint16)val);
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_PLCPHDR:
		*pval = bsscfg->PLCPHdr_override;
		break;

	case WLC_SET_PLCPHDR:
		/*
		 * Regardless of the value here, the MAC will always return ctrl/mgmt
		 * response frames with the same type preamble as received.
		 * So will the driver unless forced long (1) here (testing only).
		 * (-1) is to disable short preamble capability advertisement and
		 *      never to initiate a short preamble frame exchange sequence.
		 * (0) BSS STA: enable short preamble capability advertisement but
		 *              the driver will only send short preambles if the
		 *              AP also advertises the capability;
		 *     AP:      enable short preamble capability advertisement and will
		 *              deny association to STAs that do not advertise the capability.
		 *     IBSS STA:questionable but will generally work.
		 */
		if ((val == WLC_PLCP_AUTO) || (val == WLC_PLCP_SHORT) || (val == WLC_PLCP_LONG))
			bsscfg->PLCPHdr_override = (int8) val;
		else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_RADIO:	/* use mask if don't want to expose some internal bits */
		*pval = wlc->pub->radio_disabled;
		break;

	case WLC_SET_RADIO: { /* 32 bits input, higher 16 bits are mask, lower 16 bits are value to
			       * set
			       */
		uint16 radiomask, radioval;
		uint validbits = WL_RADIO_SW_DISABLE | WL_RADIO_HW_DISABLE;
		mbool new = 0;

		radiomask = (val & 0xffff0000) >> 16;
		radioval = val & 0x0000ffff;

		if ((radiomask == 0) || (radiomask & ~validbits) || (radioval & ~validbits) ||
		    ((radioval & ~radiomask) != 0)) {
			WL_ERROR(("SET_RADIO with wrong bits 0x%x\n", val));
			bcmerror = BCME_RANGE;
			break;
		}

		new = (wlc->pub->radio_disabled & ~radiomask) | radioval;
#ifdef WLEXTLOG
		if (wlc->pub->radio_disabled != new) {
			if (!mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE) &&
			    mboolisset(new, WL_RADIO_HW_DISABLE))
				WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_HW_OFF_ID,
					WL_LOG_LEVEL_ERR, 0, 0, NULL);
			if (!mboolisset(wlc->pub->radio_disabled, WL_RADIO_SW_DISABLE) &&
			    mboolisset(new, WL_RADIO_SW_DISABLE))
				WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_SW_OFF_ID,
					WL_LOG_LEVEL_ERR, 0, 0, NULL);
			if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_HW_DISABLE) &&
			    !mboolisset(new, WL_RADIO_HW_DISABLE))
				WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_HW_ON_ID,
					WL_LOG_LEVEL_ERR, 0, 0, NULL);
			if (mboolisset(wlc->pub->radio_disabled, WL_RADIO_SW_DISABLE) &&
			    !mboolisset(new, WL_RADIO_SW_DISABLE))
				WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_RADIO_SW_ON_ID,
					WL_LOG_LEVEL_ERR, 0, 0, NULL);
		}
#endif /* WLEXTLOG */
		wlc->pub->radio_disabled = new;
		WL_MPC(("wl%d: SET_RADIO, radio_disable vector 0x%x\n", wlc->pub->unit,
			wlc->pub->radio_disabled));

		wlc_radio_hwdisable_upd(wlc);
		wlc_radio_upd(wlc);
		break;
	}

	case WLC_GET_PHYTYPE:
		*pval = WLC_PHYTYPE(wlc->band->phytype);
		break;


#ifdef BCMDBG
	/* deprecated, use wl ratesel_xxx iovar */
	case WLC_SET_RATE_PARAMS:
		bcmerror = BCME_NOTFOUND;
		break;
#endif /* BCMDBG */

	case WLC_GET_WEP_RESTRICT:
		*pval = bsscfg->wsec_restrict;
		break;

	case WLC_SET_WEP_RESTRICT:
		bsscfg->wsec_restrict = bool_val;
		break;

#if defined(BCMDBG)
	case WLC_GET_KEY:
		if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc))) {
			wl_wsec_key_t key;

			wsec_key_t *src_key = wlc->wsec_keys[val];

			if (len < (int)sizeof(key)) {
				bcmerror = BCME_BUFTOOSHORT;
				break;
			}

			bzero((char*)&key, sizeof(key));
			if (src_key) {
				key.index = src_key->id;
				key.len = src_key->len;
				bcopy(src_key->data, key.data, key.len);
				key.algo = src_key->algo;
				if (WSEC_SOFTKEY(wlc, src_key, bsscfg))
					key.flags |= WL_SOFT_KEY;
				if (src_key->flags & WSEC_PRIMARY_KEY)
					key.flags |= WL_PRIMARY_KEY;

				bcopy(src_key->ea.octet, key.ea.octet, ETHER_ADDR_LEN);
			}

			bcopy((char*)&key, arg, sizeof(key));
		} else
			bcmerror = BCME_BADKEYIDX;
		break;
#endif 

	case WLC_SET_KEY:
		bcmerror = wlc_iovar_op(wlc, "wsec_key", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

#ifdef BCMDBG
	case WLC_SET_WSEC_TEST:
		if (wlc->pub->up &&
		    ((val == WSEC_GEN_MIC_ERROR) || (val == WSEC_GEN_REPLAY) ||
		     (val == WSEC_GEN_ICV_ERROR) || (val == WSEC_GEN_MFP_ACT_ERROR) ||
		     (val == WSEC_GEN_MFP_DISASSOC_ERROR) || (val == WSEC_GEN_MFP_DEAUTH_ERROR))) {
			/* The defined variants defined pass an int denoting
			 * which test followed by a wsec_key_t.  Others may be
			 * implemented that won't have a wsec_key_t.
			 */
			bcmerror = wlc_key_set_error(wlc, val, (wl_wsec_key_t *) (((uchar*)arg)+4));
		} else
			bcmerror = BCME_RANGE;
		break;
#endif /* BCMDBG */

	case WLC_GET_KEY_SEQ: {
		wsec_key_t *key;

		if (len < DOT11_WPA_KEY_RSC_LEN) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* Return the key's tx iv as an EAPOL sequence counter.
		 * This will be used to supply the RSC value to a supplicant.
		 * The format is 8 bytes, with least significant in seq[0].
		 */
		if (MBSS_ENAB(wlc->pub)) {

			/* MBSS is on, the default keys are different from hardware
			 * default keys.
			 */

			 if ((val >= 0) || (val <= 3)) {
				val = bsscfg->bss_def_keys[val]->idx;
			}
		}

		if ((val >= 0) && (val < WLC_MAX_WSEC_KEYS(wlc)) &&
		    (key = WSEC_KEY(wlc, val)) != NULL) {
			uint8 seq[DOT11_WPA_KEY_RSC_LEN];
			uint16 lo;
			uint32 hi;
			/* group keys in WPA-NONE (IBSS only, AES and TKIP) use a global TXIV */
			if ((bsscfg->WPA_auth & WPA_AUTH_NONE) && ETHER_ISNULLADDR(&key->ea)) {
				lo = bsscfg->wpa_none_txiv.lo;
				hi = bsscfg->wpa_none_txiv.hi;
			} else {
				lo = key->txiv.lo;
				hi = key->txiv.hi;
			}

			/* format the buffer, low to high */
			seq[0] = lo & 0xff;
			seq[1] = (lo >> 8) & 0xff;
			seq[2] = hi & 0xff;
			seq[3] = (hi >> 8) & 0xff;
			seq[4] = (hi >> 16) & 0xff;
			seq[5] = (hi >> 24) & 0xff;
			seq[6] = 0;
			seq[7] = 0;

			bcopy((char*)seq, arg, sizeof(seq));
		} else {
			bcmerror = BCME_BADKEYIDX;
		}
		break;
	}

#ifdef WLLED
	case WLC_SET_LED:
		if (len < (int)sizeof(wl_led_info_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		wlc_led_set(wlc->ledh, (wl_led_info_t *)arg);
		break;
#endif

#ifdef WL11H
	case WLC_SET_SPECT_MANAGMENT:
		if ((val != SPECT_MNGMT_OFF) &&
		    (val != SPECT_MNGMT_LOOSE_11H) &&
		    (val != SPECT_MNGMT_STRICT_11H)) {
			bcmerror = BCME_RANGE;
			break;
		}

		if (wlc->_spect_management == (uint)val)
			break;

		if (wlc->pub->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}

		wlc->_spect_management = val;
		wlc_quiet_channels_reset(wlc->cmi);
		break;

	case WLC_GET_SPECT_MANAGMENT:
		*pval = wlc->_spect_management;
		if (!*pval && WL11D_ENAB(wlc))
			*pval = SPECT_MNGMT_STRICT_11D;
		break;
#endif	/* 11H */

#ifdef WL11D
	case WLC_SET_REGULATORY:

		wlc->_regulatory_domain = bool_val;

		break;

	case WLC_GET_REGULATORY:
		*pval = wlc->_regulatory_domain;
		break;
#endif /* 11D */

	case WLC_SCAN:
		WL_ASSOC(("wl%d.%d: SCAN: WLC_SCAN custom scan\n",
		          WLCWLUNIT(wlc), WLC_BSSCFG_IDX(bsscfg)));
		bcmerror = wlc_custom_scan(wlc, arg, len, 0, WLC_ACTION_SCAN, bsscfg);
		if (bcmerror) {
			if (bcmerror != BCME_NOTREADY)
				wlc->custom_scan_results_state = WL_SCAN_RESULTS_ABORTED;
		} else {
			/* invalidate results for other scan method's query */
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_ABORTED;
			wlc->custom_scan_results_state = WL_SCAN_RESULTS_PENDING;
		}

		break;

	case WLC_SCAN_RESULTS: {
		/* IO buffer has a uint32 followed by variable data.
		 * The uint32 declares the size of the buffer on input and
		 * size written on output (or required if insufficient buf space).
		 * If successful, return the bss count in uint32, followed by
		 * variable length wl_bss_info_t structs.
		 * BCME_BUFTOOSHORT is used only to indicate results were partial.
		 */
		wl_scan_results_t *iob = (wl_scan_results_t*)arg;
		int buflen;

		if ((uint)len < WL_SCAN_RESULTS_FIXED_SIZE) {
			bcmerror = BCME_BADARG;
			break;
		}

		buflen = (int)iob->buflen;

		if ((uint)buflen < WL_SCAN_RESULTS_FIXED_SIZE) {
			bcmerror = BCME_BADARG;
			break;
		}

		if (buflen > len)
			buflen = len;

		buflen -= WL_SCAN_RESULTS_FIXED_SIZE;

		bcmerror = wlc_scan_results(wlc, iob, &buflen, wlc->custom_scan_results_state);
		break;
	}

#ifdef STA
	case WLC_DISASSOC:
		if (!wlc->clk) {
			if (!mboolisset(wlc->pub->radio_disabled, WL_RADIO_MPC_DISABLE)) {
				bcmerror = BCME_NOCLK;
			}
		} else if (BSSCFG_AP(bsscfg)) {
			bcmerror = BCME_NOTSTA;
		} else {
			/* translate the WLC_DISASSOC command to disabling the config
			 * disassoc packet will be sent if currently associated
			 */
			WL_APSTA_UPDN(("wl%d: WLC_DISASSOC -> wlc_bsscfg_disable()\n",
				wlc->pub->unit));
			wlc_bsscfg_disable(wlc, bsscfg);
		}
		break;

	case WLC_REASSOC: {
		wl_reassoc_params_t reassoc_params;
		wl_reassoc_params_t *params;

		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		if ((uint)len < ETHER_ADDR_LEN) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		if ((uint)len >= WL_REASSOC_PARAMS_FIXED_SIZE) {
			params = (wl_reassoc_params_t *)arg;
			if ((uint)len < WL_REASSOC_PARAMS_FIXED_SIZE +
			    params->chanspec_num * sizeof(chanspec_t)) {
				bcmerror = BCME_BUFTOOSHORT;
				break;
			}
			bcmerror = wlc_assoc_chanspec_sanitize(wlc, params->chanspec_list,
			                                      params->chanspec_num);
			if (bcmerror != BCME_OK)
				break;
		}
		else {
			bcopy((void *)arg, (void *)&reassoc_params.bssid, ETHER_ADDR_LEN);
			/* scan on all channels */
			reassoc_params.chanspec_num = 0;
			params = &reassoc_params;
		}

		if ((bcmerror = wlc_reassoc(bsscfg, params)) != 0)
			WL_ERROR(("%s: wlc_reassoc fails (%d)\n", __FUNCTION__, bcmerror));
		break;
	}

	case WLC_GET_ROAM_TRIGGER:
		/* bcmerror checking */
		if ((bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE)))
			break;

		if (band == WLC_BAND_ALL) {
			bcmerror = BCME_BADOPTION;
			break;
		}

		*pval = wlc->band->roam_trigger;
		break;

	case WLC_SET_ROAM_TRIGGER: {
		int trigger_dbm;

		/* bcmerror checking */
		if ((bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE)))
			break;

		if ((val < -100) || (val > WLC_ROAM_TRIGGER_MAX_VALUE)) {
			bcmerror = BCME_RANGE;
			break;
		}

		/* roam_trigger is either specified as dBm (-1 to -99 dBm) or a
		 * logical value >= 0
		 */
		trigger_dbm = (val < 0) ? val : wlc_roam_trigger_logical_dbm(wlc, wlc->band, val);
		wlc->band->roam_trigger_def = trigger_dbm;
		wlc->band->roam_trigger = trigger_dbm;

		/* if multiband and band is ALL, apply to all bands */
		if ((band == WLC_BAND_ALL) && (NBANDS(wlc) > 1)) {
			trigger_dbm = (val < 0) ? val : wlc_roam_trigger_logical_dbm(wlc,
				wlc->bandstate[OTHERBANDUNIT(wlc)], val);
			wlc->bandstate[OTHERBANDUNIT(wlc)]->roam_trigger_def = trigger_dbm;
			wlc->bandstate[OTHERBANDUNIT(wlc)]->roam_trigger = trigger_dbm;
		}

		break;
	}

	case WLC_GET_ROAM_DELTA:
		/* bcmerror checking */
		if ((bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE)))
			break;

		if (band == WLC_BAND_ALL) {
			bcmerror = BCME_BADOPTION;
			break;
		}

		*pval = wlc->band->roam_delta;
		break;

	case WLC_SET_ROAM_DELTA:
		/* bcmerror checking */
		if ((bcmerror = wlc_iocbandchk(wlc, (int*)arg, len, &band, FALSE)))
			break;

		if ((val > 100) || (val < 0)) {
			bcmerror = BCME_BADOPTION;
			break;
		}

		wlc->band->roam_delta_def = val;
		wlc->band->roam_delta = val;

		/* if multiband and band is ALL, apply to all bands */
		if ((band == WLC_BAND_ALL) && (NBANDS(wlc) > 1)) {
			wlc->bandstate[OTHERBANDUNIT(wlc)]->roam_delta_def = val;
			wlc->bandstate[OTHERBANDUNIT(wlc)]->roam_delta = val;
		}

		break;

	case WLC_GET_ROAM_SCAN_PERIOD:
		*pval = roam->partialscan_period;
		break;

	case WLC_SET_ROAM_SCAN_PERIOD:
		roam->partialscan_period = val;
		break;
#endif /* STA */

	case WLC_GET_CLOSED:
		*pval = bsscfg->closednet_nobcnssid;
		break;

	case WLC_SET_CLOSED:
		bcmerror = wlc_iovar_op(wlc, "closednet", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

	case WLC_GET_MACLIST:
		maclist = (struct maclist *) arg;
		if (len < (int)((bsscfg->nmac -1) * sizeof(struct ether_addr)
			+ sizeof(struct maclist))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		maclist->count = bsscfg->nmac;
		bcopy((void*)bsscfg->maclist, (void*)maclist->ea, bsscfg->nmac * ETHER_ADDR_LEN);
		break;

	case WLC_SET_MACLIST:
		maclist = (struct maclist *) arg;
		if (maclist->count > MAXMACLIST) {
			bcmerror = BCME_RANGE;
			break;
		}

		if (len < (int)(OFFSETOF(struct maclist, ea) + maclist->count * ETHER_ADDR_LEN)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* free the old one */
		if (bsscfg->maclist) {
			MFREE(wlc->osh, bsscfg->maclist,
			      (int)(OFFSETOF(struct maclist, ea) + bsscfg->nmac * ETHER_ADDR_LEN));
			bsscfg->nmac = 0;
		}
		if (!(bsscfg->maclist = MALLOC(wlc->osh,
			(int)(OFFSETOF(struct maclist, ea) + maclist->count * ETHER_ADDR_LEN)))) {
			WL_ERROR(("wl%d: out of memory, malloced %d bytes\n",
			          wlc->pub->unit, MALLOCED(wlc->osh)));
			bcmerror = BCME_NOMEM;
			break;
		}
		bsscfg->nmac = maclist->count;
		bcopy((void*)maclist->ea, (void*)bsscfg->maclist, bsscfg->nmac * ETHER_ADDR_LEN);
		break;

	case WLC_GET_MACMODE:
		*pval = bsscfg->macmode;
		break;

	case WLC_SET_MACMODE:
		WL_INFORM(("Setting mac mode to %d %s\n", val,
			val == 0  ? "disabled" : val == 1 ? "deny" : "allow"));
		bsscfg->macmode = val;
		break;

	case WLC_GET_CURR_RATESET: {
		wl_rateset_t *ret_rs = (wl_rateset_t *)arg;
		wlc_rateset_t *rs;

		if (bsscfg->associated)
			rs = &current_bss->rateset;
		else
			rs = &wlc->default_bss->rateset;

		if (len < (int)(rs->count + sizeof(rs->count))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* Copy only legacy rateset section */
		ret_rs->count = rs->count;
		bcopy(&rs->rates, &ret_rs->rates, rs->count);
		break;
	}

	case WLC_GET_RATESET: {
		wlc_rateset_t rs;
		wl_rateset_t *ret_rs = (wl_rateset_t *)arg;

		bzero(&rs, sizeof(wlc_rateset_t));
		wlc_default_rateset(wlc, (wlc_rateset_t*)&rs);

		if (len < (int)(rs.count + sizeof(rs.count))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* Copy only legacy rateset section */
		ret_rs->count = rs.count;
		bcopy(&rs.rates, &ret_rs->rates, rs.count);
		break;
	}

	case WLC_SET_RATESET: {
		wlc_rateset_t rs;
		wl_rateset_t *in_rs = (wl_rateset_t *)arg;

		if (len < (int)(in_rs->count + sizeof(in_rs->count))) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		if (in_rs->count > WLC_NUMRATES) {
			bcmerror = BCME_BUFTOOLONG;
			break;
		}

		bzero(&rs, sizeof(wlc_rateset_t));

		/* Copy only legacy rateset section */
		rs.count = in_rs->count;
		bcopy(&in_rs->rates, &rs.rates, rs.count);

		/* merge rateset coming in with the current mcsset */
		if (N_ENAB(wlc->pub)) {
			if (bsscfg->associated)
				bcopy(&current_bss->rateset.mcs[0], rs.mcs, MCSSET_LEN);
			else
				bcopy(&wlc->default_bss->rateset.mcs[0], rs.mcs, MCSSET_LEN);
		}

		bcmerror = wlc_set_rateset(wlc, &rs);

		if (!bcmerror)
			wlc_ofdm_rateset_war(wlc);

		break;
	}


	case WLC_GET_BCNPRD:
#ifdef STA
		if (BSSCFG_STA(bsscfg) && bsscfg->BSS && bsscfg->associated)
			*pval = current_bss->beacon_period;
		else
#endif
			*pval = wlc->default_bss->beacon_period;
		break;

	case WLC_SET_BCNPRD:
		/* range [1, 0xffff] */
		if (val >= DOT11_MIN_BEACON_PERIOD && val <= DOT11_MAX_BEACON_PERIOD) {
			wlc->default_bss->beacon_period = (uint16) val;
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_DTIMPRD:
#ifdef STA
		if (BSSCFG_STA(bsscfg) && bsscfg->BSS && bsscfg->associated)
			*pval = current_bss->dtim_period;
		else
#endif
			*pval = wlc->default_bss->dtim_period;
		break;

	case WLC_SET_DTIMPRD:
		/* range [1, 0xff] */
		if (val >= DOT11_MIN_DTIM_PERIOD && val <= DOT11_MAX_DTIM_PERIOD) {
			wlc->default_bss->dtim_period = (uint8)val;
		} else
			bcmerror = BCME_RANGE;
		break;

	case WLC_GET_SROM: {
		srom_rw_t *s = (srom_rw_t *)arg;
		if (s->byteoff == 0x55ab) {	/* Hack for srcrc */
			s->byteoff = 0;
			bcmerror = wlc_iovar_op(wlc, "srcrc", arg, len, arg, len, IOV_GET, wlcif);
		} else
			bcmerror = wlc_iovar_op(wlc, "srom", arg, len, arg, len, IOV_GET, wlcif);
		break;
	}

#if defined(BCMDBG) || defined(WLTEST)
	case WLC_SET_SROM: {
		bcmerror = wlc_iovar_op(wlc, "srom", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

	}
#endif	

#ifdef STA
	case WLC_GET_PM:
		*pval = pm->PM;
		break;

	case WLC_SET_PM:
		/* save host requested pmstate */
		wlc->btch->host_requested_pm = (uint8)val;
		if (val == PM_FORCE_OFF) {
			val = PM_OFF;
		} else {
			if (wlc->btch->bth_active && (PM_OFF == val))
				val = PM_FAST;
		}

		bcmerror = wlc_set_pm_mode(wlc, val, bsscfg);

		break;

#ifdef BCMDBG
	case WLC_GET_WAKE:
		*pval = wlc->wake;
		break;

	case WLC_SET_WAKE:
		WL_PS(("wl%d: setting WAKE to %d\n", WLCWLUNIT(wlc), val));
		wlc->wake = val ? TRUE : FALSE;

		/* apply to the mac */
		wlc_set_wake_ctrl(wlc);
		break;
#endif /* BCMDBG */
#endif /* STA */


	case WLC_GET_REVINFO:
		bcmerror = wlc_get_revision_info(wlc, arg, (uint)len);
		break;

	case WLC_SET_AP: {
	        bool wasup = wlc->pub->up;
#ifndef AP
	        if (val)
	                bcmerror = BCME_NOTAP;
#endif /* AP */
#ifndef STA
	        if (!val)
	                bcmerror = BCME_NOTSTA;
#endif /* STA */
	        /* APSTA mode takes precedence */
	        if (APSTA_ENAB(wlc->pub) && !val)
	                bcmerror = BCME_EPERM;


	        if (bcmerror || (AP_ENAB(wlc->pub) == bool_val))
	                break;

	        if (wasup) {
	                WL_APSTA_UPDN(("wl%d: WLC_SET_AP -> wl_down()\n", wlc->pub->unit));
	                wl_down(wlc->wl);
	        }

	        wlc->pub->_ap = bool_val;
		wlc_bsscfg_reinit(wlc, bsscfg, bool_val);


	        wlc_ap_upd(wlc, bsscfg);

	        /* always turn off WET when switching mode */
	        wlc->wet = FALSE;
	        /* always turn off MAC_SPOOF when switching mode */
	        wlc->mac_spoof = FALSE;

	        if (wasup) {
	                WL_APSTA_UPDN(("wl%d: WLC_SET_AP -> wl_up()\n", wlc->pub->unit));
	                bcmerror = wl_up(wlc->wl);
	        }
#ifdef STA
	        wlc_radio_mpc_upd(wlc);
#endif /* STA */
	        break;
	}

	case WLC_GET_AP:
	        *pval = (int)AP_ENAB(wlc->pub);
	        break;

	case WLC_GET_EAP_RESTRICT:
		bcmerror = wlc_iovar_op(wlc, "eap_restrict", NULL, 0, arg, len, IOV_GET, wlcif);
		break;

	case WLC_SET_EAP_RESTRICT:
		bcmerror = wlc_iovar_op(wlc, "eap_restrict", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

	case WLC_SCB_DEAUTHENTICATE:
		/* Supply a reason in val */
		val = DOT11_RC_INACTIVITY;
	case WLC_SCB_DEAUTHENTICATE_FOR_REASON:
		if (cmd == WLC_SCB_DEAUTHENTICATE_FOR_REASON) {
			/* point arg at MAC addr */
			if (len < (int)sizeof(scb_val_t)) {
				bcmerror = BCME_BUFTOOSHORT;
				break;
			}
			arg = &((scb_val_t *)arg)->ea;
			/* reason stays in `val' */
		}
#ifdef STA
		if (BSSCFG_STA(bsscfg)) {
			struct ether_addr *apmac = (struct ether_addr *)arg;
			if (ETHER_ISMULTI(apmac)) {
				WL_ERROR(("wl%d: bc/mc deauth%s on STA BSS?\n", wlc->pub->unit,
					(cmd == WLC_SCB_DEAUTHENTICATE) ? "" : "_reason"));
				apmac = &bsscfg->BSSID;
			} else if ((scb = wlc_scbfind(wlc, (struct ether_addr *)arg)) &&
			    (scb->flags & SCB_MYAP))
				wlc_scb_resetstate(scb);
			if (bsscfg->BSS) {
				wlc_disassociate_client(bsscfg, FALSE, NULL, NULL);
				if (scb)
					(void)wlc_senddeauth(wlc, apmac, apmac,
					                     &bsscfg->cur_etheraddr,
					                     scb, (uint16)val);
				WL_APSTA_UPDN(("wl%d: SCB DEAUTH: wlc_bsscfg_disable()\n",
				            wlc->pub->unit));
				wlc_bsscfg_disable(wlc, bsscfg);
			}
#if defined(IBSS_PEER_MGMT)
			else if (IBSS_PEER_MGMT_ENAB(wlc->pub)) {
				(void)wlc_senddeauth(wlc, arg, &bsscfg->BSSID,
				                     &bsscfg->cur_etheraddr,
				                     scb, (uint16)val);
				if (scb) {
					wlc_scb_disassoc_cleanup(wlc, scb);
					SCB_UNSET_IBSS_PEER(scb);
				}
			}
#endif /* defined(IBSS_PEER_MGMT) */
			break;
		}
#endif /* STA */
		/* fall thru */
	case WLC_SCB_AUTHORIZE:
	case WLC_SCB_DEAUTHORIZE: {
		uint32 flag;
		int rc = val;
		bool enable = (cmd == WLC_SCB_AUTHORIZE);

		if (cmd == WLC_SCB_AUTHORIZE || cmd == WLC_SCB_DEAUTHORIZE)
			flag = AUTHORIZED;
		else
			flag = AUTHENTICATED;

		/* (de)authorize/authenticate all stations in this BSS */
		if (ETHER_ISBCAST(arg)) {

			FOREACHSCB(wlc->scbstate, &scbiter, scb) {
				/* skip if the scb is not valid or is WDS */
				if (SCB_WDS(scb))
					continue;

				/* skip if the scb is in a different BSS */
				if (scb->bsscfg != bsscfg)
					continue;

				/* don't authorize an unassociated scb */
				if (flag == AUTHORIZED && !SCB_ASSOCIATED(scb))
					continue;

				/* don't deauthenticate an unauthenticated scb */
				if (flag == AUTHENTICATED && !SCB_AUTHENTICATED(scb))
					continue;

				wlc_scb_set_auth(wlc, bsscfg, scb, enable, flag, rc);
#ifdef MFP
				if (SCB_AMPDU(scb))
					wlc_ampdu_agg_state_update_tx(wlc, ON);
#endif
			}
		}
		/* (de)authorize/authenticate a single station */
		else if ((scb = wlc_scbfind(wlc, (struct ether_addr *) arg))) {
#ifdef BCMDBG
			if (scb->bsscfg != bsscfg) {
				const char *cmdname;
				char eabuf[ETHER_ADDR_STR_LEN];
				if (cmd == WLC_SCB_AUTHORIZE)
					cmdname = "WLC_SCB_AUTHORIZE";
				else if (cmd == WLC_SCB_DEAUTHORIZE)
					cmdname = "WLC_SCB_DEAUTHORIZE";
				else if (cmd == WLC_SCB_DEAUTHENTICATE)
					cmdname = "WLC_SCB_DEAUTHENTICATE";
				else cmdname = "WLC_SCB_DEAUTHENTICATE_FOR_REASON";
				WL_WSEC(("wl%d: %s on i/f %s for non-local scb %s\n",
					wlc->pub->unit, cmdname, wl_ifname(wlc->wl, wlcif->wlif),
					bcm_ether_ntoa((struct ether_addr*)arg, eabuf)));
			}
#endif /* BCMDBG */
			wlc_scb_set_auth(wlc, bsscfg, scb, enable, flag, rc);
#ifdef WLBTAMP
			if (BSS_BTA_ENAB(wlc, bsscfg) && (cmd == WLC_SCB_AUTHORIZE)) {
				wlc_bta_AKM_complete(wlc->bta, scb);
			}
#endif /* WLBTAMP */

		}
	}
		break;

#ifdef STA
	case WLC_GET_ATIM:
		if (bsscfg->associated)
			*pval = (int) current_bss->atim_window;
		else
			*pval = (int) wlc->default_bss->atim_window;
		break;

	case WLC_SET_ATIM:
		wlc->default_bss->atim_window = (uint32) val;
		break;
#endif /* STA */

	case WLC_GET_RSSI:
		if (!scb_val) {
			bcmerror = BCME_BADARG;
			break;
		}

		if (len == sizeof(scb_val_t)) {
			/* User *possibly* provided a MAC address to use for STA specific RSSI */
			if (!ETHER_ISMULTI(&scb_val->ea)) {
				scb = wlc_scbfind(wlc, &scb_val->ea);
				if (scb) {
					/* enable per-scb collection on first request */
					wlc->scbrssi = TRUE;
					scb_val->val = wlc_scb_rssi(scb);
				} else if (BSSCFG_AP(bsscfg)) {
					bcmerror = BCME_NOTFOUND;
					break;
				} else {
					/* IBSS or STA */
					scb_val->val = bsscfg->link->rssi;
					break;
				}
			} else {
				/* User isn't allowed to ask for RSSI for Multicast address */
				bcmerror = BCME_BADARG;
				break;
			}
		} else if ((len == sizeof(int)) && (BSSCFG_STA(bsscfg))) {
			/* User may have asked for bsscfg->link->rssi with an int sized buff */
			/* IBSS or STA */
			scb_val->val = bsscfg->link->rssi;
		} else {
			bcmerror = BCME_BADARG;
			break;
		}
		break;

	case WLC_GET_PKTCNTS: {
		get_pktcnt_t *pktcnt = (get_pktcnt_t*)pval;
		if (WLC_UPDATE_STATS(wlc))
			wlc_statsupd(wlc);
		pktcnt->rx_good_pkt = WLCNTVAL(wlc->pub->_cnt->rxframe);
		pktcnt->rx_bad_pkt = WLCNTVAL(wlc->pub->_cnt->rxerror);
		pktcnt->tx_good_pkt = WLCNTVAL(wlc->pub->_cnt->txfrmsnt);
		pktcnt->tx_bad_pkt = WLCNTVAL(wlc->pub->_cnt->txerror) +
			WLCNTVAL(wlc->pub->_cnt->txfail);
		if (len >= (int)sizeof(get_pktcnt_t)) {
			/* Be backward compatible - only if buffer is large enough  */
			pktcnt->rx_ocast_good_pkt = WLCNTVAL(wlc->pub->_cnt->rxmfrmocast);
		}
		break;
	}

	case WLC_GET_WSEC:
		bcmerror = wlc_iovar_op(wlc, "wsec", NULL, 0, arg, len, IOV_GET, wlcif);
		break;

	case WLC_SET_WSEC:
		bcmerror = wlc_iovar_op(wlc, "wsec", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

	case WLC_GET_WPA_AUTH:
		*pval = (int) bsscfg->WPA_auth;
		break;

	case WLC_SET_WPA_AUTH:
		bcmerror = wlc_iovar_op(wlc, "wpa_auth", NULL, 0, arg, len, IOV_SET, wlcif);
		break;

	case WLC_GET_BSS_INFO: {
		wl_bss_info_t *wl_bi;
		int datalen = sizeof(uint32) + sizeof(wl_bss_info_t);
#ifdef STA
		wlc_link_qual_t *link = bsscfg->link;
#endif
		if (val < datalen) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* Update the noise value of the current_bss structure */
		current_bss->phy_noise = wlc_phy_noise_avg((wlc_phy_t *)wlc->band->pi);
#ifdef STA
		current_bss->RSSI = (int16)link->rssi;
#endif

		/* convert the wlc_bss_info_t, writing into buffer */
		wl_bi = (wl_bss_info_t*)((char*)arg + sizeof(uint32));
		wlc_bss2wl_bss(wlc, current_bss, wl_bi, val - sizeof(uint32), FALSE);
		/* If the requested BSS config is an AP, get the SSID and BSSID
		 * from that configuration
		 */
		*pval = (int)datalen + wl_bi->ie_length; /* byte count for return */

		if (BSSCFG_AP(bsscfg)) {
			bzero(wl_bi->SSID, sizeof(wl_bi->SSID));
			wl_bi->SSID_len	= bsscfg->SSID_len;
			bcopy(bsscfg->SSID, wl_bi->SSID, wl_bi->SSID_len);
			bcopy(&bsscfg->BSSID, &wl_bi->BSSID, sizeof(wl_bi->BSSID));
		}
		break;
	}

	case WLC_GET_BANDLIST:
		/* count of number of bands, followed by each band type */
		*pval++ = NBANDS(wlc);
		*pval++ = wlc->band->bandtype;
		if (NBANDS(wlc) > 1)
			*pval++ = wlc->bandstate[OTHERBANDUNIT(wlc)]->bandtype;
			break;

	case WLC_GET_BAND:
		*pval = wlc->bandlocked ? wlc->band->bandtype : WLC_BAND_AUTO;
		break;

	case WLC_SET_BAND:
		bcmerror = wlc_bandlock(wlc, (uint)val);
		break;

	case WLC_GET_PHYLIST:
	{
		uchar *cp = arg;
		uint phy_type;

		if (len < 3) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		if (NBANDS(wlc) == 1) {
			phy_type = wlc->band->phytype;
			*cp++ = (phy_type == PHY_TYPE_A) ? 'a' :
				(phy_type == PHY_TYPE_G) ? 'g' :
			        (phy_type == PHY_TYPE_LP) ? 'l' :
			        (phy_type == PHY_TYPE_N) ? 'n' :
				(phy_type == PHY_TYPE_HT) ? 'h' :
			        (phy_type == PHY_TYPE_LCN) ? 'c' :
				'?';
		} else if (WLCISHTPHY(wlc->band)) {
			*cp++ = 'h';
		} else if (WLCISNPHY(wlc->band)) {
			*cp++ = 'n';
		} else if (WLCISLPPHY(wlc->band)) {
			*cp++ = 'l';
		} else if (WLCISSSLPNPHY(wlc->band)) {
			*cp++ = 's';
		} else if (WLCISLCNPHY(wlc->band)) {
			*cp++ = 'c';
		} else {
			*cp++ = 'g';
			*cp++ = 'a';
		}
		*cp = '\0';
		break;
	}

	case WLC_GET_SHORTSLOT:
		*pval = wlc->shortslot;
		break;

	case WLC_GET_SHORTSLOT_OVERRIDE:
		*pval = wlc->shortslot_override;
		break;

	case WLC_SET_SHORTSLOT_OVERRIDE:
		if ((val != WLC_SHORTSLOT_AUTO) &&
		    (val != WLC_SHORTSLOT_OFF) &&
		    (val != WLC_SHORTSLOT_ON)) {
			bcmerror = BCME_RANGE;
			break;
		}

		wlc->shortslot_override = (int8)val;

		/* shortslot is an 11g feature, so no more work if we are
		 * currently on the 5G band
		 */
		if (BAND_5G(wlc->band->bandtype))
			break;

		if (wlc->pub->up && wlc->pub->associated) {
			/* let watchdog or beacon processing update shortslot */
		} else if (wlc->pub->up) {
			/* unassociated shortslot is off */
			wlc_switch_shortslot(wlc, FALSE);
		} else {
			/* driver is down, so just update the wlc_info value */
			if (wlc->shortslot_override == WLC_SHORTSLOT_AUTO) {
				wlc->shortslot = FALSE;
			} else {
				wlc->shortslot = (wlc->shortslot_override == WLC_SHORTSLOT_ON);
			}
		}

		break;

	case WLC_GET_LEGACY_ERP:
		*pval = prot->include_legacy_erp;
		break;

	case WLC_SET_LEGACY_ERP:
		if (prot->include_legacy_erp == bool_val)
			break;

		prot->include_legacy_erp = bool_val;

		if (BSSCFG_AP(bsscfg) && wlc->clk) {
			WL_APSTA_BCN(("wl%d: WLC_SET_LEGACY_ERP -> wlc_update_beacon()\n",
				wlc->pub->unit));
			wlc_bss_update_beacon(wlc, bsscfg);
			wlc_bss_update_probe_resp(wlc, bsscfg, TRUE);
		}
		break;

	case WLC_GET_GMODE:
		if (wlc->band->bandtype == WLC_BAND_2G)
			*pval = wlc->band->gmode;
		else if (NBANDS(wlc) > 1)
			*pval = wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode;
		break;

	case WLC_SET_GMODE:
		if (!wlc->pub->associated)
			bcmerror = wlc_set_gmode(wlc, (uint8)val, TRUE);
		else {
			bcmerror = BCME_ASSOCIATED;
			break;
		}
		break;

	case WLC_GET_GMODE_PROTECTION:
		*pval = prot->_g;
		break;

	case WLC_GET_PROTECTION_CONTROL:
		*pval = prot->overlap;
		break;

	case WLC_SET_PROTECTION_CONTROL:
		if ((val != WLC_PROTECTION_CTL_OFF) &&
		    (val != WLC_PROTECTION_CTL_LOCAL) &&
		    (val != WLC_PROTECTION_CTL_OVERLAP)) {
			bcmerror = BCME_RANGE;
			break;
		}

		wlc_protection_upd(bsscfg, WLC_PROT_OVERLAP, (int8)val);

		/* Current g_protection will sync up to the specified control alg in watchdog
		 * if the driver is up and associated.
		 * If the driver is down or not associated, the control setting has no effect.
		 */
		break;

	case WLC_GET_GMODE_PROTECTION_OVERRIDE:
		*pval = prot->g_override;
		break;

	case WLC_SET_GMODE_PROTECTION_OVERRIDE:
		if ((val != WLC_PROTECTION_AUTO) &&
		    (val != WLC_PROTECTION_OFF) &&
		    (val != WLC_PROTECTION_ON)) {
			bcmerror = BCME_RANGE;
			break;
		}

		wlc_protection_upd(bsscfg, WLC_PROT_G_OVR, (int8)val);

		if (!WLCISGPHY(wlc->band))
			break;

		if (bsscfg->associated) {
			/* let watchdog or beacon processing update protection */
		} else {
			wlc_protection_g_sync(bsscfg);
		}

		break;

	case WLC_SET_SUP_RATESET_OVERRIDE: {
		wlc_rateset_t rs, new;

		/* copyin */
		if (len < (int)sizeof(wl_rateset_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		ASSERT(sizeof(wl_rateset_t) <= sizeof(wlc_rateset_t));

		bzero(&rs, sizeof(wlc_rateset_t));
		bcopy((char*)arg, (char*)&rs, sizeof(wl_rateset_t));

		/* check for bad count value */
		if (rs.count > WLC_NUMRATES) {
			bcmerror = BCME_BADRATESET;	/* invalid rateset */
			break;
		}

		/* this command is only appropriate for gmode operation */
		if (!(wlc->band->gmode ||
		      ((NBANDS(wlc) > 1) && wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode))) {
			bcmerror = BCME_BADBAND;	/* gmode only command when not in gmode */
			break;
		}

		/* check for an empty rateset to clear the override */
		if (rs.count == 0) {
			bzero(&wlc->sup_rates_override, sizeof(wlc_rateset_t));
			break;
		}

		bzero(&new, sizeof(wlc_rateset_t));
		/* validate rateset by comparing pre and post sorted against 11g hw rates */
		wlc_rateset_filter(&rs, &new, FALSE, WLC_RATES_CCK_OFDM, RATE_MASK,
		                   N_ENAB(wlc->pub));
		wlc_rate_hwrs_filter_sort_validate(&new, &cck_ofdm_rates, FALSE,
			wlc->stf->txstreams);
		if (rs.count != new.count) {
			bcmerror = BCME_BADRATESET;	/* invalid rateset */
			break;
		}

		/* apply new rateset to the override */
		bcopy((char*)&new, (char*)&wlc->sup_rates_override, sizeof(wlc_rateset_t));

		/* update bcn and probe resp if needed */
		if (wlc->pub->up && AP_ENAB(wlc->pub) && wlc->pub->associated) {
			WL_APSTA_BCN(("wl%d: Calling update from SET_SUP_RATESET_OVERRIDE\n",
			            WLCWLUNIT(wlc)));
			WL_APSTA_BCN(("wl%d: SET_SUP_RATESET_OVERRIDE -> wlc_update_beacon()\n",
			            WLCWLUNIT(wlc)));
			wlc_update_beacon(wlc);
			wlc_update_probe_resp(wlc, TRUE);
		}
		break;
	}

	case WLC_GET_SUP_RATESET_OVERRIDE:
		/* this command is only appropriate for gmode operation */
		if (!(wlc->band->gmode ||
		      ((NBANDS(wlc) > 1) && wlc->bandstate[OTHERBANDUNIT(wlc)]->gmode))) {
			bcmerror = BCME_BADBAND;	/* gmode only command when not in gmode */
			break;
		}
		if (len < (int)sizeof(wl_rateset_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy((char*)&wlc->sup_rates_override, (char*)arg, sizeof(wl_rateset_t));

		break;

#ifdef STA
	case WLC_SET_ASSOC_PREFER:
		if (!VALID_BAND(wlc, val)) {
			bcmerror = BCME_BADBAND; /* bad value */
			break;
		}
		bsscfg->join_pref->band = (uint8)val;
		wlc_join_pref_band_upd(bsscfg);
		break;

	case WLC_GET_ASSOC_PREFER:
		*pval = bsscfg->join_pref->band;
		break;

#endif /* STA */
	case WLC_GET_PRB_RESP_TIMEOUT:
		*pval = wlc->prb_resp_timeout;
		break;

	case WLC_SET_PRB_RESP_TIMEOUT:
		if (wlc->pub->up) {
			bcmerror = BCME_NOTDOWN;
			break;
		}
		if (val < 0 || val >= 0xFFFF) {
			bcmerror = BCME_RANGE; /* bad value */
			break;
		}
		wlc->prb_resp_timeout = (uint16)val;
		break;

#ifndef OPENSRC_IOV_IOCTL
	case WLC_SET_COUNTRY: {
		char country_abbrev[WLC_CNTRY_BUF_SZ];
		int slen;

		/* find strlen, with string either null terminated or 'len' terminated */
		for (slen = 0; slen < len && ((char*)arg)[slen] != '\0'; slen++)
			;
		if (slen >= WLC_CNTRY_BUF_SZ) {
			bcmerror = BCME_BUFTOOLONG;
			break;
		}

		/* copy country code from arg avoiding overruns and null terminating */
		bzero(country_abbrev, WLC_CNTRY_BUF_SZ);
		strncpy(country_abbrev, (char*)arg, slen);

		bcmerror = wlc_set_countrycode(wlc->cmi, country_abbrev);
		if (bcmerror)
			break;

		/* the country setting may have changed our radio state */
		wlc_radio_upd(wlc);

		/* save default country for exiting 11d regulatory mode */
		strncpy(wlc->country_default, country_abbrev, WLC_CNTRY_BUF_SZ - 1);
#ifdef STA
		/* setting the country ends the search for country info */
		wlc->awaiting_cntry_info = FALSE;
#endif
		break;
	}
#endif /* OPENSRC_IOV_IOCTL */

	case WLC_GET_COUNTRY:
		if (len < WLC_CNTRY_BUF_SZ) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(wlc_channel_country_abbrev(wlc->cmi), (char*)arg, WLC_CNTRY_BUF_SZ);
		break;


#ifdef WLCQ
	case WLC_GET_CHANNEL_QA:
		*pval = wlc->channel_quality;
		break;

	case WLC_START_CHANNEL_QA:
		if (!wlc->pub->up) {
			bcmerror = BCME_NOTUP;
			break;
		}

		if (!WLCISGPHY(wlc->band) && !WLCISNPHY(wlc->band)) {
			bcmerror = BCME_BADBAND;
			break;
		}

		bcmerror = wlc_lq_channel_qa_start(wlc);
		break;
#endif /* WLCQ */

	/* NOTE that this only returns valid 20MHZ channels */
	case WLC_GET_VALID_CHANNELS: {
		wl_uint32_list_t *list = (wl_uint32_list_t *)arg;
		uint8 channels[MAXCHANNEL];
		uint count;

		/* make sure the io buffer has at least room for a uint32 count */
		if (len < (int)sizeof(uint32)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		/* trim count to the buffer size in case it is bogus */
		if (list->count > (len - sizeof(uint32))/sizeof(uint32))
			list->count = (len - sizeof(uint32))/sizeof(uint32);

		/* find all valid channels */
		count = 0;
		for (i = 0; i < MAXCHANNEL; i++) {
			if (wlc_valid_chanspec_db(wlc->cmi, CH20MHZ_CHSPEC(i)))
				channels[count++] = (uint8)i;
		}

		/* check for buffer size */
		if (list->count < count) {
			/* too short, need this much */
			list->count = count;
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}

		/* return the valid channels */
		for (i = 0; i < count; i++) {
			list->element[i] = channels[i];
		}
		list->count = count;
		break;
	}

	case WLC_GET_CHANNELS_IN_COUNTRY:
		bcmerror = wlc_get_channels_in_country(wlc, arg);
		break;

	case WLC_GET_COUNTRY_LIST:
		bcmerror = wlc_get_country_list(wlc, arg);
		break;

	case WLC_GET_FAKEFRAG:
		*pval = wlc->frameburst;
		break;

	case WLC_SET_FAKEFRAG:
		wlc->frameburst = bool_val;
#ifdef WLAFTERBURNER
		wlc_frameburst_size(wlc, wlc->afterburner);
#else
		wlc_frameburst_size(wlc, FALSE);
#endif /* WLAFTERBURNER */
		break;

	case WLC_SET_BAD_FRAME_PREEMPT:
		wlc->pub->bf_preempt_4306 = bool_val;
		wlc_phy_bf_preempt_enable(wlc->band->pi, bool_val);
		break;

	case WLC_GET_BAD_FRAME_PREEMPT:
		*pval = wlc->pub->bf_preempt_4306 ? 1 : 0;
		break;


#ifdef WET
	case WLC_GET_WET:
		bcmerror = wlc_iovar_op(wlc, "wet", NULL, 0, arg, len, IOV_GET, wlcif);
		break;

	case WLC_SET_WET:
		bcmerror = AP_ONLY(wlc->pub) ?
		        BCME_BADARG :
		        wlc_iovar_op(wlc, "wet", NULL, 0, arg, len, IOV_SET, wlcif);
		break;
#endif	/* WET */

	case WLC_GET_PUB:
		*pval = (int)(uintptr)wlc->pub;
		break;

	case WLC_GET_KEY_PRIMARY: {
		wsec_key_t *key;

		/* treat the 'val' parm as the key id */
		if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
			*pval = key->id == val ? TRUE : FALSE;
		} else {
			bcmerror = BCME_BADKEYIDX;
		}
		break;
	}

	case WLC_SET_KEY_PRIMARY: {
		wsec_key_t *key, *old_key;

		bcmerror = BCME_BADKEYIDX;

		/* treat the 'val' parm as the key id */
		for (i = 0; i < WSEC_MAX_DEFAULT_KEYS; i ++) {
			if ((key = bsscfg->bss_def_keys[i]) != NULL &&
			    key->id == val) {
				if ((old_key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL)
					old_key->flags &= ~WSEC_PRIMARY_KEY;
				key->flags |= WSEC_PRIMARY_KEY;
				bsscfg->wsec_index = i;
				bcmerror = BCME_OK;
			}
		}
		break;
	}

#ifdef WL11H
	case WLC_SEND_QUIET: {
		wlc_csa_t *csa = bsscfg->csa;

		if (!BSSCFG_AP(bsscfg)) {
			bcmerror = BCME_NOTAP;
			break;
		}
		if (!wlc->clk) {
			bcmerror = BCME_NOCLK;
			break;
		}
#ifdef RADIO_PWRSAVE
		/*
		 * Check for radio power save feature enabled
		 */
		if (RADIO_PWRSAVE_ENAB(wlc->ap)) {
			WL_ERROR(("Please disable Radio Power Save feature using"
			          "radio_pwrsave_enable IOVAR"
			          "to continue with quiet IE testing\n"));
			bcmerror = BCME_ERROR;
			break;
		}
#endif

		if (len < (int)sizeof(dot11_quiet_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(arg, (char *)&csa->quiet_cmd, sizeof(dot11_quiet_t));
		WL_REGULATORY(("wl%d: Quiet ioctl: count %d, dur %d, offset %d\n",
		               WLCWLUNIT(wlc), csa->quiet_cmd.count,
		               csa->quiet_cmd.duration, csa->quiet_cmd.offset));
		csa->spect_state |= NEED_TO_UPDATE_BCN;
		WL_APSTA_BCN(("wl%d: WLC_SEND_QUIET -> wlc_update_beacon()\n",
		              wlc->pub->unit));
		wlc_bss_update_beacon(wlc, bsscfg);
		wlc_bss_update_probe_resp(wlc, bsscfg, TRUE);
		break;
	}

	case WLC_SEND_PWR_CONSTRAINT:
		if (AP_ENAB(wlc->pub)) {
			wlc->pwr_constraint = val & 0xff;
			if (wlc->pub->associated) {
				WL_APSTA_BCN(("wl%d: WLC_SEND_PWR_CONSTRAINT ->"
					" wlc_update_beacon()\n", wlc->pub->unit));
				wlc_update_beacon(wlc);
				wlc_update_probe_resp(wlc, TRUE);
			}
		} else
			bcmerror = BCME_NOTAP;
		break;
#endif /* WL11H */

	case WLC_MEASURE_REQUEST: {
		struct ether_addr *ea = (struct ether_addr *)((uint32*)arg + 1);

		if (len < (int)sizeof(struct ether_addr) + (int)sizeof(uint32)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		if (WL11H_ENAB(wlc)) {
			switch (val) {
			case WLC_MEASURE_TPC:
				wlc_send_tpc_request(wlc, ea);
				break;

			case WLC_MEASURE_CHANNEL_BASIC:
				wlc_send_measure_request(wlc, ea, DOT11_MEASURE_TYPE_BASIC);
				break;

			case WLC_MEASURE_CHANNEL_CCA:
				wlc_send_measure_request(wlc, ea, DOT11_MEASURE_TYPE_CCA);
				break;

			case WLC_MEASURE_CHANNEL_RPI:
				wlc_send_measure_request(wlc, ea, DOT11_MEASURE_TYPE_RPI);
				break;

			default:
				bcmerror = BCME_RANGE; /* unknown measurement type */
				break;
			}
		} else {
			bcmerror = BCME_UNSUPPORTED;
		}
	}
	break;

#ifdef BCMDBG
#ifndef BCMRECLAIM
	case WLC_INIT:
		wl_init(wlc->wl);
		break;
#endif
#endif /* defined BCMDBG && !defined BCMRECLAIM */

	case WLC_SET_VAR:
	case WLC_GET_VAR: {
		char *name;
		/* validate the name value */
		name = (char*)arg;
		for (i = 0; i < (uint)len && *name != '\0'; i++, name++)
			;

		if (i == (uint)len) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		i++; /* include the null in the string length */

		if (cmd == WLC_GET_VAR) {
			bcmerror = wlc_iovar_op(wlc, arg, (void*)((int8*)arg + i), len - i, arg,
				len, IOV_GET, wlcif);
		}
		else
			bcmerror = wlc_iovar_op(wlc, arg, NULL, 0, (void*)((int8*)arg + i), len - i,
				IOV_SET, wlcif);

		break;
	}

	case WLC_SET_WSEC_PMK:
#ifdef BCMSUP_PSK
		if (BSSCFG_STA(bsscfg)) {
			bcmerror = wlc_sup_set_pmk(bsscfg->sup, (wsec_pmk_t *)pval,
			                           bsscfg->associated);
			break;
		}
#endif /* BCMSUP_PSK */
#ifdef BCMAUTH_PSK
		if (BSSCFG_AP(bsscfg)) {
			bcmerror = wlc_auth_set_pmk(bsscfg->authenticator, (wsec_pmk_t *)pval);
			break;
		}
#endif /* BCMAUTH_PSK */
		bcmerror = BCME_UNSUPPORTED;
		break;

#if	defined(WLTEST)
	case WLC_NVRAM_GET:
		bcmerror = wlc_iovar_op(wlc, "nvram_get", arg, len, arg, len, IOV_GET, wlcif);
		break;

#endif 

#ifdef BCMNVRAMW
	case WLC_OTPW:
	case WLC_NVOTPW: {
		if (len & 1) {
			bcmerror = BCME_BADARG;
			break;
		}
		bcmerror = wlc_iovar_op(wlc, (cmd == WLC_OTPW) ? "otpw" : "nvotpw",
			NULL, 0, arg, len, IOV_SET, wlcif);

		break;
	}
#endif /* BCMNVRAMW */

	case WLC_GET_BANDSTATES:
		/* count of number of bands, followed by each band type */
		memcpy(pval, wlc->bandstate[0], (sizeof(wlcband_t)*MAXBANDS));
		break;
	case WLC_GET_WLC_BSS_INFO:
		memcpy(pval, current_bss, sizeof(wlc_bss_info_t));
		break;
	case WLC_GET_ASSOC_INFO:
		*pval++ = as->req_len;
		memcpy(pval, as->req, as->req_len);
		pval = (int *)&(((char *)pval)[as->req_len]);
		*pval++ = as->resp_len;
		memcpy(pval, as->resp, as->resp_len);
		break;

	case WLC_GET_BSS_BCN_TS:
		memcpy(pval, current_bss->bcn_prb->timestamp,
			sizeof(current_bss->bcn_prb->timestamp));
		break;
	case WLC_GET_BSS_WPA_RSN:
		memcpy(pval, &current_bss->wpa, sizeof(current_bss->wpa));
		break;
	case WLC_GET_BSS_WPA2_RSN:
		memcpy(pval, &current_bss->wpa2, sizeof(current_bss->wpa2));
		break;

//#if defined(BCMDBG) || defined(WLTEST)
	case WLC_CURRENT_PWR:
		if (!wlc->pub->up)
			bcmerror = BCME_NOTUP;
		else
			bcmerror = wlc_get_current_txpwr(wlc, arg, len);
		break;
//#endif

	case WLC_GET_PHY_NOISE:
	case WLC_RESTART:
#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_RADIOREG:
	case WLC_SET_RADIOREG:
#endif
#if defined(BCMDBG)
	case WLC_GET_TX_PATH_PWR:
	case WLC_SET_TX_PATH_PWR:
#endif
//#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_PHYREG:
	case WLC_SET_PHYREG:
//#endif
#if defined(BCMDBG) || defined(WLTEST)
	case WLC_GET_TSSI:
	case WLC_GET_ATTEN:
	case WLC_SET_ATTEN:
	case WLC_GET_PWRIDX:
	case WLC_SET_PWRIDX:
	case WLC_LONGTRAIN:
	case WLC_EVM:
	case WLC_FREQ_ACCURACY:
	case WLC_CARRIER_SUPPRESS:
#endif 
	case WLC_GET_INTERFERENCE_MODE:
	case WLC_SET_INTERFERENCE_MODE:
	case WLC_GET_INTERFERENCE_OVERRIDE_MODE:
	case WLC_SET_INTERFERENCE_OVERRIDE_MODE:
		if ((bcmerror = wlc_phy_ioctl_chk(wlc, cmd, len, arg)) != BCME_OK) {
			WL_ERROR(("wlc_phy_ioctl_chk failed\n"));
			break;
		}

		/* EVM is only defined for CCK rates */
		if (cmd == WLC_EVM) {
			ratespec_t *rspec = (((uint *)arg) + 1);

			if (!rspec || !IS_CCK(*rspec))
				return BCME_BADARG;
			else {
				wlc_rateset_t rs;
				wlc_default_rateset(wlc, &rs);
				wlc_rate_lookup_init(wlc, &rs);

				*(((uint *)arg) + 1) = RSPEC2RATE(*rspec);
			}
		}

		bcmerror = wlc_phy_ioctl(wlc->band->pi, cmd, len, arg, &ta_ok);

		if ((cmd == WLC_EVM) || (cmd == WLC_FREQ_ACCURACY) ||
		    (cmd == WLC_LONGTRAIN) || (cmd == WLC_CARRIER_SUPPRESS))
			if ((bcmerror == BCME_OK) && arg)
				wlc->pub->phytest_on = !!(*(uint32 *)arg);
		break;
#ifdef BCMWAPI_WAI
	case WLC_GET_WAI_RESTRICT:
		bcmerror = wlc_iovar_op(wlc, "wai_restrict", NULL, 0, arg, len, IOV_GET, wlcif);
		break;

	case WLC_SET_WAI_RESTRICT:
		bcmerror = wlc_iovar_op(wlc, "wai_restrict", NULL, 0, arg, len, IOV_SET, wlcif);
		break;
	case WLC_SET_WAI_REKEY:
		bcmerror = wlc_iovar_op(wlc, "wai_rekey", NULL, 0, arg, len, IOV_SET, wlcif);
		break;
#endif /* BCMWAPI_WAI */

	case WLC_LAST:
	default:
		/* returns BCME_UNSUPPORTED if scan, ap, and phy do not recognise the cmd */
		bcmerror = wlc_scan_ioctl(wlc->scan, cmd, arg, len, wlcif);
		if (bcmerror == BCME_UNSUPPORTED)
			bcmerror = wlc_ap_ioctl(wlc->ap, cmd, arg, len, wlcif);
	}
done:

	if (bcmerror) {
		if (VALID_BCMERROR(bcmerror))
			wlc->pub->bcmerror = bcmerror;
		else {
			bcmerror = 0;
		}

	}

	/* The sequence is significant.
	 *   Only if sbclk is TRUE, we can proceed with register access.
	 *   Even though ta_ok is TRUE, we still want to check(and clear) target abort
	 *   si_taclear returns TRUE if there was a target abort, In this case, ta_ok must be TRUE
	 *   to avoid assert
	 *   ASSERT and si_taclear are both under ifdef BCMDBG
	 */
#ifdef WLC_LOW
	/* BMAC_NOTE: for HIGH_ONLY driver, this seems being called after RPC bus failed */
	/* In hw_off condition, IOCTLs that reach here are deemed safe but taclear would
	 * certainly result in getting -1 for register reads. So skip ta_clear altogether
	 */
	if (!(wlc->pub->hw_off))
		ASSERT(wlc_bmac_taclear(wlc->hw, ta_ok) || !ta_ok);
#endif

	return (bcmerror);
}

//#if defined(BCMDBG) || defined(WLTEST) || defined(BCMDBG_ERR) || defined(BCMDBG_DUMP)
/* consolidated register access ioctl error checking */
int
wlc_iocregchk(wlc_info_t *wlc, uint band)
{
	/* if band is specified, it must be the current band */
	if ((band != WLC_BAND_AUTO) && (band != (uint)wlc->band->bandtype))
		return (BCME_BADBAND);

	/* if multiband and band is not specified, band must be locked */
	if ((band == WLC_BAND_AUTO) && IS_MBAND_UNLOCKED(wlc))
		return (BCME_NOTBANDLOCKED);

	/* must have core clocks */
	if (!wlc->clk)
		return (BCME_NOCLK);

	return (0);
}
//#endif 

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
/* For some ioctls, make sure that the pi pointer matches the current phy */
int
wlc_iocpichk(wlc_info_t *wlc, uint phytype)
{
	if (wlc->band->phytype != phytype)
		return BCME_BADBAND;
	return 0;
}
#endif 

#if defined(BCMDBG) || defined(WLTEST) || defined(STA)
int
wlc_iocbandchk(wlc_info_t *wlc, int *arg, int len, uint *bands, bool clkchk)
{
	uint band;

	/* get optional band */
	band = (len < (int)(2 * sizeof(int))) ? WLC_BAND_AUTO : arg[1];

	/* if band is specified, it must be either the current band or "all" */
	if ((band != WLC_BAND_AUTO) && (band != WLC_BAND_ALL) &&
	    (band != (uint) wlc->band->bandtype))
		return (BCME_BADBAND);

	/* if multiband and band is not specified, band must be locked */
	if ((band == WLC_BAND_AUTO) && IS_MBAND_UNLOCKED(wlc))
		return (BCME_NOTBANDLOCKED);

	/* no need clocks */
	if (clkchk && !wlc->clk)
		return (BCME_NOCLK);

	if (bands)
		*bands = band;
	return (0);
}
#endif 


/* Look up the given var name in the given table */
static const bcm_iovar_t*
wlc_iovar_lookup(const bcm_iovar_t *table, const char *name)
{
	const bcm_iovar_t *vi;
	const char *lookup_name;

	/* skip any ':' delimited option prefixes */
	lookup_name = strrchr(name, ':');
	if (lookup_name != NULL)
		lookup_name++;
	else
		lookup_name = name;

	ASSERT(table != NULL);

	for (vi = table; vi->name; vi++) {
		if (!strcmp(vi->name, lookup_name))
			return vi;
	}
	/* ran to end of table */

	return NULL; /* var name not found */
}

/* simplified integer get interface for common WLC_GET_VAR ioctl handler */
int
wlc_iovar_getint(wlc_info_t *wlc, const char *name, int *arg)
{
	return wlc_iovar_op(wlc, name, NULL, 0, arg, sizeof(int32), IOV_GET, NULL);
}

/* simplified integer set interface for common WLC_SET_VAR ioctl handler */
int
wlc_iovar_setint(wlc_info_t *wlc, const char *name, int arg)
{
	return wlc_iovar_op(wlc, name, NULL, 0, (void *)&arg, sizeof(arg), IOV_SET, NULL);
}

/* simplified int8 get interface for common WLC_GET_VAR ioctl handler */
int
wlc_iovar_getint8(wlc_info_t *wlc, const char *name, int8 *arg)
{
	int iovar_int;
	int err;

	err = wlc_iovar_op(wlc, name, NULL, 0, &iovar_int, sizeof(iovar_int), IOV_GET, NULL);
	if (!err)
		*arg = (int8)iovar_int;

	return err;
}

/* simplified bool get interface for common WLC_GET_VAR ioctl handler */
int
wlc_iovar_getbool(wlc_info_t *wlc, const char *name, bool *arg)
{
	int iovar_int;
	int err;

	err = wlc_iovar_op(wlc, name, NULL, 0, &iovar_int, sizeof(iovar_int), IOV_GET, NULL);
	if (!err)
		*arg = (bool)iovar_int;

	return err;
}

/*
 * register iovar table, watchdog and down handlers.
 * calling function must keep 'iovars' until wlc_module_unregister is called.
 * 'iovar' must have the last entry's name field being NULL as terminator.
 */
int
BCMATTACHFN(wlc_module_register)(wlc_pub_t *pub, const bcm_iovar_t *iovars,
                               const char *name, void *hdl, iovar_fn_t i_fn,
                               watchdog_fn_t w_fn, up_fn_t u_fn, down_fn_t d_fn)
{
	wlc_info_t *wlc = (wlc_info_t *)pub->wlc;
	int i;

	ASSERT(name != NULL);
	ASSERT(i_fn != NULL || w_fn != NULL || d_fn != NULL);

	/* find an empty entry and just add, no duplication check! */
	for (i = 0; i < WLC_MAXMODULES; i ++) {
		if (wlc->modulecb[i].name[0] == '\0') {
			strncpy(wlc->modulecb[i].name, name, sizeof(wlc->modulecb[i].name) - 1);
			wlc->modulecb[i].iovars = iovars;
			wlc->modulecb[i].hdl = hdl;
			wlc->modulecb[i].iovar_fn = i_fn;
			wlc->modulecb[i].watchdog_fn = w_fn;
			wlc->modulecb[i].down_fn = d_fn;
			return 0;
		}
	}

	/* it is time to increase the capacity */
	ASSERT(i < WLC_MAXMODULES);
	return BCME_NORESOURCE;
}

/* unregister module callbacks */
int
BCMATTACHFN(wlc_module_unregister)(wlc_pub_t *pub, const char *name, void *hdl)
{
	wlc_info_t *wlc = (wlc_info_t *)pub->wlc;
	int i;

	if (wlc == NULL)
		return BCME_NOTFOUND;

	ASSERT(name != NULL);

	for (i = 0; i < WLC_MAXMODULES; i ++) {
		if (!strcmp(wlc->modulecb[i].name, name) &&
		    (wlc->modulecb[i].hdl == hdl)) {
			bzero(&wlc->modulecb[i], sizeof(modulecb_t));
			return 0;
		}
	}

	/* table not found! */
	return BCME_NOTFOUND;
}

/*
 * register dump name and handlers.
 * calling function must keep 'dump function'
 */
int
BCMINITFN(wlc_dump_register)(wlc_pub_t *pub, const char *name, dump_fn_t dump_fn, void *dump_fn_arg)
{
	wlc_info_t *wlc = (wlc_info_t *)pub->wlc;
	dumpcb_t *ptr, *prev;

	ASSERT(name != NULL);
	ASSERT(dump_fn != NULL);

	for (prev = NULL, ptr = wlc->dumpcb_head; ptr != NULL; ptr = ptr->next) {
		if (strcmp(name, ptr->name) && (dump_fn == ptr->dump_fn) &&
			(dump_fn_arg == ptr->dump_fn_arg)) {
			return BCME_OK;  /* Already present */
		}
		prev = ptr;
	}

	/* Not already in list; allocate new and put at end of list */
	if ((ptr = (dumpcb_t *)MALLOC(wlc->osh, sizeof(dumpcb_t))) == NULL) {
		return BCME_NORESOURCE;
	}
	ptr->name = name;
	ptr->dump_fn = dump_fn;
	ptr->dump_fn_arg = dump_fn_arg;
	ptr->next = NULL;

	if (prev != NULL) {
		prev->next = ptr;
	} else {
		wlc->dumpcb_head = ptr;
	}

	return BCME_OK;
}


/* Write WME tunable parameters for retransmit/max rate from wlc struct to ucode */
static void
wlc_wme_retries_write(wlc_info_t *wlc)
{
	int ac;

	/* Need clock to do this */
	if (!wlc->clk)
		return;

	for (ac = 0; ac < AC_COUNT; ac++) {
		wlc_write_shm(wlc, M_AC_TXLMT_ADDR(ac), wlc->wme_retries[ac]);
	}
}

#if defined(WLTEST)
/* Get chip manufacture information */
static int
wlc_manf_info_get(wlc_info_t *wlc, char *buf, int len, struct wlc_if *wlcif)
{
	uint16 otp_data[MANF_INFO_LEN]; /* 2 rows in OTP, 64 bits each */
	struct bcmstrbuf b;
	int bcmerror = BCME_OK;
	const struct wlc_otp_manf_info *pinfo;
	uint32 data, i;
	uint16 bit_pos, row_index = 0, bit_val;

	/* read 1st 2 row from OTP */
	for (i = 0; i < 8; i++) {
		bcmerror = wlc_iovar_op(wlc, "otprawr", &i, sizeof(uint32), &data,
			sizeof(uint32), IOV_GET, wlcif);
		if (bcmerror) {
			WL_ERROR(("fail to read OTP\n"));
			return BCME_ERROR;
		}
		otp_data[i] = (uint16)data;
		WL_TRACE(("\nOTP data%x: %x", i, otp_data[i]));
	}

	bcm_binit(&b, buf, len);
	pinfo = wlc_manf_info;
	while (pinfo->name != NULL) {
		data = 0;
		ASSERT(pinfo->bit_pos_end == pinfo->bit_pos_start + pinfo->len - 1);
		for (bit_pos = row_index * MANF_INFO_ROW_WIDTH + pinfo->bit_pos_start, i = 0;
		     i < pinfo->len; i++, bit_pos++) {
			if ((bit_pos >> 4) > MANF_INFO_LEN) {
				return BCME_ERROR;
			}
			/* extract the bit from the half word array */
			bit_val = (otp_data[bit_pos >> 4] >> (bit_pos & 0xf)) & 0x1;
			data |= (bit_val << i);
		}

		WL_TRACE(("%s : 0x%x\n", pinfo->name, data));
		if (pinfo->bit_pos_end == (MANF_INFO_ROW_WIDTH - 1)) {
			row_index++;
		}
		bcm_bprintf(&b, "%s: 0x%x\n", pinfo->name, data);
		pinfo++;
	}
	bcm_bprintf(&b, "Package ID:%x\n", wlc->pub->sih->chippkg);
	return bcmerror;
}
#endif 

/* Get or set an iovar.  The params/p_len pair specifies any additional
 * qualifying parameters (e.g. an "element index") for a get, while the
 * arg/len pair is the buffer for the value to be set or retrieved.
 * Operation (get/set) is specified by the last argument.
 * interface context provided by wlcif
 *
 * All pointers may point into the same buffer.
 */
int
wlc_iovar_op(wlc_info_t *wlc, const char *name,
	void *params, int p_len, void *arg, int len,
	bool set, struct wlc_if *wlcif)
{
	int err = 0;
	int val_size;
	const bcm_iovar_t *vi = NULL;
	uint32 actionid;
	int i;

	ASSERT(name != NULL);

	ASSERT(len >= 0);

	/* Get MUST have return space */
	ASSERT(set || (arg && len));

	ASSERT(!(wlc->pub->hw_off && wlc->pub->up));

	/* Set does NOT take qualifiers */
	ASSERT(!set || (!params && !p_len));

	if (!set && (len == sizeof(int)) &&
		!(ISALIGNED((uintptr)(arg), (uint)sizeof(int)))) {
		WL_ERROR(("wl%d: %s unaligned get ptr for %s\n",
			wlc->pub->unit, __FUNCTION__, name));
		ASSERT(0);
	}

	/* find the given iovar name */
	for (i = 0; i < WLC_MAXMODULES; i ++) {
		if (!wlc->modulecb[i].iovars)
			continue;
		if ((vi = wlc_iovar_lookup(wlc->modulecb[i].iovars, name)))
			break;
	}
	/* iovar name not found */
	if (i >= WLC_MAXMODULES) {
		err = BCME_UNSUPPORTED;
		goto exit;
	}

	WL_OID(("wl%d: table \"%s\" iovar \"%s\" %s len %d p_len %d\n", wlc->pub->unit,
		wlc->modulecb[i].name, name, (set ? "set" : "get"), len, p_len));

	/* set up 'params' pointer in case this is a set command so that
	 * the convenience int and bool code can be common to set and get
	 */
	if (params == NULL) {
		params = arg;
		p_len = len;
	}

	if (vi->type == IOVT_VOID)
		val_size = 0;
	else if (vi->type == IOVT_BUFFER)
		val_size = len;
	else
		/* all other types are integer sized */
		val_size = sizeof(int);

	actionid = set ? IOV_SVAL(vi->varid) : IOV_GVAL(vi->varid);

	/* handle the "bsscfg:" prefix and index arg for multi-bsscfg cases */
	if (!strncmp("bsscfg:", name, 7)) {
		int32 bsscfg_idx;
		wlc_bsscfg_t *bsscfg;

		if (p_len < (int)sizeof(bsscfg_idx)) {
			err = BCME_BUFTOOSHORT;
			goto exit;
		}
		bcopy(params, &bsscfg_idx, sizeof(bsscfg_idx));

		bsscfg = wlc_bsscfg_find(wlc, bsscfg_idx, &err);
#ifdef AP
		if (err == BCME_NOTFOUND) {
			if (IOV_ISSET(actionid)) {
				bsscfg = wlc_bsscfg_alloc(wlc, bsscfg_idx, 0, NULL, TRUE);
				if (bsscfg == NULL)
					err = BCME_NOMEM;
				else if ((err = wlc_bsscfg_init(wlc, bsscfg))) {
					WL_ERROR(("wl%d: wlc_bsscfg_init failed (%d)\n",
					          wlc->pub->unit, err));
					wlc_bsscfg_free(wlc, bsscfg);
				}
			}
		}
#endif /* AP */
		if (err)
			goto exit;

		/* adjust the name and i/o pointers to skip over the bsscfg index
		 * parameters
		 */
		name += strlen("bsscfg:");
		params = (int8*)params + sizeof(bsscfg_idx);
		p_len -= sizeof(bsscfg_idx);
		if (IOV_ISSET(actionid)) {
			arg = (int8*)arg + sizeof(bsscfg_idx);
			len -= sizeof(bsscfg_idx);
		}

		/* use the wlcif from possibly a different bsscfg! */
		wlcif = bsscfg->wlcif;
	}

	if ((err = wlc_iovar_check(wlc, vi, arg, len, IOV_ISSET(actionid), wlcif)) != 0)
		return err;

	/* Do the actual parameter implementation */
	err = wlc->modulecb[i].iovar_fn(wlc->modulecb[i].hdl, vi, actionid,
		name, params, p_len, arg, len, val_size, wlcif);

	if (IOV_ISSET(actionid) && WLC_TXC_ENAB(wlc)) {
		wlc_txc_upd(wlc);
		/* invalidate txcache for safe */
		wlc->txcgen++;
	}

exit:
	return err;
}

static int
wlc_iovar_check(wlc_info_t *wlc, const bcm_iovar_t *vi, void *arg, int len, bool set,
	wlc_if_t *wlcif)
{
	int err = 0;
	int32 int_val = 0;
	uint16 flags;

	/* check generic condition flags */
	if (set) {
		if (((vi->flags & IOVF_SET_DOWN) && wlc->pub->up) ||
		    ((vi->flags & IOVF_SET_UP) && !wlc->pub->up)) {
			err = (wlc->pub->up ? BCME_NOTDOWN : BCME_NOTUP);
		}
		else if ((vi->flags & IOVF_SET_BAND) && IS_MBAND_UNLOCKED(wlc)) {
			err = BCME_NOTBANDLOCKED;
		}
		else if ((vi->flags & IOVF_SET_CLK) && !wlc->clk) {
			err = BCME_NOCLK;
		}
	} else {
		if (((vi->flags & IOVF_GET_DOWN) && wlc->pub->up) ||
		    ((vi->flags & IOVF_GET_UP) && !wlc->pub->up)) {
			err = (wlc->pub->up ? BCME_NOTDOWN : BCME_NOTUP);
		}
		else if ((vi->flags & IOVF_GET_BAND) && IS_MBAND_UNLOCKED(wlc)) {
			err = BCME_NOTBANDLOCKED;
		}
		else if ((vi->flags & IOVF_GET_CLK) && !wlc->clk) {
			err = BCME_NOCLK;
		}
	}

#if defined(OPENSRC_IOV_IOCTL) && !defined(BCMDBG)
	if ((vi->flags & IOVF_OPEN_ALLOW) == 0)
		err = BCME_UNSUPPORTED;
#endif

	if (err)
		goto exit;

	if ((flags = (vi->flags & (IOVF_BSSCFG_STA_ONLY | IOVF_BSSCFG_AP_ONLY))) != 0) {
		wlc_bsscfg_t *cfg;
		if ((cfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif)) == NULL) {
			err = BCME_NOTFOUND;
			goto exit;
		}
		switch (flags) {
		case IOVF_BSSCFG_STA_ONLY:
			if (!BSSCFG_STA(cfg)) {
				err = BCME_NOTSTA;
				goto exit;
			}
			break;
		case IOVF_BSSCFG_AP_ONLY:
			if (!BSSCFG_AP(cfg)) {
				err = BCME_NOTAP;
				goto exit;
			}
			break;
		}
	}

	if ((err = wlc_mfg_iovar_filter(wlc->pub, vi)) < 0)
		goto exit;

	/* length check on io buf */
	if ((err = bcm_iovar_lencheck(vi, arg, len, set)))
		goto exit;

	/* On set, check value ranges for integer types */
	if (set) {
		switch (vi->type) {
		case IOVT_BOOL:
		case IOVT_INT8:
		case IOVT_INT16:
		case IOVT_INT32:
		case IOVT_UINT8:
		case IOVT_UINT16:
		case IOVT_UINT32:
			bcopy(arg, &int_val, sizeof(int));
			err = wlc_iovar_rangecheck(wlc, int_val, vi);
			break;
		}
	}
exit:
	return err;
}

static uint
wlc_txq_txpktcnt(void *ctx)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	wlc_txq_info_t *qi = wlc->active_queue;

	return (uint)pktq_len(&qi->q);
}

/* Return total transmit packets held by the driver */
uint
wlc_txpktcnt(struct wlc_info *wlc)
{
	uint pktcnt = 0;
	int i;
#ifdef WL_BSSCFG_TX_SUPR
	wlc_bsscfg_t *bsscfg;
#endif

	/* Software txmods */
	/* Call any pktcnt handlers of registered modules only */
	for (i = TXMOD_START; i < TXMOD_LAST; i ++)
		if (wlc->txmod_fns[i].pktcnt_fn)
			pktcnt += wlc->txmod_fns[i].pktcnt_fn(wlc->txmod_fns[i].ctx);

	/* Hardware FIFO */
	pktcnt += TXPKTPENDTOT(wlc);

#ifdef WL_BSSCFG_TX_SUPR
	/* For all BSSCFG */
	FOREACH_BSS(wlc, i, bsscfg) {
		pktcnt += (uint)pktq_len(bsscfg->psq);
	}
#endif

	return pktcnt;
}

#ifdef BCMDBG
#ifdef STA
static void
wlc_rpmt_timer_cb(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;
	wlc_info_t *wlc = cfg->wlc;
	uint32 to = 0;

	if (cfg->rpmt_n_st == 1) {
		wlc_set_pmstate(cfg, TRUE);
		to = cfg->rpmt_1_prd;
		cfg->rpmt_n_st = 0;
	}
	else if (cfg->rpmt_n_st == 0) {
		wlc_set_pmstate(cfg, FALSE);
		to = cfg->rpmt_0_prd;
		cfg->rpmt_n_st = 1;
	}
	if (to == 0)
		return;
	wlc_hwtimer_add_timeout(wlc->gptimer, cfg->rpmt_timer, to, wlc_rpmt_timer_cb, cfg);
}
#endif /* STA */
#endif /* BCMDBG */

static uint16 convert_acbitmap_to_precbitmap(ac_bitmap_t acbitmap)
{
	uint16 prec_bitmap = 0;

	if (AC_BITMAP_TST(acbitmap, AC_BE))
		prec_bitmap |= WLC_PREC_BMP_AC_BE;

	if (AC_BITMAP_TST(acbitmap, AC_BK))
		prec_bitmap |= WLC_PREC_BMP_AC_BK;

	if (AC_BITMAP_TST(acbitmap, AC_VI))
		prec_bitmap |= WLC_PREC_BMP_AC_VI;

	if (AC_BITMAP_TST(acbitmap, AC_VO))
		prec_bitmap |= WLC_PREC_BMP_AC_VO;

	return prec_bitmap;
}

/* handler for iovar table wlc_iovars */
/*
 * IMPLEMENTATION NOTE: In order to avoid checking for get/set in each
 * iovar case, the switch statement maps the iovar id into separate get
 * and set values.  If you add a new iovar to the switch you MUST use
 * IOV_GVAL and/or IOV_SVAL in the case labels to avoid conflict with
 * another case.
 * Please use params for additional qualifying parameters.
 */
int
wlc_doiovar(void *hdl, const bcm_iovar_t *vi, uint32 actionid, const char *name,
	void *params, uint p_len, void *arg, int len, int val_size, struct wlc_if *wlcif)
{
	wlc_info_t *wlc = hdl;
	wlc_bsscfg_t *bsscfg;
	int err = 0;
	struct maclist *maclist;
	int32 int_val = 0;
	int32 int_val2 = 0;
	int32 *ret_int_ptr;
	bool bool_val;
	bool bool_val2;
	struct bcmstrbuf b;
#ifdef STA
	wlc_assoc_t *as;
	wlc_roam_t *roam;
	wlc_pm_st_t *pm;
#endif
	wlc_bss_info_t *current_bss;
#ifdef WLNINTENDO2
	wl_lq_t *ret_estatus = NULL;
	wl_lq_t estatus;
#endif
	wlc_prot_cfg_t *prot;

	/* update bsscfg w/provided interface context */
	bsscfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif);
	ASSERT(bsscfg != NULL);

#ifdef STA
	as = bsscfg->assoc;
	roam = bsscfg->roam;
	pm = bsscfg->pm;
#endif
	current_bss = bsscfg->current_bss;
	prot = bsscfg->prot_cfg;

	if (vi->flags & IOVF_BMAC_IOVAR) {
		if (IOV_ISSET(actionid)) {
			err = wlc_bmac_iovars_dispatch(wlc->hw,
				IOV_SVAL(vi->varid), vi->type,
				arg, len, arg, len, val_size);
		}
		else {
			err = wlc_bmac_iovars_dispatch(wlc->hw,
				IOV_GVAL(vi->varid), vi->type,
				params, p_len, arg, len, val_size);
		}

		return err;
	}

	/* convenience int and bool vals for first 8 bytes of buffer */
	if (p_len >= (int)sizeof(int_val))
		bcopy(params, &int_val, sizeof(int_val));

	if (p_len >= (int)sizeof(int_val) * 2)
		bcopy((void*)((uintptr)params + sizeof(int_val)), &int_val2, sizeof(int_val));

	/* convenience int ptr for 4-byte gets (requires int aligned arg) */
	ret_int_ptr = (int32 *)arg;

	bool_val = (int_val != 0) ? TRUE : FALSE;
	bool_val2 = (int_val2 != 0) ? TRUE : FALSE;

	/* Do the actual parameter implementation */
	switch (actionid) {

	case IOV_GVAL(IOV_5G_RATE):
		*ret_int_ptr = RSPEC2RATE(wlc->bandstate[BAND_5G_INDEX]->rspec_override);
		break;

	case IOV_SVAL(IOV_5G_RATE):
		/* Create a fixed MIMO rate if a mimo phy rate was passed in */
		err = wlc_set_rate_override(wlc, WLC_BAND_5G, (int)int_val, FALSE);
		break;

	case IOV_GVAL(IOV_5G_MRATE):
		*ret_int_ptr = RSPEC2RATE(wlc->bandstate[BAND_5G_INDEX]->mrspec_override);
		break;

	case IOV_SVAL(IOV_5G_MRATE):
		err = wlc_set_rate_override(wlc, WLC_BAND_5G, (int)int_val, TRUE);
		break;

	case IOV_GVAL(IOV_2G_RATE):
		/* check for a fixed MIMO rate */
		*ret_int_ptr = RSPEC2RATE(wlc->bandstate[BAND_2G_INDEX]->rspec_override);
		break;

	case IOV_SVAL(IOV_2G_RATE):
		err = wlc_set_rate_override(wlc, WLC_BAND_2G, (int)int_val, FALSE);
		break;

	case IOV_GVAL(IOV_2G_MRATE):
		*ret_int_ptr = RSPEC2RATE(wlc->bandstate[BAND_2G_INDEX]->mrspec_override);
		break;

	case IOV_SVAL(IOV_2G_MRATE):
		err = wlc_set_rate_override(wlc, WLC_BAND_2G, (int)int_val, TRUE);
		break;

	case IOV_GVAL(IOV_QTXPOWER): {
		uint qdbm;
		bool override;

		if ((err = wlc_phy_txpower_get(wlc->band->pi, &qdbm, &override)) != BCME_OK)
			return err;

		/* Return qdbm units */
		*ret_int_ptr = qdbm | (override ? WL_TXPWR_OVERRIDE : 0);
		break;
	}

	/* As long as override is false, this only sets the *user* targets.
	   User can twiddle this all he wants with no harm.
	   wlc_phy_txpower_set() explicitly sets override to false if
	   not internal or test.
	*/
	case IOV_SVAL(IOV_QTXPOWER): {
		uint8 qdbm;
		bool override;

		/* Remove override bit and clip to max qdbm value */
		qdbm = (uint8)MIN((int_val & ~WL_TXPWR_OVERRIDE), 0xff);
		/* Extract override setting */
		override = (int_val & WL_TXPWR_OVERRIDE) ? TRUE : FALSE;
		err = wlc_phy_txpower_set(wlc->band->pi, qdbm, override);
		break;
	}

#ifdef WLAFTERBURNER
	case IOV_GVAL(IOV_ABMINRATE):
		*ret_int_ptr = (int32) wlc->abminrate;
		break;

	case IOV_SVAL(IOV_ABMINRATE):
		wlc->abminrate = (uint8)int_val;
		break;
#endif /* WLAFTERBURNER */

#ifdef WL11N
	case IOV_GVAL(IOV_ANTSEL_TYPE):
		*ret_int_ptr = (int32) wlc_antsel_antseltype_get(wlc->asi);
		break;
#endif /* WL11N */

#ifdef STA
	case IOV_GVAL(IOV_ASSOC_INFO): {
		wl_assoc_info_t *assoc_info = (wl_assoc_info_t *)arg;
		uint32 flags = (as->req_is_reassoc) ? WLC_ASSOC_REQ_IS_REASSOC : 0;

		bcopy(&as->req_len, &assoc_info->req_len, sizeof(uint32));
		bcopy(&as->resp_len, &assoc_info->resp_len, sizeof(uint32));
		bcopy(&flags, &assoc_info->flags, sizeof(uint32));
		if (as->req_len && as->req) {
			bcopy((char*)as->req, &assoc_info->req,
			      sizeof(struct dot11_assoc_req));
		if (as->req_is_reassoc)
			bcopy((char*)(as->req+1), &assoc_info->reassoc_bssid.octet[0],
				ETHER_ADDR_LEN);}
		if (as->resp_len && as->resp)
			bcopy((char*)as->resp, &assoc_info->resp,
			      sizeof(struct dot11_assoc_resp));
		break;
	}

	case IOV_SVAL(IOV_ASSOC_INFO): {
		wl_assoc_info_t *assoc_info = (wl_assoc_info_t *)arg;
		as->capability = assoc_info->req.capability;
		as->listen = assoc_info->req.listen;
		bcopy(assoc_info->reassoc_bssid.octet, bsscfg->assoc->bssid.octet,
			ETHER_ADDR_LEN);

		break;
	}

	case IOV_GVAL(IOV_ASSOC_REQ_IES): {
		/* if a reassoc then skip the bssid */
		char *req_ies = (char*)(as->req+1);
		int req_ies_len = as->req_len - sizeof(struct dot11_assoc_req);

		if (!as->req_len) {
			ASSERT(!as->req);
			break;
		}
		ASSERT(as->req);
		if (as->req_is_reassoc) {
			req_ies_len -= ETHER_ADDR_LEN;
			req_ies += ETHER_ADDR_LEN;
		}
		if (len < req_ies_len)
			return BCME_BUFTOOSHORT;
		bcopy((char*)req_ies, (char*)arg, req_ies_len);
		break;
	}

	case IOV_SVAL(IOV_ASSOC_REQ_IES): {
		if (len) {
			if (bsscfg->assoc->ie)
				MFREE(wlc->osh, bsscfg->assoc->ie, bsscfg->assoc->ie_len);
			bsscfg->assoc->ie_len = len;
			if (!(bsscfg->assoc->ie = MALLOC(wlc->osh, bsscfg->assoc->ie_len))) {
				WL_ERROR(("wl%d: wl_set_oid: out of memory, malloced %d bytes\n",
					wlc->pub->unit, MALLOCED(wlc->osh)));
				break;
			}
			bcopy((int8 *) arg, bsscfg->assoc->ie, bsscfg->assoc->ie_len);
		}
		break;
	}

	case IOV_GVAL(IOV_ASSOC_RESP_IES):
		if (!as->resp_len) {
			ASSERT(!as->resp);
			break;
		}
		ASSERT(as->resp);
		if (len < (int)(as->resp_len - sizeof(struct dot11_assoc_resp)))
			return BCME_BUFTOOSHORT;
		bcopy((char*)(as->resp+1), (char*)arg, as->resp_len -
		      sizeof(struct dot11_assoc_resp));
		break;

	case IOV_GVAL(IOV_PMKID_INFO):
		if (len < (int)(sizeof(int_val) + bsscfg->npmkid*sizeof(pmkid_t)))
			return BCME_BUFTOOSHORT;
		*ret_int_ptr = bsscfg->npmkid;
		arg = (char*)arg + sizeof(uint32);
		bcopy(bsscfg->pmkid, arg, bsscfg->npmkid*sizeof(pmkid_t));
		break;

	case IOV_SVAL(IOV_PMKID_INFO): {
		pmkid_list_t *pmkid = (pmkid_list_t *)arg;
		uint i, npmkid;

		bcopy(&pmkid->npmkid, &npmkid, sizeof(uint));

		if (npmkid > MAXPMKID)
			return BCME_BADLEN;

		/* Full cache is always plumbed, so clear what's already there */
		bzero(bsscfg->pmkid, sizeof(bsscfg->pmkid));

		/* Fill cache */
		for (i = 0; i < npmkid; i++) {
			bcopy(&pmkid->pmkid[i], &bsscfg->pmkid[i], sizeof(pmkid_t));
#ifdef BCMDBG
			if (WL_WSEC_ON()) {
				char eabuf[ETHER_ADDR_STR_LEN];
				uint j;

				WL_WSEC(("wl%d: PMKID[%d]: %s = ", wlc->pub->unit, i,
					bcm_ether_ntoa(&pmkid->pmkid[i].BSSID,
					eabuf)));
				for (j = 0; j < WPA2_PMKID_LEN; j++)
					WL_WSEC(("%02x ", pmkid->pmkid[i].PMKID[j]));
				WL_WSEC(("\n"));
			}
#endif /* BCMDBG */
		}
		bsscfg->npmkid = npmkid;

		break;
	}


	case IOV_SVAL(IOV_JOIN_PREF):
		if ((err = wlc_join_pref_parse(bsscfg, arg, len))) {
			goto exit;
		}
		break;

	case IOV_GVAL(IOV_FREQTRACK):
		*ret_int_ptr = (int32)wlc->freqtrack_override;
		break;

	case IOV_SVAL(IOV_FREQTRACK):
		if ((int_val >= FREQTRACK_AUTO) && (int_val <= FREQTRACK_OFF)) {
			wlc->freqtrack_override = (int8)int_val;
		}
		else {
			err = BCME_RANGE;
			goto exit;
		}
		break;
#endif /* STA */

	case IOV_GVAL(IOV_WME_AC_STA):
		if (WME_ENAB(wlc->pub)) {
			edcf_acparam_t acp_all[AC_COUNT];
			wlc_wme_acp_get_all(wlc, &wlc->wme_param_ie, acp_all);
			memcpy(arg, acp_all, sizeof(acp_all));    /* Copy to handle unaligned */
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_WME_AC_STA):
		if (WME_ENAB(wlc->pub)) {
			edcf_acparam_t acp;
			memcpy(&acp, arg, sizeof(acp));
			err = wlc_wme_acp_set(wlc, &wlc->wme_param_ie, &acp);
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_STA_INFO):
		err = wlc_sta_info(wlc, bsscfg, (struct ether_addr *)params, arg, len);
		break;

#if defined(BCMSUP_PSK) && defined(BCMINTSUP)
	case IOV_GVAL(IOV_SUP_AUTH_STATUS):
		*((uint32 *)arg) = wlc_sup_get_auth_status(bsscfg->sup);
		break;

	case IOV_GVAL(IOV_SUP_AUTH_STATUS_EXT):
		*((uint32 *)arg) = wlc_sup_get_auth_status_extended(bsscfg->sup);
		break;
#endif 

	case IOV_GVAL(IOV_CAP):
		wlc_cap(wlc, (char*)arg, len);
		break;

	case IOV_GVAL(IOV_WPA_MSGS):
		*ret_int_ptr = (int32)wlc->wpa_msgs;
		break;

	case IOV_SVAL(IOV_WPA_MSGS):
		wlc->wpa_msgs = bool_val;
		break;

	case IOV_GVAL(IOV_EVENT_MSGS):
		bzero(arg, len);
		wlc_eventq_query_ind(wlc->eventq, arg);
		break;

	case IOV_SVAL(IOV_EVENT_MSGS):
		wlc_eventq_register_ind(wlc->eventq, arg);
		break;

	case IOV_GVAL(IOV_WPA_AUTH):
		*((uint*)arg) = bsscfg->WPA_auth;
		break;

	case IOV_SVAL(IOV_WPA_AUTH):
#ifdef STA
		/* change of WPA_Auth modifies the PS_ALLOWED state */
		if (BSSCFG_STA(bsscfg)) {
			bool prev_psallowed = PS_ALLOWED(bsscfg);

			bsscfg->WPA_auth = (uint16) int_val;

			if (prev_psallowed != PS_ALLOWED(bsscfg))
				wlc_set_pmstate(bsscfg, pm->PMenabled);

			wlc_join_pref_reset(bsscfg);
		} else
#endif	/* STA */
#ifdef AP
		if (BSSCFG_AP(bsscfg)) {
			if (bsscfg->up)
				err = BCME_UNSUPPORTED;
			else
				bsscfg->WPA_auth = (uint16)int_val;
		} else
#endif	/* AP */
		bsscfg->WPA_auth = (uint16)int_val;
		break;

	case IOV_GVAL(IOV_WPA_CAP): {
		uint32  cap = 0;
		/* wlc_wpa_cap() only sets a few bytes, so clear the
		 * return buffer before calling
		 */
		bzero(arg, len);
		err = wlc_wpa_cap(wlc, bsscfg, (uint8*)&cap, sizeof(cap));
		*ret_int_ptr = ltoh32(cap);
		break;
	}
	case IOV_SVAL(IOV_WPA_CAP): {
		uint8  cap[WPA_CAP_LEN];
		cap[0] = (uint8)(int_val & 0xff);
		cap[1] = (uint8)((int_val >> 8) & 0xff);
		if (AP_ENAB(wlc->pub))
			err = wlc_wpa_set_cap(wlc->ap, bsscfg, cap, sizeof(cap));
		break;
	}

	case IOV_GVAL(IOV_MALLOCED):
		*((uint*)arg) = MALLOCED(wlc->osh);
		break;

	case IOV_GVAL(IOV_PER_CHAN_INFO): {
		*ret_int_ptr = wlc_get_chan_info(wlc, (uint16)int_val);
		break;
	}
	case IOV_GVAL(IOV_VNDR_IE):
	case IOV_GVAL(IOV_IE): {
		uint32 pktflag;
		uint8 ie_type;

		if (actionid == IOV_GVAL(IOV_IE)) {
			if (p_len < sizeof(ie_getbuf_t)) {
				err = BCME_BUFTOOSHORT;
				break;
			}
			bcopy((uint8 *)params, &pktflag, sizeof(pktflag));
			ie_type = *(uint8 *)((uint8 *)params + sizeof(pktflag));
		} else {
			pktflag = -1;
			ie_type = DOT11_MNG_PROPR_ID;
		}

		if (ie_type == DOT11_MNG_PROPR_ID) {
			vndr_ie_buf_t *vndr_ie_getbufp;
			/* Extract the vndr ie into a memory-aligned structure, then bcopy
			* the structure into the ioctl output buffer pointer 'arg'.
			* This extra copying is necessary in case 'arg' has an unaligned
			* address due to a "bsscfg:N" prefix.
			*/
			if (!(vndr_ie_getbufp = MALLOC(wlc->osh, len))) {
				WL_ERROR(("wl%d: out of memory, malloced %d bytes\n",
					wlc->pub->unit, MALLOCED(wlc->osh)));
				err = BCME_NOMEM;
				break;
			}
			err = wlc_vndr_ie_get(bsscfg, vndr_ie_getbufp, len, pktflag);
			bcopy(vndr_ie_getbufp, (uint8*)arg, len);
			MFREE(wlc->osh, vndr_ie_getbufp, len);
		} else {
			int ie_len = 0;
			uint8 *ie_data;

			ie_data = wlc_bsscfg_get_ie(bsscfg, ie_type);

			if (ie_data) {
				ie_len = ie_data[TLV_LEN_OFF] + TLV_HDR_LEN;
				if (len < ie_len) {
					err = BCME_BUFTOOSHORT;
					break;
				}
				bcopy(ie_data, (uint8*)arg, ie_len);
			} else {
				err = BCME_NOTFOUND;
			}
		}

		break;
	}
	case IOV_SVAL(IOV_VNDR_IE):
	case IOV_SVAL(IOV_IE): {
		int rem = len;
		bool bcn_upd = FALSE;
		bool prbresp_upd = FALSE;
		vndr_ie_setbuf_t *vndr_ie_bufp = (vndr_ie_setbuf_t *)arg;
		uint32 pktflag;
		uint8 *ie_data;

		if (len < (int)sizeof(ie_setbuf_t) - 1) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		bcopy((uint8 *)&vndr_ie_bufp->vndr_ie_buffer.vndr_ie_list->pktflag,
			&pktflag, sizeof(pktflag));
		ie_data = (uint8 *)&vndr_ie_bufp->vndr_ie_buffer.vndr_ie_list->vndr_ie_data;

		if ((pktflag == VNDR_IE_CUSTOM_FLAG) &&
			(ie_data[TLV_TAG_OFF] != DOT11_MNG_PROPR_ID)) {
			/* none vendor IE case */
			int iecount, i, total_len;
			bcopy((uint8 *)&vndr_ie_bufp->vndr_ie_buffer.iecount,
				&iecount, sizeof(iecount));
			total_len = sizeof(ie_setbuf_t) - sizeof(ie_info_t);
			for (i = 0; i < iecount; i++) {
				total_len += (ie_data[TLV_LEN_OFF] + TLV_HDR_LEN);
				if (len < total_len) {
					err = BCME_BUFTOOSHORT;
					break;
				}
				err = wlc_bsscfg_set_ie(bsscfg, ie_data, &bcn_upd, &prbresp_upd);
				if (err != BCME_OK)
					break;
				ie_data += (ie_data[TLV_LEN_OFF] + TLV_HDR_LEN);

			}
		} else {
			/* vendor IE case */
			/* Make a memory-aligned bcopy of the arguments in case they start
			* on an unaligned address due to a "bsscfg:N" prefix.
			*/
			if (len < (int)sizeof(vndr_ie_setbuf_t) - 1) {
				err = BCME_BUFTOOSHORT;
				break;
			}
			if (!(vndr_ie_bufp = MALLOC(wlc->osh, len))) {
				WL_ERROR(("wl%d: out of memory, malloced %d bytes\n",
					wlc->pub->unit, MALLOCED(wlc->osh)));
				err = BCME_NOMEM;
				break;
			}
			bcopy((uint8*)arg, vndr_ie_bufp, len);

			do {
				int buf_len;
				int bcn_len, prbresp_len;

				if ((buf_len = wlc_vndr_ie_buflen(&vndr_ie_bufp->vndr_ie_buffer,
					rem - VNDR_IE_CMD_LEN, &bcn_len, &prbresp_len)) < 0) {
					err = buf_len;
					break;
				}

				if (rem < VNDR_IE_CMD_LEN + buf_len) {
					err = BCME_BUFTOOSHORT;
					break;
				}

				if (!bcn_upd && bcn_len > 0)
					bcn_upd = TRUE;
				if (!prbresp_upd && prbresp_len > 0)
					prbresp_upd = TRUE;

				if (!strcmp(vndr_ie_bufp->cmd, "add")) {
					err = wlc_vndr_ie_add(bsscfg,
						&vndr_ie_bufp->vndr_ie_buffer,
						rem - VNDR_IE_CMD_LEN);
				}
				else if (!strcmp(vndr_ie_bufp->cmd, "del")) {
					err = wlc_vndr_ie_del(bsscfg,
						&vndr_ie_bufp->vndr_ie_buffer,
						rem - VNDR_IE_CMD_LEN);
				}
				else {
					err = BCME_BADARG;
				}
				if ((err != BCME_OK))
					break;

				rem -= VNDR_IE_CMD_LEN + buf_len;
				if (rem == 0)
					break;

				memmove((uint8 *)vndr_ie_bufp,
					(uint8 *)vndr_ie_bufp + VNDR_IE_CMD_LEN + buf_len, rem);

				if ((rem < (int) sizeof(vndr_ie_setbuf_t) - 1) ||
					(strcmp(vndr_ie_bufp->cmd, "add") &&
					strcmp(vndr_ie_bufp->cmd, "del"))) {
					break;
				}

			}
			while (TRUE);
			MFREE(wlc->osh, vndr_ie_bufp, len);
		}

		if (err == BCME_OK && bsscfg->up) {
			if (bcn_upd)
				wlc_bss_update_beacon(wlc, bsscfg);
			if (prbresp_upd)
				wlc_bss_update_probe_resp(wlc, bsscfg, TRUE);
		}

		break;
	}
#ifdef STA
	case IOV_SVAL(IOV_WPAIE): {
		/* Mostly used by external supplicants to set the IE
		 * on the STA, so set the assoc ie for the STA
		 */
		if (BSSCFG_AP(bsscfg)) {
			err = BCME_NOTSTA;
			break;
		}
		if (as->ie) {
			MFREE(wlc->osh, as->ie, as->ie_len);
			as->ie = NULL;
			as->ie_len = 0;
		}

		/* Just want to cleanup the elts */
		if (p_len == 0)
			break;

		if (!(as->ie = MALLOC(wlc->osh, p_len))) {
			WL_ERROR(("wl%d: out of memory, malloced %d bytes\n",
			          wlc->pub->unit, MALLOCED(wlc->osh)));
			err = BCME_NOMEM;
			break;
		}
		as->ie_len = p_len;
		bcopy((uint8*)params, as->ie, p_len);
		break;
	}
#endif /* STA */

	case IOV_GVAL(IOV_WPAIE): {
		struct ether_addr *ea;
		bcm_tlv_t *wpaie;
		uint8 *buf = (uint8 *)arg;
		int buf_len = len;
		struct scb *scb;

		if (!BSSCFG_AP(bsscfg)) {
			err = BCME_NOTAP;
			break;
		}

		ea = (struct ether_addr *)params;

		/* Is it the bsscfg bssid? If so, return wpaie and rsnie  */
		if (memcmp(ea, &bsscfg->BSSID, 6) == 0) {
			buf = wlc_write_wpa_ie_safe(wlc, buf, buf_len, bsscfg->WPA_auth,
			                            bsscfg->wsec, bsscfg, bsscfg->current_bss);
			buf_len = len - (int)(buf - (uint8 *)arg);
			buf = wlc_write_rsn_ie_safe(wlc, buf, buf_len,
			                            bsscfg->WPA_auth, bsscfg->wsec, bsscfg);
			break;
		}

		/* looking for the assoc request wpaie of an associated STA  */
		if (!(scb = wlc_scbfind(wlc, ea))) {
#if defined(BCMDBG) || defined(BCMDBG_ERR)
			char ea_str[ETHER_ADDR_STR_LEN];
#endif
			WL_ERROR(("could not find scb %s\n", bcm_ether_ntoa(ea, ea_str)));
			err = BCME_NOTFOUND;
			break;
		}

		if (scb->wpaie == NULL) {
			err = BCME_NOTFOUND;
			break;
		}

		if (len < (int)scb->wpaie_len) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		wpaie = (bcm_tlv_t *)scb->wpaie;
		bcopy(scb->wpaie, buf, wpaie->len + TLV_HDR_LEN);
		/* clear length of next IE to indicate there is no more  */
		wpaie = (bcm_tlv_t *)(buf + wpaie->len + TLV_HDR_LEN);
		wpaie->len = 0;

		break;
	}

	case IOV_GVAL(IOV_WSEC):
		*((uint*)arg) = bsscfg->wsec;
		break;

	case IOV_SVAL(IOV_WSEC):
		err = wlc_wsec(wlc, bsscfg, (uint32)int_val);
		break;

	case IOV_SVAL(IOV_WSEC_KEY): {
		wl_wsec_key_t key, *out_key = (wl_wsec_key_t *)arg;
		bcopy(arg, &key, sizeof(wl_wsec_key_t));
		if (key.index >= WSEC_MAX_DEFAULT_KEYS) {
			err = BCME_BADKEYIDX;
			break;
		}

		if (ETHER_ISMULTI(&key.ea)) {
			err = BCME_BADARG;
			break;
		}

		if (key.len == 0)
			wlc_key_remove(wlc, bsscfg, &key);
		else {
			wsec_iv_t key_iv;
			wsec_iv_t *initial_iv = NULL;
			wsec_key_t *insert_key = NULL;

			memset(&key_iv, 0, sizeof(wsec_iv_t));
			if (key.iv_initialized) {
				key_iv.hi = key.rxiv.hi;
				key_iv.lo = key.rxiv.lo;
				initial_iv = &key_iv;
			}
#ifdef STA
			if (BSSCFG_WSEC_BUF_KEY_B4_M4(bsscfg)) {
				wsec_key_buf_info_t *buf_info = bsscfg->wsec_key_buf_info;
				if (buf_info->eapol_4way_m1_rxed) {
					if (!buf_info->eapol_4way_m4_txed) {
						int buf_key_id;

						WL_WSEC(("wl%d:%s(): 4-day M4 is not Txed,"
							" buffer %s key info...\n",
							wlc->pub->unit, __FUNCTION__,
							ETHER_ISNULLADDR(&key.ea) ?
							"group" : "pairwise"));

						buf_key_id = ETHER_ISNULLADDR(&key.ea) ?
						    BSSCFG_BUF_KEY_GRP_ID : BSSCFG_BUF_KEY_PAIR_ID;
						buf_info->buf_key_iv[buf_key_id].hi = key_iv.hi;
						buf_info->buf_key_iv[buf_key_id].lo = key_iv.lo;
						memcpy(&buf_info->buf_key[buf_key_id], &key,
							sizeof(wl_wsec_key_t));
						buf_info->key_buffered[buf_key_id] = TRUE;

						break;
					}
					else
						buf_info->eapol_4way_m1_rxed = FALSE;
				}
			}
#endif /* STA */
			err = wlc_key_insert(wlc, bsscfg, key.len, key.index, key.flags, key.algo,
				key.data, &key.ea, initial_iv, &insert_key);

			if (err)
				break;

			if ((insert_key != NULL) && (insert_key->idx != key.index)) {
				WL_INFORM(("%s(): set IOV_WSEC_KEY: set gtk_idx to %d\n",
					__FUNCTION__, insert_key->idx));
				out_key->index = insert_key->idx;
			}
		}
		break;
	}

	case IOV_GVAL(IOV_WSEC_RESTRICT):
		*((uint*)arg) = bsscfg->wsec_restrict;
		break;

	case IOV_SVAL(IOV_WSEC_RESTRICT):
		bsscfg->wsec_restrict = bool_val;
		break;

	case IOV_GVAL(IOV_FRAGTHRESH):
		*((uint*)arg) = wlc->usr_fragthresh;
		break;

	case IOV_SVAL(IOV_FRAGTHRESH):
	{
		int i;
		uint16 frag = (uint16)int_val;
		if (frag < DOT11_MIN_FRAG_LEN || frag > DOT11_MAX_FRAG_LEN) {
			err = BCME_RANGE;
			break;
		}

		wlc->usr_fragthresh = frag;
		for (i = 0; i < NFIFO; i++)
			wlc->fragthresh[i] = frag;

#ifdef WLAMSDU
		wlc_amsdu_agglimit_frag_upd(wlc->ami);
#endif
		break;
	}

	/* Former offset-based items */
	case IOV_GVAL(IOV_RTSTHRESH):
		*ret_int_ptr = (int32)wlc->RTSThresh;
		break;

	case IOV_SVAL(IOV_RTSTHRESH):
		wlc->RTSThresh = (uint16)int_val;
		break;

	case IOV_GVAL(IOV_D11_AUTH):
		*ret_int_ptr = DOT11AUTH2WLAUTH(bsscfg);
		break;

	case IOV_SVAL(IOV_D11_AUTH):
		if (int_val == WL_AUTH_OPEN_SHARED) {
			bsscfg->auth = DOT11_OPEN_SYSTEM;
			bsscfg->openshared = 1;
		} else {
			bsscfg->auth = WLAUTH2DOT11AUTH(int_val);
			bsscfg->openshared = 0;
		}
		break;

#ifdef STA
	case IOV_GVAL(IOV_STA_RETRY_TIME):
		*ret_int_ptr = (int32)wlc->sta_retry_time;
		break;

	case IOV_SVAL(IOV_STA_RETRY_TIME):
		if (int_val < 0 || int_val > WLC_STA_RETRY_MAX_TIME) {
			err = BCME_RANGE;
			break;
		}
		wlc->sta_retry_time = (uint32)int_val;
		break;

	case IOV_GVAL(IOV_ASSOC_RETRY_MAX):
		*ret_int_ptr = (int32)as->retry_max;
		break;

	case IOV_SVAL(IOV_ASSOC_RETRY_MAX):
		as->retry_max = (uint8)int_val;
		break;
#ifdef WLSCANCACHE
	case IOV_GVAL(IOV_ASSOC_CACHE_ASSIST):
		*ret_int_ptr = (int32)wlc->_assoc_cache_assist;
		break;

	case IOV_SVAL(IOV_ASSOC_CACHE_ASSIST):
		wlc->_assoc_cache_assist = bool_val;
		break;
#endif /* WLSCANCACHE */
#endif /* STA */

#ifdef BCMSUP_PSK
	case IOV_GVAL(IOV_SUP_WPA):
		*ret_int_ptr = (int32)bsscfg->sup_enable_wpa;
		break;

	case IOV_SVAL(IOV_SUP_WPA):
		bsscfg->sup_enable_wpa = bool_val;
		break;

	case IOV_GVAL(IOV_SUP_WPA2_EAPVER):
		*ret_int_ptr = (int32)wlc->sup_wpa2_eapver;
		break;

	case IOV_SVAL(IOV_SUP_WPA2_EAPVER):
		wlc->sup_wpa2_eapver = int_val;
		break;
#endif /* BCMSUP_PSK */

#if defined(BCMSUP_PSK)
	case IOV_GVAL(IOV_SUP_M3SEC_OK):
		*ret_int_ptr = (int32)wlc->sup_m3sec_ok;
		break;

	case IOV_SVAL(IOV_SUP_M3SEC_OK):
		wlc->sup_m3sec_ok = bool_val;
		break;
#endif 

	case IOV_SVAL(IOV_VLAN_MODE):
		if (int_val >= AUTO && int_val <= ON)
			wlc->vlan_mode = int_val;
		break;

	case IOV_GVAL(IOV_VLAN_MODE):
		*ret_int_ptr = wlc->vlan_mode;
		break;

#ifdef WME
	case IOV_GVAL(IOV_WME):
		*ret_int_ptr = (int32)wlc->pub->_wme;
		break;

	case IOV_SVAL(IOV_WME):
		if (int_val < AUTO || int_val > ON) {
			err = BCME_RANGE;
			break;
		}

#ifdef WLAFTERBURNER
		/* wme can not be enabled if afterburner is on */
		if (int_val != OFF && wlc->afterburner_override != OFF) {
			err = BCME_BADOPTION;
			break;
		}
#endif /* WLAFTERBURNER */

		/* For AP, AUTO mode is same as ON */
		if (AP_ENAB(wlc->pub) && int_val == AUTO)
			wlc->pub->_wme = ON;
		else {
			wlc->pub->_wme = int_val;
#ifdef WLBTAMP
			if (int_val == OFF) {
				wlc->pub->_bta = (bool)int_val;
			}
#endif
		}

#ifdef STA
		/* If not in AUTO mode, PM is always allowed
		 * In AUTO mode, PM is allowed on for UAPSD enabled AP
		 */
		if (int_val != AUTO) {
			int idx;
			wlc_bsscfg_t *bc;

			FOREACH_BSS(wlc, idx, bc) {
				if (!BSSCFG_STA(bc))
					continue;
				bc->pm->WME_PM_blocked = FALSE;
			}
		}
#endif

		break;

	case IOV_GVAL(IOV_WME_BSS_DISABLE):
		*ret_int_ptr = ((bsscfg->flags & WLC_BSSCFG_WME_DISABLE) != 0);
		break;

	case IOV_SVAL(IOV_WME_BSS_DISABLE):
		WL_INFORM(("%s(): set IOV_WME_BSS_DISABLE to %s\n", __FUNCTION__,
			bool_val ? "TRUE" : "FALSE"));
		if (bool_val) {
			bsscfg->flags |= WLC_BSSCFG_WME_DISABLE;
		} else {
			bsscfg->flags &= ~WLC_BSSCFG_WME_DISABLE;
		}
		break;

	case IOV_GVAL(IOV_WME_NOACK):
		*ret_int_ptr = (int32)wlc->wme_noack;
		break;

	case IOV_SVAL(IOV_WME_NOACK):
		wlc->wme_noack = bool_val;
		break;

	case IOV_GVAL(IOV_WME_APSD):
		*ret_int_ptr = (int32)wlc->wme_apsd;
		break;

	case IOV_SVAL(IOV_WME_APSD):
		wlc->wme_apsd = bool_val;
		if (AP_ENAB(wlc->pub) && wlc->clk) {
			wlc_update_beacon(wlc);
			wlc_update_probe_resp(wlc, TRUE);
		}
		break;

	case IOV_SVAL(IOV_SEND_FRAME): {
		bool status;
		osl_t *osh = wlc->osh;
		void *pkt;

		/* Reject runts and jumbos */
		if (p_len < ETHER_MIN_LEN || p_len > ETHER_MAX_LEN || params == NULL) {
			err = BCME_BADARG;
			break;
		}
		pkt = PKTGET(osh, p_len + TXOFF, TRUE);
		if (pkt == NULL) {
			err = BCME_NOMEM;
			break;
		}

		PKTPULL(osh, pkt, TXOFF);
		bcopy(params, PKTDATA(osh, pkt), p_len);
		PKTSETLEN(osh, pkt, p_len);
		status = wlc_sendpkt(wlc, pkt, wlcif);
		if (status)
			err = BCME_NORESOURCE;
		break;
	}

#ifdef STA
	case IOV_GVAL(IOV_WME_APSD_TRIGGER):
	        *ret_int_ptr = (int32)pm->apsd_trigger_timeout;
		break;

	case IOV_SVAL(IOV_WME_APSD_TRIGGER):
	        /*
		 * Round timeout up to an even number because we set
		 * the timer at 1/2 the timeout period.
		 */
	        pm->apsd_trigger_timeout = ROUNDUP((uint32)int_val, 2);
		wlc_apsd_trigger_upd(bsscfg, TRUE);
		break;

	case IOV_GVAL(IOV_WME_TRIGGER_AC):
		*ret_int_ptr = (int32)wlc->apsd_trigger_ac;
		break;

	case IOV_SVAL(IOV_WME_TRIGGER_AC):
		if (int_val <= AC_BITMAP_ALL)
			wlc->apsd_trigger_ac = (ac_bitmap_t)int_val;
		else
			err = BCME_BADARG;
		break;

	case IOV_GVAL(IOV_WME_AUTO_TRIGGER):
		*ret_int_ptr = (int32)wlc->apsd_auto_trigger;
		break;

	case IOV_SVAL(IOV_WME_AUTO_TRIGGER):
		wlc->apsd_auto_trigger = bool_val;
		break;

	case IOV_SVAL(IOV_SEND_NULLDATA): {
#if defined(BCMDBG) || defined(BCMDBG_ERR)
		char eabuf[ETHER_ADDR_STR_LEN];
#endif
		struct scb *scb;

		/* check: broadcast ea should not be send by a sta connected to an AP */
		if (bsscfg->BSS && BSSCFG_STA(bsscfg) && ETHER_ISMULTI(params)) {
			WL_ERROR(("wl%d: IOV_SEND_NULLDATA: unable to send broadcast frame\n",
				wlc->pub->unit));
			err = BCME_NOTAP;
		}
		/* Check if we can find an scb */
		else if ((scb = wlc_scbfind(wlc, (struct ether_addr *) params)) == NULL) {
			WL_ERROR(("wl%d: IOV_SEND_NULLDATA: failed to find scb\n",
			          wlc->pub->unit));
			err = BCME_BADARG;
		}
		/* transmit routine */
		else if (wlc_sendapsdtrigger(wlc, scb) == NULL) {
			WL_ERROR(("wl%d: IOV_SEND_NULLDATA: unable to send null frame to"
			          " the mac addr %s\n",
			          wlc->pub->unit, bcm_ether_ntoa(params, eabuf)));
			err = BCME_BADARG;
		}
		break;
	}

#endif /* STA */

	case IOV_GVAL(IOV_WME_DP):
		*ret_int_ptr = (int32)wlc->wme_dp;
		break;

	case IOV_SVAL(IOV_WME_DP):
		wlc->wme_dp = (uint8)int_val;
		wlc->wme_dp2precmap = convert_acbitmap_to_precbitmap(wlc->wme_dp);
		break;

#if defined(WLCNT)
	case IOV_GVAL(IOV_WME_COUNTERS):
		bcopy(wlc->pub->_wme_cnt, arg, sizeof(wl_wme_cnt_t));
		break;
	case IOV_SVAL(IOV_WME_CLEAR_COUNTERS):
		/* Zero the counters but reinit the version and length */
		bzero(wlc->pub->_wme_cnt,  sizeof(wl_wme_cnt_t));
		WLCNTSET(wlc->pub->_wme_cnt->version, WL_WME_CNT_VERSION);
		WLCNTSET(wlc->pub->_wme_cnt->length, sizeof(wl_wme_cnt_t));
		break;
#endif
	case IOV_GVAL(IOV_WME_PREC_QUEUING):
		*ret_int_ptr = wlc->wme_prec_queuing ? 1 : 0;
		break;
	case IOV_SVAL(IOV_WME_PREC_QUEUING):
		wlc->wme_prec_queuing = bool_val;
		break;

#ifdef STA
	case IOV_GVAL(IOV_WME_QOSINFO):
		*ret_int_ptr = wlc->apsd_sta_qosinfo;
		break;

	case IOV_SVAL(IOV_WME_QOSINFO):
		wlc->apsd_sta_qosinfo = (uint8)int_val;
		break;
#endif /* STA */
#endif /* WME */

#ifdef WMF
	case IOV_GVAL(IOV_WMF_BSS_ENABLE):
		*ret_int_ptr = bsscfg->wmf_enable;
		break;

	case IOV_SVAL(IOV_WMF_BSS_ENABLE):
		if (bool_val) {
			bsscfg->wmf_enable = 1;
			if (wlc_wmf_instance_add(wlc, bsscfg))
			{
				WL_ERROR(("Error in creating WMF instance\n"));
			}
			/* Start WMF if it is enabled for this bsscfg */
			wlc_wmf_start(bsscfg);
		} else {
			bsscfg->wmf_enable = 0;
			/* Stop WMF if it is enabled for this BSS */
			wlc_wmf_stop(bsscfg);

			/* Delete WMF instance for this bsscfg */
			wlc_wmf_instance_del(bsscfg);
		}
		break;

	case IOV_SVAL(IOV_WMF_UCAST_IGMP):
		if (int_val >= OFF && int_val <= ON)
			bsscfg->wmf_ucast_igmp = int_val;
		else
			err = BCME_RANGE;
		break;

	case IOV_GVAL(IOV_WMF_UCAST_IGMP):
		*ret_int_ptr = bsscfg->wmf_ucast_igmp;
		break;

#endif /* WMF */

#ifdef MCAST_REGEN
	case IOV_GVAL(IOV_MCAST_REGEN_BSS_ENABLE):
		*ret_int_ptr = bsscfg->mcast_regen_enable;
		break;

	case IOV_SVAL(IOV_MCAST_REGEN_BSS_ENABLE):
		if (bool_val) {
			bsscfg->mcast_regen_enable = 1;
		} else {
			bsscfg->mcast_regen_enable = 0;
		}
		break;
#endif /* MCAST_REGEN */

	case IOV_GVAL(IOV_TXC_POLICY):
		*ret_int_ptr = (int32)wlc->txc_policy;
		break;
	case IOV_SVAL(IOV_TXC_POLICY):
		wlc->txc_policy = bool_val;
		break;

#ifdef BCMDBG
	case IOV_GVAL(IOV_TXC):
		*ret_int_ptr = (int32)wlc->txc;
		break;

	case IOV_GVAL(IOV_TXC_STICKY):
		*ret_int_ptr = (int32)wlc->txc_sticky;
		break;

	case IOV_SVAL(IOV_TXC_STICKY):
		wlc->txc_sticky = bool_val;
		break;
#endif /* BCMDBG */

#ifdef WLAFTERBURNER
	case IOV_GVAL(IOV_AFTERBURNER):
		*ret_int_ptr = (int32)wlc->afterburner;
		break;

	case IOV_GVAL(IOV_AFTERBURNER_OVERRIDE):
		*ret_int_ptr = (int32)wlc->afterburner_override;
		break;

	case IOV_SVAL(IOV_AFTERBURNER_OVERRIDE):
		if (int_val < AUTO || int_val > ON) {
			err = BCME_RANGE;
		} else {
			err = wlc_abo(wlc, int_val);
		}
		break;
#endif /* WLAFTERBURNER */

	case IOV_GVAL(IOV_WLFEATUREFLAG):
		*ret_int_ptr = (int32)wlc->pub->wlfeatureflag;
		break;

	case IOV_SVAL(IOV_WLFEATUREFLAG):
		wlc->pub->wlfeatureflag = int_val;
		break;


#ifdef WET
	case IOV_GVAL(IOV_WET):
		*ret_int_ptr = (int32)wlc->wet;
		break;

	case IOV_SVAL(IOV_WET):
		if (!wlc->mac_spoof)
			wlc->wet = bool_val;
		else
			err = BCME_UNSUPPORTED;
		break;
#endif	/* WET */

#ifdef MAC_SPOOF
	case IOV_GVAL(IOV_MAC_SPOOF):
		*ret_int_ptr = (int32)wlc->mac_spoof;
		break;

	case IOV_SVAL(IOV_MAC_SPOOF):
		if (!wlc->wet && BSSCFG_STA(bsscfg) && !APSTA_ENAB(wlc->pub))
			wlc->mac_spoof = bool_val;
		else
			err = BCME_UNSUPPORTED;
		break;
#endif /* MAC_SPOOF */
#ifdef TOE
	case IOV_GVAL(IOV_TOE):
		*ret_int_ptr = (int32)wlc->pub->_toe;
		break;

	case IOV_SVAL(IOV_TOE):
		wlc->pub->_toe = bool_val;
		break;
#endif /* TOE */

#ifdef ARPOE
	case IOV_GVAL(IOV_ARPOE):
		*ret_int_ptr = (int32)wlc->pub->_arpoe;
		break;

	case IOV_SVAL(IOV_ARPOE):
		wlc->pub->_arpoe = bool_val;
		break;
#endif /* ARPOE */

#ifdef PLC
	case IOV_GVAL(IOV_PLC):
		*ret_int_ptr = (int32)wlc->pub->_plc;
		break;

	case IOV_SVAL(IOV_PLC):
		wlc->pub->_plc = bool_val;
		break;
#endif /* PLC */

	case IOV_GVAL(IOV_EAP_RESTRICT):
		*ret_int_ptr = (int32)bsscfg->eap_restrict;
		break;

	case IOV_SVAL(IOV_EAP_RESTRICT):
		bsscfg->eap_restrict = bool_val;
		break;
#if defined(BCMDBG) || defined(WLTEST)
	case IOV_GVAL(IOV_EIRP):
		*ret_int_ptr = wlc_channel_locale_flags(wlc->cmi) & WLC_EIRP;
		break;
#endif /* defined(BCMDBG) || defined(WLTEST) */

	case IOV_GVAL(IOV_CUR_ETHERADDR):
		bcopy(&bsscfg->cur_etheraddr, arg, ETHER_ADDR_LEN);
		break;

	case IOV_SVAL(IOV_CUR_ETHERADDR):

		err = wlc_validate_mac(wlc, bsscfg, arg);
		break;

	case IOV_GVAL(IOV_PERM_ETHERADDR):
		bcopy(&wlc->perm_etheraddr, arg, ETHER_ADDR_LEN);
		break;
#ifdef BCMDBG
	case IOV_GVAL(IOV_RAND):
		wlc_getrand(wlc, arg, sizeof(uint16));
		break;
#endif /* BCMDBG */
	case IOV_GVAL(IOV_MPC):
		*ret_int_ptr = (int32)wlc->mpc;
		break;

	case IOV_SVAL(IOV_MPC):
		if (bool_val && !wlc_mpccap(wlc)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		wlc->mpc = bool_val;
#ifdef STA
		wlc_radio_mpc_upd(wlc);

#endif /* STA */
		break;

	case IOV_GVAL(IOV_WATCHDOG_DISABLE):
		*ret_int_ptr = (int32)wlc->watchdog_disable;
		break;

	case IOV_SVAL(IOV_WATCHDOG_DISABLE):
		wlc->watchdog_disable = bool_val;
		break;

#ifdef STA
	case IOV_GVAL(IOV_MPC_DUR):
		*ret_int_ptr = (wlc->mpc && wlc_ismpc(wlc) && !wlc->mpc_delay_off) ? wlc->mpc_dur +
			(OSL_SYSUPTIME() - wlc->mpc_laston_ts) : wlc->mpc_dur;
		break;

	case IOV_SVAL(IOV_MPC_DUR):
		wlc->mpc_dur = 0;
		wlc->mpc_laston_ts = OSL_SYSUPTIME(); /* need to do this when mpc radio is off */
		break;
#endif

	case IOV_GVAL(IOV_BCMERRORSTR):
#ifdef BCMSPACE
		strncpy((char *)arg, bcmerrorstr(wlc->pub->bcmerror), BCME_STRLEN);
#else
		snprintf((char *)arg, BCME_STRLEN, "error %d", wlc->pub->bcmerror);
#endif
		break;

	case IOV_GVAL(IOV_BCMERROR):
		*ret_int_ptr = (int32) wlc->pub->bcmerror;
		break;

#ifdef WLCNT
	case IOV_GVAL(IOV_COUNTERS):
		if (WLC_UPDATE_STATS(wlc)) {
			wlc_statsupd(wlc);
		}
		bcopy(wlc->pub->_cnt, arg, sizeof(wl_cnt_t));
		break;

#endif /* WLCNT */

#if defined(DELTASTATS)
	case IOV_GVAL(IOV_DELTA_STATS_INTERVAL):
		*ret_int_ptr = wlc->delta_stats->interval;
		break;

	case IOV_SVAL(IOV_DELTA_STATS_INTERVAL):
		wlc->delta_stats->interval = int_val;
		if (wlc->delta_stats->interval > 0) {
			/* delta stats enabled */
			wlc->delta_stats->seconds = 0;
			wlc->delta_stats->current_index = 0;
		}
		break;

	case IOV_GVAL(IOV_DELTA_STATS):
		err = wlc_get_delta_stats(wlc, arg);
		break;
#endif /* DELTASTATS */


#if defined(MACOSX)
	case IOV_GVAL(IOV_TXFIFO_SZ): {
		wl_txfifo_sz_t *ts = (wl_txfifo_sz_t *)params;
		uint block_size = 0;

		if ((uint16)int_val != WL_TXFIFO_SZ_MAGIC) {
			WL_ERROR(("txfifo_sz: wl version don't match the driver\n"));
			err = BCME_VERSION;
			break;
		}

		err = wlc_bmac_xmtfifo_sz_get(wlc->hw, ts->fifo, &block_size);
		if (err)
			break;

		ts->size = (uint16)block_size;

		bcopy(ts, arg, sizeof(*ts));
		break;
	}

	case IOV_SVAL(IOV_TXFIFO_SZ): {
		wl_txfifo_sz_t *ts = (wl_txfifo_sz_t *)params;

		if ((uint16)int_val != WL_TXFIFO_SZ_MAGIC) {
			WL_ERROR(("txfifo_sz: wl version don't match the driver\n"));
			err = BCME_VERSION;
			break;
		}

		err = wlc_xmtfifo_sz_set(wlc, ts->fifo, ts->size);
		break;
	}
#endif 

	case IOV_SVAL(IOV_DUTY_CYCLE_CCK):
		err = wlc_duty_cycle_set(wlc, int_val, FALSE, wlc->pub->up);
		if (!err)
			wlc->tx_duty_cycle_cck = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_DUTY_CYCLE_CCK):
		*ret_int_ptr = (int)wlc->tx_duty_cycle_cck;
		break;

	case IOV_SVAL(IOV_DUTY_CYCLE_OFDM):
		err = wlc_duty_cycle_set(wlc, int_val, TRUE, wlc->pub->up);
		if (!err)
			wlc->tx_duty_cycle_ofdm = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_DUTY_CYCLE_OFDM):
		*ret_int_ptr = (int)wlc->tx_duty_cycle_ofdm;
		break;

	case IOV_SVAL(IOV_DUTY_CYCLE_PWR):
	        if (int_val > 100 || int_val < 0)
			return BCME_RANGE;

		wlc->stf->tx_duty_cycle_pwr = (uint8)int_val;
		if (wlc->stf->pwr_throttle_state == WLC_PWRTHROTTLE_ON) {
			err = wlc_duty_cycle_set(wlc, int_val, TRUE, wlc->pub->up);
			err = wlc_duty_cycle_set(wlc, int_val, FALSE, wlc->pub->up);
		}
		break;

	case IOV_GVAL(IOV_DUTY_CYCLE_PWR):
		*ret_int_ptr = (int)wlc->stf->tx_duty_cycle_pwr;
		break;
	case IOV_SVAL(IOV_COUNTRY_LIST_EXTENDED):
		wlc->country_list_extended = bool_val;
		break;

	case IOV_GVAL(IOV_COUNTRY_LIST_EXTENDED):
		*ret_int_ptr = (int32)wlc->country_list_extended;
		break;

#ifdef WLCNT
	case IOV_SVAL(IOV_RESET_D11CNTS): {
		if (WLC_UPDATE_STATS(wlc)) {
			wl_cnt_t *cnt = wlc->pub->_cnt;
			wlc_statsupd(wlc);
			cnt->d11cnt_txrts_off += cnt->txrts;
			cnt->d11cnt_rxcrc_off += cnt->rxcrc;
			cnt->d11cnt_txnocts_off += cnt->txnocts;

			cnt->txfrag = cnt->txmulti = cnt->txfail =
			cnt->txretry = cnt->txretrie = cnt->rxdup =
			cnt->txrts = cnt->txnocts =
			cnt->txnoack = cnt->rxfrag = cnt->rxmulti =
			cnt->rxcrc = cnt->txfrmsnt = cnt->rxundec = cnt->rxundec_mcst = 0;
		}
		break;
	}
#endif /* WLCNT */
	case IOV_SVAL(IOV_SCANABORT):
		wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);
		break;

	case IOV_GVAL(IOV_IBSS_ALLOWED):
		*ret_int_ptr = (int32)wlc->ibss_allowed;
		break;

	case IOV_SVAL(IOV_IBSS_ALLOWED):
		wlc->ibss_allowed = bool_val;
		break;

	case IOV_GVAL(IOV_MCAST_LIST):
		/* Check input buffer length */
		maclist = (struct maclist *)arg;
		if (len < (int)(sizeof(uint32) + bsscfg->nmulticast * ETHER_ADDR_LEN)) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		*ret_int_ptr = bsscfg->nmulticast;

		/* Copy each address */
		bcopy((void *)(bsscfg->multicast), (void *)(maclist->ea),
			(bsscfg->nmulticast * ETHER_ADDR_LEN));

		break;

	case IOV_SVAL(IOV_MCAST_LIST):
		/* Store number of addresses in list */
		maclist = (struct maclist *)arg;
		bcopy(&maclist->count, &int_val, sizeof(uint32));
		if (int_val > MAXMULTILIST) {
			err = BCME_RANGE;
			break;
		}
		if (len < (int)(sizeof(uint32) + int_val * ETHER_ADDR_LEN)) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		bsscfg->nmulticast = int_val;

		/* Copy each address */
		bcopy((void *)(maclist->ea), (void *)(bsscfg->multicast),
			(bsscfg->nmulticast * ETHER_ADDR_LEN));

		break;
#ifdef WL11N
	case IOV_GVAL(IOV_NMODE):
		if (N_ENAB(wlc->pub))
			*ret_int_ptr = (wlc->pub->_n_enab == SUPPORT_HT) ? WL_11N_3x3 : WL_11N_2x2;
		else
			*ret_int_ptr = OFF;
		break;

	case IOV_SVAL(IOV_NMODE):
		err = wlc_setup_nmode(wlc, int_val);
		break;

	case IOV_GVAL(IOV_NREQD):
		*ret_int_ptr = (int32)wlc->pub->_n_reqd;
		break;

	case IOV_SVAL(IOV_NREQD):
		if ((WLC_PHY_11N_CAP(wlc->band)) && N_ENAB(wlc->pub))
			wlc->pub->_n_reqd = bool_val;
		else
			err = BCME_UNSUPPORTED;
	break;

	case IOV_GVAL(IOV_N_PROTECTION):
		*ret_int_ptr = (int32)prot->n_cfg;
		break;

	case IOV_GVAL(IOV_N_PROTECTION_OVERRIDE):
		*ret_int_ptr = (int32)prot->n_cfg_override;
		break;

	case IOV_SVAL(IOV_N_PROTECTION_OVERRIDE):
		if ((int_val != WLC_PROTECTION_AUTO) &&
		    (int_val != WLC_PROTECTION_OFF) &&
		    (int_val != WLC_PROTECTION_ON) &&
		    (int_val != WLC_PROTECTION_CTS_ONLY) &&
		    (int_val != WLC_PROTECTION_MMHDR_ONLY)) {
			err = BCME_RANGE;
			break;
		}

		wlc_protection_upd(bsscfg, WLC_PROT_N_CFG_OVR, (int8)int_val);

		if (bsscfg->associated) {
			/* let watchdog or beacon processing update protection */
		} else {
			wlc_protection_ncfg_sync(bsscfg);
		}
		break;

	case IOV_GVAL(IOV_GF_PROTECTION):
		*ret_int_ptr = (int32)prot->nongf;
		break;

	case IOV_GVAL(IOV_GF_PROTECTION_OVERRIDE):
		*ret_int_ptr = (int32)prot->nongf_override;
		break;

	case IOV_SVAL(IOV_GF_PROTECTION_OVERRIDE):
		if ((int_val != WLC_PROTECTION_AUTO) &&
		    (int_val != WLC_PROTECTION_OFF) &&
		    (int_val != WLC_PROTECTION_ON)) {
			err = BCME_RANGE;
			break;
		}

		wlc_protection_upd(bsscfg, WLC_PROT_N_NONGF_OVR, (int8)int_val);

		if (bsscfg->associated) {
			/* let watchdog or beacon processing update protection */
		} else {
			wlc_protection_n_nongf_sync(bsscfg);
		}
		break;

	case IOV_GVAL(IOV_PREAMBLE_OVERRIDE):
		*ret_int_ptr = (int32)wlc->protection->n_pam_override;
		break;

	case IOV_SVAL(IOV_PREAMBLE_OVERRIDE):
		if ((int_val != AUTO) &&
		    (int_val != WLC_N_PREAMBLE_MIXEDMODE) &&
		    (int_val != WLC_N_PREAMBLE_GF) &&
		    (int_val != WLC_N_PREAMBLE_GF_BRCM)) {
			err = BCME_RANGE;
			break;
		}

		if (WLC_PHY_11N_CAP(wlc->band)) {
			if (NREV_IS(wlc->band->phyrev, 3) ||
			    NREV_IS(wlc->band->phyrev, 4)) {
				WL_ERROR(("can't change preamble for 4322, ignore\n"));
				break;
			}

			wlc_protection_set(wlc, WLC_PROT_N_PAM_OVR, (int8)int_val);

			wlc_phy_preamble_override_set(wlc->band->pi, (int8)int_val);
		}
		break;

	case IOV_GVAL(IOV_MIMO_FT):
		*ret_int_ptr = (int8)wlc->mimoft;
		break;

	case IOV_SVAL(IOV_MIMO_FT):
		wlc->mimoft = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_OBSS_COEX):
		*ret_int_ptr = (int8)wlc->pub->_coex;
		break;

	case IOV_SVAL(IOV_OBSS_COEX):
		if (!N_ENAB(wlc->pub))
			err = BCME_UNSUPPORTED;

		if ((int_val != AUTO) &&
		    (int_val != OFF) &&
		    (int_val != ON)) {
			err = BCME_RANGE;
			break;
		}
		if (wlc->pub->_coex == int_val)
			break;

		wlc_ht_update_coex_support(wlc, (int8)int_val);
		break;

	case IOV_GVAL(IOV_OBSS_SCAN_PARAMS):
	{
		obss_params_t *obss_params;

		if (len < (int)WL_OBSS_SCAN_PARAM_LEN) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		if (BSSCFG_AP(bsscfg))
			obss_params = &wlc->obss->ap_params;
		else
			obss_params = &wlc->obss->sta_params;

		bcopy((uint8 *)obss_params, (uint8 *)arg, WL_OBSS_SCAN_PARAM_LEN);
		break;
	}

	case IOV_SVAL(IOV_OBSS_SCAN_PARAMS):
	{
		obss_params_t obss_params;

		if (BSSCFG_STA(bsscfg)) {
			err = BCME_NOTAP;
			break;
		}

		if (!N_ENAB(wlc->pub) || !COEX_ENAB(wlc->pub)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		if (len < (int)WL_OBSS_SCAN_PARAM_LEN) {
			err = BCME_BUFTOOSHORT;
			break;
		}


		bcopy(arg, (uint8 *)&obss_params, WL_OBSS_SCAN_PARAM_LEN);
		if (!wlc_ht_obss_scanparams_upd(wlc, &obss_params, bsscfg)) {
			err = BCME_BADARG;
			break;
		}

		if (wlc->pub->up) {
			wlc_update_beacon(wlc);
			wlc_update_probe_resp(wlc, TRUE);
		}
		break;
	}

	case IOV_GVAL(IOV_40_INTOLERANT):
		*ret_int_ptr = (WLC_INTOL40_OVRD(wlc) ? 1 : 0);
		break;

	case IOV_SVAL(IOV_40_INTOLERANT):
	{
		uint8 bit = int_val ? WL_COEX_40MHZ_INTOLERANT : 0;
		if (!N_ENAB(wlc->pub)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		err = wlc_ht_upd_coex_bits(wlc, bit, WL_COEX_40MHZ_INTOLERANT);
		break;
	}

	case IOV_GVAL(IOV_40_INTOLERANT_DET):
		*ret_int_ptr = ((WLC_INTOL40_DET(wlc) |
		                 bsscfg->prot_cond->ht40intolerant_assoc) ? 1 : 0);
		break;

	case IOV_SVAL(IOV_OBSS_COEX_ACTION):
	{
		wl_action_obss_coex_req_t *req = (wl_action_obss_coex_req_t *)params;
		uint8 coex_map[CH_MAX_2G_CHANNEL + 1], i;

		if (!N_ENAB(wlc->pub)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		if (SCAN_IN_PROGRESS(wlc->scan)) {
			err = BCME_ERROR;
			break;
		}

		if (req->num > ARRAYSIZE(coex_map)) {
			err = BCME_BUFTOOLONG;
			break;
		}

		if (req->num) {
			/* chanlist_len include IE hdr + 1 or more BSS intolerant
			 * Channel Report IE.
			 */
			bzero(coex_map, CH_MAX_2G_CHANNEL + 1);
			for (i = 0; i < req->num; i++) {
				if ((req->ch_list[i] > CH_MAX_2G_CHANNEL) ||
				    (req->ch_list[i] == 0))
					return BCME_BADBAND;
				coex_map[req->ch_list[i]] = 1;
			}
		}

		err = wlc_ht_send_action_obss_coex(wlc, req->info, (req->num ? coex_map : NULL),
			wlc_scbfind(wlc, &bsscfg->BSSID));
		break;
	}

	case IOV_GVAL(IOV_OBSS_TE_MASK):
		*ret_int_ptr = wlc->obss->coex_te_mask;
		break;

	case IOV_SVAL(IOV_OBSS_TE_MASK):
		wlc->obss->coex_te_mask = int_val;
		break;

	case IOV_GVAL(IOV_SGI_TX):
		*ret_int_ptr = wlc->sgi_tx;
		break;

	case IOV_SVAL(IOV_SGI_TX):
		if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
			err = BCME_RANGE;
			break;
		}

		if (!WLC_SGI_CAP_PHY(wlc)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		wlc->sgi_tx = (int8)int_val;
		break;

	case IOV_GVAL(IOV_SGI_RX):
		*ret_int_ptr = (wlc->ht_cap.cap & HT_CAP_SHORT_GI_20) ? WLC_N_SGI_20 : 0;
		*ret_int_ptr |= (wlc->ht_cap.cap & HT_CAP_SHORT_GI_40) ? WLC_N_SGI_40 : 0;
		break;

	case IOV_SVAL(IOV_SGI_RX):
		if (int_val > (WLC_N_SGI_20 | WLC_N_SGI_40)) {
			err = BCME_RANGE;
			break;
		}

		if (!WLC_SGI_CAP_PHY(wlc)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		wlc_ht_update_sgi_rx(wlc, int_val);
		break;

	case IOV_GVAL(IOV_MIMO_BW_CAP):
		*ret_int_ptr = wlc->mimo_band_bwcap;
		break;

	case IOV_SVAL(IOV_MIMO_BW_CAP):
		if ((int_val < 0) || (int_val > WLC_N_BW_20IN2G_40IN5G)) {
			err = BCME_RANGE;
			break;
		}
		wlc_update_mimo_band_bwcap(wlc, (uint8) int_val);
		break;

#if defined(BCMDBG) || defined(WLTEST)
	case IOV_GVAL(IOV_MIMO_TXBW):
		*ret_int_ptr = wlc->mimo_40txbw;
		break;

	case IOV_SVAL(IOV_MIMO_TXBW):
		if (((int_val < PHY_TXC1_BW_20MHZ) || (int_val > PHY_TXC1_BW_40MHZ_DUP)) &&
		(int_val != AUTO)) {
			err = BCME_RANGE;
			break;
		}
		wlc->mimo_40txbw = (int8)int_val;
		break;
#endif /* defined(BCMDBG) || defined(WLTEST) */

#ifdef BCMDBG
	case IOV_SVAL(IOV_AGGDBG): {
#ifdef WLC_HIGH_ONLY
		rpc_tp_info_t *rpcb = bcm_rpc_tp_get(wlc->rpc);
#endif
		int32 *shmbuf;
		int i;

		int_val2 = (int_val >> 16) & 0xffff;
		int_val = int_val & 0xffff;

#ifdef WLC_HIGH_ONLY
		bcm_rpc_tp_agg_set(rpcb, 1, TRUE);
#endif

		/* block 1 */
		shmbuf = MALLOC(wlc->osh, int_val);
		if (shmbuf == NULL) {
			printf("malloc err\n");
			break;
		}
		for (i = 0; i < int_val/4; i++)
			shmbuf[i] = i;

		wlc_bmac_copyto_shm(wlc->hw, (uint)-1, shmbuf, int_val);
		MFREE(wlc->osh, shmbuf, int_val);

		/* block 2 */
		shmbuf = MALLOC(wlc->osh, int_val2);
		if (shmbuf == NULL) {
			printf("malloc err\n");
			break;
		}
		for (i = 0; i < int_val2/4; i++)
			shmbuf[i] = i;

		wlc_bmac_copyto_shm(wlc->hw, (uint)-1, shmbuf, int_val2);
		MFREE(wlc->osh, shmbuf, int_val2);

		/* block 3 */
		shmbuf = MALLOC(wlc->osh, int_val2);
		if (shmbuf == NULL) {
			printf("malloc err\n");
			break;
		}
		for (i = 0; i < int_val2/4; i++)
			shmbuf[i] = i;

		wlc_bmac_copyto_shm(wlc->hw, (uint)-1, shmbuf, int_val2);
		MFREE(wlc->osh, shmbuf, int_val2);

#ifdef WLC_HIGH_ONLY
		bcm_rpc_tp_agg_set(rpcb, 1, FALSE);
#endif
		break;
	}
#endif /* BCMDBG */

	case IOV_GVAL(IOV_OBSS_COEX_ACTIVE):
		*ret_int_ptr = (int8)(wlc->obss->coex_enab);
		break;

	case IOV_GVAL(IOV_OBSS_WIDTH20_DET):
		*ret_int_ptr = (WLC_WIDTH20_DET(wlc) ? 1 : 0);
		break;

	case IOV_GVAL(IOV_OBSS_WIDTH20):
		*ret_int_ptr = (WLC_WIDTH20_OVRD(wlc) ? 1 : 0);
		break;

	case IOV_GVAL(IOV_GF_CAP):

		if (!WLC_PHY_11N_CAP(wlc->band)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		*ret_int_ptr = (wlc->ht_cap.cap & HT_CAP_GF) ? 1 : 0;
		break;

#ifdef BCMDBG
	case IOV_SVAL(IOV_OBSS_WIDTH20):
	{
		uint8 bit = int_val ? WL_COEX_WIDTH20 : 0;
		if (!N_ENAB(wlc->pub) || !COEX_ENAB(wlc->pub)) {
			err = BCME_UNSUPPORTED;
			break;
		}

		err = wlc_ht_upd_coex_bits(wlc, bit, WL_COEX_WIDTH20);
		break;
	}

	case IOV_GVAL(IOV_OFDM_TXBW):
		*ret_int_ptr = wlc->ofdm_40txbw;
		break;

	case IOV_SVAL(IOV_OFDM_TXBW):
		if (((int_val < PHY_TXC1_BW_20MHZ) || (int_val > PHY_TXC1_BW_40MHZ_DUP) ||
		(int_val == PHY_TXC1_BW_40MHZ)) && (int_val != AUTO)) {
			err = BCME_RANGE;
			break;
		}
		wlc->ofdm_40txbw = (int8)int_val;
		break;

	case IOV_GVAL(IOV_CCK_TXBW):
		*ret_int_ptr = wlc->cck_40txbw;
		break;

	case IOV_SVAL(IOV_CCK_TXBW):
		if (((int_val < PHY_TXC1_BW_20MHZ) || (int_val > PHY_TXC1_BW_40MHZ_DUP) ||
		(int_val == PHY_TXC1_BW_40MHZ) || (int_val == PHY_TXC1_BW_40MHZ_DUP)) &&
		(int_val != AUTO)) {
			err = BCME_RANGE;
			break;
		}
		wlc->cck_40txbw = (int8)int_val;
		break;

	case IOV_GVAL(IOV_TXBURST_LIM):
		*ret_int_ptr = (int32)wlc->txburst_limit;
		break;

	case IOV_GVAL(IOV_HTPHY_MEMBERSHIP):
		*ret_int_ptr = (int32)(wlc->htphy_membership ? TRUE : FALSE);
		break;

	case IOV_SVAL(IOV_HTPHY_MEMBERSHIP):
		wlc->htphy_membership = (bool_val ? (WLC_HTPHY | WLC_RATE_FLAG) : 0);
		break;

	case IOV_GVAL(IOV_OFDM_ASSOC):
		*ret_int_ptr = bsscfg->prot_cond->ofdm_assoc ? 1 : 0;
		break;
	case IOV_GVAL(IOV_NONERP_ASSOC):
		*ret_int_ptr = bsscfg->prot_cond->nonerp_assoc ? 1 : 0;
		break;
#endif /* BCMDBG */

	case IOV_GVAL(IOV_CURR_MCSSET):
		if (bsscfg->associated)
			bcopy(&current_bss->rateset.mcs[0], arg, MCSSET_LEN);
		else
			bcopy(&wlc->default_bss->rateset.mcs[0], arg, MCSSET_LEN);
		break;

	case IOV_GVAL(IOV_RIFS):
		*ret_int_ptr = wlc->_rifs;
		break;

	case IOV_SVAL(IOV_RIFS):
		/* frameburst has to be enabled for RIFS */
		if (int_val && !wlc->frameburst) {
			err = BCME_NOTREADY;
			break;
		}
		wlc->_rifs = (uint8)int_val;
		if (wlc->pub->up) {
			if (wlc->_rifs) {
				wlc_write_shm(wlc, M_MBURST_TXOP, (EDCF_AC_VO_TXOP_AP << 5));
			} else {
				wlc_write_shm(wlc, M_MBURST_TXOP, MAXFRAMEBURST_TXOP);
			}
			/* pass _rifs flag down to wlc_hw_info structure */
			/* and update PHY holdoff and delay registers */
			wlc_phy_tkip_rifs_war(wlc->band->pi, wlc->_rifs);
		}
		break;

	case IOV_GVAL(IOV_RIFS_ADVERT):
		*ret_int_ptr = wlc->rifs_mode;
		break;

	case IOV_SVAL(IOV_RIFS_ADVERT):
		wlc->rifs_advert = int_val;

		/* Modify the RIFS mode bit in the beacon and probe response
		 * frames. This is to indicate to STAs if RIFS is permitted
		 * in the BSS or not.
		 */
		if (AP_ENAB(wlc->pub)) {
			wlc_update_beacon(wlc);
			wlc_update_probe_resp(wlc, TRUE);
		}
		break;

	case IOV_GVAL(IOV_LDPC_CAP):
		if (!WLCISHTPHY(wlc->band)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		*ret_int_ptr = (int32)wlc->stf->ldpc;
		break;

	case IOV_SVAL(IOV_LDPC_CAP):
		if (!WLCISHTPHY(wlc->band)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		if ((int_val != OFF) && (int_val != ON)) {
			err = BCME_RANGE;
			break;
		}

		if (wlc->stf->ldpc != (int8)int_val)
			wlc_ht_update_ldpc(wlc, (int8)int_val);
		break;

#ifdef BCMDBG
	case IOV_GVAL(IOV_LDPC_TX):
		if (!WLCISHTPHY(wlc->band)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		*ret_int_ptr = (int32)wlc->stf->ldpc_tx;
		break;

	case IOV_SVAL(IOV_LDPC_TX):
		if (!WLCISHTPHY(wlc->band)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		if ((int_val != AUTO) && (int_val != OFF) && (int_val != ON)) {
			err = BCME_RANGE;
			break;
		}

		wlc->stf->ldpc_tx = (int8)int_val;
		break;
#endif /* BCMDBG */

#endif /* WL11N */

	case IOV_GVAL(IOV_CHANSPECS): {
		chanspec_t chanspec = *((chanspec_t *)params);
		char abbrev[WLC_CNTRY_BUF_SZ];
		wl_uint32_list_t *list = (wl_uint32_list_t *)arg;

		bzero(abbrev, WLC_CNTRY_BUF_SZ);
		strncpy(abbrev, ((char*)params + sizeof(chanspec_t)), WLC_CNTRY_BUF_SZ - 1);

		list->count = 0;
		if (CHSPEC_IS2G(chanspec) || (chanspec == 0)) {
			if (CHSPEC_IS20(chanspec) || (chanspec == 0))
				wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, TRUE, abbrev);
			if (CHSPEC_IS40(chanspec) || (chanspec == 0))
				wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, TRUE, abbrev);
		}
		if (CHSPEC_IS5G(chanspec) || (chanspec == 0)) {
			if (CHSPEC_IS20(chanspec) || (chanspec == 0))
				wlc_get_valid_chanspecs(wlc->cmi, list, TRUE, FALSE, abbrev);
			if (CHSPEC_IS40(chanspec) || (chanspec == 0))
				wlc_get_valid_chanspecs(wlc->cmi, list, FALSE, FALSE, abbrev);
		}
		ASSERT(list->count < WL_NUMCHANSPECS);
		break;
	}

	case IOV_GVAL(IOV_CHANSPEC):
		if (bsscfg->associated)
			*ret_int_ptr = (int32)current_bss->chanspec;
		else
			*ret_int_ptr = (int32)wlc->default_bss->chanspec;
		break;

	case IOV_SVAL(IOV_CHANSPEC): {
		chanspec_t chspec = (chanspec_t)int_val;

		if (wf_chspec_malformed(chspec)) {
			err = BCME_BADCHAN;
			break;
		}

		if (!wlc_valid_chanspec_db(wlc->cmi, chspec)) {
			err = BCME_BADCHAN;
			break;
		}


#if defined(AP) && defined(RADAR)
		/* allow channel override for BCMINTERNAL and WLTEST build */
		if (AP_ENAB(wlc->pub))
			wlc_dfs_setchanspec(wlc->ap, chspec);
#endif

		if (!wlc->pub->up && IS_MBAND_UNLOCKED(wlc)) {
			if (wlc->band->bandunit != CHSPEC_WLCBANDUNIT(chspec))
				wlc->bandinit_pending = TRUE;
			else
				wlc->bandinit_pending = FALSE;
		}

		/* want to migrate to use bsscfg->chanspec as the configured chanspec
		 * and wlc->chanspec as the current chanspec.
		 * wlc->default_bss->chanspec would have no meaning
		 */
		wlc->default_bss->chanspec = chspec;

#ifdef AP
		wlc->chanspec_selected = chspec;
#endif

#ifdef WLMCHAN
		if (MCHAN_ENAB(wlc->pub))
			bsscfg->chanspec = chspec;
#endif /* WLMCHAN */

		/* wlc_BSSinit() will sanitize the rateset before using it.. */

		if (wlc->pub->up && !wlc->pub->associated &&
		    (WLC_BAND_PI_RADIO_CHANSPEC != chspec)) {
			wlc_set_home_chanspec(wlc, chspec);
			wlc_suspend_mac_and_wait(wlc);
			wlc_set_chanspec(wlc, chspec);
			wlc_enable_mac(wlc);
		}
		break;
	}

#if defined(WL11N) || defined(WLTEST)
	case IOV_GVAL(IOV_NRATE):
	{
		wlcband_t *cur_band = wlc->band;
		ratespec_t rspec;

		if (bsscfg->associated)
			cur_band = wlc->bandstate[CHSPEC_IS2G(current_bss->chanspec) ?
				BAND_2G_INDEX : BAND_5G_INDEX];

		rspec = wlc_get_rspec_history(bsscfg);

		*ret_int_ptr = (rspec & RSPEC_RATE_MASK);
		*ret_int_ptr |= RSPEC_STF(rspec) << NRATE_STF_SHIFT;

		if (IS_MCS(rspec))
			*ret_int_ptr |= NRATE_MCS_INUSE;
		if ((cur_band->rspec_override & RSPEC_OVERRIDE))
			*ret_int_ptr |= RSPEC_OVERRIDE;
		if ((cur_band->rspec_override & RSPEC_OVERRIDE_MCS_ONLY))
			*ret_int_ptr |= RSPEC_OVERRIDE_MCS_ONLY;
		break;
	}

	case IOV_SVAL(IOV_NRATE):
	{
		wlcband_t *cur_band = wlc->band;

		if (bsscfg->associated)
			cur_band = wlc->bandstate[CHSPEC_IS2G(current_bss->chanspec) ?
				BAND_2G_INDEX : BAND_5G_INDEX];

		err = wlc_set_nrate_override(wlc, cur_band, int_val);
		break;
	}
#endif /* defined(WL11N) || defined(WLTEST) */

//#if defined(WLTEST)
	case IOV_SVAL(IOV_PKTENG): {
		wl_pkteng_t pkteng;
		void *pkt = NULL;
		uint32 pkteng_flags;

		if (D11REV_LT(wlc->pub->corerev, 11))
			return BCME_UNSUPPORTED;

		bcopy(params, &pkteng, sizeof(wl_pkteng_t));
		pkteng_flags = pkteng.flags  & WL_PKTENG_PER_MASK;

		if (pkteng.length + TXOFF > PKTBUFSZ)
			return BCME_BADLEN;

		/* Prepare the packet for Tx */
		if ((pkteng_flags == WL_PKTENG_PER_TX_START) ||
			(pkteng_flags == WL_PKTENG_PER_TX_WITH_ACK_START)) {
			struct ether_addr *sa;

			/* Don't allow pkteng to start if associated */
			if (wlc->pub->associated)
				return BCME_ASSOCIATED;
			if (!wlc->band->rspec_override)
				return BCME_ERROR;

			sa = (ETHER_ISNULLADDR(&pkteng.src)) ?
				&wlc->pub->cur_etheraddr : &pkteng.src;
			/* pkt will be freed in wlc_bmac_pkteng() */
			pkt = wlc_tx_testframe(wlc, &pkteng.dest, sa,
				0, pkteng.length);
			if (pkt == NULL)
				return BCME_ERROR;

#ifdef WLC_HIGH_ONLY
			/* For the returning txstatus */
			wlc_rpctx_pkteng(wlc->rpctx, TX_DATA_FIFO, pkt);
#endif /* WLC_HIGH_ONLY */
		}

		err = wlc_bmac_pkteng(wlc->hw, &pkteng, pkt);
		break;
	}

	case IOV_GVAL(IOV_PKTENG_MAXLEN): {
		*ret_int_ptr = wlc->pkteng_maxlen;
		break;
	}
#if defined(WLTEST)
	case IOV_GVAL(IOV_BOARDFLAGS): {
		*ret_int_ptr = wlc->pub->boardflags;
		break;
	}

	case IOV_SVAL(IOV_BOARDFLAGS): {
		wlc->pub->boardflags = int_val;

		/* This iovar needs to be done at both host and dongle */
		err = wlc_bmac_iovars_dispatch(wlc->hw, IOV_SVAL(IOV_BMAC_BOARDFLAGS),
			vi->type, arg, len, arg, len, val_size);
		break;
	}

	case IOV_GVAL(IOV_BOARDFLAGS2): {
		*ret_int_ptr = wlc->pub->boardflags2;
		break;
	}

	case IOV_SVAL(IOV_BOARDFLAGS2): {
		wlc->pub->boardflags2 = int_val;

#ifdef WL11N
		/* Re-attach antsel module */
		if (wlc->asi) {
			wlc_antsel_detach(wlc->asi);
			wlc->asi = NULL;
		}
		if ((wlc->asi = wlc_antsel_attach(wlc, wlc->osh, wlc->pub, wlc->hw)) == NULL) {
			WL_ERROR(("wl%d: wlc_attach: wlc_antsel_attach failed\n", wlc->pub->unit));
			ASSERT(0);
		}
#endif /* WL11N */

		/* This iovar needs to be done at both host and dongle */
		err = wlc_bmac_iovars_dispatch(wlc->hw, IOV_SVAL(IOV_BMAC_BOARDFLAGS2),
			vi->type, arg, len, arg, len, val_size);
		break;
	}

	case IOV_GVAL(IOV_ANTGAIN): {
		uint8	*ag = (uint8*)arg;
		uint j;

		ag[0] = 0;
		ag[1] = 0;

		for (j = 0; j < NBANDS(wlc); j++) {
			/* Use band 1 for single band 11a */
			if (IS_SINGLEBAND_5G(wlc->deviceid))
				j = BAND_5G_INDEX;

			/* Compute Antenna Gain */
			ag[j] = wlc->bandstate[j]->antgain >> 2;
		}
		break;
	}

	case IOV_SVAL(IOV_ANTGAIN): {
		uint8	*ag = (uint8*)params;
		uint j;

		for (j = 0; j < NBANDS(wlc); j++) {
			/* Use band 1 for single band 11a */
			if (IS_SINGLEBAND_5G(wlc->deviceid))
				j = BAND_5G_INDEX;

			wlc->band = wlc->bandstate[j];

			/* Compute Antenna Gain */
			wlc->band->antgain = BAND_5G(wlc->band->bandtype) ? ag[1] : ag[0];

			wlc_attach_antgain_init(wlc);
		}
		break;
	}

	case IOV_GVAL(IOV_NVRAM_GET): {
		char *nv_str;

		nv_str = getvar(wlc->pub->vars, params);

		if (nv_str != NULL) {
			size_t nv_len = strlen(nv_str);
			if ((size_t)len < nv_len + 1)
				err = BCME_BUFTOOSHORT;
			else {
				char *dst = (char *)arg;
				strncpy(dst, nv_str, nv_len);
				dst[nv_len] = '\0';
			}
		} else {
			err = BCME_NOTFOUND;
		}
		break;
	}

	case IOV_GVAL(IOV_NVRAM_DUMP):
		bcm_binit(&b, (char*)arg, len);
		err = wlc_nvram_dump(wlc, &b);
		break;
#endif 

#if (defined(BCMNVRAMR) || defined(BCMNVRAMW)) && defined(WLTEST)
#ifdef BCMNVRAMW
	case IOV_SVAL(IOV_CISWRITE):
	{
		cis_rw_t cis;
		uint16 *tbuf;

		ASSERT(len >= (int)sizeof(cis));
		bcopy(arg, &cis, sizeof(cis));
		len -= sizeof(cis);
		arg = (uint8 *)arg + sizeof(cis);

		/* Basic validity checks.  For now retain 2-byte mode, insist on byteoff 0 */
		if (cis.source || (cis.byteoff & 1) || (cis.nbytes & 1) || cis.byteoff) {
			err = BCME_BADARG;
			break;
		}

		/* Use a temp buffer to ensure alignment */
		if ((tbuf = (uint16*)MALLOC(wlc->osh, cis.nbytes)) == NULL) {
			err = BCME_NOMEM;
			break;
		}
		bcopy(arg, tbuf, cis.nbytes);
		ltoh16_buf(tbuf, cis.nbytes);

		err = wlc_bmac_ciswrite(wlc->hw, &cis, tbuf, len);

		MFREE(wlc->osh, tbuf, cis.nbytes);
		break;
	}
#endif /* BCMNVRAMW */

	case IOV_GVAL(IOV_CISDUMP):
	{
		cis_rw_t cis;
		uint16 *tbuf = NULL;

		/* Extract parameters (to allow length spec) */
		if ((p_len < sizeof(cis)) || (len < (int)sizeof(cis))) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(params, &cis, sizeof(cis));

		/* Some basic consistency checks */
		if (cis.source || cis.byteoff || (cis.nbytes & 1) || (cis.nbytes > SROM_MAX)) {
			err = BCME_BADARG;
			break;
		}

		/* Use a temp buffer to ensure alignment */
		if ((tbuf = (uint16*)MALLOC(wlc->osh, SROM_MAX)) == NULL) {
			err = BCME_NOMEM;
			break;
		}
		memset(tbuf, 0, SROM_MAX);

		/* Adjust length to available bytes */
		len -= sizeof(cis);

		/* Read the CIS */
		err = wlc_bmac_cisdump(wlc->hw, &cis, tbuf, len);

		/* Prepare return buffer */
		if (!err) {
			bcopy(&cis, arg, sizeof(cis));
			htol16_buf(tbuf, cis.nbytes);
			bcopy(tbuf, (char*)arg + sizeof(cis), cis.nbytes);
		}

		MFREE(wlc->osh, tbuf, SROM_MAX);
		break;
	}
#endif 

	case IOV_GVAL(IOV_LIFETIME):
	{
		wl_lifetime_t *lifetime = (wl_lifetime_t *)arg;

		if (int_val < AC_COUNT) {
			lifetime->ac = int_val;
			lifetime->lifetime = wlc->lifetime[int_val] / 1000; /* us -> ms */
		}
		else
			err = BCME_BADARG;

		break;
	}

	case IOV_SVAL(IOV_LIFETIME):
	{
		wl_lifetime_t lifetime;

		bcopy(arg, &lifetime, sizeof(wl_lifetime_t));
		if (lifetime.ac < AC_COUNT && lifetime.lifetime <= WL_LIFETIME_MAX) {
			wlc->lifetime[lifetime.ac] = lifetime.lifetime * 1000; /* ms ->us */

			wlc_rfaware_lifetime_set(wlc, wlc->rfaware_lifetime);
		} else
			err = BCME_BADARG;

		break;
	}
#ifdef RWL_DONGLE
	case IOV_GVAL(IOV_RWLDONGLE_DATA):
		/* Wait for serial protocol layer to set the packet_status bit
		  *  if bit set then copy the data in arg
		  *  reset the packet_status bit
		  * if not set send 0 to server application
		  */
		if (g_rwl_dongle_data.packet_status) {
			if (g_rwl_dongle_data.packet_buf != NULL) {
				bcopy(g_rwl_dongle_data.packet_buf, (char*)arg,
				 g_rwl_dongle_data.packet_len);
				MFREE(NULL, g_rwl_dongle_data.packet_buf,
				 g_rwl_dongle_data.packet_len);
			}
			g_rwl_dongle_data.packet_status = 0;
		} else {
			uint status = 0;
			bcopy(&status, arg, sizeof(status));
		}
		break;
	case IOV_SVAL(IOV_RWLDONGLE_DATA):
		/* Tranmit the server response to client
		 * Code junps to hndrte_cons.c at this point
		 */
		remote_uart_tx(arg);
		break;
	case IOV_GVAL(IOV_DONGLE_FLAG):
		{
			*ret_int_ptr = g_rwl_dongle_flag;
			break;
		}
	case IOV_SVAL(IOV_DONGLE_FLAG):
		{
			g_rwl_dongle_flag = int_val;
			break;
		}
#endif /* RWL_DONGLE */

#ifdef WIFI_ACT_FRAME
	case IOV_SVAL(IOV_ACTION_FRAME):
		if (wlc->pub->up) {
			/* Send frame to remote client/server */
			err = wlc_send_action_frame(wlc, bsscfg, NULL, arg);
		} else {
			err = BCME_NOTUP;
		}
		break;
	case IOV_SVAL(IOV_AF): {
#ifdef STA
		uint32 channel;
		int32 dwell_time;
		bool af_continue;
#endif /* STA */
		struct ether_addr bssid;
		char *inbuf = (char *) arg;

		bcopy(&ether_bcast, &bssid, ETHER_ADDR_LEN);
#ifdef STA
		bcopy(inbuf, &channel, sizeof(channel));
		bcopy(inbuf + OFFSETOF(wl_af_params_t, dwell_time), &dwell_time,
		      sizeof(dwell_time));
		bcopy(inbuf + OFFSETOF(wl_af_params_t, BSSID), &bssid,
		      ETHER_ADDR_LEN);

		af_continue = 0;

		/* Piggyback on current scan channel if the user
		 * does not care about the channel
		 */
		if ((channel == 0) &&
		    (SCAN_IN_PROGRESS(wlc->scan) ||
		     ACT_FRAME_IN_PROGRESS(wlc->scan))) {
			af_continue = 1;
		}

		/* If not associated, need to use scan engine to bring
		 * the driver up, so have to use off-channel scanning
		 */
		if ((af_continue == 0) || !wlc->pub->associated) {
			err = wlc_send_action_frame_off_channel(wlc, bsscfg,
			                channel, dwell_time, &bssid,
			                inbuf + OFFSETOF(wl_af_params_t, action_frame));
			break;
		}
#endif /* STA */
		if (!wlc->pub->up) {
			err = BCME_NOTUP;
			break;
		}

#ifdef STA
		/* If current channel is a 'quiet' channel
		 * then reject
		 */
		if (QUIET_STATE(wlc)) {
			err = BCME_NOTREADY;
			break;
		}
#endif

		/* Send frame to remote client/server */
		err = wlc_send_action_frame(wlc, bsscfg, &bssid,
		                inbuf + OFFSETOF(wl_af_params_t, action_frame));
#ifdef STA
		if ((af_continue == 1) && dwell_time) {
			/* apply new dwell time to the channel */
			wlc_scan_timer_update(wlc->scan, dwell_time);
		}
#endif /* STA */
		break;
	}
#endif /* WIFI_ACT_FRAME */

#ifdef STA
#ifdef BCMDBG
	case IOV_GVAL(IOV_APSTA_DBG):
		*ret_int_ptr = wl_apsta_dbg;
		break;

	case IOV_SVAL(IOV_APSTA_DBG):
		wl_apsta_dbg = int_val;
		break;
#endif /* BCMDBG */

	case IOV_GVAL(IOV_IBSS_JOIN_ONLY):
		*ret_int_ptr = (int32)wlc->IBSS_join_only;
		break;
	case IOV_SVAL(IOV_IBSS_JOIN_ONLY):
		wlc->IBSS_join_only = bool_val;
		break;

	case IOV_GVAL(IOV_BCN_TIMEOUT):
		*ret_int_ptr = (int32)roam->bcn_timeout;
		break;

	case IOV_SVAL(IOV_BCN_TIMEOUT):
		roam->bcn_timeout = (uint)int_val;
		wlc_roam_thresh_upd(bsscfg);
		break;

#endif /* STA */


	case IOV_GVAL(IOV_DUMP):
#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) || defined(WLNINTENDO2)
		if (wl_msg_level & WL_LOG_VAL)
			bcmdumplog((char*)arg, len);
		else
			err = wlc_iovar_dump(wlc, (const char *)params, p_len, (char*)arg, len);
#elif defined(WLTINYDUMP)
		bcm_binit(&b, arg, len);
		err = wlc_tinydump(wlc, &b);
#else
		strcpy(arg, "N/A\n");
#endif /* defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST) || defined(WLNINTENDO2) */
		break;

	case IOV_GVAL(IOV_VER):
		bcm_binit(&b, arg, len);
		wl_dump_ver(wlc->wl, &b);

		break;

	case IOV_GVAL(IOV_COUNTRY): {
		wl_country_t *io_country = (wl_country_t*)arg;
		size_t ccode_buflen = (size_t)(len - OFFSETOF(wl_country_t, ccode));

		if (ccode_buflen < strlen(wlc_channel_ccode(wlc->cmi)) + 1) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		strncpy(io_country->country_abbrev,
			wlc_channel_country_abbrev(wlc->cmi),
			WLC_CNTRY_BUF_SZ-1);
		io_country->country_abbrev[WLC_CNTRY_BUF_SZ-1] = '\0';
		io_country->rev = wlc_channel_regrev(wlc->cmi);
		strncpy(io_country->ccode,
			wlc_channel_ccode(wlc->cmi),
			strlen(wlc_channel_ccode(wlc->cmi)) + 1);
		break;
	}

#ifndef OPENSRC_IOV_IOCTL
	case IOV_SVAL(IOV_COUNTRY): {
		char country_abbrev[WLC_CNTRY_BUF_SZ] = "";
		char ccode[WLC_CNTRY_BUF_SZ] = "";
		int32 rev = -1;

		WL_REGULATORY(("wl%d:%s(): set IOV_COUNTRY.\n", wlc->pub->unit, __FUNCTION__));
		if (len < WLC_CNTRY_BUF_SZ) {
			strncpy(country_abbrev, (char*)arg, len);
		} else {
			strncpy(country_abbrev, (char*)arg, WLC_CNTRY_BUF_SZ-1);
		country_abbrev[WLC_CNTRY_BUF_SZ-1] = '\0';
		if (country_abbrev[WLC_CNTRY_BUF_SZ - 1] != '\0') {
				err = BCME_BADLEN;
				break;
			}
		}

		if (len >= (int)sizeof(wl_country_t)) {
			rev = load32_ua((uint8*)&((wl_country_t*)arg)->rev);
			strncpy(ccode, ((wl_country_t*)arg)->ccode, WLC_CNTRY_BUF_SZ-1);
			ccode[WLC_CNTRY_BUF_SZ-1] = '\0';
		if (ccode[WLC_CNTRY_BUF_SZ - 1] != '\0') {
				err = BCME_BADLEN;
				break;
			}
		}

		if (ccode[0] == '\0')
			err = wlc_set_countrycode(wlc->cmi, country_abbrev);
		else
			err = wlc_set_countrycode_rev(wlc->cmi, country_abbrev, ccode, rev);

		if (err)
			break;

		/* the country setting may have changed our radio state */
		wlc_radio_upd(wlc);

		/* save default country for exiting 11d regulatory mode */
		strncpy(wlc->country_default, country_abbrev, WLC_CNTRY_BUF_SZ - 1);
#ifdef STA
		/* setting the country ends the search for country info */
		wlc->awaiting_cntry_info = FALSE;
#endif
		break;
	}
#endif /* OPENSRC_IOV_IOCTL */

#ifdef WL11D
	case IOV_GVAL(IOV_AUTOCOUNTRY_DEFAULT):
		if ((uint)len <= strlen(wlc->autocountry_default) + 1) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		strncpy(arg, wlc->autocountry_default, len - 1);
		break;

	case IOV_SVAL(IOV_AUTOCOUNTRY_DEFAULT): {
		char country_abbrev[WLC_CNTRY_BUF_SZ];
		int slen;

		/* find strlen, with string either null terminated or 'len' terminated */
		for (slen = 0; slen < len && ((char*)arg)[slen] != '\0'; slen++)
			;
		if (slen >= WLC_CNTRY_BUF_SZ) {
			err = BCME_BUFTOOLONG;
			break;
		}
		/* copy country code from arg avoiding overruns and null terminating */
		bzero(country_abbrev, WLC_CNTRY_BUF_SZ);
		strncpy(country_abbrev, (char*)arg, slen);

		WL_REGULATORY(("wl%d:%s(): set IOV_AUTOCOUNTRY_DEFAULT %s\n",
			wlc->pub->unit, __FUNCTION__, country_abbrev));

		if (slen == 0 || wlc_country_lookup(wlc, country_abbrev) == NULL) {
			err = BCME_BADARG;
			break;
		}
		strncpy(wlc->autocountry_default, country_abbrev, WLC_CNTRY_BUF_SZ - 1);
		break;
	}
#endif /* WL11D */
#ifdef BCMDBG
	case IOV_GVAL(IOV_COUNTRY_IE_OVERRIDE): {
		bcm_tlv_t *ie = (bcm_tlv_t*)arg;

		if (wlc->country_ie_override == NULL) {
			ie->id = DOT11_MNG_COUNTRY_ID;
			ie->len = 0;
			break;
		} else if (len < (wlc->country_ie_override->len + TLV_HDR_LEN)) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		wlc_copy_info_elt((uint8*)ie, wlc->country_ie_override);
		break;
	}

	case IOV_SVAL(IOV_COUNTRY_IE_OVERRIDE): {
		bcm_tlv_t *ie = (bcm_tlv_t*)arg;

		if (ie->id != DOT11_MNG_COUNTRY_ID || len < (ie->len + TLV_HDR_LEN)) {
			err = BCME_BADARG;
			break;
		}

		/* free any existing override */
		if (wlc->country_ie_override) {
			MFREE(wlc->osh, wlc->country_ie_override,
			      wlc->country_ie_override->len + TLV_HDR_LEN);
			wlc->country_ie_override = NULL;
		}

		/* save a copy of the Country IE override */
		wlc->country_ie_override = MALLOC(wlc->osh, ie->len + TLV_HDR_LEN);
		if (wlc->country_ie_override == NULL) {
			err = BCME_NORESOURCE;
			break;
		}
		wlc_copy_info_elt((uint8*)wlc->country_ie_override, ie);
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, TRUE);
		break;
	}
#endif /* BCMDBG */

	case IOV_GVAL(IOV_ANTENNAS):
		*ret_int_ptr = wlc_get_antennas(wlc);
		break;

#ifdef STA
	case IOV_GVAL(IOV_SCANRESULTS_MINRSSI):
		bcopy(&wlc->scanresults_minrssi, arg, sizeof(wlc->scanresults_minrssi));
		break;

	case IOV_SVAL(IOV_SCANRESULTS_MINRSSI):
		wlc->scanresults_minrssi = int_val;
		break;

	case IOV_SVAL(IOV_ESCAN): {
		uint32 escanver;
		uint16 action;
		uint16 escan_sync_id;
		char *inbuf = (char *) arg;

		bcopy(inbuf, &escanver, sizeof(escanver));
		if (escanver != ESCAN_REQ_VERSION) {
			WL_ERROR(("escan: bad version %d\n", escanver));
			err = BCME_VERSION;
			break;
		}
		bcopy(inbuf + OFFSETOF(wl_escan_params_t, action), &action, sizeof(action));
		bcopy(inbuf + OFFSETOF(wl_escan_params_t, sync_id), &escan_sync_id,
		      sizeof(escan_sync_id));

		if (action == WL_SCAN_ACTION_START) {
			/* nothing to do here */
		} else if (action == WL_SCAN_ACTION_ABORT) {
			if (ESCAN_IN_PROGRESS(wlc->scan))
				wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);
			break;
		} else {
			err = BCME_BADOPTION;
			break;
		}

		wlc->escan_sync_id = escan_sync_id;

		/* start the scan state machine */
		err = wlc_custom_scan(wlc, inbuf + OFFSETOF(wl_escan_params_t, params),
		                      len - OFFSETOF(wl_escan_params_t, params),
		                      0, WLC_ACTION_ESCAN, bsscfg);

		if (err) {
			if (err != BCME_NOTREADY) {
				wlc->custom_scan_results_state = WL_SCAN_RESULTS_ABORTED;
			}
		} else {
			/* invalidate results for other scan method's query */
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_ABORTED;
			wlc->custom_scan_results_state = WL_SCAN_RESULTS_PENDING;
		}
		break;
	}

	case IOV_SVAL(IOV_ISCAN): {
		uint32 iscanver;
		uint16 action;
		uint16 scan_duration;
		char *inbuf = (char *) arg;

		bcopy(inbuf, &iscanver, sizeof(iscanver));
		if (iscanver != ISCAN_REQ_VERSION) {
			WL_ERROR(("iscan: bad version %d\n", iscanver));
			err = BCME_VERSION;
			break;
		}
		bcopy(inbuf + OFFSETOF(wl_iscan_params_t, action), &action, sizeof(action));
		bcopy(inbuf + OFFSETOF(wl_iscan_params_t, scan_duration), &scan_duration,
		      sizeof(scan_duration));

		if (action == WL_SCAN_ACTION_START) {
			wlc->iscan_chanspec_last = 0;
			wlc->iscan_ignore_count = 0;
			if (!wlc->iscan_ignore_list) {
				wlc->iscan_ignore_list = (iscan_ignore_t *)
				    MALLOC(wlc->osh, WLC_ISCAN_IGNORE_LIST_SZ);
				if (!wlc->iscan_ignore_list) {
					err = BCME_NOMEM;
					break;
				}
			}
			bzero(wlc->iscan_ignore_list, WLC_ISCAN_IGNORE_LIST_SZ);
		} else if (action != WL_SCAN_ACTION_CONTINUE) {
			err = BCME_BADOPTION;
			break;
		}

		/* kick off the scan state machine */
		inbuf += OFFSETOF(wl_iscan_params_t, params);
		wlc->iscan_ignore_last = wlc->iscan_ignore_count;
		err = wlc_custom_scan(wlc, inbuf, len - OFFSETOF(wl_iscan_params_t, params),
		                      wlc->iscan_chanspec_last, WLC_ACTION_ISCAN,
		                      bsscfg);
		if (err)
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_ABORTED;
		else {
			if (scan_duration)
				/* specified value must allow time for at least 2 channels! */
				wl_add_timer(wlc->wl, wlc->iscan_timer,
				             scan_duration, 0);
			/* invalidate results for other scan method's query */
			wlc->custom_scan_results_state = WL_SCAN_RESULTS_ABORTED;
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_PENDING;
		}

		break;
	}

	case IOV_GVAL(IOV_ISCANRESULTS):
	{
		wl_iscan_results_t *resp = (wl_iscan_results_t *)arg;
		int buflen;

		/* BCME_BUFTOOSHORT is used only to indicate results were partial. */

		if (len < (int)WL_ISCAN_RESULTS_FIXED_SIZE) {
			err = BCME_BADARG;
			break;
		}

		/* params has in/out data, so shift it to be the start of the resp buf */
		bcopy(params, resp, WL_ISCAN_RESULTS_FIXED_SIZE);

		buflen = (int)resp->results.buflen;

		if (buflen < (int)WL_ISCAN_RESULTS_FIXED_SIZE) {
			err = BCME_BADARG;
			break;
		}

		if (buflen > len)
			buflen = len;

		buflen -= (int)WL_ISCAN_RESULTS_FIXED_SIZE;

		err = wlc_scan_results(wlc, &resp->results, &buflen,
		                       wlc->custom_iscan_results_state);
		if (err == BCME_BUFTOOSHORT)
			resp->results.buflen = buflen;
		else if (ISCAN_ABORTED(wlc))
			/* query failure: dump this round of ignore elements */
			wlc->iscan_ignore_count = wlc->iscan_ignore_last;

		resp->status = wlc->custom_iscan_results_state;
		/* response struct will have the actual status code */
		/* free results if host has retrieved all of them */
		if ((resp->status == WL_SCAN_RESULTS_SUCCESS) ||
			(resp->status == WL_SCAN_RESULTS_ABORTED))
			wlc_bss_list_free(wlc, wlc->custom_scan_results);
		err = BCME_OK;
		break;
	}
#endif /* STA */


#if defined(MACOSX)
	case IOV_GVAL(IOV_SENDUP_MGMT):
		*ret_int_ptr = (int32)bsscfg->sendup_mgmt;
		break;

	case IOV_SVAL(IOV_SENDUP_MGMT):
		bsscfg->sendup_mgmt = bool_val;
		break;
#endif

#if defined(WME_PER_AC_TUNING) && defined(WME_PER_AC_TX_PARAMS)
	case IOV_GVAL(IOV_WME_TX_PARAMS):
		if (WME_PER_AC_TX_PARAMS_ENAB(wlc->pub)) {
			int ac;
			wme_tx_params_t *prms;

			prms = (wme_tx_params_t *)arg;
			for (ac = 0; ac < AC_COUNT; ac++) {
				prms[ac].max_rate = wlc->wme_max_rate[ac];
				prms[ac].short_retry = WLC_WME_RETRY_SHORT_GET(wlc, ac);
				prms[ac].short_fallback = WLC_WME_RETRY_SFB_GET(wlc, ac);
				prms[ac].long_retry = WLC_WME_RETRY_LONG_GET(wlc, ac);
				prms[ac].long_fallback = WLC_WME_RETRY_LFB_GET(wlc, ac);
			}
		}
		break;


	case IOV_SVAL(IOV_WME_TX_PARAMS):
		if (WME_PER_AC_TX_PARAMS_ENAB(wlc->pub)) {
			int ac;
			wme_tx_params_t *prms;

			prms = (wme_tx_params_t *)arg;
			for (ac = 0; ac < AC_COUNT; ac++) {
				wlc->wme_max_rate[ac] = prms[ac].max_rate;
				WLC_WME_RETRY_SHORT_SET(wlc, ac, prms[ac].short_retry);
				WLC_WME_RETRY_SFB_SET(wlc, ac, prms[ac].short_fallback);
				WLC_WME_RETRY_LONG_SET(wlc, ac, prms[ac].long_retry);
				WLC_WME_RETRY_LFB_SET(wlc, ac, prms[ac].long_fallback);
			}
			wlc_wme_retries_write(wlc);
		}
		break;

#endif /* WME_PER_AC_TUNING && PER_AC_TX_PARAMS */


	case IOV_SVAL(IOV_IBSS_COALESCE_ALLOWED):
	       wlc->ibss_coalesce_allowed = bool_val;
	       break;

	case IOV_GVAL(IOV_IBSS_COALESCE_ALLOWED):
	       *ret_int_ptr = (int32)wlc->ibss_coalesce_allowed;
	       break;

	case IOV_SVAL(IOV_MSGLEVEL2): {
		struct wl_msglevel2 *msglevel = (struct wl_msglevel2 *)arg;
		bcopy(&msglevel->low, &wl_msg_level, sizeof(uint32));
		bcopy(&msglevel->high, &wl_msg_level2, sizeof(uint32));
		break;
	}

	case IOV_GVAL(IOV_MSGLEVEL2): {
		struct wl_msglevel2 *msglevel = (struct wl_msglevel2 *)arg;
		msglevel->low = wl_msg_level;
		msglevel->high = wl_msg_level2;
		break;
	}

#ifdef STA
	case IOV_GVAL(IOV_PSPOLL_PRD):
		*ret_int_ptr = pm->pspoll_prd;
		break;

	case IOV_SVAL(IOV_PSPOLL_PRD):
		pm->pspoll_prd = (uint8)int_val;
		wlc_pspoll_timer_upd(bsscfg, TRUE);
		break;

	case IOV_GVAL(IOV_BCN_LI_BCN):
		*ret_int_ptr = wlc->bcn_li_bcn;
		break;

	case IOV_SVAL(IOV_BCN_LI_BCN):
		wlc->bcn_li_bcn = (uint8)int_val;
	        if (wlc->pub->up)
			wlc_bcn_li_upd(wlc);
		break;

	case IOV_GVAL(IOV_BCN_LI_DTIM):
		*ret_int_ptr = wlc->bcn_li_dtim;
		break;

	case IOV_SVAL(IOV_BCN_LI_DTIM):
		wlc->bcn_li_dtim = (uint8)int_val;
	        if (wlc->pub->up)
			wlc_bcn_li_upd(wlc);
		break;

	case IOV_GVAL(IOV_ASSOC_LISTEN):
		*ret_int_ptr = as->listen;
		break;

	case IOV_SVAL(IOV_ASSOC_LISTEN):
		as->listen = (uint16)int_val;
		break;

#ifdef WL_ASSOC_RECREATE
	case IOV_SVAL(IOV_ASSOC_RECREATE): {
		int i;
		wlc_bsscfg_t *bc;

		if (wlc->pub->_assoc_recreate == bool_val)
			break;

		/* if we are turning the feature on, nothing more to do */
		if (bool_val) {
			wlc->pub->_assoc_recreate = bool_val;
			break;
		}

		/* if we are turning the feature off clean up assoc recreate state */

		/* if we are in the process of an association recreation, abort it */
		if (as->type == AS_RECREATE)
			wlc_assoc_abort(bsscfg);

		FOREACH_BSS(wlc, i, bc) {
			/* if we are down with a STA bsscfg enabled due to the preserve
			 * flag, disable the bsscfg. Without the preserve flag we would
			 * normally disable the bsscfg as we put the driver into the down
			 * state.
			 */
			if (!wlc->pub->up && BSSCFG_STA(bc) && (bc->flags & WLC_BSSCFG_PRESERVE))
				wlc_bsscfg_disable(wlc, bc);

			/* clean up assoc recreate preserve flag */
			bc->flags &= ~WLC_BSSCFG_PRESERVE;
		}

		wlc->pub->_assoc_recreate = bool_val;
		break;
	}

	case IOV_GVAL(IOV_ASSOC_RECREATE):
		*ret_int_ptr = wlc->pub->_assoc_recreate;
		break;

	case IOV_GVAL(IOV_ASSOC_PRESERVED):
	        *ret_int_ptr = as->preserved;
		break;

	case IOV_SVAL(IOV_PRESERVE_ASSOC):
		if (!ASSOC_RECREATE_ENAB(wlc->pub) && bool_val) {
			err = BCME_BADOPTION;
			break;
		}

		if (bool_val)
			bsscfg->flags |= WLC_BSSCFG_PRESERVE;
		else
			bsscfg->flags &= ~WLC_BSSCFG_PRESERVE;
		break;

	case IOV_GVAL(IOV_PRESERVE_ASSOC):
		*ret_int_ptr = ((bsscfg->flags & WLC_BSSCFG_PRESERVE) != 0);
		break;

	case IOV_SVAL(IOV_ASSOC_VERIFY_TIMEOUT):
		as->verify_timeout = (uint)int_val;
		break;

	case IOV_GVAL(IOV_ASSOC_VERIFY_TIMEOUT):
		*ret_int_ptr = (int)as->verify_timeout;
		break;

	case IOV_SVAL(IOV_RECREATE_BI_TIMEOUT):
		as->recreate_bi_timeout = (uint)int_val;
		break;

	case IOV_GVAL(IOV_RECREATE_BI_TIMEOUT):
		*ret_int_ptr = (int)as->recreate_bi_timeout;
		break;
#endif /* WL_ASSOC_RECREATE */

	case IOV_GVAL(IOV_INFRA_CONFIGURATION):
		*ret_int_ptr = wlc->default_bss->infra;
		break;

	case IOV_SVAL(IOV_INFRA_CONFIGURATION):
		if (int_val > DOT11_BSSTYPE_ANY) {
			err = BCME_RANGE;
			break;
		}
		if (AP_ENAB(wlc->pub) &&
		    int_val != DOT11_BSSTYPE_INFRASTRUCTURE) {
			err = BCME_NOTSTA;
		} else
			wlc->default_bss->infra = (uint)int_val;
		break;
#endif	/* STA */

	case IOV_SVAL(IOV_BTC_FLAGS):
		err = wlc_btc_flags_idx_set(wlc, int_val, int_val2);
		break;

	case IOV_GVAL(IOV_BTC_FLAGS): {
		*ret_int_ptr = wlc_btc_flags_idx_get(wlc, int_val);
		break;
		}

	case IOV_SVAL(IOV_BTC_PARAMS):
		err = wlc_btc_params_set(wlc, int_val, int_val2);
		break;

	case IOV_GVAL(IOV_BTC_PARAMS):
		*ret_int_ptr = wlc_btc_params_get(wlc, int_val);
		break;


	case IOV_SVAL(IOV_BTC_MODE):
		err = wlc_btc_mode_set(wlc, int_val);
		break;

	case IOV_GVAL(IOV_BTC_MODE):
		*ret_int_ptr = wlc_btc_mode_get(wlc);
		break;

	case IOV_SVAL(IOV_BTC_WIRE):
		err = wlc_btc_wire_set(wlc, int_val);
		break;

	case IOV_GVAL(IOV_BTC_WIRE):
		*ret_int_ptr = wlc_btc_wire_get(wlc);
		break;

	case IOV_SVAL(IOV_BTC_STUCK_WAR):
		wlc_btc_stuck_war50943(wlc, bool_val);
		break;

#if defined(RIM) || defined(BCMDBG) || defined(WLNINTENDO2)
	case IOV_GVAL(IOV_RATE_HISTO):{
		int min_len = sizeof(ratespec_t) * ((WLC_MAXRATE + 1) + (WLC_MAXMCS + 1));
		ratespec_t most_used_rate_spec, highest_used_ratespec;
		ratespec_t *mcs, *rates;

		if (len < min_len) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		/* Legacy rates immediately followed by mcs rates */
		rates = (ratespec_t *)arg;
		mcs = rates + WLC_MAXRATE + 1;
		bzero(arg, min_len);
		wlc_get_rate_histo_bsscfg(bsscfg, rates, mcs,
			&most_used_rate_spec, &highest_used_ratespec);
		}
		break;
#endif /* RIM */

	case IOV_GVAL(IOV_DOWN_OVERRIDE):
		*ret_int_ptr = (int32)wlc->down_override;
		break;

	case IOV_SVAL(IOV_DOWN_OVERRIDE):
		wlc->down_override = bool_val;
		break;


	case IOV_GVAL(IOV_ALLMULTI):
		*ret_int_ptr = (int32)bsscfg->allmulti;
		break;

	case IOV_SVAL(IOV_ALLMULTI):
		bsscfg->allmulti = bool_val;
		break;

	case IOV_GVAL(IOV_LEGACY_PROBE):
		*ret_int_ptr = (int32)wlc->legacy_probe;
		break;

	case IOV_SVAL(IOV_LEGACY_PROBE):
		wlc->legacy_probe = bool_val;
		break;

#ifdef AP
	case IOV_SVAL(IOV_WOWL_PKT): {
	        /* Send a Wake packet to a ea */
	        /* The format of this iovar params is
		 *   pkt_len
		 *   dst
		 *   Type of pkt - WL_WOWL_MAGIC or WL_WOWL_NET
		 *   for net pkt, wl_wowl_pattern_t
		 *   for magic pkt, dst ea, sta ea
		 */
		uint16 type;
		struct ether_addr dst;
		wl_wowl_pattern_t *wl_pattern;
		void *pkt;
		uint16 pktlen = *(uint16 *)arg;
		uint loc = 0;
		struct ether_header *eh;

		loc += sizeof(pktlen);

		bcopy(((uint8*)arg + loc), &dst, ETHER_ADDR_LEN);
		loc += ETHER_ADDR_LEN;

		type = *((uint16 *)((uint8 *)arg + loc));
		loc += sizeof(uint16);

		if (type != WL_WOWL_NET &&
		    type != WL_WOWL_MAGIC) {
			err = BCME_BADARG;
			break;
		}

		if (type == WL_WOWL_NET) {
			uint8 *pattern;
			uint8 *buf;
			wl_pattern = (wl_wowl_pattern_t *)((uint8 *)arg + loc);

			if (pktlen < (wl_pattern->offset + wl_pattern->patternsize)) {
				err = BCME_RANGE;
				break;
			}

			if ((pkt = PKTGET(wlc->osh, pktlen +
			                  sizeof(struct ether_header) + TXOFF,
			                  TRUE)) == NULL) {
				err = BCME_NOMEM;
				break;
			}

			PKTPULL(wlc->osh, pkt, TXOFF);

			eh = (struct ether_header *)PKTDATA(wlc->osh, pkt);
			buf = (uint8 *)eh;

			/* Go to end to find pattern */
			pattern = ((uint8*)wl_pattern + wl_pattern->patternoffset);
			bcopy(pattern, &buf[wl_pattern->offset], wl_pattern->patternsize);
			bcopy((char *)&wlc->pub->cur_etheraddr, (char *)eh->ether_shost,
			      ETHER_ADDR_LEN);
			if (wl_pattern->offset >= ETHER_ADDR_LEN)
				bcopy((char *)&dst, (char *)eh->ether_dhost, ETHER_ADDR_LEN);

			wl_msg_level |= WL_PRPKT_VAL;
			wlc_sendpkt(wlc, pkt, NULL);
			wl_msg_level &= ~WL_PRPKT_VAL;
		} else {
			struct ether_addr ea;
			uint8 *buf, ptr;
			int i, j;

			if (pktlen < MAGIC_PKT_MINLEN) {
				err = BCME_RANGE;
				break;
			}

			bcopy(((uint8 *)arg + loc), (char *)&ea, ETHER_ADDR_LEN);

			if ((pkt = PKTGET(wlc->osh, pktlen +
			                  sizeof(struct ether_header) + TXOFF,
			                  TRUE)) == NULL) {
				err = BCME_NOMEM;
				break;
			}
			PKTPULL(wlc->osh, pkt, TXOFF);
			eh = (struct ether_header *)PKTDATA(wlc->osh, pkt);
			bcopy((char *)&wlc->pub->cur_etheraddr, (char *)eh->ether_shost,
			      ETHER_ADDR_LEN);
			bcopy((char *)&dst, (char*)eh->ether_dhost, ETHER_ADDR_LEN);
			eh->ether_type = hton16(ETHER_TYPE_MIN);
			buf = ((uint8 *)eh + sizeof(struct ether_header));
			for (i = 0; i < 6; i++)
				buf[i] = 0xff;
			ptr = 6;
			for (j = 0; j < 16; j++) {
				bcopy(&ea, buf + ptr, ETHER_ADDR_LEN);
				ptr += 6;
			}
			wl_msg_level |= WL_PRPKT_VAL;
			wlc_sendpkt(wlc, pkt, NULL);
			wl_msg_level &= ~WL_PRPKT_VAL;
		}
	}
	        break;
#endif /* AP */

#ifdef STA
	case IOV_SVAL(IOV_ROAM_OFF):
		roam->off = bool_val;
		break;

	case IOV_GVAL(IOV_ROAM_OFF):
		*ret_int_ptr = (int32)roam->off;
		break;

	case IOV_GVAL(IOV_ASSOCROAM):
		*ret_int_ptr = (int32)roam->assocroam;
		break;

	case IOV_SVAL(IOV_ASSOCROAM):
		roam->assocroam = bool_val;
		break;

	case IOV_GVAL(IOV_FULLROAM_PERIOD):
		int_val = roam->fullscan_period;
		bcopy(&int_val, arg, val_size);
		break;

	case IOV_SVAL(IOV_FULLROAM_PERIOD):
		roam->fullscan_period = int_val;
		break;

	case IOV_GVAL(IOV_ROAM_PERIOD):
		int_val = roam->partialscan_period;
		bcopy(&int_val, arg, val_size);
		break;

	case IOV_SVAL(IOV_ROAM_PERIOD):
		roam->partialscan_period = int_val;
		break;

	case IOV_GVAL(IOV_TXFAIL_ROAMTHRESH):
		int_val = roam->minrate_txfail_thresh;
		bcopy(&int_val, arg, val_size);
		break;

	case IOV_SVAL(IOV_TXFAIL_ROAMTHRESH):
		roam->minrate_txfail_thresh = int_val;
		break;

	/* Start roam scans if we are sending too often at the min TX rate */
	/* Setting to zero disables this feature */
	case IOV_GVAL(IOV_TXMIN_ROAMTHRESH):
		*ret_int_ptr = roam->minrate_txpass_thresh;
		break;

	case IOV_SVAL(IOV_TXMIN_ROAMTHRESH):
	        roam->minrate_txpass_thresh = (uint8)int_val;
	        /* this must be set to turn off the trigger */
	        roam->txpass_thresh = (uint8)int_val;
		break;

	/* Auto-detect the AP density within the environment. '0' disables all auto-detection.
	 * Setting to AP_ENV_INDETERMINATE turns on auto-detection
	 */
	case IOV_GVAL(IOV_AP_ENV_DETECT):
	        *ret_int_ptr = (int32)roam->ap_environment;
		break;

	case IOV_SVAL(IOV_AP_ENV_DETECT):
	        roam->ap_environment = (uint8)int_val;
		break;

	/* change roaming behavior if we detect that the STA is moving */
	case IOV_GVAL(IOV_MOTION_RSSI_DELTA):
	        *ret_int_ptr = roam->motion_rssi_delta;
	        break;

	case IOV_SVAL(IOV_MOTION_RSSI_DELTA):
	        roam->motion_rssi_delta = (uint8)int_val;
	        break;

	/* Piggyback roam scans on periodic upper-layer scans, e.g. the 63sec WinXP WZC scan */
	case IOV_GVAL(IOV_SCAN_PIGGYBACK):
	        *ret_int_ptr = (int32)roam->piggyback_enab;
		break;

	case IOV_SVAL(IOV_SCAN_PIGGYBACK):
	        roam->piggyback_enab = bool_val;
		break;

	case IOV_GVAL(IOV_ROAM_RSSI_CANCEL_HYSTERESIS):
		*ret_int_ptr = wlc->roam_rssi_cancel_hysteresis;
		break;

	case IOV_SVAL(IOV_ROAM_RSSI_CANCEL_HYSTERESIS):
		wlc->roam_rssi_cancel_hysteresis = (uint8)int_val;
		break;

#if defined(WL_PM2_RCV_DUR_LIMIT)
	case IOV_GVAL(IOV_PM2_RCV_DUR):
		*ret_int_ptr = pm->pm2_rcv_percent;
		break;

	case IOV_SVAL(IOV_PM2_RCV_DUR):
		if (int_val != 0) {
			if (int_val >= WLC_PM2_RCV_DUR_MIN &&
			    int_val <= WLC_PM2_RCV_DUR_MAX) {
				pm->pm2_rcv_percent = int_val;
				pm->pm2_rcv_time = current_bss->beacon_period *
				    pm->pm2_rcv_percent/100;
			} else {
				err = BCME_RANGE;
			}
		}
		else {
			/* Setting pm2_rcv_dur = 0 disables the Receive Throttle feature */
			pm->pm2_rcv_percent = 0;
			wlc_pm2_rcv_reset(bsscfg);
		}
		break;

#endif /* WL_PM2_RCV_DUR_LIMIT */

	case IOV_GVAL(IOV_PM2_SLEEP_RET):
		*ret_int_ptr = (uint32)pm->pm2_sleep_ret_time;
		break;

	case IOV_SVAL(IOV_PM2_SLEEP_RET):
		if ((int_val < WLC_PM2_TICK_MS) || (int_val > WLC_PM2_MAX_MS)) {
			WL_ERROR(("pm2_sleep_ret should be in range %d-%d\n",
				WLC_PM2_TICK_MS, WLC_PM2_MAX_MS));
			err = BCME_RANGE;
			break;
		}
		pm->pm2_sleep_ret_time = (uint)int_val;
		pm->pm2_sleep_ret_time_left = pm->pm2_sleep_ret_time;
		break;

	case IOV_GVAL(IOV_PM2_REFRESH_BADIV):
		*ret_int_ptr = pm->pm2_refresh_badiv;
		break;

	case IOV_SVAL(IOV_PM2_REFRESH_BADIV):
		pm->pm2_refresh_badiv = bool_val;
		break;

	case IOV_GVAL(IOV_NOLINKUP):
		*ret_int_ptr = wlc->nolinkup;
		break;

	case IOV_SVAL(IOV_NOLINKUP):
		wlc->nolinkup = bool_val;
		break;
#endif /* STA */

	case IOV_GVAL(IOV_BANDUNIT):
		*ret_int_ptr = wlc->band->bandunit;
		break;


#if defined(DSLCPE_DELAY)
	case IOV_SVAL(IOV_DELAYMODE):
		if (int_val <= WL_DELAYMODE_AUTO && int_val >= WL_DELAYMODE_DEFER) {
			wlc->pub->delaymode = int_val;
		} else {
			err = BCME_RANGE;
		}
		break;

	case IOV_GVAL(IOV_DELAYMODE):
		*ret_int_ptr = wlc->pub->delaymode;
		break;
#endif

#ifdef BRCMAPIVTW
	case IOV_GVAL(IOV_BRCMAPIVTW_OVERRIDE):
		*ret_int_ptr = (int32)wlc->brcm_ap_iv_tw_override;
		break;

	case IOV_SVAL(IOV_BRCMAPIVTW_OVERRIDE):
		if (int_val < AUTO || int_val > ON) {
			err = BCME_RANGE;
			break;
		}
		wlc->brcm_ap_iv_tw_override = (int8)int_val;
		break;
#endif

#if defined(STA) && defined(ADV_PS_POLL)
	case IOV_GVAL(IOV_ADV_PS_POLL):
		*ret_int_ptr = (int32)pm->adv_ps_poll;
		break;

	case IOV_SVAL(IOV_ADV_PS_POLL):
		pm->adv_ps_poll = bool_val;
		break;
#endif /* ADV_PS_POLL */
#if defined(BCMDBG) && defined(MBSS)
	case IOV_GVAL(IOV_SRCHMEM): {
		uint reg = (uint)int_val;

		if (reg > 15) {
			err = BCME_BADADDR;
			break;
		}

		wlc_bmac_copyfrom_objmem(wlc->hw, reg * SHM_MBSS_SSIDSE_BLKSZ,
			arg, SHM_MBSS_SSIDSE_BLKSZ, OBJADDR_SRCHM_SEL);
		break;
	}
	case IOV_SVAL(IOV_SRCHMEM): {
		uint reg = (uint)int_val;
		int *parg = (int *)arg;

		/* srchmem set params:
		 *	uint32		register num
		 *	uint32		ssid len
		 *	int8[32]	ssid name
		 */

		if (reg > 15) {
			err = BCME_BADADDR;
			break;
		}

		wlc_bmac_copyto_objmem(wlc->hw, reg * SHM_MBSS_SSIDSE_BLKSZ,
			(parg + 1), SHM_MBSS_SSIDSE_BLKSZ, OBJADDR_SRCHM_SEL);
		break;
	}
#endif	/* BCMDBG && MBSS */

#ifdef WLC_HIGH_ONLY
	case IOV_SVAL(IOV_BMAC_REBOOT):
		wlc_bmac_dngl_reboot(wlc->rpc);
		break;

	case IOV_GVAL(IOV_RPC_AGG):
		*ret_int_ptr = (int32)wlc->rpc_agg;
		break;

	case IOV_SVAL(IOV_RPC_AGG):
		wlc->rpc_agg = int_val;

		/* high 16 bits are for host->dongle agg, use it directly */

		wlc_bmac_dngl_rpc_agg(wlc->rpc, wlc->rpc_agg & 0xffff);
		break;

	case IOV_GVAL(IOV_RPC_MSGLEVEL):
		*ret_int_ptr = (int32)wlc->rpc_msglevel;
		break;

	case IOV_SVAL(IOV_RPC_MSGLEVEL):
		wlc->rpc_msglevel = int_val;

		bcm_rpc_msglevel_set(wlc->rpc, (uint16)(wlc->rpc_msglevel >> 16), TRUE);
		wlc_bmac_dngl_rpc_msglevel(wlc->rpc, (uint16)(wlc->rpc_msglevel & 0xffff));
		break;

	case IOV_GVAL(IOV_RPC_DNGL_TXQ_WM):
		wlc_bmac_dngl_rpc_txq_wm_get(wlc->rpc, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_RPC_DNGL_TXQ_WM):
		wlc_bmac_dngl_rpc_txq_wm_set(wlc->rpc, (uint32)int_val);
		break;

	case IOV_GVAL(IOV_RPC_DNGL_AGG_LIMIT):
		wlc_bmac_dngl_rpc_agg_limit_get(wlc->rpc, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_RPC_DNGL_AGG_LIMIT):
		wlc_bmac_dngl_rpc_agg_limit_set(wlc->rpc, (uint32)int_val);
		break;

	case IOV_GVAL(IOV_RPC_HOST_AGG_LIMIT): {
		rpc_tp_info_t *rpcb = bcm_rpc_tp_get(wlc->rpc);
		uint8 sf;
		uint16 bytes;

		bcm_rpc_tp_agg_limit_get(rpcb, &sf, &bytes);
		*ret_int_ptr = (uint32)((sf << 16) + bytes);
		break;

	}

	case IOV_SVAL(IOV_RPC_HOST_AGG_LIMIT): {
		rpc_tp_info_t *rpcb = bcm_rpc_tp_get(wlc->rpc);
		bcm_rpc_tp_agg_limit_set(rpcb, (int_val >> 16)&0xFFFF, (int_val & 0xFFFF));
		break;
	}

	case IOV_GVAL(IOV_BMAC_DNGL_SUSPEND_ENABLE):
		bcm_rpc_dngl_suspend_enable_get(wlc->rpc, ret_int_ptr);
		break;

	case IOV_SVAL(IOV_BMAC_DNGL_SUSPEND_ENABLE):
		bcm_rpc_dngl_suspend_enable_set(wlc->rpc, (uint32)int_val);
		break;
#endif	/* WLC_HIGH_ONLY */

	case IOV_GVAL(IOV_RSSI_ANT): {
		wl_rssi_ant_t rssi_ant;

		bzero((char *)&rssi_ant, sizeof(wl_rssi_ant_t));
		rssi_ant.version = WL_RSSI_ANT_VERSION;

		/* only get RSSI for one antenna for all SISO PHY */
		if (WLCISAPHY(wlc->band) || WLCISGPHY(wlc->band) || WLCISLPPHY(wlc->band) ||
			WLCISLCNPHY(wlc->band))
		{
			rssi_ant.count = 1;
			rssi_ant.rssi_ant[0] = (int8)(bsscfg->link->rssi);

		} else if (WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band)) {
			int8 rssi[WL_RSSI_ANT_MAX] = {0, 0, 0, 0};
			uint8 i;

			wlc_rssi_ant_get(wlc, rssi);
			rssi_ant.count = WLCISHTPHY(wlc->band) ? WL_ANT_HT_RX_MAX : WL_ANT_RX_MAX;

			for (i = WL_ANT_IDX_1; i < rssi_ant.count; i++) {
				if (wlc->stf->rxchain & (1 << i))
					rssi_ant.rssi_ant[i] = rssi[i];
			}
		}
		else {
			rssi_ant.count = 0;
		}

		bcopy(&rssi_ant, arg, sizeof(wl_rssi_ant_t));
		break;
	}

	case IOV_GVAL(IOV_SNR): {
		if (WLCISLPPHY(wlc->band)) {
			*ret_int_ptr = (int32)bsscfg->link->snr;
		} else {
			err = BCME_UNSUPPORTED;
		}
		break;
	}

	case IOV_SVAL(IOV_NAV_RESET_WAR_DISABLE):
		wlc_nav_reset_war(wlc, bool_val);
		break;

	case IOV_GVAL(IOV_NAV_RESET_WAR_DISABLE):
		*ret_int_ptr = wlc->nav_reset_war_disable;
		break;
#ifdef BCMDBG
#ifdef WL11N
	case IOV_GVAL(IOV_TXMCSSET):
		wlc_get_mcsset(wlc, arg, TRUE);

		break;

	case IOV_GVAL(IOV_RXMCSSET):
		wlc_get_mcsset(wlc, arg, FALSE);

		break;
#endif /* WL11N */
#endif /* BCMDBG */

	case IOV_GVAL(IOV_RSSI_EVENT):
		memcpy(arg, bsscfg->link->rssi_event, sizeof(wl_rssi_event_t));
		break;

	case IOV_SVAL(IOV_RSSI_EVENT): {
		wlc_link_qual_t *link = bsscfg->link;
		if (link->rssi_event_timer) {
			wl_del_timer(wlc->wl, link->rssi_event_timer);
			wl_free_timer(wlc->wl, link->rssi_event_timer);
			link->rssi_event_timer = NULL;
			link->is_rssi_event_timer_active = FALSE;
		}
		link->rssi_level = 0; 	/* reset current rssi level */
		memcpy(link->rssi_event, arg, sizeof(wl_rssi_event_t));
		if (link->rssi_event->rate_limit_msec) {
			link->rssi_event_timer = wl_init_timer(wlc->wl,
				wlc_rssi_event_timeout, bsscfg, "rssi_event");
		}
		break;
	}

#ifdef STA
	case IOV_SVAL(IOV_RSSI_WINDOW_SZ):
		if (int_val > MA_WINDOW_SZ) {
			err = BCME_RANGE;
			break;
		}

		if ((int_val & (int_val - 1)) != 0) {
			/* Value passed is not power of 2 */
			err = BCME_BADARG;
			break;
		}
		bsscfg->link->rssi_pkt_win_sz = (uint16)int_val;
		wlc_lq_rssi_reset_ma(bsscfg, bsscfg->link->rssi);
		break;

	case IOV_GVAL(IOV_RSSI_WINDOW_SZ):
		*ret_int_ptr = (int32)bsscfg->link->rssi_pkt_win_sz;
		break;
#endif /* STA */

	case IOV_GVAL(IOV_RFAWARE_LIFETIME):
		*ret_int_ptr = (uint32)wlc->rfaware_lifetime;
		break;

	case IOV_SVAL(IOV_RFAWARE_LIFETIME):
		err = wlc_rfaware_lifetime_set(wlc, (uint16)int_val);
		break;


	case IOV_GVAL(IOV_ASSERT_TYPE):
		*ret_int_ptr = g_assert_type;

		break;

	case IOV_SVAL(IOV_ASSERT_TYPE):
		g_assert_type = (uint32)int_val;
#ifdef WLC_HIGH_ONLY
		wlc_bmac_assert_type_set(wlc->hw, g_assert_type);
#endif
		break;

#ifdef PHYCAL_CACHING
	case IOV_GVAL(IOV_PHYCAL_CACHE):
	        *ret_int_ptr = (int32)wlc_bmac_get_phycal_cache_flag(wlc->hw);
		break;

	case IOV_SVAL(IOV_PHYCAL_CACHE):
	        if (!bool_val) {
			if (wlc_bmac_get_phycal_cache_flag(wlc->hw)) {
				wlc_phy_cal_cache_deinit((wlc_phy_t *)wlc->band->pi);
				wlc_bmac_set_phycal_cache_flag(wlc->hw, FALSE);
				wlc_iovar_setint(wlc, "phy_percal", PHY_PERICAL_MPHASE);
			}
			break;
		}
		/* enable caching, break association, compute TX/RX IQ Cal and RSSI cal values */
		else {
			if (wlc_bmac_get_phycal_cache_flag(wlc->hw))
				break;

			if (!(WLCISNPHY(wlc->band) && NREV_GE(wlc->band->phyrev, 3)) &&
			    !WLCISHTPHY(wlc->band)) {
				WL_ERROR(("wl%d: %s: IOV_PHYCAL_CACHE: Caching only supported "
				          "on nphy rev 3 or newer and htphy\n",
				          wlc->pub->unit, __FUNCTION__));
				err = BCME_UNSUPPORTED;
			}
			else if (wlc_phy_cal_cache_init(wlc->band->pi) == BCME_OK)
				err = wlc_cache_cals(wlc);
			else
				err = BCME_NOMEM;
			break;
		}

	case IOV_GVAL(IOV_CACHE_CHANSWEEP):
	        if (wlc_bmac_get_phycal_cache_flag(wlc->hw))
			*ret_int_ptr = wlc_cachedcal_sweep(wlc);
		else {
			*ret_int_ptr = BCME_UNSUPPORTED;
			WL_ERROR(("wl%d: %s: IOV_CACHE_CHANSWEEP: PhyCal caching not enabled, "
			          "can't scan\n", wlc->pub->unit, __FUNCTION__));
		}
		break;

	case IOV_SVAL(IOV_CACHE_CHANSWEEP):
	        if (wlc_bmac_get_phycal_cache_flag(wlc->hw)) {
			if (int_val > 0 && int_val < MAXCHANNEL)
				err = wlc_cachedcal_tune(wlc, (uint16) int_val);
			else if (!wf_chspec_malformed((uint16)int_val))
				err = wlc_cachedcal_tune(wlc,
				                         (uint16) int_val & WL_CHANSPEC_CHAN_MASK);
			else
				err = BCME_BADCHAN;
			break;
		} else {
			err = BCME_UNSUPPORTED;
			WL_ERROR(("wl%d: %s: IOV_CACHE_CHANSWEEP: PhyCal caching not enabled, "
			          "can't scan\n", wlc->pub->unit, __FUNCTION__));
		}

#endif /* PHYCAL_CACHING */

	case IOV_GVAL(IOV_HT_WSEC_RESTRICT):
		*ret_int_ptr = wlc->ht_wsec_restriction;

		break;

	case IOV_SVAL(IOV_HT_WSEC_RESTRICT):
		if ((int_val < 0) || (int_val > 3))
			err = BCME_RANGE;
		else
			wlc->ht_wsec_restriction = (uint8)int_val;

		break;

	case IOV_GVAL(IOV_PM2_RADIO_SHUTOFF_DLY):
		*ret_int_ptr = wlc->pm2_radio_shutoff_dly;
		break;

	case IOV_SVAL(IOV_PM2_RADIO_SHUTOFF_DLY): {
		uint16 delay_val = (uint16) int_val;

		if (delay_val > 10) {
			err = BCME_BADARG;
			break;
		}
		wlc->pm2_radio_shutoff_dly = delay_val;
		break;
	}

	case IOV_GVAL(IOV_CHANIM_ENAB):
		*ret_int_ptr = (int32)WLC_CHANIM_ENAB(wlc);
		break;

#ifdef WLCHANIM
	case IOV_GVAL(IOV_CHANIM_STATE): {
		chanspec_t chspec;
		wlc_chanim_stats_t *stats;

		if (p_len < (int)sizeof(int)) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		chspec = (chanspec_t) int_val;

		if (wf_chspec_malformed(chspec)) {
			err = BCME_BADCHAN;
			break;
		}

		if (chspec != wlc->home_chanspec)
			stats = chanim_chanspec_to_stats(wlc->chanim_info, chspec);
		else
			stats = &wlc->chanim_info->cur_stats;

		if (!stats) {
			err = BCME_RANGE;
			break;
		}

		if (chspec == wlc->home_chanspec)
			*ret_int_ptr = (int32) chanim_mark(wlc->chanim_info).state;
		else
			*ret_int_ptr = (int32)wlc_chanim_interfered(wlc, chspec);

		break;
	}

	case IOV_SVAL(IOV_CHANIM_STATE):
		chanim_mark(wlc->chanim_info).state = (bool)int_val;
		break;

	case IOV_GVAL(IOV_CHANIM_MODE):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).mode;
		break;

	case IOV_SVAL(IOV_CHANIM_MODE):
		if (int_val > CHANIM_MODE_MAX) {
			err = BCME_RANGE;
			break;
		}

		chanim_config(wlc->chanim_info).mode = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_CCASTATS_THRES):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).ccastats_thres;
		break;

	case IOV_SVAL(IOV_CCASTATS_THRES):
		chanim_config(wlc->chanim_info).ccastats_thres = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_CRSGLITCH_THRES):
		*ret_int_ptr = chanim_config(wlc->chanim_info).crsglitch_thres;
		break;

	case IOV_SVAL(IOV_CRSGLITCH_THRES):
		chanim_config(wlc->chanim_info).crsglitch_thres = int_val;
		break;

	case IOV_GVAL(IOV_BGNOISE_THRES):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).bgnoise_thres;
		break;

	case IOV_SVAL(IOV_BGNOISE_THRES):
		chanim_config(wlc->chanim_info).bgnoise_thres = (int8)int_val;
		break;

	case IOV_GVAL(IOV_SAMPLE_PERIOD):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).sample_period;
		break;

	case IOV_SVAL(IOV_SAMPLE_PERIOD):
		if (int_val < SAMPLE_PERIOD_MIN)
			err = BCME_RANGE;
		chanim_config(wlc->chanim_info).sample_period = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_THRESHOLD_TIME):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).threshold_time;
		break;

	case IOV_SVAL(IOV_THRESHOLD_TIME):
		if (int_val < THRESHOLD_TIME_MIN)
			err = BCME_RANGE;
		chanim_config(wlc->chanim_info).threshold_time = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_MAX_ACS):
		*ret_int_ptr = (int32)chanim_config(wlc->chanim_info).max_acs;
		break;

	case IOV_SVAL(IOV_MAX_ACS):
		if (int_val > CHANIM_ACS_RECORD)
			err = BCME_RANGE;
		chanim_config(wlc->chanim_info).max_acs = (uint8)int_val;
		break;

	case IOV_GVAL(IOV_LOCKOUT_PERIOD):
		*ret_int_ptr = chanim_config(wlc->chanim_info).lockout_period;
		break;

	case IOV_SVAL(IOV_LOCKOUT_PERIOD):
		chanim_config(wlc->chanim_info).lockout_period = int_val;
		break;

	case IOV_GVAL(IOV_ACS_RECORD):
		if (len < (int)sizeof(wl_acs_record_t))
			err = BCME_BUFTOOSHORT;
		else
			err = chanim_get_acs_record(wlc->chanim_info, len, arg);
		break;

	case IOV_GVAL(IOV_CHANIM_STATS): {
		wl_chanim_stats_t input = *((wl_chanim_stats_t *)params);
		wl_chanim_stats_t *iob = (wl_chanim_stats_t*) arg;
		int buflen;

		if ((uint)len < WL_CHANIM_STATS_FIXED_LEN) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		buflen = (int)input.buflen;

		if ((uint)buflen < WL_CHANIM_STATS_FIXED_LEN) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		err = chanim_get_stats(wlc->chanim_info, iob, &buflen, input.count);
		break;
	}

#endif /* WLCHANIM */

#ifdef CCA_STATS
	case IOV_GVAL(IOV_CCA_STATS):
		if ((p_len < sizeof(cca_congest_channel_req_t)) ||
			(len < (int)sizeof(cca_congest_channel_req_t)))
			err = BCME_BUFTOOSHORT;
		else
			err = cca_get_stats(wlc->cca_info, params, len, arg);
		break;

#ifdef ISID_STATS
	case IOV_GVAL(IOV_ITFR_STATS):
		if (len < (int)sizeof(interference_source_rep_t))
			err = BCME_BUFTOOSHORT;
		else
			err = itfr_get_stats(wlc->itfr_info, (interference_source_rep_t*)arg);

		break;

	case IOV_GVAL(IOV_ITFR_ENAB):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->op_mode;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_ENAB):
		err = itfr_set_mode(wlc, int_val);
		break;

	case IOV_SVAL(IOV_ITFR_DETECT):
		err = itfr_detect_req(wlc);
		break;

	case IOV_SVAL(IOV_ITFR_ABORT):
		err = itfr_abort_req(wlc);
		break;

	case IOV_GVAL(IOV_ITFR_THRES):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->threshold;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_THRES):
		if (wlc->itfr_info) {
			if (int_val < ITFR_MIN_THRESHOLD ||
				int_val > ITFR_MAX_THRESHOLD)
				err = BCME_BADARG;
			else
				wlc->itfr_info->threshold = (uint16)int_val;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_ITFR_NET_THRES):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->max_nets;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_NET_THRES):
		err = itfr_set_net_thres_req(wlc, int_val);
		break;

	case IOV_GVAL(IOV_ITFR_STOP_TM):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->stop_hold_tm;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_STOP_TM):
		if (wlc->itfr_info) {
			if (int_val < ITFR_MIN_STOP_HOLD_TM ||
				int_val > ITFR_MAX_STOP_HOLD_TM)
				err = BCME_BADARG;
			else
				wlc->itfr_info->stop_hold_tm = (uint16)int_val;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_ITFR_ID_HOLD_TM):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->id_hold_tm;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_ID_HOLD_TM):
		if (wlc->itfr_info) {
			if (int_val < ITFR_MIN_ID_HOLD_TM ||
				int_val > ITFR_MAX_ID_HOLD_TM)
				err = BCME_BADARG;
			else
				wlc->itfr_info->id_hold_tm = (uint16)int_val;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_ITFR_NON_ID_HOLD_TM):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->non_id_hold_tm;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_NON_ID_HOLD_TM):
		if (wlc->itfr_info) {
			if (int_val < ITFR_MIN_NON_ID_HOLD_TM ||
				int_val > ITFR_MAX_NON_ID_HOLD_TM)
				err = BCME_BADARG;
			else
				wlc->itfr_info->non_id_hold_tm = (uint16)int_val;
		} else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_GVAL(IOV_ITFR_CLEAN_TM):
		if (wlc->itfr_info)
			*ret_int_ptr = (int)wlc->itfr_info->clean_tm;
		else
			err = BCME_UNSUPPORTED;
		break;

	case IOV_SVAL(IOV_ITFR_CLEAN_TM):
		if (wlc->itfr_info)
			wlc->itfr_info->clean_tm = (uint16)int_val;
		else
			err = BCME_UNSUPPORTED;
		break;
#endif /* ISID_STATS */
#endif /* CCA_STATS */
#ifdef SMF_STATS
	case IOV_GVAL(IOV_SMF_STATS): {
		int idx = int_val;
		if (len < (int)sizeof(wl_smf_stats_t)) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		err = wlc_bsscfg_get_smfs(bsscfg, idx, arg, len);
		break;
	}
	case IOV_SVAL(IOV_SMF_STATS):
		err = wlc_bsscfg_clear_smfs(wlc, bsscfg);
		break;

	case IOV_GVAL(IOV_SMF_STATS_ENABLE):
		*ret_int_ptr = bsscfg->smfs_info->enable;
		break;

	case IOV_SVAL(IOV_SMF_STATS_ENABLE):
		bsscfg->smfs_info->enable = int_val;
		break;

#endif /* SMF_STATS */
#ifdef BCMWAPI_WAI
	case IOV_GVAL(IOV_WAI_RESTRICT):
		*ret_int_ptr = (int32)bsscfg->wai_restrict;
		break;

	case IOV_SVAL(IOV_WAI_RESTRICT):
		bsscfg->wai_restrict = bool_val;
		break;
	case IOV_SVAL(IOV_WAI_REKEY):
		wlc_wai_rekey(wlc, bsscfg, arg);
		break;
#endif /* BCMWAPI_WAI */
#ifdef STA
	case IOV_SVAL(IOV_ROAM_TBTT):
		if (int_val < 2 || int_val > 255)
		{
			err = BCME_RANGE;
			break;
		}
		roam->tbtt_thresh = (uint8) int_val;
		roam->uatbtt_tbtt_thresh = (uint8) int_val/2;
		roam->tbtt_since_bcn = 0;
		break;
	case IOV_GVAL(IOV_ROAM_TBTT):
		*ret_int_ptr = roam->tbtt_thresh;
		break;
#endif /* STA */
#if defined(WLTEST)
	case IOV_GVAL(IOV_MANF_INFO):
		err = wlc_manf_info_get(wlc, (char *)arg, len, wlcif);
		break;
#endif 
	case IOV_GVAL(IOV_POOL):
		if (POOL_ENAB(wlc->pub))
			*ret_int_ptr = pktpool_len(wlc->pub->pktpool);
		else
			*ret_int_ptr = 0;
		break;
	case IOV_SVAL(IOV_POOL):
		if (!POOL_ENAB(wlc->pub)) {
			err = BCME_UNSUPPORTED;
			break;
		}
		if (POOL_ENAB(wlc->pub)) {
			if (pktpool_setmaxlen(wlc->pub->pktpool, (uint16)int_val) != int_val)
				err = BCME_BADLEN;
		}
		else
			err = BCME_BADLEN;
		break;

	case IOV_GVAL(IOV_CURR_RATESET): {
		wl_rateset_args_t *ret_rs = (wl_rateset_args_t *)arg;
		wlc_rateset_t *rs;

		if (wlc->pub->associated)
			rs = &bsscfg->current_bss->rateset;
		else
			rs = &wlc->default_bss->rateset;

		if (len < (int)(rs->count + sizeof(rs->count))) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		/* Copy legacy rateset and mcsset */
		ret_rs->count = rs->count;
		bcopy(&rs->rates, &ret_rs->rates, rs->count);

		if (N_ENAB(wlc->pub))
			bcopy(rs->mcs, ret_rs->mcs, MCSSET_LEN);
		break;
	}

	case IOV_GVAL(IOV_RATESET): {
		wlc_rateset_t rs;
		wl_rateset_args_t *ret_rs = (wl_rateset_args_t *)arg;

		bzero(&rs, sizeof(wlc_rateset_t));
		wlc_default_rateset(wlc, (wlc_rateset_t*)&rs);

		if (len < (int)(rs.count + sizeof(rs.count))) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		/* Copy legacy rateset */
		ret_rs->count = rs.count;
		bcopy(&rs.rates, &ret_rs->rates, rs.count);

		/* Copy mcs rateset */
		if (N_ENAB(wlc->pub))
			bcopy(rs.mcs, ret_rs->mcs, MCSSET_LEN);
		break;
	}

	case IOV_SVAL(IOV_RATESET): {
		wlc_rateset_t rs;
		wl_rateset_args_t *in_rs = (wl_rateset_args_t *)arg;

		if (len < (int)(in_rs->count + sizeof(in_rs->count))) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		bzero(&rs, sizeof(wlc_rateset_t));

		/* Copy legacy rateset */
		rs.count = in_rs->count;
		bcopy(&in_rs->rates, &rs.rates, rs.count);

		/* Copy mcs rateset */
		if (N_ENAB(wlc->pub))
			bcopy(in_rs->mcs, rs.mcs, MCSSET_LEN);

		err = wlc_set_rateset(wlc, &rs);

		break;
	}
#if defined(BCM_DCS) && defined(STA)
	case IOV_SVAL(IOV_BRCM_DCS_REQ): {

		chanspec_t chspec = (chanspec_t) int_val;

		if (SCAN_IN_PROGRESS(wlc->scan)) {
			wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);
			err = BCME_BUSY;
			break;
		}

		if (wf_chspec_malformed(chspec) || !wlc_valid_chanspec(wlc->cmi, chspec)) {
			err = BCME_BADCHAN;
			break;
		}

		if (BSSCFG_STA(bsscfg) && bsscfg->associated) {
			wl_bcmdcs_data_t bcmdcs_data;
			bcmdcs_data.reason = BCM_DCS_IOVAR;
			bcmdcs_data.chspec = chspec;
			err = wlc_send_action_brcm_dcs(wlc, &bcmdcs_data,
				wlc_scbfind(wlc, &bsscfg->BSSID));
		}

		break;
	}
#endif /* BCM_DCS && STA */


	case IOV_GVAL(IOV_PM_DUR):
		*ret_int_ptr = wlc_get_accum_pmdur(wlc);
		break;
	case IOV_SVAL(IOV_PM_DUR):
		err = wlc_reset_accum_pmdur(wlc);
		break;

	/* iovar versions of WLC_SCB_AUTHORIZE et al */
	case IOV_SVAL(IOV_AUTHOPS): {
		authops_t *pp = params;

		err = wlc_ioctl(wlc, pp->code, &pp->ioctl_args, sizeof(pp->ioctl_args), wlcif);
		break;
	}
#ifdef WL_DNGL_WD
	case IOV_GVAL(IOV_DNGL_WD):
		((uint32*)arg)[0] = wlc->dngl_wd_high;
		((uint32*)arg)[1] = wlc->dngl_wd_high_exptime;
		break;
	case IOV_SVAL(IOV_DNGL_WD):
			wlc->dngl_wd_high = bool_val;
			if (wlc->dngl_wd_high)
				wlc->dngl_wd_high_exptime = (int_val2 == 0) ?
					WL_DNGL_WD_DEFAULT_TIMEOUT : int_val2;
			else
				wlc->dngl_wd_high_exptime = 0;
			wlc_bmac_dngl_wd_set(wlc->hw, wlc->dngl_wd_high, wlc->dngl_wd_high_exptime);
		break;
#endif /* WL_DNGL_WD */

#if defined(BCMDBG) || defined(WLNINTENDO2)
	case IOV_SVAL(IOV_TSF):
		wlc_tsf_set(wlc, int_val, int_val2);
		break;

	case IOV_GVAL(IOV_TSF): {
		uint32 tsf_l, tsf_h;
		wlc_read_tsf(wlc, &tsf_l, &tsf_h);
		((uint32*)arg)[0] = tsf_l;
		((uint32*)arg)[1] = tsf_h;
		break;
	}

	case IOV_SVAL(IOV_TSF_ADJUST):
		wlc_tsf_adjust(wlc, int_val);
		break;
#endif /* BCMDBG */

	case IOV_GVAL(IOV_WLIF_BSSCFG_IDX):
		*ret_int_ptr = WLC_BSSCFG_IDX(bsscfg);
		break;

	case IOV_GVAL(IOV_SSID): {
		wlc_ssid_t ssid;
		int ssid_copy_len;

		/* copy the bsscfg's SSID to the on-stack return structure */
		ssid.SSID_len = bsscfg->SSID_len;
		if (ssid.SSID_len)
			bcopy(bsscfg->SSID, ssid.SSID, ssid.SSID_len);

		ssid_copy_len = (int)(sizeof(ssid.SSID_len) + ssid.SSID_len);
		if (len < ssid_copy_len) {
			err = BCME_BUFTOOSHORT;
			break;
		}

		bcopy(&ssid, arg, ssid_copy_len);
		break;
	}

	case IOV_SVAL(IOV_SSID): {
		int32 ssidlen;
		uchar* ssid_ptr;
#if defined(BCMDBG) || defined(WLMSG_OID)
		char ssidbuf[SSID_FMT_BUF_LEN];
#endif
		/* input buffer is:
		 * uint32 ssid_len      (local int_val)
		 * char   ssid[]	(local arg + 4)
		 */

		/* get the SSID length from the wlc_ssid_t struct starting just past the
		 * bsscfg index
		 */
		ssidlen = int_val;

		if (ssidlen < 0 || ssidlen > DOT11_MAX_SSID_LEN) {
			err = BCME_BADSSIDLEN;
			break;
		}

		if (len < (int)(sizeof(int32) + ssidlen)) {
			err = BCME_BUFTOOSHORT;
			break;
		}
		ssid_ptr = (uchar*)arg + sizeof(int32);

		WL_OID(("wl: wlc_iovar_op: setting SSID of bsscfg %d to \"%s\"\n",
		 WLC_BSSCFG_IDX(bsscfg),
			(wlc_format_ssid(ssidbuf, ssid_ptr, ssidlen), ssidbuf)));

		/* can only change SSID if the config is down */
		if (bsscfg->up) {
			err = BCME_NOTDOWN;
			break;
		}
		wlc_bsscfg_SSID_set(bsscfg, ssid_ptr, ssidlen);

		break;
	}

#ifdef MFP
	case IOV_SVAL(IOV_MFP): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		if ((flag != 0) && (flag != 1) && (flag != 2)) {
			err = BCME_BADARG;
			break;
		}
		wlc_down(wlc);
		bsscfg->wsec &= ~(MFP_CAPABLE | MFP_REQUIRED);
		if (flag == 1)
			bsscfg->wsec |= MFP_CAPABLE;
		else if (flag == 2)
			bsscfg->wsec |= (MFP_CAPABLE | MFP_REQUIRED);
		wlc_up(wlc);
		break;
	}

	case IOV_SVAL(IOV_MFP_SHA256): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		if (!BSSCFG_STA(bsscfg)) {
			err = BCME_NOTSTA;
			break;
		}
		if (flag)
			bsscfg->wsec |= MFP_SHA256;
		else
			bsscfg->wsec &= ~MFP_SHA256;
		break;
	}


	case IOV_SVAL(IOV_MFP_SA_QUERY): {
		int32 flag;
		uint8 action;
		uint16 id;
		struct scb *scb;
		struct scb_iter scbiter;

		char *inbuf = (char *) arg;
		bcopy(inbuf + OFFSETOF(wl_sa_query_t, action), &action, sizeof(action));
		bcopy(inbuf + OFFSETOF(wl_sa_query_t, id), &id, sizeof(id));
		bcopy(inbuf + OFFSETOF(wl_sa_query_t, flag), &flag, sizeof(flag));
		printf("sa query: action == %d\n", action);
		if (id == 0) {
			/* Token needs to be non-zero, so burn the high bit */
			id = (uint16)(wlc->counter | 0x8000);
		}
		FOREACHSCB(wlc->scbstate, &scbiter, scb) {
			if (SCB_ASSOCIATED(scb)) {
				if (flag) {
					if (flag == 1) {
						wl_wsec_key_t key_param;
						bcopy((char *)&scb->ea, (char *)&key_param.ea,
							sizeof(struct ether_addr));
#ifdef BCMDBG
						wlc_key_set_error(wlc, WSEC_GEN_MFP_ACT_ERROR,
							&key_param);
#endif
					}
					wlc_scb_send_action_sa_query(wlc, scb, action, id);
				} else {
					wlc_bypass_send_action_sa_query(wlc, scb, action, id);
				}
			}
		}
		break;
	}

	case IOV_SVAL(IOV_MFP_DISASSOC): {
		int32 flag, flag2;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		bcopy(inbuf+sizeof(int32), &flag2, sizeof(flag2));
		wlc_disassociate_mfp(wlc, bsscfg, flag, flag2);
		break;
	}

	case IOV_SVAL(IOV_MFP_DEAUTH): {
		int32 flag, flag2;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		bcopy(inbuf+sizeof(int32), &flag2, sizeof(flag2));
		wlc_deauth_mfp(wlc, bsscfg, flag, flag2);
		break;
	}

	case IOV_SVAL(IOV_MFP_ASSOC): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		wlc_associate_mfp(wlc, bsscfg, flag);
		break;
	}

	case IOV_SVAL(IOV_MFP_AUTH): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		wlc_auth_mfp(wlc, bsscfg, flag);
		break;
	}

	case IOV_SVAL(IOV_MFP_REASSOC): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		wlc_reassociate_mfp(wlc, bsscfg, flag);
		break;
	}
	case IOV_SVAL(IOV_MFP_BIP_TEST): {
		int32 flag;
		char *inbuf = (char *) arg;
		bcopy(inbuf, &flag, sizeof(flag));
		wlc_mfp_bip_test(wlc, bsscfg, flag);
		break;
	}
#endif /* MFP */

#ifdef WLNINTENDO2
	case IOV_GVAL(IOV_LINKQUAL_ONOFF):{
		*ret_int_ptr = wlc->_lqstats.enable;
		break;
	}

	case IOV_SVAL(IOV_LINKQUAL_ONOFF):{
		if (int_val == LQ_STOP_MONITOR) {
			wlc_lq_stats_off(wlc);
		} else {
			wlc_lq_stats_on(wlc);
		}

		break;
	}

	case IOV_GVAL(IOV_GET_LINKQUAL_STATS):{
		ret_estatus = (wl_lq_t *)arg;

		wlc_get_lq_stats(wlc, &estatus);
		bcopy(&estatus, ret_estatus, sizeof(wl_lq_t));
		break;
	}

#ifdef WL_MULTIQUEUE
	case IOV_GVAL(IOV_FLUSH_SELECTED_TX_FIFOS):{
		*ret_int_ptr = wlc->flush_txfifo_bitmap;
		break;
	}

	case IOV_SVAL(IOV_FLUSH_SELECTED_TX_FIFOS):{
		if (int_val < BITMAP_FLUSH_NO_TX_FIFOS || int_val  > BITMAP_FLUSH_ALL_TX_FIFOS) {
			err = BCME_RANGE;
		} else {
			wlc->flush_txfifo_bitmap = int_val;
			wlc_bmac_tx_fifo_sync(wlc->hw, int_val, FLUSHFIFO);
		}
		break;
	}
#endif
#endif /* WLNINTENDO2 */

#ifdef STA
	case IOV_SVAL(IOV_JOIN): {
		wlc_ssid_t *ssid = (wlc_ssid_t *)arg;
		wl_join_scan_params_t *scan_params = NULL;
		wl_join_assoc_params_t *assoc_params = NULL;
		int assoc_params_len = 0;

		scan_params = &((wl_extjoin_params_t *)arg)->scan;

		if ((uint)len >= WL_EXTJOIN_PARAMS_FIXED_SIZE) {
			assoc_params = &((wl_extjoin_params_t *)arg)->assoc;
			assoc_params_len = len - OFFSETOF(wl_extjoin_params_t, assoc);
			if ((uint)len < WL_EXTJOIN_PARAMS_FIXED_SIZE +
				assoc_params->chanspec_num * sizeof(chanspec_t)) {
				err = BCME_BUFTOOSHORT;
				break;
			}
			err = wlc_assoc_chanspec_sanitize(wlc,
				assoc_params->chanspec_list,
				assoc_params->chanspec_num);
			if (err != BCME_OK)
				break;
		}
		WL_APSTA_UPDN(("wl%d: \"join\" -> wlc_join()\n", wlc->pub->unit));
		wlc_join(wlc, bsscfg, ssid->SSID, ssid->SSID_len,
			scan_params,
			assoc_params, assoc_params_len);
		err = BCME_OK;
		break;
	}

	case IOV_GVAL(IOV_AUTOCOUNTRY):
		*ret_int_ptr = (int)wlc->_autocountry;

		break;

	case IOV_SVAL(IOV_AUTOCOUNTRY):
		if (wlc->pub->associated) {
			err = BCME_ASSOCIATED;
			break;
		}

		if (SCAN_IN_PROGRESS(wlc->scan))
			wlc_scan_abort(wlc->scan, WLC_E_STATUS_ABORT);

		wlc->_autocountry = bool_val;

		wlc->awaiting_cntry_info = bool_val;
		if (bool_val) {
			WL_INFORM(("wl%d:%s(): IOV_AUTOCOUNTRY is TRUE, re-init to "
				"autocountry_defualt %s\n", wlc->pub->unit, __FUNCTION__,
				wlc->autocountry_default));
			/* Re-init channels and locale to Auto Country default */
			err = wlc_set_countrycode(wlc->cmi, wlc->autocountry_default);
			ASSERT(!err);
		} else {
			/* restore orig country/locale */
			WL_INFORM(("wl%d:%s(): IOV_AUTOCOUNTRY is FALSE, restore "
				"country_default %s.\n", wlc->pub->unit, __FUNCTION__,
				wlc->country_default));
			err = wlc_set_countrycode(wlc->cmi, wlc->country_default);
			ASSERT(!err);
		}

		wlc->autocountry_adopted_from_ap = FALSE;

		break;

#endif /* STA */

	case IOV_GVAL(IOV_RPT_HITXRATE):
		*ret_int_ptr = wlc->rpt_hitxrate;
		break;

	case IOV_SVAL(IOV_RPT_HITXRATE):
		wlc->rpt_hitxrate = bool_val;
		break;

#if defined(WLTEST)
	case IOV_GVAL(IOV_TPC_RPT_OVERRIDE):
		*ret_int_ptr = (int32)wlc->tpc_rpt_override;
		break;

	case IOV_SVAL(IOV_TPC_RPT_OVERRIDE):
		wlc->tpc_rpt_override = (uint16)int_val;
		break;
#endif 

#ifdef STA
	case IOV_GVAL(IOV_BUF_KEY_B4_M4):
		*ret_int_ptr = bsscfg->wsec_buf_key_b4_m4;
		break;

	case IOV_SVAL(IOV_BUF_KEY_B4_M4):
		if (bsscfg->wsec_buf_key_b4_m4 == bool_val)
			break;

		if (bool_val) {
			err = wlc_bsscfg_wsec_key_buf_init(wlc, bsscfg);
			if (err) {
				WL_ERROR(("wl%d:%s(): enable buf_key_b4_m4 failed, err=%d\n",
					wlc->pub->unit, __FUNCTION__, err));
				break;
			}
		}
		else
			wlc_bsscfg_wsec_key_buf_free(wlc, bsscfg);

		bsscfg->wsec_buf_key_b4_m4 = bool_val;

		break;
#endif /* STA */

#ifdef BCMDBG
#ifdef STA
	case IOV_SVAL(IOV_RPMT): {
		uint32 rpmt_1_prd = ltoh32_ua((uint8 *)arg);
		uint32 rpmt_0_prd = ltoh32_ua((uint8 *)arg + sizeof(uint32));
		bool enab = rpmt_1_prd != 0 && rpmt_0_prd != 0;

		if (enab) {
			if (bsscfg->rpmt_timer != NULL) {
				err = BCME_BUSY;
				break;
			}
			if ((bsscfg->rpmt_timer = wlc_hwtimer_alloc_timeout(wlc)) == NULL) {
				WL_ERROR(("wl%d.%d: failed to alloc Rapid PM Transition timeout\n",
				          wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				err = BCME_NORESOURCE;
				break;
			}
			bsscfg->rpmt_1_prd = rpmt_1_prd;
			bsscfg->rpmt_0_prd = rpmt_0_prd;
			bsscfg->rpmt_n_st = 1;
			wlc_rpmt_timer_cb(bsscfg);
		}
		else {
			if (bsscfg->rpmt_timer == NULL) {
				err = BCME_ERROR;
				break;
			}
			wlc_hwtimer_del_timeout(wlc->gptimer, bsscfg->rpmt_timer);
			wlc_hwtimer_free_timeout(wlc, bsscfg->rpmt_timer);
			bsscfg->rpmt_timer = NULL;
		}
		break;
	}
#endif /* STA */
#endif /* BCMDBG */

	case IOV_GVAL(IOV_CHAN_BLOCK): {
		chanspec_t chspec = (chanspec_t)int_val;
		uint channel = CHSPEC_CHANNEL(chspec);

		if (CHSPEC_IS40(chspec)) {
			if (wlc->ap->chan_blocked[LOWER_20_SB(channel)] >
				wlc->ap->chan_blocked[UPPER_20_SB(channel)])
				*ret_int_ptr = wlc->ap->chan_blocked[LOWER_20_SB(channel)];
			else
				*ret_int_ptr = wlc->ap->chan_blocked[UPPER_20_SB(channel)];
		} else {
			*ret_int_ptr = wlc->ap->chan_blocked[channel];
		}

		break;
	}


	default:
		err = BCME_UNSUPPORTED;
		break;
	}

	goto exit;	/* avoid unused label warning */

exit:
	return err;
}

static int
wlc_iovar_rangecheck(wlc_info_t *wlc, uint32 val, const bcm_iovar_t *vi)
{
	int err = 0;
	uint32 min_val = 0;
	uint32 max_val = 0;

	/* Only ranged integers are checked */
	switch (vi->type) {
	case IOVT_INT32:
		max_val |= 0x7fffffff;
		/* fall through */
	case IOVT_INT16:
		max_val |= 0x00007fff;
		/* fall through */
	case IOVT_INT8:
		max_val |= 0x0000007f;
		min_val = ~max_val;
		if (vi->flags & IOVF_NTRL)
			min_val = 1;
		else if (vi->flags & IOVF_WHL)
			min_val = 0;
		/* Signed values are checked against max_val and min_val */
		if ((int32)val < (int32)min_val || (int32)val > (int32)max_val)
			err = BCME_RANGE;
		break;

	case IOVT_UINT32:
		max_val |= 0xffffffff;
		/* fall through */
	case IOVT_UINT16:
		max_val |= 0x0000ffff;
		/* fall through */
	case IOVT_UINT8:
		max_val |= 0x000000ff;
		if (vi->flags & IOVF_NTRL)
			min_val = 1;
		if ((val < min_val) || (val > max_val))
			err = BCME_RANGE;
		break;
	}

	return err;
}

/*
 * format a bsscfg indexed iovar buffer
 */
int
wlc_bssiovar_mkbuf(char *iovar, int bssidx, void *param,
	int paramlen, void *bufptr, int buflen, int *perr)
{
	const char *prefix = "bsscfg:";
	int8* p;
	uint prefixlen;
	uint namelen;
	uint iolen;

	prefixlen = strlen(prefix);	/* length of bsscfg prefix */
	namelen = strlen(iovar) + 1;	/* length of iovar name + null */
	iolen = prefixlen + namelen + sizeof(int) + paramlen;

	/* check for overflow */
	if (buflen < 0 || iolen > (uint)buflen) {
		*perr = BCME_BUFTOOSHORT;
		return 0;
	}

	p = (int8*)bufptr;

	/* copy prefix, no null */
	bcopy(prefix, p, prefixlen);
	p += prefixlen;

	/* copy iovar name including null */
	bcopy(iovar, p, namelen);
	p += namelen;

	/* bss config index as first param */
	bcopy(&bssidx, p, sizeof(int32));
	p += sizeof(int32);

	/* parameter buffer follows */
	if (paramlen)
		bcopy(param, p, paramlen);

	*perr = 0;
	return iolen;
}
/* Convert a wlc_bss_info_t into an external wl_bss_info_t
 * Destination pointer does not need to be aligned.
 */
static int
wlc_bss2wl_bss(wlc_info_t *wlc, wlc_bss_info_t *bi, wl_bss_info_t *to_bi, int to_bi_len,
	bool need_ies)
{
	wl_bss_info_t wl_bi;
	uint bi_length;
	int ie_length;
	uint16 ie_offset;
	uint8 *ie;

	/* user buffer should at least hold fixed portion of bss info */
	if (to_bi_len < (int) sizeof(wl_bss_info_t)) {
		WL_ERROR(("wlc_bss2wl_bss: to_bi_len %d too small\n", to_bi_len));
		return BCME_BUFTOOSHORT;
	}

	/* init ie length, point to IEs */
	if (bi->bcn_prb) {
		ie_length = bi->bcn_prb_len - DOT11_BCN_PRB_LEN;
		ie_offset = sizeof(wl_bss_info_t);
		if (ie_length > 0)
			ie = (uint8 *)bi->bcn_prb + DOT11_BCN_PRB_LEN;
		else {
			ie_length = 0;
			ie_offset = 0;
			ie = NULL;
		}
	}
	/* no IEs */
	else {
		ie_length = 0;
		ie_offset = 0;
		ie = NULL;
	}

	/* check for user buffer again to see if it can take IEs */
	if (ie_length) {
		/* adjust bss info length to hold variable length IEs as well */
		bi_length = sizeof(wl_bss_info_t) + ROUNDUP(ie_length, 4);
		/* check again for user buffer length */
		if (to_bi_len < (int) bi_length) {
			if (need_ies) {
				WL_ERROR(("wlc_bss2wl_bss: to_bi_len %d	too small for ies\n",
					to_bi_len));
				return BCME_BUFTOOSHORT;
			}
			bi_length = sizeof(wl_bss_info_t); /* just the fixed bss info */
			ie_length = 0;
			ie_offset = 0;
			ie = NULL;
		}
	}
	else
		bi_length = sizeof(wl_bss_info_t);

	bzero(&wl_bi, sizeof(wl_bss_info_t));

	/* constant values for wl_bss_info */
	wl_bi.version		= WL_BSS_INFO_VERSION;
	wl_bi.length		= bi_length;

	/* simple copies from wlc_bss_info */
	wl_bi.beacon_period	= bi->beacon_period;
	wl_bi.capability	= bi->capability;
	wl_bi.chanspec		= bi->chanspec;
	wl_bi.atim_window	= bi->atim_window;
	wl_bi.dtim_period	= bi->dtim_period;
	wl_bi.RSSI		= bi->RSSI;
	wl_bi.SNR		= bi->SNR;
	wl_bi.phy_noise		= bi->phy_noise;

	bcopy(bi->BSSID.octet, wl_bi.BSSID.octet, ETHER_ADDR_LEN);

	wl_bi.SSID_len	= bi->SSID_len;
	bcopy(bi->SSID, wl_bi.SSID, wl_bi.SSID_len);

	if (bi->flags & WLC_BSS_BEACON)
		wl_bi.flags |= WL_BSS_FLAGS_FROM_BEACON;
	if (bi->flags & WLC_BSS_CACHE)
		wl_bi.flags |= WL_BSS_FLAGS_FROM_CACHE;
	if (bi->flags & WLC_BSS_RSSI_ON_CHANNEL)
		wl_bi.flags |= WL_BSS_FLAGS_RSSI_ONCHANNEL;

	/* limit rates to destination rate array size */
	wl_bi.rateset.count = MIN(bi->rateset.count, sizeof(wl_bi.rateset.rates));
	bcopy(bi->rateset.rates, wl_bi.rateset.rates, wl_bi.rateset.count);

#ifdef WLP2P
	if (!P2P_ENAB(wlc->pub))
#endif
	{
	/* make capability match the infra value */
	wl_bi.capability &= ~(DOT11_CAP_ESS | DOT11_CAP_IBSS);
	if (bi->infra)
		wl_bi.capability |= DOT11_CAP_ESS;
	else
		wl_bi.capability |= DOT11_CAP_IBSS;
	}

	/* Some 802.11N related capabilities */
	if (bi->flags & WLC_BSS_HT) {
		wl_bi.n_cap = TRUE;
		if (bi->flags & WLC_BSS_40MHZ)
			wl_bi.nbss_cap |= HT_CAP_40MHZ;
		if (bi->flags & WLC_BSS_SGI_20)
			wl_bi.nbss_cap |= HT_CAP_SHORT_GI_20;
		if (bi->flags & WLC_BSS_SGI_40)
			wl_bi.nbss_cap |= HT_CAP_SHORT_GI_40;
		/* Copy Basic MCS set */
		bcopy(&bi->rateset.mcs[0], &wl_bi.basic_mcs[0], MCSSET_LEN);
		wl_bi.ctl_ch = wf_chspec_ctlchan(bi->chanspec);
	}

	/* ie length */
	wl_bi.ie_length = ie_length;
	wl_bi.ie_offset = ie_offset;

	/* copy fixed portion of the bss info structure to user buffer */
	bcopy(&wl_bi, to_bi, sizeof(wl_bss_info_t));

	/* append beacon/probe response IEs */
	if (ie_length)
		bcopy(ie, (uint8 *)to_bi + sizeof(wl_bss_info_t), ie_length);

	return 0;
}

#ifdef MBSS

/* Select SSID length register based on HW index */
#define _MBSS_SSID_LEN_SELECT(wlc, idx) (MBSS_ENAB(wlc->pub) ? \
	(((idx) == 0 || (idx) == 1) ? SHM_MBSS_SSID_LEN0 : SHM_MBSS_SSID_LEN1) : \
	M_SSIDLEN)

/* Use to access a specific SSID length */
#define WLC_MBSS_SSID_LEN_GET(wlc, idx, out_val) do { \
		out_val = wlc_read_shm(wlc, _MBSS_SSID_LEN_SELECT(wlc, idx)); \
		if ((idx) % 2) out_val = ((out_val) >> 8) & 0xff; \
		else out_val = (out_val) & 0xff; \
	} while (0)

#endif	/* MBSS */

#if ((defined(BCMDBG) || defined(WLMSG_PRPKT)) && defined(STA)) || ((defined(BCMDBG) || \
	defined(BCMDBG_DUMP)) && !defined(WLLMAC_ONLY))
static const struct wlc_id_name_entry dot11_ie_names[] =
{
	{DOT11_MNG_SSID_ID, "SSID"},
	{DOT11_MNG_RATES_ID, "Rates"},
	{DOT11_MNG_FH_PARMS_ID, "FH Parms"},
	{DOT11_MNG_DS_PARMS_ID, "DS Parms"},
	{DOT11_MNG_CF_PARMS_ID, "CF Parms"},
	{DOT11_MNG_TIM_ID, "TIM"},
	{DOT11_MNG_IBSS_PARMS_ID, "IBSS Parms"},
	{DOT11_MNG_COUNTRY_ID, "Country"},
	{DOT11_MNG_HOPPING_PARMS_ID, "Hopping Parms"},
	{DOT11_MNG_HOPPING_TABLE_ID, "Hopping Table"},
	{DOT11_MNG_REQUEST_ID, "Request"},
	{DOT11_MNG_QBSS_LOAD_ID, "QBSS LOAD"},
	{DOT11_MNG_CHALLENGE_ID, "Challenge"},
	{DOT11_MNG_PWR_CONSTRAINT_ID, "Pwr Constraint"},
	{DOT11_MNG_PWR_CAP_ID, "Pwr Capability"},
	{DOT11_MNG_TPC_REQUEST_ID, "TPC Request"},
	{DOT11_MNG_TPC_REPORT_ID, "TPC Report"},
	{DOT11_MNG_SUPP_CHANNELS_ID, "Supported Channels"},
	{DOT11_MNG_CHANNEL_SWITCH_ID, "Channel Switch"},
	{DOT11_MNG_MEASURE_REQUEST_ID, "Measure Request"},
	{DOT11_MNG_MEASURE_REPORT_ID, "Measure Report"},
	{DOT11_MNG_QUIET_ID, "Quiet"},
	{DOT11_MNG_IBSS_DFS_ID, "IBSS DFS"},
	{DOT11_MNG_ERP_ID, "ERP Info"},
	{DOT11_MNG_TS_DELAY_ID, "TS Delay"},
	{DOT11_MNG_HT_CAP, "HT Capability"},
	{DOT11_MNG_NONERP_ID, "Legacy ERP Info"},
	{DOT11_MNG_RSN_ID, "RSN"},
	{DOT11_MNG_EXT_RATES_ID, "Ext Rates"},
	{DOT11_MNG_HT_ADD, "HT Additional"},
	{DOT11_MNG_EXT_CHANNEL_OFFSET, "Ext Channel Offset"},
	{DOT11_MNG_VS_ID, "Vendor Specific"},
	{0, NULL}
};
#endif /* ((BCMDBG || WLMSG_PRPKT) && STA) || ((BCMDBG || BCMDBG_DUMP) && !WLLMAC_ONLY) */

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
#ifndef WLLMAC_ONLY
static int
wlc_dump_ratestuff(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint i;
	uint r;

#ifdef WL11N
	wlc_dump_mcsset("\nhw_mcsset ", &wlc->band->hw_rateset.mcs[0], b);
#endif
	bcm_bprintf(b, "\n");
	bcm_bprintf(b, "basic_rate: ");
	for (i = 0; i < sizeof(wlc->band->basic_rate); i++)
		if ((r = wlc->band->basic_rate[i]))
			bcm_bprintf(b, "%d%s->%d%s ",
				(i / 2), (i % 2)?".5":"",
				(r / 2), (r % 2)?".5":"");
	bcm_bprintf(b, "\n");

	return 0;
}

static int
wlc_dump_wlc(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlcband_t *band;
	uint fifo_size[NFIFO];
	char perm[32], cur[32];
	char cap[WLC_IOCTL_SMLEN];
	char chn[8];
	uint16 maj_rev, min_rev, date, time;
	uint16 dbgst;
	uint i;
	wlc_bsscfg_t *cfg;
	wlc_txq_info_t *qi;
	wlc_if_t *wlcif;
	wlc_tunables_t *tunables;

	/* read ucode revision info */
	maj_rev = wlc->ucode_rev >> NBITS(uint16);
	min_rev = wlc->ucode_rev & 0xffff;

	/* skip accessing registers if the clock is off */
	if (!wlc->clk) {
		date = time = dbgst = 0;
	} else {
		date = wlc_read_shm(wlc, M_UCODE_DATE);
		time = wlc_read_shm(wlc, M_UCODE_TIME);
		/* read ucode debug status */
		dbgst = wlc_read_shm(wlc, M_UCODE_DBGST);
	}

	bcm_bprintf(b, "\n");

	bcm_bprintf(b, "wl%d: wlc %p wl %p msglevel 0x%x clk %d up %d hw_off %d now %d\n",
	            wlc->pub->unit, wlc, wlc->wl, wl_msg_level, wlc->clk,
	            wlc->pub->up, wlc->pub->hw_off, wlc->pub->now);

	bcm_bprintf(b, "ucode %d.%d %02d/%02d/%02d %02d:%02d:%02d dbgst 0x%x\n",
	            maj_rev, min_rev,
	            (date >> 8) & 0xf, date & 0xff, (date >> 12) & 0xf,
	            (time >> 11) & 0x1f, (time >> 5) & 0x3f, time & 0x1f, dbgst);

	bcm_bprintf(b, "capabilities: %s\n", wlc_cap(wlc, cap, sizeof(cap)));

	bcm_bprintf(b, "promisc %d monitor %d piomode %d gmode %d\n",
	            wlc->pub->promisc, wlc->monitor, PIO_ENAB(wlc->pub), wlc->band->gmode);
#ifdef WLAFTERBURNER
	bcm_bprintf(b, "afterburner %d afterburner_override %d abminrate %d"
	            " ab_wds_timeout %d nonabcap %d\n",
	            wlc->afterburner, wlc->afterburner_override, wlc->abminrate,
	            wlc->ab_wds_timeout, wlc->protection->nonabcap_assoc);
#endif /* WLAFTERBURNER */

	bcm_bprintf(b, "ap %d apsta %d wet %d wme %d mac_spoof %d per-ac maxrate %d\n",
	            AP_ENAB(wlc->pub), APSTA_ENAB(wlc->pub), wlc->wet, wlc->pub->_wme,
	            wlc->mac_spoof, WME_PER_AC_MAXRATE_ENAB(wlc->pub));

	bcm_bprintf(b, "vendor 0x%x device 0x%x nbands %d regs %p\n",
	            wlc->vendorid, wlc->deviceid, NBANDS(wlc), wlc->regs);

	bcm_bprintf(b, "chip %s chiprev %d corerev %d maccap 0x%x\n",
	            bcm_chipname(wlc->pub->sih->chip, chn, 8), wlc->pub->sih->chiprev,
	            wlc->pub->corerev, wlc->machwcap);

	bcm_bprintf(b, "boardvendor 0x%x boardtype 0x%x boardrev %s "
	            "boardflags 0x%x boardflags2 0x%x sromrev %d\n",
	            wlc->pub->sih->boardvendor, wlc->pub->sih->boardtype,
	            bcm_brev_str(wlc->pub->boardrev, cur), wlc->pub->boardflags,
	            wlc->pub->boardflags2, wlc->pub->sromrev);
	if (wlc->pub->boardrev == BOARDREV_PROMOTED)
		bcm_bprintf(b, " (actually 0x%02x)", BOARDREV_PROMOTABLE);
	bcm_bprintf(b, "\n");

	bcm_bprintf(b, "clock: fastpwrup_dly %d\n", wlc->fastpwrup_dly);

	bcm_bprintf(b, "perm_etheraddr %s cur_etheraddr %s\n",
	            bcm_ether_ntoa(&wlc->perm_etheraddr, (char*)perm),
	            bcm_ether_ntoa(&wlc->pub->cur_etheraddr, (char*)cur));

	bcm_bprintf(b, "swdecrypt %d\n",
	            wlc->pub->swdecrypt);

	bcm_bprintf(b, "\nuserfragthresh %d, fragthresh %d/%d/%d/%d RTSThresh %d \n",
	            wlc->usr_fragthresh, wlc->fragthresh[0], wlc->fragthresh[1],
	            wlc->fragthresh[2], wlc->fragthresh[3], wlc->RTSThresh);

	bcm_bprintf(b, "\nSRL %d LRL %d SFBL %d LFBL %d\n",
	            wlc->SRL, wlc->LRL, wlc->SFBL, wlc->LFBL);

	bcm_bprintf(b, "gmode_user %d nmode_user %d n_pam_overrd %d\n",
	            wlc->protection->gmode_user, wlc->protection->nmode_user,
	            wlc->protection->n_pam_override);

	bcm_bprintf(b, "shortslot %d shortslot_ovrrd %d ignore_bcns %d "
	            "txc %d txc_policy %d txc_sticky %d\n",
	            wlc->shortslot, wlc->shortslot_override, wlc->ignore_bcns,
	            wlc->txc, wlc->txc_policy, wlc->txc_sticky);

	bcm_bprintf(b, "\nprotection:\n");
	FOREACH_BSS(wlc, i, cfg) {
		wlc_prot_cond_t *cond = cfg->prot_cond;
		wlc_prot_cfg_t *prot = cfg->prot_cfg;
		wlc_prot_to_t *to = cfg->prot_to;

		if (!cfg->associated)
			continue;

		bcm_bprintf(b, "\nbsscfg: %u %s\n", WLC_BSSCFG_IDX(cfg),
		            BSSCFG_AP(cfg) ? "AP" : cfg->BSS ? "STA" : "IBSS");
		bcm_bprintf(b, "nonerp %d use_prot %d shortpreamble %d barker_preamble %d\n",
		            prot->erp_ie_nonerp, prot->erp_ie_use_protection,
		            prot->shortpreamble, prot->barker_preamble);
		bcm_bprintf(b, "g_prot %d g_prot_ovrrd %d prot_ctl %d\n",
		            prot->_g, prot->g_override, prot->overlap);
		bcm_bprintf(b, "n_cfg %d n_cfg_ovrrd %d prot_ctl %d "
		            "nongf %d nongf_ovrrd %d obss_nonht_sta %d\n",
		            prot->n_cfg, prot->n_cfg_override,
		            prot->overlap, prot->nongf,
		            prot->nongf_override, prot->n_obss);
		bcm_bprintf(b, "include_legacy_erp %d barker_overlap_control %d\n",
		            prot->include_legacy_erp, prot->barker_overlap_control);

		bcm_bprintf(b, "longpre_assoc %d nonerp_assoc %d ofdm_assoc %d longslot_assoc %d"
		            " ht20in40_assoc %d non_gf_assoc %d ht20intolerant_assoc %d\n",
		            cond->longpre_assoc, cond->nonerp_assoc, cond->ofdm_assoc,
		            cond->longslot_assoc,
		            cond->ht20in40_assoc, cond->non_gf_assoc, cond->ht40intolerant_assoc,
		            cond->non11n_apsd_assoc);

		bcm_bprintf(b, "longpre_detect_timeout %d barker_detect_timeout %d "
		            "ofdm_ovlp_timeout %d ofdm_ibss_timeout %d "
		            "nonerp_ovlp_timeout %d nonerp_ibss_timeout %d "
		            "g_prot_ibss_detect_timeout %d n_prot_ibss_detect_timeout %d "
		            "ht20in40_ovlp_timeout %d ht20in40_ibss_timeout %d "
		            "non_gf_ibss_timeout %d\n",
		            to->longpre_detect_timeout,
		            to->barker_detect_timeout,
		            to->ofdm_ovlp_timeout,
		            to->ofdm_ibss_timeout,
		            to->nonerp_ovlp_timeout,
		            to->nonerp_ibss_timeout,
		            to->g_ibss_timeout,
		            to->n_ibss_timeout,
		            to->ht20in40_ovlp_timeout,
		            to->ht20in40_ibss_timeout,
		            to->non_gf_ibss_timeout);
	}

	bcm_bprintf(b, "\nspect_mngmt %d reg_domain %d block_datafifo 0x%x tx_suspended %d\n",
	            wlc->_spect_management, wlc->_regulatory_domain,
	            wlc->block_datafifo, wlc->tx_suspended);

	bcm_bprintf(b, "bandunit %d bandlocked %d \n", wlc->band->bandunit, wlc->bandlocked);
	bcm_bprintf(b, "radio_disabled 0x%x down_override %d\n", wlc->pub->radio_disabled,
	            wlc->down_override);

#ifdef STA
	bcm_bprintf(b, "mpc %d, mpc_scan %d mpc_join %d mpc_oidscan %d mpc_oidjoin %d"
	            " mpc_oidnettype %d mpc_out %d\n",
	            wlc->mpc, wlc->mpc_scan, wlc->mpc_join, wlc->mpc_oidscan, wlc->mpc_oidjoin,
	            wlc->mpc_oidnettype, wlc->mpc_out);
#endif

	bcm_bprintf(b, "5G band: ratespec_override 0x%x mratespec_override 0x%x\n",
	            wlc->bandstate[BAND_5G_INDEX]->rspec_override,
	            wlc->bandstate[BAND_5G_INDEX]->mrspec_override);

	bcm_bprintf(b, "2G band: ratespec_override 0x%x mratespec_override 0x%x\n",
	            wlc->bandstate[BAND_2G_INDEX]->rspec_override,
	            wlc->bandstate[BAND_2G_INDEX]->mrspec_override);
	bcm_bprintf(b, "\n");

	FOREACH_BSS(wlc, i, cfg) {
		bcm_bprintf(b, "PLCPHdr_ovrrd %d\n",
			cfg->PLCPHdr_override);
	}

	bcm_bprintf(b, "CCK_power_boost %d mhf 0x%02x mhf2 0x%02x mhf3 0x%02x mhf4 0x%02x\n",
		((wlc->pub->boardflags & BFL_CCKHIPWR) ? 1 : 0),
		wlc_bmac_mhf_get(wlc->hw, MHF1, WLC_BAND_AUTO),
		wlc_bmac_mhf_get(wlc->hw, MHF2, WLC_BAND_AUTO),
		wlc_bmac_mhf_get(wlc->hw, MHF3, WLC_BAND_AUTO),
		wlc_bmac_mhf_get(wlc->hw, MHF4, WLC_BAND_AUTO));

	bcm_bprintf(b, "swdecrypt %d\n", wlc->pub->swdecrypt);

#ifdef STA
	bcm_bprintf(b, "\n");
	bcm_bprintf(b, "STAY_AWAKE() %d wake %d PMpending %d PMblocked %d\n",
	            STAY_AWAKE(wlc), wlc->wake, wlc->PMpending, wlc->PMblocked);
	FOREACH_AS_STA(wlc, i, cfg) {
		bcm_bprintf(b, "join_pref->band %d\n", cfg->join_pref->band);

		bcm_bprintf(b, "assoc->state %d assoc->type %d assoc->flags 0x%x assocroam %d\n",
		            cfg->assoc->state, cfg->assoc->type, cfg->assoc->flags,
		            cfg->roam->assocroam);

		bcm_bprintf(b, "wsec_portopen %d WME_PM_blocked %d\n",
		            cfg->wsec_portopen, cfg->pm->WME_PM_blocked);

		bcm_bprintf(b, "PM mode %d PMenabled %d PM_override %d "
		            "PS_ALLOWED() %d PSpoll %d\n",
		            cfg->pm->PM, cfg->pm->PMenabled, cfg->pm->PM_override,
		            PS_ALLOWED(cfg), cfg->pm->PSpoll);
		bcm_bprintf(b, "WLC_PORTOPEN() %d dtim_programmed %d PMpending %d "
		            "priorPMstate %d\n",
		            WLC_PORTOPEN(cfg), cfg->dtim_programmed,
		            cfg->pm->PMpending, cfg->pm->priorPMstate);

		bcm_bprintf(b, "bcns_lost %d tbtt_since_bcn %d time_since_bcn %d\n",
		            cfg->roam->bcns_lost, cfg->roam->tbtt_since_bcn,
		            cfg->roam->time_since_bcn);

		bcm_bprintf(b, "BSSID %s BSS %d\n",
		            bcm_ether_ntoa(&cfg->BSSID, (char*)cur),
		            cfg->BSS);
		bcm_bprintf(b, "reprate %dkbps\n",
		            RSPEC2KBPS(wlc_get_rspec_history(cfg)));

		bcm_bprintf(b, "\n");
	}
#endif /* STA */

	bcm_bprintf(b, "associated %d stas_associated %d aps_associated %d\n",
	            wlc->pub->associated, wlc->stas_associated, wlc->aps_associated);

	FOREACH_BSS(wlc, i, cfg) {
		if (!BSSCFG_AP(cfg))
			continue;
	        bcm_bprintf(b, "BSSID %s\n", bcm_ether_ntoa(&cfg->BSSID, (char*)perm));
	}
	bcm_bprintf(b, "AID 0x%x\n", wlc->AID);

	if (wlc->pub->up)
		bcm_bprintf(b, "chan %d ", CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC));
	else
		bcm_bprintf(b, "chan N/A ");

	bcm_bprintf(b, "country \"%s\" country def \"%s\" auto country \"%s\"\n",
	            wlc_channel_country_abbrev(wlc->cmi),
	            wlc->country_default, wlc->autocountry_default);

	bcm_bprintf(b, "counter %d\n", wlc->counter & 0xfff);


	bcm_bprintf(b, "defmacintmask 0x%08x softmacintmask 0x%08x\n",
	            wlc->defmacintmask, wlc->macintmask);

	bcm_bprintf(b, "\n");

	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
		bcm_bprintf(b, "txqinfo %p len %d stopped 0x%x\n",
		            qi, pktq_len(&qi->q), qi->stopped);
		bcm_bprintf(b, "associated wlcifs:");

		for (wlcif = wlc->wlcif_list;  wlcif != NULL; wlcif = wlcif->next) {
			char ifname[32];

			if (wlcif->qi != qi)
				continue;

			strncpy(ifname, wl_ifname(wlc->wl, wlcif->wlif), sizeof(ifname));
			ifname[sizeof(ifname) - 1] = '\0';

			bcm_bprintf(b, " \"%s\" 0x%p", ifname, wlcif);
		}
		bcm_bprintf(b, "\n");
	}

	bcm_bprintf(b, "\n");

	bcm_bprintf(b, "malloc_failed %d\n", MALLOC_FAILED(wlc->osh));

#ifdef STA
	bcm_bprintf(b, "freqtrack: wideband %d override %d attempts %d duration %d\n",
	            wlc->freqtrack,
	            wlc->freqtrack_override,
	            wlc->freqtrack_attempts,
	            (wlc->freqtrack_attempts > 0) ? (wlc->pub->now - wlc->freqtrack_starttime) : 0);
#endif /* STA */

	bcm_bprintf(b, "txpktpend AC_BK %d AC_BE %d AC_VI %d AC_VO %d BCMC %d fifo5 %d "
	            "pkt_callback_reg_fail %d tx_prec_map %x total_tx_pkt %d\n",
	            TXPKTPENDGET(wlc, TX_AC_BK_FIFO), TXPKTPENDGET(wlc, TX_AC_BE_FIFO),
	            TXPKTPENDGET(wlc, TX_AC_VI_FIFO), TXPKTPENDGET(wlc, TX_AC_VO_FIFO),
	            TXPKTPENDGET(wlc, TX_BCMC_FIFO), TXPKTPENDGET(wlc, TX_ATIM_FIFO),
	            WLCNTVAL(wlc->pub->_cnt->pkt_callback_reg_fail), wlc->tx_prec_map,
	            wlc_txpktcnt(wlc));

	for (i = 0; i < NFIFO; i++) {
		if (wlc_bmac_xmtfifo_sz_get(wlc->hw, i, &fifo_size[i]))
			fifo_size[i] = 0;
	}
	bcm_bprintf(b, "xmtfifo_sz(in unit of 256B)");
	bcm_bprintf(b, "AC_BK %d AC_BE %d AC_VI %d AC_VO %d 5th %d 6th %d\n",
	            fifo_size[TX_AC_BK_FIFO],
	            fifo_size[TX_AC_BE_FIFO],
	            fifo_size[TX_AC_VI_FIFO],
	            fifo_size[TX_AC_VO_FIFO],
	            fifo_size[4],
	            fifo_size[5]);

	band = wlc->bandstate[IS_SINGLEBAND_5G(wlc->deviceid) ? BAND_5G_INDEX : BAND_2G_INDEX];
	bcm_bprintf(b, "(ROAMThreshold, ROAMDelta) (2.4G) default: %d, %d::current: %d, %d\n",
	            band->roam_trigger_def, band->roam_delta_def,
	            band->roam_trigger, band->roam_delta);

	if (NBANDS(wlc) > 1) {
		band = wlc->bandstate[BAND_5G_INDEX];
		bcm_bprintf(b, "(ROAMThreshold, ROAMDelta) (5G) default: %d, %d::current: %d, %d\n",
		            band->roam_trigger_def, band->roam_delta_def,
		            band->roam_trigger, band->roam_delta);
	}

	if (wlc->stf->pwr_throttle_state == WLC_PWRTHROTTLE_ON) {
		bcm_bprintf(b, "state:%d duty cycle:%d rxchain: %x txchain: %x\n",
		            wlc->stf->pwr_throttle_state,
		            wlc->stf->tx_duty_cycle_pwr,
		            wlc->stf->rxchain,
		            wlc->stf->txchain);
	}

	bcm_bprintf(b, "autocountry:%d autocountry_def:%s adopted_from_ap:%d\n",
		wlc->_autocountry, wlc->autocountry_default, wlc->autocountry_adopted_from_ap);

	tunables = wlc->pub->tunables;
	bcm_bprintf(b, "tunables:\n");
	bcm_bprintf(b, "\tntxd = %d, nrxd = %d, rxbufsz = %d, maxscb = %d\n",
	            tunables->ntxd, tunables->nrxd, tunables->rxbufsz, tunables->maxscb);
	bcm_bprintf(b, "\tampdunummpdu2streams = %d, ampdunummpdu3streams = %d\n",
	            tunables->ampdunummpdu2streams, tunables->ampdunummpdu3streams);
	bcm_bprintf(b, "\tmaxpktcb = %d, maxdpt = %d, maxucodebss = %d, maxucodebss4 = %d\n",
	            tunables->maxpktcb, tunables->maxdpt,
	            tunables->maxucodebss, tunables->maxucodebss4);
	bcm_bprintf(b, "\tmaxbss = %d, datahiwat = %d, ampdudatahiwat = %d\n",
	            tunables->maxbss, tunables->datahiwat, tunables->ampdudatahiwat);
	bcm_bprintf(b, "\trxbnd = %d, txsbnd = %d\n", tunables->rxbnd, tunables->txsbnd);
#ifdef WLC_HIGH_ONLY
	bcm_bprintf(b, "\trpctxbufpost = %d\n", tunables->rpctxbufpost);
#endif
#ifdef WLC_LOW_ONLY
	bcm_bprintf(b, "\tdngl_mem_restrict_rxdma = %d\n", tunables->dngl_mem_restrict_rxdma);
#endif
	return 0;
}

/* Print out the AC Params in an IE */
static void
wlc_dump_wme_ie(wlc_info_t *wlc, struct bcmstrbuf *b, edcf_acparam_t *acp_ie, const char *desc)
{
	int ac;

	bcm_bprintf(b, "EDCF params for %s\n", desc);

	for (ac = 0; ac < AC_COUNT; ac++, acp_ie++) {
		bcm_bprintf(b,
		               "%s: ACI 0x%02x ECW 0x%02x "
		               "(aci %d acm %d aifsn %d ecwmin %d ecwmax %d txop 0x%x)\n",
		               aci_names[ac],
		               acp_ie->ACI, acp_ie->ECW,
		               (acp_ie->ACI & EDCF_ACI_MASK) >> EDCF_ACI_SHIFT,
		               (acp_ie->ACI & EDCF_ACM_MASK) ? 1 : 0,
		               acp_ie->ACI & EDCF_AIFSN_MASK,
		               acp_ie->ECW & EDCF_ECWMIN_MASK,
		               (acp_ie->ECW & EDCF_ECWMAX_MASK) >> EDCF_ECWMAX_SHIFT,
		               ltoh16(acp_ie->TXOP));
	}

	bcm_bprintf(b, "\n");
}

/* Print out the AC Params in use by ucode */
static void
wlc_dump_wme_shm(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int ac;

	bcm_bprintf(b, "EDCF params in shared memory\n");

	for (ac = 0; ac < AC_COUNT; ac++) {
		shm_acparams_t shm_acp;
		uint16 *element;
		int j;

		element = (uint16 *)&shm_acp;

		/* fill in the ac param element from the shm locations */
		for (j = 0; j < (int)sizeof(shm_acparams_t); j += 2)
			*element++ = wlc_read_shm(wlc,
			                          M_EDCF_QINFO +
			                          wme_shmemacindex(ac) * M_EDCF_QLEN + j);

		bcm_bprintf(b,
		               "%s: txop 0x%x cwmin 0x%x cwmax 0x%x cwcur 0x%x\n"
		               "       aifs 0x%x bslots 0x%x reggap 0x%x status 0x%x\n",
		               aci_names[ac],
		               shm_acp.txop, shm_acp.cwmin, shm_acp.cwmax, shm_acp.cwcur,
		               shm_acp.aifs, shm_acp.bslots, shm_acp.reggap, shm_acp.status);
	}

	bcm_bprintf(b, "\n");
}

static int
wlc_dump_wme(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	d11regs_t *regs = wlc->regs;
	uint32 cwcur, cwmin, cwmax;
	uint8 qi;
	osl_t *osh;
	int idx;
	wlc_bsscfg_t *bsscfg;

	if (!((EDCF_ENAB(wlc->pub)) && (wlc->pub->up)))
		return BCME_ERROR;

	ASSERT(M_EDCF_QLEN == sizeof(shm_acparams_t));

	osh = wlc->osh;

	if (WME_ENAB(wlc->pub)) {
		qi = wlc->wme_param_ie.qosinfo;

		bcm_bprintf(b,
		               "WME enab %d apsd %d count %d admctl 0x%x dp 0x%x\n\n",
		               WME_ENAB(wlc->pub),
		               (qi & WME_QI_AP_APSD_MASK) >> WME_QI_AP_APSD_SHIFT,
		               (qi & WME_QI_AP_COUNT_MASK) >> WME_QI_AP_COUNT_SHIFT,
		               wlc->wme_admctl,
		               wlc->wme_dp);

		FOREACH_BSS(wlc, idx, bsscfg) {
			if (!BSS_WME_ENAB(wlc, bsscfg)) {
				bcm_bprintf(b, "WME no advert on BSS %d\n", idx);
			}
		}

		if (AP_ENAB(wlc->pub))
			wlc_dump_wme_ie(wlc, b,
				(edcf_acparam_t *)&wlc->ap->wme_param_ie_ap.acparam[0], "AP");

		wlc_dump_wme_ie(wlc, b,
			(edcf_acparam_t *)&wlc->wme_param_ie.acparam[0], "STA");

	}
	wlc_dump_wme_shm(wlc, b);

	/* read current cwcur, cwmin, cwmax */
	W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_CWMIN);
	(void)R_REG(osh, &regs->objaddr);
	cwmin = R_REG(osh, &regs->objdata);
	W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_CWMAX);
	(void)R_REG(osh, &regs->objaddr);
	cwmax = R_REG(osh, &regs->objdata);
	W_REG(osh, &regs->objaddr, OBJADDR_SCR_SEL | S_DOT11_CWCUR);
	(void)R_REG(osh, &regs->objaddr);
	cwcur = R_REG(osh, &regs->objdata);

	bcm_bprintf(b, "xfifordy 0x%x psm_b0 0x%x txf_cur_idx 0x%x\n",
		R_REG(osh, &regs->xmtfifordy), R_REG(osh, &regs->psm_base_0),
		wlc_read_shm(wlc, M_TXF_CUR_INDEX));
	bcm_bprintf(b, "cwcur 0x%x cwmin 0x%x cwmax 0x%x\n", cwcur, cwmin, cwmax);

	bcm_bprintf(b, "\n");

	return 0;
}

#ifdef MBSS
/* Get the SSID for the indicated (idx) bsscfg from SHM Return the length
 */
static void
wlc_shm_ssid_get(wlc_info_t *wlc, int idx, wlc_ssid_t *ssid)
{
	int i;
	int base;
	uint16 tmpval;
	int ucode_idx;

	ucode_idx = WLC_BSSCFG_UCIDX(wlc->bsscfg[idx]);

	if (MBSS_ENAB16(wlc->pub)) {
		base = SHM_MBSS_SSIDSE_BASE_ADDR + (ucode_idx * SHM_MBSS_SSIDSE_BLKSZ);
		wlc_bmac_copyfrom_objmem(wlc->hw, base, &ssid->SSID_len,
		                       SHM_MBSS_SSIDLEN_BLKSZ, OBJADDR_SRCHM_SEL);
		/* search mem length field is always little endian */
		ssid->SSID_len = ltoh32(ssid->SSID_len);
		base += SHM_MBSS_SSIDLEN_BLKSZ;
		wlc_bmac_copyfrom_objmem(wlc->hw, base, ssid->SSID,
		                       SHM_MBSS_SSID_BLKSZ, OBJADDR_SRCHM_SEL);
		return;
	}

	WLC_MBSS_SSID_LEN_GET(wlc, ucode_idx, ssid->SSID_len);
	base = SHM_MBSS_SSID_ADDR(ucode_idx);
	for (i = 0; i < DOT11_MAX_SSID_LEN; i += 2) {
		tmpval = wlc_read_shm(wlc, base + i);
		ssid->SSID[i] = tmpval & 0xFF;
		ssid->SSID[i + 1] = tmpval >> 8;
	}
}

#endif /* MBSS */

static const char *wlc_bsscfg_flags_str[] = { WLC_BSSCFG_FLAGS_STR_INIT };
static const int wlc_bsscfg_flags_count = ARRAYSIZE(wlc_bsscfg_flags_str);

static int
wlc_dump_bsscfg(wlc_info_t *wlc, wlc_bsscfg_t *cfg, int bsscfg_idx, struct bcmstrbuf *b)
{
	char ssidbuf[SSID_FMT_BUF_LEN];
	char bssbuf[ETHER_ADDR_STR_LEN];
	char ifname[32];
	wsec_key_t *key;
	int i, j;
	vndr_ie_listel_t *vndrie;

	wlc_format_ssid(ssidbuf, cfg->SSID, cfg->SSID_len);

	strncpy(ifname, wl_ifname(wlc->wl, cfg->wlcif->wlif), sizeof(ifname));
	ifname[sizeof(ifname) - 1] = '\0';

	bcm_bprintf(b, "BSS Config %d (0x%p): \"%s\". BSSID: %s\n", bsscfg_idx, cfg, ssidbuf,
		bcm_ether_ntoa(&cfg->BSSID, bssbuf));

	bcm_bprintf(b, "_ap %d BSS %d enable %d. up %d. associated %d. flags 0x%x:",
	            cfg->_ap, cfg->BSS, cfg->enable, cfg->up, cfg->associated, cfg->flags);
	for (i = 0; i < wlc_bsscfg_flags_count; i++) {
		if (cfg->flags & (1 << i)) bcm_bprintf(b, " %s", wlc_bsscfg_flags_str[i]);
	}
	bcm_bprintf(b, "\n");

	/* allmulti and multicast lists */
	bcm_bprintf(b, "allmulti %d\n", cfg->allmulti);
	bcm_bprintf(b, "nmulticast %d\n", cfg->nmulticast);
	if (cfg->nmulticast) {
		for (i = 0; i < (int)cfg->nmulticast; i++)
			bcm_bprintf(b, "%s ", bcm_ether_ntoa(&cfg->multicast[i], bssbuf));
		bcm_bprintf(b, "\n");
	}

#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub)) {
		char chanbuf[CHANSPEC_STR_LEN];
		bcm_bprintf(b, "context: %p, ctxt_chanspec %s, wlcif->qi = %p\n",
		            cfg->chan_context,
		            (cfg->chan_context ?
		             wf_chspec_ntoa(cfg->chan_context->chanspec, chanbuf) :
		             "0"),
		            cfg->wlcif->qi);
		bcm_bprintf(b, "chanspec %s\n",
		            wf_chspec_ntoa(cfg->chanspec, chanbuf));
	}
#endif /* WLMCHAN */
	bcm_bprintf(b, "cur_etheraddr %s\n", bcm_ether_ntoa(&cfg->cur_etheraddr, bssbuf));
	bcm_bprintf(b, "wlcif: flags 0x%x wlif 0x%p \"%s\"\n",
		cfg->wlcif->flags, cfg->wlcif->wlif, ifname);
	bcm_bprintf(b, "ap_isolate %d\n", cfg->ap_isolate);
	bcm_bprintf(b, "nobcnssid %d nobcprbresp %d\n",
		cfg->closednet_nobcnssid, cfg->closednet_nobcprbresp);
	bcm_bprintf(b, "wsec 0x%x auth %d wsec_index %d wep_algo %d\n",
		cfg->wsec, cfg->auth, cfg->wsec_index, WSEC_BSS_DEFAULT_KEY(cfg) ?
		WSEC_BSS_DEFAULT_KEY(cfg)->algo : 0);
	bcm_bprintf(b, "WPA_auth 0x%x wsec_restrict %d eap_restrict %d",
		cfg->WPA_auth, cfg->wsec_restrict, cfg->eap_restrict);
	bcm_bprintf(b, " wpa2_preauth %d", cfg->wpa2_preauth);
	bcm_bprintf(b, "\n");
#if defined(BCMSUP_PSK)
	bcm_bprintf(b, " sup_type %d sup %p\n", cfg->sup_type, cfg->sup);
#endif
#ifdef BCMAUTH_PSK
	bcm_bprintf(b, " authenticator %p\n", cfg->authenticator);
#endif
	bcm_bprintf(b, "tkip_countermeasures %d tk_cm_dt %d tk_cm_bt %d tk_cm_activate %d\n",
		cfg->tkip_countermeasures, cfg->tk_cm_dt, cfg->tk_cm_bt, cfg->tk_cm_activate);
	bcm_bprintf(b, "macmode %d (%s)", cfg->macmode,
		cfg->macmode == 0  ? "disabled" : cfg->macmode == 1 ? "deny" : "allow");
	if (cfg->macmode) {
		bcm_bprintf(b, " nmac %d:\n", cfg->nmac);
		for (i = 0; i < (int)cfg->nmac; i++) {
			bcm_bprintf(b, "%s ", bcm_ether_ntoa(&cfg->maclist[i], bssbuf));
		}
	}
	bcm_bprintf(b, "\n");

	for (i = 0; i < WLC_DEFAULT_KEYS; i++) {
		key = cfg->bss_def_keys[i];
		if (key) {
			bcm_bprintf(b, "Key ID: %d%s %s\tidx %d len %2d data ",
				key->id, (i == cfg->wsec_index) ? "*" : " ",
			        bcm_crypto_algo_name(key->algo),
				key->idx, key->len);

			if (key->len)
				bcm_bprintf(b, "0x");

			for (j = 0; j < (int)key->len; j++)
				bcm_bprintf(b, "%02X", key->data[j]);

			for (j = 0; j < (int)key->len; j++)
				if (!bcm_isprint(key->data[j]))
					break;
			if (j == (int)key->len)
				bcm_bprintf(b, " (%.*s)", (int)key->len, key->data);
			bcm_bprintf(b, "\n");

		}
	}

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub)) {
		bcm_bprintf(b, "RA rcmta: %d", cfg->rcmta_ra_idx);
		if (wlc->clk &&
		    cfg->rcmta_ra_idx >= P2P_ADDR_STRT_INDX && cfg->rcmta_ra_idx < RCMTA_SIZE) {
			uint offset = M_ADDR_BMP_BLK(cfg->rcmta_ra_idx - P2P_ADDR_STRT_INDX);
			bcm_bprintf(b, " type: 0x%x", wlc_p2p_read_shm(wlc->p2p, offset));
		}
		bcm_bprintf(b, "\n");
		bcm_bprintf(b, "BSSID rcmta: %d", cfg->rcmta_bssid_idx);
		if (wlc->clk &&
		    cfg->rcmta_bssid_idx >= P2P_ADDR_STRT_INDX &&
		    cfg->rcmta_bssid_idx < RCMTA_SIZE) {
			uint offset = M_ADDR_BMP_BLK(cfg->rcmta_bssid_idx - P2P_ADDR_STRT_INDX);
			bcm_bprintf(b, " type: 0x%x", wlc_p2p_read_shm(wlc->p2p, offset));
		}
		bcm_bprintf(b, "\n");
	}
	else
#endif /* WLP2P */
	if (cfg->rcmta != NULL)
		bcm_bprintf(b, "BSSID rcmta: %d(%p)\n",
		            WSEC_KEY_INDEX(wlc, cfg->rcmta), cfg->rcmta);

#ifdef MBSS
	bcm_bprintf(b, "PS trans %u.\n", WLCNTVAL(cfg->cnt->ps_trans));
#if defined(WLC_SPT_DEBUG)
	bcm_bprintf(b, "BCN: bcn tx cnt %u. bcn suppressed %u\n",
		cfg->bcn_template->tx_count, cfg->bcn_template->suppressed);
#endif /* WLC_SPT_DEBUG */
	bcm_bprintf(b, "PrbResp: soft-prb-resp %s. directed req %d, alloc_fail %d, tx_fail %d\n",
		SOFTPRB_ENAB(cfg) ? "enabled" : "disabled",
		WLCNTVAL(cfg->cnt->prq_directed_entries), WLCNTVAL(cfg->cnt->prb_resp_alloc_fail),
		WLCNTVAL(cfg->cnt->prb_resp_tx_fail));
	bcm_bprintf(b, "PrbResp: TBTT suppressions %d. TTL expires %d. retrx fail %d.\n",
		WLCNTVAL(cfg->cnt->prb_resp_retrx), WLCNTVAL(cfg->cnt->prb_resp_ttl_expy),
		WLCNTVAL(cfg->cnt->prb_resp_retrx_fail));
	bcm_bprintf(b, "BCN: soft-bcn %s. bcn in use bmap 0x%x. bcn fail %u\n",
		SOFTBCN_ENAB(cfg) ? "enabled" : "disabled",
		cfg->bcn_template->in_use_bitmap, WLCNTVAL(cfg->cnt->bcn_tx_failed));
	bcm_bprintf(b, "BCN: HW MBSS %s. bcn in use bmap 0x%x. bcn fail %u\n",
		UCTPL_MBSS_ENAB(cfg) ? "enabled" : "disabled",
		cfg->bcn_template->in_use_bitmap, WLCNTVAL(cfg->cnt->bcn_tx_failed));
	bcm_bprintf(b, "PRB: HW MBSS %s.\n",
		UCTPL_MBSS_ENAB(cfg) ? "enabled" : "disabled");
	bcm_bprintf(b, "MC pkts in fifo %u. Max %u\n", cfg->mc_fifo_pkts,
		WLCNTVAL(cfg->cnt->mc_fifo_max));
	if (wlc->clk) {
		wlc_ssid_t ssid;
		uint16 shm_fid;

		shm_fid = wlc_read_shm((wlc), SHM_MBSS_WORD_OFFSET_TO_ADDR(5 + cfg->_ucidx));
		bcm_bprintf(b, "bcmc_fid 0x%x. bcmc_fid_shm 0x%x. shm last fid 0x%x. "
			"bcmc TX pkts %u\n", cfg->bcmc_fid, cfg->bcmc_fid_shm, shm_fid,
			WLCNTVAL(cfg->cnt->bcmc_count));
		wlc_shm_ssid_get(wlc, bsscfg_idx, &ssid);
		if (ssid.SSID_len > DOT11_MAX_SSID_LEN) {
			WL_ERROR(("Warning: Invalid MBSS ssid length %d for BSS %d\n",
				ssid.SSID_len, bsscfg_idx));
			ssid.SSID_len = DOT11_MAX_SSID_LEN;
		}
		wlc_format_ssid(ssidbuf, ssid.SSID, ssid.SSID_len);
		bcm_bprintf(b, "MBSS: ucode idx %d; shm ssid >%s< of len %d\n",
			WLC_BSSCFG_UCIDX(cfg), ssidbuf, ssid.SSID_len);
	} else {
		bcm_bprintf(b, "Core clock disabled, not dumping SHM info\n");
	}
#endif /* MBSS */

	bcm_bprintf(b, "rssi %d snr %d\n", cfg->link->rssi, cfg->link->snr);
#ifdef WL_BSSCFG_TX_SUPR
	bcm_bprintf(b, "%s, length %d\n", BSS_TX_SUPR(cfg)? "suppressed":"not suppressed",
	            pktq_len(cfg->psq));
#endif

	/* vendor IEs */
	for (vndrie = cfg->vndr_ie_listp; vndrie != NULL; vndrie = vndrie->next_el) {
		bcm_tlv_t *ie = (bcm_tlv_t *)&vndrie->vndr_ie_infoel.vndr_ie_data;

		bcm_bprintf(b, "flags: %08x ", vndrie->vndr_ie_infoel.pktflag);
		wlc_dump_ie(wlc, ie, b);
		bcm_bprintf(b, "\n");
	}

	/* CSA info */
	bcm_bprintf(b, "csa->spect_state 0x%x, csa->csa_timer %p\n",
	            cfg->csa->spect_state, cfg->csa->csa_timer);
	bcm_bprintf(b, "csa->csa.mode %d, csa->csa.count %d\n",
	            cfg->csa->csa.mode, cfg->csa->csa.count);
	bcm_bprintf(b, "csa->csa.chspec 0x%x, csa->csa.reg %d \n",
	            cfg->csa->csa.chspec, cfg->csa->csa.reg);

	return 0;
}
#endif /* !WLLMAC_ONLY */
#endif /* BCMDBG || BCMDBG_DUMP */

#ifdef BCMDBG
static const char *supr_reason[] = {
	"None", "PMQ Entry", "Flush request",
	"Previous frag failure", "Channel mismatch",
	"Lifetime Expiry", "Underflow", "AB NACK or TX SUPR"
};

static void
wlc_print_txs_status(uint16 s)
{
	printf("[15:12]  %d  frame attempts\n", (s & TX_STATUS_FRM_RTX_MASK) >>
	       TX_STATUS_FRM_RTX_SHIFT);
	printf(" [11:8]  %d  rts attempts\n", (s & TX_STATUS_RTS_RTX_MASK) >>
	       TX_STATUS_RTS_RTX_SHIFT);
	printf("    [7]  %d  PM mode indicated\n", ((s & TX_STATUS_PMINDCTD) ? 1 : 0));
	printf("    [6]  %d  intermediate status\n", ((s & TX_STATUS_INTERMEDIATE) ? 1 : 0));
	printf("    [5]  %d  AMPDU\n", (s & TX_STATUS_AMPDU) ? 1 : 0);
	printf("  [4:2]  %d  Frame Suppressed Reason (%s)\n",
	           ((s & TX_STATUS_SUPR_MASK) >> TX_STATUS_SUPR_SHIFT),
	           supr_reason[(s & TX_STATUS_SUPR_MASK) >> TX_STATUS_SUPR_SHIFT]);
	printf("    [1]  %d  acked\n", ((s & TX_STATUS_ACK_RCV) ? 1 : 0));
}
#endif /* BCMDBG */

void
wlc_print_txstatus(tx_status_t* txs)
{
#if defined(BCMDBG) || defined(BCMDBG_ERR) || defined(WLMSG_PRHDRS) || \
	defined(WLMSG_PRPKT)
	uint16 s = txs->status;
	uint16 ackphyrxsh = txs->ackphyrxsh;

	printf("\ntxpkt (MPDU) Complete\n");

	printf("FrameID: %04x   ", txs->frameid);
	printf("TxStatus: %04x", s);
	printf("\n");

#ifdef BCMDBG
	wlc_print_txs_status(s);
#endif

	printf("LastTxTime: %08x ", txs->lasttxtime);
	printf("Seq: %04x ", txs->sequence);
	printf("PHYTxStatus: %04x ", txs->phyerr);
	printf("RxAckRSSI: %04x ", (ackphyrxsh & PRXS1_JSSI_MASK) >> PRXS1_JSSI_SHIFT);
	printf("RxAckSQ: %04x", (ackphyrxsh & PRXS1_SQ_MASK) >> PRXS1_SQ_SHIFT);
	printf("\n");
#endif	/* BCMDBG || BCMDBG_ERR || WLMSG_PRHDRS || WLMSG_PRPKT */
}

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
#define	PRVAL(name)	bcm_bprintf(b, "%s %d ", #name, WLCNTVAL(wlc->pub->_cnt->name))
#define	PRNL()		bcm_bprintf(b, "\n")

#ifndef WLLMAC_ONLY
#define	PRREG(name)	bcm_bprintf(b, #name " 0x%x ", R_REG(wlc->osh, &regs->name))
#define PRREG_INDEX(name, reg) bcm_bprintf(b, #name " 0x%x ", R_REG(wlc->osh, &reg))

static int
wlc_dump_dma(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	d11regs_t *regs;
	int i;

	regs = wlc->regs;

	if (!wlc->clk)
		return BCME_NOCLK;

	for (i = 0; i < NFIFO; i++) {
		PRREG_INDEX(intstatus, wlc->regs->intctrlregs[i].intstatus);
		PRREG_INDEX(intmask, wlc->regs->intctrlregs[i].intmask);
		bcm_bprintf(b, "\n");
		if (!PIO_ENAB(wlc->pub)) {
			bcm_bprintf(b, "DMA %d: ", i);
			if (wlc->hw->di[i])	{
				dma_dumptx(wlc->hw->di[i], b, TRUE);
				if ((i == RX_FIFO) ||
				    (D11REV_IS(wlc->pub->corerev, 4) && (i == RX_TXSTATUS_FIFO))) {
					dma_dumprx(wlc->hw->di[i], b, TRUE);
					PRVAL(rxuflo[i]);
				} else
					PRVAL(txuflo);
				PRNL();
			}
		}
		bcm_bprintf(b, "\n");
	}

	PRVAL(dmada); PRVAL(dmade); PRVAL(rxoflo); PRVAL(dmape);
	bcm_bprintf(b, "\n");

	return 0;
}

static int
wlc_dump_mac(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	d11regs_t *regs;
	uint16 match_data[6];
	char ea[ETHER_ADDR_STR_LEN];
	char *p;
	int i;

	regs = wlc->regs;

	if (!wlc->clk)
		return BCME_NOCLK;

	PRREG(biststatus);
	bcm_bprintf(b, "\n");

	PRREG(maccontrol); PRREG(maccommand); PRREG(macintstatus); PRREG(macintmask);
	bcm_bprintf(b, "\n");
	PRREG(chnstatus);
	PRREG(psmdebug); PRREG(phydebug);
	bcm_bprintf(b, "\n");

	PRREG(psm_gpio_in); PRREG(psm_gpio_out); PRREG(psm_gpio_oe);
	bcm_bprintf(b, "\n\n");

	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		W_REG(wlc->osh, &regs->rcm_ctl, i);
		match_data[i] = R_REG(wlc->osh, &regs->rcm_mat_data);
		match_data[i] = htol16(match_data[i]);
	}

	/* read mac addr words from match_data[0, 2] */
	p = (char*)&match_data[0];
	bcm_bprintf(b, "MAC addr %s ", bcm_ether_ntoa((struct ether_addr*)p, ea));

	/* read mac addr words from match_data[3, 5] */
	p = (char*)&match_data[3];
	bcm_bprintf(b, "BSSID %s\n\n", bcm_ether_ntoa((struct ether_addr*)p, ea));

	return 0;
}

static int
wlc_dump_pio(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	int i;

	if (!wlc->clk)
		return BCME_NOCLK;

	if (!PIO_ENAB(wlc->pub))
		return 0;

	for (i = 0; i < NFIFO; i++) {
		bcm_bprintf(b, "PIO %d: ", i);
		if (wlc->hw->pio[i])
			wlc_pio_dump(wlc->hw->pio[i], b);
		bcm_bprintf(b, "\n");
	}

	return 0;
}

static void
wlc_dump_bcntpl(wlc_info_t *wlc, struct bcmstrbuf *b, int offset, int len)
{
	d11regs_t *regs;
	osl_t *osh;
	uint16 val;
	uint i;

	regs = wlc->regs;
	osh = wlc->osh;

	len = (len + 3) & ~3;

	bcm_bprintf(b, "tpl: offset %d len %d\n", offset, len);

	while ((val = R_REG(osh, &regs->xmttplateptr)) & 3)
		printf("read_txe_ram: polling xmttplateptr 0x%x\n", val);

	for (i = 0; i < (uint)len; i += 4) {
		W_REG(osh, &regs->xmttplateptr, (offset + i) | 2);
		while ((val = R_REG(osh, &regs->xmttplateptr)) & 2)
			printf("read_txe_ram: polling xmttplateptr 0x%x\n", val);
		bcm_bprintf(b, "%04X: %04X%04X\n", i,
		            R_REG(osh, &regs->xmttplatedatahi),
		            R_REG(osh, &regs->xmttplatedatalo));
	}
}

static int
wlc_dump_bcntpls(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint16 len;

	/* if multiband, band must be set */
	if (IS_MBAND_UNLOCKED(wlc)) {
		WL_ERROR(("wl%d: %s: band must be locked\n", wlc->pub->unit, __FUNCTION__));
		return BCME_NOTBANDLOCKED;
	}

	if (!wlc->clk) {
		WL_ERROR(("wl%d: %s: clock must be on\n", wlc->pub->unit, __FUNCTION__));
		return BCME_NOCLK;
	}

	len = wlc_read_shm(wlc, M_BCN0_FRM_BYTESZ);
	bcm_bprintf(b, "bcn 0: len %u\n", len);
	wlc_dump_bcntpl(wlc, b, T_BCN0_TPL_BASE, len);
	len = wlc_read_shm(wlc, M_BCN1_FRM_BYTESZ);
	bcm_bprintf(b, "bcn 1: len %u\n", len);
	wlc_dump_bcntpl(wlc, b, T_BCN1_TPL_BASE, len);

	return 0;
}
#endif /* !WLLMAC_ONLY */
#endif	/* BCMDBG || BCMDBG_DUMP */

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
#ifndef WLLMAC_ONLY
int
wlc_dump_bss_info(const char *name, wlc_bss_info_t *bi, struct bcmstrbuf *b)
{
	char bssid[DOT11_MAX_SSID_LEN];
	char ssidbuf[SSID_FMT_BUF_LEN];

	wlc_format_ssid(ssidbuf, bi->SSID, bi->SSID_len);

	bcm_bprintf(b, "%s: %s BSSID %s\n", name, (bi->infra == 1?"Infra":(bi->infra ==
		0?"IBSS":"auto")),
		bcm_ether_ntoa(&bi->BSSID, bssid));
	bcm_bprintf(b, "SSID len %d \"%s\" ISBRCM %d ISHT %d\n", bi->SSID_len, ssidbuf,
		((bi->flags & WLC_BSS_BRCM) != 0), ((bi->flags & WLC_BSS_HT) != 0));
	bcm_bprintf(b, "channel %d chanspec 0x%x beacon %d dtim %d atim %d capability 0x%04x"
		" flags 0x%02x RSSI %d\n",
		CHSPEC_CHANNEL(bi->chanspec), bi->chanspec, bi->beacon_period, bi->dtim_period,
		bi->atim_window, bi->capability, bi->flags, bi->RSSI);
	wlc_dump_rateset("rateset", &bi->rateset, b);
	if (bi->rateset.htphy_membership)
		bcm_bprintf(b, "\nmembership %d(b)",
			(bi->rateset.htphy_membership & RATE_MASK));
	if (bi->flags & WLC_BSS_HT) {
		wlc_dump_mcsset("\nmcs", &bi->rateset.mcs[0], b);
	}
	bcm_bprintf(b, "\n");

	return 0;
}

/* print aggregate (since driver load time) driver and macstat counter values */
static int
wlc_dump_stats(wlc_info_t *wlc, struct bcmstrbuf * b)
{
#ifdef WLCNT
	int i;
	wl_cnt_t *cnt = wlc->pub->_cnt;

	if (WLC_UPDATE_STATS(wlc)) {
		wlc_statsupd(wlc);
	}

	/* summary stat counter line */
	PRVAL(txframe); PRVAL(txbyte); PRVAL(txretrans); PRVAL(txerror);
	PRVAL(rxframe); PRVAL(rxbyte); PRVAL(rxerror); PRNL();

	PRVAL(txprshort); PRVAL(txdmawar); PRVAL(txnobuf); PRVAL(txnoassoc);
	PRVAL(txchit); PRVAL(txcmiss); PRVAL(txchanrej); PRVAL(txexptime); PRNL();

	PRVAL(reset); PRVAL(txserr); PRVAL(txphyerr); PRVAL(txphycrs);
	PRVAL(txfail); PRVAL(psmwds); PRVAL(phywatchdog); PRVAL(rfdisable); PRNL();

	bcm_bprintf(b, "d11_txfrag %d d11_txmulti %d d11_txretry %d d11_txretrie %d\n",
		cnt->txfrag, cnt->txmulti, cnt->txretry, cnt->txretrie);

	bcm_bprintf(b, "d11_txrts %d d11_txnocts %d d11_txnoack %d d11_txfrmsnt %d\n",
		cnt->txrts, cnt->txnocts, cnt->txnoack, cnt->txfrmsnt);

	PRVAL(rxcrc); PRVAL(rxnobuf); PRVAL(rxnondata); PRVAL(rxbadds);
	PRVAL(rxbadcm); PRVAL(rxdup); PRVAL(rxfragerr); PRNL();

	PRVAL(rxrunt); PRVAL(rxgiant); PRVAL(rxnoscb); PRVAL(rxbadproto);
	PRVAL(rxbadsrcmac); PRNL();

	bcm_bprintf(b, "d11_rxfrag %d d11_rxmulti %d d11_rxundec %d d11_rxundec_mcst %d\n",
		cnt->rxfrag, cnt->rxmulti, cnt->rxundec, cnt->rxundec_mcst);

	PRVAL(rxctl); PRVAL(rxbadda); PRVAL(rxfilter); PRNL();

	bcm_bprintf(b, "rxuflo: ");
	for (i = 0; i < NFIFO; i++)
		bcm_bprintf(b, "%d ", cnt->rxuflo[i]);
	bcm_bprintf(b, "\n");
	PRVAL(txallfrm); PRVAL(txrtsfrm); PRVAL(txctsfrm); PRVAL(txackfrm); PRNL();
	PRVAL(txdnlfrm); PRVAL(txbcnfrm); PRVAL(txtplunfl); PRVAL(txphyerr); PRNL();
	bcm_bprintf(b, "txfunfl: ");
	for (i = 0; i < NFIFO; i++)
		bcm_bprintf(b, "%d ", cnt->txfunfl[i]);
	bcm_bprintf(b, "\n");

	/* WPA2 counters */
	PRVAL(tkipmicfaill); PRVAL(tkipicverr); PRVAL(tkipcntrmsr); PRNL();
	PRVAL(tkipreplay); PRVAL(ccmpfmterr); PRVAL(ccmpreplay); PRNL();
	PRVAL(ccmpundec); PRVAL(fourwayfail); PRVAL(wepundec); PRNL();
	PRVAL(wepicverr); PRVAL(decsuccess); PRVAL(rxundec); PRNL();

	PRVAL(tkipmicfaill_mcst); PRVAL(tkipicverr_mcst); PRVAL(tkipcntrmsr_mcst); PRNL();
	PRVAL(tkipreplay_mcst); PRVAL(ccmpfmterr_mcst); PRVAL(ccmpreplay_mcst); PRNL();
	PRVAL(ccmpundec_mcst); PRVAL(fourwayfail_mcst); PRVAL(wepundec_mcst); PRNL();
	PRVAL(wepicverr_mcst); PRVAL(decsuccess_mcst); PRVAL(rxundec_mcst); PRNL();

	PRVAL(rxfrmtoolong); PRVAL(rxfrmtooshrt); PRVAL(rxinvmachdr); PRVAL(rxbadfcs); PRNL();
	PRVAL(rxbadplcp); PRVAL(rxcrsglitch); PRVAL(rxstrt); PRVAL(rxdfrmucastmbss); PRNL();
	PRVAL(rxmfrmucastmbss); PRVAL(rxcfrmucast); PRVAL(rxrtsucast); PRVAL(rxctsucast); PRNL();
	PRVAL(rxackucast); PRVAL(rxdfrmocast); PRVAL(rxmfrmocast); PRVAL(rxcfrmocast); PRNL();
	PRVAL(rxrtsocast); PRVAL(rxctsocast); PRVAL(rxdfrmmcast); PRVAL(rxmfrmmcast); PRNL();
	PRVAL(rxcfrmmcast); PRVAL(rxbeaconmbss); PRVAL(rxdfrmucastobss); PRVAL(rxbeaconobss);
		PRNL();
	PRVAL(rxrsptmout); PRVAL(bcntxcancl); PRVAL(rxf0ovfl); PRVAL(rxf1ovfl); PRNL();
	PRVAL(rxf2ovfl); PRVAL(txsfovfl); PRVAL(pmqovfl); PRNL();
	PRVAL(rxcgprqfrm); PRVAL(rxcgprsqovfl); PRVAL(txcgprsfail); PRVAL(txcgprssuc); PRNL();
	PRVAL(prs_timeout); PRVAL(rxnack); PRVAL(frmscons); PRVAL(txnack); PRVAL(txglitch_nack);
		PRNL();
	PRVAL(txburst); PRVAL(txphyerror); PRVAL(txchanrej); PRNL();
	PRVAL(pktengrxducast); PRVAL(pktengrxdmcast); PRNL();
	PRVAL(txmpdu_sgi); PRVAL(rxmpdu_sgi); PRVAL(txmpdu_stbc); PRVAL(rxmpdu_stbc); PRNL();

#endif /* WLCNT */
	return 0;
}


static int
wlc_dump_btc(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	wlc_bmac_dump(wlc->hw, b, BMAC_DUMP_BTC_ID);
	return 0;
}
#endif /* !WLLMAC_ONLY */

#endif /* BCMDBG || BCMDBG_DUMP */

#if defined(BCMDBG) || defined(BCMDBG_DUMP) || defined(WLTEST)
#ifndef WLLMAC_ONLY
static int
wlc_dump_rssi(wlc_info_t *wlc, struct bcmstrbuf * b)
{
	uint32 i, idx, antidx, max_ant;
	int32 tot;

	if (!wlc->pub->up)
		return BCME_NOTUP;

	bcm_bprintf(b, "History and average of latest %d RSSI values:\n", WLC_RSSI_WINDOW_SZ);

	max_ant = (uint8)WLC_BITSCNT(wlc->stf->hw_rxchain);
	ASSERT(max_ant <= (uint32)(WLCISHTPHY(wlc->band) ? WL_ANT_HT_RX_MAX : WL_ANT_RX_MAX));
	for (antidx = WL_ANT_IDX_1; antidx < max_ant; antidx++) {
		if (((wlc->stf->rxchain >> antidx) & 1) == 0)
			continue;
		tot = 0;
		bcm_bprintf(b, "Ant%d: [", antidx);

		idx = wlc->rssi_win_rfchain_idx;
		for (i = 0; i < WLC_RSSI_WINDOW_SZ; i++) {
			bcm_bprintf(b, "%3d ", wlc->rssi_win_rfchain[antidx][idx]);
			tot += wlc->rssi_win_rfchain[antidx][idx];
			idx = MODINC_POW2(idx, WLC_RSSI_WINDOW_SZ);
		}
		bcm_bprintf(b, "]");

		tot /= WLC_RSSI_WINDOW_SZ;
		bcm_bprintf(b, "avg [%4d]\n", tot);
	}

	return 0;
}
#endif /* !WLLMAC_ONLY */
#endif /* BCMDBG || BCMDBG_DUMP || WLTEST */

#ifdef BCMDBG
void
wlc_dump_ucode_fatal(wlc_info_t *wlc)
{
	uint32 phydebug, psm_brc, psmdebug;
	uint32 wepctl, pcmctl, pcmstat;
	d11regs_t *regs;

	regs = wlc->regs;

	WL_ERROR(("wl%d: PSM microcode watchdog fired at %d (seconds)\n",
		wlc->pub->unit, wlc->pub->now));

	psmdebug = R_REG(wlc->osh, &regs->psmdebug);
	phydebug = R_REG(wlc->osh, &regs->phydebug);
	psm_brc = R_REG(wlc->osh, &regs->psm_brc);
	wepctl = R_REG(wlc->osh, &regs->wepctl);
	pcmctl = R_REG(wlc->osh, &regs->pcmctl);
	pcmstat = R_REG(wlc->osh, &regs->pcmstat);

	wlc_mac_event(wlc, WLC_E_PSM_WATCHDOG, NULL, psmdebug, phydebug, psm_brc, NULL, 0);
	/* dump regs */
	WL_ERROR(("wl%d: psmdebug 0x%08x, phydebug 0x%08x, psm_brc 0x%08x\n",
		wlc->pub->unit, psmdebug, phydebug, psm_brc));
	WL_ERROR(("     wepctl 0x%08x, pcmctl 0x%08x, pcmstat 0x%08x\n",
		wepctl, pcmctl, pcmstat));
#ifdef WLAMPDU_MAC
	 if (AMPDU_MAC_ENAB(wlc->pub))
		 wlc_dump_aggfifo(wlc, NULL);
#endif
}
#endif /* BCMDBG */

#ifdef WLCNT
static void
wlc_ctrupd_cache(uint16 cur_stat, uint16 *macstat_snapshot, uint32 *macstat)
{
	uint16 v;
	uint16 delta;

	v = ltoh16(cur_stat);
	delta = (uint16)(v - *macstat_snapshot);

	if (delta != 0) {
		*macstat += delta;
		*macstat_snapshot = v;
	}
}
#endif /* WLCNT */

#define MACSTATUPD(name) \
	wlc_ctrupd_cache(macstats.name, &wlc->core->macstat_snapshot->name, &wlc->pub->_cnt->name)

void
wlc_statsupd(wlc_info_t *wlc)
{
	int i;
#ifdef BCMDBG
	uint16 delta;
	uint16 rxf0ovfl;
	uint16 txfunfl[NFIFO];
#endif /* BCMDBG */
#ifdef WLCNT
	macstat_t macstats;
#endif

	/* if driver or core are down, makes no sense to update stats */
	if (!wlc->pub->up || !wlc->clk)
		return;

#ifdef BCMDBG
	/* save last rx fifo 0 overflow count */
	rxf0ovfl = wlc->core->macstat_snapshot->rxf0ovfl;

	/* save last tx fifo  underflow count */
	for (i = 0; i < NFIFO; i++)
		txfunfl[i] = wlc->core->macstat_snapshot->txfunfl[i];
#endif /* BCMDBG */

#ifdef WLCNT
	/* Read mac stats from contiguous shared memory */
	wlc_bmac_copyfrom_shm(wlc->hw, M_UCODE_MACSTAT, &macstats, sizeof(macstat_t));

	/* update mac stats */
	MACSTATUPD(txallfrm);
	MACSTATUPD(txrtsfrm);
	MACSTATUPD(txctsfrm);
	MACSTATUPD(txackfrm);
	MACSTATUPD(txdnlfrm);
	MACSTATUPD(txbcnfrm);
	for (i = 0; i < NFIFO; i++)
		MACSTATUPD(txfunfl[i]);
	MACSTATUPD(txtplunfl);
	MACSTATUPD(txphyerr);
	MACSTATUPD(rxfrmtoolong);
	MACSTATUPD(rxfrmtooshrt);
	MACSTATUPD(rxinvmachdr);
	MACSTATUPD(rxbadfcs);
	MACSTATUPD(rxbadplcp);
	MACSTATUPD(rxcrsglitch);
	MACSTATUPD(rxstrt);
	MACSTATUPD(rxdfrmucastmbss);
	MACSTATUPD(rxmfrmucastmbss);
	MACSTATUPD(rxcfrmucast);
	MACSTATUPD(rxrtsucast);
	MACSTATUPD(rxctsucast);
	MACSTATUPD(rxackucast);
	MACSTATUPD(rxdfrmocast);
	MACSTATUPD(rxmfrmocast);
	MACSTATUPD(rxcfrmocast);
	MACSTATUPD(rxrtsocast);
	MACSTATUPD(rxctsocast);
	MACSTATUPD(rxdfrmmcast);
	MACSTATUPD(rxmfrmmcast);
	MACSTATUPD(rxcfrmmcast);
	MACSTATUPD(rxbeaconmbss);
	MACSTATUPD(rxdfrmucastobss);
	MACSTATUPD(rxbeaconobss);
	MACSTATUPD(rxrsptmout);
	MACSTATUPD(bcntxcancl);
	MACSTATUPD(rxf0ovfl);
	MACSTATUPD(rxf1ovfl);
	MACSTATUPD(rxf2ovfl);
	MACSTATUPD(txsfovfl);
	MACSTATUPD(pmqovfl);
	MACSTATUPD(rxcgprqfrm);
	MACSTATUPD(rxcgprsqovfl);
	MACSTATUPD(txcgprsfail);
	MACSTATUPD(txcgprssuc);
	MACSTATUPD(prs_timeout);
	MACSTATUPD(rxnack);
	MACSTATUPD(frmscons);
	MACSTATUPD(txnack);
	MACSTATUPD(txglitch_nack);
	MACSTATUPD(txburst);
	MACSTATUPD(phywatchdog);
	MACSTATUPD(pktengrxducast);
	MACSTATUPD(pktengrxdmcast);
#endif /* WLCNT */

#ifdef BCMDBG
	/* check for rx fifo 0 overflow */
	delta = (uint16)(wlc->core->macstat_snapshot->rxf0ovfl - rxf0ovfl);
	if (delta)
		WL_ERROR(("wl%d: %u rx fifo 0 overflows!\n", wlc->pub->unit, delta));

	/* check for tx fifo underflows */
	for (i = 0; i < NFIFO; i++) {
		delta = (uint16)(wlc->core->macstat_snapshot->txfunfl[i] - txfunfl[i]);
		if (delta)
			WL_ERROR(("wl%d: %u tx fifo %d underflows!\n", wlc->pub->unit, delta, i));
	}
#endif /* BCMDBG */

	/* dot11 counter update */

	WLCNTSET(wlc->pub->_cnt->txrts,
	         (wlc->pub->_cnt->rxctsucast - wlc->pub->_cnt->d11cnt_txrts_off));
	WLCNTSET(wlc->pub->_cnt->rxcrc,
	         (wlc->pub->_cnt->rxbadfcs - wlc->pub->_cnt->d11cnt_rxcrc_off));
	WLCNTSET(wlc->pub->_cnt->txnocts,
	         ((wlc->pub->_cnt->txrtsfrm - wlc->pub->_cnt->rxctsucast) -
	          wlc->pub->_cnt->d11cnt_txnocts_off));

	if (!PIO_ENAB(wlc->pub)) {
		/* merge counters from dma module */
		for (i = 0; i < NFIFO; i++) {
			if (wlc->hw->di[i]) {
				WLCNTADD(wlc->pub->_cnt->txnobuf, (wlc->hw->di[i])->txnobuf);
				WLCNTADD(wlc->pub->_cnt->rxnobuf, (wlc->hw->di[i])->rxnobuf);
				WLCNTADD(wlc->pub->_cnt->rxgiant, (wlc->hw->di[i])->rxgiants);
				dma_counterreset(wlc->hw->di[i]);
			}
		}
	}

	/*
	 * Aggregate transmit and receive errors that probably resulted
	 * in the loss of a frame are computed on the fly.
	 */
	WLCNTSET(wlc->pub->_cnt->txerror,  wlc->pub->_cnt->txnobuf + wlc->pub->_cnt->txnoassoc +
	       wlc->pub->_cnt->txuflo + wlc->pub->_cnt->txrunt + wlc->pub->_cnt->dmade +
	       wlc->pub->_cnt->dmada + wlc->pub->_cnt->dmape);
	WLCNTSET(wlc->pub->_cnt->rxerror, wlc->pub->_cnt->rxoflo + wlc->pub->_cnt->rxnobuf +
	       wlc->pub->_cnt->rxfragerr + wlc->pub->_cnt->rxrunt + wlc->pub->_cnt->rxgiant +
	       wlc->pub->_cnt->rxnoscb + wlc->pub->_cnt->rxbadsrcmac);
	for (i = 0; i < NFIFO; i++)
		WLCNTADD(wlc->pub->_cnt->rxerror, wlc->pub->_cnt->rxuflo[i]);
}

#ifdef WLCHANIM
static void
BCMATTACHFN(wlc_chanim_init)(chanim_info_t *c_info)
{
	c_info->config.crsglitch_thres = CRSGLITCH_THRESHOLD_DEFAULT;
	c_info->config.ccastats_thres = CCASTATS_THRESHOLD_DEFAULT;
	c_info->config.bgnoise_thres = BGNOISE_THRESHOLD_DEFAULT;
	c_info->config.mode = CHANIM_DETECT;
	c_info->config.sample_period = SAMPLE_PERIOD_DEFAULT;
	c_info->config.threshold_time = THRESHOLD_TIME_DEFAULT;
	c_info->config.lockout_period = LOCKOUT_PERIOD_DEFAULT;
	c_info->config.max_acs = MAX_ACS_DEFAULT;
	c_info->config.scb_max_probe = CHANIM_SCB_MAX_PROBE;
}

static wlc_chanim_stats_t *
chanim_create_stats(wlc_info_t *wlc, chanspec_t chanspec)
{

	chanspec_t ctl_chanspec;
	wlc_chanim_stats_t *new_stats = NULL;

	if (CHSPEC_IS40(chanspec))
		ctl_chanspec = wf_chspec_ctlchspec(chanspec);
	else
		ctl_chanspec = chanspec;

	new_stats = (wlc_chanim_stats_t *) MALLOC(wlc->osh, sizeof(wlc_chanim_stats_t));
	bzero((char*)new_stats, sizeof(wlc_chanim_stats_t));

	if (!new_stats) {
		WL_ERROR(("wl%d: chanim_create_stats: out of memory %d bytes\n",
			wlc->pub->unit, (uint)sizeof(wlc_chanim_stats_t)));
	}
	else {
		new_stats->chanim_stats.chanspec = ctl_chanspec;
		new_stats->next = NULL;
	}
	return new_stats;
}

static void
chanim_insert_stats(wlc_chanim_stats_t **rootp, wlc_chanim_stats_t *new)
{
	wlc_chanim_stats_t *curptr;
	wlc_chanim_stats_t *previous;

	curptr = *rootp;
	previous = NULL;

	while (curptr &&
		(curptr->chanim_stats.chanspec < new->chanim_stats.chanspec)) {
		previous = curptr;
		curptr = curptr->next;
	}
	new->next = curptr;

	if (previous == NULL)
		*rootp = new;
	else
		previous->next = new;
}

static wlc_chanim_stats_t *
chanim_chanspec_to_stats(chanim_info_t *c_info, chanspec_t chanspec)
{
	chanspec_t ctl_chanspec;
	wlc_chanim_stats_t *cur_stats = c_info->stats;

	if (CHSPEC_IS40(chanspec))
		ctl_chanspec = wf_chspec_ctlchspec(chanspec);
	else
		ctl_chanspec = chanspec;

	while (cur_stats) {
		if (cur_stats->chanim_stats.chanspec == ctl_chanspec)
			return cur_stats;
		cur_stats = cur_stats->next;
	}
	return cur_stats;
}

static wlc_chanim_stats_t *
chanim_find_stats(wlc_info_t *wlc, chanspec_t chanspec)
{
	wlc_chanim_stats_t *stats = NULL;
	chanim_info_t *c_info = wlc->chanim_info;

	if (SCAN_IN_PROGRESS(wlc->scan)) {
		/* find the stats element if it exists */
		stats = chanim_chanspec_to_stats(c_info, chanspec);

		if (!stats) {
			stats = chanim_create_stats(wlc, chanspec);
			if (stats)
				chanim_insert_stats(&c_info->stats, stats);
		}
	}
	else {
		stats = &c_info->cur_stats;
		stats->chanim_stats.chanspec = chanspec;
		stats->next = NULL;
	}

	return stats;
}

static void
wlc_chanim_meas(wlc_info_t *wlc, chanim_cnt_t *chanim_cnt)
{
	uint16 rxcrsglitch = 0;
	uint16 rxbadplcp = 0;
	uint32 ccastats_cnt[CCASTATS_MAX];
	int i, offset;

	/* Read rxcrsglitch count from shared memory */
	rxcrsglitch = wlc_bmac_read_shm(wlc->hw, M_UCODE_MACSTAT +
	  OFFSETOF(macstat_t, rxcrsglitch));
	chanim_cnt->glitch_cnt = rxcrsglitch;

	rxbadplcp = wlc_bmac_read_shm(wlc->hw, M_UCODE_MACSTAT +
	  OFFSETOF(macstat_t, rxbadplcp));
	chanim_cnt->badplcp_cnt = rxbadplcp;

	if (WLC_CCASTATS_CAP(wlc)) {
		for (i = 0; i < CCASTATS_MAX; i++) {
			uint16 low, high;
			offset = M_CCA_STATS_BLK + 4 * i;
			low = wlc_bmac_read_shm(wlc->hw, offset);
			high = wlc_bmac_read_shm(wlc->hw, offset+2);
			ccastats_cnt[i] = (high << 16) | low;
			chanim_cnt->ccastats_cnt[i] = ccastats_cnt[i];
		}
	}

	chanim_cnt->timestamp = OSL_SYSUPTIME();
}

static void
wlc_chanim_glitch_accum(chanim_info_t* c_info, chanim_cnt_t *cur_cnt, chanim_accum_t *acc)
{
	uint16 glitch_delta = 0;
	chanim_cnt_t *last_cnt;

	last_cnt = &c_info->last_cnt;

	if (last_cnt->glitch_cnt) {
		glitch_delta = cur_cnt->glitch_cnt - last_cnt->glitch_cnt;
		acc->glitch_cnt += glitch_delta;
	}
	last_cnt->glitch_cnt = cur_cnt->glitch_cnt;
}

static void
wlc_chanim_badplcp_accum(chanim_info_t* c_info, chanim_cnt_t *cur_cnt, chanim_accum_t *acc)
{
	uint16 badplcp_delta = 0;
	chanim_cnt_t *last_cnt;

	last_cnt = &c_info->last_cnt;

	if (last_cnt->badplcp_cnt) {
		badplcp_delta = cur_cnt->badplcp_cnt - last_cnt->badplcp_cnt;
		acc->badplcp_cnt += badplcp_delta;
	}
	last_cnt->badplcp_cnt = cur_cnt->badplcp_cnt;
}


static void
wlc_chanim_ccastats_accum(chanim_info_t* c_info, chanim_cnt_t *cur_cnt, chanim_accum_t *acc)
{
	int i;
	uint32 ccastats_delta = 0;
	chanim_cnt_t *last_cnt;

	last_cnt = &c_info->last_cnt;

	for (i = 0; i < CCASTATS_MAX; i++) {
		if (last_cnt->ccastats_cnt[i]) {
			ccastats_delta = cur_cnt->ccastats_cnt[i] - last_cnt->ccastats_cnt[i];
			acc->ccastats_us[i] += ccastats_delta;
		}
		last_cnt->ccastats_cnt[i] = cur_cnt->ccastats_cnt[i];
	}
}

/*
 * based on current read, accumulate the count
 * also, update the last
 */
static void
wlc_chanim_accum(wlc_info_t* wlc, chanspec_t chanspec, chanim_accum_t *acc)
{
	chanim_info_t* c_info = wlc->chanim_info;
	chanim_cnt_t cur_cnt, *last_cnt;
	uint cur_time;
	uint interval = 0;

	/* read the current measurement counters */
	wlc_chanim_meas(wlc, &cur_cnt);

	last_cnt = &c_info->last_cnt;
	cur_time = OSL_SYSUPTIME();
	if (last_cnt->timestamp)
		interval = cur_time - last_cnt->timestamp;

	/* update the accumulator with current deltas */
	wlc_chanim_glitch_accum(c_info, &cur_cnt, acc);
	wlc_chanim_badplcp_accum(c_info, &cur_cnt, acc);

	if (WLC_CCASTATS_CAP(wlc)) {
		wlc_chanim_ccastats_accum(c_info, &cur_cnt, acc);
	}
	last_cnt->timestamp = cur_time;
	acc->stats_ms += interval;
	acc->chanspec = chanspec;
}

static void
wlc_chanim_clear_acc(wlc_info_t* wlc, chanim_accum_t* acc)
{
	int i;

	if (acc) {
		acc->glitch_cnt = 0;
		acc->badplcp_cnt = 0;

		if (WLC_CCASTATS_CAP(wlc))
			for (i = 0; i < CCASTATS_MAX; i++)
				acc->ccastats_us[i] = 0;

		acc->stats_ms = 0;
	}
}

static int8
wlc_chanim_phy_noise(wlc_info_t *wlc)
{

	int32 rxiq = 0;
	int8 result = 0;
	int err = 0;

	if (!WLCISSSLPNPHY(wlc->band) && !WLCISAPHY(wlc->band) &&
		!WLCISLCNPHY(wlc->band) && SCAN_IN_PROGRESS(wlc->scan)) {

		int cnt = 10, valid_cnt = 0;
		int i;
		int sum = 0;

		rxiq = 10 << 8 | 3; /* default: samples = 1024 (2^10) and antenna = 3 */

		if ((err = wlc_iovar_setint(wlc, "phy_rxiqest", rxiq)) < 0) {
			WL_ERROR(("failed to set phy_rxiqest\n"));
		}

		for (i =  0; i < cnt; i++) {

			if ((err = wlc_iovar_getint(wlc, "phy_rxiqest", &rxiq)) < 0) {
				WL_ERROR(("failed to get phy_rxiqest\n"));
			}

			if (rxiq >> 8)
				result = (int8)MAX((rxiq >> 8) & 0xff, (rxiq & 0xff));
			else
				result = (int8)(rxiq & 0xff);

			if (result) {
				sum += result;
				valid_cnt++;
			}

		}

		if (valid_cnt)
			result = sum/valid_cnt;
	}

	if (!SCAN_IN_PROGRESS(wlc->scan))
		result = wlc_phy_noise_avg(wlc->band->pi);

	WL_CHANINT(("bgnoise: %d dBm\n", result));

	return result;
}

/*
 * convert the stats from the accumulative counters to the final stats
 * also clear the accumulative counter.
 */

static void
wlc_chanim_close(wlc_info_t* wlc, chanspec_t chanspec, chanim_accum_t* acc)
{
	int i;
	uint32 stats_cnt = 0;
	uint8 stats_frac = 0;
	wlc_chanim_stats_t *cur_stats = NULL;

	if (!(cur_stats = chanim_find_stats(wlc, chanspec))) {
		WL_ERROR(("failed to allocate chanim_stats\n"));

		return;
	}

	/* normalized to per second count */
	if (acc->stats_ms)
		stats_cnt = acc->glitch_cnt * 1000 / acc->stats_ms;

	cur_stats->chanim_stats.glitchcnt = stats_cnt;

	if (acc->stats_ms)
		stats_cnt = acc->badplcp_cnt * 1000 / acc->stats_ms;

	cur_stats->chanim_stats.badplcp = stats_cnt;

	if (WLC_CCASTATS_CAP(wlc)) {
		uint txop_us = 0;
		uint slottime = APHY_SLOT_TIME;
		uint txop = 0, txop_nom = 0;
		uint8 txop_percent = 0;

		for (i = 0; i < CCASTATS_MAX; i++) {
			/* normalize to be 0-100 */

			if (i == CCASTATS_TXOP)
				continue;

			if (acc->stats_ms)
				stats_frac = (uint8)CEIL(100 * acc->ccastats_us[i],
				  acc->stats_ms * 1000);

			if (stats_frac > 100) {
				WL_ERROR(("stats > 100: ccastats_us: %d, acc->statss_ms: %d\n",
					acc->ccastats_us[i], acc->stats_ms));
			}
			cur_stats->chanim_stats.ccastats[i] = stats_frac;
		}

		/* calc txop */
		txop_us = acc->stats_ms * 1000 -
			acc->ccastats_us[CCASTATS_INBSS] - acc->ccastats_us[CCASTATS_OBSS] -
			acc->ccastats_us[CCASTATS_NOCTG] - acc->ccastats_us[CCASTATS_DOZE] +
			acc->ccastats_us[CCASTATS_BDTXDUR];

		if (wlc->band->gmode && !wlc->shortslot)
			slottime = BPHY_SLOT_TIME;

		txop_nom = txop_us / slottime;
		txop = acc->ccastats_us[CCASTATS_TXOP] +
			(acc->ccastats_us[CCASTATS_TXDUR] -
			acc->ccastats_us[CCASTATS_BDTXDUR]) / slottime;
		if (txop_nom) {
			 txop_percent = (uint8)CEIL(100 * txop, txop_nom);
			 txop_percent = MIN(100, txop_percent);
		}
		cur_stats->chanim_stats.ccastats[CCASTATS_TXOP] = txop_percent;

	}
	cur_stats->chanim_stats.bgnoise = wlc_chanim_phy_noise(wlc);

	cur_stats->chanim_stats.timestamp = OSL_SYSUPTIME();
	wlc_chanim_clear_acc(wlc, acc);
}

#ifdef BCMDBG
static void
wlc_chanim_display(wlc_info_t *wlc, chanspec_t chanspec)
{
	chanim_info_t *c_info = wlc->chanim_info;
	wlc_chanim_stats_t *cur_stats;

	if (chanspec != wlc->home_chanspec)
		cur_stats = chanim_chanspec_to_stats(c_info, chanspec);
	else
		cur_stats = &c_info->cur_stats;

	if (!cur_stats)
		return;

	WL_CHANINT(("**intf: %d glitch cnt: %d badplcp: %d noise: %d chanspec: 0x%x \n",
		chanim_mark(c_info).state, cur_stats->chanim_stats.glitchcnt,
		cur_stats->chanim_stats.badplcp, cur_stats->chanim_stats.bgnoise, chanspec));

		if (WLC_CCASTATS_CAP(wlc)) {
			WL_CHANINT(("***cca stats: txdur: %d, inbss: %d, obss: %d,"
			  "nocat: %d, nopkt: %d, doze: %d\n",
			  cur_stats->chanim_stats.ccastats[CCASTATS_TXDUR],
			  cur_stats->chanim_stats.ccastats[CCASTATS_INBSS],
			  cur_stats->chanim_stats.ccastats[CCASTATS_OBSS],
			  cur_stats->chanim_stats.ccastats[CCASTATS_NOCTG],
			  cur_stats->chanim_stats.ccastats[CCASTATS_NOPKT],
			  cur_stats->chanim_stats.ccastats[CCASTATS_DOZE]));
		}

}
#endif /* BCMDBG */

/*
 * the main function for chanim information update
 * it could occur 1) on watchdog 2) on channel switch
 * based on the flag.
 */
static void
wlc_chanim_update(wlc_info_t *wlc, chanspec_t chanspec, uint32 flags)
{
	chanim_info_t* c_info = wlc->chanim_info;
	chanim_accum_t* home_acc = &c_info->accum_cnt[CHANIM_HOME_CHAN];

	if (!WLC_CHANIM_ENAB(wlc))
		return;

	/* on watchdog trigger */
	if (flags & CHANIM_WD) {

		if (!WLC_CHANIM_MODE_DETECT(c_info) || SCAN_IN_PROGRESS(wlc->scan))
			return;

		/* need to initialize if chanspec is not set yet */
		if (home_acc->chanspec == 0)
			home_acc->chanspec = wlc->chanspec;

		if (wlc->chanspec == home_acc->chanspec)
			wlc_chanim_accum(wlc, chanspec, home_acc);

		if (!(wlc->pub->now % chanim_config(c_info).sample_period)) {
			wlc_chanim_close(wlc, home_acc->chanspec, home_acc);

#ifdef BCMDBG
			wlc_chanim_display(wlc, home_acc->chanspec);
#endif
		}
	}

	/* on channel switch */
	if (flags & CHANIM_CHANSPEC) {
		if (home_acc->chanspec == 0)
			home_acc->chanspec = chanspec;

		if (chanspec == home_acc->chanspec) {
			wlc_chanim_accum(wlc, chanspec, home_acc);
			wlc_chanim_close(wlc, home_acc->chanspec, home_acc);

			if (wlc->home_chanspec != home_acc->chanspec)
				home_acc->chanspec = wlc->home_chanspec;
		} else {
			chanim_accum_t *off_chan_acc = &c_info->accum_cnt[CHANIM_OFF_CHAN];

			wlc_chanim_accum(wlc, chanspec, off_chan_acc);
			wlc_chanim_close(wlc, chanspec, off_chan_acc);
		}
#ifdef BCMDBG
		wlc_chanim_display(wlc, chanspec);
#endif
	}
}

static void
wlc_chanim_acc_reset(wlc_info_t *wlc)
{
	chanim_info_t* c_info = wlc->chanim_info;
	chanim_accum_t* home_acc = &c_info->accum_cnt[CHANIM_HOME_CHAN];

	wlc_chanim_clear_acc(wlc, home_acc);
	bzero((char*)&c_info->last_cnt, sizeof(chanim_cnt_t));
	home_acc->chanspec = 0;
}

static bool
wlc_chanim_interfered_glitch(wlc_chanim_stats_t *stats, uint32 thres)
{
	bool interfered = FALSE;

	interfered = stats->chanim_stats.glitchcnt > thres;
	return interfered;
}

static bool
wlc_chanim_interfered_cca(wlc_chanim_stats_t *stats, uint32 thres)
{
	bool interfered = FALSE;
	uint8 stats_sum;

	stats_sum = stats->chanim_stats.ccastats[CCASTATS_NOPKT];
	interfered = stats_sum > (uint8)thres;

	return interfered;
}

static bool
wlc_chanim_interfered_noise(wlc_chanim_stats_t *stats, int8 thres)
{
	bool interfered = FALSE;
	int8 bgnoise;

	bgnoise = stats->chanim_stats.bgnoise;
	interfered = bgnoise > (uint8)thres;

	return interfered;
}

bool
wlc_chanim_interfered(wlc_info_t *wlc, chanspec_t chanspec)
{
	bool interfered = FALSE;
	wlc_chanim_stats_t *cur_stats;
	chanim_info_t *c_info = wlc->chanim_info;

	if (chanspec != wlc->home_chanspec)
		cur_stats = chanim_chanspec_to_stats(wlc->chanim_info, chanspec);
	else
		cur_stats = &c_info->cur_stats;

	if (!cur_stats)  {
		WL_INFORM(("%s: no stats allocated for chanspec 0x%x\n",
			__FUNCTION__, chanspec));
		return interfered;
	}

	if (wlc_chanim_interfered_glitch(cur_stats, chanim_config(c_info).crsglitch_thres) ||
		wlc_chanim_interfered_cca(cur_stats, chanim_config(c_info).ccastats_thres) ||
		wlc_chanim_interfered_noise(cur_stats, chanim_config(c_info).bgnoise_thres))
		interfered = TRUE;

	if (chanspec == wlc->home_chanspec)
		chanim_mark(c_info).state = interfered;

	return interfered;
}

#ifdef AP
static void
wlc_chanim_scb_probe(wlc_info_t *wlc, bool activate)
{
	chanim_info_t * c_info = wlc->chanim_info;

	if (activate) {
		/* store the original values, and replace with the chanim values */
		chanim_mark(c_info).scb_timeout = wlc->scb_timeout;
		chanim_mark(c_info).scb_max_probe = wlc->scb_max_probe;
		wlc->scb_timeout = chanim_config(c_info).sample_period;
		wlc->scb_max_probe = chanim_config(c_info).scb_max_probe;
	}
	else {
		/* swap back on exit */
		wlc->scb_timeout = chanim_mark(c_info).scb_timeout;
		wlc->scb_max_probe = chanim_mark(c_info).scb_max_probe;
	}
}
#endif /* AP */

void
wlc_chanim_upd_act(wlc_info_t *wlc)
{
	chanim_info_t * c_info = wlc->chanim_info;

	if (wlc_chanim_interfered(wlc, wlc->home_chanspec) &&
		(wlc->chanspec == wlc->home_chanspec)) {
		if (chanim_mark(c_info).detecttime && !WLC_CHANIM_ACT(c_info)) {
			if ((wlc->pub->now - chanim_mark(c_info).detecttime) >
				(uint)chanim_act_delay(c_info)) {
			    chanim_mark(c_info).flags |= CHANIM_ACTON;
				WL_CHANINT(("***chanim action set\n"));
			}
		}
		else if (!WLC_CHANIM_ACT(c_info)) {
			chanim_mark(c_info).detecttime = wlc->pub->now;

#ifdef AP
			/* start to probe */
			wlc_chanim_scb_probe(wlc, TRUE);
#endif /* AP */
		}
	}
	else {
#ifdef AP
		if (chanim_mark(c_info).detecttime)
			wlc_chanim_scb_probe(wlc, FALSE);
#endif /* AP */
		chanim_mark(c_info).detecttime = 0;
		chanim_mark(c_info).flags &= ~CHANIM_ACTON;
	}
}

static int
chanim_get_acs_record(chanim_info_t *c_info, int buf_len, void *output)
{
	wl_acs_record_t *record = (wl_acs_record_t *)output;
	uint8 idx = chanim_mark(c_info).record_idx;
	int i, count = 0;

	for (i = 0; i < CHANIM_ACS_RECORD; i++) {
		if (c_info->record[idx].valid) {
			bcopy(&c_info->record[idx], &record->acs_record[i],
				sizeof(chanim_acs_record_t));
			count++;
		}
		idx = (idx + 1) % CHANIM_ACS_RECORD;
	}

	record->count = (uint8)count;
	record->timestamp = OSL_SYSUPTIME();
	return BCME_OK;
}

void
wlc_chanim_upd_acs_record(chanim_info_t *c_info, chanspec_t home_chspc,
	chanspec_t selected, uint8 trigger)
{
	chanim_acs_record_t* cur_record = &c_info->record[chanim_mark(c_info).record_idx];
	wlc_chanim_stats_t *cur_stats;
	cur_stats = chanim_chanspec_to_stats(c_info, home_chspc);

	bzero(cur_record, sizeof(chanim_acs_record_t));

	cur_record->trigger = trigger;
	cur_record->timestamp = OSL_SYSUPTIME();
	cur_record->selected_chspc = selected;
	cur_record->valid = TRUE;

	if (cur_stats) {
		cur_record->glitch_cnt = cur_stats->chanim_stats.glitchcnt;
		cur_record->ccastats = cur_stats->chanim_stats.ccastats[CCASTATS_NOPKT];
	}

	chanim_mark(c_info).record_idx ++;
	if (chanim_mark(c_info).record_idx == CHANIM_ACS_RECORD)
		chanim_mark(c_info).record_idx = 0;
}

#ifdef AP
static bool
chanim_chk_lockout(chanim_info_t *c_info)
{
	uint8 cur_idx = chanim_mark(c_info).record_idx;
	uint8 start_idx;
	chanim_acs_record_t *start_record;
	uint32 cur_time;

	if (!chanim_config(c_info).max_acs)
		return TRUE;

	start_idx = MODSUB(cur_idx, chanim_config(c_info).max_acs, CHANIM_ACS_RECORD);
	start_record = &c_info->record[start_idx];
	cur_time = OSL_SYSUPTIME();

	if (start_record->valid && ((cur_time - start_record->timestamp) <
			chanim_config(c_info).lockout_period * 1000)) {
		WL_CHANINT(("***chanim lockout true\n"));
		return TRUE;
	}

	return FALSE;
}

static int
chanim_get_stats(chanim_info_t *c_info, wl_chanim_stats_t* iob, int *len, int cnt)
{
	uint32 count = 0;
	uint32 datalen;
	wlc_chanim_stats_t* stats = c_info->stats;
	int bcmerror = BCME_OK;
	int buflen = *len;

	iob->version = WL_CHANIM_STATS_VERSION;
	datalen = WL_CHANIM_STATS_FIXED_LEN;

	if (cnt == WL_CHANIM_COUNT_ALL)
		stats = c_info->stats;
	else
		stats = &c_info->cur_stats;

	while (stats) {
		if (buflen < (int)sizeof(chanim_stats_t)) {
			bcmerror = BCME_BUFTOOSHORT;
			break;
		}
		bcopy(&stats->chanim_stats, &iob->stats[count],
			sizeof(chanim_stats_t));

		count++;
		stats = stats->next;
		datalen += sizeof(chanim_stats_t);
		buflen -= sizeof(chanim_stats_t);
	}

	iob->count = count;
	iob->buflen = datalen;

	return bcmerror;
}

/* function for chanim mitigation (action) */
void
wlc_chanim_action(wlc_info_t *wlc)
{
	chanim_info_t *c_info = wlc->chanim_info;
	struct scb *scb;
	struct scb_iter scbiter;
	/* clear the action flag and reset detecttime */
	chanim_mark(c_info).flags &= ~CHANIM_ACTON;
	chanim_mark(c_info).detecttime = 0;
#ifdef AP
	wlc_chanim_scb_probe(wlc, FALSE);
#endif /* AP */

	FOREACHSCB(wlc->scbstate, &scbiter, scb) {
		if (SCB_ASSOCIATED(scb) &&
		    (wlc->pub->now - scb->used < (uint)chanim_act_delay(c_info)))
			break;
	}

	if (!scb) {
		wl_uint32_list_t request;

		if (chanim_chk_lockout(c_info)) {
			WL_CHANINT(("***chanim scan is not allowed due to lockout\n"));
			return;
		}

		request.count = 0;
#ifdef APCS
		if (!wlc_cs_scan_start(wlc, &request, TRUE, FALSE,
			wlc->band->bandtype, APCS_CHANIM, NULL, NULL)) {
			wlc->cs_scan_ini = TRUE;
		}
#endif /* APCS */
	}
	return;
}
#endif /* AP */
#endif /* WLCHANIM */

#if defined(DELTASTATS)
static void
wlc_delta_stats_update(wlc_info_t *wlc)
{
	wl_delta_stats_t *stats;
	wl_cnt_t *cnt = wlc->pub->_cnt;

	/* current stats becomes previous stats */
	wlc->delta_stats->current_index =
		(wlc->delta_stats->current_index + 1) % DELTA_STATS_NUM_INTERVAL;

	/* update current stats */
	stats = &wlc->delta_stats->stats[wlc->delta_stats->current_index];

	/* NOTE: wlc_statsupd() must be invoked to update the stats if there are
	 * any stats which depend on macstat_t
	 */

	/* stats not dependent on macstat_t */
	WLCNTSET(stats->txframe,   WLCNTVAL(cnt->txframe));
	WLCNTSET(stats->txbyte,    WLCNTVAL(cnt->txbyte));
	WLCNTSET(stats->txretrans, WLCNTVAL(cnt->txretrans));
	WLCNTSET(stats->txfail,    WLCNTVAL(cnt->txfail));
	WLCNTSET(stats->rxframe,   WLCNTVAL(cnt->rxframe));
	WLCNTSET(stats->rxbyte,    WLCNTVAL(cnt->rxbyte));
	WLCNTSET(stats->rx1mbps,   WLCNTVAL(cnt->rx1mbps));
	WLCNTSET(stats->rx2mbps,   WLCNTVAL(cnt->rx2mbps));
	WLCNTSET(stats->rx5mbps5,  WLCNTVAL(cnt->rx5mbps5));
	WLCNTSET(stats->rx6mbps,   WLCNTVAL(cnt->rx6mbps));
	WLCNTSET(stats->rx9mbps,   WLCNTVAL(cnt->rx9mbps));
	WLCNTSET(stats->rx11mbps,  WLCNTVAL(cnt->rx11mbps));
	WLCNTSET(stats->rx12mbps,  WLCNTVAL(cnt->rx12mbps));
	WLCNTSET(stats->rx18mbps,  WLCNTVAL(cnt->rx18mbps));
	WLCNTSET(stats->rx24mbps,  WLCNTVAL(cnt->rx24mbps));
	WLCNTSET(stats->rx36mbps,  WLCNTVAL(cnt->rx36mbps));
	WLCNTSET(stats->rx48mbps,  WLCNTVAL(cnt->rx48mbps));
	WLCNTSET(stats->rx54mbps,  WLCNTVAL(cnt->rx54mbps));
}

static int
wlc_get_delta_stats(wlc_info_t *wlc, wl_delta_stats_t *stats)
{
	int err = BCME_OK;

	/* return zeros if disabled or interval has not yet elapsed */
	if (wlc->delta_stats->interval == 0 ||
		wlc->delta_stats->seconds <= wlc->delta_stats->interval) {
		/* zero the entire structure */
		bzero(stats, sizeof(wl_delta_stats_t));
		err = BCME_ERROR;
	} else {
		/* indexes to current and previous stats */
		uint32 curr_index = wlc->delta_stats->current_index;
		uint32 prev_index = (curr_index - 1) % DELTA_STATS_NUM_INTERVAL;

		/* pointers to current and previous stats */
		wl_delta_stats_t *curr = &wlc->delta_stats->stats[curr_index];
		wl_delta_stats_t *prev = &wlc->delta_stats->stats[prev_index];

		/* calculate delta statistics */
		WLCNTSET(stats->txframe,   curr->txframe   - prev->txframe);
		WLCNTSET(stats->txbyte,    curr->txbyte    - prev->txbyte);
		WLCNTSET(stats->txretrans, curr->txretrans - prev->txretrans);
		WLCNTSET(stats->txfail,    curr->txfail    - prev->txfail);
		WLCNTSET(stats->rxframe,   curr->rxframe   - prev->rxframe);
		WLCNTSET(stats->rxbyte,    curr->rxbyte    - prev->rxbyte);
		WLCNTSET(stats->rx1mbps,   curr->rx1mbps   - prev->rx1mbps);
		WLCNTSET(stats->rx2mbps,   curr->rx2mbps   - prev->rx2mbps);
		WLCNTSET(stats->rx5mbps5,  curr->rx5mbps5  - prev->rx5mbps5);
		WLCNTSET(stats->rx6mbps,   curr->rx6mbps   - prev->rx6mbps);
		WLCNTSET(stats->rx9mbps,   curr->rx9mbps   - prev->rx9mbps);
		WLCNTSET(stats->rx11mbps,  curr->rx11mbps  - prev->rx11mbps);
		WLCNTSET(stats->rx12mbps,  curr->rx12mbps  - prev->rx12mbps);
		WLCNTSET(stats->rx18mbps,  curr->rx18mbps  - prev->rx18mbps);
		WLCNTSET(stats->rx24mbps,  curr->rx24mbps  - prev->rx24mbps);
		WLCNTSET(stats->rx36mbps,  curr->rx36mbps  - prev->rx36mbps);
		WLCNTSET(stats->rx48mbps,  curr->rx48mbps  - prev->rx48mbps);
		WLCNTSET(stats->rx54mbps,  curr->rx54mbps  - prev->rx54mbps);
	}

	/* set version and length of structure */
	WLCNTSET(stats->version, WL_DELTA_STATS_T_VERSION);
	WLCNTSET(stats->length, sizeof(wl_delta_stats_t));

	return err;
}
#endif /* DELTASTATS */

static void
wlc_rssi_event_timeout(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t*)arg;
	cfg->link->is_rssi_event_timer_active = FALSE;
}

void
wlc_lq_rssi_event_update(wlc_bsscfg_t *cfg)
{
	int level;
	wlc_info_t *wlc = cfg->wlc;
	wlc_link_qual_t *link = cfg->link;

	/* no update if timer active */
	if (link->is_rssi_event_timer_active)
		return;

	/* find rssi level */
	for (level = 0; level < link->rssi_event->num_rssi_levels; level++) {
		if (link->rssi <= link->rssi_event->rssi_levels[level])
			break;
	}

	if (level != link->rssi_level) {
		/* rssi level changed - post rssi event */
		int value = hton32(link->rssi);
		link->rssi_level = (uint8)level;
		wlc_bss_mac_event(wlc, cfg, WLC_E_RSSI, NULL, 0, 0, 0, &value, sizeof(value));
		if (link->rssi_event->rate_limit_msec) {
			/* rate limit rssi events */
			link->is_rssi_event_timer_active = TRUE;
			wl_add_timer(wlc->wl, link->rssi_event_timer,
				link->rssi_event->rate_limit_msec, FALSE);
		}
	}
}

uint
wlc_ctrupd(wlc_info_t *wlc, uint ucode_offset, uint offset)
{
#ifdef WLCNT
	uint16 v, delta;
	uint32 *total;
	uint16 *per_core;

	total = (uint32*)((char*)(&wlc->pub->_cnt->txallfrm) + offset);
	per_core = (uint16*)((char*)wlc->core->macstat_snapshot + ucode_offset);

	v = wlc_bmac_read_shm(wlc->hw, M_UCODE_MACSTAT + ucode_offset);
	delta = (uint16)(v - *per_core);

	if (delta != 0) {
		*total += delta;
		*per_core = v;
	}
	return (delta);
#else
	return (0);
#endif /* WLCNT */
}

bool
wlc_chipmatch(uint16 vendor, uint16 device)
{
	if (vendor != VENDOR_BROADCOM) {
		WL_ERROR(("wlc_chipmatch: unknown vendor id %04x\n", vendor));
		return (FALSE);
	}

	if (device == BCM4306_D11G_ID)
		return (TRUE);
	if (device == BCM4306_D11G_ID2)
		return (TRUE);
	if (device == BCM4303_D11B_ID)
		return (TRUE);
	if (device == BCM4306_D11A_ID)
		return (TRUE);
	if (device == BCM4306_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4318_D11G_ID)
		return (TRUE);
	if (device == BCM4318_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4318_D11A_ID)
		return (TRUE);
	if (device == BCM4311_D11G_ID)
		return (TRUE);
	if (device == BCM4311_D11A_ID)
		return (TRUE);
	if (device == BCM4311_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4328_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4328_D11G_ID)
		return (TRUE);
	if (device == BCM4328_D11A_ID)
		return (TRUE);
	if (device == BCM4325_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4325_D11G_ID)
		return (TRUE);
	if (device == BCM4325_D11A_ID)
		return (TRUE);
	if ((device == BCM4321_D11N_ID) || (device == BCM4321_D11N2G_ID) ||
		(device == BCM4321_D11N5G_ID))
		return (TRUE);
	if ((device == BCM4322_D11N_ID) || (device == BCM4322_D11N2G_ID) ||
		(device == BCM4322_D11N5G_ID))
		return (TRUE);
	if (device == BCM43221_D11N2G_ID)
		return (TRUE);
	if (device == BCM43231_D11N2G_ID)
		return (TRUE);
	if ((device == BCM43222_D11N_ID) || (device == BCM43222_D11N2G_ID) ||
		(device == BCM43222_D11N5G_ID))
		return (TRUE);
	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID) ||
		(device == BCM43421_D11N_ID) || (device == BCM43224_D11N_ID_VEN1))
		return (TRUE);
	if ((device == BCM43226_D11N_ID))
		return (TRUE);
	if ((device == BCM6362_D11N_ID))
		return (TRUE);

	/* Chips with blank-OTP */
	/* BCMHOSTVARS is enabled only if WLTEST is enabled or BCMEXTNVM is enabled */
#if defined(BCMHOSTVARS)
	if (device == BCM4322_CHIP_ID)
		return (TRUE);
	if ((device == BCM43222_CHIP_ID) || (device == BCM43111_CHIP_ID) ||
	    (device == BCM43112_CHIP_ID) || (device == BCM43420_CHIP_ID))
		return (TRUE);
	if ((device == BCM43224_CHIP_ID) || (device == BCM43421_CHIP_ID))
		return (TRUE);
	if (device == BCM4313_CHIP_ID)
		return (TRUE);
	if ((device == BCM4331_CHIP_ID) || (device == BCM43431_CHIP_ID))
		return (TRUE);
	if (device == BCM43227_CHIP_ID)
		return (TRUE);
	if ((device == BCM43228_CHIP_ID) || (device == BCM43428_CHIP_ID))
		return (TRUE);
#endif 

	if (device == BCM4329_D11N2G_ID)
		return (TRUE);
	if (device == BCM4315_D11DUAL_ID)
		return (TRUE);
	if (device == BCM4315_D11G_ID)
		return (TRUE);
	if (device == BCM4315_D11A_ID)
		return (TRUE);
	if ((device == BCM4319_D11N_ID) || (device == BCM4319_D11N2G_ID) ||
		(device == BCM4319_D11N5G_ID))
		return (TRUE);
	if (device == BCM4716_CHIP_ID)
		return (TRUE);
	if (device == BCM4313_D11N2G_ID)
		return (TRUE);
	if (device == BCM4336_D11N_ID)
		return (TRUE);
	if (device == BCM4330_D11N_ID)
		return (TRUE);
	if ((device == BCM43236_D11N_ID) || (device == BCM43236_D11N2G_ID) ||
		(device == BCM43236_D11N5G_ID))
		return (TRUE);
	if ((device == BCM4331_D11N_ID) || (device == BCM4331_D11N2G_ID) ||
		(device == BCM4331_D11N5G_ID))
		return (TRUE);
	if (device == BCM43131_D11N2G_ID)
		return (TRUE);
	if ((device == BCM43227_D11N2G_ID) || (device == BCM43228_D11N_ID) ||
		(device == BCM43228_D11N5G_ID) || (device == BCM43217_D11N2G_ID))
		return (TRUE);
	if ((device == BCM43237_D11N_ID) || (device == BCM43237_D11N5G_ID))
		return (TRUE);

	WL_ERROR(("wlc_chipmatch: unknown device id %04x\n", device));
	return (FALSE);
}

#if defined(BCMDBG) || defined(WLMSG_PRHDRS) || defined(WLMSG_PRPKT) || \
	defined(WLMSG_ASSOC)
static const char* errstr = "802.11 Header INCOMPLETE\n";
static const char* fillstr = "------------";
static void
wlc_print_dot11hdr(uint8* buf, int len)
{
	char hexbuf[(2*D11B_PHY_HDR_LEN)+1];

	if (len == 0) {
		printf("802.11 Header MISSING\n");
		return;
	}

	if (len < D11B_PHY_HDR_LEN) {
		bcm_format_hex(hexbuf, buf, len);
		strncpy(hexbuf + (2 * len), fillstr, 2 * (D11B_PHY_HDR_LEN - len));
		hexbuf[sizeof(hexbuf) - 1] = '\0';
	} else {
		bcm_format_hex(hexbuf, buf, D11B_PHY_HDR_LEN);
	}

	printf("PLCPHdr: %s ", hexbuf);
	if (len < D11B_PHY_HDR_LEN) {
		printf("%s\n", errstr);
		return;
	}

	len -= D11B_PHY_HDR_LEN;
	buf += D11B_PHY_HDR_LEN;

	wlc_print_dot11_mac_hdr(buf, len);
}

void
wlc_print_dot11_mac_hdr(uint8* buf, int len)
{
	char hexbuf[(2*D11B_PHY_HDR_LEN)+1];
	char a1[(2*ETHER_ADDR_LEN)+1], a2[(2*ETHER_ADDR_LEN)+1];
	char a3[(2*ETHER_ADDR_LEN)+1];
	char flagstr[64];
	uint16 fc, kind, toDS, fromDS;
	uint16 v;
	int fill_len = 0;
	static const bcm_bit_desc_t fc_flags[] = {
		{FC_TODS, "ToDS"},
		{FC_FROMDS, "FromDS"},
		{FC_MOREFRAG, "MoreFrag"},
		{FC_RETRY, "Retry"},
		{FC_PM, "PM"},
		{FC_MOREDATA, "MoreData"},
		{FC_WEP, "WEP"},
		{FC_ORDER, "Order"},
		{0, NULL}
	};

	if (len < 2) {
		printf("FC: ------ ");
		printf("%s\n", errstr);
		return;
	}

	fc = buf[0] | (buf[1] << 8);
	kind = fc & FC_KIND_MASK;
	toDS = (fc & FC_TODS) != 0;
	fromDS = (fc & FC_FROMDS) != 0;

	bcm_format_flags(fc_flags, fc, flagstr, 64);

	printf("FC: 0x%04x ", fc);
	if (flagstr[0] != '\0')
		printf("(%s) ", flagstr);

	len -= 2;
	buf += 2;

	if (len < 2) {
		printf("Dur/AID: ----- ");
		printf("%s\n", errstr);
		return;
	}

	v = buf[0] | (buf[1] << 8);
	if (kind == FC_PS_POLL) {
		printf("AID: 0x%04x", v);
	} else {
		printf("Dur: 0x%04x", v);
	}
	printf("\n");
	len -= 2;
	buf += 2;

	strncpy(a1, fillstr, sizeof(a1));
	strncpy(a2, fillstr, sizeof(a2));
	strncpy(a3, fillstr, sizeof(a3));

	if (len < ETHER_ADDR_LEN) {
		bcm_format_hex(a1, buf, len);
		strncpy(a1+(2*len), fillstr, 2*(ETHER_ADDR_LEN-len));
	} else if (len < 2*ETHER_ADDR_LEN) {
		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
		bcm_format_hex(a2, buf+ETHER_ADDR_LEN, len-ETHER_ADDR_LEN);
		fill_len = len - ETHER_ADDR_LEN;
		strncpy(a2+(2*fill_len), fillstr, 2*(ETHER_ADDR_LEN-fill_len));
	} else if (len < 3*ETHER_ADDR_LEN) {
		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
		bcm_format_hex(a2, buf+ETHER_ADDR_LEN, ETHER_ADDR_LEN);
		bcm_format_hex(a3, buf+(2*ETHER_ADDR_LEN), len-(2*ETHER_ADDR_LEN));
		fill_len = len - (2*ETHER_ADDR_LEN);
		strncpy(a3+(2*fill_len), fillstr, 2*(ETHER_ADDR_LEN-fill_len));
	} else {
		bcm_format_hex(a1, buf, ETHER_ADDR_LEN);
		bcm_format_hex(a2, buf+ETHER_ADDR_LEN, ETHER_ADDR_LEN);
		bcm_format_hex(a3, buf+(2*ETHER_ADDR_LEN), ETHER_ADDR_LEN);
	}

	if (kind == FC_RTS) {
		printf("RA: %s ", a1);
		printf("TA: %s ", a2);
		if (len < 2*ETHER_ADDR_LEN)
			printf("%s ", errstr);
	} else if (kind == FC_CTS || kind == FC_ACK) {
		printf("RA: %s ", a1);
		if (len < ETHER_ADDR_LEN)
			printf("%s ", errstr);
	} else if (kind == FC_PS_POLL) {
		printf("BSSID: %s", a1);
		printf("TA: %s ", a2);
		if (len < 2*ETHER_ADDR_LEN)
			printf("%s ", errstr);
	} else if (kind == FC_CF_END || kind == FC_CF_END_ACK) {
		printf("RA: %s ", a1);
		printf("BSSID: %s ", a2);
		if (len < 2*ETHER_ADDR_LEN)
			printf("%s ", errstr);
	} else if (FC_TYPE(fc) == FC_TYPE_DATA) {
		if (!toDS) {
			printf("DA: %s ", a1);
			if (!fromDS) {
				printf("SA: %s ", a2);
				printf("BSSID: %s ", a3);
			} else {
				printf("BSSID: %s ", a2);
				printf("SA: %s ", a3);
			}
		} else if (!fromDS) {
			printf("BSSID: %s ", a1);
			printf("SA: %s ", a2);
			printf("DA: %s ", a3);
		} else {
			printf("RA: %s ", a1);
			printf("TA: %s ", a2);
			printf("DA: %s ", a3);
		}
		if (len < 3*ETHER_ADDR_LEN) {
			printf("%s ", errstr);
		} else if (len < 20) {
			printf("SeqCtl: ------ ");
			printf("%s ", errstr);
		} else {
			len -= 3*ETHER_ADDR_LEN;
			buf += 3*ETHER_ADDR_LEN;
			v = buf[0] | (buf[1] << 8);
			printf("SeqCtl: 0x%04x ", v);
			len -= 2;
			buf += 2;
		}
	} else if (FC_TYPE(fc) == FC_TYPE_MNG) {
		printf("DA: %s ", a1);
		printf("SA: %s ", a2);
		printf("BSSID: %s ", a3);
		if (len < 3*ETHER_ADDR_LEN) {
			printf("%s ", errstr);
		} else if (len < 20) {
			printf("SeqCtl: ------ ");
			printf("%s ", errstr);
		} else {
			len -= 3*ETHER_ADDR_LEN;
			buf += 3*ETHER_ADDR_LEN;
			v = buf[0] | (buf[1] << 8);
			printf("SeqCtl: 0x%04x ", v);
			len -= 2;
			buf += 2;
		}
	}

	if ((FC_TYPE(fc) == FC_TYPE_DATA) && toDS && fromDS) {

		if (len < ETHER_ADDR_LEN) {
			bcm_format_hex(hexbuf, buf, len);
			strncpy(hexbuf+(2*len), fillstr, 2*(ETHER_ADDR_LEN-len));
		} else {
			bcm_format_hex(hexbuf, buf, ETHER_ADDR_LEN);
		}

		printf("SA: %s ", hexbuf);

		if (len < ETHER_ADDR_LEN) {
			printf("%s ", errstr);
		} else {
			len -= ETHER_ADDR_LEN;
			buf += ETHER_ADDR_LEN;
		}
	}

	if ((FC_TYPE(fc) == FC_TYPE_DATA) && (kind == FC_QOS_DATA)) {
		if (len < 2) {
			printf("QoS: ------");
			printf("%s ", errstr);
		} else {
			v = buf[0] | (buf[1] << 8);
			printf("QoS: 0x%04x ", v);
			len -= 2;
			buf += 2;
		}
	}

	printf("\n");
	return;
}
#endif /* BCMDBG || WLMSG_PRHDRS || WLMSG_PRPKT || WLMSG_ASSOC */

#if defined(BCMDBG) || defined(WLMSG_PRHDRS)
void
wlc_print_txdesc(d11txh_t* txh)
{
	uint16 mtcl = ltoh16(txh->MacTxControlLow);
	uint16 mtch = ltoh16(txh->MacTxControlHigh);
	uint16 mfc = ltoh16(txh->MacFrameControl);
	uint16 tfest = ltoh16(txh->TxFesTimeNormal);
	uint16 ptcw = ltoh16(txh->PhyTxControlWord);
	uint16 ptcw_1 = ltoh16(txh->PhyTxControlWord_1);
	uint16 ptcw_1_Fbr = ltoh16(txh->PhyTxControlWord_1_Fbr);
	uint16 ptcw_1_Rts = ltoh16(txh->PhyTxControlWord_1_Rts);
	uint16 ptcw_1_FbrRts = ltoh16(txh->PhyTxControlWord_1_FbrRts);
	uint16 mainrates = ltoh16(txh->MainRates);
	uint16 xtraft = ltoh16(txh->XtraFrameTypes);
	uint8 *iv = txh->IV;
	uint8 *ra = txh->TxFrameRA;
	uint16 tfestfb = ltoh16(txh->TxFesTimeFallback);
	uint8 *rtspfb = txh->RTSPLCPFallback;
	uint16 rtsdfb = ltoh16(txh->RTSDurFallback);
	uint8 *fragpfb = txh->FragPLCPFallback;
	uint16 fragdfb = ltoh16(txh->FragDurFallback);
	uint16 mmodelen = ltoh16(txh->MModeLen);
	uint16 mmodefbrlen = ltoh16(txh->MModeFbrLen);
	uint16 tfid = ltoh16(txh->TxFrameID);
	uint16 txs = ltoh16(txh->TxStatus);
	uint16 mnmpdu = ltoh16(txh->MaxNMpdus);
	uint16 maxdur = ltoh16(txh->u1.MaxAggDur);
	uint16 maxrnum = ltoh16(txh->u2.MaxRNum);
	uint16 mmbyte = ltoh16(txh->MinMBytes);

	uint8 *rtsph = txh->RTSPhyHeader;
	struct dot11_rts_frame rts = txh->rts_frame;
	char hexbuf[256];

	prhex("Raw TxDesc", (uchar *) txh, sizeof(d11txh_t));

	printf("TxCtlLow: %04x ", mtcl);
	printf("TxCtlHigh: %04x ", mtch);
	printf("FC: %04x ", mfc);
	printf("FES Time: %04x\n", tfest);
	printf("PhyCtl: %04x%s ", ptcw, (ptcw & PHY_TXC_SHORT_HDR) ? " short" : "");
	printf("PhyCtl_1: %04x ", ptcw_1);
	printf("PhyCtl_1_Fbr: %04x\n", ptcw_1_Fbr);
	printf("PhyCtl_1_Rts: %04x ", ptcw_1_Rts);
	printf("PhyCtl_1_Fbr_Rts: %04x\n", ptcw_1_FbrRts);
	printf("MainRates: %04x ", mainrates);
	printf("XtraFrameTypes: %04x ", xtraft);
	printf("\n");

	bcm_format_hex(hexbuf, iv, sizeof(txh->IV));
	printf("SecIV:       %s\n", hexbuf);
	bcm_format_hex(hexbuf, ra, sizeof(txh->TxFrameRA));
	printf("RA:          %s\n", hexbuf);

	printf("Fb FES Time: %04x ", tfestfb);
	bcm_format_hex(hexbuf, rtspfb, sizeof(txh->RTSPLCPFallback));
	printf("RTS PLCP: %s ", hexbuf);
	printf("RTS DUR: %04x ", rtsdfb);
	bcm_format_hex(hexbuf, fragpfb, sizeof(txh->FragPLCPFallback));
	printf("PLCP: %s ", hexbuf);
	printf("DUR: %04x", fragdfb);
	printf("\n");

	printf("MModeLen: %04x ", mmodelen);
	printf("MModeFbrLen: %04x\n", mmodefbrlen);

	printf("FrameID:     %04x\n", tfid);
	printf("TxStatus:    %04x\n", txs);

	printf("MaxNumMpdu:  %04x\n", mnmpdu);
	printf("MaxAggDur:   %04x\n", maxdur);
	printf("MaxRNum:     %04x\n", maxrnum);
	printf("MinByte:     %04x\n", mmbyte);

	bcm_format_hex(hexbuf, rtsph, sizeof(txh->RTSPhyHeader));
	printf("RTS PLCP: %s ", hexbuf);
	bcm_format_hex(hexbuf, (uint8 *) &rts, sizeof(txh->rts_frame));
	printf("RTS Frame: %s", hexbuf);
	printf("\n");

	if (mtcl & TXC_SENDRTS) {
		wlc_print_dot11hdr((uint8 *) &rts, sizeof(txh->rts_frame));
	}
}
#endif /* BCMDBG || WLMSG_PRHDRS */

#if defined(BCMDBG) || defined(WLMSG_PRHDRS)
void
wlc_recv_print_rxh(wlc_d11rxhdr_t *wrxh)
{
	d11rxhdr_t * rxh = &wrxh->rxhdr;
	uint16 len = rxh->RxFrameSize;
	uint16 phystatus_0 = rxh->PhyRxStatus_0;
	uint16 phystatus_1 = rxh->PhyRxStatus_1;
	uint16 phystatus_2 = rxh->PhyRxStatus_2;
	uint16 phystatus_3 = rxh->PhyRxStatus_3;
	uint16 macstatus1 = rxh->RxStatus1;
	uint16 macstatus2 = rxh->RxStatus2;
	char flagstr[64];
	char lenbuf[20];
	static const bcm_bit_desc_t macstat_flags[] = {
		{RXS_FCSERR, "FCSErr"},
		{RXS_RESPFRAMETX, "Reply"},
		{RXS_PBPRES, "PADDING"},
		{RXS_DECATMPT, "DeCr"},
		{RXS_DECERR, "DeCrErr"},
		{RXS_BCNSENT, "Bcn"},
		{0, NULL}
	};

	prhex("Raw RxDesc", (uchar *)rxh, sizeof(d11rxhdr_t));

	bcm_format_flags(macstat_flags, macstatus1, flagstr, 64);

	snprintf(lenbuf, sizeof(lenbuf), "0x%x", len);

	printf("RxFrameSize:     %6s (%d)%s\n", lenbuf, len,
		(rxh->PhyRxStatus_0 & PRXS0_SHORTH) ? " short preamble" : "");
	printf("RxPHYStatus:     %04x %04x %04x %04x\n",
		phystatus_0, phystatus_1, phystatus_2, phystatus_3);
	printf("RxMACStatus:     %x %s\n", macstatus1, flagstr);
	printf("RXMACaggtype: %x\n", (macstatus2 & RXS_AGGTYPE_MASK));
	printf("RxTSFTime:       %04x\n", rxh->RxTSFTime);
}

void
wlc_print_hdrs(wlc_info_t *wlc, const char *prefix, uint8 *frame,
               d11txh_t *txh, wlc_d11rxhdr_t *wrxh, uint len)
{
	ASSERT(!(txh && wrxh));

	printf("\nwl%d: %s:\n", wlc->pub->unit, prefix);

	if (txh) {
		wlc_print_txdesc(txh);
	} else if (wrxh) {
		wlc_recv_print_rxh(wrxh);
	}

	if (len > 0) {
		ASSERT(frame != NULL);
		wlc_print_dot11hdr(frame, len);
	}
}
#endif /* BCMDBG || WLMSG_PRHDRS */

#if defined(WLTINYDUMP) || defined(BCMDBG) || defined(WLMSG_ASSOC) || \
	defined(WLMSG_PRPKT) || defined(WLMSG_OID) || defined(BCMDBG_DUMP) || \
	defined(WLMSG_INFORM) || defined(WLMSG_WSEC)
int
wlc_format_ssid(char* buf, const uchar ssid[], uint ssid_len)
{
	uint i, c;
	char *p = buf;
	char *endp = buf + SSID_FMT_BUF_LEN;

	if (ssid_len > DOT11_MAX_SSID_LEN) ssid_len = DOT11_MAX_SSID_LEN;

	for (i = 0; i < ssid_len; i++) {
		c = (uint)ssid[i];
		if (c == '\\') {
			*p++ = '\\';
			*p++ = '\\';
		} else if (bcm_isprint((uchar)c)) {
			*p++ = (char)c;
		} else {
			p += snprintf(p, (endp - p), "\\x%02X", c);
		}
	}
	*p = '\0';
	ASSERT(p < endp);

	return (int)(p - buf);
}
#endif /* WLTINYDUMP || BCMDBG || WLMSG_ASSOC || WLMSG_PRPKT || WLMSG_OID || BCMDBG_DUMP */

uint16
wlc_rate_shm_offset(wlc_info_t *wlc, uint8 rate)
{
	return (wlc_bmac_rate_shm_offset(wlc->hw, rate));
}

/* Callback for device removed */
#if defined(WLC_HIGH_ONLY)
void
wlc_device_removed(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t *)arg;

	wlc->device_present = FALSE;
}
#endif 

/* alloc fragment buf and fill with data from msdu input packet */
static void *
wlc_allocfrag(osl_t *osh, void *sdu, uint offset, uint headroom, uint frag_length, uint tailroom)
{
	void *p1;
	uint plen;
	uint totlen = pkttotlen(osh, sdu);

	/* In TKIP, (offset >= pkttotlen(sdu)) is possible due to MIC. */
	if (offset >= totlen) {
		plen = 0; /* all sdu has been consumed */
	} else {
		plen = MIN(frag_length, totlen - offset);
	}
	/* one-copy: alloc fragment buffers and fill with data from msdu input pkt */


	/* alloc a new pktbuf */
	if ((p1 = PKTGET(osh, headroom + tailroom + plen, TRUE)) == NULL)
		return (NULL);
	PKTPULL(osh, p1, headroom);

	/* copy frags worth of data at offset into pktbuf */
	pktcopy(osh, sdu, offset, plen, (uchar*)PKTDATA(osh, p1));
	PKTSETLEN(osh, p1, plen);

	/* Currently our PKTXXX macros only handle contiguous pkts. */
	ASSERT(!PKTNEXT(osh, p1));

	return (p1);
}

/*
 * If a lifetime is configured, calculate the expiry time for
 * the packet and update the pkttag.
 */
void
wlc_lifetime_set(wlc_info_t *wlc, void *sdu, uint32 lifetime)
{
	WLPKTTAG(sdu)->flags |= WLF_EXPTIME;
	WLPKTTAG(sdu)->exptime = R_REG(wlc->osh, &wlc->regs->tsf_timerlow) + lifetime;
}

/*
 * Attempts to queue a packet onto a multiple-precedence queue,
 * if necessary evicting a lower precedence packet from the queue.
 *
 * 'prec' is the precedence number that has already been mapped
 * from the packet priority.
 *
 * Returns TRUE if packet consumed (queued), FALSE if not.
 */
bool BCMFASTPATH
wlc_prec_enq(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec)
{
	return wlc_prec_enq_head(wlc, q, pkt, prec, FALSE);
}

bool BCMFASTPATH
wlc_prec_enq_head(wlc_info_t *wlc, struct pktq *q, void *pkt, int prec, bool head)
{
	void *p;
	void *dqp = NULL;
	int eprec = -1;		/* precedence to evict from */


	/* Determine precedence from which to evict packet, if any */
	if (pktq_pfull(q, prec))
		eprec = prec;
	else if (pktq_full(q)) {
		p = pktq_peek_tail(q, &eprec);
		ASSERT(p != NULL);
		if (eprec > prec)
			return FALSE;
	}

	/* Evict if needed */
	if (eprec >= 0) {
		bool discard_oldest;
		struct scb *scb;

		/* Detect queueing to unconfigured precedence */
		ASSERT(!pktq_pempty(q, eprec));

		discard_oldest = AC_BITMAP_TST(wlc->wme_dp2precmap, eprec);

		/* Refuse newer packet unless configured to discard oldest */
		if (eprec == prec && !discard_oldest)
			return FALSE;

		/* Evict packet according to discard policy */
		dqp = discard_oldest ? pktq_pdeq(q, eprec) : pktq_pdeq_tail(q, eprec);
		ASSERT(dqp != NULL);

		/* Increment wme stats */
		if (WME_ENAB(wlc->pub)) {
			WLCNTINCR(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(PKTPRIO(dqp))].packets);
			WLCNTADD(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(PKTPRIO(dqp))].bytes,
			         pkttotlen(wlc->osh, dqp));
		}

		scb = WLPKTTAGSCBGET(dqp);
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		WLCIFCNTINCR(scb, txnobuf);

	}

	/* Enqueue */
	if (head)
		p = pktq_penq_head(q, prec, pkt);
	else
		p = pktq_penq(q, prec, pkt);
	ASSERT(p != NULL);
	PKTDBG_TRACE(wlc->osh, p, PKTLIST_PRECQ);

	/* Free dequeued packet */
	if (dqp != NULL) {
		PKTFREE(wlc->osh, dqp, TRUE);
	}

	return TRUE;
}

static void BCMFASTPATH
wlc_txq_enq(void *ctx, struct scb *scb, void *sdu, uint prec)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	wlc_txq_info_t *qi = SCB_WLCIFP(scb)->qi;
	struct pktq *q = &qi->q;
	int prio;

	prio = PKTPRIO(sdu);

	ASSERT(pktq_max(q) >= wlc->pub->tunables->datahiwat);

	if (!wlc_prec_enq(wlc, q, sdu, prec)) {
		if (!EDCF_ENAB(wlc->pub) || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL))
			WL_ERROR(("wl%d: wlc_txq_enq: txq overflow\n", wlc->pub->unit));
		else
			WL_INFORM(("wl%d: wlc_txq_enq: txq overflow\n", wlc->pub->unit));

		PKTDBG_TRACE(wlc->osh, sdu, PKTLIST_FAIL_PRECQ);
		PKTFREE(wlc->osh, sdu, TRUE);
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		WLCIFCNTINCR(scb, txnobuf);
	}

	/* Check if flow control needs to be turned on after enqueuing the packet
	 *   Don't turn on flow control if EDCF is enabled. Driver would make the decision on what
	 *   to drop instead of relying on stack to make the right decision
	 */
	if (!EDCF_ENAB(wlc->pub) || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL)) {
		if (pktq_len(q) >= wlc->pub->tunables->datahiwat) {
			wlc_txflowcontrol(wlc, qi, ON, ALLPRIO);
		}
	} else if (wlc->pub->_priofc) {
		if (pktq_plen(q, wlc_prio2prec_map[prio]) >= wlc->pub->tunables->datahiwat) {
			wlc_txflowcontrol(wlc, qi, ON, prio);
		}
	}
}

/* Sends an 80211 packet with radio parameters specified */
bool BCMFASTPATH
wlc_send80211_specified(wlc_info_t *wlc, void *sdu, ratespec_t rspec, struct wlc_if *wlcif)
{
	bool short_preamble = FALSE;
	wlc_bsscfg_t *bsscfg;
	struct scb *scb;
	chanspec_t chanspec;

	/* figure out the bsscfg for this packet */
	bsscfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif);
	ASSERT(bsscfg != NULL);

	if (wlcif == NULL)
		wlcif = bsscfg->wlcif;

	ASSERT(wlcif->qi != NULL);

	chanspec = wlc_get_home_chanspec(bsscfg);

	/* grab the hwrs_scb and validate the rate override
	 * based on the home channel band for this wlcif
	 */
	if (CHSPEC_IS2G(chanspec)) {
		scb = wlc->bandstate[BAND_2G_INDEX]->hwrs_scb;
	} else {
		scb = wlc->bandstate[BAND_5G_INDEX]->hwrs_scb;
		/* make sure the rate override does not specify a DSSS/CCK rate */
		if (IS_CCK(rspec)) {
			rspec = 0; /* clear the invalid rate override */
			WL_ERROR(("wl%d: %s: rate override with DSSS rate "
			          "incompatible with 5GHz band\n",
			          wlc->pub->unit, __FUNCTION__));
		}
	}

	/* validate the rspec for the correct BW */
	if ((rspec & RSPEC_OVERRIDE) &&
	    RSPEC_IS40MHZ(rspec) &&
	    CHSPEC_IS20(wlc->chanspec)) {
		rspec = 0; /* clear the invalid rate override */
		WL_ERROR(("wl%d: %s: rate override with 40MHz bw but only 20MHz channel\n",
		          wlc->pub->unit, __FUNCTION__));
	}

	/* if the rspec is for 2,5.5,11 rate, and specifies a mode override,
	 * check for short preamble
	 */
	if ((rspec & RSPEC_OVERRIDE) &&
	    !IS_MCS(rspec) &&
	    ((rspec & RATE_MASK) == WLC_RATE_2M ||
	     (rspec & RATE_MASK) == WLC_RATE_5M5 ||
	     (rspec & RATE_MASK) == WLC_RATE_11M))
		short_preamble = ((rspec & RSPEC_SHORT_PREAMBLE) != 0);

	return wlc_queue_80211_frag(wlc, sdu, wlcif->qi, scb, short_preamble, NULL, rspec);
}

bool
wlc_send80211pkt(wlc_info_t *wlc, void *sdu, struct wlc_if *wlcif)
{
	struct scb *scb;
	wlc_bsscfg_t *bsscfg;
	struct dot11_header *h;
	wlc_txq_info_t *qi;
	uint16 fc;
	struct ether_addr *dst;
	bool	ibss_frame = FALSE;
	int8 bsscfgidx = -1;
	uint32	lifetime;
	uint8 prio;

	/*
	 * Only used in LMAC builds, this expects the packet to be in specific format,
	 * so not a generic function yet
	 */
	if (!LMAC_ENAB(wlc->pub)) {
		WL_ERROR(("Only LMAC uses wlc_send80211pkt for now\n"));
		ASSERT(0);
	}

	ASSERT(!wlcif);
	bsscfg = wlc_bsscfg_primary(wlc);
	qi = bsscfg->wlcif->qi;

	ASSERT(pktq_max(&qi->q) >= wlc->pub->tunables->datahiwat);
	ASSERT(sdu != NULL);

	prio = (uint8)PKTPRIO(sdu);
	h = (struct dot11_header *)PKTDATA(wlc->osh, sdu);

	fc = ltoh16(h->fc);

	WL_TRACE(("%s: FC=0x%x Type=0x%x FromDS=%d ToDS=%d\n",
	          __FUNCTION__, fc, FC_TYPE(fc),
	           (fc & FC_FROMDS) ? 1 : 0,
	           (fc & FC_TODS) ? 1 : 0));

	if (((FC_TYPE(fc) == FC_TYPE_DATA) && (!(fc & (FC_TODS | FC_FROMDS)))) ||
		((FC_TYPE(fc) == FC_TYPE_MNG) && (FC_SUBTYPE(fc) == FC_SUBTYPE_ATIM))) {
		ibss_frame = TRUE;
	}
	dst = &h->a1;

	if (ETHER_ISMULTI(dst)) {
		scb = WLC_BCMCSCB_GET(wlc, bsscfg);
		if (scb == NULL) {
			WL_ERROR(("wl%d: wlc_send80211pkt: invalid multicast frame\n",
			          wlc->pub->unit));
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
	}
	else if (ibss_frame) {
		scb = wlc_scblookupband(wlc, dst,
		                        CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec));
		if (!scb) {
			WL_ERROR(("wl%d: wlc_send80211pkt: out of scbs\n", wlc->pub->unit));
			WLCNTINCR(wlc->pub->_cnt->txnobuf);
			/* Increment interface stats */
			WLCNTINCR(wlcif->_cnt.txnobuf);
			goto toss;
		}
	}
	else {
		scb = wlc_scbfind(wlc, dst);
		if (!scb || (scb->bsscfg != bsscfg)) {
#ifdef BCMDBG_ERR
			char eabuf[ETHER_ADDR_STR_LEN];
			WL_ERROR(("wl%d: wlc_send80211pkt: "
			          "invalid frame to non-associated station %s\n",
			          wlc->pub->unit, bcm_ether_ntoa(dst, eabuf)));
#endif /* BCMDBG_ERR */
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
	}

	lifetime = wlc->lifetime[WME_PRIO2AC(prio)];
	if (!lifetime)
		lifetime = wlc->txmsdulifetime;

	if (lifetime)
		wlc_lifetime_set(wlc, sdu, lifetime);

	bsscfgidx = WLC_BSSCFG_IDX(bsscfg);
	ASSERT(BSSCFGIDX_ISVALID(bsscfgidx));
	WLPKTTAGBSSCFGSET(sdu, bsscfgidx);
	WLPKTTAGSCBSET(sdu, scb);

	SCB_TX_NEXT(TXMOD_START, scb, sdu, WLC_PRIO_TO_PREC(prio));
	wlc_send_q(wlc, qi);
	return (FALSE);

toss:
	/* Increment wme stats */
	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(prio)].packets);
		WLCNTADD(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(prio)].bytes,
		         pkttotlen(wlc->osh, sdu));
	}
	WL_ERROR(("wl%d: wlc_send80211pkt: tossing pkt %p\n", wlc->pub->unit, sdu));
	PKTFREE(wlc->osh, sdu, TRUE);
	return (FALSE);
}


#ifdef STA
static void
wlc_4way_m4_tx(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	int err;
	int i;
	wsec_key_buf_info_t *buf_info;

	/* in case bsscfg is freed before this callback is invoked */
	if (cfg == NULL) {
		return;
	}

	buf_info = cfg->wsec_key_buf_info;

	if (buf_info == NULL)
		return;

	/* install the key */
	for (i = 0; i < BSSCFG_BUF_KEY_NUM; i++) {
		wsec_key_t *insert_key = NULL;

		if (buf_info->key_buffered[i]) {
			WL_WSEC(("wl%d:%s(): install buffered %s key ...\n",
				wlc->pub->unit, __FUNCTION__,
				(i == BSSCFG_BUF_KEY_PAIR_ID) ? "pairwise" : "group"));
			err = wlc_key_insert(wlc, cfg, buf_info->buf_key[i].len,
				buf_info->buf_key[i].index, buf_info->buf_key[i].flags,
				buf_info->buf_key[i].algo, buf_info->buf_key[i].data,
				&buf_info->buf_key[i].ea,
				(buf_info->buf_key[i].iv_initialized ?
				&buf_info->buf_key_iv[i] : NULL),
				&insert_key);
			if (err)
				return;
			if ((insert_key != NULL) &&
				(insert_key->idx != buf_info->buf_key[i].index)) {
				WL_WSEC(("wl%d:%s(): wlc_key_insert(): set gtk_idx to %d\n",
					wlc->pub->unit, __FUNCTION__, insert_key->idx));
			}

			buf_info->key_buffered[i] = FALSE;

			buf_info->eapol_4way_m1_rxed = FALSE;
		}
	}

	buf_info->eapol_4way_m4_txed = TRUE;
}
#endif /* STA */
#ifdef WMF
static bool
is_igmp(struct ether_header *eh)
{
	uint8 *iph = (uint8 *)eh + ETHER_HDR_LEN;

	if ((ntoh16(eh->ether_type) == ETHER_TYPE_IP) && (IP_VER(iph) == IP_VER_4) &&
		(IPV4_PROT(iph) == IP_PROT_IGMP))
		return TRUE;
	else
		return FALSE;
}
#endif

/*
 * Enqueues a packet on txq, then sends as many packets as possible.
 * Packets are enqueued to a maximum depth of WLC_DATAHIWAT*2.
 * tx flow control is turned on at WLC_DATAHIWAT, and off at WLC_DATAHIWAT/2.
 *
 * NOTE: it's important that the txq be able to accept at least
 * one packet after tx flow control is turned on, as this ensures
 * NDIS does not drop a packet.
 *
 * Returns TRUE if packet discarded and freed because txq was full, FALSE otherwise.
 */
bool BCMFASTPATH
wlc_sendpkt(wlc_info_t *wlc, void *sdu, struct wlc_if *wlcif)
{
	struct scb *scb = NULL;
	osl_t *osh;
	struct ether_header *eh;
	struct ether_addr *dst;
	wlc_bsscfg_t *bsscfg;
	struct ether_addr *wds = NULL;
	bool discarded = FALSE;
	void *pkt;
	int8 bsscfgidx = -1;
	uint32 lifetime;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */
	wlc_bss_info_t *current_bss;

	WL_TRACE(("wlc%d: wlc_sendpkt\n", wlc->pub->unit));

	/* sanity */
	ASSERT(sdu != NULL);


	osh = wlc->osh;

	WL_APSTA_TX(("wl%d: wlc_sendpkt() pkt %p, wlcif %p total_len %d\n",
		wlc->pub->unit, sdu, wlcif, pkttotlen(osh, sdu)));

	/* figure out the bsscfg for this packet */
	bsscfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif);
	ASSERT(bsscfg != NULL);

		eh = (struct ether_header*) PKTDATA(osh, sdu);

	if (!BSSCFG_SAFEMODE(bsscfg)) {

#ifdef WLBTAMP
		/* Process BT-SIG packets and fixup missing/inconsistent info including wlcif. */
		if (BTA_ENAB(wlc->pub) && (ntoh16(eh->ether_type) < ETHER_TYPE_MIN) &&
		    (PKTLEN(osh, sdu) >= RFC1042_HDR_LEN) &&
		    bcmp(&eh[1], BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0) {
			/* a non-zero return value indicates no further processing is needed! */
			if (wlc_bta_send_proc(wlc->bta, sdu, &wlcif))
				goto toss;
			/* update eh again since we may have changed the headers location! */
			eh = (struct ether_header*)PKTDATA(osh, sdu);
		}
#endif /* WLBTAMP */

		WL_APSTA_TX(("wl%d: wlc_sendpkt() pkt %p, wlcif %p type %d\n",
		             wlc->pub->unit, sdu, wlcif, (wlcif ? wlcif->type : 0)));

		/* figure out the bsscfg for this packet */
		bsscfg = wlc_bsscfg_find_by_wlcif(wlc, wlcif);
		ASSERT(bsscfg != NULL);
	}

	/* fixup wlcif in case it is NULL */
	if (wlcif == NULL)
		wlcif = bsscfg->wlcif;
	ASSERT(wlcif != NULL);

#ifdef WET
	/* Apply WET only on the STA interface */
	if (wlc->wet && BSSCFG_STA(bsscfg) &&
	    wlc_wet_send_proc(wlc->weth, sdu, &sdu) < 0)
		goto toss;
#endif /* WET */

	if (wlcif->type == WLC_IFTYPE_WDS) {
		scb = wlcif->u.scb;
		wds = &scb->ea;
	}

	/* discard if we're not up or not yet part of a BSS */
	if (!wds && (!bsscfg->up || (BSSCFG_STA(bsscfg) && ETHER_ISNULLADDR(&bsscfg->BSSID)))) {
		WL_INFORM(("wl%d: wlc_sendpkt: bsscfg %p is not up\n", wlc->pub->unit, bsscfg));
		WLCNTINCR(wlc->pub->_cnt->txnoassoc);
		goto toss;
	}

	ASSERT(WLPKTTAG(sdu) != NULL);

	if (!BSSCFG_SAFEMODE(bsscfg)) {
#ifdef WMF
		/* Do the WMF processing for multicast packets */
		if (!wds && WMF_ENAB(bsscfg) && (ETHER_ISMULTI(eh->ether_dhost) ||
			(bsscfg->wmf_ucast_igmp && is_igmp(eh)))) {
			/* We only need to process packets coming from the stack/ds */
			switch (wlc_wmf_packets_handle(bsscfg, NULL, sdu, 0)) {
			case WMF_TAKEN:
				/* The packet is taken by WMF return */
				return (FALSE);
			case WMF_DROP:
				/* Packet DROP decision by WMF. Toss it */
				goto toss;
			default:
				/* Continue the transmit path */
				break;
			}
		}
#endif /* WMF */

#ifdef MAC_SPOOF
		/* in MAC Clone/Spoof mode, change our MAC address to be that of the original
		 * sender of the packet.  This will allow full layer2 bridging for that client.
		 * Note:  This is to be used in STA mode, and is not to be used with WET.
		 */
		if (wlc->mac_spoof &&
		    bcmp(&eh->ether_shost, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN)) {
			if (wlc->wet)
				WL_ERROR(("Configuration Error,"
					"MAC spoofing not supported in WET mode"));
			else {
				bcopy(&eh->ether_shost, &wlc->pub->cur_etheraddr, ETHER_ADDR_LEN);
				bcopy(&eh->ether_shost, &bsscfg->cur_etheraddr, ETHER_ADDR_LEN);
				WL_INFORM(("wlc_sendpkt:  Setting WL device MAC address to %s",
				           bcm_ether_ntoa(&bsscfg->cur_etheraddr, eabuf)));
				wlc_set_mac(bsscfg);
			}
		}
#endif /* MAC_SPOOF */
	}

	if (wds)
		dst = wds;
	else if (BSSCFG_AP(bsscfg))
		dst = (struct ether_addr*)eh->ether_dhost;
	else {
		dst = bsscfg->BSS ? &bsscfg->BSSID : (struct ether_addr*)eh->ether_dhost;
	}

	current_bss = bsscfg->current_bss;

	/* toss if station is not associated to the correct bsscfg. Make sure to use
	 * the band while looking up as we could be scanning on different band
	 */
	if (!wds && bsscfg->BSS && !ETHER_ISMULTI(dst)) {
		/* Class 3 (BSS) frame */
		if (!(scb = wlc_scbfindband(wlc, dst,
			CHSPEC_WLCBANDUNIT(current_bss->chanspec))) ||
		    (scb->bsscfg != bsscfg)) {
			WL_INFORM(("wl%d: wlc_sendpkt: invalid class 3 frame to "
				"non-associated station %s\n", wlc->pub->unit,
				bcm_ether_ntoa(dst, eabuf)));
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
	} else {
		/* Class 1 (IBSS/DPT) or 4 (WDS) frame */
		if (ETHER_ISMULTI(dst)) {
			scb = WLC_BCMCSCB_GET(wlc, bsscfg);
			if (scb == NULL) {
				WL_ERROR(("wl%d: wlc_sendpkt: invalid multicast frame\n",
				          wlc->pub->unit));
				WLCNTINCR(wlc->pub->_cnt->txnoassoc);
				goto toss;
			}
		}
		else if (!scb &&
		         !(scb = wlc_scblookupband(wlc, dst,
		                CHSPEC_WLCBANDUNIT(current_bss->chanspec)))) {
			WL_ERROR(("wl%d: wlc_sendpkt: out of scbs\n", wlc->pub->unit));
			WLCNTINCR(wlc->pub->_cnt->txnobuf);
			/* Increment interface stats */
			if (wlcif != NULL)
				WLCNTINCR(wlcif->_cnt.txnobuf);
			goto toss;
		}
#ifdef WLBTAMP
		else if (BSS_BTA_ENAB(wlc, bsscfg) &&
		         (scb->bsscfg != bsscfg || !SCB_ASSOCIATED(scb))) {
			WL_INFORM(("wl%d: wlc_sendpkt: invalid class 4 frame to "
			           "non-associated BT-AMP peer %s\n", wlc->pub->unit,
			           bcm_ether_ntoa(dst, eabuf)));
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
#endif
	}

	/* per-port code must keep track of WDS cookies */
	ASSERT(!wds || SCB_WDS(scb));


		pkt = wlc_hdr_proc(wlc, sdu, scb);

	/* Header conversion failed */
	if (pkt == NULL)
		goto toss;
	else
		sdu = pkt;

	/* early discard of non-8021x frames if keys are not plumbed */
	if (!BSSCFG_SAFEMODE(bsscfg) &&
	    WSEC_ENABLED(bsscfg->wsec) &&
	    !(WLPKTTAG(pkt)->flags & WLF_8021X) &&
#ifdef BCMWAPI_WAI
	    !(WLPKTTAG(pkt)->flags & WLF_WAI) &&
#endif
	    !scb->key &&
	    !(WSEC_BSS_DEFAULT_KEY(bsscfg))) {
		WL_WSEC(("wl%d: wlc_sendpkt: tossing unencryptable frame, flags=0x%x\n",
			wlc->pub->unit, WLPKTTAG(pkt)->flags));
		goto toss;
	}

	bsscfgidx = WLC_BSSCFG_IDX(bsscfg);
	ASSERT(BSSCFGIDX_ISVALID(bsscfgidx));
	WLPKTTAGBSSCFGSET(sdu, bsscfgidx);
	WLPKTTAGSCBSET(sdu, scb);

#ifdef	WLCAC
	if (CAC_ENAB(wlc->pub)) {

		if (!wlc_cac_is_traffic_admitted(wlc->cac, WME_PRIO2AC(PKTPRIO(sdu)), scb)) {
			WL_CAC(("%s: Pkt dropped. Admission not granted for ac %d pktprio %d\n",
				__FUNCTION__, WME_PRIO2AC(PKTPRIO(sdu)), PKTPRIO(sdu)));
			goto toss;
		}

		if (BSSCFG_AP(bsscfg) && !SCB_ISMULTI(scb)) {
			wlc_cac_reset_inactivity_interval(wlc->cac, WME_PRIO2AC(PKTPRIO(sdu)), scb);
		}
	}
#endif /* WLCAC */

	/* Set packet lifetime if configured */
	if (!(WLPKTTAG(sdu)->flags & WLF_EXPTIME) &&
	    (lifetime = wlc->lifetime[(SCB_WME(scb) ? WME_PRIO2AC(PKTPRIO(sdu)) : AC_BE)]))
		wlc_lifetime_set(wlc, sdu, lifetime);

	WLPKTTAG(sdu)->flags |= WLF_DATA;

	SCB_TX_NEXT(TXMOD_START, scb, sdu, WLC_PRIO_TO_PREC(PKTPRIO(sdu)));
	wlc_send_q(wlc, bsscfg->wlcif->qi);

	return (FALSE);

toss:
	/* Increment wme stats */
	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(PKTPRIO(sdu))].packets);
		WLCNTADD(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(PKTPRIO(sdu))].bytes,
		         pkttotlen(osh, sdu));
	}

	WL_APSTA_TX(("wl%d: wlc_sendpkt: tossing pkt %p\n", wlc->pub->unit, sdu));
	PKTFREE(osh, sdu, TRUE);
	return (discarded);
}

/* Move flags from one packet to another */
#define WLPKTTAG_FLAGS_COPY_COMMON(pkt_from, pkt_to) \
	do { \
		WLPKTTAG(pkt_to)->flags = WLPKTTAG(pkt_from)->flags & \
			(WLF_AMSDU | WLF_APSD | WLF_AMPDU_MPDU | WLF_BSS_DOWN | \
			 WLF_DPT_TYPE | WLF_DPT_DIRECT | WLF_DPT_APPATH | \
			 WLF_USERTS | WLF_RATE_AUTO | WLF_8021X | WLF_EXPTIME | \
		         WLF_DATA | WLF_TXHDR); \
		WLPKTTAG(pkt_to)->flags2 = WLPKTTAG(pkt_from)->flags2 & \
			(WLF2_TYPE_MASK); \
	} while (0)

#ifdef BCMWAPI_WAI
#define WLPKTTAG_FLAGS_COPY(pkt_from, pkt_to) \
	do { \
		WLPKTTAG_FLAGS_COPY_COMMON(pkt_from, pkt_to); \
		WLPKTTAG(pkt_to)->flags |= WLPKTTAG(pkt_from)->flags & \
			(WLF_WAI); \
	} while (0)
#else
#define WLPKTTAG_FLAGS_COPY(pkt_from, pkt_to) \
	do { \
		WLPKTTAG_FLAGS_COPY_COMMON(pkt_from, pkt_to); \
	} while (0)
#endif /* BCMWAPI_WAI */

#define WLPKTTAG_FLAGS_MOVE(pkt_from, pkt_to) \
	do { \
		WLPKTTAG_FLAGS_COPY(pkt_from, pkt_to); \
	} while (0)

/* Move callback functions from a packet to another
 * CAUTION: This is destructive operation for pkt_from
 */
void
wlc_pkttag_info_move(wlc_pub_t *pub, void *pkt_from, void *pkt_to)
{
	/* Make sure not moving to same packet! */
	ASSERT(pkt_from != pkt_to);
	WLPKTTAG(pkt_to)->callbackidx = WLPKTTAG(pkt_from)->callbackidx;
	WLPKTTAG(pkt_from)->callbackidx = 0;
	WLPKTTAG(pkt_to)->_bsscfgidx = WLPKTTAG(pkt_from)->_bsscfgidx;
	WLPKTTAG(pkt_to)->_scb = WLPKTTAG(pkt_from)->_scb;
	WLPKTTAG(pkt_to)->seq = WLPKTTAG(pkt_from)->seq;
	WLPKTTAG(pkt_to)->exptime = WLPKTTAG(pkt_from)->exptime;
	WLPKTTAG_FLAGS_MOVE(pkt_from, pkt_to);
	if (pub->_lmac) {
		/* LMAC specific pkttag info */
		WLPKTTAG(pkt_to)->ac_override = WLPKTTAG(pkt_from)->ac_override;
		WLPKTTAG(pkt_to)->shared.packetid = WLPKTTAG(pkt_from)->shared.packetid;
	}
}


/* allocate headroom buffer if necessary and convert ether frame to 8023 frame
 * !! WARNING: HND WL driver only supports data frame of type ethernet, 802.1x or 802.3
 */
void * BCMFASTPATH
wlc_hdr_proc(wlc_info_t *wlc, void *sdu, struct scb *scb)
{
	osl_t *osh;
	struct ether_header *eh;
	void *pkt;
	int prio;

	osh = wlc->osh;

	/* allocate enough room once for all cases */
	prio = PKTPRIO(sdu);
	if ((uint)PKTHEADROOM(osh, sdu) < TXOFF || PKTSHARED(sdu)) {
		if ((pkt = PKTGET(osh, TXOFF, TRUE)) == NULL) {
			WL_ERROR(("wl%d: wlc_hdr_proc, PKTGET headroom %d failed\n",
				wlc->pub->unit, TXOFF));
			WLCNTINCR(wlc->pub->_cnt->txnobuf);
			/* increment interface stats */
			WLCIFCNTINCR(scb, txnobuf);
			return NULL;
		}
		PKTPULL(osh, pkt, TXOFF);

		wlc_pkttag_info_move(wlc->pub, sdu, pkt);
		/* Transfer priority */
		PKTSETPRIO(pkt, prio);

		/* move ether_hdr from data buffer to header buffer */
		eh = (struct ether_header*) PKTDATA(osh, sdu);
		PKTPULL(osh, sdu, ETHER_HDR_LEN);
		PKTPUSH(osh, pkt, ETHER_HDR_LEN);
		bcopy((char*)eh, (char*)PKTDATA(osh, pkt), ETHER_HDR_LEN);

		/* chain original sdu onto newly allocated header */
		PKTSETNEXT(osh, pkt, sdu);
		sdu = pkt;
	}

	{
	/*
	 * Optionally add an 802.1Q VLAN tag to convey non-zero priority for
	 * non-WMM associations.
	 */
	eh = (struct ether_header *)PKTDATA(osh, sdu);

	if (prio && !SCB_QOS(scb)) {
		if (
#ifdef WLAFTERBURNER
		    !wlc->afterburner &&
#endif /* WLAFTERBURNER */
		    (wlc->vlan_mode != OFF) && (ntoh16(eh->ether_type) != ETHER_TYPE_8021Q)) {
			struct ethervlan_header *vh;
			struct ether_header da_sa;

			bcopy(eh, &da_sa, VLAN_TAG_OFFSET);
			vh = (struct ethervlan_header *)PKTPUSH(osh, sdu, VLAN_TAG_LEN);
			bcopy(&da_sa, vh, VLAN_TAG_OFFSET);

			vh->vlan_type = hton16(ETHER_TYPE_8021Q);
			vh->vlan_tag = hton16(prio << VLAN_PRI_SHIFT);	/* Priority-only Tag */
		}

		if (WME_ENAB(wlc->pub) && !wlc->wme_prec_queuing) {
			prio = 0;
			PKTSETPRIO(sdu, prio);
		}
	}
	}

	/*
	 * Original Ethernet (header length = 14):
	 * ----------------------------------------------------------------------------------------
	 * |                                                     |   DA   |   SA   | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *                                                            6        6     2
	 *
	 * Conversion to 802.3 (header length = 22):
	 *                     (LLC includes ether_type in last 2 bytes):
	 * ----------------------------------------------------------------------------------------
	 * |                                      |   DA   |   SA   | L | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *                                             6        6     2       6      2
	 */

	eh = (struct ether_header *)PKTDATA(osh, sdu);
	if ((ntoh16(eh->ether_type) > ETHER_MAX_DATA)) {

		if (ntoh16(eh->ether_type) == ETHER_TYPE_802_1X)
			WLPKTTAG(sdu)->flags |= WLF_8021X;
#ifdef BCMWAPI_WAI
		if (ntoh16(eh->ether_type) == ETHER_TYPE_WAI) {
			WLPKTTAG(sdu)->flags |= WLF_WAI;
		}
#endif /* BCMWAPI_WAI */

		/* save original type in pkt tag */
		WLPKTTAG(sdu)->flags |= WLF_NON8023;
		wlc_ether_8023hdr(wlc, osh, eh, sdu);
	}

	return sdu;
}

void BCMFASTPATH
wlc_send_q(wlc_info_t *wlc, wlc_txq_info_t *qi)
{
	void *pkt[DOT11_MAXNUMFRAGS];
	int prec;
	uint16 prec_map;
	int err, i, count;
	uint fifo;
	wlc_pkttag_t *pkttag;
	struct scb *scb;
	struct pktq *q = &qi->q;
#if defined(STA) && defined(ADV_PS_POLL)
	uint8 prio;
#endif /* ADV_PS_POLL */
	wlc_bsscfg_t *cfg;

#if defined(DSLCPE_DELAY)
	if (IN_LONG_DELAY(wlc->osh)) {
		return;
	}
#endif

#ifdef WL_BSSCFG_TX_SUPR
	/* Waiting to drain the FIFO so don't pull any packet */
	if (wlc->block_datafifo & DATA_BLOCK_TX_SUPR)
		return;
#endif

#ifdef WL_MULTIQUEUE
	/* Detaching queue is still pending, don't queue packets to FIFO */
	if (wlc->txfifo_detach_pending)
		return;
#endif /* WL_MULTIQUEUE */

	/* only do work for the active queue */
	if (qi != wlc->active_queue)
		return;

	if (in_send_q)
		return;
	else
		in_send_q = TRUE;

	prec_map = wlc->tx_prec_map;

	/* Send all the enq'd pkts that we can.
	 * Dequeue packets with precedence with empty HW fifo only
	 */
	while (prec_map && (pkt[0] = pktq_mdeq(q, prec_map, &prec))) {
		/* Send AMPDU using wlc_sendampdu (calls wlc_txfifo() also),
		 * SDU using wlc_prep_sdu and PDU using wlc_prep_pdu followed by
		 * wlc_txfifo() for each of the fragments
		 */
		pkttag = WLPKTTAG(pkt[0]);

		scb = WLPKTTAGSCBGET(pkt[0]);
		ASSERT(scb != NULL);

		cfg = SCB_BSSCFG(scb);
		ASSERT(cfg != NULL);

		if (BSS_TX_SUPR(cfg)) {
			ASSERT(!(wlc->block_datafifo & DATA_BLOCK_TX_SUPR));
			if (wlc_bsscfg_txq_enq(wlc, cfg, pkt[0], prec))
				PKTFREE(wlc->osh, pkt[0], TRUE);
			continue;
		}

#ifdef WLAMPDU
		if (WLPKTFLAG_AMPDU(pkttag))
			err = wlc_sendampdu(wlc->ampdu, qi, pkt, prec);
		else
#endif
		{
			if (pkttag->flags & WLF_MPDU) {
				count = 1;
				err = wlc_prep_pdu(wlc, pkt[0], &fifo);
			} else {
				err = wlc_prep_sdu(wlc, pkt, &count, &fifo);
#if defined(STA) && defined(ADV_PS_POLL)
				if (BSSCFG_STA(cfg) && cfg->BSS && cfg->pm->adv_ps_poll) {
					scb = WLPKTTAGSCBGET(pkt[0]);
					ASSERT(scb != NULL);
					cfg = SCB_BSSCFG(scb);
					ASSERT(cfg != NULL);
					prio = 0;
					if (SCB_QOS(scb)) {
						prio = (uint8)PKTPRIO(pkt[0]);
						ASSERT(prio <= MAXPRIO);
					}
					if (!(WME_ENAB(wlc->pub) && (fifo <= TX_AC_VO_FIFO) &&
					     AC_BITMAP_TST(scb->apsd.ac_trig, WME_PRIO2AC(prio))) &&
					    cfg->pm->PM == PM_MAX) {
						cfg->pm->send_pspoll_after_tx = TRUE;
					}
				}
#endif /* ADV_PS_POLL */
			}

			/* transmit if no error */
			if (!err) {

#ifdef WLAMPDU_MAC
				if (AMPDU_MAC_ENAB(wlc->pub) && fifo < AC_COUNT) {
					wlc_ampdu_change_epoch(wlc->ampdu, fifo,
						AMU_EPOCH_CHG_MPDU);
				}
#endif

				for (i = 0; i < count; i++) {
#ifdef WL11N
					uint16 frameid = ltoh16(((d11txh_t *)PKTDATA(wlc->osh,
						pkt[i]))->TxFrameID);
					if (frameid & TXFID_RATE_PROBE_MASK)
						wlc_ratesel_probe_ready(wlc->rsi,
							WLPKTTAGSCBGET(pkt[i]),	frameid, FALSE, 0);
#endif
					wlc_txfifo(wlc, fifo, pkt[i], TRUE, 1);
				}
			}
		}

		if (err == BCME_BUSY) {
			pktq_penq_head(q, prec, pkt[0]);
			/* If send failed due to any other reason than a change in
			 * HW FIFO condition, quit. Otherwise, read the new prec_map!
			 */
			if (prec_map == wlc->tx_prec_map)
				break;
			prec_map = wlc->tx_prec_map;
		}
	}

	/* Check if flow control needs to be turned off after sending the packet */
	if (!EDCF_ENAB(wlc->pub) || (wlc->pub->wlfeatureflag & WL_SWFL_FLOWCONTROL)) {
		if (wlc_txflowcontrol_prio_isset(wlc, qi, ALLPRIO) &&
		    (pktq_len(q) < wlc->pub->tunables->datahiwat / 2)) {
			wlc_txflowcontrol(wlc, qi, OFF, ALLPRIO);
		}
	} else if (wlc->pub->_priofc) {
		int prio;

		for (prio = MAXPRIO; prio >= 0; prio--) {
			if (wlc_txflowcontrol_prio_isset(wlc, qi, prio) &&
			    (pktq_plen(q, wlc_prio2prec_map[prio]) <
			     wlc->pub->tunables->datahiwat/2)) {
				wlc_txflowcontrol(wlc, qi, OFF, prio);
			}
		}
	}

	in_send_q = FALSE;
}

/*
 * bcmc_fid_generate:
 * Generate frame ID for a BCMC packet.  The frag field is not used
 * for MC frames so is used as part of the sequence number.
 */
static INLINE uint16
bcmc_fid_generate(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, d11txh_t *txh)
{
	uint16 frameid = txh->TxFrameID;
	uint16 nextfid_mask;
	uint16 target_mc_fid;

	nextfid_mask =
		(frameid + (1 << TXFID_SEQ_SHIFT)) & (TXFID_SEQ_MASK | TXFID_QUEUE_MASK);
	target_mc_fid =
		((wlc->mc_fid_counter << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) | TX_BCMC_FIFO;

	/* Prevent generate consecutive fid on same packet twice */
	if (nextfid_mask != target_mc_fid) {
		frameid = frameid & ~(TXFID_SEQ_MASK | TXFID_QUEUE_MASK);
		frameid |= target_mc_fid;
		wlc->mc_fid_counter++;
	}

	return frameid;
}

/*
	do necessary work to allow use of the tx cache with encryption
	algorithm.
*/

static void
wlc_txc_iv_update(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct scb *scb, wsec_key_t *key,
                void *sdu, uint pktlen, txc_t *txc)
{
	uchar *iv_ptr;
	d11txh_t *txh;

	/* update IV */
	/* go to beginning of IV  */
	iv_ptr = txc->txh + txc->txhlen - key->iv_len;
	wlc_key_iv_update(wlc, cfg, key, iv_ptr, 1);
	txh = (d11txh_t*)(txc->txh);
	if (key->algo == CRYPTO_ALGO_TKIP) {
#ifndef LINUX_CRYPTO
		union {
			uint16 u16;
			uint8  u8[2];
		} u;
		int i = 0, j = 0;

		do {
			u.u16 = htol16(key->tkip_tx.phase1[i]);
			txh->IV[j++] = u.u8[0];
			txh->IV[j++] = u.u8[1];
		} while (++i < TKHASH_P1_KEY_SIZE/2);
		bcopy(iv_ptr, (char*)&txh->IV[TKHASH_P1_KEY_SIZE], 3);
#endif
#ifdef BCMWAPI_WPI
	} else if (key->algo == CRYPTO_ALGO_SMS4) {
		struct wpi_iv *wpi_iv;
		/* WAPI */
		wpi_iv = (struct wpi_iv *)iv_ptr;
		bcopy(&wpi_iv->PN[0], (char*)txh->IV, SMS4_WPI_PN_LEN);
#endif /* BCMWAPI_WPI */
	} else {
		bcopy(iv_ptr, (char *)txh->IV, key->iv_len);
	}
}

#ifdef STA
static void
wlc_pm_tx_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct scb *scb, bool dpt, uint fifo, uint prio)
{
	wlc_pm_st_t *pm;

	WL_RTDC(wlc, "wlc_pm_tx_upd", 0, 0);

	ASSERT(cfg != NULL);
	ASSERT(BSSCFG_STA(cfg));

	ASSERT(scb != NULL);

	pm = cfg->pm;

	if (!pm->PMenabled)
		return;

	/* Do not leave PS mode on a tx if the Receive Throttle
	 * feature is  enabled. Leaving PS mode during the OFF
	 * part of the receive throttle duty cycle
	 * for any reason will defeat the whole purpose
	 * of the OFF part of the duty cycle - heat reduction.
	 */
	if (!PM2_RCV_DUR_ENAB(cfg)) {
		/* Leave PS mode if in fast PM mode */
		if (pm->PM == PM_FAST &&
		    !dpt &&
		    !wlc->PMblocked) {
			WL_RTDC(wlc, "wlc_pm_tx_upd: exit PS", 0, 0);
			wlc_set_pmstate(cfg, FALSE);
			wlc_pm2_sleep_ret_timer_start(cfg);
		}
	}

#ifdef WME
	/* If sending APSD trigger frame, stay awake until EOSP */
	if (WME_ENAB(wlc->pub) && (fifo <= TX_AC_VO_FIFO) &&
	    AC_BITMAP_TST(scb->apsd.ac_trig, WME_PRIO2AC(prio))) {
		if (!pm->apsd_sta_usp) {
			WL_PS(("wl%d.%d: APSD wake\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
			wlc_set_apsd_stausp(cfg, TRUE);
		}
		scb->flags |= SCB_SENT_APSD_TRIG;
	}
#endif /* WME */
}
#endif /* STA */

/* driver fast path to send sdu using cached tx d11-phy-mac header (before llc/snap)
 *  doesn't support wsec and eap_restrict for now
 */
static void BCMFASTPATH
wlc_txfast(wlc_info_t *wlc, struct scb *scb, void *sdu, uint pktlen, txc_t *txc)
{
	osl_t *osh;
	struct ether_header *eh;
	d11txh_t *txh;
	uint16 seq, frameid;
	struct dot11_header *h;
	struct ether_addr da, sa;
	uint fifo = 0;
	wlc_pkttag_t *pkttag;
	wlc_bsscfg_t *bsscfg;

	osh = wlc->osh;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);
	ASSERT(txc != NULL);

	ASSERT(ISALIGNED((uintptr)PKTDATA(osh, sdu), 2));

	/* basic sanity check the tx cache */
	ASSERT((txc->txhlen >= (D11_TXH_LEN + D11_PHY_HDR_LEN + DOT11_A3_HDR_LEN)) &&
		(txc->txhlen < TXOFF));

	pkttag = WLPKTTAG(sdu);

	/* headroom has been allocated, may have llc/snap header already */
	/* uncomment after fixing osl_vx port
	 * ASSERT(PKTHEADROOM(osh, sdu) >= (TXOFF - DOT11_LLC_SNAP_HDR_LEN - ETHER_HDR_LEN));
	 */

	/* eh is going to be overwritten, save DA and SA for later fixup */
	eh = (struct ether_header*) PKTDATA(osh, sdu);
	bcopy((char*)eh->ether_dhost, &da, ETHER_ADDR_LEN);
	bcopy((char*)eh->ether_shost, &sa, ETHER_ADDR_LEN);

	/* strip off ether header, copy cached tx header onto the front of the frame */
	PKTPULL(osh, sdu, ETHER_HDR_LEN);
	txh = (d11txh_t*) PKTPUSH(osh, sdu, txc->txhlen);
	bcopy(txc->txh, (char*)txh, txc->txhlen);

	/* txc_hit doesn't check DA,SA, fixup is needed for different configs */
	h = (struct dot11_header*) (((char*)txh) + D11_TXH_LEN + D11_PHY_HDR_LEN);

	if (!bsscfg->BSS) {
		/* IBSS, no need to fixup BSSID */
	} else if (SCB_WDS(scb)) {
		/* wds: fixup a3 with DA, a4 with SA */
		ASSERT((ltoh16(h->fc) & (FC_TODS | FC_FROMDS)) == (FC_TODS | FC_FROMDS));
		bcopy((char*)&da, (char*)&h->a3, ETHER_ADDR_LEN);
		bcopy((char*)&sa, (char*)&h->a4, ETHER_ADDR_LEN);
	} else if (BSSCFG_STA(bsscfg)) {
		/* normal STA to AP, fixup a3 with DA */
		bcopy((char*)&da, (char*)&h->a3, ETHER_ADDR_LEN);
	} else {
		/* normal AP to normal STA, fixup a3 with SA */
		bcopy((char*)&sa, (char*)&h->a3, ETHER_ADDR_LEN);
	}

	/* fixup counter in TxFrameID */
	fifo = ltoh16(txh->TxFrameID) & TXFID_QUEUE_MASK;
	if (fifo == TX_BCMC_FIFO) {
		frameid = bcmc_fid_generate(wlc, bsscfg, txh);
	} else {
		frameid = ltoh16(txh->TxFrameID) & ~TXFID_SEQ_MASK;
		seq = (wlc->counter++ << SEQNUM_SHIFT) << TXFID_SEQ_SHIFT;
		frameid |= (seq & TXFID_SEQ_MASK);
	}
	txh->TxFrameID = htol16(frameid);

	/* fix up the seqnum in the hdr */
	if (WLPKTFLAG_AMPDU(pkttag)) {
		seq = pkttag->seq << SEQNUM_SHIFT;
		h->seq = htol16(seq);
	}
	else if (!(ltoh16(txh->MacTxControlLow) & TXC_HWSEQ)) {
		seq = SCB_SEQNUM(scb, PKTPRIO(sdu)) << SEQNUM_SHIFT;
		SCB_SEQNUM(scb, PKTPRIO(sdu))++;
		h->seq = htol16(seq);
	}

	/* Update timestamp */
	if ((pkttag->flags & WLF_EXPTIME)) {
		txh->TstampLow = htol16(pkttag->exptime & 0xffff);
		txh->TstampHigh = htol16((pkttag->exptime >> 16) & 0xffff);
		txh->MacTxControlLow |= htol16(TXC_LIFETIME);
	}

#ifdef STA
	if (BSSCFG_STA(bsscfg))
		wlc_pm_tx_upd(wlc, bsscfg, scb, WLPKTFLAG_DPT(pkttag), txc->fifo, txc->prio);
#endif /* STA */

	if (CAC_ENAB(wlc->pub) && fifo <= TX_AC_VO_FIFO) {
		/* update cac used time with cached value */
		if (wlc_cac_update_used_time(wlc->cac, wme_fifo2ac[fifo], -1, scb))
			WL_ERROR(("wl%d: ac %d: txop exceeded allocated TS time\n",
			          wlc->pub->unit, wme_fifo2ac[fifo]));
	}


	if (BSSCFG_AP(bsscfg) && SCB_PS(scb) && (txc->fifo != TX_BCMC_FIFO)) {
		if (AC_BITMAP_TST(scb->apsd.ac_delv, wme_fifo2ac[txc->fifo]))
			wlc_apps_apsd_prepare(wlc, scb, sdu, h, TRUE);
		else
			wlc_apps_pspoll_resp_prepare(wlc, scb, sdu, h, TRUE);
	}

	/* retrieve the saved flags */
	pkttag->flags |= txc->flags;

	/* (bsscfg specific): Add one more entry of the current rate to keep an accurate histogram.
	 * If the rate changed, we wouldn't be in the fastpath
	*/
	if (!bsscfg->txrspecidx) {
		bsscfg->txrspec[bsscfg->txrspecidx][0] = bsscfg->txrspec[NTXRATE-1][0]; /* rspec */
		bsscfg->txrspec[bsscfg->txrspecidx][1] = bsscfg->txrspec[NTXRATE-1][1]; /* nfrags */
	} else {
		bsscfg->txrspec[bsscfg->txrspecidx][0] = bsscfg->txrspec[bsscfg->txrspecidx - 1][0];
		bsscfg->txrspec[bsscfg->txrspecidx][1] = bsscfg->txrspec[bsscfg->txrspecidx - 1][1];
	}

	bsscfg->txrspecidx = (bsscfg->txrspecidx+1) % NTXRATE;
}


void BCMFASTPATH
wlc_txfifo(wlc_info_t *wlc, uint fifo, void *p, bool commit, int8 txpktpend)
{
	uint16 frameid = INVALIDFID;
	d11txh_t *txh;
	wlc_pkttag_t *pkttag;

	txh = (d11txh_t *)PKTDATA(wlc->osh, p);
	pkttag = WLPKTTAG(p);

	if ((pkttag->flags & WLF_EXPTIME)) {
		uint32 exptime = pkttag->exptime;

		txh->TstampLow = htol16(exptime & 0xffff);
		txh->TstampHigh = htol16((exptime >> 16) & 0xffff);
		txh->MacTxControlLow |= htol16(TXC_LIFETIME);
	}

#ifdef WLPKTDLYSTAT
	/* Save the packet enqueue time (for latency calculations) */
	if (pkttag->shared.enqtime == 0)
		pkttag->shared.enqtime = WLC_GET_CURR_TIME(wlc);
#endif


	/* Packet has been accepted for transmission, so clear scb pointer */
#ifndef WL_MULTIQUEUE
	/* leave the scb pointer if we need to recover packets from the queue for multiqueue */
	WLPKTTAGSCBCLR(p);
#endif
	/* When a BC/MC frame is being committed to the BCMC fifo via DMA (NOT PIO), update
	 * ucode or BSS info as appropriate.
	 */
	if (fifo == TX_BCMC_FIFO) {
		frameid = ltoh16(txh->TxFrameID);

#if defined(MBSS)
		/* For MBSS mode, keep track of the last bcmc FID in the bsscfg info.
		 * A snapshot of the FIDs for each BSS will be committed to shared memory
		 * at DTIM.
		 */
		if (MBSS_ENAB(wlc->pub)) {
			wlc_bsscfg_t *bsscfg;
			bsscfg = wlc->bsscfg[WLPKTTAGBSSCFGGET(p)];
			ASSERT(bsscfg != NULL);
			bsscfg->bcmc_fid = frameid;
			bsscfg->mc_fifo_pkts++;
#if defined(WLCNT)
			if (bsscfg->mc_fifo_pkts > bsscfg->cnt->mc_fifo_max) {
				bsscfg->cnt->mc_fifo_max = bsscfg->mc_fifo_pkts;
			}
			bsscfg->cnt->bcmc_count++;
#endif
			/* invalidate frameid so wlc_bmac_txfifo() does not commit to
			 * the non-MBSS BCMCFID location
			 */
			frameid = INVALIDFID;
		}
#endif /* MBSS */
	}

	if (WLC_WAR16165(wlc))
		wlc_war16165(wlc, TRUE);

#ifdef WLC_HIGH_ONLY
	if (RPCTX_ENAB(wlc->pub)) {
		WL_PRHDRS(wlc, __FUNCTION__, PKTDATA(wlc->osh, p) + sizeof(d11txh_t),
		          (d11txh_t *)PKTDATA(wlc->osh, p), NULL, PKTLEN(wlc->osh, p)
		          - sizeof(d11txh_t));
		(void) wlc_rpctx_tx(wlc->rpctx, fifo, p, commit, frameid, txpktpend);
		return;
	}
#else

	/* Bump up pending count for if not using rpc. If rpc is used, this will be handled
	 * in wlc_bmac_txfifo()
	 */
	if (commit) {
		TXPKTPENDINC(wlc, fifo, txpktpend);
		WL_TRACE(("wlc_txfifo, pktpend inc %d to %d\n", txpktpend,
			TXPKTPENDGET(wlc, fifo)));
	}

	/* Commit BCMC sequence number in the SHM frame ID location */
	if (frameid != INVALIDFID)
		BCMCFID(wlc, frameid);

	if (!PIO_ENAB(wlc->pub)) {
		if (dma_txfast(wlc->hw->di[fifo], p, commit) < 0) {
			WL_ERROR(("%s: fatal, toss frames !!!\n", __FUNCTION__));
			if (commit)
				TXPKTPENDDEC(wlc, fifo, txpktpend);
		} else {
			PKTDBG_TRACE(wlc->osh, p, PKTLIST_DMAQ);
		}
	} else
		wlc_pio_tx(wlc->hw->pio[fifo], p);

	if (STA_ONLY(wlc->pub) && BCM4331_CHIP_ID == CHIPID(wlc->pub->sih->chip)) {
		(void)R_REG(wlc->osh, &wlc->regs->maccontrol);
	}
#endif /* WLC_HIGH_ONLY */
}

/* get original etype for converted ether frame or 8023 frame */
uint16
wlc_sdu_etype(wlc_info_t *wlc, void *sdu)
{
	uint16 etype;
	struct ether_header *eh;

	eh = (struct ether_header*) PKTDATA(wlc->osh, sdu);
	if (WLPKTTAG(sdu)->flags & WLF_NON8023) {
		/* ether and llc/snap are in one continuous buffer */
		etype = *(uint16 *)((uint8*)eh + ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN - 2);
		ASSERT(ntoh16(etype) > ETHER_MAX_DATA);
	} else {
		etype = eh->ether_type;
	}

	return etype;
}

/* get data/body pointer from 8023 frame(original or converted) */
uint8 *
wlc_sdu_data(wlc_info_t *wlc, void *sdu)
{
	uint body_offset;
	uint hdrlen;
	osl_t *osh;

	osh = wlc->osh;

	body_offset = ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN;

	/* handle chained hdr buffer and data buffer */
	hdrlen = PKTLEN(osh, sdu);
	if (body_offset >= hdrlen)
		return ((uint8*)PKTDATA(osh, PKTNEXT(osh, sdu)) + (body_offset - hdrlen));
	else
		return ((uint8*)PKTDATA(osh, sdu) + body_offset);
}

#if defined(MBSS)
/*
 * Return true if packet got enqueued in BCMC PS packet queue.
 * This happens when the BSS is in transition from ON to OFF.
 * Called in prep_pdu and prep_sdu.
 */
static bool
bcmc_pkt_q_check(wlc_info_t *wlc, struct scb *bcmc_scb, wlc_pkt_t pkt)
{
	if (!MBSS_ENAB(wlc->pub) || !SCB_PS(bcmc_scb) ||
		!(bcmc_scb->bsscfg->flags & WLC_BSSCFG_PS_OFF_TRANS)) {
		/* No need to enqueue pkt to PS queue */
		return FALSE;
	}

	/* BSS is in PS transition from ON to OFF; Enqueue frame on SCB's PSQ */
	if (wlc_apps_bcmc_ps_enqueue(wlc, bcmc_scb, pkt) < 0) {
		WL_PS(("wl%d: Failed to enqueue BC/MC pkt for BSS %d\n",
			wlc->pub->unit, WLC_BSSCFG_IDX(bcmc_scb->bsscfg)));
		PKTFREE(wlc->osh, pkt, TRUE);
	}
	/* Force caller to give up packet and not tx */
	return TRUE;
}
#else
#define bcmc_pkt_q_check(wlc, bcmc_scb, pkt) FALSE
#endif /* MBSS */

/*
 * Common transmit packet routine
 * Return 0 when a packet is accepted and should not be referenced again
 * by the caller -- wlc will free it.
 * Return an error code when we're flow-controlled and the caller should try again later..
 */

int BCMFASTPATH
wlc_prep_sdu(wlc_info_t *wlc, void **pkts, int *npkts, uint *fifop)
{
	struct scb *scb;
	uint i, j, nfrags, frag_length = 0, next_payload_len, fifo;
	void *sdu;
	uint offset;
	osl_t *osh;
	uint headroom, want_tailroom;
	wsec_key_t *key;
	uint pkt_length;
	uint8 prio = 0;
	struct ether_header *eh;
	bool is_8021x;
#ifdef BCMWAPI_WAI
	uint32 is_wai;
#endif /* BCMWAPI_WAI */
	bool fast_path;
	wlc_bsscfg_t *bsscfg;
	wlc_pkttag_t *pkttag;
#if defined(BCMDBG_ERR) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif
	bool is_tkip = FALSE;
	bool ext_tkip = FALSE;
#ifdef STA
	bool is_4way_m4 = FALSE;
#endif /* STA */
	txc_t *txc = NULL;

	/* Make sure that we are passed in an SDU */
	sdu = pkts[0];
	ASSERT(sdu != NULL);
	pkttag = WLPKTTAG(sdu);
	ASSERT(pkttag != NULL);

	ASSERT((pkttag->flags & WLF_MPDU) == 0);

	if (!wlc->pub->up) {
		WL_INFORM(("wl%d: wlc_prep_sdu: wl is not up\n", wlc->pub->unit));
		WLCNTINCR(wlc->pub->_cnt->txnoassoc);
		goto toss;
	}

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return (wlc_prep_80211sdu(wlc, pkts, npkts, fifop));
#endif

	/* Something is blocking data packets */
	if (wlc->block_datafifo)
		return BCME_BUSY;

	osh = wlc->osh;

	is_8021x = (WLPKTTAG(sdu)->flags & WLF_8021X);
#ifdef BCMWAPI_WAI
	is_wai = (WLPKTTAG(sdu)->flags & WLF_WAI);
#endif /* BCMWAPI_WAI */


	scb = WLPKTTAGSCBGET(sdu);
	ASSERT(scb != NULL);

	if (SCB_ISMULTI(scb) && bcmc_pkt_q_check(wlc, scb, sdu)) {
		/* Does BCMC pkt need to go to BSS's PS queue? */
		/* Force caller to give up packet and not tx */
		return BCME_NOTREADY;
	}

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	WL_APSTA_TX(("wl%d.%d: wlc_prep_sdu: pkt %p dst %s\n", wlc->pub->unit,
	             WLC_BSSCFG_IDX(bsscfg), sdu,
	             bcm_ether_ntoa(&scb->ea, eabuf)));

	/* toss if station is not associated to the correct bsscfg */
	if (bsscfg->BSS && !SCB_WDS(scb) && !SCB_ISMULTI(scb)) {
		/* Class 3 (BSS) frame */
		if (!SCB_ASSOCIATED(scb)) {
			WL_INFORM(("wl%d.%d: wlc_prep_sdu: invalid class 3 frame to "
				   "non-associated station %s\n", wlc->pub->unit,
				    WLC_BSSCFG_IDX(bsscfg), bcm_ether_ntoa(&scb->ea, eabuf)));
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
	}
#ifdef WLBTAMP
	else if (BSS_BTA_ENAB(wlc, bsscfg)) {
		/* Class 4 (BT-AMP) frame */
		if (!SCB_ASSOCIATED(scb)) {
			WL_INFORM(("wl%d.%d: wlc_prep_sdu: invalid frame to "
				   "non-associated BT-AMP peer %s\n", wlc->pub->unit,
				    WLC_BSSCFG_IDX(bsscfg), bcm_ether_ntoa(&scb->ea, eabuf)));
			WLCNTINCR(wlc->pub->_cnt->txnoassoc);
			goto toss;
		}
	}
#endif /* WLBTAMP */

	/* Toss the frame if scb's band does not match our current band
	 * this is possible if the STA has roam'ed while the packet was on txq
	 */
	if (scb->bandunit != CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec)) {
		WL_INFORM(("wl%d.%d: frame destined to %s sent on incorrect band %d\n",
		           wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), bcm_ether_ntoa(&scb->ea, eabuf),
		           scb->bandunit));
		WLCNTINCR(wlc->pub->_cnt->txnoassoc);
		goto toss;
	}

	/*
	 * On the AP, bcast/mcast always goes through the bcmc fifo if bcmc_scb is in PS Mode.
	 * bcmc_scb is in PS Mode if at least one ucast STA is in PS.  SDUs are data
	 * packets and always go in BE_FIFO unless WME is enabled.
	 *
	 * Default prio has to be 0 for TKIP MIC calculation when sending packet on a non-WME
	 * link, as the receiving end uses prio of 0 for MIC calculation when QoS header
	 * is absent from the packet.
	 */

	prio = 0;
	if (SCB_QOS(scb)) {
		prio = (uint8)PKTPRIO(sdu);
		ASSERT(prio <= MAXPRIO);
	}

	fifo = TX_AC_BE_FIFO;

	if (BSSCFG_AP(bsscfg) && SCB_ISMULTI(scb) && WLC_BCMC_PSMODE(wlc, bsscfg)) {
		fifo = TX_BCMC_FIFO;
#ifdef WLBTAMP
	} else if (SCB_11E(scb)) {
		fifo = prio2fifo[prio];
#endif /* WLBTAMP */
	} else if (SCB_WME(scb)) {
		fifo = prio2fifo[prio];

#ifdef	WME
		if (wlc_wme_downgrade_fifo(wlc, &fifo, scb) == BCME_ERROR)
			goto toss;
#endif /* WME */

	}

	*fifop = fifo;

	/*
	 * Apply FIFO admission control to reduce "rate lag"
	 * by limiting the amount of data queued to the hardware.
	 */
	if ((TXPKTPENDGET(wlc, fifo) >= wlc->pub->txmaxpkts) && (fifo <= TX_AC_VO_FIFO)) {
		/* Mark precedences related to this FIFO, unsendable */
		WLC_TX_FIFO_CLEAR(wlc, fifo);
		return BCME_BUSY;
	}

	if ((fifo == TX_BCMC_FIFO) &&
		(TXPKTPENDGET(wlc, fifo) >= TXFID_MAX_BCMC_FID)) {
		WLC_TX_FIFO_CLEAR(wlc, fifo);
		return BCME_BUSY;
	}

	/* toss runt frames */
	pkt_length = pkttotlen(osh, sdu);
	if (pkt_length < ETHER_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN) {
		WLCNTINCR(wlc->pub->_cnt->txrunt);
		WLCIFCNTINCR(scb, txrunt);
		goto toss;
	}

	/* check enough headroom has been reserved */
	/* uncomment after fixing vx port
	 * ASSERT((uint)PKTHEADROOM(osh, sdu) < (D11_TXH_LEN + D11_PHY_HDR_LEN));
	 */
		eh = (struct ether_header*) PKTDATA(osh, sdu);


	if (BSSCFG_AP(bsscfg) && !SCB_WDS(scb)) {
		/* Check if this is a packet indicating a STA roam and remove assoc state if so.
		 * Only check if we are getting the send on a non-wds link so that we do not
		 * process our own roam/assoc-indication packets
		 */
		if (ETHER_ISMULTI(eh->ether_dhost))
			if (wlc_roam_check(wlc->ap, bsscfg, eh, pkt_length))
				goto toss;
	}

	/* toss if station not yet authorized to receive non-802.1X frames */
	if (bsscfg->eap_restrict && !SCB_ISMULTI(scb) && !SCB_AUTHORIZED(scb)) {
		if (!is_8021x) {
			WL_ERROR(("wl%d.%d: non-802.1X frame to unauthorized station %s\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg),
			          bcm_ether_ntoa(&scb->ea, eabuf)));
			goto toss;
		}
	}

#ifdef BCMWAPI_WAI
	/* toss if station not yet authorized to receive non-WAI frames */
	if (bsscfg->wai_restrict && !SCB_ISMULTI(scb) && !SCB_AUTHORIZED(scb)) {
		if (!is_wai) {
			WL_ERROR(("wl%d.%d: non-WAI frame len %d to unauthorized station %s\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), pkt_length,
				bcm_ether_ntoa(&scb->ea, eabuf)));
			goto toss;
		}
	}
#endif /* BCMWAPI_WAI */

	WL_PRUSR("tx", (uchar*)eh, ETHER_HDR_LEN);

	key = NULL;
	if (WSEC_ENABLED(bsscfg->wsec) && !BSSCFG_SAFEMODE(bsscfg)) {
	{
		if (is_8021x) {
			/*
			* use per scb WPA_auth to handle 802.1x frames differently
			* in WPA/802.1x mixed mode when having a pairwise key:
			*  - 802.1x frames are unencrypted in plain 802.1x mode
			*  - 802.1x frames are encrypted in WPA mode
			*/
			uint16 WPA_auth = SCB_WDS(scb) ? bsscfg->WPA_auth : scb->WPA_auth;

			if ((WPA_auth != WPA_AUTH_DISABLED) &&
			    (WSEC_SCB_KEY_VALID(scb))) {
				WL_WSEC(("wl%d.%d: wlc_prep_sdu: encrypting 802.1X frame using "
					"per-path key\n", wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				key = scb->key;
			} else {
				/* Do not encrypt 802.1X packets with group keys */
				WL_WSEC(("wl%d.%d: wlc_prep_sdu: not encrypting 802.1x frame\n",
					wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				key = NULL;
			}
		}
#ifdef BCMWAPI_WAI
		else if (is_wai) {
			/* Do not encrypt WAI packets with group keys */
			WL_WSEC(("wl%d.%d: wlc_prep_sdu: not encrypting WAI frame\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
			key = NULL;
		}
#endif /* BCMWAPI_WAI */
		else {
			/* Use a paired key or primary group key if present, toss otherwise */
			if (scb->key) {
				key = scb->key;
				WL_WSEC(("wl%d.%d: wlc_prep_sdu: using per-path key algo %d\n",
					wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), key->algo));
			} else if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
				WL_WSEC(("wl%d.%d: wlc_prep_sdu: using group key index %d "
				         "ID %d algo %d\n",
				         wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg),
				         bsscfg->wsec_index, key->id, key->algo));
			} else {
				WL_WSEC(("wl%d.%d: wlc_prep_sdu: tossing unencryptable frame\n",
					wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				goto toss;
			}
		}
	}
	} else {	/* Do not encrypt packet */
		WL_WSEC(("wl%d.%d: wlc_prep_sdu: not encrypting frame, encryption disabled\n",
			wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
		WL_WSEC(("wl%d.%d: wlc_prep_sdu: wsec 0x%x \n", wlc->pub->unit,
			WLC_BSSCFG_IDX(bsscfg), bsscfg->wsec));
		key = NULL;
	}

#ifdef STA
	if (BSSCFG_WSEC_BUF_KEY_B4_M4(bsscfg) && is_8021x && !BSSCFG_SAFEMODE(bsscfg)) {
		if (wlc_is_4way_msg(wlc, sdu, ETHER_HDR_LEN, PMSG4)) {
			WL_WSEC(("wl%d:%s(): Tx 4-way M4 pkt...\n", wlc->pub->unit, __FUNCTION__));
			is_4way_m4 = TRUE;
		}
	}
#endif /* STA */

	if (key) {

		/* TKIP MIC space reservation */
		if (key->algo == CRYPTO_ALGO_TKIP) {
			is_tkip = TRUE;
			pkt_length += TKIP_MIC_SIZE;
			WL_WSEC(("wl%d.%d: %s: pkt_length after adding TKIP_MIC_SIZE is %d\n",
			         wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__, pkt_length));
#ifdef LINUX_CRYPTO
			ext_tkip = TRUE;
#endif
		}
	}

	/* calculate how many frags needed
	 *  ETHER_HDR - (CKIP_LLC_MIC) - LLC/SNAP-ETHER_TYPE - payload - TKIP_MIC
	 */
	if (!WLPKTFLAG_AMSDU(pkttag) && !WLPKTFLAG_AMPDU(pkttag) && !BSSCFG_SAFEMODE(bsscfg))
		nfrags = wlc_frag(wlc, scb, fifo, pkt_length, &frag_length);
	else {
		frag_length = pkt_length - ETHER_HDR_LEN;
		nfrags = 1;
	}
	if (!PIO_ENAB(wlc->pub)) {
		uint max_nsegs = MAX_DMA_SEGS;
		if (BCM4331_CHIP_ID == CHIPID(wlc->pub->sih->chip))
			max_nsegs *= 2;
		/* bail if there is insufficient room in the ring to hold all fragments */
		if (TXAVAIL(wlc, fifo) < (nfrags * max_nsegs)) {
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}
	} else {
		uint sz;

		/* calculate required "flow-control" amount of all fragments */

		/* per frag header overhead */
		sz = D11_TXH_LEN + D11_PHY_HDR_LEN + DOT11_A3_HDR_LEN;
		/* account for A4 */
		if (SCB_WDS(scb))
			sz += ETHER_ADDR_LEN;
		/* SCB_QOS: account for QoS Control Field */
		if (SCB_QOS(scb))
			sz += DOT11_QOS_LEN;
		/* per frag encrypt overhead */
		if (key) {
			sz += key->iv_len;
			if (WSEC_SOFTKEY(wlc, key, bsscfg) || ext_tkip)
				sz += key->icv_len;
		}

		/* total frag overhead */
		sz = sz * nfrags;
		sz += pkt_length - ETHER_HDR_LEN;
		/* bail if there is insufficient room in the fifo to hold all fragments */
		if (!wlc_pio_txavailable(wlc->hw->pio[fifo], sz, nfrags)) {
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}
	}

	fast_path = (nfrags == 1);

	/*
	 * Prealloc all fragment buffers for this frame.
	 * If any of the allocs fail, free them all and bail.
	 * p->data points to ETHER_HEADER, original ether_type is passed separately
	 */
	offset = ETHER_HDR_LEN;
	for (i = 0; i < nfrags; i++) {
		headroom = TXOFF;
		want_tailroom = 0;

		if (key) {
			if (WSEC_SOFTKEY(wlc, key, bsscfg) || ext_tkip) {
				headroom += key->iv_len;
				want_tailroom += key->icv_len;
				fast_path = FALSE;		/* no fast path for SW encryption */
			}

			if (is_tkip) {
				void *p;
				p = PKTNEXT(osh, sdu);
				if ((i + 2) >= nfrags) {
					WL_WSEC(("wl%d.%d: wlc_prep_sdu: checking "
						"space for TKIP tailroom\n",
						wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
					want_tailroom += MAX(TKIP_MIC_SIZE, TKIP_EOM_SIZE);
					if (p != NULL) {
						if (PKTNEXT(osh, p))
							fast_path = FALSE;
						else if ((uint)PKTTAILROOM(osh, p) < want_tailroom)
							fast_path = FALSE;
					} else if ((uint)PKTTAILROOM(osh, sdu) < want_tailroom)
						fast_path = FALSE;
				}

				/* Cloned TKIP packets to go via the slow path so that
				 * each interface gets a private copy of data to add MIC
				 */
				if (PKTSHARED(sdu) || (p && PKTSHARED(p)))
					fast_path = FALSE;
			}
		}

		if (fast_path) {
			/* fast path for non fragmentation/non copy of pkts
			 * header buffer has been allocated in wlc_sendpkt()
			 * don't change ether_header at the front
			 */
			/* tx header cache hit */
			if (!BSSCFG_SAFEMODE(bsscfg)) {
				if (WLC_TXC_ENAB(wlc) && wlc->txc &&
				   ((txc = wlc_txc_hit(wlc, scb, sdu, pkt_length, fifo, prio))
				   != NULL)) {
					if (key) {
						wlc_txc_iv_update(wlc, bsscfg, scb, key, sdu,
							pkt_length, txc);
#ifndef LINUX_CRYPTO
						if (key->algo == CRYPTO_ALGO_TKIP)
							wlc_dofrag_tkip(wlc->pub, sdu, 0, 1, osh,
								bsscfg, scb, eh, key, prio,
								pkt_length);
#endif
					}

					wlc_txfast(wlc, scb, sdu, pkt_length, txc);
					WLCNTINCR(wlc->pub->_cnt->txchit);
					*npkts = 1;
					goto done;
				}
				WLCNTINCR(wlc->pub->_cnt->txcmiss);
			}
			ASSERT(i == 0);
			pkts[0] = sdu;

		} else {
			/* before fragmentation make sure the frame contents are valid */
			PKTCTFMAP(osh, sdu);

			/* fragmentation:
			 * realloc new buffer for each frag, copy over data,
			 * append original ether_header at the front
			 */
			pkts[i] = wlc_allocfrag(osh, sdu, offset, headroom, frag_length,
				want_tailroom);
			if (pkts[i] == NULL) {
				for (j = 0; j < i; j++)
					PKTFREE(osh, pkts[j], TRUE);
				pkts[0] = sdu;    /* restore pointer to sdu */
				WL_ERROR(("wl%d.%d: wlc_prep_sdu: allocfrag failed\n",
				          wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				WLCNTINCR(wlc->pub->_cnt->txnobuf);
				WLCIFCNTINCR(scb, txnobuf);
				return BCME_BUSY;
			} else {
#ifdef BCMWAPI_WPI
				if (key && (key->algo == CRYPTO_ALGO_SMS4) &&
					WSEC_SOFTKEY(wlc, key, bsscfg))
				{
					int cur_len = PKTLEN(wlc->osh, pkts[i]);
					PKTSETLEN(wlc->osh, pkts[i],
						cur_len + SMS4_WPI_CBC_MAC_LEN);
				}
#endif /* BCMWAPI_WPI */
				PKTPUSH(osh, pkts[i], ETHER_HDR_LEN);
				bcopy((char*)eh, (char*)PKTDATA(osh, pkts[i]), ETHER_HDR_LEN);

				/* Transfer SDU's pkttag info to the last fragment */
				if (i == (nfrags - 1))
					wlc_pkttag_info_move(wlc->pub, sdu, pkts[i]);
			}

			/* set fragment priority */
			PKTSETPRIO(pkts[i], PKTPRIO(sdu));
			/* leading frag buf must be aligned 0-mod-2 */
			ASSERT(ISALIGNED((uintptr)PKTDATA(osh, pkts[i]), 2));
			offset += frag_length;
		}
	}

#ifdef STA
	if (BSSCFG_STA(bsscfg))
		wlc_pm_tx_upd(wlc, bsscfg, scb, WLPKTFLAG_DPT(pkttag), fifo, prio);
#endif /* STA */

#ifdef WLBA
	if (SCB_BA(scb))
		wlc_ba_process_data_pkt(wlc->bastate, scb, prio, pkts, nfrags);
#endif

	/* build and transmit each fragment */
	for (i = 0; i < nfrags; i++) {
		if (i < nfrags - 1) {
			if (is_tkip) {
				next_payload_len = wlc_wsec_tkip_nextfrag_len(wlc->pub, osh,
					pkts[i], pkts[i + 1],
					frag_length + ETHER_HDR_LEN);
			} else {
				next_payload_len = pkttotlen(osh, pkts[i + 1]);
			}
			ASSERT(next_payload_len >= ETHER_HDR_LEN);
			next_payload_len -= ETHER_HDR_LEN;
		}
		else
			next_payload_len = 0;

		/* ether header is on front of each frag to provide the dhost and shost
		 *  ether_type may not be original, should not be used
		 */
		wlc_dofrag(wlc, pkts[i], i, nfrags, next_payload_len, scb,
			is_8021x, fifo, key, prio, frag_length);

		WLPKTTAGSCBSET(pkts[i], scb);
	}

	/* Free the original SDU if not shared */
	if (pkts[nfrags - 1] != sdu)
		PKTFREE(wlc->osh, sdu, TRUE);

	*npkts = nfrags;

#ifdef STA
	if (is_4way_m4)
		wlc_4way_m4_tx(wlc, bsscfg);
#endif /* STA */

done:
	WLCNTSCBINCR(scb->scb_stats.tx_pkts);
	wlc_update_txpktsuccess_stats(wlc, scb, pkt_length, prio);
	return 0;
toss:
	*npkts = 0;
	wlc_update_txpktfail_stats(wlc, pkttotlen(wlc->osh, sdu), prio);
	PKTFREE(wlc->osh, sdu, TRUE);
	return BCME_ERROR;
}


static txc_t * BCMFASTPATH
wlc_txc_hit(wlc_info_t *wlc, struct scb *scb, void *sdu, uint pktlen, uint fifo, uint8 prio)
{
	uint miss = 1;
	txc_t *txc = NULL;
	uint8 txcidx;
	wlc_bsscfg_t *bsscfg;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	if (SCB_TXC_PARAMS(wlc, scb) == NULL) {
		return NULL;
	}

	for (txcidx = 0; txcidx < MAX_TXC_ENTRIES; txcidx++) {
		if ((txc = SCB_TXC_CUBBY(wlc, scb, txcidx)) == NULL) {
			miss = 1;
			break;
		}

		miss = (txc->txhlen == 0);
		miss |= (pktlen != txc->pktlen);

		/* Do not look any further if length match fails */
		if (miss) {
			continue;
		}

		miss |= (fifo != txc->fifo);
		miss |= (prio != txc->prio);
		miss |= (txc->gen != wlc->txcgen);
		miss |= ((txc->flags & WLF_EXEMPT_MASK) !=
			(WLPKTTAG(sdu)->flags & WLF_EXEMPT_MASK));
#ifdef AP
		if (BSSCFG_AP(bsscfg))
			miss |= (txc->ps_on != SCB_PS(scb));
#endif
		if (!PIO_ENAB(wlc->pub)) {
			uint max_nsegs = MAX_DMA_SEGS;
			if (BCM4331_CHIP_ID == CHIPID(wlc->pub->sih->chip))
				max_nsegs *= 2;
			miss |= (uint)TXAVAIL(wlc, fifo) < max_nsegs;
		} else
			miss |= !wlc_pio_txavailable(wlc->hw->pio[fifo],
				(pktlen + D11_TXH_LEN + D11_PHY_HDR_LEN + DOT11_A3_HDR_LEN), 1);

		if (!miss) {
			break; /* TXH match found */
		}
	}

#if defined(BCMDBG) || defined(WLMSG_PRPKT)
	if (miss && WL_PRPKT_ON()) {
		printf("txc missed: scb %p gen %d txcgen %d hdr_len %d body len %d, pkt_len %d\n",
		        scb, txc->gen, wlc->txcgen, txc->txhlen, txc->pktlen, pktlen);
	}
#endif

	return ((miss == 0) ? (txc) : (NULL));
}

/* construct one fragment */
static void BCMFASTPATH
wlc_dofrag(wlc_info_t *wlc, void *p, uint frag, uint nfrags, uint next_payload_len,
	struct scb *scb, bool is8021x, uint fifo,
	wsec_key_t *key, uint8 prio, uint frag_length)
{
	struct ether_header *eh;
	struct dot11_header *h;
	uint next_frag_len;
	uint16 frameid;
	uint16 txc_hdr_len = 0;
	bool ext_tkip = FALSE;
	wlc_bsscfg_t *cfg;
	osl_t *osh;
	txc_t *txc = NULL;
	uint8 idx = 0;

	ASSERT(scb != NULL);

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

#ifdef BCMDBG
	{
	char eabuf[ETHER_ADDR_STR_LEN];
	WL_APSTA_TX(("wl%d.%d: wlc_dofrag: send %p to %s, cfg %p, fifo %d, frag %d, nfrags %d\n",
	             wlc->pub->unit, WLC_BSSCFG_IDX(cfg), p,
	             bcm_ether_ntoa(&scb->ea, eabuf), cfg, fifo, frag, nfrags));
	}
#endif /* BCMDBG */

	/*
	 * 802.3 (header length = 22):
	 *                     (LLC includes ether_type in last 2 bytes):
	 * ----------------------------------------------------------------------------------------
	 * |                                      |   DA   |   SA   | L | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *                                             6        6     2       6      2
	 *
	 * NON-WDS
	 *
	 * Conversion to 802.11 (header length = 32):
	 * ----------------------------------------------------------------------------------------
	 * |              | FC | D |   A1   |   A2   |   A3   | S | QoS | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *                   2   2      6        6        6     2    2        6      2
	 *
	 * Conversion to 802.11 (WEP, QoS):
	 * ----------------------------------------------------------------------------------------
	 * |         | FC | D |   A1   |   A2   |   A3   | S | QoS | IV | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *             2   2      6        6        6     2    2     4        6      2
	 *
	 * WDS
	 *
	 * Conversion to 802.11 (header length = 38):
	 * ----------------------------------------------------------------------------------------
	 * |     | FC | D |   A1   |   A2   |   A3   | S |   A4   | QoS | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *         2   2      6        6        6     2      6      2         6      2
	 *
	 * Conversion to 802.11 (WEP, QoS):
	 * ----------------------------------------------------------------------------------------
	 * | FC | D |   A1   |   A2   |   A3   | S |   A4   |  QoS | IV | LLC/SNAP | T |  Data... |
	 * ----------------------------------------------------------------------------------------
	 *    2   2      6        6        6     2      6       2    4        6      2
	 *
	 */

	osh = wlc->osh;
	eh = (struct ether_header*)PKTDATA(osh, p);

	WL_WSEC(("wl%d.%d: %s: tx sdu, len %d(with 802.3 hdr)\n",
	         wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, pkttotlen(osh, p)));

	if (key && (key->algo == CRYPTO_ALGO_TKIP)) {
		if (WSEC_HW_TKMIC_KEY(wlc, key, cfg) && (nfrags == 1))
			WL_WSEC(("wl%d.%d: %s: using hardware TKIP MIC\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__));
#ifndef LINUX_CRYPTO
		else
			wlc_dofrag_tkip(wlc->pub, p, frag, nfrags, osh, cfg, scb, eh, key,
				prio, frag_length);
#else /* LINUX_CRYPTO */
		ext_tkip = TRUE;
#endif /* LINUX_CRYPTO */
	}

	/*
	 * Convert 802.3 MAC header to 802.11 MAC header (data only)
	 * and add WEP IV information if enabled.
	 *  requires valid DA and SA, does not care ether_type
	 */
	if (!BSSCFG_SAFEMODE(cfg))
		h = wlc_80211hdr(wlc, p, scb, (bool)(frag != (nfrags - 1)),
			key, prio, &txc_hdr_len);

	WL_WSEC(("wl%d.%d: %s: tx sdu, len %d(w 80211hdr and iv, no d11hdr, icv and fcs)\n",
	         wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, pkttotlen(osh, p)));
#ifdef LINUX_CRYPTO
	/* external supplicant require 802.11 hdr formed before adding mic */
	if (key && ext_tkip)
		wl_tkip_micadd(wlc->wl, p, txc_hdr_len); /* Fix the Header Len */
#endif /* LINUX_CRYPTO */

	/* determine total MPDU length of next frag */
	next_frag_len = next_payload_len;
	if (next_frag_len > 0) {	/* there is a following frag */
		next_frag_len += DOT11_A3_HDR_LEN + DOT11_FCS_LEN;
		/* A4 header */
		if (SCB_WDS(scb))
			next_frag_len += ETHER_ADDR_LEN;
		/* SCB_QOS: account for QoS Control Field */
		if (SCB_QOS(scb))
			next_frag_len += DOT11_QOS_LEN;
		if (key && !ext_tkip)
			next_frag_len += key->iv_len + key->icv_len;
	}

	/* add d11 headers */
	frameid = wlc_d11hdrs(wlc, p, scb,
	        (cfg->prot_cfg->shortpreamble && (scb->flags & SCB_SHORTPREAMBLE) != 0),
		frag, nfrags, fifo, next_frag_len, key, 0);

	txc_hdr_len += D11_PHY_HDR_LEN + D11_TXH_LEN;

#ifdef STA
	if (cfg->tk_cm_activate && next_frag_len == 0 && is8021x) {
		WL_WSEC(("wl%d.%d: %s: TKIP countermeasures: sending MIC failure"
		         " report...\n", wlc->pub->unit,
		         WLC_BSSCFG_IDX(cfg), __FUNCTION__));

		if (frameid == 0xffff) {
			WL_ERROR(("wl%d.%d: %s: could not register MIC failure packet"
			          " callback\n", wlc->pub->unit, WLC_BSSCFG_IDX(cfg),
			          __FUNCTION__));
		}
		else
			WLPKTFLAG2_TYPESET(p, WLF2_TYPE_TKIP_CM);

		cfg->tk_cm_activate = FALSE;
	}
#endif /* STA */

	/* 802.3 header needs to be included in WEP-encrypted portion of frame, and
	 * we need the IV info in the frame, so we're forced to do WEP here
	 */
#ifdef LINUX_CRYPTO
	if (key && ext_tkip) {
		int hdr_len = DOT11_A3_HDR_LEN;
		if (SCB_QOS(scb))
			hdr_len += DOT11_QOS_LEN;
		/* pull the frame such that the data points at Dot11 Header field now */
		switch (key->algo) {
			case CRYPTO_ALGO_TKIP:
				PKTPULL(osh, p, D11_PHY_HDR_LEN + D11_TXH_LEN + 8);
				wl_tkip_encrypt(wlc->wl, p, hdr_len); /* Fix the Header Len */
				PKTPUSH(osh, p, D11_PHY_HDR_LEN + D11_TXH_LEN);
				break;
			default:
				WL_WSEC(("wl%d: %s: unsupported algorithm %d\n",
					wlc->pub->unit, __FUNCTION__, key->algo));
		}
	}
#else /* LINUX_CRYPTO */
	if (key && (WSEC_SOFTKEY(wlc, key, cfg) || WLPKTFLAG_PMF(WLPKTTAG(p)))) {
		if (!wlc_wsec_sw_encrypt_data(wlc, osh, p, cfg, scb, key))
			WL_WSEC(("wl%d: %s: wlc_wsec_sw_encrypt_data error\n",
			         wlc->pub->unit, __FUNCTION__));
	}
#endif /* LINUXCRYPTO */

	if (BSSCFG_AP(cfg)) {
		/* Processing to set MoreData when needed */
		if (fifo != TX_BCMC_FIFO) {
			/* Check if packet is being sent to STA in PS mode */
			if (SCB_PS(scb)) {
				bool last_frag;

				last_frag = (frag == nfrags - 1);
				/* Make preparations for APSD delivery frame or PS-Poll response */
				if (AC_BITMAP_TST(scb->apsd.ac_delv, wme_fifo2ac[fifo]))
					wlc_apps_apsd_prepare(wlc, scb, p, h, last_frag);
				else
					wlc_apps_pspoll_resp_prepare(wlc, scb, p, h, last_frag);
			}
		} else {
			/* The uCode clears the MoreData field of the last bcmc pkt per dtim period
			 */
			/* Suppress setting MoreData if we have to support legacy AES.
			 * This should probably also be conditional on at least one legacy
			 * STA associated
			 */
			/*
			* Note: We currently use global WPA_auth for WDS and per scb WPA_auth
			* for others, but fortunately there is no bcmc frames over WDS link
			* therefore we don't need to worry about WDS and it is safe to use per
			* scb WPA_auth only here!
			*/
			/* Also look at wlc_apps_ps_prep_mpdu if following condition ever changes */
			if (!IS_WPA_AUTH(cfg->WPA_auth) ||
				((key = WSEC_BSS_DEFAULT_KEY(cfg)) == NULL) ||
				(key->algo != CRYPTO_ALGO_AES_CCM))
					h->fc |= htol16(FC_MOREDATA);
		}
	}


	/* install new header into tx header cache: starting from the bytes after DA-SA-L  */
	if (WLC_TXC_ENAB(wlc) && wlc->txc && (nfrags == 1) &&
	   (SCB_TXC_PARAMS(wlc, scb) != NULL) && !BSSCFG_SAFEMODE(cfg)) {

		/* Get available index to use */
		idx = wlc_txc_get_avail_idx(wlc, scb);

		if ((txc = SCB_TXC_CUBBY(wlc, scb, idx)) != NULL) {
			/* cache any pkt with same DA-SA-L(before LLC/SNAP), 
			 * hdr must be in one buffer
			*/
			txc->txhlen = txc_hdr_len;
			bcopy(PKTDATA(osh, p), txc->txh, txc_hdr_len);
			txc->pktlen = pkttotlen(osh, p) - txc_hdr_len + ETHER_HDR_LEN;
			txc->fifo = fifo;
			txc->prio = prio;
			txc->gen = wlc->txcgen;
#ifdef AP
			if (BSSCFG_AP(cfg))
				txc->ps_on = SCB_PS(scb);
#endif

			/* need MPDU flag to avoid going back to prep_sdu */
			txc->flags = (WLF_MPDU | WLF_TXHDR | (WLPKTTAG(p)->flags & (WLF_MIMO |
			             WLF_VRATE_PROBE | WLF_RATE_AUTO |
			             WLF_RIFS | WLF_WME_NOACK | WLF_EXEMPT_MASK)));

			/* Clear pkt exptime from the txheader cache */
			((d11txh_t *)txc->txh)->MacTxControlLow &= htol16(~TXC_LIFETIME);

#if defined(BCMDBG) || defined(WLMSG_PRPKT)
			if (WL_PRPKT_ON())
				printf("install txc: scb %p gen %d hdr_len %d, body len %d\n", scb,
					txc->gen, txc->txhlen, txc->pktlen);
#endif
			wlc_txc_upd_avail_idx(wlc, scb);
	    }
	}
}

static bool
sstlookup(wlc_info_t *wlc, uint16 proto)
{
	return (proto == 0x80f3 || proto == 0x8137);
}

/* Convert Ethernet to 802.3 per 802.1H (use bridge-tunnel if type in SST) */
void
wlc_ether_8023hdr(wlc_info_t *wlc, osl_t *osh, struct ether_header *eh, void *p)
{
	struct ether_header *neh;
	struct dot11_llc_snap_header *lsh;
	uint16 plen, ether_type;

	ether_type = ntoh16(eh->ether_type);
	neh = (struct ether_header *)PKTPUSH(osh, p, DOT11_LLC_SNAP_HDR_LEN);

	/* 802.3 MAC header */
	bcopy((char*)eh->ether_dhost, (char*)neh->ether_dhost, ETHER_ADDR_LEN);
	bcopy((char*)eh->ether_shost, (char*)neh->ether_shost, ETHER_ADDR_LEN);
	plen = (uint16)pkttotlen(osh, p) - ETHER_HDR_LEN;
	neh->ether_type = hton16(plen);

	/* 802.2 LLC header */
	lsh = (struct dot11_llc_snap_header *)&neh[1];
	lsh->dsap = 0xaa;
	lsh->ssap = 0xaa;
	lsh->ctl = 0x03;

	/* 802.2 SNAP header Use RFC1042 or bridge-tunnel if type in SST per 802.1H */
	lsh->oui[0] = 0x00;
	lsh->oui[1] = 0x00;
	if (sstlookup(wlc, ether_type))
		lsh->oui[2] = 0xf8;
	else
		lsh->oui[2] = 0x00;
	lsh->type = hton16(ether_type);
}

/* Convert 802.3 back to ethernet per 802.1H (use bridge-tunnel if type in SST) */
void BCMFASTPATH
wlc_8023_etherhdr(wlc_info_t *wlc, osl_t *osh, void *p)
{
	struct ether_header *neh, *eh;
	struct dot11_llc_snap_header *lsh;
	bool isrfc894;

	if (PKTLEN(osh, p) < DOT11_LLC_SNAP_HDR_LEN)
		return;

	eh = (struct ether_header *) PKTDATA(osh, p);

	/*
	 * check conversion is necessary
	 * - if ([AA AA 03 00 00 00] and protocol is not in SST) or
	 *   if ([AA AA 03 00 00 F8] and protocol is in SST), convert to RFC894
	 * - otherwise,
	 *	 preserve 802.3 (including RFC1042 with protocol in SST)
	 */
	lsh = (struct dot11_llc_snap_header *)((uint8 *)eh + ETHER_HDR_LEN);
	isrfc894 = (lsh->dsap == 0xaa &&
	            lsh->ssap == 0xaa &&
	            lsh->ctl  == 0x03 &&
	            lsh->oui[0] == 0x00 &&
	            lsh->oui[1] == 0x00 &&
	            ((lsh->oui[2] == 0x00 && !sstlookup(wlc, ntoh16(lsh->type))) ||
	             (lsh->oui[2] == 0xf8 && sstlookup(wlc, ntoh16(lsh->type)))));

	/* if it was not converted in transmitter, no need to convert it back at here receiver */
	if (!isrfc894)
		return;

	/* 802.3 MAC header */
	neh = (struct ether_header *) PKTPULL(osh, p, DOT11_LLC_SNAP_HDR_LEN);
	bcopy((char*)eh->ether_shost, (char*)neh->ether_shost, ETHER_ADDR_LEN);
	bcopy((char*)eh->ether_dhost, (char*)neh->ether_dhost, ETHER_ADDR_LEN);

	/* no change to the ether_type field */

	return;
}

/*
 * Convert 802.3 MAC header to 802.11 MAC header (data only)
 * and add WEP IV information if enabled.
 */
static struct dot11_header * BCMFASTPATH
wlc_80211hdr(wlc_info_t *wlc, void *p, struct scb *scb,
	bool MoreFrag, wsec_key_t *key, uint8 prio, uint16 *pushlen)
{
	struct ether_header *eh;
	struct dot11_header *h;
	struct ether_addr tmpaddr;
	uchar *iv_data;
	uint16 offset;
	struct ether_addr *ra;
	wlc_pkttag_t *pkttag;
	bool wds;
	bool ext_tkip = FALSE;
	osl_t *osh;
	wlc_bsscfg_t *bsscfg;
	uint16 fc = 0;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	wds = (SCB_WDS(scb) != 0);
	ra = (wds ? &scb->ea : NULL);
	pkttag = WLPKTTAG(p);

	osh = wlc->osh;
	/* convert 802.3 header to 802.11 header */
	eh = (struct ether_header *) PKTDATA(osh, p);
	/* Make room for 802.11 header, add additional bytes if WEP enabled for IV */
	offset = DOT11_A3_HDR_LEN - ETHER_HDR_LEN;
	if (wds)
		offset += ETHER_ADDR_LEN;
	if (SCB_QOS(scb))
		offset += DOT11_QOS_LEN;

#ifdef LINUX_CRYPTO
	if (key && (key->algo == CRYPTO_ALGO_TKIP))
		ext_tkip = TRUE;
#endif /* LINUX_CRYPTO */
	if (key && !ext_tkip)
		offset += key->iv_len;
	h = (struct dot11_header *) PKTPUSH(osh, p, offset);
	bzero((char*)h, offset);

	*pushlen = offset + ETHER_HDR_LEN;

	if (wds) {
		ASSERT(ra != NULL);
		/* WDS: a1 = RA, a2 = TA, a3 = DA, a4 = SA, ToDS = 0, FromDS = 1 */
		bcopy((char*)ra, (char*)&h->a1, ETHER_ADDR_LEN);
		bcopy((char*)&bsscfg->cur_etheraddr, (char*)&h->a2, ETHER_ADDR_LEN);
		/* eh->ether_dhost and h->a3 may overlap */
		if (key || SCB_QOS(scb)) {
			/* In WEP case, &h->a3 + 4 = &eh->ether_dhost due to IV offset, thus
			 * need to bcopy
			 */
			bcopy((char*)&eh->ether_dhost, (char*)&tmpaddr, ETHER_ADDR_LEN);
			bcopy((char*)&tmpaddr, (char*)&h->a3, ETHER_ADDR_LEN);
		}
		/* eh->ether_shost and h->a4 may overlap */
		bcopy((char*)&eh->ether_shost, (char*)&tmpaddr, ETHER_ADDR_LEN);
		bcopy((char*)&tmpaddr, (char*)&h->a4, ETHER_ADDR_LEN);
		fc |= FC_TODS | FC_FROMDS;

		/* A-MSDU: use BSSID for A3 and A4, only need to fix up A3 */
		if (WLPKTFLAG_AMSDU(pkttag))
			bcopy((char*)&bsscfg->BSSID, (char*)&h->a3, ETHER_ADDR_LEN);
	}
	else if (BSSCFG_AP(bsscfg)) {
		ASSERT(ra == NULL);
		/* AP: a1 = DA, a2 = BSSID, a3 = SA, ToDS = 0, FromDS = 1 */
		bcopy(eh->ether_dhost, h->a1.octet, ETHER_ADDR_LEN);
		bcopy(bsscfg->BSSID.octet, h->a2.octet, ETHER_ADDR_LEN);
		/* eh->ether_shost and h->a3 may overlap */
		if (key || SCB_QOS(scb)) {
			/* In WEP case, &h->a3 + 4 = &eh->ether_shost due to IV offset,
			 * thus need to bcopy
			 */
			bcopy((char*)&eh->ether_shost, (char*)&tmpaddr, ETHER_ADDR_LEN);
			bcopy((char*)&tmpaddr, (char*)&h->a3, ETHER_ADDR_LEN);
		}
		fc |= FC_FROMDS;
	} else {
		ASSERT(ra == NULL);
		if (bsscfg->BSS) {
			/* BSS STA: a1 = BSSID, a2 = SA, a3 = DA, ToDS = 1, FromDS = 0 */
			bcopy((char*)&bsscfg->BSSID, (char*)&h->a1, ETHER_ADDR_LEN);
			bcopy((char*)&eh->ether_dhost, (char*)&tmpaddr, ETHER_ADDR_LEN);
			bcopy((char*)&eh->ether_shost, (char*)&h->a2, ETHER_ADDR_LEN);
			bcopy((char*)&tmpaddr, (char*)&h->a3, ETHER_ADDR_LEN);
			fc |= FC_TODS;
		} else {
			/* IBSS/DPT STA: a1 = DA, a2 = SA, a3 = BSSID, ToDS = 0, FromDS = 0 */
			bcopy((char*)&eh->ether_dhost, (char*)&h->a1, ETHER_ADDR_LEN);
			bcopy((char*)&eh->ether_shost, (char*)&h->a2, ETHER_ADDR_LEN);
			bcopy((char*)&bsscfg->BSSID, (char*)&h->a3, ETHER_ADDR_LEN);
		}
	}

	/* SCB_QOS: Fill QoS Control Field */
	if (SCB_QOS(scb)) {
		uint16 qos, *pqos;

		/* Set fragment priority */
		qos = (prio << QOS_PRIO_SHIFT) & QOS_PRIO_MASK;

		/* Set the ack policy; BA/AMPDU overrides wme_noack */
		if (WLPKTFLAG_BA(pkttag))
			qos |= (QOS_ACK_BLOCK_ACK << QOS_ACK_SHIFT) & QOS_ACK_MASK;
		else if (WLPKTFLAG_AMPDU(pkttag))
			qos |= (QOS_ACK_NORMAL_ACK << QOS_ACK_SHIFT) & QOS_ACK_MASK;
		else if (wlc->wme_noack == QOS_ACK_NO_ACK) {
			WLPKTTAG(p)->flags |= WLF_WME_NOACK;
			qos |= (QOS_ACK_NO_ACK << QOS_ACK_SHIFT) & QOS_ACK_MASK;
		}
		else
			qos |= (wlc->wme_noack << QOS_ACK_SHIFT) & QOS_ACK_MASK;

		/* Set the A-MSDU bit for AMSDU packet */
		if (WLPKTFLAG_AMSDU(pkttag))
			qos |= (1 << QOS_AMSDU_SHIFT) & QOS_AMSDU_MASK;

		pqos = (uint16 *)((uchar *)h + (wds ? DOT11_A4_HDR_LEN : DOT11_A3_HDR_LEN));
		ASSERT(ISALIGNED((uintptr)pqos, sizeof(*pqos)));

		*pqos = htol16(qos);

		/* Set subtype to QoS Data */
		fc |= (FC_SUBTYPE_QOS_DATA << FC_SUBTYPE_SHIFT);
	}

	if (key && !ext_tkip) {
		bool update = TRUE;

		iv_data = (uchar *)h + DOT11_A3_HDR_LEN;
		if (wds)
			iv_data += ETHER_ADDR_LEN;
		if (SCB_QOS(scb))
			iv_data += DOT11_QOS_LEN;
#if defined(BCMDBG)
		update = ((key->flags & WSEC_REPLAY_ERROR) == 0);
		if (!update)
			key->flags &= ~WSEC_REPLAY_ERROR;
#endif /* defined(BCMDBG) */
		wlc_key_iv_update(wlc, bsscfg, key, iv_data, update);
	}

	fc |= (FC_TYPE_DATA << FC_TYPE_SHIFT);

	/* Set MoreFrag, WEP, and Order fc fields */
	if (MoreFrag)
		fc |= FC_MOREFRAG;
	if (key)
		fc |= FC_WEP;

	h->fc = htol16(fc);

	return h;
}

static uint16
wlc_compute_airtime(wlc_info_t *wlc, ratespec_t rspec, uint length)
{
	uint16 usec = 0;
	uint mac_rate = RSPEC2RATE(rspec);
	uint nsyms;

	if (IS_MCS(rspec)) {
		/* not supported yet */
		ASSERT(0);
	} else if (IS_OFDM(rspec)) {
		/* nsyms = Ceiling(Nbits / (Nbits/sym))
		 *
		 * Nbits = length * 8
		 * Nbits/sym = Mbps * 4 = mac_rate * 2
		 */
		nsyms = CEIL((length * 8), (mac_rate * 2));

		/* usec = symbols * usec/symbol */
		usec = (uint16) (nsyms * APHY_SYMBOL_TIME);
		return (usec);
	} else {
		switch (mac_rate) {
		case WLC_RATE_1M:
			usec = length << 3;
			break;
		case WLC_RATE_2M:
			usec = length << 2;
			break;
		case WLC_RATE_5M5:
			usec = (length << 4)/11;
			break;
		case WLC_RATE_11M:
			usec = (length << 3)/11;
			break;
		default:
			WL_ERROR(("wl%d: wlc_compute_airtime: unsupported rspec 0x%x\n",
				wlc->pub->unit, rspec));
			ASSERT((const char*)"Bad phy_rate" == NULL);
			break;
		}
	}

	return (usec);
}

void BCMFASTPATH
wlc_compute_plcp(wlc_info_t *wlc, ratespec_t rspec, uint length, uint8 *plcp)
{
	WL_TRACE(("wl%d: wlc_compute_plcp: rate 0x%x, length %d\n", wlc->pub->unit, rspec, length));

	if (IS_MCS(rspec)) {
		wlc_compute_mimo_plcp(rspec, length, plcp);
	} else if (IS_OFDM(rspec)) {
		wlc_compute_ofdm_plcp(rspec, length, plcp);
	} else {
		wlc_compute_cck_plcp(rspec, length, plcp);
	}
	return;
}

/* Rate: 802.11 rate code, length: PSDU length in octets */
static void
wlc_compute_mimo_plcp(ratespec_t rspec, uint length, uint8 *plcp)
{
	uint8 mcs = (uint8)(rspec & RSPEC_RATE_MASK);
	ASSERT(IS_MCS(rspec));
	plcp[0] = mcs;
	if (RSPEC_IS40MHZ(rspec) || (mcs == 32))
		plcp[0] |= MIMO_PLCP_40MHZ;
	WLC_SET_MIMO_PLCP_LEN(plcp, length);
	plcp[3] = RSPEC_MIMOPLCP3(rspec); /* rspec already holds this byte */
	plcp[3] |= 0x7;	/* set smoothing, not sounding ppdu & reserved */
	plcp[4] = 0;	/* number of extension spatial streams bit 0 & 1 */
	plcp[5] = 0;
}

/* Rate: 802.11 rate code, length: PSDU length in octets */
static void BCMFASTPATH
wlc_compute_ofdm_plcp(ratespec_t rspec, uint32 length, uint8 *plcp)
{
	uint8 rate_signal;
	uint32 tmp = 0;
	int rate = RSPEC2RATE(rspec);

	ASSERT(IS_OFDM(rspec));

	/* encode rate per 802.11a-1999 sec 17.3.4.1, with lsb transmitted first */
	rate_signal = rate_info[rate] & RATE_MASK;
	ASSERT(rate_signal != 0);

	bzero(plcp, D11_PHY_HDR_LEN);
	D11A_PHY_HDR_SRATE((ofdm_phy_hdr_t *)plcp, rate_signal);

	tmp = (length & 0xfff) << 5;
	plcp[2] |= (tmp >> 16) & 0xff;
	plcp[1] |= (tmp >> 8) & 0xff;
	plcp[0] |= tmp & 0xff;

	return;
}

/*
 * Compute PLCP, but only requires actual rate and length of pkt.
 * Rate is given in the driver standard multiple of 500 kbps.
 * le is set for 11 Mbps rate if necessary.
 * Broken out for PRQ.
 */

static void
wlc_cck_plcp_set(int rate_500, uint length, uint8 *plcp)
{
	uint16 usec = 0;
	uint8 le = 0;

	switch (rate_500) {
	case 2:
		usec = length << 3;
		break;
	case 4:
		usec = length << 2;
		break;
	case 11:
		usec = (length << 4)/11;
		if ((length << 4) - (usec * 11) > 0)
			usec++;
		break;
	case 22:
		usec = (length << 3)/11;
		if ((length << 3) - (usec * 11) > 0) {
			usec++;
			if ((usec * 11) - (length << 3) >= 8)
				le = D11B_PLCP_SIGNAL_LE;
		}
		break;

	default:
		WL_ERROR(("wlc_cck_plcp_set: unsupported rate %d\n", rate_500));
		ASSERT((const char*)"invalid rate" == NULL);
		break;
	}
	/* PLCP signal byte */
	plcp[0] = rate_500 * 5; /* r (500kbps) * 5 == r (100kbps) */
	/* PLCP service byte */
	plcp[1] = (uint8)(le | D11B_PLCP_SIGNAL_LOCKED);
	/* PLCP length uint16, little endian */
	plcp[2] = usec & 0xff;
	plcp[3] = (usec >> 8) & 0xff;
	/* PLCP CRC16 */
	plcp[4] = 0;
	plcp[5] = 0;
}

/* Rate: 802.11 rate code, length: PSDU length in octets */
static void
wlc_compute_cck_plcp(ratespec_t rspec, uint length, uint8 *plcp)
{
	int rate = RSPEC2RATE(rspec);

	ASSERT(IS_CCK(rspec));

	wlc_cck_plcp_set(rate, length, plcp);
}

#if defined(MBSS) || defined(WLTXMONITOR)

/* convert rate in OFDM PLCP to ratespec */
static ratespec_t
ofdm_plcp_to_rspec(uint8 rate)
{
	ratespec_t rspec = 0;


	switch (rate & 0x0F) {
	case 0x0B: /* 6Mbps */
		rspec = 6*2;
		break;
	case 0x0F: /* 9Mbps */
		rspec = 9*2;
		break;
	case 0x0A: /* 12 Mbps */
		rspec = 12*2;
		break;
	case 0x0E: /* 18 Mbps */
		rspec = 18*2;
		break;
	case 0x09: /* 24 Mbps */
		rspec = 24*2;
		break;
	case 0x0D: /* 36 Mbps */
		rspec = 36*2;
		break;
	case 0x08: /* 48 Mbps */
		rspec = 48*2;
		break;
	case 0x0C: /* 54 Mbps */
		rspec = 54*2;
		break;
	default:
		/* Not a valid OFDM rate */
		ASSERT(0);
		break;
	}

	return rspec;
}
#endif /* MBSS || WLTXMONITOR */

#if defined(MBSS)
/* Given a PRQ entry info structure, generate a PLCP header for a probe response and fixup the
 * txheader of the probe response template
 */
void
wlc_prb_resp_plcp_hdrs(wlc_info_t *wlc, wlc_prq_info_t *info, int length, uint8 *plcp,
                       d11txh_t *txh, uint8 *d11_hdr)
{
	uint32 tmp;

	/* generate the PLCP header */
	switch (info->frame_type) {
	case SHM_MBSS_PRQ_FT_OFDM:
		bzero(plcp, D11_PHY_HDR_LEN);
		/* Low order 4 bits preserved from plcp0 */
		plcp[0] = (info->plcp0 & 0xf);
		/* The rest is the length, shifted over 5 bits, little endian */
		tmp = (length & 0xfff) << 5;
		plcp[2] |= (tmp >> 16) & 0xff;
		plcp[1] |= (tmp >> 8) & 0xff;
		plcp[0] |= tmp & 0xff;
		break;
	case SHM_MBSS_PRQ_FT_MIMO:
		plcp[0] = info->plcp0;
		WLC_SET_MIMO_PLCP_LEN(plcp, length);
		break;
	case SHM_MBSS_PRQ_FT_CCK:
		wlc_cck_plcp_set(info->plcp0 / 5, length, plcp);
		break;
	default:
		WL_ERROR(("Received illegal frame type in PRQ\n"));
		break;
	}

	/* for OFDM, MIMO and CCK fixup txheader, d11hdr */
	if (info->frame_type == SHM_MBSS_PRQ_FT_OFDM || info->frame_type == SHM_MBSS_PRQ_FT_MIMO ||
		info->frame_type == SHM_MBSS_PRQ_FT_CCK) {
		uint16 phyctl = 0;
		uint16 mainrates;
		uint16 xfts;
		uint16 durid;
		ratespec_t rspec;
		struct dot11_header *h = (struct dot11_header *)d11_hdr;

		/* plcp0 low 4 bits have incoming rate, we'll respond at same rate */
		if (info->frame_type == SHM_MBSS_PRQ_FT_OFDM) {
			rspec = ofdm_plcp_to_rspec(plcp[0]);
			phyctl = FT_OFDM;
		}
		else if (info->frame_type == SHM_MBSS_PRQ_FT_MIMO) {
			rspec = plcp[0] | RSPEC_MIMORATE;
			phyctl = FT_HT;
		}
		else {
			rspec = plcp[0]/5;
			phyctl = FT_CCK;
		}

#ifdef WL11N
		if (WLCISHTPHY(wlc->band)) {
			uint16 phytxant;
			phytxant = wlc_stf_txcore_get(wlc, rspec) << PHY_TXC_ANT_SHIFT;
			phyctl |= phytxant & PHY_TXC_HTCORE_MASK;
		} else
#endif /* WL11N */
			phyctl |= wlc->stf->phytxant & PHY_TXC_ANT_MASK;

		txh->PhyTxControlWord = htol16(phyctl);

		mainrates = D11A_PHY_HDR_GRATE((ofdm_phy_hdr_t *)plcp);
		txh->MainRates = htol16(mainrates);

		/* leave "most" of existing XtraFrameTypes, but make sure Fallback Frame Type
		 * is set to FT_OFDM.
		 */
		xfts = ltoh16(txh->XtraFrameTypes);
		xfts &= 0xFFFC;
		if (info->frame_type == SHM_MBSS_PRQ_FT_OFDM)
			xfts |= FT_OFDM;
		else if (info->frame_type == SHM_MBSS_PRQ_FT_MIMO)
			xfts |= FT_HT;
		else
			xfts |= FT_CCK;

		txh->XtraFrameTypes = htol16(xfts);

		/* dup plcp as fragplcp, same fallback rate etc */
		bcopy(plcp, (char*)&txh->FragPLCPFallback, sizeof(txh->FragPLCPFallback));

		/* Possibly fixup some more fields */
		if (WLCISNPHY(wlc->band) || WLCISLPPHY(wlc->band) || WLCISSSLPNPHY(wlc->band)) {
			uint16 phyctl1 = 0;

			/* When uCode handles probe responses, they use same rate for fallback
			 * as the main rate, so we'll do the same.
			 */

			/* the following code expects the BW setting in the ratespec */
			rspec &= ~RSPEC_BW_MASK;
			rspec |= (PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT);

			phyctl1 = wlc_phytxctl1_calc(wlc, rspec);
			txh->PhyTxControlWord_1 = htol16(phyctl1);
			txh->PhyTxControlWord_1_Fbr = htol16(phyctl1);
		}

		/* fixup dur based on our tx rate */
		durid = wlc_compute_frame_dur(wlc, rspec,
		        (IS_MCS(rspec)? WLC_MM_PREAMBLE:WLC_LONG_PREAMBLE), 0);
		h->durid = htol16(durid);
		txh->FragDurFallback = h->durid;
	}
}
#endif /* MBSS */

/* wlc_compute_frame_dur()
 *
 * Calculate the 802.11 MAC header DUR field for MPDU
 * DUR for a single frame = 1 SIFS + 1 ACK
 * DUR for a frame with following frags = 3 SIFS + 2 ACK + next frag time
 *
 * rate			MPDU rate in unit of 500kbps
 * next_frag_len	next MPDU length in bytes
 * preamble_type	use short/GF or long/MM PLCP header
 */
static uint16 BCMFASTPATH
wlc_compute_frame_dur(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type, uint next_frag_len)
{
	uint16 dur, sifs;

	sifs = SIFS(wlc->band);

	dur = sifs;
	dur += (uint16)wlc_calc_ack_time(wlc, rate, preamble_type);

	if (next_frag_len) {
		/* Double the current DUR to get 2 SIFS + 2 ACKs */
		dur *= 2;
		/* add another SIFS and the frag time */
		dur += sifs;
		dur += (uint16)wlc_calc_frame_time(wlc, rate, preamble_type, next_frag_len);
	}
	return (dur);
}

/* wlc_compute_rtscts_dur()
 *
 * Calculate the 802.11 MAC header DUR field for an RTS or CTS frame
 * DUR for normal RTS/CTS w/ frame = 3 SIFS + 1 CTS + next frame time + 1 ACK
 * DUR for CTS-TO-SELF w/ frame    = 2 SIFS         + next frame time + 1 ACK
 *
 * cts			cts-to-self or rts/cts
 * rts_rate		rts or cts rate in unit of 500kbps
 * rate			next MPDU rate in unit of 500kbps
 * frame_len		next MPDU frame length in bytes
 */
uint16 BCMFASTPATH
wlc_compute_rtscts_dur(wlc_info_t *wlc, bool cts_only, ratespec_t rts_rate, ratespec_t frame_rate,
                       uint8 rts_preamble_type, uint8 frame_preamble_type, uint frame_len, bool ba)
{
	uint16 dur, sifs;

	sifs = SIFS(wlc->band);

	if (!cts_only) {	/* RTS/CTS */
		dur = 3 * sifs;
		dur += (uint16)wlc_calc_cts_time(wlc, rts_rate, rts_preamble_type);
	} else {	/* CTS-TO-SELF */
		dur = 2 * sifs;
	}

	dur += (uint16)wlc_calc_frame_time(wlc, frame_rate, frame_preamble_type, frame_len);
#ifdef WL11N
	if (ba)
		dur += (uint16)wlc_calc_ba_time(wlc, frame_rate, WLC_SHORT_PREAMBLE);
	else
#endif
		dur += (uint16)wlc_calc_ack_time(wlc, frame_rate, frame_preamble_type);
	return (dur);
}

static bool
wlc_phy_rspec_check(wlc_info_t *wlc, uint16 bw, ratespec_t rspec)
{
	if (IS_MCS(rspec)) {
		uint mcs = rspec & RSPEC_RATE_MASK;

		if (mcs < 8) {
			ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_SDM);
		} else if ((mcs >= 8) && (mcs <= 23)) {
			ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SDM);
		} else if (mcs == 32) {
			ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_SDM);
			ASSERT(bw == PHY_TXC1_BW_40MHZ_DUP);
		}
	} else if (IS_OFDM(rspec)) {
		ASSERT(RSPEC_STF(rspec) < PHY_TXC1_MODE_STBC);
	} else {
		ASSERT(IS_CCK(rspec));

		ASSERT((bw == PHY_TXC1_BW_20MHZ) || (bw == PHY_TXC1_BW_20MHZ_UP));
		ASSERT(RSPEC_STF(rspec) == PHY_TXC1_MODE_SISO);
	}

	return TRUE;
}

uint16 BCMFASTPATH
wlc_phytxctl1_calc(wlc_info_t *wlc, ratespec_t rspec)
{
	uint16 phyctl1 = 0;
	uint16 bw;

	if (WLCISLPPHY(wlc->band) || WLCISLCNPHY(wlc->band)) {
		bw = PHY_TXC1_BW_20MHZ;
	} else {
		bw = RSPEC_GET_BW(rspec);
		/* 10Mhz is not supported yet */
		if (bw < PHY_TXC1_BW_20MHZ) {
			WL_ERROR(("wlc_phytxctl1_calc: bw %d is not supported yet, set to 20L\n",
				bw));
			bw = PHY_TXC1_BW_20MHZ;
		}

		wlc_phy_rspec_check(wlc, bw, rspec);
	}

	if (WLCISHTPHY(wlc->band)) {
		uint16 spatial_map = wlc_stf_spatial_expansion_get(wlc, rspec);
		/* retrive power offset on per packet basis */
		uint8 pwr = wlc_stf_get_pwrperrate(wlc, rspec, bw, spatial_map);
		phyctl1 = (bw | (pwr << PHY_TXC1_HTTXPWR_OFFSET_SHIFT));
		/* spatial mapper table lookup on per packet basis */
		phyctl1 |= (spatial_map << PHY_TXC1_HTSPARTIAL_MAP_SHIFT);
		goto exit;
	}

	if (IS_MCS(rspec)) {
		uint mcs = rspec & RSPEC_RATE_MASK;

		ASSERT(!WLCISLPPHY(wlc->band));

		/* bw, stf, coding-type is part of RSPEC_PHYTXBYTE2 returns */
		phyctl1 = RSPEC_PHYTXBYTE2(rspec);
		/* set the upper byte of phyctl1 */
		phyctl1 |= (mcs_table[mcs].tx_phy_ctl3 << 8);
	} else if (IS_CCK(rspec) && !WLCISLPPHY(wlc->band) &&
		!WLCISSSLPNPHY(wlc->band) && !WLCISLCNPHY(wlc->band)) {
		/* In CCK mode LPPHY overloads OFDM Modulation bits with CCK Data Rate */
		/* Eventually MIMOPHY would also be converted to this format */
		/* 0 = 1Mbps; 1 = 2Mbps; 2 = 5.5Mbps; 3 = 11Mbps */
		phyctl1 = (bw | (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
	} else {	/* legacy OFDM/CCK */
		int16 phycfg;
		/* get the phyctl byte from rate phycfg table */
		if ((phycfg = wlc_rate_legacy_phyctl(RSPEC2RATE(rspec))) == -1) {
			WL_ERROR(("wlc_phytxctl1_calc: wrong legacy OFDM/CCK rate\n"));
			ASSERT(0);
			phycfg = 0;
		}
		/* set the upper byte of phyctl1 */
		phyctl1 = (bw | (phycfg << 8) | (RSPEC_STF(rspec) << PHY_TXC1_MODE_SHIFT));
	}
exit:
#ifdef BCMDBG
	/* phy clock must support 40Mhz if tx descriptor uses it */
	if ((phyctl1 & PHY_TXC1_BW_MASK) >= PHY_TXC1_BW_40MHZ) {
		ASSERT(CHSPEC_IS40(wlc->chanspec));
#ifdef WLC_LOW
		ASSERT(wlc->chanspec == wlc_phy_chanspec_get(wlc->band->pi));
#endif
	}
#endif /* BCMDBG */
	return phyctl1;
}

ratespec_t BCMFASTPATH
wlc_rspec_to_rts_rspec(wlc_bsscfg_t *cfg, ratespec_t rspec, bool use_rspec, uint16 mimo_ctlchbw)
{
	wlc_info_t *wlc = cfg->wlc;
	ratespec_t rts_rspec = 0;

	if (use_rspec) {
		/* use frame rate as rts rate */
		rts_rspec = rspec;

	} else if (wlc->band->gmode && cfg->prot_cfg->_g && !IS_CCK(rspec)) {
		/* Use 11Mbps as the g protection RTS target rate and fallback.
		 * Use the WLC_BASIC_RATE() lookup to find the best basic rate under the
		 * target in case 11 Mbps is not Basic.
		 * 6 and 9 Mbps are not usually selected by rate selection, but even
		 * if the OFDM rate we are protecting is 6 or 9 Mbps, 11 is more robust.
		 */
		rts_rspec = WLC_BASIC_RATE(wlc, WLC_RATE_11M);
	} else {
		/* calculate RTS rate and fallback rate based on the frame rate
		 * RTS must be sent at a basic rate since it is a
		 * control frame, sec 9.6 of 802.11 spec
		 */
		rts_rspec = WLC_BASIC_RATE(wlc, rspec);
	}

#ifdef WL11N
	if (WLC_PHY_11N_CAP(wlc->band)) {
		/* set rts txbw to correct side band */
		rts_rspec &= ~RSPEC_BW_MASK;

		/* if rspec/rspec_fallback is 40MHz, then send RTS on both 20MHz channel
		 * (DUP), otherwise send RTS on control channel
		 */
		if (RSPEC_IS40MHZ(rspec) && !IS_CCK(rts_rspec))
			rts_rspec |= (PHY_TXC1_BW_40MHZ_DUP << RSPEC_BW_SHIFT);
		else
			rts_rspec |= (mimo_ctlchbw << RSPEC_BW_SHIFT);

		/* pick siso/cdd as default for ofdm */
		if (IS_OFDM(rts_rspec)) {
			rts_rspec &= ~RSPEC_STF_MASK;
			rts_rspec |= (wlc->stf->ss_opmode << RSPEC_STF_SHIFT);
		}
	}
#else
	/* set rts txbw to control channel BW if 11 n feature is not turned on */
	rts_rspec &= ~RSPEC_BW_MASK;
	rts_rspec |= (mimo_ctlchbw << RSPEC_BW_SHIFT);
#endif /* WL11N */

	return rts_rspec;
}

/* Apply all N-related overrides to resolve preamble type */
static INLINE uint8
wlc_mimo_preamble_get(wlc_info_t *wlc, struct scb *scb)
{
	uint8 preamble_type = WLC_GF_PREAMBLE;
	wlc_bsscfg_t *cfg;
	wlc_prot_cfg_t *prot;

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

	prot = cfg->prot_cfg;

	if ((prot->n_cfg == WLC_N_PROTECTION_MIXEDMODE) ||
	    (prot->n_cfg == WLC_N_PROTECTION_OPTIONAL)) {
		/* additional protection for legacy dev */
		preamble_type = WLC_MM_PREAMBLE;
	} else {
	}

	/* use mixed mode preamble if dest is not GF capable or nongf associated */
	if (SCB_NONGF_CAP(scb) || prot->nongf)
		preamble_type = WLC_MM_PREAMBLE;

	if (((CHIPID(wlc->pub->sih->chip) == BCM4716_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM4748_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM47162_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM5357_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM53572_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM43236_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM4331_CHIP_ID) ||
	     (CHIPID(wlc->pub->sih->chip) == BCM43431_CHIP_ID)) &&
	    (wlc->protection->n_pam_override == WLC_N_PREAMBLE_GF_BRCM)) {
		if (preamble_type == WLC_GF_PREAMBLE) {
			if (!(scb->flags & SCB_BRCM))
				preamble_type = WLC_MM_PREAMBLE;
		}
	}

	if (CHIPID(wlc->pub->sih->chip) == BCM4313_CHIP_ID) {
		if (preamble_type == WLC_GF_PREAMBLE) {
			preamble_type = WLC_MM_PREAMBLE;
		}
	}

	if ((wlc->protection->n_pam_override != AUTO) &&
	    (wlc->protection->n_pam_override != WLC_N_PREAMBLE_GF_BRCM)) {
		if (wlc->protection->n_pam_override == WLC_N_PREAMBLE_GF)
			preamble_type = WLC_GF_PREAMBLE;
		else {
			preamble_type = WLC_MM_PREAMBLE;
		}
	}

	return preamble_type;
}

/*
 * Add d11txh_t, cck_phy_hdr_t.
 *
 * 'p' data must start with 802.11 MAC header
 * 'p' must allow enough bytes of local headers to be "pushed" onto the packet
 *
 * headroom == D11_PHY_HDR_LEN + D11_TXH_LEN (D11_TXH_LEN is now 104 bytes)
 *
 */
static uint16 BCMFASTPATH
wlc_d11hdrs(wlc_info_t *wlc, void *p, struct scb *scb, bool short_preamble, uint frag,
	uint nfrags, uint queue, uint next_frag_len, wsec_key_t *key, ratespec_t rspec_override)
{
	struct dot11_header *h;
	d11txh_t *txh;
	uint8 *plcp, plcp_fallback[D11_PHY_HDR_LEN];
	osl_t *osh;
	int len, phylen, rts_phylen;
	uint16 fc, type, frameid, mch, phyctl, xfts, mainrates, rate_flag;
	uint16 seq = 0, mcl = 0, status = 0;
	ratespec_t rspec, rspec_fallback;
	bool use_rts = FALSE;
	bool use_cts = FALSE, rspec_history = FALSE;
#ifdef WLAFTERBURNER
	bool use_afterburner = FALSE;
#endif /* WLAFTERBURNER */
	bool use_rifs = FALSE;
	uint8 preamble_type = WLC_LONG_PREAMBLE, fbr_preamble_type = WLC_LONG_PREAMBLE;
	uint8 rts_preamble_type = WLC_LONG_PREAMBLE, rts_fbr_preamble_type = WLC_LONG_PREAMBLE;
	uint8 *rts_plcp, rts_plcp_fallback[D11_PHY_HDR_LEN];
	struct dot11_rts_frame *rts = NULL;
	ratespec_t rts_rspec = 0, rts_rspec_fallback = 0;
	bool qos;
	uint ac, rate;
	wlc_pkttag_t *pkttag;
	bool hwtkmic = FALSE;
	uint16 mimo_ctlchbw = PHY_TXC1_BW_20MHZ;
	uint8 antselid, fbantselid;
#ifdef WL11N
#define ANTCFG_NONE 0xFF
	uint8 antcfg = ANTCFG_NONE;
	uint8 fbantcfg = ANTCFG_NONE;
	uint16 mimoantsel;
	bool use_mimops_rts = FALSE;
	uint phyctl1_stf = 0;
#endif /* WL11N */
	uint16 durid = 0;
#if SSLPNCONF && !defined(WLC_SPLIT)
	int16 mcs_adjustment;
	int8 mcs_pwr_this_rate, legacy_pwr_this_rate;
	uint bw20_u_l = 0;
#endif
	wlc_bsscfg_t *bsscfg;
	wlc_prot_cfg_t *prot;

	ASSERT(scb != NULL);
	ASSERT(queue < NFIFO);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	prot = bsscfg->prot_cfg;

	osh = wlc->osh;

	/* locate 802.11 MAC header */
	h = (struct dot11_header*) PKTDATA(osh, p);
	pkttag = WLPKTTAG(p);
	fc = ltoh16(h->fc);
	type = FC_TYPE(fc);
	qos = (type == FC_TYPE_DATA && FC_SUBTYPE_ANY_QOS(FC_SUBTYPE(fc)));

	/* compute length of frame in bytes for use in PLCP computations */
	len = pkttotlen(osh, p);
	phylen = len + DOT11_FCS_LEN;

	/* If WEP enabled, add room in phylen for the additional bytes of
	 * ICV which MAC generates.  We do NOT add the additional bytes to
	 * the packet itself, thus phylen = packet length + ICV_LEN + FCS_LEN
	 * in this case
	 */
	if (key) {
#ifdef BCMWAPI_WPI
		if (!WSEC_SMS4_SW_KEY(wlc, key))
#endif /* BCMWAPI_WPI */
		{
			phylen += key->icv_len;
		}
	}

#ifndef LINUX_CRYPTO
	/* Enable hardware TKIP MIC if supported */
	if (WSEC_HW_TKMIC_KEY(wlc, key, bsscfg) &&
	    !WLPKTFLAG_PMF(WLPKTTAG(p)) && (nfrags == 1)) {
		hwtkmic = TRUE;

		/* add MIC size as it will be appended by hardware */
		phylen += TKIP_MIC_SIZE;
	}
#else
	/* Software TKIP module adds the extiv at the front */
	if (key && (key->algo == CRYPTO_ALGO_TKIP)) {
		PKTPUSH(osh, p, 8);
		phylen += 8;
	}
#endif /* LINUX_CRYPTO */

	/* add PLCP */
	plcp = PKTPUSH(osh, p, D11_PHY_HDR_LEN);

	/* add Broadcom tx descriptor header */
	txh = (d11txh_t*)PKTPUSH(osh, p, D11_TXH_LEN);
	bzero((char*)txh, D11_TXH_LEN);

	/* use preassigned or software seqnum */
	if (WLPKTFLAG_AMPDU(pkttag))
		seq = pkttag->seq;
	else if (SCB_QOS(scb) && ((fc & FC_KIND_MASK) == FC_QOS_DATA) && !ETHER_ISMULTI(&h->a1)) {
		seq = SCB_SEQNUM(scb, PKTPRIO(p));
		/* Increment the sequence number only after the last fragment */
		if (frag == (nfrags - 1))
		    SCB_SEQNUM(scb, PKTPRIO(p))++;
	} else if (type != FC_TYPE_CTL)
		mcl |= TXC_HWSEQ;

	if (type != FC_TYPE_CTL) {
		seq = (seq << SEQNUM_SHIFT) | (frag & FRAGNUM_MASK);
		h->seq = htol16(seq);
	}

	/* setup frameid */
	if (queue == TX_BCMC_FIFO) {
		frameid = bcmc_fid_generate(wlc, bsscfg, txh);
	} else {
		seq = (wlc->counter << SEQNUM_SHIFT) | (frag & FRAGNUM_MASK);
		/* Increment the counter only after the last fragment */
		if (frag == (nfrags - 1))
			wlc->counter++;
		frameid = ((seq << TXFID_SEQ_SHIFT) & TXFID_SEQ_MASK) |
			(queue & TXFID_QUEUE_MASK);
	}

	/* set the ignpmq bit for all pkts tx'd in PS mode and for beacons */
	if (SCB_PS(scb) || ((fc & FC_KIND_MASK) == FC_BEACON))
		mcl |= TXC_IGNOREPMQ;

	/* (1) RATE: determine and validate primary rate and fallback rates */

	if (RSPEC_ACTIVE(rspec_override)) {
		rspec = rspec_fallback = rspec_override;
#ifdef WL11N
		if (WLANTSEL_ENAB(wlc) && !ETHER_ISMULTI(&h->a1)) {
			/* set tx antenna config */
			wlc_antsel_antcfg_get(wlc->asi, FALSE, FALSE, 0, 0,
				&antcfg, &fbantcfg);
		}
#endif /* WL11N */
	}
	else if ((type == FC_TYPE_MNG) ||
		(type == FC_TYPE_CTL) ||
		(pkttag->flags & WLF_8021X) ||
#ifdef BCMWAPI_WAI
		(pkttag->flags & WLF_WAI) ||
#endif
		FALSE)
		rspec = rspec_fallback = scb->rateset.rates[0] & RATE_MASK;
	else if (RSPEC_ACTIVE(wlc->band->mrspec_override) && ETHER_ISMULTI(&h->a1))
		rspec = rspec_fallback = wlc->band->mrspec_override;
	else if (RSPEC_ACTIVE(wlc->band->rspec_override)) {
		rspec = rspec_fallback = wlc->band->rspec_override;
#ifdef WL11N
		if (WLANTSEL_ENAB(wlc) && !ETHER_ISMULTI(&h->a1)) {
			/* set tx antenna config */
			wlc_antsel_antcfg_get(wlc->asi, FALSE, FALSE, 0, 0,
				&antcfg, &fbantcfg);
		}
#endif /* WL11N */
	} else if (ETHER_ISMULTI(&h->a1) || SCB_INTERNAL(scb))
		rspec = rspec_fallback = scb->rateset.rates[0] & RATE_MASK;
	else {
		/* run rate algorithm for data frame only, a cookie will be deposited in frameid */
		wlc_ratesel_gettxrate(wlc->rsi, scb, &frameid, &rspec, &rspec_fallback,
		                      &antselid, &fbantselid, &rate_flag);

		pkttag->flags |= WLF_RATE_AUTO;
#ifdef WL11N
		if (rate_flag & RATESEL_VRATE_PROBE)
			WLPKTTAG(p)->flags |= WLF_VRATE_PROBE;

		if (WLANTSEL_ENAB(wlc)) {
			wlc_antsel_antcfg_get(wlc->asi, FALSE, TRUE, antselid, fbantselid,
				&antcfg, &fbantcfg);
		}
#endif /* WL11N */

		/* perform rate history after txbw has been selected */
		if (frag == 0)
			rspec_history = TRUE;
	}

#ifdef WL11N
	phyctl1_stf = wlc->stf->ss_opmode;

	if (N_ENAB(wlc->pub)) {
		uint16 mimo_txbw;
		uint8 mimo_preamble_type;

		/* apply siso/cdd to single stream mcs's or ofdm if rspec is auto selected */
		if (((IS_MCS(rspec) &&
			IS_SINGLE_STREAM(rspec & RSPEC_RATE_MASK)) ||
			IS_OFDM(rspec)) && ((rspec & RSPEC_OVERRIDE_MCS_ONLY) ||
			!(rspec & RSPEC_OVERRIDE))) {
			rspec &= ~(RSPEC_STF_MASK | RSPEC_STC_MASK);

			/* For SISO MCS use STBC if possible */
			if (IS_MCS(rspec) && WLC_STF_SS_STBC_TX(wlc, scb)) {
				uint8 stc;

				ASSERT(WLC_STBC_CAP_PHY(wlc));
				stc = 1;	/* Nss for single stream is always 1 */
				rspec |= (PHY_TXC1_MODE_STBC << RSPEC_STF_SHIFT) |
					(stc << RSPEC_STC_SHIFT);
			} else
				rspec |= (phyctl1_stf << RSPEC_STF_SHIFT);
		}

		if (((IS_MCS(rspec_fallback) &&
			IS_SINGLE_STREAM(rspec_fallback & RSPEC_RATE_MASK)) ||
			IS_OFDM(rspec_fallback)) && ((rspec & RSPEC_OVERRIDE_MCS_ONLY) ||
			!(rspec & RSPEC_OVERRIDE))) {
			rspec_fallback &= ~(RSPEC_STF_MASK | RSPEC_STC_MASK);

			/* For SISO MCS use STBC if possible */
			if (IS_MCS(rspec_fallback) && WLC_STF_SS_STBC_TX(wlc, scb)) {
				uint8 stc;

				ASSERT(WLC_STBC_CAP_PHY(wlc));
				stc = 1;	/* Nss for single stream is always 1 */
				rspec_fallback |= (PHY_TXC1_MODE_STBC << RSPEC_STF_SHIFT) |
					(stc << RSPEC_STC_SHIFT);
			} else
				rspec_fallback |= phyctl1_stf << RSPEC_STF_SHIFT;
		}

		/* Is the phy configured to use 40MHZ frames? If so then pick the desired txbw */
		if (CHSPEC_IS40(wlc->chanspec)) {
			/* default txbw is 20in40 SB */
			mimo_ctlchbw = mimo_txbw = CHSPEC_SB_UPPER(WLC_BAND_PI_RADIO_CHANSPEC) ?
				PHY_TXC1_BW_20MHZ_UP : PHY_TXC1_BW_20MHZ;

			if (IS_MCS(rspec)) {
				/* mcs 32 must be 40b/w DUP */
				if ((rspec & RSPEC_RATE_MASK) == 32) {
					mimo_txbw = PHY_TXC1_BW_40MHZ_DUP;
				/* use override */
				} else if (wlc->mimo_40txbw != AUTO)
					mimo_txbw = wlc->mimo_40txbw;
				/* else check if dst is using 40 Mhz */
				else if (scb->flags & SCB_IS40)
					mimo_txbw = PHY_TXC1_BW_40MHZ;
			} else if (IS_OFDM(rspec)) {
				if (wlc->ofdm_40txbw != AUTO)
					mimo_txbw = wlc->ofdm_40txbw;
			} else {
				ASSERT(IS_CCK(rspec));
				if (wlc->cck_40txbw != AUTO)
					mimo_txbw = wlc->cck_40txbw;
			}
#if SSLPNCONF && !defined(WLC_SPLIT)
			if (!(mimo_txbw & PHY_TXC1_BW_40MHZ))
				bw20_u_l = 1;
#endif
		} else  {
			/* mcs32 is 40 b/w only.
			 * This is possible for probe packets on a STA during SCAN
			 */
			if ((rspec & RSPEC_RATE_MASK) == 32) {
				WL_INFORM(("wl%d: wlc_d11hdrs mcs 32 invalid in 20MHz mode, using"
				           "mcs 0 instead\n", wlc->pub->unit));
				/* mcs 0 */
				rspec = RSPEC_MIMORATE;
			}

			/* Fix fallback as well */
			if ((rspec_fallback & RSPEC_RATE_MASK) == 32)
				rspec_fallback = RSPEC_MIMORATE;

			mimo_txbw = PHY_TXC1_BW_20MHZ;
		}

		rspec &= ~RSPEC_BW_MASK;
		rspec |= (mimo_txbw << RSPEC_BW_SHIFT);

		rspec_fallback &= ~RSPEC_BW_MASK;
		if (IS_MCS(rspec_fallback))
			rspec_fallback |= (mimo_txbw << RSPEC_BW_SHIFT);
		else
			rspec_fallback |= (mimo_ctlchbw << RSPEC_BW_SHIFT);

		if (IS_MCS(rspec) && (wlc->sgi_tx == ON))
			rspec |= RSPEC_SHORT_GI;
		else if (wlc->sgi_tx == OFF)
			rspec &= ~RSPEC_SHORT_GI;

		if (IS_MCS(rspec_fallback) && (wlc->sgi_tx == ON))
			rspec_fallback |= RSPEC_SHORT_GI;
		else if (wlc->sgi_tx == OFF)
			rspec_fallback &= ~RSPEC_SHORT_GI;

		if (WLCISHTPHY(wlc->band)) {
			ASSERT(!(rspec & RSPEC_LDPC_CODING));
			ASSERT(!(rspec_fallback & RSPEC_LDPC_CODING));
			rspec &= ~RSPEC_LDPC_CODING;
			rspec_fallback &= ~RSPEC_LDPC_CODING;
			if (wlc->stf->ldpc_tx == ON ||
			    (SCB_LDPC_CAP(scb) && wlc->stf->ldpc_tx == AUTO)) {
				if (IS_MCS(rspec))
					rspec |= RSPEC_LDPC_CODING;
				if (IS_MCS(rspec_fallback))
					rspec_fallback |= RSPEC_LDPC_CODING;
			}
		}

		mimo_preamble_type = wlc_mimo_preamble_get(wlc, scb);
		if (IS_MCS(rspec)) {
			preamble_type = mimo_preamble_type;
			if (prot->n_cfg == WLC_N_PROTECTION_20IN40 &&
			    RSPEC_IS40MHZ(rspec))
				use_cts = TRUE;

			/* if the mcs is multi stream check if it needs an rts */
			if (!IS_SINGLE_STREAM(rspec & RSPEC_RATE_MASK)) {
				if (scb->ht_mimops_enabled && scb->ht_mimops_rtsmode)
					use_rts = use_mimops_rts = TRUE;
			}

			/* if SGI is selected, then forced mm for single stream */
			if ((rspec & RSPEC_SHORT_GI) && IS_SINGLE_STREAM(rspec & RSPEC_RATE_MASK)) {
				ASSERT(IS_MCS(rspec));
				preamble_type = WLC_MM_PREAMBLE;
			}
		}

		if (IS_MCS(rspec_fallback)) {
			fbr_preamble_type = mimo_preamble_type;

			/* if SGI is selected, then forced mm for single stream */
			if ((rspec_fallback & RSPEC_SHORT_GI) &&
			    IS_SINGLE_STREAM(rspec_fallback & RSPEC_RATE_MASK))
				fbr_preamble_type = WLC_MM_PREAMBLE;
		}
	} else
#endif /* WL11N */
	{
		/* Set ctrlchbw as 20Mhz */
		ASSERT(!IS_MCS(rspec));
		ASSERT(!IS_MCS(rspec_fallback));
		rspec &= ~RSPEC_BW_MASK;
		rspec_fallback &= ~RSPEC_BW_MASK;
		rspec |= (PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT);
		rspec_fallback |= (PHY_TXC1_BW_20MHZ << RSPEC_BW_SHIFT);

#ifdef WL11N
#if NCONF
		/* for nphy, stf of ofdm frames must follow policies */
		if ((WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band)) && IS_OFDM(rspec)) {
			rspec &= ~RSPEC_STF_MASK;
			rspec |= phyctl1_stf << RSPEC_STF_SHIFT;
		}
		if ((WLCISNPHY(wlc->band) || WLCISHTPHY(wlc->band)) && IS_OFDM(rspec_fallback)) {
			rspec_fallback &= ~RSPEC_STF_MASK;
			rspec_fallback |= phyctl1_stf << RSPEC_STF_SHIFT;
		}
#endif /* NCONF */
#endif /* WL11N */
	}

	/* record rate history after the txbw is valid */
	if (rspec_history) {
#ifdef WL11N
		/* store current tx ant config ratesel (ignore probes) */
		if (WLANTSEL_ENAB(wlc) && N_ENAB(wlc->pub) &&
			((frameid & TXFID_RATE_PROBE_MASK) == 0)) {
			wlc_antsel_set_unicast(wlc->asi, antcfg);
		}
#endif

		/* update per bsscfg tx rate */
		bsscfg->txrspec[bsscfg->txrspecidx][0] = rspec;
		bsscfg->txrspec[bsscfg->txrspecidx][1] = (uint8) nfrags;
		bsscfg->txrspecidx = (bsscfg->txrspecidx+1) % NTXRATE;
	}

	/* mimo bw field MUST now be valid in the rspec (it affects duration calculations) */
	rate = RSPEC2RATE(rspec);

#ifdef WLAFTERBURNER
	/* afterburner, turn on/off afterburner based on instantaneous rate */
	if (wlc->afterburner && (type == FC_TYPE_DATA) && !ETHER_ISMULTI(&h->a1)) {
		if (IS_MCS(rspec) || (rate >= wlc->abminrate && IS_OFDM(rspec))) {
			use_afterburner = TRUE;
			use_rts = TRUE;
		}
	}
#endif /* WLAFTERBURNER */

	/* (2) PROTECTION, may change rspec */
	if (((type == FC_TYPE_DATA) || (type == FC_TYPE_MNG)) &&
	    ((phylen > wlc->RTSThresh) || (pkttag->flags & WLF_USERTS)) &&
	    !ETHER_ISMULTI(&h->a1))
		use_rts = TRUE;

	if ((wlc->band->gmode && prot->_g && IS_OFDM(rspec)) ||
	    (N_ENAB(wlc->pub) && IS_MCS(rspec) && prot->n_cfg)) {
		if (nfrags > 1) {
			/* For a frag burst use the lower modulation rates for the entire frag burst
			 * instead of protection mechanisms.
			 * As per spec, if protection mechanism is being used, a fragment sequence
			 * may only employ ERP-OFDM modulation for the final fragment and control
			 * response. (802.11g Sec 9.10) For ease we send the *whole* sequence at the
			 * lower modulation instead of using a higher modulation for the last frag.
			 */

			/* downgrade the rate to CCK or OFDM */
			if (prot->_g) {
				/* Use 11 Mbps as the rate and fallback. We should make sure that if
				 * we are downgrading an OFDM rate to CCK, we should pick a more
				 * robust rate.  6 and 9 Mbps are not usually selected by rate
				 * selection, but even if the OFDM rate we are downgrading is 6 or 9
				 * Mbps, 11 Mbps is more robust.
				 */
				rspec = rspec_fallback = WLC_RATE_11M;
			} else {
				/* Use 24 Mbps as the rate and fallback for what would have been
				 * a MIMO rate. 24 Mbps is the highest phy mandatory rate for OFDM.
				 */
				rspec = rspec_fallback = WLC_RATE_24M;
			}
			pkttag->flags &= ~WLF_RATE_AUTO;
#ifdef NCONF
			if (WLC_PHY_11N_CAP(wlc->band))
				/* need to set tx bw again */
				rspec = rspec_fallback |= (mimo_ctlchbw << RSPEC_BW_SHIFT);
#endif /* NCONF */
		} else {
			/* Use protection mechanisms on unfragmented frames */
			/* If this is a 11g protection, then use CTS-to-self */
			if (wlc->band->gmode && prot->_g && !IS_CCK(rspec))
				use_cts = TRUE;
		}
	}

	/* calculate minimum rate */
	ASSERT(RSPEC2KBPS(rspec_fallback) <= RSPEC2KBPS(rspec));
	ASSERT(VALID_RATE_DBG(wlc, rspec));
	ASSERT(VALID_RATE_DBG(wlc, rspec_fallback));

	if (IS_CCK(rspec)) {
		if (short_preamble &&
		    !((RSPEC2RATE(rspec) == WLC_RATE_1M) ||
		      (scb->bsscfg->PLCPHdr_override == WLC_PLCP_LONG)))
			preamble_type = WLC_SHORT_PREAMBLE;
		else
			preamble_type = WLC_LONG_PREAMBLE;
	}

	if (IS_CCK(rspec_fallback)) {
		if (short_preamble &&
		    !((RSPEC2RATE(rspec_fallback) == WLC_RATE_1M) ||
		      (scb->bsscfg->PLCPHdr_override == WLC_PLCP_LONG)))
			fbr_preamble_type = WLC_SHORT_PREAMBLE;
		else
			fbr_preamble_type = WLC_LONG_PREAMBLE;
	}

	ASSERT(!IS_MCS(rspec) || WLC_IS_MIMO_PREAMBLE(preamble_type));
	ASSERT(!IS_MCS(rspec_fallback) || WLC_IS_MIMO_PREAMBLE(fbr_preamble_type));

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		WLPKTTAG(p)->rspec = ((rspec_fallback & RSPEC_RATE_MASK) |
		                      ((rspec & RSPEC_RATE_MASK) << 16));
#endif

	WLCNTSCB_COND_SET(type == FC_TYPE_DATA, scb->scb_stats.tx_rate, rspec);

	/* RIFS(testing only): based on frameburst, non-CCK frames only */
	if (SCB_HT_CAP(scb) && wlc->frameburst && wlc->_rifs &&
	    prot->n_cfg != WLC_N_PROTECTION_MIXEDMODE && !IS_CCK(rspec) &&
	    !ETHER_ISMULTI(&h->a1) && ((fc & FC_KIND_MASK) == FC_QOS_DATA)) {
		uint16 qos_field, *pqos;

		WLPKTTAG(p)->flags |= WLF_RIFS;
		mcl |= (TXC_FRAMEBURST | TXC_USERIFS);
		use_rifs = TRUE;

		/* RIFS implies QoS frame with no-ack policy, hack the QoS field */
		pqos = (uint16 *)((uchar *)h + ((SCB_WDS(scb) != 0) ?
			DOT11_A4_HDR_LEN : DOT11_A3_HDR_LEN));
		qos_field = ltoh16(*pqos) & ~QOS_ACK_MASK;
		qos_field |= (QOS_ACK_NO_ACK << QOS_ACK_SHIFT) & QOS_ACK_MASK;
		*pqos = htol16(qos_field);
	}

	/* (3) PLCP: determine PLCP header and MAC duration, fill d11txh_t */

	wlc_compute_plcp(wlc, rspec, phylen, plcp);
	wlc_compute_plcp(wlc, rspec_fallback, phylen, plcp_fallback);
	bcopy(plcp_fallback, (char*)&txh->FragPLCPFallback, sizeof(txh->FragPLCPFallback));

	/* Length field now put in CCK FBR CRC field for AES */
	if (IS_CCK(rspec_fallback)) {
		txh->FragPLCPFallback[4] = phylen & 0xff;
		txh->FragPLCPFallback[5] = (phylen & 0xff00) >> 8;
	}

#ifdef WLAMPDU
	/* mark pkt as aggregable if it is */
	if (WLPKTFLAG_AMPDU(pkttag) && IS_MCS(rspec)) {
		if (!key || (key->algo == CRYPTO_ALGO_AES_CCM) ||
#ifdef BCMWAPI_WPI
		    (key->algo == CRYPTO_ALGO_SMS4) ||
#endif
		    FALSE) {
			WLPKTTAG(p)->flags |= WLF_MIMO;
			if (wlc->ampdu_rts)
				use_rts = TRUE;
		}
	}
#endif /* WLAMPDU */

	/* MIMO-RATE: need validation ?? */
	mainrates = IS_OFDM(rspec) ? D11A_PHY_HDR_GRATE((ofdm_phy_hdr_t *)plcp) : plcp[0];

	/* DUR field for main rate */
	if ((fc != FC_PS_POLL) &&
#ifdef WLAFTERBURNER
	    !use_afterburner &&
#endif
	    !ETHER_ISMULTI(&h->a1) && !use_rifs) {
		durid = wlc_compute_frame_dur(wlc, rspec, preamble_type, next_frag_len);
		h->durid = htol16(durid);
	}
	else if (use_rifs) {
		/* NAV protect to end of next max packet size */
		durid = (uint16)wlc_calc_frame_time(wlc, rspec, preamble_type, DOT11_MAX_FRAG_LEN);
		durid += RIFS_11N_TIME;
		h->durid = htol16(durid);
	}

	/* DUR field for fallback rate */
	if (fc == FC_PS_POLL)
		txh->FragDurFallback = h->durid;
	else if (ETHER_ISMULTI(&h->a1) || use_rifs)
		txh->FragDurFallback = 0;
	else {
		durid = wlc_compute_frame_dur(wlc, rspec_fallback,
		                              fbr_preamble_type, next_frag_len);
		txh->FragDurFallback = htol16(durid);
	}

	/* Timestamp */
	if ((pkttag->flags & WLF_EXPTIME)) {
		txh->TstampLow = htol16(pkttag->exptime & 0xffff);
		txh->TstampHigh = htol16((pkttag->exptime >> 16) & 0xffff);

		mcl |= TXC_LIFETIME;	/* Enable timestamp for the packet */
	}

	/* (4) MAC-HDR: MacTxControlLow */
	if (frag == 0)
		mcl |= TXC_STARTMSDU;

	if (!ETHER_ISMULTI(&h->a1) && !WLPKTFLAG_BA(pkttag) && !WLPKTFLAG_RIFS(pkttag) &&
	    !(wlc->_amsdu_noack && WLPKTFLAG_AMSDU(pkttag)) && !(!WLPKTFLAG_AMPDU(pkttag) &&
		qos && wlc->wme_noack))
		mcl |= TXC_IMMEDACK;

	if (type == FC_TYPE_DATA) {
		if ((wlc->frameburst && (rate > WLC_FRAMEBURST_MIN_RATE) &&
#ifdef WLAMPDU
			(wlc_ampdu_frameburst_override(wlc->ampdu) == FALSE) &&
#endif
			(!wlc->edcf_txop[wme_fifo2ac[queue]] || WLPKTFLAG_AMPDU(pkttag))) ||
#ifdef WLBTAMP
		      wlc_bta_frameburst_active(wlc->bta, pkttag, rate) ||
#endif
#ifdef WLAFTERBURNER
		    use_afterburner ||
#endif
		    FALSE)
#ifdef WL11N
			/* dont allow bursting if rts is required around each mimo frame */
			if (use_mimops_rts == FALSE)
#endif
				mcl |= TXC_FRAMEBURST;
	}

	if (BAND_5G(wlc->band->bandtype))
		mcl |= TXC_FREQBAND_5G;

	if (CHSPEC_IS40(WLC_BAND_PI_RADIO_CHANSPEC))
		mcl |= TXC_BW_40;

	/* set AMIC bit if using hardware TKIP MIC */
	if (hwtkmic)
		mcl |= TXC_AMIC;

	txh->MacTxControlLow = htol16(mcl);

	/* MacTxControlHigh */
	mch = 0;
#ifdef LINUX_CRYPTO
	if (key && (key->algo != CRYPTO_ALGO_TKIP))
#else
	if (key && !(WSEC_SOFTKEY(wlc, key, bsscfg) || WLPKTFLAG_PMF(WLPKTTAG(p))))
#endif
	{
		mch |= ((WSEC_KEY_INDEX(wlc, key) << TXC_SECKEY_SHIFT) & TXC_SECKEY_MASK);
		mch |= ((key->algo_hw << TXC_SECTYPE_SHIFT) & TXC_SECTYPE_MASK);
		WL_WSEC(("wl%d.%d: wlc_d11hdrs: setting key info in mch: index %d type %d\n",
		         wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg),
			(mch & TXC_SECKEY_MASK) >> TXC_SECKEY_SHIFT, mch & TXC_SECTYPE_MASK));
	}

#ifdef WLBTAMP
	/* use short range mode txpwr at 4dbm */
	if (pkttag->flags & WLF_BTA_SRM)
		mch |= TXC_ALT_TXPWR;
#endif
	/* Set fallback rate preamble type */
	if ((fbr_preamble_type == WLC_SHORT_PREAMBLE) ||
	    (fbr_preamble_type == WLC_GF_PREAMBLE)) {
		ASSERT((fbr_preamble_type == WLC_GF_PREAMBLE) ||
		       (!IS_MCS(rspec_fallback)));
		mch |= TXC_PREAMBLE_DATA_FB_SHORT;
	}

	/* MacFrameControl */
	bcopy((char*)&h->fc, (char*)&txh->MacFrameControl, sizeof(uint16));

	txh->TxFesTimeNormal = htol16(0);

	txh->TxFesTimeFallback = htol16(0);

	/* SecurityInitVector (IV) */
#ifdef LINUX_CRYPTO
	if (key && (key->algo != CRYPTO_ALGO_TKIP))
#else
	if (key && !(WSEC_SOFTKEY(wlc, key, bsscfg) || WLPKTFLAG_PMF(WLPKTTAG(p))))
#endif
	{
		bool wds = (fc & (FC_TODS | FC_FROMDS)) == (FC_TODS | FC_FROMDS);
		char *IV;

		IV = (char*)h + DOT11_A3_HDR_LEN;
		if (wds)
			IV += ETHER_ADDR_LEN;
		if (qos)
			IV += DOT11_QOS_LEN;

		if (key->algo == CRYPTO_ALGO_TKIP) {
#ifndef LINUX_CRYPTO
			union {
				uint16 u16;
				uint8  u8[2];
			} u;
			int i = 0, j = 0;

			do {
				u.u16 = htol16(key->tkip_tx.phase1[i]);
				txh->IV[j++] = u.u8[0];
				txh->IV[j++] = u.u8[1];
			} while (++i < TKHASH_P1_KEY_SIZE/2);
			bcopy(IV, (char*)&txh->IV[TKHASH_P1_KEY_SIZE], 3);
#endif /* LINUX_CRYPTO */
#ifdef BCMWAPI_WPI
		} else if (key->algo == CRYPTO_ALGO_SMS4) {
			struct wpi_iv *wpi_iv;
			/* WAPI */
			wpi_iv = (struct wpi_iv *)IV;
			bcopy(&wpi_iv->PN[0], (char*)txh->IV, SMS4_WPI_PN_LEN);
#endif /* BCMWAPI_WPI */
		} else {
			/* WEP and AES */
			bcopy(IV, (char*)txh->IV, key->iv_len);
			/* Ignore upper 12 IV bytes */
		}
	}

	/* TxFrameRA */
	bcopy((char*)&h->a1, (char*)&txh->TxFrameRA, ETHER_ADDR_LEN);

	/* TxFrameID */
	txh->TxFrameID = htol16(frameid);

#ifdef WL11N
	/* Set tx antenna configuration for all transmissions */
	if (WLANTSEL_ENAB(wlc)) {
		if (antcfg == ANTCFG_NONE) {
			/* use tx antcfg default */
			wlc_antsel_antcfg_get(wlc->asi, TRUE, FALSE, 0, 0, &antcfg, &fbantcfg);
		}
		mimoantsel = wlc_antsel_buildtxh(wlc->asi, antcfg, fbantcfg);
		txh->ABI_MimoAntSel = htol16(mimoantsel);
	}
#endif /* WL11N */

#ifdef WLP2P
	if (P2P_ENAB(wlc->pub)) {
		uint16 addr_bmp_idx = (uint16)wlc_p2p_d11ab_idx(wlc->p2p, bsscfg);
		ASSERT(addr_bmp_idx < M_ADDR_BMP_BLK_SZ);
		txh->ABI_MimoAntSel |= htol16(addr_bmp_idx <<ABI_MAS_ADDR_BMP_IDX_SHIFT);
	}
#endif

	/* TxStatus, Note the case of recreating the first frag of a suppressed frame
	 * then we may need to reset the retry cnt's via the status reg
	 */
	txh->TxStatus = htol16(status);

	if (D11REV_GE(wlc->pub->corerev, 16)) {
		/* extra fields for ucode AMPDU aggregation, the new fields are added to
		 * the END of previous structure so that it's compatible in driver.
		 * In old rev ucode, these fields should be ignored
		 */
		txh->MaxNMpdus = htol16(0);
		txh->u1.MaxAggDur = htol16(0);
		txh->u2.MaxRNum = htol16(0);
		txh->MinMBytes = htol16(0);
	}

	/* (5) RTS/CTS: determine RTS/CTS PLCP header and MAC duration, furnish d11txh_t */

	/* RTS PLCP header and RTS frame */
	if (use_rts || use_cts) {
		if (use_rts && use_cts)
			use_cts = FALSE;

#ifdef NOT_YET
		if (SCB_ISGF_CAP(scb)) {
			hdr_mcs_mixedmode = FALSE;
			hdr_cckofdm_shortpreamble = TRUE;
		}
#endif /* NOT_YET */


#ifdef WLAFTERBURNER
		rts_rspec = wlc_rspec_to_rts_rspec(bsscfg, rspec,
			use_afterburner && use_rts, mimo_ctlchbw);
		rts_rspec_fallback = wlc_rspec_to_rts_rspec(bsscfg, rspec_fallback,
			use_afterburner && use_rts, mimo_ctlchbw);
#else
		rts_rspec = wlc_rspec_to_rts_rspec(bsscfg, rspec,
			FALSE, mimo_ctlchbw);
		rts_rspec_fallback = wlc_rspec_to_rts_rspec(bsscfg, rspec_fallback,
			FALSE, mimo_ctlchbw);
#endif /* WLAFTERBURNER */

		if (!IS_OFDM(rts_rspec) &&
		    !((RSPEC2RATE(rts_rspec) == WLC_RATE_1M) ||
		      (scb->bsscfg->PLCPHdr_override == WLC_PLCP_LONG))) {
			rts_preamble_type = WLC_SHORT_PREAMBLE;
			mch |= TXC_PREAMBLE_RTS_MAIN_SHORT;
		}

		if (!IS_OFDM(rts_rspec_fallback) &&
		    !((RSPEC2RATE(rts_rspec_fallback) == WLC_RATE_1M) ||
		      (scb->bsscfg->PLCPHdr_override == WLC_PLCP_LONG))) {
			rts_fbr_preamble_type = WLC_SHORT_PREAMBLE;
			mch |= TXC_PREAMBLE_RTS_FB_SHORT;
		}

		/* RTS/CTS additions to MacTxControlLow */
		if (use_cts) {
			txh->MacTxControlLow |= htol16(TXC_SENDCTS);
		} else {
			txh->MacTxControlLow |= htol16(TXC_SENDRTS);
			txh->MacTxControlLow |= htol16(TXC_LONGFRAME);
		}

		/* RTS PLCP header */
		ASSERT(ISALIGNED((uintptr)txh->RTSPhyHeader, sizeof(uint16)));
		rts_plcp = txh->RTSPhyHeader;
		if (use_cts)
			rts_phylen = DOT11_CTS_LEN + DOT11_FCS_LEN;
		else
			rts_phylen = DOT11_RTS_LEN + DOT11_FCS_LEN;

		wlc_compute_plcp(wlc, rts_rspec, rts_phylen, rts_plcp);

		/* fallback rate version of RTS PLCP header */
		wlc_compute_plcp(wlc, rts_rspec_fallback, rts_phylen, rts_plcp_fallback);
		bcopy(rts_plcp_fallback, (char*)&txh->RTSPLCPFallback,
			sizeof(txh->RTSPLCPFallback));

		/* RTS frame fields... */
		rts = (struct dot11_rts_frame*)&txh->rts_frame;

#ifdef WLAFTERBURNER
		if (!use_afterburner) {
#endif /* WLAFTERBURNER */
			durid = wlc_compute_rtscts_dur(wlc, use_cts, rts_rspec,
			        rspec, rts_preamble_type, preamble_type, phylen, FALSE);
			rts->durid = htol16(durid);
#ifdef WLAFTERBURNER
		}
#endif /* WLAFTERBURNER */
		/* fallback rate version of RTS DUR field */
		durid = wlc_compute_rtscts_dur(wlc, use_cts,
		        rts_rspec_fallback, rspec_fallback, rts_fbr_preamble_type,
		        fbr_preamble_type, phylen, FALSE);
		txh->RTSDurFallback = htol16(durid);

		if (use_cts) {
			rts->fc = htol16(FC_CTS);
			bcopy((char*)&h->a2, (char*)&rts->ra, ETHER_ADDR_LEN);
		} else {
#ifdef WLAFTERBURNER
			/* indicate ack/nak policy in afterburner via rts fc order bit */
			rts->fc = use_afterburner ? htol16((uint16)(FC_RTS | FC_ORDER)) :
				htol16((uint16)FC_RTS);
#else
			rts->fc = htol16((uint16)FC_RTS);
#endif /* WLAFTERBURNER */
			bcopy((char*)&h->a1, (char*)&rts->ra, 2*ETHER_ADDR_LEN);
		}

		/* mainrate
		 *    low 8 bits: main frag rate/mcs,
		 *    high 8 bits: rts/cts rate/mcs
		 */
		mainrates |= (IS_OFDM(rts_rspec) ?
			D11A_PHY_HDR_GRATE((ofdm_phy_hdr_t *)rts_plcp) : rts_plcp[0]) << 8;
	} else {
		bzero((char*)txh->RTSPhyHeader, D11_PHY_HDR_LEN);
		bzero((char*)&txh->rts_frame, sizeof(struct dot11_rts_frame));
		bzero((char*)txh->RTSPLCPFallback, sizeof(txh->RTSPLCPFallback));
		txh->RTSDurFallback = 0;
	}

#ifdef WLAMPDU
	/* add null delimiter count */
	if (WLPKTFLAG_AMPDU(pkttag) && IS_MCS(rspec)) {
		uint16 minbytes = 0;
		txh->RTSPLCPFallback[AMPDU_FBR_NULL_DELIM] =
			wlc_ampdu_null_delim_cnt(wlc->ampdu, scb, rspec, phylen, &minbytes);
#ifdef WLAMPDU_HW
		if (AMPDU_HW_ENAB(wlc->pub))
			txh->MinMBytes = htol16(minbytes);
#endif
	}
#endif /* WLAMPDU */

	/* Now that RTS/RTS FB preamble types are updated, write the final value */
	txh->MacTxControlHigh = htol16(mch);

	/* MainRates (both the rts and frag plcp rates have been calculated now) */
	txh->MainRates = htol16(mainrates);

	/* XtraFrameTypes */
	xfts = FRAMETYPE(rspec_fallback, wlc->mimoft);
	xfts |= (FRAMETYPE(rts_rspec, wlc->mimoft) << XFTS_RTS_FT_SHIFT);
	xfts |= (FRAMETYPE(rts_rspec_fallback, wlc->mimoft) << XFTS_FBRRTS_FT_SHIFT);
	xfts |= CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC) << XFTS_CHANNEL_SHIFT;
	txh->XtraFrameTypes = htol16(xfts);

	/* PhyTxControlWord */
	phyctl = FRAMETYPE(rspec, wlc->mimoft);
	if ((preamble_type == WLC_SHORT_PREAMBLE) ||
	    (preamble_type == WLC_GF_PREAMBLE)) {
		ASSERT((preamble_type == WLC_GF_PREAMBLE) || !IS_MCS(rspec));
		phyctl |= PHY_TXC_SHORT_HDR;
		WLCNTINCR(wlc->pub->_cnt->txprshort);
	}

	/* phytxant is properly bit shifted */
	phyctl |= wlc_stf_d11hdrs_phyctl_txant(wlc, rspec);
	txh->PhyTxControlWord = htol16(phyctl);
	if (WLCISNPHY(wlc->band) && (wlc->pub->sromrev >= 9)) {
		uint8 rate_offset;
		uint16 minbytes;
		rate_offset = wlc_stf_get_pwrperrate(wlc, rspec, RSPEC_GET_BW(rspec), 0);
		phyctl |= (rate_offset <<  PHY_TXC_PWR_SHIFT);
		rate_offset = wlc_stf_get_pwrperrate(wlc, rspec_fallback,
		                                     RSPEC_GET_BW(rspec_fallback), 0);
		minbytes = ltoh16(txh->MinMBytes);
		minbytes |= (rate_offset << MINMBYTES_FBRATE_PWROFFSET_SHIFT);
		txh->MinMBytes = htol16(minbytes);
		txh->PhyTxControlWord = htol16(phyctl);
	}

	/* PhyTxControlWord_1 */
	if (WLC_PHY_11N_CAP(wlc->band) || WLCISLPPHY(wlc->band)) {
		uint16 phyctl1 = 0;

		phyctl1 = wlc_phytxctl1_calc(wlc, rspec);
		txh->PhyTxControlWord_1 = htol16(phyctl1);
		phyctl1 = wlc_phytxctl1_calc(wlc, rspec_fallback);
		txh->PhyTxControlWord_1_Fbr = htol16(phyctl1);

		if (use_rts || use_cts) {
			phyctl1 = wlc_phytxctl1_calc(wlc, rts_rspec);
			txh->PhyTxControlWord_1_Rts = htol16(phyctl1);
			phyctl1 = wlc_phytxctl1_calc(wlc, rts_rspec_fallback);
			txh->PhyTxControlWord_1_FbrRts = htol16(phyctl1);
		}

		/*
		 * For mcs frames, if mixedmode(overloaded with long preamble) is going to be set,
		 * fill in non-zero MModeLen and/or MModeFbrLen
		 *  it will be unnecessary if they are separated
		 */
		if (IS_MCS(rspec) && (preamble_type == WLC_MM_PREAMBLE)) {
			uint16 mmodelen = wlc_calc_lsig_len(wlc, rspec, phylen);
			txh->MModeLen = htol16(mmodelen);
		}

		if (IS_MCS(rspec_fallback) && (fbr_preamble_type == WLC_MM_PREAMBLE)) {
			uint16 mmodefbrlen = wlc_calc_lsig_len(wlc, rspec_fallback, phylen);
			txh->MModeFbrLen = htol16(mmodefbrlen);
		}
	}

	ASSERT(!IS_MCS(rspec) ||
	       ((preamble_type == WLC_MM_PREAMBLE) == (txh->MModeLen != 0)));
	ASSERT(!IS_MCS(rspec_fallback) ||
	       ((fbr_preamble_type == WLC_MM_PREAMBLE) == (txh->MModeFbrLen != 0)));

#if SSLPNCONF && !defined(WLC_SPLIT)
	if (WLCISSSLPNPHY(wlc->band)) {
		mcs_adjustment = 0;
		if (IS_MCS(rspec)) {
			legacy_pwr_this_rate = wlc_phy_get_tx_power_offset(wlc->band->pi,
				(rspec & RSPEC_RATE_MASK));
			mcs_pwr_this_rate = wlc_phy_get_tx_power_offset_by_mcs(wlc->band->pi,
				(rspec & RSPEC_RATE_MASK));

			mcs_adjustment = legacy_pwr_this_rate - mcs_pwr_this_rate;

			if (mcs_adjustment > 31)
				mcs_adjustment = 31;

			if (mcs_adjustment < -32)
				mcs_adjustment = -32;

			if (bw20_u_l)
				mcs_adjustment = mcs_adjustment + 32;

		} else if (bw20_u_l && IS_OFDM(rspec)) {
			mcs_adjustment = 32;
		}

		phyctl = (phyctl & ~PHY_TXC_PWR_MASK) | ((mcs_adjustment << 10) & PHY_TXC_PWR_MASK);
		txh->PhyTxControlWord = htol16(phyctl);

	}
#endif /* SSLPNCONF */

	if (SCB_WME(scb) && qos && wlc->edcf_txop[(ac = wme_fifo2ac[queue])]) {
		uint frag_dur, dur, dur_fallback;

		ASSERT(!ETHER_ISMULTI(&h->a1));

		/* WME: Update TXOP threshold */
		if ((!WLPKTFLAG_AMPDU(pkttag)) && (frag == 0)) {

			frag_dur = wlc_calc_frame_time(wlc, rspec, preamble_type, phylen);

			if (rts) {
				/* 1 RTS or CTS-to-self frame */
				dur = wlc_calc_cts_time(wlc, rts_rspec, rts_preamble_type);
				dur_fallback = wlc_calc_cts_time(wlc, rts_rspec_fallback,
				                                 rts_fbr_preamble_type);
				/* (SIFS + CTS) + SIFS + frame + SIFS + ACK */
				dur += ltoh16(rts->durid);
				dur_fallback += ltoh16(txh->RTSDurFallback);
			} else if (use_rifs) {
				dur = frag_dur;
				dur_fallback = 0;
			} else {
				/* frame + SIFS + ACK */
				dur = frag_dur;
				dur += wlc_compute_frame_dur(wlc, rspec, preamble_type, 0);

				dur_fallback = wlc_calc_frame_time(wlc, rspec_fallback,
				               fbr_preamble_type, phylen);
				dur_fallback += wlc_compute_frame_dur(wlc, rspec_fallback,
				                                      fbr_preamble_type, 0);
			}
			/* NEED to set TxFesTimeNormal (hard) */
			txh->TxFesTimeNormal = htol16((uint16)dur);
			/* NEED to set fallback rate version of TxFesTimeNormal (hard) */
			txh->TxFesTimeFallback = htol16((uint16)dur_fallback);

			/* update txop byte threshold (txop minus intraframe overhead) */
			if (wlc->edcf_txop[ac] >= (dur - frag_dur)) {
#ifdef WLAMSDU
				if (WLPKTFLAG_AMSDU(pkttag) && (queue == TX_AC_BE_FIFO)) {
					WL_ERROR(("edcf_txop changed, update AMSDU\n"));
					wlc_amsdu_txop_upd(wlc->ami);
				} else
#endif
				{
					uint newfragthresh;

					newfragthresh = wlc_calc_frame_len(wlc, rspec,
					                preamble_type,
					                (wlc->edcf_txop[ac] - (dur - frag_dur)));
					/* range bound the fragthreshold */
					if (newfragthresh < DOT11_MIN_FRAG_LEN)
						newfragthresh = DOT11_MIN_FRAG_LEN;
					else if (newfragthresh > wlc->usr_fragthresh)
						newfragthresh = wlc->usr_fragthresh;
					/* update the fragthresh and do txc update */
					if (wlc->fragthresh[queue] != (uint16)newfragthresh) {
						wlc->fragthresh[queue] = (uint16)newfragthresh;
						if (WLC_TXC_ENAB(wlc))
							wlc_txc_upd(wlc);
					}
				}
			} else
				WL_ERROR(("wl%d: %s txop invalid for rate %d\n",
					wlc->pub->unit, fifo_names[queue], RSPEC2RATE(rspec)));

			if (CAC_ENAB(wlc->pub) &&
				queue <= TX_AC_VO_FIFO) {
				/* update cac used time */
				if (wlc_cac_update_used_time(wlc->cac, ac, dur, scb))
					WL_ERROR(("wl%d: ac %d: txop exceeded allocated TS time\n",
						wlc->pub->unit, ac));
			}

			if (dur > wlc->edcf_txop[ac])
				WL_ERROR(("wl%d: %s txop exceeded phylen %d/%d dur %d/%d\n",
					wlc->pub->unit, fifo_names[queue], phylen,
					wlc->fragthresh[queue], dur, wlc->edcf_txop[ac]));
		}
		else if (CAC_ENAB(wlc->pub) &&
			queue <= TX_AC_VO_FIFO) {
			if (rts) {
				/* 1 RTS or CTS-to-self frame */
				dur = wlc_calc_cts_time(wlc, rts_rspec, rts_preamble_type);
				/* (SIFS + CTS) + SIFS + frame + SIFS + ACK */
				dur += ltoh16(rts->durid);
			} else {
				/* frame + SIFS + ACK */
				dur = wlc_calc_frame_time(wlc, rspec, preamble_type, phylen);
				dur += wlc_compute_frame_dur(wlc, rspec, preamble_type, 0);
			}

			/* update cac used time */
			if (wlc_cac_update_used_time(wlc->cac, ac, dur, scb))
				WL_ERROR(("wl%d: ac %d: txop exceeded allocated TS time\n",
					wlc->pub->unit, ac));
		}
	}

	/* With d11 hdrs on, mark the packet as MPDU with txhdr */
	WLPKTTAG(p)->flags |= (WLF_MPDU | WLF_TXHDR);

	WL_PRHDRS(wlc, "txpkt hdr (MPDU)", (uint8*)plcp, txh, NULL, PKTLEN(osh, p));
	WL_PRPKT("txpkt body (MPDU)", (uchar *)txh, PKTLEN(osh, p));

	return (frameid);
}


/* Do multicast filtering
 * returns TRUE on success (reject/filter frame).
 */
static bool
wlc_bsscfg_mcastfilter(wlc_bsscfg_t *cfg, struct dot11_header *h)
{
	unsigned int i;

	for (i = 0; i < cfg->nmulticast; i++) {
		if (bcmp((void*)&(h->a1), (void*)&cfg->multicast[i],
			ETHER_ADDR_LEN) == 0)
			return FALSE;
	}

	return TRUE;
}

void
wlc_lq_rssi_init(wlc_info_t *wlc, int rssi)
{
	uint i, k, max_ant;

	/* legacy PHY */
	max_ant = (uint8)WLC_BITSCNT(wlc->stf->hw_rxchain);
	ASSERT(max_ant <= (uint32)(WLCISHTPHY(wlc->band) ? WL_ANT_HT_RX_MAX : WL_ANT_RX_MAX));
	for (i = 0; i < WLC_RSSI_WINDOW_SZ; i++) {
		for (k = WL_ANT_IDX_1; k < max_ant; k++) {
			if (((wlc->stf->rxchain >> k) & 1) == 0)
				continue;
			wlc->rssi_win_rfchain[k][i] = (int16)rssi;
		}
	}
	wlc->rssi_win_rfchain_idx = 0;
}

/* Reset RSSI moving average */
void
wlc_lq_rssi_reset_ma(wlc_bsscfg_t *cfg, int rssi)
{
	int i;
	wlc_link_qual_t *link = cfg->link;

	link->rssi_pkt_tot = 0;
	link->rssi_pkt_count = 0;
	for (i = 0; i < MA_WINDOW_SZ; i++)
		link->rssi_pkt_window[i] = 0;
	link->rssi_pkt_index = 0;

	link->rssi = rssi;
}

static void
wlc_rssi_ant_get(wlc_info_t *wlc, int8 *rssi)
{
	uint32 i, k, chains, idx;
	/* use int32 to avoid overflow when accumulate int8 */
	int32 rssi_sum[WL_RSSI_ANT_MAX] = {0, 0, 0, 0};

	idx = wlc->rssi_win_rfchain_idx;

	chains = (uint8)WLC_BITSCNT(wlc->stf->hw_rxchain);
	ASSERT(chains <= (uint32)(WLCISHTPHY(wlc->band) ? WL_ANT_HT_RX_MAX : WL_ANT_RX_MAX));
	for (i = 0; i < WLC_RSSI_WINDOW_SZ; i++) {
		for (k = WL_ANT_IDX_1; k < chains; k++) {
			if (((wlc->stf->rxchain >> k) & 1) == 0)
				continue;
			rssi_sum[k] += wlc->rssi_win_rfchain[k][idx];
		}
		idx = MODINC_POW2(idx, WLC_RSSI_WINDOW_SZ);
	}

	for (k = WL_ANT_IDX_1; k < chains; k++) {
		rssi[k] = (int8)(rssi_sum[k] / WLC_RSSI_WINDOW_SZ);
	}
}

int
wlc_lq_rssi_update_ma(wlc_bsscfg_t *cfg, int nval)
{
	wlc_link_qual_t *link = cfg->link;
#ifdef DOS
	link->rssi = nval;
	return nval;
#endif

	if (nval != WLC_RSSI_INVALID) {
		/* evict old value */
		link->rssi_pkt_tot -= link->rssi_pkt_window[link->rssi_pkt_index];

		/* admit new value */
		link->rssi_pkt_tot += nval;
		link->rssi_pkt_window[link->rssi_pkt_index] = nval;
		link->rssi_pkt_index = MODINC_POW2(link->rssi_pkt_index,
			link->rssi_pkt_win_sz);
		if (link->rssi_pkt_count < link->rssi_pkt_win_sz)
			link->rssi_pkt_count++;
	}

	if (link->rssi_pkt_count == 0)
		link->rssi = WLC_RSSI_INVALID;
	else
		link->rssi = (link->rssi_pkt_tot / link->rssi_pkt_count);

	return link->rssi;
}


#ifdef STA
static int
wlc_phy_update_snr_ma(wlc_bsscfg_t *cfg, int nval)
{
	wlc_link_qual_t *link = cfg->link;
#ifdef DOS
	link->snr = nval;
	return nval;
#endif

	if (nval != WLC_SNR_INVALID) {
		/* evict old value */
		link->snr_ma -= (int32)link->snr_window[link->snr_index];

		/* admit new value */
		link->snr_ma += (int32)nval;
		link->snr_window[link->snr_index] = (uint8)nval;
		link->snr_index = MODINC_POW2(link->snr_index, MA_WINDOW_SZ);

		if (link->snr_no_of_valid_values < MA_WINDOW_SZ) {
			link->snr_no_of_valid_values++;
		}
	}

	if (link->snr_no_of_valid_values > 0) {
		link->snr = ((link->snr_ma+(link->snr_no_of_valid_values>>1)) /
			link->snr_no_of_valid_values);
	}
	else
		link->snr = WLC_SNR_INVALID;

	return link->snr;
}
#endif /* #ifdef STA */

/* The rssi compute is done in low level driver and embedded in the rx pkt in wlc_d11rxhdr,
 * per-antenna rssi are also embedded in wlc_d11rxhdr for moving average cal here
 */
int8
wlc_lq_rssi_pktrxh_cal(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh)
{
	int i, max_ant;

	max_ant = (uint8)WLC_BITSCNT(wlc->stf->hw_rxchain);
	ASSERT(max_ant <= (WLCISHTPHY(wlc->band) ? WL_ANT_HT_RX_MAX : WL_ANT_RX_MAX));
	if (!wrxh->do_rssi_ma && wrxh->rssi != WLC_RSSI_INVALID) {
		/* go through all valid antennas */
		for (i = WL_ANT_IDX_1; i < max_ant; i++) {
			if (((wlc->stf->rxchain >> i) & 1) == 0)
				continue;
			wlc->rssi_win_rfchain[i][wlc->rssi_win_rfchain_idx] = wrxh->rxpwr[i];
		}

		wlc->rssi_win_rfchain_idx = MODINC_POW2(wlc->rssi_win_rfchain_idx,
			WLC_RSSI_WINDOW_SZ);
		wrxh->do_rssi_ma = 1;
	}

	return wrxh->rssi;
}

/*
This function returns SNR during the recently received frame.
SNR is computed by PHY during frame reception and keeps it in the
D11 frame header. This function reads that value from the D11 frame header
and returns it.
For CCK frame SNR in the D11 frame is in dB in Q.2 format.
For OFDM frames SNR in the D11 frame is 9.30139866 * SNR dB in Q.0 format.
This function returns the SNR for both the frames in dB in Q.0 format.
Brief documentation is available about signalQuality parameter in D11 frame is
available at http://hwnbu-twiki.broadcom.com/bin/view/Mwgroup/MAC-PhyInterface.
*/
#ifdef STA
static int
wlc_recv_snr_compute(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh)
{
	int frameType;
	int signalQuality, snr = WLC_SNR_INVALID;
	int32 snr32;
	int16 multiplication_coefficient;

	if (WLCISLPPHY(wlc->band)) {
		frameType = wrxh->rxhdr.PhyRxStatus_0 & PRXS0_FT_MASK;
		signalQuality = wrxh->rxhdr.PhyRxStatus_1 & PRXS1_SQ_MASK;
		signalQuality = signalQuality >> PRXS1_SQ_SHIFT;
		if (frameType == PRXS0_CCK) {
			snr = signalQuality;		/* Q.2 format */
			snr = ((snr + 2) >> 2);		/* bring to Q.0 format and round */
		}
		else {
			/* signalQuality = 9.30139866 * SNR dB. So convert it into
			* SNR in db at Q.0 format.
			*/
			multiplication_coefficient = (int16)((1.0/9.30139866) * (1<<18)); /* Q.18 */
			snr32 = signalQuality * multiplication_coefficient;	/* snr dB in Q.18 */
			snr = (snr32 + (1 << 17)) >> 18;		/* snr in dB in Q.0 */
		}
	}

	/* return SNR */
	return snr;
}
#endif /* #ifdef STA */

void BCMFASTPATH
wlc_recvdata(wlc_info_t *wlc, osl_t *osh, wlc_d11rxhdr_t *wrxh, void *p)
{
	d11rxhdr_t *rxh = &wrxh->rxhdr;
	uchar *plcp;
	uint min_len;
	bool promisc_frame = FALSE;
	struct scb *scb = NULL;
	struct wlc_frminfo f;	/* frame info to be passed to intermediate functions */
	uint offset;
#ifdef BCMDBG_ERR
	char eabuf[ETHER_ADDR_STR_LEN];
#endif
	wlc_pkttag_t *pkttag;
	ratespec_t rspec;
	bool tome;
	struct ether_addr *bssid;
	wlc_bsscfg_t *bsscfg;
	wlc_roam_t *roam;
#if defined(AP) || defined(STA)
	int rssi = WLC_RSSI_INVALID;
#endif

	WL_TRACE(("wl%d: wlc_recvdata\n", wlc->pub->unit));

	/* since most of the fields in the struct frminfo is initialized
	 * through this function, it not necessary to bzero the frminfo for
	 * perf issue.  Initial each field as needed.
	 */
	f.key = NULL;
	f.prio = 0;
	f.ac = 0;
	f.ht = FALSE;
	f.apsd_eosp = FALSE;
	f.ividx = 0;
	f.ismulti = FALSE;
	f.p = p;
	f.rxh = rxh;
	f.wrxh = wrxh;

	min_len = D11_PHY_HDR_LEN + DOT11_A3_HDR_LEN + DOT11_FCS_LEN;

	/* check for runts */
	if ((uint)PKTLEN(osh, f.p) < min_len) {
		WL_ERROR(("wl%d: wlc_recvdata: runt frame\n", wlc->pub->unit));
		WLCNTINCR(wlc->pub->_cnt->rxrunt);
		goto toss;
	}

	plcp = PKTDATA(osh, p);
	rspec = wlc_recv_compute_rspec(wrxh, plcp);

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		bcopy(&f.plcp, plcp, D11_PHY_HDR_LEN);
	}
#endif /* WLLMAC */

	f.h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
	pkttag = WLPKTTAG(p);

	WL_PRHDRS(wlc, "rxpkt hdr (data)", (uint8*)plcp, NULL, wrxh, PKTLEN(osh, f.p));
	WL_PRPKT("rxpkt body (data)", plcp, PKTLEN(osh, f.p));
	WL_APSTA_RX(("wl%d: wlc_recvdata: frame from %s\n",
		wlc->pub->unit, bcm_ether_ntoa(&f.h->a2, eabuf)));

	f.fc = ltoh16(f.h->fc);
	f.type = FC_TYPE(f.fc);
	f.subtype = (f.fc & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT;
	ASSERT(f.type == FC_TYPE_DATA);

	f.wds = ((f.fc & (FC_TODS | FC_FROMDS)) == (FC_TODS | FC_FROMDS));
	f.qos = (f.type == FC_TYPE_DATA && FC_SUBTYPE_ANY_QOS(f.subtype));
#ifdef WL11N
	f.ht = (((wrxh->rxhdr.PhyRxStatus_0 & PRXS0_FT_MASK) == PRXS0_PREN) &&
		(f.fc & FC_ORDER) && FC_SUBTYPE_ANY_QOS(f.subtype));
#endif

	/* check for runts */
	if (f.wds)
		min_len += ETHER_ADDR_LEN;
	/* WME: account for QoS Control Field */
	if (f.qos)
		min_len += DOT11_QOS_LEN;
	if (f.ht)
		min_len += DOT11_HTC_LEN;
	if ((uint)PKTLEN(osh, f.p) < min_len) {
		WL_ERROR(("wl%d: wlc_recvdata: runt frame from %s\n", wlc->pub->unit,
			bcm_ether_ntoa(&(f.h->a2), eabuf)));
		WLCNTINCR(wlc->pub->_cnt->rxrunt);
		goto toss;
	}

#ifdef STA
#endif /* STA */

	/* check for a broadcast/multicast A1 */
	f.ismulti = ETHER_ISMULTI(&(f.h->a1));

	/* check if this frame is in our BSS */
	if (f.wds) {
		bsscfg = NULL;
		/* this is a WDS frame, and WDS frames are not part of a BSS */
		f.bssid_match = FALSE;
	}
	else {
		if (f.fc & FC_TODS)
			bssid = &f.h->a1;
		else if (f.fc & FC_FROMDS)
			bssid = &f.h->a2;
		else
			bssid = &f.h->a3;
		bsscfg = wlc_bsscfg_find_by_bssid(wlc, bssid);
		f.bssid_match = bsscfg != NULL ? TRUE : FALSE;
	}

	/* is this frame sent to one of our addresses? */
	if (!f.ismulti && wlc_bsscfg_find_by_hwaddr(wlc, &f.h->a1) != NULL)
		tome = TRUE;
	else
		tome = FALSE;

	if (MONITOR_ENAB(wlc) || PROMISC_ENAB(wlc->pub)) {

		/* we are not participating in a BSS */
		if (!wlc->pub->associated)
			f.bssid_match = FALSE;

		/* determine if frame is for us or received only due to promisc setting */
		promisc_frame = TRUE;


		/* A1 is the destination or receiver address for all FromDS/ToDS combination,
		 * so the unicast check is done on A1.
		 * Multicast/Broadcast is only allowed
		 *     1) when ToDS==0 and the STA is participating in a BSS or IBSS,
		 *  OR 2) both ToDS and FromDS (a WDS multicast)
		 */
		if (/* unicast match */
		    tome ||
		    /* multicast in BSS (from AP) or in IBSS */
		    (!(f.fc & FC_TODS) && f.ismulti && f.bssid_match) ||
		    /* multicast WDS */
		    (f.wds && f.ismulti)) {
			promisc_frame = FALSE;
		}
		else if (PROMISC_ENAB(wlc->pub)) {
			/* pass up frames from inside our BSS */
			if (!f.bssid_match)
				goto toss;
			/* ensure promisc frames are tossed for AP */
			if (BSSCFG_AP(bsscfg))
				goto toss;
		}
		else {
			/* In monitor mode (sniffing while operating as a normal interface),
			 * don't continue processing packets that aren't for us
			 */
			ASSERT(MONITOR_ENAB(wlc));
			goto toss;
		}

		/* These frames survive above filters:
		 * unicast for us (!promisc_frame)
		 * - in all BSS/IBSS
		 * - WDS
		 * unicast but not for us (promisc_frame)
		 * - in our BSS/IBSS
		 * multicast (!promisc_frame)
		 * - in our BSS/IBSS
		 * - WDS
		 */
	}
	else {
		/* a race window exists while changing the RX MAC addr match registers where
		 * we may receive a fame that does not have our MAC address
		 */
		if (!f.ismulti && !tome)
			goto toss;

		/* These frames survive PSM filters:
		 * unicast for us (!promisc_frame)
		 * - in all BSS/IBSS
		 * - WDS
		 * multicast (!promisc_frame)
		 * - in our BSS/IBSS
		 * - WDS
		 */
	}

	/* get rid of non-WDS frame that is not in our BSS/IBSS */
	if (tome && !f.wds && !f.bssid_match)
		goto toss;


	/* strip off PLCP header */
	PKTPULL(osh, f.p, D11_PHY_HDR_LEN);

	f.pbody = (uchar*)f.h + DOT11_A3_HDR_LEN;
	if (f.wds)
		f.pbody += ETHER_ADDR_LEN;

	f.isamsdu = FALSE;
	/* account for QoS Control Field */
	if (f.qos) {
		uint16 qoscontrol = ltoh16_ua(f.pbody);

		f.isamsdu = (qoscontrol & QOS_AMSDU_MASK) != 0;
		if (f.isamsdu) {
			if (BSSCFG_SAFEMODE(bsscfg)) {
				WL_ERROR(("%s(): safe mode no AMSDU support!\n", __FUNCTION__));
				goto toss;
			}
#ifdef WLAMSDU
			if (wlc->_amsdu_rx) {
				WLPKTTAG(f.p)->flags |= WLF_AMSDU;
				WL_AMSDU(("wlc_recvdata: is A-MSDU frame, rspec 0x%x\n", rspec));
			} else
#endif
			{
				WL_ERROR(("wlc_recvdata: amsdu is not enabled, toss\n"));
				goto toss;
			}
		}

		f.prio = (uint8)QOS_PRIO(qoscontrol);
		f.ac = WME_PRIO2AC(f.prio);
		f.apsd_eosp = QOS_EOSP(qoscontrol);
		f.pbody += DOT11_QOS_LEN;
		f.ividx = (uint8)PRIO2IVIDX(f.prio);
		ASSERT(f.ividx < WLC_NUMRXIVS);
	}

	/* strip off FCS, A-MSDU has FCS on the tail buffer */
	if (!f.isamsdu)
		PKTSETLEN(osh, f.p, PKTLEN(osh, f.p) - DOT11_FCS_LEN);
	else {
		void *pt = pktlast(osh, f.p);
		PKTSETLEN(osh, pt, PKTLEN(osh, pt) - DOT11_FCS_LEN);
	}

	/* assign f.len now */
	f.len = PKTLEN(osh, f.p);
	offset = (uint)(f.pbody - (uint8*)PKTDATA(osh, f.p));
	f.body_len = f.len - offset;

	/* A-MSDU may be chained */
	f.totlen = pkttotlen(osh, p) - offset;

	/* save seq in host endian */
	f.seq = ltoh16(f.h->seq);

	/* 802.11-specific rx processing... */

	/* For reference, DS bits on Data frames and addresses:
	 *
	 *         ToDS FromDS   a1    a2    a3    a4
	 *
	 * IBSS      0      0    DA    SA   BSSID  --
	 * To STA    0      1    DA   BSSID  SA    --
	 * To AP     1      0   BSSID  SA    DA    --
	 * WDS       1      1    RA    TA    DA    SA
	 *
	 * For A-MSDU frame
	 *         ToDS FromDS   a1    a2    a3    a4
	 *
	 * IBSS      0      0    DA    SA   BSSID  --
	 * To STA    0      1    DA   BSSID BSSID  --
	 * To AP     1      0   BSSID  SA   BSSID  --
	 * WDS       1      1    RA    TA   BSSID  BSSID
	 */

	/* state based filtering */
	if (!promisc_frame && wlc_recvfilter(wlc, f.h, wrxh, &scb, f.len))
		goto toss;

	/* create scb for class 1 IBSS data frame for which recvfilter() won't */
	if (!promisc_frame && (f.fc & (FC_FROMDS | FC_TODS)) == 0) {
		if ((scb = wlc_scblookupband(wlc, &f.h->a2,
		                CHANNEL_BANDUNIT(wlc, WLC_RX_CHANNEL(&wrxh->rxhdr)))) == NULL) {
			WL_ERROR(("wl%d: wlc_recvdata: out of scbs for IBSS data\n",
			          wlc->pub->unit));
			WLCNTINCR(wlc->pub->_cnt->rxnoscb);
			goto toss;
		}
	}

	/* filter out bad frames with invalid toDS/fromDS combinations in promisc mode */
	if (promisc_frame &&
	    /* rx IBSS data frame but our bsscfg is BSS */
	    ((((f.fc & (FC_FROMDS | FC_TODS)) == 0) && bsscfg->BSS) ||
	     /* rx BSS data frame but our bsscfg is IBSS */ 
	     (((f.fc & (FC_FROMDS | FC_TODS)) != 0) && !f.wds && !bsscfg->BSS))) {
		WL_ERROR(("wl%d: wlc_recvdata: bad DS from %s\n", wlc->pub->unit,
		          bcm_ether_ntoa(&(f.h->a2), eabuf)));
		WLCNTINCR(wlc->pub->_cnt->rxbadds);
		goto toss;
	}

	/* create scb for class 3 BSS and class 1 IBSS data frames
	 * for other nodes received in promisc mode
	 */
	if (promisc_frame) {
		if ((scb = wlc_scblookupband(wlc, &f.h->a2,
		                CHANNEL_BANDUNIT(wlc, WLC_RX_CHANNEL(&wrxh->rxhdr)))) == NULL) {
			WL_INFORM(("wl%d: wlc_recvdata: out of scbs for promisc data\n",
			           wlc->pub->unit));
			goto toss;
		}
	}

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	roam = bsscfg->roam;

	/* toss frames with invalid DS bits */
	if (!promisc_frame && !f.wds &&
	     /* multicast frame to AP */
	    ((f.ismulti && (f.fc & FC_TODS) != 0) ||
	     /* frame w/o ToDS to AP */
	     (BSSCFG_AP(bsscfg) && (f.fc & FC_TODS) == 0) ||
	     /* frame w/o FromDS to infra STA or with FromDS and/or ToDS to IBSS STA */
	     (BSSCFG_STA(bsscfg) &&
	      (f.fc & (FC_TODS | FC_FROMDS)) != (bsscfg->BSS ? FC_FROMDS : 0)))) {
		WL_ERROR(("wl%d: wlc_recvdata: bad DS from %s (%s %s%s %s %s)\n",
		          wlc->pub->unit, bcm_ether_ntoa(&f.h->a2, eabuf),
		          f.ismulti ? "MC" : "UC",
		          (f.fc & FC_FROMDS) ? "FromDS" : "",
		          (f.fc & FC_TODS) ? "ToDS" : "",
		          BSSCFG_AP(bsscfg) ? "AP" : "STA",
		          bsscfg->BSS ? "BSS" : "IBSS"));
		WLCNTINCR(wlc->pub->_cnt->rxbadds);
		goto toss;
	}

#if defined(AP) || defined(STA)
	/* update rssi */
	if (BSSCFG_STA(bsscfg) ||
#ifdef AP
	    wlc->scbrssi ||
#endif
	    FALSE) {
		rssi = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);
		if (rssi != WLC_RSSI_INVALID)
			pkttag->rssi = (int8)rssi;
	}
#endif 

#ifdef STA
	/* update rssi and snr */
	if (BSSCFG_STA(bsscfg) &&
	    TRUE) {
		int nval;

		/* update rssi information */
		wlc_lq_rssi_update_ma(bsscfg, rssi);
		wlc_lq_rssi_event_update(bsscfg);

		/* update snr info */
		nval = wlc_recv_snr_compute(wlc, wrxh);
		wlc_phy_update_snr_ma(bsscfg, nval);

		/* handle bookkeeping tasks */
		if (f.bssid_match &&
		    bsscfg->BSS && bsscfg->associated &&
#ifdef WLP2P
		    !BSS_P2P_ENAB(wlc, bsscfg) &&
#endif
		    !roam->off) {
			wlc_roamscan_start(bsscfg, WLC_E_REASON_LOW_RSSI);
		}
	}
#endif /* STA */

	if (f.wds) {
		/* the packet should be from one of our WDS partners */
		ASSERT(SCB_WDS(scb));
		f.WPA_auth = bsscfg->WPA_auth;
	}
	else if (BSSCFG_AP(bsscfg)) {
		/* If we are an AP only the packet should be from one
		 * of our clients even if we are in promiscuous mode.
		 */
		ASSERT(SCB_ASSOCIATED(scb));
		/*
		 * use per scb WPA_auth to handle 802.1x frames differently
		 * in WPA/802.1x mixed mode when having a pairwise key:
		 *  - accept unencrypted 802.1x frames in plain 802.1x mode
		 *  - drop unencrypted 802.1x frames in WPA mode
		 */
		f.WPA_auth = scb->WPA_auth;
		/*
		 * Trigger Automatic Power-Save Delivery as early as possible.
		 * WMM/APSD: x.y.z: Do not trigger on the frame that transitions
		 * to power save mode.
		 */
		if (SCB_WME(scb) && f.qos &&
		    ((f.seq & FRAGNUM_MASK) == 0) &&
		    SCB_PS(scb) && !SCB_ISMULTI(scb) &&
		    (f.fc & FC_PM) && (scb->flags & SCB_RECV_PM) &&
		    AC_BITMAP_TST(scb->apsd.ac_trig, f.ac))
			wlc_apps_apsd_trigger(wlc, scb, f.ac);

		/*
		 * Remember the PM bit from the last data frame received so
		 * power save transitions can be detected synchronously.
		 */
		if (f.fc & FC_PM)
			scb->flags |= SCB_RECV_PM;
		else
			scb->flags &= ~SCB_RECV_PM;
	} else {
		if (bsscfg->BSS && !promisc_frame) {
			ASSERT(SCB_ASSOCIATED(scb));
		}
		f.WPA_auth = scb->WPA_auth;
	}

	/* update info based on rx of any new traffic */
#if defined(AP)
	/* collect per-scb rssi samples */
	if (wlc->scbrssi ||
	    scb->rssi_enabled) {
		if (rssi != WLC_RSSI_INVALID) {
			scb->rssi_window[scb->rssi_index] = rssi;
			scb->rssi_index = MODINC_POW2(scb->rssi_index, MA_WINDOW_SZ);
		}
	}

#endif 

#ifdef STA
	if (BSSCFG_STA(bsscfg) && bsscfg->BSS) {
		/* This pkt must have come from the AP so we know it is up */

		/* Adjust time_since_bcn only for directed traffic to us since
		 * only directed traffic indicates the AP considers us associated.
		 * We want to handle the case of an AP rebooting by "roaming" to
		 * the AP, but we also want to also detect the case of going out
		 * then in range of an AP.
		 * If our rebooted old AP sends multicast traffic to other newly
		 * associated STAs, we do not want to stop the roam mechanism.
		 * But if we get directed traffic from our old AP since we just
		 * moved back into range, we want to stop the roam mechanism.
		 */
		if (!f.ismulti && !promisc_frame) {
			roam->time_since_bcn = 0;
			roam->tbtt_since_bcn = 0;
		}
	}
#endif /* STA */

	/* multicast address filtering */
	if (f.ismulti) {
		if (BSSCFG_AP(bsscfg))
			/* APs do not accept data traffic with a multicast a1 address */
			goto toss;

		/* toss multicast frames we sent forwarded back to us by the AP */
		if (bsscfg->BSS &&
		    bcmp((char*)&(f.h->a3), (char*)&bsscfg->cur_etheraddr, ETHER_ADDR_LEN) == 0) {
			goto toss;
		}

#ifdef WET_TUNNEL
		/* toss multicast frames we sent forwarded back to us by the AP-WET Tunnel */
		if (bsscfg->BSS &&
		    wlc_wet_multicast_forwarded_back(wlc, (char *)&(f.h->a3))) {
			goto toss;
		}
#endif /* WET_TUNNEL */

		/* filter with multicast list */
		if (!ETHER_ISBCAST(&(f.h->a1)) &&
			!bsscfg->allmulti && wlc_bsscfg_mcastfilter(bsscfg, f.h))
			goto toss;
	}

	/* Now that the frame is accepted, update some rx packet related data */
	pkttag->rspec = (uint32)rspec;

#ifdef WL11N
	/* skip non-first MPDU in an A-MPDU */
	if (!f.ismulti && (plcp[0] | plcp[1] | plcp[2])) {
		wlc_ratesel_upd_rxstats(wlc->rsi, pkttag->rspec, wrxh->rxhdr.RxStatus2);
	}
#endif /* WL11N */

#if defined(WLCNT)
	if (PLCP3_ISSGI(plcp[3]))
		WLCNTINCR(wlc->pub->_cnt->rxmpdu_sgi);
	if (PLCP3_ISSTBC(plcp[3]))
		WLCNTINCR(wlc->pub->_cnt->rxmpdu_stbc);

	/* per-rate rx for unicast only */
	if (!f.ismulti) {
		wl_cnt_t *cnt = wlc->pub->_cnt;

		/* update per-rate rx count */
		switch (RSPEC2RATE(pkttag->rspec)) {
		case WLC_RATE_1M:
			WLCNTINCR(cnt->rx1mbps);
			break;
		case WLC_RATE_2M:
			WLCNTINCR(cnt->rx2mbps);
			break;
		case WLC_RATE_5M5:
			WLCNTINCR(cnt->rx5mbps5);
			break;
		case WLC_RATE_6M:
			WLCNTINCR(cnt->rx6mbps);
			break;
		case WLC_RATE_9M:
			WLCNTINCR(cnt->rx9mbps);
			break;
		case WLC_RATE_11M:
			WLCNTINCR(cnt->rx11mbps);
			break;
		case WLC_RATE_12M:
			WLCNTINCR(cnt->rx12mbps);
			break;
		case WLC_RATE_18M:
			WLCNTINCR(cnt->rx18mbps);
			break;
		case WLC_RATE_24M:
			WLCNTINCR(cnt->rx24mbps);
			break;
		case WLC_RATE_36M:
			WLCNTINCR(cnt->rx36mbps);
			break;
		case WLC_RATE_48M:
			WLCNTINCR(cnt->rx48mbps);
			break;
		case WLC_RATE_54M:
			WLCNTINCR(cnt->rx54mbps);
			break;
		default:
			break;
		}
	}
#endif /* WLCNT */

	/* Upate per SCB receive stats */
	WLCNTSCB_COND_INCR(!ETHER_ISMULTI(&(f.h->a3)), scb->scb_stats.rx_ucast_pkts);
	WLCNTSCB_COND_INCR(ETHER_ISMULTI(&(f.h->a3)), scb->scb_stats.rx_mcast_pkts);
	WLCNTSCBSET(scb->scb_stats.rx_rate, rspec);

#ifdef WLAMPDU
	if (SCB_AMPDU(scb) && !f.ismulti && !promisc_frame)
		wlc_ampdu_recvdata(wlc->ampdu, scb, &f);
	else
#endif
#ifdef WLBA
	 if (SCB_BA(scb) && !f.ismulti)
		wlc_ba_recvdata(wlc->bastate, scb, &f);
	else
#endif
		wlc_recvdata_ordered(wlc, scb, &f);


	return;

toss:
	if (WME_ENAB(wlc->pub) && !f.ismulti) {
		WLCNTINCR(wlc->pub->_wme_cnt->rx_failed[WME_PRIO2AC(PKTPRIO(f.p))].packets);
		WLCNTADD(wlc->pub->_wme_cnt->rx_failed[WME_PRIO2AC(PKTPRIO(f.p))].bytes,
		                                     pkttotlen(osh, f.p));
	}

	PKTFREE(osh, f.p, FALSE);
	return;
}

/* Performs reassembly and per-msdu operations. Expects the frames to be in order */
void BCMFASTPATH
wlc_recvdata_ordered(wlc_info_t *wlc, struct scb *scb, struct wlc_frminfo *f)
{
	struct dot11_llc_snap_header *lsh;
	struct ether_addr a1, a2, a3, a4;
	uint body_offset;
	uint16 prev_seqctl = 0;
	wlc_bsscfg_t *bsscfg;
	osl_t *osh;
#ifdef BCMDBG_ERR
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG_ERR */
	uint8 prio = 0; /* Best-effort */
	bool more_frag = ((f->fc & FC_MOREFRAG) != 0);
#if defined(WLLMAC)
	rx_ctxt_t rx_ctxt;
	uint16 ether_type;
	bool sendup_80211 = FALSE;
#endif 
	char *prx_ctxt;
	int rx_ctxt_len;

	osh = wlc->osh;
	prx_ctxt = NULL;
	rx_ctxt_len = 0;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	/* For WME, update the prio */
	/* f->prio is already updated with the proper value by the caller(s) */
	if (f->qos)
		prio = f->prio;

	/* Detect and discard duplicates */
	if (!f->ismulti) {
		if ((f->fc & FC_RETRY) && (scb->seqctl[prio] == f->seq)) {
			WL_TRACE(("wl%d: wlc_recvdata_ordered: discarding duplicate MPDU %04x "
				  "received from %s prio: %d\n", wlc->pub->unit, f->seq,
				  bcm_ether_ntoa(&(f->h->a2), eabuf), prio));
			WLCNTINCR(wlc->pub->_cnt->rxdup);
			goto toss;
		} else {
			WL_TRACE(("wl%d: wlc_recvdata: received new MPDU %04x from %s prio: %d\n",
				wlc->pub->unit, f->seq,
				bcm_ether_ntoa(&(f->h->a2), eabuf), prio));
		}
	}

#ifdef STA
	if (BSSCFG_STA(bsscfg)) {
		wlc_pm_st_t *pm = bsscfg->pm;

		WL_NONE(("%s: psp=%d wme=%d usp=%d qos=%d eosp=%d\n",
		         __FUNCTION__, wlc->PSpoll, WME_ENAB(wlc->pub),
		         pm->apsd_sta_usp, f->qos, f->apsd_eosp));

		/* Check for a PS-Poll response */
		if (pm->PSpoll &&	/* PS-Poll outstanding */
		    !f->ismulti &&	/* unicast */
		    !more_frag &&	/* last frag in burst, or non-frag frame */
		    !AC_BITMAP_TST(scb->apsd.ac_delv, f->ac)) /* not on a delivery-enabled AC */
			wlc_recv_PSpoll_resp(bsscfg, f->fc);

#ifdef WME
		/* Check for end of APSD unscheduled service period */
		if (WME_ENAB(wlc->pub) &&
		    pm->apsd_sta_usp && f->qos) {
			if (f->apsd_eosp) {
				WL_PS(("wl%d.%d: APSD sleep\n",
				       wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
				wlc_set_apsd_stausp(bsscfg, FALSE);
			}
#ifdef WLP2P
			if (BSS_P2P_ENAB(wlc, bsscfg)) {
				wlc_p2p_apsd_eosp(wlc->p2p, bsscfg,
					!f->apsd_eosp && (f->fc & FC_MOREDATA));
			}
#endif
		}
#endif /* WME */
	}
#endif /* STA */

	/* null data frames */
	if (FC_SUBTYPE_ANY_NULL(f->subtype))
		goto toss;

	f->rx_wep = f->fc & FC_WEP;
	if (BSSCFG_SAFEMODE(bsscfg))
		f->key = NULL;
	else {
		if (f->rx_wep || (WSEC_ENABLED(bsscfg->wsec) && bsscfg->wsec_restrict)) {
			/* the key, if any, will be provided by wsec_recvdata */
			f->key = NULL;
			if (!wlc_wsec_recvdata(wlc, osh, scb, f, prio)) {
				WLCNTSCB_COND_INCR((f->rx_wep), scb->scb_stats.rx_decrypt_failures);
				{
#ifdef WLLMAC
				/* LMAC sends up the 802.11 header incase of decrypt */
				/* failure errors */
				if (LMAC_ENAB(wlc->pub)) {
					wlc_lmac_recvdata(wlc->lmac_info, f,
						LMAC_RX_DECRYPT_FAILED);
					return;
				}
#endif
				goto toss;
				}
			}
			WLCNTSCB_COND_INCR((f->rx_wep), scb->scb_stats.rx_decrypt_succeeds);
		}
	}

	if (!f->ismulti) {
		/* Update cached seqctl */
		prev_seqctl = scb->seqctl[prio];
		scb->seqctl[prio] = f->seq;
	}


	if (!f->ismulti) {
		/* reassembly */
		if ((f->seq & FRAGNUM_MASK) == 0) {
			/* Discard partially-received frame */
			if (scb->fragbuf[prio]) {
				WL_ERROR(("wl%d: wlc_recvdata_ordered: discarding partial "
				          "MSDU %03x with prio %d received from %s\n",
				          wlc->pub->unit, prev_seqctl >> SEQNUM_SHIFT, prio,
				          bcm_ether_ntoa(&(f->h->a2), eabuf)));
				PKTFREE(osh, scb->fragbuf[prio], FALSE);
				scb->fragbuf[prio] = NULL;
				scb->fragresid[prio] = 0;
				scb->fragtimestamp[prio] = 0;
			}

			if (more_frag) {
				int pkt_len = f->len;

				/* map the contents of 1st frag */
				PKTCTFMAP(osh, f->p);

				/* save packet for reassembly */
				scb->fragbuf[prio] = f->p;
				if (BSSCFG_SAFEMODE(bsscfg))
					return;

				if ((int)((PKTTAILROOM(osh, f->p) + PKTHEADROOM(osh, f->p)
				     + PKTLEN(osh, f->p))) < wlc->pub->tunables->rxbufsz) {
					scb->fragbuf[prio] = PKTGET(osh,
					                            wlc->pub->tunables->rxbufsz,
					                            FALSE);
					if (scb->fragbuf[prio] == NULL) {
						WL_ERROR(("wl%d: %s(): Allocate %d rxbuf for"
							" frag pkt failed!\n",
							(int)wlc->pub->unit, __FUNCTION__,
							(int)wlc->pub->tunables->rxbufsz));
						goto toss;
					}
					memcpy(PKTDATA(osh, scb->fragbuf[prio]),
						(PKTDATA(osh, f->p) - PKTHEADROOM(osh, f->p)),
						(PKTHEADROOM(osh, f->p) + PKTLEN(osh, f->p)));
					PKTPULL(osh, scb->fragbuf[prio],
						(int)PKTHEADROOM(osh, f->p));
					PKTSETLEN(osh, scb->fragbuf[prio], PKTLEN(osh, f->p));

					PKTFREE(osh, f->p, FALSE);
				}
				scb->fragresid[prio] = (wlc->pub->tunables->rxbufsz -
				                        wlc->hwrxoff - D11_PHY_HDR_LEN) - pkt_len;
				if (!bcmp(wlc_802_1x_hdr, f->pbody, DOT11_LLC_SNAP_HDR_LEN)) {
					scb->flags |= SCB_8021XHDR;
#ifdef WLBTAMP
				} else if (!bcmp(BT_SIG_SNAP_MPROT, f->pbody,
				                 DOT11_LLC_SNAP_HDR_LEN - 2) &&
				           (*(uint16 *)&f->pbody[DOT11_LLC_SNAP_HDR_LEN - 2] ==
				            hton16(BTA_PROT_SECURITY))) {
					scb->flags |= SCB_8021XHDR;
#endif /* WLBTAMP */
				} else {
					scb->flags &= ~SCB_8021XHDR;
				}

#ifdef BCMWAPI_WAI
				if (!bcmp(wlc_wai_hdr, f->pbody, DOT11_LLC_SNAP_HDR_LEN)) {
					scb->flags2 |= SCB2_WAIHDR;
				} else {
					scb->flags2 &= ~SCB2_WAIHDR;
				}
#endif /* BCMWAPI_WAI */

#ifdef WLLMAC
				/* rxh holds only the 16bits of the TSF, so recover 32bit TSF */
				if (LMAC_ENAB(wlc->pub)) {
					uint8 ac = wme_fifo2ac[prio2fifo[prio]];
					lmac_info_t *lmac = wlc->lmac_info;
					if (lmac->rx_maxlifetime[ac] || wlc->rxmsdulifetime)
						scb->fragtimestamp[prio] =
							wlc_recover_tsf32(wlc, f->wrxh);
				}
#endif /* WLLMAC */
			}
		} else {
			/* subsequent frag */
			/*
			 * This isn't the first frag, but we don't have a partially-
			 * received MSDU.  We must have somehow missed the previous
			 * frags or timed-out the partially-received MSDU (not implemented yet).
			 */
			if (!scb->fragbuf[prio]) {
				WL_ERROR(("wl%d: wlc_recvdata_ordered: discarding MPDU %04x with "
				          "prio %d; previous MPDUs missed or partially-received "
				          "MSDU timed-out\n", wlc->pub->unit, f->seq, prio));
				WLCNTINCR(wlc->pub->_cnt->rxfragerr);
				WLCIFCNTINCR(scb, rxfragerr);
				goto toss;
			}

			/* Make sure this MPDU:
			 * - matches the partially-received MSDU
			 * - is the one we expect (next in sequence)
			 */
			if (((f->seq & ~FRAGNUM_MASK) != (prev_seqctl & ~FRAGNUM_MASK)) ||
			    ((f->seq & FRAGNUM_MASK) != ((prev_seqctl & FRAGNUM_MASK) + 1))) {
				/* discard the partially-received MSDU */
				WL_ERROR(("wl%d: wlc_recvdata_ordered: discarding partial "
				          "MSDU %03x with prio:%d received from %s\n",
				          wlc->pub->unit, prev_seqctl >> SEQNUM_SHIFT, prio,
				          bcm_ether_ntoa(&(f->h->a2), eabuf)));
				PKTFREE(osh, scb->fragbuf[prio], FALSE);
				scb->fragbuf[prio] = NULL;
				scb->fragresid[prio] = 0;
				scb->fragtimestamp[prio] = 0;

				/* discard the MPDU */
				WL_INFORM(("wl%d: wlc_recvdata_ordered: discarding MPDU %04x with "
				           "prio %d; previous MPDUs missed\n", wlc->pub->unit,
				           f->seq, prio));
				WLCNTINCR(wlc->pub->_cnt->rxfragerr);
				WLCIFCNTINCR(scb, rxfragerr);
				goto toss;

			}

			if (BSSCFG_SAFEMODE(bsscfg)) {
				void *next_p = scb->fragbuf[prio];
				/* chain the fragmented packets in scb->fragbuf[prio] */
				while (PKTNEXT(osh, next_p))
					next_p = (void *)PKTNEXT(osh, next_p);

				PKTSETNEXT(osh, next_p, f->p);
				if (!more_frag) {
					/* last frag...fall through and sendup reassembled MSDU */
					f->p = scb->fragbuf[prio];
					scb->fragbuf[prio] = NULL;
				}
			}
			else {

				/* detect fragbuf overflow */
				if (f->body_len > scb->fragresid[prio]) {
					/* discard the partially-received MSDU */
					WL_ERROR(("wl%d: wlc_recvdata_ordered: discarding partial "
					          "MSDU %03x with prio %d received from %s\n",
					          wlc->pub->unit, prev_seqctl >> SEQNUM_SHIFT, prio,
					          bcm_ether_ntoa(&(f->h->a2), eabuf)));
					PKTFREE(osh, scb->fragbuf[prio], FALSE);
					scb->fragbuf[prio] = NULL;
					scb->fragresid[prio] = 0;
					scb->fragtimestamp[prio] = 0;

					/* discard the MPDU */
					WL_ERROR(("wl%d: wlc_recvdata: discarding MPDU %04x "
							  "with prio %d; resulting MSDU too big\n",
							  wlc->pub->unit, f->seq, prio));
					WLCNTINCR(wlc->pub->_cnt->rxfragerr);
					WLCIFCNTINCR(scb, rxfragerr);
					goto toss;
				}
#ifdef WLLMAC
				if (LMAC_ENAB(wlc->pub))
				{
					uint16 	rxmsdulifetime;
					uint32	tsf32;
					uint8	ac = wme_fifo2ac[prio2fifo[prio]];

					rxmsdulifetime = wlc->lmac_info->rx_maxlifetime[ac];
					if (!rxmsdulifetime)
						rxmsdulifetime = wlc->rxmsdulifetime;

					/*
					 * rx max msdu lifetime, if the fragments are received after
					 * rxmaxlifetime whole frame needs to be dropped
					 */
					if (rxmsdulifetime) {
						tsf32 = wlc_recover_tsf32(wlc, f->wrxh);
						if ((tsf32 - scb->fragtimestamp[prio])
							>= rxmsdulifetime) {
							WL_ERROR(("wl%d: expired MaxRxLifetime"
								" so drop"));
							WL_ERROR(("tsf1(%d),tsf2(%d),max(%d)",
								tsf32, scb->fragtimestamp[prio],
							        rxmsdulifetime));
							PKTFREE(osh, scb->fragbuf[prio], FALSE);
							scb->fragbuf[prio] = NULL;
							scb->fragresid[prio] = 0;
							scb->fragtimestamp[prio] = 0;
							goto toss;
						}
					}
				}
#endif /* WLLMAC */

				/* map the contents of each subsequent frag before copying */
				PKTCTFMAP(osh, f->p);

				/* copy frame into fragbuf */
				wlc_appendfrag(wlc, scb->fragbuf[prio], &scb->fragresid[prio],
					f->pbody, f->body_len, osh);

				PKTFREE(osh, f->p, FALSE);

				if (!more_frag) {
					/* last frag...fall through and sendup reassembled MSDU */
					f->p = scb->fragbuf[prio];
					scb->fragbuf[prio] = NULL;
					scb->fragresid[prio] = 0;
					scb->fragtimestamp[prio] = 0;

					/* reset packet pointers to beginning */
					f->h = (struct dot11_header *) PKTDATA(osh, f->p);
					f->len = PKTLEN(osh, f->p);
					f->pbody = (uchar*)(f->h) + DOT11_A3_HDR_LEN;
					f->body_len = f->len - DOT11_A3_HDR_LEN;
					if (f->wds) {
						f->pbody += ETHER_ADDR_LEN;
						f->body_len -= ETHER_ADDR_LEN;
					}
					/* WME: account for QoS Control Field */
					if (f->qos) {
						f->prio = prio;
						f->pbody += DOT11_QOS_LEN;
						f->body_len -= DOT11_QOS_LEN;
					}
					f->fc = ltoh16(f->h->fc);
					if ((f->rx_wep) && (f->key)) {
						/* strip WEP IV */
						f->pbody += f->key->iv_len;
						f->body_len -= f->key->iv_len;
					}
				}
			}
		}
	} /* unicast */

	if (f->key) {
		/* update rx iv */
		if (f->key->algo == CRYPTO_ALGO_AES_CCM)
			wlc_wsec_rxiv_update(wlc, f);
#ifdef BCMWAPI_WPI
		if (f->key->algo == CRYPTO_ALGO_SMS4)
			wlc_wsec_wapi_rxiv_update(wlc, f);
#endif /* BCMWAPI_WPI */
	}

	if (more_frag)
		return;


#ifdef WLAMSDU
	/* A-MSDU deagg */
	if (WLPKTTAG(f->p)->flags & WLF_AMSDU) {
		if (BSSCFG_SAFEMODE(bsscfg)) {
			WL_ERROR(("%s(): safe mode no AMSDU support!\n", __FUNCTION__));
			goto toss;
		}
		if (WLPKTTAG(f->p)->flags & WLF_HWAMSDU) {
			wlc_amsdu_deagg_hw(wlc->ami, scb, f, prx_ctxt, rx_ctxt_len);
			return;
		} else {
#ifdef WLAMSDU_SWDEAGG
			wlc_amsdu_deagg_sw(wlc->ami, scb, f, prx_ctxt, rx_ctxt_len);
			return;
#else
			WL_ERROR(("wlc_recvdata_ordered: sw deagg is not supported\n"));
			ASSERT(0);
			goto toss;
#endif /* WLAMSDU_SWDEAGG */
		}
	}
#endif /* WLAMSDU */

	/*
	 * 802.11 -> 802.3/Ethernet header conversion
	 * Part 1: eliminate possible overwrite problems, find right eh pointer
	 */
	bcopy((char *)&(f->h->a1), (char *)&a1, ETHER_ADDR_LEN);
	bcopy((char *)&(f->h->a2), (char *)&a2, ETHER_ADDR_LEN);
	bcopy((char *)&(f->h->a3), (char *)&a3, ETHER_ADDR_LEN);
	if (f->wds)
		bcopy((char *)&(f->h->a4), (char *)&a4, ETHER_ADDR_LEN);

	/*
	 * 802.11 -> 802.3/Ethernet header conversion
	 * Part 2: find sa/da pointers
	 */
	if ((f->fc & FC_TODS) == 0) {
		f->da = &a1;
		if ((f->fc & FC_FROMDS) == 0)
			f->sa = &a2;
		else
			f->sa = &a3;
	} else {
		f->da = &a3;
		if ((f->fc & FC_FROMDS) == 0)
			f->sa = &a2;
		else
			f->sa = &a4;
	}

#if defined(WLLMAC)
	if (LMAC_ENAB(wlc->pub))
		sendup_80211 = TRUE;
#endif

#if defined(WLLMAC)
	if (sendup_80211) {
		f->eh = (struct ether_header *)f->h;

		/* Find the snap hdr in order to find the ether_type which we will
		 * examine in order to detect cram/802.1x
		 */
		if (!BSSCFG_SAFEMODE(bsscfg)) {

			lsh = (struct dot11_llc_snap_header *)(f->pbody);
			if ((lsh->dsap == 0xaa) && (lsh->ssap == 0xaa) && (lsh->ctl == 0x03) &&
			    (lsh->oui[0] == 0) && (lsh->oui[1] == 0) &&
			    ((lsh->oui[2] == 0x00 && !sstlookup(wlc, ntoh16(lsh->type))) ||
			     (lsh->oui[2] == 0xf8 && sstlookup(wlc, ntoh16(lsh->type))))) {
				ether_type = ntoh16(lsh->type);
			} else {
				ether_type = (uint16)f->body_len;
			}


#ifdef STA
			if (BSSCFG_WSEC_BUF_KEY_B4_M4(bsscfg)) {
				body_offset = (uint)(f->pbody - (uchar*)PKTDATA(osh, f->p));
				WL_WSEC(("wl%d:%s(): body_offset=%d, body_len=%d, pkt_len=%d\n",
					wlc->pub->unit, __FUNCTION__, body_offset, f->body_len,
					PKTLEN(osh, f->p)));
				if (wlc_is_4way_msg(wlc, f->p, body_offset, PMSG1)) {
					WL_WSEC(("wl%d: %s: allowing unecrypted "
						"802.1x 4-Way M1\n",
						wlc->pub->unit, __FUNCTION__));
					wlc_bsscfg_wsec_session_reset(wlc, bsscfg);
				}
			}
#endif /* STA */
		}

		if (f->key && f->key->algo != CRYPTO_ALGO_WEP1 &&
		    f->key->algo != CRYPTO_ALGO_WEP128) {
			if (!wlc_wsec_miccheck(wlc, osh, scb, f)) {
#ifdef WLLMAC
				/* LMAC sends up the 802.11 header incase of MIC failure errors */
				if (LMAC_ENAB(wlc->pub)) {
					wlc_lmac_recvdata(wlc->lmac_info, f, LMAC_RX_MICFAILURE);
					return;
				}
#endif
				goto toss;
			}
		}

		if (ETHER_ISMULTI(f->da))
			WLCNTINCR(wlc->pub->_cnt->rxmulti);

		if (!BSSCFG_SAFEMODE(bsscfg)) {

			if (f->key && (f->key->algo == CRYPTO_ALGO_TKIP))
				/* update rx iv */
				wlc_wsec_rxiv_update(wlc, f);

#ifdef WLLMAC
			/* LMAC code path diverges from here */
			if (LMAC_ENAB(wlc->pub)) {
				WL_TRACE(("Calling LMAC_RECV DATA\n"));
				scb->used = wlc->pub->now;
				wlc_lmac_recvdata(wlc->lmac_info, f, LMAC_SUCCESS);
				return;
			}
#endif


			/* reposition 802.11 header to strip IV and/or QoS field */
			if (f->rx_wep || f->qos) {
				uchar *dst;

				body_offset = 0;
				if (f->rx_wep) {
					ASSERT(f->key);
					body_offset += f->key->iv_len;
				}
				if (f->qos) {
					body_offset += DOT11_QOS_LEN;

					/* mask QoS subtype bit since QoS header will be stripped */
					f->h->fc &=
						htol16(~(FC_SUBTYPE_QOS_DATA << FC_SUBTYPE_SHIFT));
				}
				for (dst = f->pbody - 1; dst >= (uchar *)PKTDATA(osh, f->p); dst--)
					*dst = *(dst - body_offset);

				f->h = (struct dot11_header *)PKTPULL(osh, f->p, body_offset);
			}

			if (!WIN7_OS(wlc->pub) || !(APSTA_ENAB(wlc->pub) && AP_ACTIVE(wlc)))
				ASSERT((f->fc & FC_TODS) == 0);


#ifdef STA
			WL_RTDC(wlc, "wlc_recvdata_ordered %u", PKTLEN(osh, f->p), 0);
			if (BSSCFG_STA(bsscfg)) {
				wlc_pm2_ret_upd_last_wake_time(bsscfg, &f->wrxh->tsf_l);
			}
#endif /* STA */

#if defined(BCMSUP_PSK) && defined(BCMINTSUP)
			if ((bsscfg->sup_type != SUP_UNUSED) && (ether_type == ETHER_TYPE_802_1X)) {
				eapol_header_t *eapol_hdr = (eapol_header_t *)((uint8 *)f->h +
					DOT11_A3_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN - ETHER_HDR_LEN);

				if (wlc_sup_eapol(bsscfg->sup, eapol_hdr, (f->rx_wep != 0),
				                  &bsscfg->sup_auth_pending))
					goto toss;
			}
#endif

#if defined(BCMAUTH_PSK)
			if (bsscfg->authenticator && (ether_type == ETHER_TYPE_802_1X)) {
				eapol_header_t *eapol_hdr = (eapol_header_t *)((uint8 *)f->h +
					DOT11_A3_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN - ETHER_HDR_LEN);

				if (wlc_auth_eapol(bsscfg->authenticator, eapol_hdr,
					(f->rx_wep != 0), scb))
					goto toss;
			}
#endif



			/* Process either:
			 * 	- a regular packet with 802.11 hdr, or,
			 *  - a cram packet consisting of an 802.11 hdr,
			 *    followed by a 4-byte cram hdr, followed by some number
			 *    of cram frames.
			 */
#ifdef CRAM
			if ((ether_type == ETHER_TYPE_BRCM) &&
			    (*((uint8 *)f->pbody+DOT11_LLC_SNAP_HDR_LEN) == 0) &&
			    (ntoh16(*(uint16 *)(f->pbody+DOT11_LLC_SNAP_HDR_LEN+2)) ==
			    ETHER_BRCM_CRAM)) {
				PKTPULL(osh, f->p, DOT11_A3_HDR_LEN + DOT11_LLC_SNAP_HDR_LEN);
				wlc_uncram(wlc, scb, f->wds, f->da, f->p, (char *)&rx_ctxt,
				            (int)sizeof(rx_ctxt_t));
				return;
			}
#endif /* CRAM */

		}

		/* toss pkt if there is no room for rx_ctxt */
		if (PKTTAILROOM(osh, f->p) < sizeof(rx_ctxt))
			goto toss;

		/* dot11 hdr is already in place so ndis does not need
		 * to prepend it.
		 */
		rx_ctxt.prepend_dot11_hdr = FALSE;
		bcopy((uchar *)&rx_ctxt, (uchar *)PKTDATA(osh, f->p) +
		            PKTLEN(osh, f->p), sizeof(rx_ctxt));

		PKTSETPRIO(f->p, f->prio);

		wlc_recvdata_sendup(wlc, scb, f->wds, f->da, f->p);
	}
	else
#endif 
	{
		lsh = (struct dot11_llc_snap_header *)(f->pbody);
		/* calc the bytes included in the 802.11 header (A3 or A4 format + qos + iv) */
		body_offset = (uint)(f->pbody - (uchar*)PKTDATA(osh, f->p));

#ifdef LINUX_CRYPTO
		if (f->key && f->key->algo != CRYPTO_ALGO_WEP1 &&
		    f->key->algo != CRYPTO_ALGO_WEP128) {
			if (!wlc_wsec_miccheck(wlc, osh, scb, f))
				goto toss;
		}
#endif /* LINUX_CRYPTO */

		/*
		 * 802.11 -> 802.3/Ethernet header conversion part 1:
		 * - if ([AA AA 03 00 00 00] and protocol is not in SST) or
		 *   if ([AA AA 03 00 00 F8] and protocol is in SST), convert to RFC894
		 * - otherwise,
		 *	 preserve 802.3 (including RFC1042 with protocol in SST)
		 *
		 * NOTE: Need to be careful when changing this because MIC calculation
		 * depends on 802.3 header still being present
		 */
		if (lsh->dsap == 0xaa && lsh->ssap == 0xaa && lsh->ctl == 0x03 &&
		    lsh->oui[0] == 0 && lsh->oui[1] == 0 &&
		    ((lsh->oui[2] == 0x00 && !sstlookup(wlc, ntoh16(lsh->type))) ||
		     (lsh->oui[2] == 0xf8 && sstlookup(wlc, ntoh16(lsh->type))))) {
			/* RFC894 */
			f->eh = (struct ether_header *)PKTPULL(osh, f->p,
				body_offset + DOT11_LLC_SNAP_HDR_LEN - ETHER_HDR_LEN);
		} else {
			/* RFC1042 */
			{
				f->eh = (struct ether_header *)PKTPULL(osh, f->p,
					body_offset - ETHER_HDR_LEN);
				f->eh->ether_type = hton16((uint16)f->body_len);	/* length */
			}
		}

#ifndef LINUX_CRYPTO
		if (f->key && f->key->algo != CRYPTO_ALGO_WEP1 &&
		    f->key->algo != CRYPTO_ALGO_WEP128)
			if (!wlc_wsec_miccheck(wlc, osh, scb, f))
				goto toss;

		if (f->key && (f->key->algo == CRYPTO_ALGO_TKIP))
			/* update rx iv */
			wlc_wsec_rxiv_update(wlc, f);
#endif /* LINUX_CRYPTO */

#ifdef STA
		if (BSSCFG_WSEC_BUF_KEY_B4_M4(bsscfg) &&
			(ntoh16(f->eh->ether_type) == ETHER_TYPE_802_1X)) {
			if (wlc_is_4way_msg(wlc, f->p, ETHER_HDR_LEN - DOT11_LLC_SNAP_HDR_LEN,
				PMSG1)) {
				WL_WSEC(("wl%d: %s: allowing unecrypted "
				         "802.1x 4-Way M1\n",
				         wlc->pub->unit, __FUNCTION__));
				wlc_bsscfg_wsec_session_reset(wlc, bsscfg);
			}
		}
#endif /* STA */
		/*
		 * 802.11 -> 802.3/Ethernet header conversion
		 * Part 3: do the conversion
		 */
		bcopy((char*)(f->da), (char*)&(f->eh->ether_dhost), ETHER_ADDR_LEN);
		bcopy((char*)(f->sa), (char*)&(f->eh->ether_shost), ETHER_ADDR_LEN);

		/* WME: set packet priority based on first received MPDU */
		PKTSETPRIO(f->p, f->prio);

		if (ETHER_ISMULTI(f->da))
			WLCNTINCR(wlc->pub->_cnt->rxmulti);

#ifdef WLBTAMP
		/* process BT-AMP frames */
		if (BTA_ENAB(wlc->pub) && (ntoh16(f->eh->ether_type) <= ETHER_MAX_DATA) &&
		    (PKTLEN(osh, f->p) >= RFC1042_HDR_LEN) &&
		    bcmp((uint8 *)&f->eh[1], BT_SIG_SNAP_MPROT, DOT11_LLC_SNAP_HDR_LEN - 2) == 0) {
			if (wlc_bta_recv_proc(wlc->bta, f, scb))
				goto toss;
		}
#endif /* WLBTAMP */

		/* toss if station not yet authorized to transmit non-802.1X frames */
		if (bsscfg->eap_restrict && !SCB_AUTHORIZED(scb)) {
			if (ntoh16(f->eh->ether_type) != ETHER_TYPE_802_1X &&
#ifdef WLBTAMP
			    !(WLPKTTAG(f->p)->flags & WLF_8021X) &&
#endif
			    TRUE) {
				WL_ERROR(("wl%d: non-802.1X frame from unauthorized station %s\n",
					wlc->pub->unit, bcm_ether_ntoa(&scb->ea, eabuf)));
				goto toss;
			}
		}

#ifdef BCMWAPI_WAI
		/* toss if station not yet authorized to transmit non-WAI
		 * frames except 802.1X frame
		 */
		if (bsscfg->wai_restrict && !SCB_AUTHORIZED(scb)) {
			if (ntoh16(f->eh->ether_type) != ETHER_TYPE_WAI &&
			    ntoh16(f->eh->ether_type) != ETHER_TYPE_802_1X &&
#ifdef WLBTAMP
			    !(WLPKTTAG(f->p)->flags & WLF_WAI) &&
			    !(WLPKTTAG(f->p)->flags & WLF_8021X) &&
#endif
			    TRUE) {
				WL_ERROR(("wl%d: non-WAI frame from unauthorized station %s\n",
					wlc->pub->unit, bcm_ether_ntoa(&scb->ea, eabuf)));
				goto toss;
			}
		}
#endif /* BCMWAPI_WAI */

#ifdef STA
		WL_RTDC(wlc, "wlc_recvdata_ordered %u", PKTLEN(osh, f->p), 0);
		if (BSSCFG_STA(bsscfg)) {
			wlc_pm2_ret_upd_last_wake_time(bsscfg, &f->wrxh->tsf_l);
		}

#if defined(BCMSUP_PSK) && defined(BCMINTSUP)
		if ((bsscfg->sup_type != SUP_UNUSED) &&
		    (ntoh16(f->eh->ether_type) == ETHER_TYPE_802_1X)) {
			if (wlc_sup_eapol(bsscfg->sup, (eapol_header_t*) f->eh, (f->rx_wep != 0),
			                  &bsscfg->sup_auth_pending))
				goto toss;
		}
#endif

#if defined(BCMAUTH_PSK)
		if (bsscfg->authenticator &&
		    (ntoh16(f->eh->ether_type) == ETHER_TYPE_802_1X)) {
			if (wlc_auth_eapol(bsscfg->authenticator, (eapol_header_t*) f->eh,
			                   (f->rx_wep != 0), scb))
				goto toss;
		}
#endif

#endif	/* STA */

#ifdef CRAM
		if ((ntoh16(f->eh->ether_type) == ETHER_TYPE_BRCM) &&
		    (*(uint8*)((uint8*)(f->eh) + ETHER_HDR_LEN) == 0) &&
		    (ntoh16(*(uint16*)((uint8*)(f->eh) + ETHER_HDR_LEN + 2)) == ETHER_BRCM_CRAM)) {
			PKTPULL(osh, f->p, ETHER_HDR_LEN);
			wlc_uncram(wlc, scb, f->wds, f->da, f->p, NULL, 0);
			return;
		}
#endif /* CRAM */


		wlc_recvdata_sendup(wlc, scb, f->wds, f->da, f->p);

	}
	return;

toss:
	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->rx_failed[WME_PRIO2AC(PKTPRIO(f->p))].packets);
		WLCNTADD(wlc->pub->_wme_cnt->rx_failed[WME_PRIO2AC(PKTPRIO(f->p))].bytes,
		                                     pkttotlen(osh, f->p));
	}
	PKTFREE(osh, f->p, FALSE);
	return;
}

/* forward and/or sendup a received data frame */
void BCMFASTPATH
wlc_recvdata_sendup(wlc_info_t *wlc, struct scb *scb, bool wds, struct ether_addr *da, void *p)
{
	struct ether_header *eh;
	osl_t *osh;
	wlc_bsscfg_t *bsscfg;
	struct wl_if *wlif;
	uint pktlen;
#if defined(BCMDBG)
	char eabuf1[ETHER_ADDR_STR_LEN];
	char eabuf2[ETHER_ADDR_STR_LEN];
	char eabuf3[ETHER_ADDR_STR_LEN];

	eabuf1[0] = 0;
	eabuf2[0] = 0;
	eabuf3[0] = 0;
#endif /* defined(BCMDBG) */
	bcmeth_hdr_t *pkt_data;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	osh = wlc->osh;
	eh = (struct ether_header*) PKTDATA(osh, p);
	pktlen = pkttotlen(osh, p);
	BCM_REFERENCE(pktlen);

	{
		/*
		 * If VLAN Mode is active, and an 802.1Q VLAN Priority Tag (VLAN ID 0) is present,
		 * extract the priority from it and strip the tag (satisfies requirements of WMM
		 * section A.6 and WHQL).
		 */
		if (!BSSCFG_SAFEMODE(bsscfg) &&
#ifdef WLAFTERBURNER
		    !wlc->afterburner &&
#endif /* WLAFTERBURNER */
		    (wlc->vlan_mode != OFF) && ntoh16(eh->ether_type) == ETHER_TYPE_8021Q) {
			struct ethervlan_header *vh = (struct ethervlan_header *)eh;

			if (!(ntoh16(vh->vlan_tag) & VLAN_VID_MASK)) {
				struct ether_header da_sa;

				PKTSETPRIO(p,
					(ntoh16(vh->vlan_tag) >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK);

				bcopy(vh, &da_sa, VLAN_TAG_OFFSET);
				eh = (struct ether_header *)PKTPULL(osh, p, VLAN_TAG_LEN);
				pktlen = pkttotlen(osh, p);
				bcopy(&da_sa, eh, VLAN_TAG_OFFSET);
			}
		}
	}

	/* Security fix for ETHER_TYPE_BRCM event packet spoofing.
	 * preventing user can hack copying whole ETHER_TYPE_BRCM(802.3) packet
	 * on host and inject it through 802.11 frame into its BSS.
	 * Unless we filter it out, it will be passed to host and can take harmful action.
	 * (e.g deauth or disassoc)
	 */

	if ((ntoh16(eh->ether_type) == ETHER_TYPE_BRCM) &&
		(pktlen >= (sizeof(bcmeth_hdr_t) + ETHER_HDR_LEN))) {
		pkt_data = (bcmeth_hdr_t *)((uchar *)eh + ETHER_HDR_LEN);

		if ((ntoh16(pkt_data->subtype) == BCMILCP_SUBTYPE_VENDOR_LONG) &&
			(!bcmp(BRCM_OUI, &pkt_data->oui[0], DOT11_OUI_LEN)) &&
				(ntoh16(pkt_data->usr_subtype) == BCMILCP_BCM_SUBTYPE_EVENT))
			{
				PKTFREE(osh, p, FALSE);
				WLCNTINCR(wlc->pub->_cnt->rxbadproto);
				return;
			}
	}

	/* forward */
	if (BSSCFG_AP(bsscfg)) {
		void *tmp;
		struct scb *dst;
		struct wlc_if *wlcif;

		wlcif = bsscfg->wlcif;

		WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: %s pkt %p da %s as AP: "
			"shost %s dhost %s\n",
			wlc->pub->unit, (wds ? "WDS" : ""), p,
			bcm_ether_ntoa(da, eabuf1),
			bcm_ether_ntoa((struct ether_addr*)eh->ether_shost, eabuf2),
			bcm_ether_ntoa((struct ether_addr*)eh->ether_dhost, eabuf3)));
		WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: bsscfg %p %s iface %p\n", wlc->pub->unit,
			scb->bsscfg,
			(scb->bsscfg ? (BSSCFG_AP(scb->bsscfg) ? "(AP)" : "(STA)") : ""), wlcif));

#ifdef WMF
		/* Do the WMF processing for multicast packets */
		if (WMF_ENAB(bsscfg) && ETHER_ISMULTI((struct ether_addr*)eh->ether_dhost)) {
			int ret;
			ret = wlc_wmf_packets_handle(bsscfg, scb, p, 1);
			switch (ret) {
			case WMF_TAKEN:
				/* The packet is taken by WMF return */
				return;
			case WMF_DROP:
				/* The packet drop decision by WMF free and return */
				PKTFREE(osh, p, FALSE);
				return;
			default:
				/* Continue the forwarding path */
				break;
			}
		}
#endif /* WMF */

		/* forward packets destined within the BSS */
		if (bsscfg->ap_isolate || wds) {
			/* in ap_isolate mode, packets are passed up not forwarded */
			/* WDS endpoint, packets just go up the stack */
		} else if (ETHER_ISMULTI(da)) {
			WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: forward bcmc pkt %p\n",
			             wlc->pub->unit, p));
#ifdef WET_TUNNEL
			wlc_wet_tunnel_recv_proc(wlc->wetth, p);
#endif /* WET_TUNNEL */
			if ((tmp = PKTDUP(osh, p)))
				wlc_sendpkt(wlc, tmp, wlcif);
#ifndef WET_TUNNEL
		} else if (bcmp(eh->ether_dhost, wlc->pub->cur_etheraddr.octet, ETHER_ADDR_LEN) &&
		           (dst = wlc_scbfind(wlc, (struct ether_addr *)eh->ether_dhost))) {
#else
		} else if (bcmp(eh->ether_dhost, wlc->pub->cur_etheraddr.octet, ETHER_ADDR_LEN) &&
		           (wlc_wet_tunnel_recv_proc(wlc->wetth, p) >= 0) &&
		           (dst = wlc_scbfind(wlc, (struct ether_addr *)eh->ether_dhost))) {
#endif /* WET_TUNNEL */
			/* check that the dst is associated to same BSS before forwarding within the
			 * BSS
			 */

			if (SCB_ASSOCIATED(dst) && (dst->bsscfg == bsscfg)) {
				WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: forward pkt %p in BSS\n",
				             wlc->pub->unit, p));
#ifdef WLCNT
				if (WME_ENAB(wlc->pub)) {
					wl_traffic_stats_t *forward =
					    &wlc->pub->_wme_cnt->forward[WME_PRIO2AC(PKTPRIO(p))];
					WLCNTINCR(forward->packets);
					WLCNTADD(forward->bytes, pkttotlen(osh, p));
				}
#endif
				if (PROMISC_ENAB(wlc->pub) && (tmp = PKTDUP(osh, p))) {
					/* both forward and send up stack */
					/* Before forwarding, fix the priority */
					if (QOS_ENAB(wlc->pub) && (PKTPRIO(tmp) == 0))
						pktsetprio(tmp, FALSE);
					wlc_sendpkt(wlc, tmp, wlcif);
#ifdef HNDCTF
					PKTSETSKIPCT(osh, p);
#endif /* HNDCTF */
				} else {
					/* Before forwarding, fix the priority */
					if (QOS_ENAB(wlc->pub) && (PKTPRIO(p) == 0))
						pktsetprio(p, FALSE);
					wlc_sendpkt(wlc, p, wlcif);
					return;
				}
			}
		}
	}

	WL_PRPKT("rxpkt (Ethernet)", (uchar *)eh, PKTLEN(osh, p));
	WL_PRUSR("rx", (uchar*)eh, ETHER_HDR_LEN);
	WL_WSEC(("wl%d: wlc_recvdata_sendup: rx sendup, len %d\n",
	  WLCWLUNIT(wlc), PKTLEN(osh, p)));

	/* update stat counters */
	WLCNTINCR(wlc->pub->_cnt->rxframe);
	WLCNTADD(wlc->pub->_cnt->rxbyte, PKTLEN(osh, p));
	WLACTINCR(wlc->pub->_activity);

	/* update interface stat counters */
	if (SCB_WDS(scb)) {
		WLCNTINCR(scb->wds->_cnt.rxframe);
		WLCNTADD(scb->wds->_cnt.rxbyte, PKTLEN(osh, p));
	} else {
		WLCNTINCR(bsscfg->wlcif->_cnt.rxframe);
		WLCNTADD(bsscfg->wlcif->_cnt.rxbyte, PKTLEN(osh, p));
	}

	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->rx[WME_PRIO2AC(PKTPRIO(p))].packets);
		WLCNTADD(wlc->pub->_wme_cnt->rx[WME_PRIO2AC(PKTPRIO(p))].bytes,
		         PKTLEN(osh, p));
	}

	scb->used = wlc->pub->now;


	if (!BSSCFG_SAFEMODE(bsscfg)) {
#if !defined(WLNOEIND)
		/* encapsulate 802.1x frame within 802.3 LLC/SNAP */
		/*
		* Encap. is for userland applications such as NAS to tell the
		* origin of the data frame when they can't directly talk to the
		* interface, for example, they run behind a software bridge
		* where interface info is lost (it can't be identified only
		* from MAC address, for example, both WDS interface and wireless
		* interface have the save MAC address).
		*/
		/* If IBSS, only sendup if this is from a peer. */
		if (!wlc->mac_spoof && ntoh16(eh->ether_type) == ETHER_TYPE_802_1X) {
			if (BSSCFG_AP(bsscfg)) {
				WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: "
							"gen EAPOL event for AP %s\n",
							wlc->pub->unit,
							bcm_ether_ntoa(&scb->ea, eabuf1)));
			}
			/* If IBSS, don't send 802.1x frames from a station that isn't a peer */
			if (bsscfg->BSS || SCB_IS_IBSS_PEER(scb))
				wlc_bss_eapol_event(wlc, bsscfg, &scb->ea,
					PKTDATA(osh, p) + ETHER_HDR_LEN,
					PKTLEN(osh, p) - ETHER_HDR_LEN);

			/* also send original one up */
		}
#ifdef BCMWAPI_WAI
		if (!wlc->mac_spoof && ntoh16(eh->ether_type) == ETHER_TYPE_WAI) {
			if (BSSCFG_AP(bsscfg)) {
				WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: gen WAI event for AP %s\n",
					wlc->pub->unit, bcm_ether_ntoa(&scb->ea, eabuf1)));
			}
			/* If IBSS, don't send WAI frames from a station that isn't a peer */
			if (bsscfg->BSS || SCB_IS_IBSS_PEER(scb))
				wlc_bss_wai_event(wlc, bsscfg, &scb->ea,
					PKTDATA(osh, p) + ETHER_HDR_LEN,
					PKTLEN(osh, p) - ETHER_HDR_LEN);
			/* also send original one up */
		}
#endif /* BCMWAPI_WAI */

#endif /* !defined(WLNOEIND) */

#ifdef MCAST_REGEN
		/* Apply WMF reverse translation only the STA side */
		if (MCAST_REGEN_ENAB(bsscfg) && !SCB_WDS(scb) && BSSCFG_STA(SCB_BSSCFG(scb)))
			wlc_mcast_reverse_translation(eh);
#endif /* MCAST_REGEN */

#ifdef WET
		/* Apply WET only on the STA side */
		if (wlc->wet && !SCB_WDS(scb) && BSSCFG_STA(SCB_BSSCFG(scb)))
			wlc_wet_recv_proc(wlc->weth, p);
#endif /* WET */

		/* Before sending the packet up the stack, set the packet prio correctly */
		if (QOS_ENAB(wlc->pub) && (PKTPRIO(p) == 0))
			pktsetprio(p, FALSE);
	}

#ifdef WLBTAMP
	if (BSS_BTA_ENAB(wlc, bsscfg))
		wlif = bsscfg->wlcif->wlif;
	else
#endif
	wlif = SCB_INTERFACE(scb);

	WL_APSTA_RX(("wl%d: wlc_recvdata_sendup: sending pkt %p up iface %p %s\n",
	             wlc->pub->unit, p, wlif, wl_ifname(wlc->wl, wlif)));

	wl_sendup(wlc->wl, wlif, p, BSSCFG_SAFEMODE(bsscfg)? pktsegcnt(osh, p) : 1);
}

static void
wlc_appendfrag(wlc_info_t *wlc, void *fragbuf, uint *fragresid,
               uchar *body, uint body_len, void *osh)
{
	uchar *dst;
	uint fraglen;

	/* append frag payload to end of partial packet */
	fraglen = PKTLEN(osh, fragbuf);
	dst = PKTDATA(osh, fragbuf) + fraglen;
	bcopy(body, dst, body_len);
	PKTSETLEN(osh, fragbuf, (fraglen + body_len));
	*fragresid -= body_len;
}

void
wlc_tx_suspend(wlc_info_t *wlc)
{
	wlc->tx_suspended = TRUE;

	wlc_bmac_tx_fifo_suspend(wlc->hw, TX_DATA_FIFO);
}

bool
wlc_tx_suspended(wlc_info_t *wlc)
{
	return wlc_bmac_tx_fifo_suspended(wlc->hw, TX_DATA_FIFO);
}

void
wlc_tx_resume(wlc_info_t *wlc)
{
	bool silence = FALSE;

	wlc->tx_suspended = FALSE;
#ifdef STA
	if (QUIET_STATE(wlc) & SILENCE) {
		/* do not unsuspend when in quiet period */
		silence = TRUE;
	}
#endif /* STA */

	if (!silence && !wlc_quiet_chanspec(wlc->cmi, WLC_BAND_PI_RADIO_CHANSPEC)) {
		wlc_bmac_tx_fifo_resume(wlc->hw, TX_DATA_FIFO);
	}
}

void
wlc_bss_tbtt(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
#ifdef STA
	wlc_roam_t *roam = cfg->roam;
#endif
#ifdef AP
	wlc_bss_info_t *current_bss = cfg->current_bss;
	wlc_csa_t *csa = cfg->csa;
#endif

	(void)wlc;

#ifdef STA
	/* Monitor connection to a BSS network. */

	/* Start monitoring at tick 1 */
	if (BSSCFG_STA(cfg) && cfg->associated && cfg->BSS) {
#ifdef WLMCHAN
		if (MCHAN_ENAB(wlc->pub) && MCHAN_ACTIVE(wlc->pub) &&
		    wlc_mchan_blocking_enab(wlc->mchan)) {
			cfg->mchan_tbtt_since_bcn++;
		}
#endif /* WLMCHAN */
		if (roam->time_since_bcn > 0) {
		/* no beacon seen for awhile, check unaligned beacon */
		if (roam->tbtt_since_bcn == roam->uatbtt_tbtt_thresh) {

			if (cfg->pm->PMenabled && !cfg->pm->PM_override &&
			    !ETHER_ISNULLADDR(&cfg->BSSID)) {
				WL_ASSOC(("wl%d: ROAM: check for unaligned TBTT, "
				          "tbtt_since_bcn %d, time_since_bcn %d\n",
				          WLCWLUNIT(wlc), roam->tbtt_since_bcn,
				          roam->time_since_bcn));
				wlc_set_uatbtt(cfg, TRUE);
				ASSERT(STAY_AWAKE(wlc));
			}
		}

		/* no beacon seen for awhile, start roam */
		if (roam->tbtt_since_bcn > roam->tbtt_thresh) {

			if (cfg->pm->check_for_unaligned_tbtt) {
				WL_ASSOC(("wl%d: ROAM: done for unaligned TBTT, "
				          "tbtt_since_bcn %d, time_since_bcn %d\n",
				          WLCWLUNIT(wlc), roam->tbtt_since_bcn,
				          roam->time_since_bcn));
				wlc_set_uatbtt(cfg, FALSE);
			}

			wlc_roam_bcns_lost(cfg);
		}
		else {
			/* clear the consec_roam_bcns_lost counter */
			/* because we've seen at least 1 beacon since */
			/* we last called wlc_roam_bcns_lost() above */
			roam->consec_roam_bcns_lost = 0;
		}

		/* prepare for unaligned tbtt checking and roaming */
		if (roam->tbtt_since_bcn <= roam->tbtt_thresh)
			roam->tbtt_since_bcn++;
		}
	}
#endif /* STA */

#ifdef AP
	/* If we have previously detected radar and scheduled a channel switch in
	 * the future, then every TBTT interval we come here and decrement the
	 * 'TBTT time to chan switch' field in the outgoing beacons.
	 */
	if (BSSCFG_AP(cfg) &&
	    (csa->spect_state & NEED_TO_UPDATE_BCN)) {
		/* If all counts are 0, no further need to update outgoing beacons */
		if ((csa->quiet_cmd.count == 0) && (csa->csa.count == 0)) {
			csa->spect_state &= ~NEED_TO_UPDATE_BCN;
		}

		/* Count down for switch channels... */
		if (csa->csa.count == 0) {
			if (WL11H_ENAB(wlc))
				wlc->block_datafifo &= ~DATA_BLOCK_QUIET; /* Resume tx */
		}
		else {
			/* to updated channel switch count of csa ie. */
			if (csa->csa.count == 1) {
				/* set up time to switch channel after beacon is sent */
				wl_del_timer(wlc->wl, csa->csa_timer);
				wl_add_timer(wlc->wl, csa->csa_timer,
					(current_bss->beacon_period < CSA_PRE_SWITCH_TIME ?
				         current_bss->beacon_period : CSA_PRE_SWITCH_TIME), 0);
			}
			csa->csa.count--;
		}

		WL_APSTA_BCN(("wl%d: wlc_tbtt 11h -> wlc_update_beacon()\n", wlc->pub->unit));
		wlc_bss_update_beacon(wlc, cfg);
		wlc_bss_update_probe_resp(wlc, cfg, TRUE);
	}
#endif /* AP */
}

/* MI_TBTT and MI_DTIM_TBTT interrupt handler.
 *
 * The interrupt is generated when tsf_cfpstart register is programmed and
 * tsf_timerlow = tsf_cfpstart + pre_tbtt.
 *
 * - In APSTA mode when the AP is brought up the tsf timers including tsf_cfpstart
 * register are allocated to the AP otherwise when there is no AP running they are
 * allocated to the primary STA (primary bsscfg).
 * - When P2P is enabled SHM TSFs are allocated for each STA BSS including the
 * primary STA (primary bsscfg).
 */
void
wlc_tbtt(wlc_info_t *wlc, d11regs_t *regs)
{
	wlc_bsscfg_t *cfg = wlc->cfg;
	wlc_bsscfg_t *oth_cfg;
	int oth_cfg_idx;

	WLCNTINCR(wlc->pub->_cnt->tbtt);

	WL_TRACE(("wl%d: wlc_tbtt: TBTT indication\n", wlc->pub->unit));

#ifdef DEBUG_TBTT
	if (WL_INFORM_ON())
		wlc->prev_TBTT = R_REG(wlc->osh, &regs->tsf_timerlow);
#endif /* DEBUG_TBTT */

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		wlc_lmac_tbtt(wlc->lmac_info, regs);
		return;
	}
#endif

#ifdef STA
	if (BSSCFG_STA(cfg)) {
		WL_RTDC2(wlc, "wlc_tbtt: PMe=%u", cfg->pm->PMenabled, 0);

		/* run watchdog here if the watchdog timer is not armed */
		if (WLC_WATCHDOG_TBTT(wlc)) {
			uint32 cur, delta;
			if (wlc->WDarmed) {
				wl_del_timer(wlc->wl, wlc->wdtimer);
				wlc->WDarmed = FALSE;
			}

			cur = OSL_SYSUPTIME();
			delta = cur > wlc->WDlast ? cur - wlc->WDlast :
			        (uint32)~0 - wlc->WDlast + cur + 1;
			if (delta >= TIMER_INTERVAL_WATCHDOG) {
				wlc_watchdog((void *)wlc);
				wlc->WDlast = cur;
			}

			wl_add_timer(wlc->wl, wlc->wdtimer, wlc_watchdog_backup_bi(wlc), TRUE);
			wlc->WDarmed = TRUE;
		}
	}
#endif /* STA */

#ifdef AP
	/* increment scb tbtt counts, used for PS aging */
	if (AP_ACTIVE(wlc))
		wlc_apps_tbtt_update(wlc);
#endif
#ifdef WLP2P
	/* p2p ucode has per BSS pretbtt */
	if (!P2P_ENAB(wlc->pub) || !cfg->BSS)
#endif
	{
		/* if not using P2P, must go through all associated cfg's */
		FOREACH_AS_BSS(wlc, oth_cfg_idx, oth_cfg) {
			wlc_bss_tbtt(oth_cfg);
		}
	}

#ifdef AP
	if (BSSCFG_AP(cfg)) {
	}
#endif /* AP */

	if (!cfg->BSS) {
		/* DirFrmQ is now valid...defer setting until end of ATIM window */
		wlc->qvalid |= MCMD_DIRFRMQVAL;
	}
}

/* Generic hw timer abstraction layer for multiplexing hw timer use */
#ifdef BCMDBG
static void
wlc_hwtimer_print_timers(wlc_hwtimer_info_t *hwtmr)
{
	wlc_hwtimer_to_t *this;

	if ((this = hwtmr->timer_list.next) == NULL) {
		WL_ERROR(("No timers\n"));
		return;
	}
	while (this != NULL) {
		WL_ERROR(("timer %p, fun %p, arg %p, %d TO units\n", this, this->fun, this->arg,
		          this->timeout));
		this = this->next;
	}
}
#endif /* BCMDBG */

/* initialize the hwtimer object */
wlc_hwtimer_info_t *wlc_hwtimer_init(wlc_info_t *wlc,
                                     hwt_gettime_fn gettime,
                                     hwt_set_timer_fn set_timer,
                                     hwt_ack_timer_fn ack_timer,
                                     uint max_timer_val)
{
	wlc_hwtimer_info_t *hwtmr;

	hwtmr = (wlc_hwtimer_info_t *)wlc_calloc(wlc->osh, wlc->pub->unit,
	                                         sizeof(wlc_hwtimer_info_t));
	if (hwtmr != NULL) {
		hwtmr->wlc = wlc;
		hwtmr->gettime = gettime;
		hwtmr->set_timer = set_timer;
		hwtmr->ack_timer = ack_timer;
		hwtmr->max_timer_val = max_timer_val;
		hwtmr->timer_allowed = TRUE;
	}
	else {
		WL_ERROR(("%s: failed to allocate memory for hw timer\n", __FUNCTION__));
	}

	return (hwtmr);
}

/* deinitialize hwtimer object */
void wlc_hwtimer_deinit(wlc_info_t *wlc, wlc_hwtimer_info_t *hwtmr)
{
	if (hwtmr != NULL) {
		MFREE(wlc->osh, hwtmr, sizeof(wlc_hwtimer_info_t));
	}
}

/* timer isr */
void wlc_hwtimer_isr(wlc_hwtimer_info_t *hwtmr)
{
	wlc_hwtimer_to_t *head;

	hwtmr->timer_armed = FALSE;
	wlc_hwtimer_run_timeouts(hwtmr);
	if (hwtmr->timer_armed)
		return;
	head = &hwtmr->timer_list;
	if (head->next != NULL) {
		hwtmr->set_timer((void *)hwtmr, head->next->timeout);
		hwtmr->timer_armed = TRUE;
	}
	else if (hwtmr->ack_timer != NULL) {
		hwtmr->ack_timer((void *)hwtmr);
	}
}

/* Update expiration times in timeout list */
static void
wlc_hwtimer_update_timeout_list(wlc_hwtimer_info_t *hwtmr)
{
	uint delta, curr_time;
	wlc_hwtimer_to_t *head = &hwtmr->timer_list;
	wlc_hwtimer_to_t *this = head->next;

	curr_time = hwtmr->gettime((void *)hwtmr);
	/* put in condition to check for wrap around */
	if (curr_time < hwtmr->lasttime) {
		delta = hwtmr->max_timer_val - hwtmr->lasttime + curr_time + 1;
	}
	else {
		delta = curr_time - hwtmr->lasttime;
	}
	hwtmr->lasttime = curr_time;
	if (!this)
		return;
	if (this->timeout == 0 || delta != 0) {
		while (this != NULL) {
			if (this->timeout <= delta) {
				/* timer has expired */
				delta -= this->timeout;
				this->timeout = 0;
				this->expired = TRUE;
				this = this->next;
			} else {
				this->timeout -= delta;
				break;
			}
		}
	}
}

/* Remove expired from timeout list and invoke their callbacks */
static void
wlc_hwtimer_run_timeouts(wlc_hwtimer_info_t *hwtmr)
{
	wlc_hwtimer_to_t *this;
	wlc_hwtimer_to_t *head = &hwtmr->timer_list;
	hwtto_fn fun;

	if ((this = head->next) == NULL)
		return;

	wlc_hwtimer_update_timeout_list(hwtmr);

	/* Always start from the head */
	while (((this = head->next) != NULL) && (this->expired == TRUE)) {
		head->next = this->next;
		fun = this->fun;
		this->fun = NULL;
		this->expired = FALSE;
		fun(this->arg);
	}
}

/* Add timeout to the list */
bool
wlc_hwtimer_add_timeout(wlc_hwtimer_info_t *hwtmr, wlc_hwtimer_to_t *newto,
                        uint32 _timeout, hwtto_fn fun, void *arg)
{
	wlc_hwtimer_to_t *prev, *this;
	uint delta_to = _timeout;

	if (!hwtmr->wlc->pub->up) {
		WL_ERROR(("%s: trying to add timeout when wlc down\n", __FUNCTION__));
		return FALSE;
	}

	if (!newto)
		return FALSE;

	if (newto->fun != NULL) {
		WL_INFORM(("fun not null in 0x%p, timer already in list?\n", newto));
#ifdef	BCMDBG
		wlc_hwtimer_print_timers(hwtmr);
#endif
		return FALSE;
	}

	wlc_hwtimer_update_timeout_list(hwtmr);

	/* find a proper location for the new timeout and update the timer value */
	prev = &hwtmr->timer_list;
	while (((this = prev->next) != NULL) && (this->timeout <= delta_to)) {
		delta_to -= this->timeout;
		prev = this;
	}
	if (this != NULL)
		this->timeout -= delta_to;

	newto->fun = fun;
	newto->arg = arg;
	newto->timeout = delta_to;

	/* insert the new timeout */
	newto->next = this;
	prev->next = newto;

	if (newto == hwtmr->timer_list.next && hwtmr->timer_allowed) {
		hwtmr->set_timer((void *)hwtmr, newto->timeout);
		hwtmr->timer_armed = TRUE;
	}

	return TRUE;
}

/* Remove specified timeout from the list */
void
wlc_hwtimer_del_timeout(wlc_hwtimer_info_t *hwtmr, wlc_hwtimer_to_t *newto)
{
	wlc_hwtimer_to_t *this, *prev = &hwtmr->timer_list;

	while (((this = prev->next) != NULL)) {
		if (this == newto) {
			if (this->next != NULL)
				this->next->timeout += this->timeout;
			prev->next = this->next;
			this->fun = NULL;
			break;
		}
		prev = this;
	}
}

void
wlc_hwtimer_init_timeout(wlc_hwtimer_to_t *newto)
{
	bzero(newto, sizeof(wlc_hwtimer_to_t));
}

wlc_hwtimer_to_t *
wlc_hwtimer_alloc_timeout(wlc_info_t *wlc)
{
	wlc_hwtimer_to_t *newto;

	newto = (wlc_hwtimer_to_t *)MALLOC(wlc->osh, sizeof(wlc_hwtimer_to_t));
	if (newto == NULL) {
		WL_ERROR(("%s: failed to allocate memory for hwtime timeout obj\n", __FUNCTION__));
	}
	else {
		wlc_hwtimer_init_timeout(newto);
	}

	return (newto);
}

void
wlc_hwtimer_free_timeout(wlc_info_t *wlc, wlc_hwtimer_to_t *newto)
{
	if (newto != NULL) {
		MFREE(wlc->osh, newto, sizeof(wlc_hwtimer_to_t));
	}
}

/* gptimer specific helper functions for setting the
 * gettime, set_timer, ack_timer functions in the
 * wlc_hwtimer_info_t object for wlc->gptimer.
 */
static uint
wlc_hwtimer_gptimer_gettime(void *arg)
{
	wlc_hwtimer_info_t *hwtmr = (wlc_hwtimer_info_t *)arg;
	wlc_info_t *wlc = hwtmr->wlc;

	return ((uint)R_REG(wlc->osh, &wlc->regs->tsf_timerlow));
}

static void
wlc_hwtimer_gptimer_set_timeout(void *arg, uint timeout)
{
	wlc_hwtimer_info_t *hwtmr = (wlc_hwtimer_info_t *)arg;

	wlc_hwtimer_gptimer_set(hwtmr->wlc, timeout);
}

static void
wlc_hwtimer_gptimer_ack(void *arg)
{
	wlc_hwtimer_info_t *hwtmr = (wlc_hwtimer_info_t *)arg;

	wlc_hwtimer_gptimer_set(hwtmr->wlc, 0);
}

/* This function needs to be called if the user of gptimer requires the device to
 * stay awake while gptimer is running.
 * An exception to this rule would be if the user of gptimer knows that the device
 * will always be awake when it is using gptimer.
 */
void wlc_hwtimer_gptimer_wake_upd(wlc_info_t *wlc, mbool requestor, bool set)
{
	mbool old_req = wlc->gptimer_stay_awake_req;

	if (set) {
		mboolset(wlc->gptimer_stay_awake_req, requestor);
		/* old request was cleared, we just set a new request.
		 * need to update wake ctrl
		 */
		if (old_req == 0) {
			wlc_set_wake_ctrl(wlc);
		}
	}
	else {
		mboolclr(wlc->gptimer_stay_awake_req, requestor);
		/* if old request was set and now it is not set,
		 * need to update wake ctrl
		 */
		if (old_req && (wlc->gptimer_stay_awake_req == 0)) {
			wlc_set_wake_ctrl(wlc);
		}
	}
}

/* GP timer is a freerunning 32 bit counter, decrements at 1 us rate */
void
wlc_hwtimer_gptimer_set(wlc_info_t *wlc, uint us)
{
	ASSERT(wlc->pub->corerev >= 3); /* no gptimer in earlier revs */

	W_REG(wlc->osh, &wlc->regs->gptimer, us);
}

void wlc_hwtimer_gptimer_abort(wlc_info_t *wlc) {}
void wlc_hwtimer_gptimer_cb(wlc_info_t *wlc) {}

/*
 * This fn has all the high level dpc processing from wlc_dpc.
 * POLICY: no macinstatus change, no bounding loop.
 *         All dpc bounding should be handled in BMAC dpc, like txstatus and rxint
 */
void
wlc_high_dpc(wlc_info_t *wlc, uint32 macintstatus)
{
	d11regs_t *regs = wlc->regs;
#ifdef BCMDBG
	char flagstr[128];
	static const bcm_bit_desc_t int_flags[] = {
		{MI_MACSSPNDD,	"MACSSPNDD"},
		{MI_BCNTPL,	"BCNTPL"},
		{MI_TBTT,	"TBTT"},
		{MI_BCNSUCCESS,	"BCNSUCCESS"},
		{MI_BCNCANCLD,	"BCNCANCLD"},
		{MI_ATIMWINEND,	"ATIMWINEND"},
		{MI_PMQ,	"PMQ"},
		{MI_NSPECGEN_0,	"NSPECGEN_0"},
		{MI_NSPECGEN_1,	"NSPECGEN_1"},
		{MI_MACTXERR,	"MACTXERR"},
		{MI_NSPECGEN_3,	"NSPECGEN_3"},
		{MI_PHYTXERR,	"PHYTXERR"},
		{MI_PME,	"PME"},
		{MI_GP0,	"GP0"},
		{MI_GP1,	"GP1"},
		{MI_DMAINT,	"DMAINT"},
		{MI_TXSTOP,	"TXSTOP"},
		{MI_CCA,	"CCA"},
		{MI_BG_NOISE,	"BG_NOISE"},
		{MI_DTIM_TBTT,	"DTIM_TBTT"},
		{MI_PRQ,	"PRQ"},
		{MI_PWRUP,	"PWRUP"},
		{MI_BT_RFACT_STUCK,	"BT_RFACT_STUCK"},
		{MI_BT_PRED_REQ,	"BT_PRED_REQ"},
		{MI_RFDISABLE,	"RFDISABLE"},
		{MI_TFS,	"TFS"},
		{MI_PHYCHANGED,	"PHYCHANGED"},
		{MI_TO,	"TO"},
		{0, NULL}
	};

	if (macintstatus & ~(MI_TBTT | MI_TXSTOP)) {
		bcm_format_flags(int_flags, macintstatus, flagstr, sizeof(flagstr));
		WL_TRACE(("wl%d: macintstatus 0x%x %s\n", wlc->pub->unit, macintstatus, flagstr));
	}
#endif /* BCMDBG */

#ifdef MBSS
	if (MBSS_ENAB(wlc->pub)) {
		if (macintstatus & (MI_TBTT | MI_DTIM_TBTT)) {
			if (MBSS_ENAB16(wlc->pub))
				(void)wlc_ap_mbss16_tbtt(wlc, macintstatus);
			else
				(void)wlc_ap_mbss4_tbtt(wlc, macintstatus);
		}
	}
#endif /* MBSS */

	/* BCN template is available */
	/* ZZZ: Use AP_ACTIVE? */
	if (AP_ENAB(wlc->pub) && (!APSTA_ENAB(wlc->pub) || wlc->aps_associated) &&
	    (macintstatus & MI_BCNTPL)) {
		WL_APSTA_BCN(("wl%d: wlc_dpc: template -> wlc_update_beacon()\n",
			wlc->pub->unit));
		wlc_update_beacon(wlc);
	}

	/* TBTT indication */
	/* ucode only gives either TBTT or DTIM_TBTT, not both */
	if (macintstatus & (MI_TBTT | MI_DTIM_TBTT))
		wlc_tbtt(wlc, regs);

	/* TX FIFO suspend/flush completion */
	if (macintstatus & MI_TXSTOP) {
		if (wlc_bmac_tx_fifo_suspended(wlc->hw, TX_DATA_FIFO)) {
			/* handle a scan request for tx suspend */
			wlc_scan_fifo_suspend_complete(wlc->scan);
#ifdef STA
#ifdef WLRM
			/* handle a radio measurement request for tx suspend */
			if (wlc->rm_info->rm_state->step == WLC_RM_WAIT_TX_SUSPEND)
				wl_add_timer(wlc->wl, wlc->rm_info->rm_timer, 0, 0);
#endif
			/* move to next quiet state if both DATA and CTL fifos are suspended */
			if ((QUIET_STATE(wlc) & WAITING_FOR_FLUSH_COMPLETE) &&
			    wlc_bmac_tx_fifo_suspended(wlc->hw, TX_CTL_FIFO)) {
				wlc->quiet->_state &= ~WAITING_FOR_FLUSH_COMPLETE;
				wlc_start_quiet2(wlc);
			}
#endif /* STA */
		}
	}

	if (macintstatus & MI_GP0) {

#ifdef BCMDBG
		wlc_dump_ucode_fatal(wlc);
#else
		WL_ERROR(("wl%d: PSM microcode watchdog fired at %d (seconds). Resetting.\n",
			wlc->pub->unit, wlc->pub->now));
#endif /* BCMDBG */

		if (!((CHIPID(wlc->pub->sih->chip) == BCM4321_CHIP_ID) &&
		      (CHIPREV(wlc->pub->sih->chiprev) == 0)))
			ASSERT("PSM Watchdog" && 0);

		WLCNTINCR(wlc->pub->_cnt->psmwds);

		/* big hammer */
		wl_init(wlc->wl);
	}

	/* gptimer timeout */
	if (macintstatus & MI_TO) {
		wlc_hwtimer_isr(wlc->gptimer);
	}

#ifdef STA
	if (macintstatus & MI_RFDISABLE) {
		WL_ERROR(("wl%d: MAC Detected a change on the RF Disable Input 0x%x\n",
			wlc->pub->unit, R_REG(wlc->osh, &regs->phydebug) & PDBG_RFD));
		/* delay the cleanup to wl_down in IBSS case */
#ifndef WLLMAC_ONLY
		if (!LMAC_ENAB(wlc->pub) &&
		    (R_REG(wlc->osh, &regs->phydebug) & PDBG_RFD)) {
			int idx;
			wlc_bsscfg_t *bsscfg;
			FOREACH_BSS(wlc, idx, bsscfg) {
				/* all bsscfg including AP's for Win7 */
				if ((!WIN7_OS(wlc->pub) && !BSSCFG_STA(bsscfg)) ||
				    !bsscfg->enable || !bsscfg->BSS)
					continue;
				WL_APSTA_UPDN(("wl%d: wlc_dpc: rfdisable -> wlc_bsscfg_disable()\n",
					wlc->pub->unit));
				wlc_bsscfg_disable(wlc, bsscfg);
			}
		}
#endif /* !WLLMAC_ONLY */
	}
#endif /* STA */

	/* send any enq'd tx packets. Just makes sure to jump start tx */
	if (!pktq_empty(&wlc->active_queue->q))
		wlc_send_q(wlc, wlc->active_queue);

#ifdef WLC_HIGH_ONLY
#else
	ASSERT(wlc_ps_check(wlc));
#endif
}

#if defined(MBSS)
/* Under MBSS, this routine handles all TX dma done packets from the ATIM fifo. */
static void
wlc_mbss_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, void *pkt, uint16 fc,
	wlc_pkttag_t *pkttag, uint supr_status)
{
	wlc_bsscfg_t *bsscfg = NULL;
	int bss_idx;
	bool free_pkt = FALSE;

	bss_idx = (int)(WLPKTTAG_BSSIDX_GET(pkttag));
#if defined(BCMDBG)     /* Verify it's a reasonable index */
	if ((bss_idx < 0) || (bss_idx >= WLC_MAXBSSCFG) ||
	    (wlc->bsscfg[bss_idx] == NULL)) {
		WL_ERROR(("%s: bad BSS idx\n", __FUNCTION__));
		ASSERT("MBSS dotxstatus: bad BSS idx\n" && 0);
		return;
	}
#endif /* BCMDBG */

	/* For probe resp, this is really only used for counters */
	bsscfg = wlc->bsscfg[bss_idx];
	ASSERT(bsscfg != NULL);

	/* Being in the ATIM fifo, it must be a beacon or probe response */
	switch (fc & FC_KIND_MASK) {
	case FC_PROBE_RESP:
		/* Requeue suppressed probe response if due to TBTT */
		if (supr_status == TX_STATUS_SUPR_TBTT) {
			int txerr;
			WLCNTINCR(bsscfg->cnt->prb_resp_retrx);
#ifdef WLC_HIGH_ONLY
			if (RPCTX_ENAB(wlc->pub))
				txerr = wlc_rpctx_tx(wlc->rpctx, TX_ATIM_FIFO, pkt, TRUE, -1, 1);
			else
#endif /* WLC_HIGH_ONLY */
				txerr = dma_txfast(wlc->hw->di[TX_ATIM_FIFO], pkt, TRUE);

			if (txerr < 0) {
				WL_MBSS(("Failed to retransmit suppressed probe resp for bss %d\n",
					WLC_BSSCFG_IDX(bsscfg)));
				WLCNTINCR(bsscfg->cnt->prb_resp_retrx_fail);
				free_pkt = TRUE;
			}
		} else {
			free_pkt = TRUE;
			if (supr_status == TX_STATUS_SUPR_EXPTIME) {
				WLCNTINCR(bsscfg->cnt->prb_resp_ttl_expy);
			}
		}
		break;
	case FC_BEACON:
		if (supr_status)
			WL_ERROR(("%s: Suppressed Beacon frame = 0x%x\n", __FUNCTION__,
			          supr_status));

		if (WLPKTFLAG_BSS_DOWN_GET(pkttag)) { /* Free the pkt since BSS is gone */
			WL_MBSS(("BSSCFG down on bcn done\n"));
			WL_ERROR(("%s: in_use_bitmap = 0x%x pkt: %p\n", __FUNCTION__,
			          bsscfg->bcn_template->in_use_bitmap, pkt));
			free_pkt = TRUE;
			break; /* All done */
		}
		ASSERT(bsscfg->up);
		/* Assume only one beacon in use at a time */
		bsscfg->bcn_template->in_use_bitmap = 0;
#if defined(WLC_SPT_DEBUG) && defined(BCMDBG)
		if (supr_status != 0) {
			bsscfg->bcn_template->suppressed++;
		}
#endif /* WLC_STP_DEBUG && BCMDBG */
		break;
	default: /* Bad packet type for ATIM fifo */
		ASSERT(0 && "TX done ATIM packet neither BCN or PRB");
		break;
	}

	if (supr_status != 0) {
		WLCNTINCR(wlc->pub->_cnt->atim_suppress_count);
	}

	if (free_pkt) {
		PKTFREE(wlc->osh, pkt, TRUE);
	}
}
#else
#define wlc_mbss_dotxstatus(wlc, txs, pkt, fc, pkttag, supr_status)
#endif /* MBSS */

static void
wlc_nav_reset_war(wlc_info_t *wlc, bool disable)
{
	if (disable) {
		wlc->nav_reset_war_disable = TRUE;
		wlc_mhf(wlc, MHF2, MHF2_BTCANTMODE, MHF2_BTCANTMODE, WLC_BAND_ALL);
	} else {
		wlc->nav_reset_war_disable = FALSE;
		wlc_mhf(wlc, MHF2, MHF2_BTCANTMODE, 0, WLC_BAND_ALL);
	}
}

static void*
wlc_15420war(wlc_info_t *wlc, uint queue)
{
	hnddma_t *di;
	void *p;

	ASSERT(queue < NFIFO);

	if (PIO_ENAB(wlc->pub))
		return (NULL);

	if ((D11REV_IS(wlc->pub->corerev, 4)) || (D11REV_GT(wlc->pub->corerev, 6)))
		return (NULL);

	di = wlc->hw->di[queue];
	ASSERT(di != NULL);

	/* get next packet, ignoring XmtStatus.Curr */
	p = dma_getnexttxp(di, HNDDMA_RANGE_ALL);

	/* sw block tx dma */
	dma_txblock(di);

	/* if tx ring is now empty, reset and re-init the tx dma channel */
	if (dma_txactive(wlc->hw->di[queue]) == 0) {
		WLCNTINCR(wlc->pub->_cnt->txdmawar);
		if (!dma_txreset(di))
			WL_ERROR(("wl%d: %s: dma_txreset[%d]: cannot stop dma\n",
			          wlc->pub->unit, __FUNCTION__, queue));
		dma_txinit(di);
	}

	return (p);
}

static void
wlc_war16165(wlc_info_t *wlc, bool tx)
{
	if (tx) {
		/* the post-increment is used in STAY_AWAKE macro */
		if (wlc->txpend16165war++ == 0)
			wlc_set_ps_ctrl(wlc->cfg);
	} else {
		wlc->txpend16165war--;
		if (wlc->txpend16165war == 0)
			wlc_set_ps_ctrl(wlc->cfg);
	}
}

/* update tx header cache flag (wlc->txc) */
void
wlc_txc_upd(wlc_info_t *wlc)
{
	int bad;
	int i;

	if (!WLC_TXC_ENAB(wlc))
		return;

	switch (wlc->txc_policy) {
	case OFF:
		wlc->txc = FALSE;
		break;
	default:
		bad = WLBA_ENAB(wlc->pub);
		for (i = 0; i < NFIFO; i++)
			bad |= (wlc->fragthresh[i] < DOT11_DEFAULT_FRAG_LEN);
		wlc->txc = (bad == 0);
		break;
	}
}

/*
 * Return driver capability string where the "capability" means *both* the sw and hw exist.
 */
static char*
wlc_cap(wlc_info_t *wlc, char *buf, uint bufsize)
{
	struct bcmstrbuf b;
	ASSERT(bufsize >= WLC_IOCTL_SMLEN);

	bcm_binit(&b, buf, bufsize);

	/* pure software-only components */

/* Need AP defined here to print out capability only if enabled */
#ifdef AP
	bcm_bprintf(&b, "ap ");
#endif

#ifdef STA
	bcm_bprintf(&b, "sta ");
#endif /* STA */
#ifdef WET
	bcm_bprintf(&b, "wet ");
#endif /* WET */
#ifdef MAC_SPOOF
	bcm_bprintf(&b, "mac_spoof ");
#endif /* MAC_SPOOF */
#ifdef TOE
	bcm_bprintf(&b, "toe ");
#endif /* TOE */
#ifdef WLLED
	bcm_bprintf(&b, "led ");
#endif /* WLLED */
#ifdef WME
	bcm_bprintf(&b, "wme ");
#endif /* WME */
#ifdef WLPIO
	bcm_bprintf(&b, "pio ");
#endif /* PIO */
#ifdef WL11D
	bcm_bprintf(&b, "802.11d ");
#endif /* WL11D */
#ifdef WL11H
	bcm_bprintf(&b, "802.11h ");
#endif /* WL11H */
#ifdef WLRM
	bcm_bprintf(&b, "rm ");
#endif /* WLRM */
#ifdef WLCQ
	bcm_bprintf(&b, "cqa ");
#endif /* WLCQ */
#ifdef BCMRECLAIM
	bcm_bprintf(&b, "reclm ");
#endif /* BCMRECLAIM */
#ifdef WLCAC
	bcm_bprintf(&b, "cac ");
#endif /* WLCAC */
#ifdef MBSS
	/* Special case for 4313 to only advertise mbss4 */
	if (D11REV_ISMBSS4(wlc->pub->corerev) || D11REV_IS(wlc->pub->corerev, 24))
		bcm_bprintf(&b, "mbss4 ");
	else if (D11REV_ISMBSS16(wlc->pub->corerev) && wlc_bmac_ucodembss_hwcap(wlc->hw))
		bcm_bprintf(&b, "mbss%d ", wlc->pub->tunables->maxucodebss);
#endif /* MBSS */

	/* combo software+hardware components */

	if (NBANDS(wlc) > 1)
		bcm_bprintf(&b, "dualband ");
#ifdef WLAFTERBURNER
	if (wlc_abcap(wlc))
		bcm_bprintf(&b, "afterburner ");
#endif /* WLAFTERBURNER */
#ifdef WLAMPDU
	if (wlc_ampdu_cap(wlc->ampdu))
		bcm_bprintf(&b, "ampdu ");
#endif
#ifdef WLAMSDU
	if (wlc_amsdurx_cap(wlc->ami))
		bcm_bprintf(&b, "amsdurx ");

	if (wlc_amsdutx_cap(wlc->ami))
		bcm_bprintf(&b, "amsdutx ");
#endif
#ifdef WLBA
	if (wlc_ba_cap(wlc->bastate))
		bcm_bprintf(&b, "ba ");
#endif
#ifdef WOWL
	if (wlc_wowl_cap(wlc))
		bcm_bprintf(&b, "wowl ");
#endif
#ifdef WMF
	bcm_bprintf(&b, "wmf ");
#endif
#ifdef RXCHAIN_PWRSAVE
	bcm_bprintf(&b, "rxchain_pwrsave ");
#endif
#ifdef RADIO_PWRSAVE
	bcm_bprintf(&b, "radio_pwrsave ");
#endif
#ifdef WLBTAMP
	bcm_bprintf(&b, "btamp ");
#endif
#ifdef WLP2P
	if (wlc_p2p_cap(wlc->p2p))
		bcm_bprintf(&b, "p2p ");
#endif
#ifdef BCM_DCS
	bcm_bprintf(&b, "bcm_dcs ");
#endif
	return (buf);
}

#ifdef WLAFTERBURNER
/* return true if underlying hardware is Afterburner capable, otherwise false */
static bool
wlc_abcap(wlc_info_t *wlc)
{
	bool rev_check = ((D11REV_GT(wlc->pub->corerev, 4)) && !PIO_ENAB(wlc->pub));
	bool flag_check = TRUE;
	bool chipid_check = TRUE;

#if defined(WLC_HIGH_ONLY)
	/* complicate to support in SplitMAC architecture. AMPDU is much better, block it */
	return FALSE;
#endif

	if (CHIPID(wlc->pub->sih->chip) == BCM4318_CHIP_ID &&
	    wlc->pub->sih->boardvendor != VENDOR_BUFFALO)
		/* 4318: No encore -> no ab unless overridden */
		chipid_check = (wlc->band->abgphy_encore ||
			(wlc->pub->wlfeatureflag & WL_SWFL_ABENCORE));

	flag_check = ((wlc->pub->boardflags & BFL_AFTERBURNER) ||
	              wlc->pub->wlfeatureflag & WL_SWFL_ABBFL);


	return (rev_check && flag_check && chipid_check);
}

/* Set afterburner_override to requested value -- if possible. */
int
wlc_abo(wlc_info_t *wlc, int val)
{
	if (val != OFF) {
		if (!wlc_abcap(wlc)) {
			WL_ERROR(("wl%d: device not afterburner capable\n", wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}
#ifndef WL11N
		if (WME_ENAB(wlc->pub)) {
			WL_ERROR(("wl%d: not supported with wsec/wme\n", wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}
#endif
#ifdef WLP2P
		if (P2P_ENAB(wlc->pub)) {
			WL_ERROR(("wl%d: not supported with p2p\n", wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}
#endif
		if (WLBA_ENAB(wlc->pub)) {
			WL_ERROR(("wl%d: not supported with ba\n", wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}
		/* allowed STA to set afterburner_override = AUTO when AMPDU is enabled */
		if (AMPDU_ENAB(wlc->pub) && (AP_ONLY(wlc->pub) || val == ON)) {
			WL_ERROR(("wl%d: not supported with ampdu\n", wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}
		if (APSTA_ENAB(wlc->pub) && (val == ON)) {
			WL_ERROR(("wl%d: forced afterburner unsupported in apsta mode\n",
				wlc->pub->unit));
			return BCME_UNSUPPORTED;
		}

#ifdef WLC_HIGH_ONLY
		/* complicate to support. AMPDU is much better */
		return BCME_UNSUPPORTED;
#endif
	}

	wlc->afterburner_override = val;

#if defined(WL11N) && defined(AP)
	if (AP_ONLY(wlc->pub))
		wlc_switch_ab_11n(wlc, (wlc->afterburner_override == ON) ? TRUE : FALSE, TRUE);
	else
		wlc_afterburner(wlc, ((wlc->afterburner_override == ON) ? TRUE : FALSE));
#else /* defined (WL11N) && defined(AP) */
	wlc_afterburner(wlc, ((wlc->afterburner_override == ON) ? TRUE : FALSE));
#endif /* defined (WL11N) && defined(AP) */

	wlc_update_brcm_ie(wlc);
	return (0);
}

void
wlc_afterburner(wlc_info_t *wlc, bool state)
{
	struct scb *scb;
	struct scb_iter scbiter;
	ASSERT(!state || (wlc->afterburner_override != OFF));

	/* afterburner is BSS only */
	if (state && wlc->ibss_bsscfgs > 0)
		return;

#ifdef NCONF
	if ((WLCISNPHY(wlc->band) && D11REV_GE(wlc->pub->corerev, 16)) || WLCISHTPHY(wlc->band)) {
		/* WAR: EDCRS cannot be enabled with afterburner on */
		if (state)
			AND_REG(wlc->osh, &wlc->regs->ifs_ctl1, ~IFS_CTL1_EDCRS);
	}
#endif /* NCONF */

	wlc->afterburner = state;
	wlc->pub->txmaxpkts = state ? MAXTXPKTS_AB : MAXTXPKTS;

	/* we need to take care of wlc_rate_init for every scb here */
	FOREACHSCB(wlc->scbstate, &scbiter, scb)
		wlc_scb_ratesel_init(wlc, scb);

	if (!wlc->pub->up)
		return;

	/* toggle shm mhf, burstsize, antcnt */
	wlc_mhf(wlc, MHF1, MHF1_AFTERBURNER, (state ? MHF1_AFTERBURNER : 0), WLC_BAND_ALL);
	wlc_frameburst_size(wlc, state);
	wlc_write_shm(wlc, M_MAX_ANTCNT, (state ? ANTCNT_AB : ANTCNT));
}

static void
wlc_afterburner_nack(wlc_info_t *wlc, uint queue, tx_status_t *txs)
{
	hnddma_t *di;
	bool suspended;
	d11txh_t *txh;
	struct scb *scb;
	uint frmrtx;
	void *p;
	uint8 mcs = MCS_INVALID;
	uint8 antselid = 0;
#ifdef WL11N
	uint8 frametype;
#endif

	di = wlc->hw->di[queue];

	/* sanity check */
	ASSERT(di);
	ASSERT(wlc->afterburner_override != OFF);
	ASSERT(!PIO_ENAB(wlc->pub));

	/* get corresponding packet pointer */
	p = dma_peeknexttxp(di);

	if (p) {
		/* bumpup frame tx count (because ucode doesn't) */
		frmrtx = ((txs->status & TX_STATUS_FRM_RTX_MASK) >> TX_STATUS_FRM_RTX_SHIFT) + 2;
		txs->status = (txs->status & ~TX_STATUS_FRM_RTX_MASK) | (frmrtx <<
			TX_STATUS_FRM_RTX_SHIFT);

		/* update rate state */
		txh = (d11txh_t*)PKTDATA(wlc->osh, p);
		if ((scb = wlc_scbfind(wlc,  (struct ether_addr*)txh->TxFrameRA))) {
			uint16 sfbl, lfbl;

			if (queue < AC_COUNT) {
				sfbl = WLC_WME_RETRY_SFB_GET(wlc, wme_fifo2ac[queue]);
				lfbl = WLC_WME_RETRY_LFB_GET(wlc, wme_fifo2ac[queue]);
			} else {
				sfbl = wlc->SFBL;
				lfbl = wlc->LFBL;
			}
#ifdef WL11N
			frametype = ltoh16(txh->PhyTxControlWord) & PHY_TXC_FT_MASK;
			if (frametype == FT_HT || frametype == FT_N) {
				uint8 *plcp = (uint8 *)(txh + 1);
				mcs = plcp[0] & MIMO_PLCP_MCS_MASK;
			}
			if (WLANTSEL_ENAB(wlc))
				antselid = wlc_antsel_antsel2id(wlc->asi,
				                ltoh16(txh->ABI_MimoAntSel));
#endif
			wlc_ratesel_upd_txstatus_normalack(wlc->rsi, scb, txs, sfbl, lfbl,
				TRUE, ABURN_NACK_WEIGHT, mcs, antselid, FALSE);
		}
	}

	/* dma suspend */
	if (!(suspended = dma_txsuspendedidle(di))) {
		dma_txsuspend(di);
		SPINWAIT(!dma_txsuspendedidle(di), 10000);
		if (!dma_txsuspendedidle(di))  {
#ifdef BCMDBG
			char   dma_buf[200];
			struct bcmstrbuf b;

			bcm_binit(&b, dma_buf, (uint)sizeof(dma_buf));
			dma_dumptx(di, &b, FALSE);
			WL_ERROR(("Failed to stop Tx Dma...!!!\n %s", dma_buf));
#endif  /* BCMDBG */
			ASSERT("dma_txsuspendedidle" && 0);
		}
	}

	/* rotate dma tx entries */
	dma_txrotate(di);

	/* dma resume */
	if (!suspended)
		dma_txresume(di);
}
#endif /* WLAFTERBURNER */

static void
wlc_frameburst_size(wlc_info_t *wlc, bool aburn)
{
	if (!wlc->pub->up)
		return;

#ifdef WLAFTERBURNER
	wlc_write_shm(wlc, M_MBURST_SIZE, (aburn ? MAXTXFRAMEBURST_AB : MAXTXFRAMEBURST));
#else
	wlc_write_shm(wlc, M_MBURST_SIZE,
		AMPDU_HW_ENAB(wlc->pub) ? MAXTXFRAMEBURST_AMPDUHW : MAXTXFRAMEBURST);
#endif /* WLAFTERBURNER */
	wlc_update_txba_burst_war(wlc, NULL);
}

void
wlc_recover_pkts(wlc_info_t *wlc, uint queue)
{
	void *p = NULL;
	volatile uint32 intstatus =
	        R_REG(wlc->osh, &wlc->regs->intctrlregs[queue].intstatus);

	if (intstatus) {
		if (!(intstatus & I_XI))
			WL_ERROR(("%s: failure 0x%x\t", __FUNCTION__, intstatus));

		while ((p = GETNEXTTXP(wlc, queue))) {
			wlc_txfifo_complete(wlc, queue, 1);
			PKTFREE(wlc->osh, p, TRUE);
		}
		W_REG(wlc->osh, &wlc->regs->intctrlregs[queue].intstatus, intstatus);
	}
	while ((p = dma_rx(wlc->hw->di[RX_FIFO])))
		PKTFREE(wlc->osh, p, FALSE);
}

#ifdef WL_MULTIQUEUE
static struct scb*
wlc_recover_pkt_scb(wlc_info_t *wlc, void *pkt, d11txh_t *txh)
{
	struct scb *scb;

	scb = WLPKTTAG(pkt)->_scb;

	/* check to see if the SCB is just one of the permanent hwrs_scbs */
	if (scb == wlc->band->hwrs_scb ||
	    (NBANDS(wlc) > 1 && scb == wlc->bandstate[OTHERBANDUNIT(wlc)]->hwrs_scb)) {
		WL_MQ(("MQ: %s: recovering %p hwrs_scb\n",
		       __FUNCTION__, pkt));
		return scb;
	}

	if (ETHER_ISMULTI(txh->TxFrameRA)) {
		wlc_bsscfg_t *bsscfg;

		/*  use the bsscfg index in the packet tag to find out which
		 *  bsscfg this packet belongs to
		 */
		bsscfg = wlc->bsscfg[WLPKTTAGBSSCFGGET(pkt)];
		ASSERT(bsscfg != NULL);

		scb = WLC_BCMCSCB_GET(wlc, bsscfg);
		ASSERT(scb != NULL);

		WL_MQ(("MQ: %s: recovering %p bcmc scb\n",
		       __FUNCTION__, pkt));
	} else {
		uint16 mcl = ltoh16(txh->MacTxControlLow);

		scb = wlc_scbfindband(wlc, (struct ether_addr*)txh->TxFrameRA,
		                      ((mcl & TXC_FREQBAND_5G) == TXC_FREQBAND_5G) ?
		                      BAND_5G_INDEX : BAND_2G_INDEX);

#if defined(BCMDBG)
		if (scb != NULL) {
			char eabuf[ETHER_ADDR_STR_LEN];
			bcm_ether_ntoa(&scb->ea, eabuf);
			WL_MQ(("MQ: %s: recovering %p scb %p:%s\n", __FUNCTION__,
			       pkt, scb, eabuf));
		} else {
			WL_MQ(("MQ: %s: failed recovery scb for pkt %p\n", __FUNCTION__, pkt));
		}
#endif
	}

	if (scb != NULL)
		WLPKTTAGSCBSET(pkt, scb);
	else
		WLPKTTAGSCBCLR(pkt);

	return scb;
}
#endif /* WL_MULTIQUEUE */

#if defined(MACOSX)

#ifdef panic
#undef panic
#endif
void panic(const char *str, ...);
#endif /* MACOSX */

/* process an individual tx_status_t */
/* WLC_HIGH_API */
bool BCMFASTPATH
wlc_dotxstatus(wlc_info_t *wlc, tx_status_t *txs, uint32 frm_tx2)
{
	void *p;
	uint queue;
	int err = 0;
	d11txh_t *txh;
	struct scb *scb = NULL;
	bool update_rate, free_pdu;
	osl_t *osh;
	int tx_rts, tx_frame_count, tx_rts_count;
	uint totlen, supr_status;
	bool lastframe;
	struct dot11_header *h;
	uint16 fc;
	wlc_pkttag_t *pkttag;
	wlc_bsscfg_t *bsscfg = NULL;
	bool pkt_sent = FALSE;
	bool pkt_max_retries = FALSE;
	uint16 mcl;
	bool ack_recd = FALSE;
	uint8 ac;
#ifdef WLPKTDLYSTAT
	uint32 delay, now;
	wlc_scb_delay_stats_t *delay_stats;
#endif

	(void)(frm_tx2); /* Compiler reference to avoid unused variable warning */

	if (WL_PRHDRS_ON())
		wlc_print_txstatus(txs);


	/* discard intermediate indications for ucode with one legitimate case:
	 *   e.g. if "useRTS" is set. ucode did a successful rts/cts exchange, but the subsequent
	 *   tx of DATA failed. so it will start rts/cts from the beginning (resetting the rts
	 *   transmission count)
	 */
	if (!(txs->status & TX_STATUS_AMPDU) && (txs->status & TX_STATUS_INTERMEDIATE)) {
		WLCNTADD(wlc->pub->_cnt->txnoack, ((txs->status & TX_STATUS_FRM_RTX_MASK) >>
			TX_STATUS_FRM_RTX_SHIFT));
		return FALSE;
	}

	osh = wlc->osh;
	queue = txs->frameid & TXFID_QUEUE_MASK;
	ASSERT(queue < NFIFO);

	if (queue >= NFIFO) {
		p = NULL;
		goto fatal;
	}

	supr_status = txs->status & TX_STATUS_SUPR_MASK;
	if (FALSE)
		;
#ifdef WLP2P
	else if (P2P_ENAB(wlc->pub) &&
	         supr_status == TX_STATUS_SUPR_NACK_ABS)
		;
#endif
#ifdef WLAFTERBURNER
	/* afterburner nack */
	else if (supr_status == TX_STATUS_SUPR_NACK_ABS) {
		wlc_afterburner_nack(wlc, queue, txs);
		return FALSE;
	}
#endif
#ifdef WL_MULTIQUEUE
	/* Flushed packets have been re-enqueued, just toss the status */
	else if (supr_status == TX_STATUS_SUPR_FLUSH) {
		WL_MQ(("MQ: %s: Flush status for txs->frameid 0x%x\n", __FUNCTION__,
		       txs->frameid));
		return FALSE;
	}
#endif /* WL_MULTIQUEUE */

	p = GETNEXTTXP(wlc, queue);

	if (WLC_WAR16165(wlc))
		wlc_war16165(wlc, FALSE);

	if (p == NULL)
		p = wlc_15420war(wlc, queue);

#ifdef WL_MULTIQUEUE
	if (p == NULL)
		WL_MQ(("MQ: %s: txs->frameid 0x%x\n", __FUNCTION__, txs->frameid));
	else if (wlc->excursion_active || wlc->txfifo_detach_pending)
		WL_MQ(("MQ: %s: txs->frameid 0x%x\n", __FUNCTION__, txs->frameid));
#endif /* WL_MULTIQUEUE */

	ASSERT(p != NULL);

	PKTDBG_TRACE(wlc->osh, p, PKTLIST_MI_TFS_RCVD);

#ifdef MACOSX
	/* If the packet pointer is null, we will crash shortly.
	 * Dump a panic message for more accessible info in panic logs
	 */
	if (p == NULL) {
		OSL_LOG("mbuf", "wlc_dotxstatus: mbuf pointer null status:0x%x"
		        "pktpend: %d %d %d %d %d ap: %d\n", txs->status,
		        TXPKTPENDGET(wlc, TX_AC_BK_FIFO),
		        TXPKTPENDGET(wlc, TX_AC_BE_FIFO),
		        TXPKTPENDGET(wlc, TX_AC_VI_FIFO),
		        TXPKTPENDGET(wlc, TX_AC_VO_FIFO),
		        TXPKTPENDGET(wlc, TX_BCMC_FIFO),
		        AP_ENAB(wlc->pub));
	}
#endif /* MACOSX */

	if (p == NULL)
		goto fatal;

	txh = (d11txh_t *)PKTDATA(osh, p);
	mcl = ltoh16(txh->MacTxControlLow);

	if (AMPDU_HOST_ENAB(wlc->pub)) {
		ASSERT(txs->frameid == htol16(txh->TxFrameID));
		if (txs->frameid != htol16(txh->TxFrameID))
			goto fatal;
	}

	pkttag = WLPKTTAG(p);
	ac = WME_PRIO2AC(PKTPRIO(p));

#ifdef MACOSX
	/* If the packet tag pointer is null, we will crash shortly.
	 * Dump a panic message for more info in panic logs
	 */
	if (pkttag == NULL) {
		mbuf_t m = (mbuf_t)p;

		if (mbuf_type(m) == MBUF_TYPE_FREE) {
			panic("wlc_dotxstatus: no pkttag, mbuf %p is a free mbuf status:0x%x\n",
				m, txs->status);
		} else if (!(mbuf_flags(m) & MBUF_PKTHDR)) {
			panic("wlc_dotxstatus: no pkttag, mbuf %p is not a header mbuf "
				"status:0x%x\n", m, txs->status);
		} else {
			panic("wlc_dotxstatus: mbuf %p does not have a wl pkttag status:0x%x\n",
				m, txs->status);
		}
	}
#endif /* MACOSX */

	h = (struct dot11_header *)((uint8*)(txh + 1) + D11_PHY_HDR_LEN);
	fc = ltoh16(h->fc);

	if (MBSS_ENAB(wlc->pub) && (queue == TX_ATIM_FIFO)) {
		/* Under MBSS, all ATIM packets are handled by mbss_dotxstatus */
		wlc_mbss_dotxstatus(wlc, txs, p, fc, pkttag, supr_status);
		return FALSE;
	}

	if (ETHER_ISMULTI(txh->TxFrameRA)) {

		/*  use the bsscfg index in the packet tag to find out which
		 *  bsscfg this packet belongs to
		 */

		bsscfg = wlc_bsscfg_find(wlc, WLPKTTAGBSSCFGGET(p), &err);
		if (bsscfg != NULL) {
#if defined(MBSS)
			if (MBSS_ENAB(wlc->pub) && (queue == TX_BCMC_FIFO)) {
				bsscfg->mc_fifo_pkts--; /* Decrement mc fifo counter */
				/* Check if this was last frame uCode knew about */
				if (bsscfg->bcmc_fid_shm == txs->frameid) {
					bsscfg->bcmc_fid_shm = INVALIDFID;
					if ((bsscfg->flags & WLC_BSSCFG_PS_OFF_TRANS) &&
					    (bsscfg->bcmc_fid == INVALIDFID)) {
					/* Mark transition complete as pkts out of BCMC fifo */
						wlc_apps_bss_ps_off_done(wlc, bsscfg);
					}
				}
			}
#endif /* MBSS */
			/* With pkt suppression, need to assign SCB for any frame */
			scb = WLC_BCMCSCB_GET(wlc, bsscfg);
			ASSERT(scb != NULL);
		}
	} else {
		/* For ucast frames, lookup the scb directly by the RA.
		 * The scb may not be found if we sent a frame with no scb, or if the
		 * scb was deleted while the frame was queued.
		 */
		if ((scb = wlc_scbfindband(wlc, (struct ether_addr*)txh->TxFrameRA,
		                           ((mcl & TXC_FREQBAND_5G) == TXC_FREQBAND_5G) ?
		                           BAND_5G_INDEX : BAND_2G_INDEX)) != NULL) {
			bsscfg = SCB_BSSCFG(scb);
			ASSERT(bsscfg != NULL);
		}
#ifdef STA
		else {
			/* no scb, but we may be able to look up a bsscfg by the BSSID if this
			 * was a frame sent by an infra STA to its AP
			 */
			bsscfg = wlc_bsscfg_find_by_bssid(wlc, (struct ether_addr *)txh->TxFrameRA);
		}
#endif /* STA */
	}

	if (scb != NULL)
		WLPKTTAGSCBSET(p, scb);

	if (N_ENAB(wlc->pub)) {
		uint8 *plcp = (uint8 *)(txh + 1);
		if (PLCP3_ISSGI(plcp[3]))
			WLCNTINCR(wlc->pub->_cnt->txmpdu_sgi);
		if (PLCP3_ISSTBC(plcp[3]))
			WLCNTINCR(wlc->pub->_cnt->txmpdu_stbc);
	}

#ifdef WLAMPDU
	if (WLPKTFLAG_AMPDU(pkttag)) {
		if ((mcl & TXC_AMPDU_MASK) == TXC_AMPDU_NONE) {
			wlc_ampdu_dotxstatus_regmpdu(wlc->ampdu, scb, p, txs);
			/* continue with rest of regular mpdu processing */
		} else {
			bool ret;
			ret = wlc_ampdu_dotxstatus(wlc->ampdu, scb, p, txs);
#if defined(ADV_PS_POLL)
			if (bsscfg != NULL && BSSCFG_STA(bsscfg) && bsscfg->BSS) {
				wlc_pm_st_t *pm = bsscfg->pm;
				if (pm->adv_ps_poll && pm->send_pspoll_after_tx &&
				    !pm->PSpoll && TXPKTPENDTOT(wlc) == 0) {
					/* Re-using existing implementation of pspoll_prd */
					wlc_pspoll_timer(bsscfg);
					pm->send_pspoll_after_tx = FALSE;
				}
			}
#endif /* defined(ADV_PS_POLL) */
			return ret;
		}
	}
#endif /* WLAMPDU */

	tx_rts = htol16(txh->MacTxControlLow) & TXC_SENDRTS;

	tx_frame_count = (txs->status & TX_STATUS_FRM_RTX_MASK) >> TX_STATUS_FRM_RTX_SHIFT;
	tx_rts_count = (txs->status & TX_STATUS_RTS_RTX_MASK) >> TX_STATUS_RTS_RTX_SHIFT;

	/* count all retransmits */
	if (tx_frame_count)
		WLCNTADD(wlc->pub->_cnt->txretrans, (tx_frame_count - 1));
	if (tx_rts_count)
		WLCNTADD(wlc->pub->_cnt->txretrans, (tx_rts_count - 1));

	lastframe = (fc & FC_MOREFRAG) == 0;

	totlen = pkttotlen(osh, p);

	/* plan for success */
	update_rate = (pkttag->flags & WLF_RATE_AUTO) ? TRUE : FALSE;
	free_pdu = TRUE;

#if defined(WLP2P) && defined(BCMDBG)
	if (fc == FC_ACTION || fc == FC_PROBE_REQ || fc == FC_PROBE_RESP) {
		char eabuf[ETHER_ADDR_STR_LEN];
		char *frmtype_str = NULL;
		switch (fc) {
			case FC_ACTION:
				frmtype_str = "ACTION";
				break;
			case FC_PROBE_REQ:
				frmtype_str = "PROBE_REQ";
				break;
			case FC_PROBE_RESP:
				frmtype_str = "PROBE_RESP";
				break;
		}
		WL_P2P(("wl%d: %s frm tx to %s, seqnum %d, txstatus 0x%x, totlen %d, pkt %p\n",
		        wlc->pub->unit, frmtype_str, bcm_ether_ntoa(&h->a1, eabuf),
		        txs->sequence, txs->status, totlen, p));
		if (fc == FC_ACTION) {
			uint8 *pbody = (uint8 *)&h->a4;
			WL_P2P(("wl%d: action_category %d, action_id %d\n", wlc->pub->unit,
			        pbody[DOT11_ACTION_CAT_OFF], pbody[DOT11_ACTION_ACT_OFF]));
		}
	}
#endif /* WLP2P && BCMDBG */

	/* process txstatus info */
	if (txs->status & TX_STATUS_ACK_RCV) {
		/* success... */

		ack_recd = TRUE;
		/* update counters */
		WLCNTINCR(wlc->pub->_cnt->txfrag);
		WLCNTADD(wlc->pub->_cnt->txnoack, (tx_frame_count - 1));
		if (tx_frame_count > 1)
			wlc->txretried += tx_frame_count - 1;
		if (lastframe) {
			WLCNTINCR(wlc->pub->_cnt->txfrmsnt);
			if (wlc->txretried >= 1)
				WLCNTINCR(wlc->pub->_cnt->txretry);
			if (wlc->txretried > 1)
				WLCNTINCR(wlc->pub->_cnt->txretrie);
		}
		if (scb)
			scb->used = wlc->pub->now;

		pkt_sent = TRUE;

	} else if (((txs->status & TX_STATUS_MASK) == TX_STATUS_NO_ACK) &&
	           (WLPKTFLAG_BA(pkttag) || WLPKTFLAG_AMSDU(pkttag) || WLPKTFLAG_RIFS(pkttag))) {
		update_rate = FALSE;

		/* update counters */
		WLCNTINCR(wlc->pub->_cnt->txfrag);
		if (lastframe)
			WLCNTINCR(wlc->pub->_cnt->txfrmsnt);

		/* should not update scb->used for ap otherwise the ap probe will not work */
		if (scb && BSSCFG_STA(bsscfg))
			scb->used = wlc->pub->now;

		pkt_sent = TRUE;

	} else if (supr_status == TX_STATUS_SUPR_FRAG) {
		/* subsequent frag failure... */
		update_rate = FALSE;
	} else if (supr_status == TX_STATUS_SUPR_BADCH) {
		update_rate = FALSE;
		WLCNTINCR(wlc->pub->_cnt->txchanrej);
	} else if (supr_status == TX_STATUS_SUPR_EXPTIME) {
		WLCNTINCR(wlc->pub->_wme_cnt->tx_expired[(WME_ENAB(wlc->pub) ?
			WME_PRIO2AC(PKTPRIO(p)) : AC_BE)].packets);
		WLCNTINCR(wlc->pub->_cnt->txexptime);	/* generic lifetime expiration */

		/* Interference detected */
		if (wlc->rfaware_lifetime)
			wlc_exptime_start(wlc);
	} else if (supr_status == TX_STATUS_SUPR_PMQ) {
		update_rate = FALSE;

		if (scb != NULL && bsscfg != NULL && BSSCFG_AP(bsscfg)) {
#ifdef BCMDBG_ERR
			char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG_ERR */


			if (SCB_ISMULTI(scb) || SCB_ASSOCIATED(scb)) {
				free_pdu = wlc_apps_suppr_frame_enq(wlc, p, txs, lastframe);
			} else {
				WL_ERROR(("wl%d: wlc_dotxstatus: "
				          "Suppressed frame 0x%x for %s tossed\n", wlc->pub->unit,
				          txs->frameid,
				          bcm_ether_ntoa((struct ether_addr *)txh->TxFrameRA,
				                         eabuf)));
			}
		}

		/* If the packet is not queued for later delivery, it will be freed
		 * and any packet callback needs to consider this as a un-ACKed packet.
		 * Change the txstatus to simple no-ack instead of suppressed.
		 */
		if (free_pdu) {
			txs->status = txs->status & ~TX_STATUS_SUPR_MASK;
		}
	} else if (supr_status == TX_STATUS_SUPR_FLUSH) {
		update_rate = FALSE;
		free_pdu = FALSE;

		ASSERT(0);
	} else if (supr_status == TX_STATUS_SUPR_UF) {
		update_rate = FALSE;
	}
	/* scb could have been freed while this frame was on the FIFO */
#ifdef WLP2P
	else if (P2P_ENAB(wlc->pub) && supr_status == TX_STATUS_SUPR_NACK_ABS) {
		if (bsscfg != NULL) {
#ifdef BCMDBG
			uint32 tsf_l = R_REG(wlc->osh, &wlc->regs->tsf_timerlow);

			if (WL_P2P_ON())
				wlc_print_txstatus(txs);
#endif

			/* This is possible if we got a packet suppression
			 * before getting ABS interrupt
			 */
			if (!BSS_TX_SUPR(bsscfg))
				wlc_bsscfg_tx_stop(bsscfg);

			free_pdu = wlc_bsscfg_txq_enq(wlc, bsscfg, p,
			                              WLC_PRIO_TO_HI_PREC(PKTPRIO(p)));

			WL_P2P(("wl%d.%d: %s: suppress for Absence at tick 0x%x (local) "
			        "0x%x (remote), frame re-enqueued %s\n",
			        wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__,
			        tsf_l, tsf_l - bsscfg->tsfo_l,
			        free_pdu?"unsuccessfully":"successfully"));
		}

		/* If the packet is not queued for later delivery, it will be freed
		 * and any packet callback needs to consider this as a un-ACKed packet.
		 * Change the txstatus to simple no-ack instead of suppressed.
		 */
		if (free_pdu) {
			txs->status = txs->status & ~TX_STATUS_SUPR_MASK;
		}
	}
#endif /* WLP2P */
	else if (txs->phyerr) {
		update_rate = FALSE;
		WLCNTINCR(wlc->pub->_cnt->txphyerr);
		WL_ERROR(("wl%d: wlc_dotxstatus: tx phy error (0x%x)\n", wlc->pub->unit,
			txs->phyerr));
#ifdef BCMDBG
		if (WL_ERROR_ON()) {
			prpkt("txpkt (MPDU)", osh, p);
			wlc_print_txdesc((d11txh_t*)PKTDATA(osh, p));
			wlc_print_txstatus(txs);
		}
#endif /* BCMDBG */
	} else if (ETHER_ISMULTI(txh->TxFrameRA)) {
		/* mcast success */
		/* update counters */
		if (tx_frame_count)
			WLCNTINCR(wlc->pub->_cnt->txfrag);

		if (lastframe) {
			WLCNTINCR(wlc->pub->_cnt->txfrmsnt);
			if (tx_frame_count)
				WLCNTINCR(wlc->pub->_cnt->txmulti);
		}
		pkt_sent = TRUE;
	}
#ifdef STA
	else if (bsscfg != NULL && BSSCFG_STA(bsscfg) && bsscfg->BSS && ETHER_ISMULTI(&h->a3)) {
		if (lastframe) {
			WLCNTINCR(wlc->pub->_cnt->txfrmsnt);
			if (tx_frame_count)
				WLCNTINCR(wlc->pub->_cnt->txmulti);
		}

		pkt_sent = TRUE;
	}
#endif /* STA */
	else if ((!tx_rts && tx_frame_count == wlc->SRL) ||
	         (tx_rts && (tx_rts_count == wlc->SRL || tx_frame_count == wlc->LRL))) {
		WLCNTADD(wlc->pub->_cnt->txnoack, tx_frame_count);
		/* ucast failure */
		if (lastframe) {
			WLCNTINCR(wlc->pub->_cnt->txfail);
			WLCNTSCB_COND_INCR((scb != NULL) && (!tx_rts), scb->scb_stats.tx_failures);
			WLCIFCNTINCR(scb, txfail);
			wlc_bss_mac_event(wlc, bsscfg, WLC_E_TXFAIL,
				(struct ether_addr *)txh->TxFrameRA,
				WLC_E_STATUS_TIMEOUT, 0, 0, 0, 0);
		}
		pkt_max_retries = TRUE;
	} else {
		/* unexpected tx status */
		update_rate = FALSE;
		WLCNTINCR(wlc->pub->_cnt->txserr);
		WL_ERROR(("wl%d: wlc_dotxstatus: unexpected tx status returned (0x%x)\n",
			wlc->pub->unit, txs->status));
#ifdef BCMDBG
		if (WL_ERROR_ON()) {
			prpkt("txpkt (MPDU)", osh, p);
			wlc_print_txdesc((d11txh_t*)PKTDATA(osh, p));
			wlc_print_txstatus(txs);
		}
#endif /* BCMDBG */
	}

	/* Check if interference still there and print external log if needed */
	if (wlc->rfaware_lifetime && wlc->exptime_cnt && (supr_status != TX_STATUS_SUPR_EXPTIME))
		wlc_exptime_check_end(wlc);


#ifdef WLBA
	if (WLPKTFLAG_BA(pkttag) && (FC_TYPE(fc) == FC_TYPE_DATA))
		wlc_ba_dotxstatus(wlc->bastate, scb, p, h->seq, &free_pdu);
#endif

#ifdef WLAMSDU
	if (scb && SCB_AMSDU(scb) && (FC_TYPE(fc) == FC_TYPE_DATA))
		wlc_amsdu_dotxstatus(wlc->ami, scb, p);
#endif

	/* update rate state and scb used time */
	if (update_rate && scb) {
#ifdef WLAFTERBURNER
		struct dot11_rts_frame *rts = (struct dot11_rts_frame *)&txh->rts_frame;
		bool aburn = (ltoh16(rts->fc) == (FC_RTS | FC_ORDER));
#endif /* WLAFTERBURNER */
		uint16 sfbl, lfbl;
		uint8 mcs = MCS_INVALID;
		uint8 antselid = 0;
#ifdef WL11N
		uint8 frametype = ltoh16(txh->PhyTxControlWord) & PHY_TXC_FT_MASK;
		if (frametype == FT_HT || frametype == FT_N) {
			uint8 *plcp = (uint8 *)(txh + 1);
			mcs = plcp[0] & MIMO_PLCP_MCS_MASK;
		}
		if (WLANTSEL_ENAB(wlc))
			antselid = wlc_antsel_antsel2id(wlc->asi, ltoh16(txh->ABI_MimoAntSel));
#endif /* WL11N */

		ASSERT(!TX_STATUS_UNEXP(txs->status));

		if (queue < AC_COUNT) {
			sfbl = WLC_WME_RETRY_SFB_GET(wlc, wme_fifo2ac[queue]);
			lfbl = WLC_WME_RETRY_LFB_GET(wlc, wme_fifo2ac[queue]);
		} else {
			sfbl = wlc->SFBL;
			lfbl = wlc->LFBL;
		}
#ifdef WLAFTERBURNER
		wlc_ratesel_upd_txstatus_normalack(wlc->rsi, scb, txs, sfbl, lfbl,
			aburn, (tx_rts_count > 1 ? ABURN_RRTS_WEIGHT : ABURN_DATA_WEIGHT),
			mcs, antselid, ltoh16(txh->MacTxControlHigh) & TXC_AMPDU_FBR ? 1 : 0);
#else
		wlc_ratesel_upd_txstatus_normalack(wlc->rsi, scb, txs, sfbl, lfbl,
			mcs, antselid, ltoh16(txh->MacTxControlHigh) & TXC_AMPDU_FBR ? 1 : 0);
#endif /* WLAFTERBURNER */
	}

	wlc_txfifo_complete(wlc, queue, 1);

#ifdef WLPKTDLYSTAT
	/* calculate latency and packet loss statistics */
	if (scb && free_pdu) {
		/* Get the current time */
		now = WLC_GET_CURR_TIME(wlc);
		/* Ignore wrap-around case */
		if (now > WLPKTTAG(p)->shared.enqtime) {
			uint tr = tx_frame_count - 1;
			if (tx_frame_count == 0 || tx_frame_count > RETRY_SHORT_DEF)
				tr = RETRY_SHORT_DEF-1;

			delay_stats = &scb->delay_stats[ac];
			delay = now - WLPKTTAG(p)->shared.enqtime;
			wlc_delay_stats_upd(delay_stats, delay, tr, ack_recd);
		}
	}
#endif /* WLPKTDLYSTAT */

#ifdef STA
	/* PM state change */
	/* - in mcast case we always have a valid bsscfg.
	 * - in ucast case we may not have a valid bsscfg and scb could have been deleted before
	 *   the transmission finishes, in which case lookup the bsscfg from the BSSID
	 * - Infrastructure STAs should always find the bsscfg by RA BSSID match, unless the
	 *   bsscfg has been deleted (in which case we do not care about PM state update for it)
	 * - in case we located neither scb nor bsscfg we assume the PM states have
	 *   been taken care of when deleting the scb or the bsscfg, yes we hope;-)
	 */
	if (bsscfg != NULL) {
		wlc_update_pmstate(bsscfg, txs->status);

		if ((((fc & FC_KIND_MASK)  == FC_DATA) ||
			((fc & FC_KIND_MASK)  == FC_QOS_DATA)) && lastframe) {

			wlc_pm2_ret_upd_last_wake_time(bsscfg, &txs->lasttxtime);
		}
	}
#endif /* STA */


	/* update the bytes in/out counts */
	if (PIO_ENAB(wlc->pub))
		wlc_pio_cntupd(wlc->hw->pio[queue], totlen);

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		/* LMAC handles txstatus as per the LMAC-UMAC protocol */
		wlc_lmac_txstatus(wlc->lmac_info, p, txs, supr_status, tx_frame_count,
			tx_rts ? tx_rts_count: 0, FALSE);
	}
#endif /* WLLMAC */

	/* call any matching pkt callbacks */
	if (WLPKTTAG(p)->callbackidx) {
		wlc_pkt_callback((void *)wlc, p, (uint)txs->status);
	}
	wlc_pkt_type_cb((void *)wlc, p, (uint)txs->status);

#ifdef STA
	/* Roaming decision based upon too many packets at the min tx rate */
	if (scb != NULL && !SCB_ISMULTI(scb) &&
	    bsscfg != NULL && BSSCFG_STA(bsscfg) && bsscfg->BSS && bsscfg->associated &&
	    !bsscfg->roam->off)
		wlc_txrate_roam(wlc, scb, txs, pkt_sent, pkt_max_retries);
#endif /* STA */

	PKTDBG_TRACE(osh, p, PKTLIST_TXDONE);

	/* free the mpdu */
	if (free_pdu) {
#ifdef WLTXMONITOR
		if (MONITOR_ENAB(wlc) || PROMISC_ENAB(wlc->pub))
			wlc_tx_monitor(wlc, txh, txs, p, NULL);
#endif
		PKTFREE(osh, p, TRUE);
	}

	if (lastframe)
		wlc->txretried = 0;

	return FALSE;

fatal:
	if (p) {
		PKTDBG_TRACE(osh, p, PKTLIST_TXFAIL);
		PKTFREE(osh, p, TRUE);
	}

#if defined(STA) && defined(ADV_PS_POLL)
	/* If this was the last frame sent, send a pspoll to check any buffered
	 * frames at AP, before going back to sleep
	 */
	if (bsscfg != NULL && BSSCFG_STA(bsscfg) && bsscfg->BSS) {
		wlc_pm_st_t *pm = bsscfg->pm;
		if (pm->adv_ps_poll && pm->send_pspoll_after_tx &&
		    !pm->PSpoll && TXPKTPENDTOT(wlc) == 0) {
			/* Re-using existing implementation of pspoll_prd */
			wlc_pspoll_timer(bsscfg);
			pm->send_pspoll_after_tx = FALSE;
		}
	}
#endif /* ADV_PS_POLL */
#ifdef WLC_HIGH_ONLY
	/* If this is a split driver, do the big-hammer here.
	 * If this is a monolithic driver, wlc_bmac.c:wlc_dpc() will do the big-hammer.
	 */
	wl_init(wlc->wl);
#endif
	return TRUE;
}

void BCMFASTPATH
wlc_txfifo_complete(wlc_info_t *wlc, uint fifo, int8 txpktpend)
{
#ifdef STA
	wlc_bsscfg_t *cfg;
#endif /* STA */

	TXPKTPENDDEC(wlc, fifo, txpktpend);
	WL_TRACE(("wlc_txfifo_complete, pktpend dec %d to %d\n", txpktpend,
		TXPKTPENDGET(wlc, fifo)));

	/* There is more room; mark precedences related to this FIFO sendable */
	WLC_TX_FIFO_ENAB(wlc, fifo);
	ASSERT(TXPKTPENDGET(wlc, fifo) >= 0);

	if (TXPKTPENDTOT(wlc) == 0) {
		if (wlc->block_datafifo & DATA_BLOCK_TX_SUPR)
			wlc_bsscfg_tx_check(wlc);

		if (AP_ENAB(wlc->pub))
			wlc_apps_process_pend_ps(wlc);

#ifdef WL11N
		if ((wlc->block_datafifo & DATA_BLOCK_TXCHAIN)) {
			ASSERT(wlc->stf->txchain_pending != 0);
			wlc_stf_txchain_set_complete(wlc);
			wlc->block_datafifo &= ~DATA_BLOCK_TXCHAIN;
		}

		if ((wlc->block_datafifo & DATA_BLOCK_SPATIAL)) {
			wlc_stf_spatialpolicy_set_complete(wlc);
			wlc->block_datafifo &= ~DATA_BLOCK_SPATIAL;
		}
#endif
	}

	/* Clear MHF2_TXBCMC_NOW flag if BCMC fifo has drained */
	if (AP_ENAB(wlc->pub) &&
	    wlc->bcmcfifo_drain && !TXPKTPENDGET(wlc, TX_BCMC_FIFO)) {
		wlc->bcmcfifo_drain = FALSE;
		wlc_mhf(wlc, MHF2, MHF2_TXBCMC_NOW, 0, WLC_BAND_AUTO);
	}

#ifdef STA
#ifdef WLLMAC
	/* check if all the tx packets drained out before join */
	if (LMAC_ENAB(wlc->pub))
		return;
#endif
	/* figure out which bsscfg is being worked on... */

	cfg = wlc->assoc_req[0];
	if (cfg == NULL)
		return;

	if (cfg->assoc == NULL)	{
		WL_ERROR(("%s: cfg->assoc == NULL (assertion)\n", __FUNCTION__));
		return;
	}

	if (cfg->assoc->state == AS_WAIT_TX_DRAIN && pktq_empty(&cfg->wlcif->qi->q) &&
	    TXPKTPENDTOT(wlc) == 0) {
		wlc_join_BSS(cfg, wlc->join_targets->ptrs[wlc->join_targets_last]);
	}
#endif	/* STA */
}

#ifdef STA
static uint32
wlc_tbtt_calc(wlc_info_t *wlc, bool short_preamble, ratespec_t rspec,
	struct dot11_bcn_prb *bcn, bool adopt)
{
	uint32 bo = ltoh16(bcn->beacon_interval);
	uint32 bp;
	uint32 tbtt, tbtt_leeway;
	uint32 bcn_l, bcn_h, bcn_offset, bcn_tbtt;

	bcn_l = ltoh32_ua(&bcn->timestamp[0]);
	bcn_h = ltoh32_ua(&bcn->timestamp[1]);

	/* bad AP beacon frame, set beacon interval to WECA maximum */
	if (bo == 0) {
		WL_ERROR(("wlc_update_tbtt: !bad AP, change beacon period\n"));
		bp = 1024;
	} else
		bp = bo;

	if (!adopt && wlc->check_for_unaligned_tbtt) {
		uint tsf2preamble;

		/* use beacon start to determine if beacon is really unaligned
		 * [--------------------------[--------------------------[
		 *                                       =======TSF(1)
		 *                      =======TSF(2)
		 *                            <-- bcn_tbtt(based on tsf timestamp)
		 * <-- bcn_tbtt(based on beacon frame starting timestamp)
		 *
		 * case(1) is normal, tsf_offset can determine if beacon is unaligned
		 * case(2) is unusual, tsf_offset will result in aligned condition(false)
		 *   subtracting tsf2preamble out of bcn_l before calling wlc_calc_tbtt_offset
		 * will result in a large bcn_offset, which is out of WLC_MAX_TBTT_OFFSET and
		 * trigger adjustment
		 */
		tsf2preamble = wlc_compute_bcntsfoff(wlc, rspec, short_preamble, FALSE);
		wlc_uint64_sub(&bcn_h, &bcn_l, 0, tsf2preamble);
		WL_ASSOC(("wl%d: TBTT: tsf2preamble %d rspec x%x, short_preamble %d\n",
			wlc->pub->unit, tsf2preamble, rspec, short_preamble));
	}

	/* CFP start should be set to a future TBTT. Start by finding the most recent TBTT. */
	bcn_offset = wlc_calc_tbtt_offset(bp, bcn_h, bcn_l);

	/* TBTT = Beacon TSF Timestamp(uint64) - bcn_tsf_offset, but only interested in low 32 bits
	 */
	bcn_tbtt = bcn_l - bcn_offset;

#ifdef DEBUG_TBTT
	{
	uint32 tbtt2 = bcn_l - (bcn_l % ((uint32)bp << 10));
	/* if the tsf is still in 32 bits, we can check the calculation directly */
	if (tbtt2 != bcn_tbtt && bcn_h == 0) {
		WL_ERROR(("tbtt calc error, tbtt2 %d tbtt %d\n", tbtt2, bcn_tbtt));
	}
	}
#endif /* defined(DEBUG_TBTT) && !defined(linux) */

	WL_ASSOC(("wl%d: bcn_h 0x%x bcn_l 0x%x bcn_offset 0x%x bcn_tbtt 0x%x\n", wlc->pub->unit,
		bcn_h, bcn_l, bcn_offset, bcn_tbtt));

	if (adopt || !wlc->check_for_unaligned_tbtt) {
		WL_ASSOC(("wl%d: adopting aligned TBTT\n", wlc->pub->unit));
	} else {
		if (bcn_offset >> 10 >= (uint32)wlc->bcn_wait_prd - 1) {
			bcn_tbtt += bcn_offset;
			WL_ASSOC(("wl%d: adjust to unaligned (%d us) TBTT, new_tbtt 0x%x\n",
				wlc->pub->unit, bcn_offset, bcn_tbtt));
		} else {
			WL_ASSOC(("wl%d: adjust to aligned TBTT\n", wlc->pub->unit));
		}
	}

	/* Add a leeway to make sure we still have enough time in the future */
	tbtt_leeway = ROUNDUP((bcn_offset +
		((ISSIM_ENAB(wlc->pub->sih) ? TBTT_ALIGN_LEEWAY_US_QT :
		TBTT_ALIGN_LEEWAY_US) << 10)), (bp << 10));

	tbtt = bcn_tbtt + tbtt_leeway;

	return tbtt;
}

void
wlc_tbtt_align(wlc_bsscfg_t *cfg, bool short_preamble, ratespec_t rspec, struct dot11_bcn_prb *bcn)
{
	wlc_info_t *wlc = cfg->wlc;
	uint32 tbtt;

	if (cfg != wlc->cfg)
		return;

	if (AP_ACTIVE(wlc))
		return;

	tbtt = wlc_tbtt_calc(wlc, short_preamble, rspec, bcn, FALSE);

	WL_ASSOC(("wl%d: %s: old cfpstart = 0x%x, new = 0x%x\n",
	          wlc->pub->unit, __FUNCTION__,
	          R_REG(wlc->osh, &wlc->regs->tsf_cfpstart), tbtt));

	W_REG(wlc->osh, &wlc->regs->tsf_cfpstart, tbtt);
}

static void
wlc_tbtt_adopt(wlc_bsscfg_t *cfg, struct dot11_bcn_prb *bcn)
{
	wlc_info_t *wlc = cfg->wlc;
	uint32 tbtt;

	if (cfg != wlc->cfg)
		return;

	if (AP_ACTIVE(wlc))
		return;

	tbtt = wlc_tbtt_calc(wlc, FALSE, 0, bcn, TRUE);

	WL_ASSOC(("wl%d: %s: old cfpstart = 0x%x, new = 0x%x\n",
	          wlc->pub->unit, __FUNCTION__,
	          R_REG(wlc->osh, &wlc->regs->tsf_cfpstart), tbtt));

	W_REG(wlc->osh, &wlc->regs->tsf_cfpstart, tbtt);
}

/* Given the beacon interval in kus, and a 64 bit TSF in us,
 * return the offset (in us) of the TSF from the last TBTT
 */
uint32
wlc_calc_tbtt_offset(uint32 bp, uint32 tsf_h, uint32 tsf_l)
{
	uint32 k, btklo, btkhi, offset;

	/* TBTT is always an even multiple of the beacon_interval,
	 * so the TBTT less than or equal to the beacon timestamp is
	 * the beacon timestamp minus the beacon timestamp modulo
	 * the beacon interval.
	 *
	 * TBTT = BT - (BT % BIu)
	 *      = (BTk - (BTk % BP)) * 2^10
	 *
	 * BT = beacon timestamp (usec, 64bits)
	 * BTk = beacon timestamp (Kusec, 54bits)
	 * BP = beacon interval (Kusec, 16bits)
	 * BIu = BP * 2^10 = beacon interval (usec, 26bits)
	 *
	 * To keep the calculations in uint32s, the modulo operation
	 * on the high part of BT needs to be done in parts using the
	 * relations:
	 * X*Y mod Z = ((X mod Z) * (Y mod Z)) mod Z
	 * and
	 * (X + Y) mod Z = ((X mod Z) + (Y mod Z)) mod Z
	 *
	 * So, if BTk[n] = uint16 n [0,3] of BTk.
	 * BTk % BP = SUM((BTk[n] * 2^16n) % BP , 0<=n<4) % BP
	 * and the SUM term can be broken down:
	 * (BTk[n] *     2^16n)    % BP
	 * (BTk[n] * (2^16n % BP)) % BP
	 *
	 * Create a set of power of 2 mod BP constants:
	 * K[n] = 2^(16n) % BP
	 *      = (K[n-1] * 2^16) % BP
	 * K[2] = 2^32 % BP = ((2^16 % BP) * 2^16) % BP
	 *
	 * BTk % BP = BTk[0-1] % BP +
	 *            (BTk[2] * K[2]) % BP +
	 *            (BTk[3] * K[3]) % BP
	 *
	 * Since K[n] < 2^16 and BTk[n] is < 2^16, then BTk[n] * K[n] < 2^32
	 */

	/* BTk = BT >> 10, btklo = BTk[0-3], bkthi = BTk[4-6] */
	btklo = (tsf_h << 22) | (tsf_l >> 10);
	btkhi = tsf_h >> 10;

	/* offset = BTk % BP */
	offset = btklo % bp;

	/* K[2] = ((2^16 % BP) * 2^16) % BP */
	k = (uint32)(1<<16) % bp;
	k = (uint32)(k * 1<<16) % (uint32)bp;

	/* offset += (BTk[2] * K[2]) % BP */
	offset += ((btkhi & 0xffff) * k) % bp;

	/* BTk[3] */
	btkhi = btkhi >> 16;

	/* k[3] = (K[2] * 2^16) % BP */
	k = (k << 16) % bp;

	/* offset += (BTk[3] * K[3]) % BP */
	offset += ((btkhi & 0xffff) * k) % bp;

	offset = offset % bp;

	/* convert offset from kus to us by shifting up 10 bits and
	 * add in the low 10 bits of tsf that we ignored
	 */
	offset = (offset << 10) + (tsf_l & 0x3FF);

#ifdef DEBUG_TBTT
	{
	uint32 offset2 = tsf_l % ((uint32)bp << 10);
	/* if the tsf is still in 32 bits, we can check the calculation directly */
	if (offset2 != offset && tsf_h == 0) {
		WL_ERROR(("tbtt offset calc error, offset2 %d offset %d\n",
		          offset2, offset));
	}
	}
#endif /* DEBUG_TBTT */

	return offset;
}

int
wlc_bcn_tsf_later(wlc_bsscfg_t *cfg, wlc_d11rxhdr_t *wrxh, void *bcn_plcp)
{
	wlc_info_t *wlc = cfg->wlc;
	struct dot11_bcn_prb *bcn;
	uint16 rxtime;
	uint32 tsf_l, tsf_h;
	uint32 bcn_tsf_l, bcn_tsf_h;
	uint32 offset;
	ratespec_t rspec;

	/* read the tsf from our chip */
	wlc_read_tsf(wlc, &tsf_l, &tsf_h);

	/* read the tsf from the beacon */
	bcn = (struct dot11_bcn_prb *)((int8*)bcn_plcp + D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN);
	bcn_tsf_l = ltoh32_ua(&bcn->timestamp[0]);
	bcn_tsf_h = ltoh32_ua(&bcn->timestamp[1]);

	/* if the bcn_tsf is later than the current tsf, then we know it is later than the
	 * tsf at the time of the beacon
	 */
	if (wlc_uint64_lt(tsf_h, tsf_l, bcn_tsf_h, bcn_tsf_l)) {
		WL_ASSOC(("wlc_bcn_tsf_later: current local time: %08x:%08x\n", tsf_h, tsf_l));
		WL_ASSOC(("wlc_bcn_tsf_later: beacon tsf time: %08x:%08x\n", bcn_tsf_h, bcn_tsf_l));
		return 1;
	}

	/* expand the rxtime to 64 bits */
	rxtime = wrxh->rxhdr.RxTSFTime;
	if (rxtime < (tsf_l & 0xffff)) {
		tsf_l &= 0xffff0000;
	} else {
		/* tsf_l has rolled over 2^16 so roll the upper bits back */
		tsf_l &= 0xffff0000;
		if (tsf_l > 0) {
			tsf_l -= 1<<16;
		} else {
			tsf_l = 0xffff0000;
			tsf_h -= 1;
		}
	}
	tsf_l |= rxtime;

	/* calculate the rxtime offset to the transmission time of the first
	 * symbol of the beacon timestamp
	 */
	rspec = wlc_recv_compute_rspec(wrxh, bcn_plcp);
	offset = wlc_compute_airtime(wlc, rspec, DOT11_MAC_HDR_LEN);

	/* rxtime is slightly offset from the end of the plcp due to rf delay */
	offset -= M_BPHY_PLCPRX_DLY;

	/* do uint64 math to add offset to our tsf */
	wlc_uint64_add(&tsf_h, &tsf_l, 0, offset);

	WL_ASSOC(("wlc_bcn_tsf_later:  local tsf time: %08x:%08x\n", tsf_h, tsf_l));
	WL_ASSOC(("wlc_bcn_tsf_later: beacon tsf time: %08x:%08x\n", bcn_tsf_h, bcn_tsf_l));

	if (wlc_uint64_lt(tsf_h, tsf_l, bcn_tsf_h, bcn_tsf_l))
		return 1;

	return 0;
}

/* update cfg->PMpending and wlc->PMpending */
void
wlc_set_pmpending(wlc_bsscfg_t *cfg, bool pm0to1)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->PMpending;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, pm0to1));

	pm->PMpending = pm0to1;
#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub) && cfg->chan_context) {
		cfg->chan_context->pm_pending = pm0to1;
	}
#endif /* WLMCHAN */

	if (oldstate == pm0to1)
		return;

	if (pm0to1)
		wlc->PMpending = TRUE;
	/* leave setting wlc->PMpending to FALSE to wlc_pm_pending_complete()
	 * else {
	 * 	int idx;
	 *	wlc_bsscfg_t *bc;
	 *	FOREACH_AS_STA(wlc, idx, bc) {
	 *		if (bc->pm->PMpending)
	 *			return;
	 *	}
	 *	wlc->PMpending = FALSE;
	 * }
	 */
	wlc_set_wake_ctrl(wlc);
}

/* update cfg->PMawakebcn and wlc->PMawakebcn */
void
wlc_set_pmawakebcn(wlc_bsscfg_t *cfg, bool state)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->PMawakebcn;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	pm->PMawakebcn = state;
	if (state == oldstate)
		return;

	if (state)
		wlc->PMawakebcn = TRUE;
	else {
		int idx;
		wlc_bsscfg_t *bc;
		FOREACH_AS_STA(wlc, idx, bc) {
			if (bc->pm->PMawakebcn)
				return;
		}
		wlc->PMawakebcn = FALSE;
	}
	wlc_set_wake_ctrl(wlc);
}

/* update cfg->PSpoll and wlc->PSpoll */
void
wlc_set_pspoll(wlc_bsscfg_t *cfg, bool state)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->PSpoll;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	pm->PSpoll = state;
	if (oldstate == state)
		return;

	if (state)
		wlc->PSpoll = TRUE;
	else {
		int idx;
		wlc_bsscfg_t *bc;

		FOREACH_AS_STA(wlc, idx, bc) {
			if (bc->pm->PSpoll)
				return;
		}
		wlc->PSpoll = FALSE;
	}
	wlc_set_wake_ctrl(wlc);
}

/* update cfg->apsd_sta_usp and wlc->apsd_sta_usp */
void
wlc_set_apsd_stausp(wlc_bsscfg_t *cfg, bool state)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->apsd_sta_usp;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	pm->apsd_sta_usp = state;
	if (state == oldstate)
		return;

	if (state)
		wlc->apsd_sta_usp = TRUE;
	else {
		int idx;
		wlc_bsscfg_t *bc;
		FOREACH_AS_STA(wlc, idx, bc) {
			if (bc->pm->apsd_sta_usp)
				return;
		}
		wlc->apsd_sta_usp = FALSE;
	}
	wlc_set_wake_ctrl(wlc);
}


/* update cfg->check_for_unaligned_tbtt and wlc->check_for_unaligned_tbtt */
void
wlc_set_uatbtt(wlc_bsscfg_t *cfg, bool state)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->check_for_unaligned_tbtt;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	pm->check_for_unaligned_tbtt = state;
	if (state == oldstate)
		return;

	if (state)
		wlc->check_for_unaligned_tbtt = TRUE;
	else {
		int idx;
		wlc_bsscfg_t *bc;
		FOREACH_AS_STA(wlc, idx, bc) {
			if (bc->pm->check_for_unaligned_tbtt)
				return;
		}
		wlc->check_for_unaligned_tbtt = FALSE;
	}
	wlc_set_wake_ctrl(wlc);
}

/* update cfg->PMenabled */
static void
wlc_set_pmenabled(wlc_bsscfg_t *cfg, bool state)
{
	wlc_pm_st_t *pm = cfg->pm;
#if defined(BCMDBG) || defined(WLMSG_PS)
	bool oldstate = pm->PMenabled;
#endif
	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       cfg->wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	pm->PMenabled = state;

	wlc_set_ps_ctrl(cfg);
}

/* update cfg->PM_override */
void
wlc_set_pmoverride(wlc_bsscfg_t *cfg, bool state)
{
	wlc_pm_st_t *pm = cfg->pm;
	bool oldstate = pm->PM_override;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       cfg->wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	cfg->pm->PM_override = state;
	if (oldstate == state)
		return;

	wlc_set_pmstate(cfg, cfg->pm->PMenabled);
}

/* update cfg->dtim_programmed */
void
wlc_set_dtim_programmed(wlc_bsscfg_t *cfg, bool state)
{
	bool oldstate = cfg->dtim_programmed;

	WL_PS(("wl%d.%d: %s: old %d new %d\n",
	       cfg->wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, oldstate, state));

	cfg->dtim_programmed = state;
	if (oldstate == state)
		return;

	wlc_set_ps_ctrl(cfg);
}

/* Set the module id that triggered PS mode and call wlc_set_pmstate */
void wlc_module_set_pmstate(wlc_bsscfg_t *cfg, bool state, mbool moduleId)
{
	mboolset(cfg->pm->PMenabledModuleId, moduleId);
	wlc_set_pmstate(cfg, state);
}

/*
 * Set PS mode and communicate new state to AP by sending null data frame.
 */
void
wlc_set_pmstate(wlc_bsscfg_t *cfg, bool state)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	uint txstatus = TX_STATUS_ACK_RCV;

	if (!BSSCFG_STA(cfg) || !cfg->BSS)
		return;

	WL_PS(("wl%d.%d: PM-MODE: wlc_set_pmstate: set PMenabled to %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), state));

	wlc_set_pmenabled(cfg, state);

	if (state == FALSE)
		pm->PMenabledModuleId = 0;


	wlc_set_pmpending(cfg, PS_ALLOWED(cfg));

	if (!wlc->pub->up)
		return;


	if (!cfg->associated)
		return;

	WL_RTDC(wlc, "wlc_set_pmstate: tx PMep=%02u AW=%02u",
	        (pm->PMenabled ? 10 : 0) | pm->PMpending,
	        (PS_ALLOWED(cfg) ? 10 : 0) | STAY_AWAKE(wlc));

	/* If wlc->PMPending, fake a status of TX_STATUS_PMINDCTD | TX_STATUS_ACK_RCV
	 * else, fake TX_STATUS_ACK_RCV, in case the upper layers need to know of the
	 * conditions.
	 */
	if (pm->PMpending)
		txstatus |= TX_STATUS_PMINDCTD;

	/* announce PM change */
	/* send NULL data frame to communicate PM state to each associated APs */
	/* don't bother sending a null data frame if we lost our AP connection */
	if (!WLC_BSS_CONNECTED(cfg) ||
#ifdef WLBTAMP
	    BSS_BTA_ENAB(wlc, cfg) ||
#endif
#ifdef WLP2P
	    (!P2P_ENAB(wlc->pub) && cfg != wlc->cfg) ||
#endif
	    FALSE) {
		WL_PS(("wl%d.%d: skip the PM null frame, fake a PM0->PM1 transition\n",
		       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		wlc_bss_pm_pending_upd(cfg, txstatus);
	}
	else if (!wlc_sendnulldata(wlc, &cfg->BSSID, 0, 0, -1)) {
		WL_ERROR(("wl%d.%d: failed to send PM null frame, fake a PM0->PM1 transition\n",
		          wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		wlc_bss_pm_pending_upd(cfg, txstatus);
	}

	/* start periodic pspoll timer if we are indeed in PS mode */
	wlc_pspoll_timer_upd(cfg, state);
	wlc_apsd_trigger_upd(cfg, state);
}

static void
wlc_radio_shutoff_dly_timer_upd(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;

	wl_del_timer(wlc->wl, wlc->pm2_radio_shutoff_dly_timer);

	if (wlc->pm2_radio_shutoff_dly == 0)
		return;

	/* we are done if no one is in FAST PS mode */
	cfg = NULL;
	FOREACH_AS_STA(wlc, idx, cfg) {
		if (cfg->pm->PMenabled && cfg->pm->PM == PM_FAST)
			break;
	}
	if (cfg == NULL)
		return;

	WL_PS(("wl%d: wlc_radio_shutoff_dly_timer_upd: arm periodic(%u) "
	       "radio shutoff delay timer\n", wlc->pub->unit, wlc->pm2_radio_shutoff_dly));

	wlc->pm2_radio_shutoff_pending = TRUE;
	wl_add_timer(wlc->wl, wlc->pm2_radio_shutoff_dly_timer, wlc->pm2_radio_shutoff_dly, FALSE);
	wlc_set_wake_ctrl(wlc);
}

int
wlc_pspoll_timer_upd(wlc_bsscfg_t *cfg, bool allow)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	int callbacks = 0;

	if (!wl_del_timer(wlc->wl, pm->pspoll_timer))
		callbacks ++;

	if (!allow || !cfg->associated || !pm->PMenabled || pm->pspoll_prd == 0)
		return callbacks;

	WL_PS(("wl%d.%d: wlc_pspoll_timer_upd: arm periodic(%u) pspoll timer\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), pm->pspoll_prd));

	wl_add_timer(wlc->wl, pm->pspoll_timer, pm->pspoll_prd, TRUE);
	return 0;
}

/* Update local PM state(s) and change local PS mode based on tx status.
 * It will also resume any pending work ie. scan that depend on the PM
 * transition, or allow local to doze if there is nothing pending.
 */
void
wlc_update_pmstate(wlc_bsscfg_t *cfg, uint txstatus)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool pmindctd;

	/* we only work on associated BSS STA... */
	if (!BSSCFG_STA(cfg) || !cfg->BSS || !cfg->associated)
		return;

	/* If we get a suppressed frame due to lifetime expiration when waiting for PM indication,
	 * consider it as a PM indication since it indicates a strong interference. Since ucode
	 * doesn't give us PM indication bit in this case, we need to fake it.
	 */
	if (pm->PMpending) {
		WL_PS(("wl%d.%d: PM-MODE: wlc_update_pmstate: txstatus 0x%x\n",
		       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), txstatus));

		if ((txstatus & TX_STATUS_SUPR_MASK) == TX_STATUS_SUPR_EXPTIME) {
			WL_PS(("wl%d.%d: PM-MODE: frame lifetime expired\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
			txstatus |= TX_STATUS_PMINDCTD;
		}
		if ((txstatus & TX_STATUS_MASK) == TX_STATUS_NO_ACK) {
			WL_PS(("wl%d.%d: PM-MODE: frame recv'd no ACK\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
			txstatus |= TX_STATUS_ACK_RCV|TX_STATUS_PMINDCTD;
		}
	}

	pmindctd = (txstatus & TX_STATUS_PMINDCTD) == TX_STATUS_PMINDCTD;

	/* PM change */
	if (pm->priorPMstate != pmindctd) {
		wlc_bss_pm_pending_upd(cfg, txstatus);
		pm->priorPMstate = pmindctd;
	}

	/* If this evaluates to true, the PM1->PM0 transition was lost and we didn't catch the
	 * transition. So, fake the transition (for upper layers that need to be aware of
	 * PM1->PM0 transitions, and then send the real PM0->PM1 transition
	 */
	if (pm->PMpending && pmindctd) {
		WL_PS(("wl%d.%d: PM-MODE: fake a lost PM1->PM0 transition\n",
		       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
		wlc_bss_pm_pending_upd(cfg, (txstatus | TX_STATUS_ACK_RCV));
	}

	/* update the PMpending state and move things forward when possible */
	wlc_pm_pending_complete(wlc);
}

/* we are only interested in PM0->PM1 transition! */
void
wlc_pm_pending_complete(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;

	if (!wlc->PMpending)
		return;

	WL_PS(("wl%d: PM-MODE: wlc_pm_pending_complete: wlc->PMpending %d\n",
	       wlc->pub->unit, wlc->PMpending));

#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub)) {
		/* wlc_mchan_pm_pending_complete relies on chan_context->pm_pending being FALSE */
		wlc_mchan_pm_pending_complete(wlc->mchan);
	}
#endif /* WLMCHAN */

	FOREACH_AS_STA(wlc, idx, cfg) {
		if (cfg->pm->PMpending)
			return;
	}

	WL_PS(("wl%d: PM-MODE: PM indications are all finished, "
	       "set wlc->PMpending to FALSE\n", wlc->pub->unit));

	wlc->PMpending = FALSE;
	wlc_set_wake_ctrl(wlc);

	wlc_scan_pm_pending_complete(wlc->scan);
#ifdef WLRM
	wlc_rm_pm_pending_complete(wlc->rm_info);
#endif

	FOREACH_AS_STA(wlc, idx, cfg) {
	}

	/* non-p2p APs are out there don't shutdown the radio */
	FOREACH_UP_AP(wlc, idx, cfg) {
		if (cfg != wlc->cfg &&
#ifdef WLP2P
		    !BSS_P2P_ENAB(wlc, cfg) &&
#endif
		    TRUE)
			return;
	}

	wlc_radio_shutoff_dly_timer_upd(wlc);

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		wlc_lmac_pschange_complete(wlc->lmac_info);
		return;
	}
#endif /* WLLMAC */
}

/* we are only interested in PM0->PM1 transition! */
static void
wlc_bss_pm_pending_upd(wlc_bsscfg_t *cfg, uint txstatus)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	bool pmindctd = (txstatus & TX_STATUS_PMINDCTD) == TX_STATUS_PMINDCTD;

	WL_PS(("wl%d.%d: PM-MODE: wlc_bss_pm_pending_upd: PMpending %d pmindctd %d\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), pm->PMpending, pmindctd));

	if (!pm->PMpending)
		return;

	if (wlc->PMblocked || (txstatus & TX_STATUS_ACK_RCV))
		wlc_set_pmpending(cfg, !pmindctd);

	if (pm->PMpending)
		return;

	/* when done waiting PM0->PM1 transition, let core go to sleep */
	WL_RTDC(wlc, "wlc_bss_pm_pending_upd: PMep=%02u PMaw=%02u",
	        (pm->PMenabled ? 10 : 0) | pm->PMpending,
	        (PS_ALLOWED(cfg) ? 10 : 0) | STAY_AWAKE(wlc));
	WL_PS(("wl%d.%d: PM-MODE: PS_ALLOWED() %d, %s\n",
	       wlc->pub->unit, WLC_BSSCFG_IDX(cfg), PS_ALLOWED(cfg),
	       STAY_AWAKE(wlc)?"but remaining awake":"going to sleep"));

	if (PM2_RCV_DUR_ENAB(cfg) && pm->PM == PM_FAST) {
		if (pm->pm2_rcv_state == PM2RD_WAIT_RTS_ACK) {
			pm->pm2_rcv_state = PM2RD_WAIT_BCN;
			WL_RTDC(wlc, "pm2_rcv_state=PM2RD_WAIT_BCN", 0, 0);
		}
	}

#ifdef WLMCHAN
	/* update chan_context pm_pending flag */
	if (MCHAN_ENAB(wlc->pub)) {
		wlc_mchan_context_t *chan_ctxt = cfg->chan_context;
		wlc_bsscfg_t *mchan_cfg;
		uint mchan_idx;

		if (chan_ctxt && chan_ctxt->pm_pending) {
			/* clear the pm_pending first */
			chan_ctxt->pm_pending = FALSE;
			FOREACH_AS_STA(wlc, mchan_idx, mchan_cfg) {
				/* as soon as we find cfg with the same context and
				 * PMpending set, set chan_ctxt->pm_pending back to true.
				 */
				if ((mchan_cfg->chan_context == chan_ctxt) &&
				    (mchan_cfg->pm->PMpending == TRUE)) {
					chan_ctxt->pm_pending = TRUE;
					break;
				}
			}
		}
	}
#endif /* WLMCHAN */
}

void
wlc_reset_pmstate(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	(void)wlc;

	WL_PS(("wl%d.%d: PM-MODE: wlc_reset_pmstate:\n", wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));

	wlc_set_pmawakebcn(cfg, FALSE);

	if (pm->PMpending)
		wlc_update_pmstate(cfg, TX_STATUS_NO_ACK);

	wlc_set_pspoll(cfg, FALSE);
	wlc_set_apsd_stausp(cfg, FALSE);
	wlc_set_uatbtt(cfg, FALSE);
	pm->WME_PM_blocked = FALSE;
	pm->PMenabled = (pm->PM != PM_OFF);
	wlc_set_ps_ctrl(cfg);
}

#if defined(WL_PM2_RCV_DUR_LIMIT)
/* Reset the PM2 receive throttle duty cycle feature */
void
wlc_pm2_rcv_reset(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	/* The Receive Throttle feature overrides the TBTT wakeup interval
	 * specified by bcn_li_bcn and bcn_li_dtim.  So we must restore the
	 * wakeup interval to match bcn_li_bcn and bcn_li_dtim again.
	 */
	wlc_bcn_li_upd(wlc);

	/* Stop the receive throttle timer */
	wlc_pm2_rcv_timer_stop(cfg);
	/* Next beacon should start the timer */

	pm->pm2_rcv_state = PM2RD_IDLE;
	WL_RTDC(wlc, "pm2_rcv_state=PM2RD_IDLE", 0, 0);
}

/* Start the PM2 receive throttle duty cycle timer.
 *
 * This timer should be started at the beginning of the ON part of the
 * PM2 receive duty cycle.
 * When this timer expires, the OFF part of the duty cycle begins.
 * At the end of the current beacon period, the duty cycle ends.
 * (The end of the current beacon period is indicated by the next TBTT
 * wakeup.  This function adjusts the TBTT wake up interval to ensure
 * the wakeup interval is the same as the beacon interval.)
 */
static void
wlc_pm2_rcv_timer_start(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	 /* Start the PM2 receive duration timer */
	 /* the new timeout will supercede the old one so delete old one first */
	wlc_hwtimer_del_timeout(wlc->gptimer, pm->pm2_rcv_timer);
	wlc_hwtimer_add_timeout(wlc->gptimer, pm->pm2_rcv_timer,
	                        WLC_PM2_TICK_GP(pm->pm2_rcv_time),
	                        wlc_pm2_rcv_timeout_cb, (void *)cfg);

	pm->pm2_rcv_state = PM2RD_WAIT_TMO;
	WL_RTDC(wlc, "pm2_rcv_state=PM2RD_WAIT_TMO", 0, 0);

	/* Ensure we will get our next TBTT wake up interrupt at the next beacon:
	 * update the beacon listen interval in shared memory to instruct ucode to
	 * wake up to listen to every beacon, as if bcn_li_bcn == 1 and
	 * bcn_li_dtim == 0.
	 *
	 * This is needed because the wakeup interval varies between 1 and DTIM
	 * beacon intervals depending on recent tx/rx activity.
	 */
	wlc_write_shm(wlc, M_BCN_LI, (0 /* bcn_li_dtim */  << 8) | 1 /* bcn_li_bcn */);
}

/* Stop the PM2 tick timer */
static void
wlc_pm2_rcv_timeout_cb(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;

	if (cfg->pm->PM == PM_FAST) {
		wlc_pm2_rcv_timeout(cfg);
	}
}

static void
wlc_pm2_rcv_timer_stop(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	wlc_hwtimer_del_timeout(wlc->gptimer, cfg->pm->pm2_rcv_timer);

	WL_RTDC2(wlc, "wlc_pm2_rcv_timer_stop", 0, 0);
}

/* PM2 tick timer timeout handler */
static void
wlc_pm2_rcv_timeout(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	(void)wlc;

	/* Ignore timeout if it occurs just as we exited PM2 (race condition). */
	if (pm->PM != PM_FAST) {
		WL_RTDC(wlc, "wlc_pm2_rcv_timeout: not PM2", 0, 0);
		return;
	}

	ASSERT(!CRAM_ENAB(wlc->pub));

	/* Decrement the Receive Throttle countdown timers.
	 * If timer reaches 0, enter PS mode and stop the PM2 timer.
	 */
	if (PM2_RCV_DUR_ENAB(cfg)) {
		WL_RTDC(wlc, "wlc_pm2_rcv_timeout: RTDC enter ps", 0, 0);
		wlc_pm2_enter_ps(cfg);
		return;
	}

	/* Let the next beacon start next timer again */
}

#endif /* WL_PM2_RCV_DUR_LIMIT */

/* Start the PM2 return to sleep timer */
void
wlc_pm2_sleep_ret_timer_start(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	/* the new timeout will supercede the old one so delete old one first */
	wlc_hwtimer_del_timeout(wlc->gptimer, pm->pm2_ret_timer);
	wlc_hwtimer_add_timeout(wlc->gptimer, pm->pm2_ret_timer,
	                        WLC_PM2_TICK_GP(pm->pm2_sleep_ret_time_left),
	                        wlc_pm2_sleep_ret_timeout_cb, (void *)cfg);
}

/* Stop the PM2 tick timer */
static void wlc_pm2_sleep_ret_timeout_cb(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;

	if (cfg->pm->PM == PM_FAST) {
		wlc_pm2_sleep_ret_timeout(cfg);
	}
}

void
wlc_pm2_sleep_ret_timer_stop(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	wlc_hwtimer_del_timeout(wlc->gptimer, cfg->pm->pm2_ret_timer);

	WL_RTDC2(wlc, "wlc_pm2_sleep_ret_timer_stop", 0, 0);
}
/* PM2 tick timer timeout handler */
static void
wlc_pm2_sleep_ret_timeout(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;
	wlc_hwtimer_info_t *hwtmr = wlc->gptimer;
	uint curr_time;
	uint wake_time;

	(void)wlc;

#ifdef BCMDBG
	wlc_update_perf_stats(wlc, WLC_PERF_STATS_GPTIMER);
#endif

	/* Ignore timeout if it occurs just as we exited PM2 (race condition). */
	if (pm->PM != PM_FAST) {
		WL_RTDC(wlc, "wlc_pm2_timeout: not PM2", 0, 0);
		return;
	}

	ASSERT(!CRAM_ENAB(wlc->pub));

	curr_time = hwtmr->gettime((void *)hwtmr);
	/* put in condition to check for wrap around */
	if (curr_time < pm->pm2_last_wake_time) {
		wake_time = hwtmr->max_timer_val - pm->pm2_last_wake_time + curr_time + 1;
	}
	else {
		wake_time = curr_time - pm->pm2_last_wake_time;
	}

	wake_time = wake_time/1024;

	/* 5 ms is to account for delays to avoid re-fires for small time */
	if (wake_time >= (pm->pm2_sleep_ret_time_left - 5)) {
		/* Re-initialize back for next cycle */
		pm->pm2_sleep_ret_time_left = pm->pm2_sleep_ret_time;
		wlc_pm2_enter_ps(cfg);
		return;
	}
	else {
		pm->pm2_sleep_ret_time_left = pm->pm2_sleep_ret_time - wake_time;
	}

	/* Start the PM2 tick timer for the next tick */
	wlc_pm2_sleep_ret_timer_start(cfg);
}


void
wlc_pm2_ret_upd_last_wake_time(wlc_bsscfg_t *cfg, uint32* tsf_l)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_hwtimer_info_t *hwtmr = wlc->gptimer;

	if (tsf_l) {
		cfg->pm->pm2_last_wake_time = *tsf_l;

	} else {
		/* Note down the last time some one tried to avoid going to ps */
		cfg->pm->pm2_last_wake_time = hwtmr->gettime((void *)hwtmr);
	}
}

/* Try enter PS mode in power mgmt mode PM_FAST.
 * If entered PS mode, stop the PM2 timers.
 */
static void
wlc_pm2_enter_ps(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	/* Do not enter PS mode if:
	 * a) a scan is in progress, or
	 * b) there are pending tx packets and the Receive Throttle feature is
	 *    not enabled.
	 *    (Not entering PS mode for the OFF part of the receive
	 *    throttle duty cycle for any reason will defeat the main purpose
	 *    of the receive throttle feature - heat reduction.)
	 * c) we are no longer in PM2
	 * d) we are no longer associated to an AP
	 * e) PMenabledModuleId is non-zero, meaning another module put us in PS already
	 */
	if (SCAN_IN_PROGRESS(wlc->scan) ||
	    AS_IN_PROGRESS(wlc) ||
	    (!PM2_RCV_DUR_ENAB(cfg) && wlc_txpktcnt(wlc) > 0) ||
	    pm->PM != PM_FAST ||
	    !cfg->associated ||
	    pm->PMenabledModuleId) {

		WL_RTDC(wlc, "wlc_pm2_enter_ps: no PS, scan=%u txcnt=%u",
			SCAN_IN_PROGRESS(wlc->scan), wlc_txpktcnt(wlc));
		WL_RTDC(wlc, "    stas=%u AS_IN_PROGRESS=%d",
			wlc->stas_associated, AS_IN_PROGRESS(wlc));
		WL_RTDC(wlc, "    PM=%u", pm->PM, 0);
	}
	else {
		/* Start entering PS mode */
		wlc_set_pmstate(cfg, TRUE);
	}

	/* If we succeeded in starting to enter PS mode or
	 * if another module already put us in PS mode.
	 */
	if (pm->PMpending || pm->PMenabledModuleId) {
		WL_RTDC(wlc, "wlc_pm2_enter_ps: succeeded", 0, 0);

		/* Enter the Receive Throttle feature state where we are in the
		 * transition between the ON and OFF parts of the duty cycle.  In this
		 * state we are waiting for a PM-indicated ACK to complete entering PS
		 * mode.
		 */
#if defined(WL_PM2_RCV_DUR_LIMIT)
		if (PM2_RCV_DUR_ENAB(cfg)) {
			/* non-zero pm->PMenabledModuleId means another module has already
			 * put us in PS mode.  This means that we won't get PM-indicated
			 * ACK because we're already in PS mode.  Thus, proceed to the next
			 * state, which is PM2RD_WAIT_BCN.
			 */
			if (pm->PMenabledModuleId) {
				pm->pm2_rcv_state = PM2RD_WAIT_BCN;
				WL_RTDC(wlc, "pm2_rcv_state=PM2RD_WAIT_BCN", 0, 0);
			}
			else {
				pm->pm2_rcv_state = PM2RD_WAIT_RTS_ACK;
				WL_RTDC(wlc, "pm2_rcv_state=PM2RD_WAIT_RTS_ACK", 0, 0);
			}
			wlc_pm2_rcv_timer_stop(cfg);
		}
#endif /* WL_PM2_RCV_DUR_LIMIT */

		/* Stop the PM2 tick timer */
		wlc_pm2_sleep_ret_timer_stop(cfg);
	}
	/* else we did not start entering PS mode */
	else {
		/* Restart the return to sleep timer to try again later */
		WL_RTDC2(wlc, "wlc_pm2_enter_ps: restart timer", 0, 0);
		wlc_pm2_sleep_ret_timer_start(cfg);

#ifdef BCMDBG
		WL_RTDC(wlc, "wlc_pm2_enter_ps: enter PS failed, PMep=%02u AW=%02u",
			(pm->PMenabled ? 10 : 0) | pm->PMpending,
			(PS_ALLOWED(cfg) ? 10 : 0) | STAY_AWAKE(wlc));
		WL_RTDC(wlc, "    bss=%u assoc=%u", cfg->BSS, cfg->associated);
		WL_RTDC(wlc, "    dptpend=%u portopen=%u",
		        WLC_DPT_PM_PENDING(wlc, cfg), WLC_PORTOPEN(cfg));
#endif /* BCMDBG */
	}
}

bool
wlc_bssid_is_current(wlc_bsscfg_t *cfg, struct ether_addr *bssid)
{
	return WLC_IS_CURRENT_BSSID(cfg, bssid);
}

bool
wlc_bss_connected(wlc_bsscfg_t *cfg)
{
	return WLC_BSS_CONNECTED(cfg);
}

uint8
wlc_stas_connected(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;
	uint8 stas_connected = 0;

	/* count STAs currently still talking with their associated APs */
	FOREACH_AS_STA(wlc, idx, cfg) {
		if (WLC_BSS_CONNECTED(cfg))
			stas_connected ++;
	}

	return stas_connected;
}

bool
wlc_portopen(wlc_bsscfg_t *cfg)
{
	return WLC_PORTOPEN(cfg);
}

/*
 * Check if STA's bit is set in TIM
 * See Tality MS/futils.c: boFUTILS_InTIM()
 */
bool
wlc_InTIM(wlc_bsscfg_t *cfg, void *body, uint plen, bool *bcmc, uint *dtim_count)
{
	wlc_info_t *wlc = cfg->wlc;
	bcm_tlv_t *tim_ie;
	uint pvboff, AIDbyte;
	uint pvblen;

	*bcmc = 0;
	*dtim_count = 0;

	tim_ie = bcm_parse_tlvs((uint8 *)body + DOT11_BCN_PRB_LEN, plen - DOT11_BCN_PRB_LEN,
	                        DOT11_MNG_TIM_ID);

	if (!tim_ie || tim_ie->len < DOT11_MNG_TIM_FIXED_LEN ||
	    tim_ie->data[DOT11_MNG_TIM_DTIM_COUNT] >= tim_ie->data[DOT11_MNG_TIM_DTIM_PERIOD]) {
		/* sick AP, prevent going to power-save mode */
		wlc_set_pmoverride(cfg, TRUE);
		return FALSE;
	}

#if defined(DEBUG_TIM)
	if (WL_INFORM_ON()) {
		prhex("BCN_INFO: TIM", tim_ie, TLV_HDR_LEN + tim_ie->len);
	}
#endif /* defined(DEBUG_TIM) */

	/* check broadcast/multicast traffic indication in DTIM beacon */
	*dtim_count = tim_ie->data[DOT11_MNG_TIM_DTIM_COUNT];
	*bcmc = tim_ie->data[DOT11_MNG_TIM_BITMAP_CTL] & 0x1;

	/* extract bitmap offset (N1) from bitmap control field */
	pvboff = tim_ie->data[DOT11_MNG_TIM_BITMAP_CTL] & 0xfe;

	/* compute bitmap length (N2 - N1) from info element length */
	pvblen = tim_ie->len - DOT11_MNG_TIM_FIXED_LEN;

	/* bail early if our AID precedes the TIM */
	AIDbyte = (wlc->AID & DOT11_AID_MASK) >> 3;
	if (AIDbyte < pvboff || AIDbyte >= pvboff + pvblen)
		return FALSE;

	/* check our AID in bitmap */
	return (tim_ie->data[DOT11_MNG_TIM_PVB + AIDbyte - pvboff] &
	        (1 << (wlc->AID & 0x7))) ? TRUE : FALSE;
}
#endif /* STA */

static bool
wlc_is_publicaction(uint8 *hdr, int len)
{
	if (len < (DOT11_MGMT_HDR_LEN + DOT11_ACTION_HDR_LEN))
		return FALSE;

	hdr += DOT11_MGMT_HDR_LEN;	/* peek for category field */
	if (*hdr == DOT11_ACTION_CAT_PUBLIC)
		return TRUE;
	return FALSE;
}

static bool
wlc_is_vsaction(uint8 *hdr, int len)
{
	if (len < (DOT11_MGMT_HDR_LEN + DOT11_ACTION_HDR_LEN))
		return FALSE;

	hdr += DOT11_MGMT_HDR_LEN;	/* peek for category field */
	if (*hdr == DOT11_ACTION_CAT_VS)
		return TRUE;
	return FALSE;
}

/*
 * Filters frames based on class and the current authentication and
 * association states of the remote station.
 * State 1 is unauthenticated and unassociated.
 * State 2 is authenticated and unassociated.
 * State 3 is authenticated and associated.
 * Class 1 frames are permitted from within states 1, 2, and 3.
 * Class 2 frames are permitted if and only if authenticated with the remote station
 *	(i.e., allowed from within States 2 and 3 only).
 * Class 3 frames are permitted if and only if associated with the remote station
 *	(i.e., allowed only from within State 3).
 *
 * Returns 0 on success (accept frame) and non-zero reason code on failure (toss frame).
 * Updates pointer to scb if provided.
 */
static uint16 BCMFASTPATH
wlc_recvfilter(wlc_info_t *wlc, struct dot11_header *h, wlc_d11rxhdr_t *wrxh, struct scb **pscb,
	int len)
{
#if defined(BCMDBG) || defined(WLMSG_ASSOC) || defined(WLMSG_BTA) || \
	((defined(WLMSG_INFORM) || defined(BCMDBG_ERR)) && defined(AP))
	char eabuf[ETHER_ADDR_STR_LEN], *sa = bcm_ether_ntoa(&h->a2, eabuf);
#endif
	uint16 fc = ltoh16(h->fc), rc;
	uint16 fk = fc & FC_KIND_MASK;
	struct scb *scb = NULL;
	int class, rx_bandunit;
	bool ibss_accept = FALSE;
	wlc_bsscfg_t *bsscfg = NULL;
	struct ether_addr *bssid;

	rx_bandunit = CHANNEL_BANDUNIT(wlc, WLC_RX_CHANNEL(&wrxh->rxhdr));

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return (wlc_lmac_recvfilter(wlc->lmac_info, h, rx_bandunit, pscb));
#endif

	/* Default is class 1 */
	class = 1;
	rc = 0;

	switch (FC_TYPE(fc)) {

	case FC_TYPE_CTL:
	case FC_TYPE_MNG:
		/* Control and management frames should have no DS bits set */
		if (fc & (FC_TODS | FC_FROMDS))
			/* Some Conexant AP has FROMDS set on Probe Responses */
			if ((fk != FC_PROBE_RESP) &&
			    (fk != FC_PS_POLL))
				goto bad;

		switch (fk) {

		/* Class 2 control and management frames */
		case FC_ASSOC_REQ:
		case FC_ASSOC_RESP:
		case FC_REASSOC_REQ:
		case FC_REASSOC_RESP:
		case FC_DISASSOC:
#ifdef MFP
		case FC_DEAUTH:
#endif
			class = 2;
			rc = DOT11_RC_INVAL_CLASS_2;
			break;

		/* Class 3 control and management frames */
		case FC_ACTION:
			if (wlc_is_vsaction((uint8 *)h, len)) {
				goto done;
			}
			if (wlc_is_publicaction((uint8 *)h, len)) {
				goto done;
			}
		case FC_PS_POLL:
		case FC_BLOCKACK:
		case FC_BLOCKACK_REQ:
			class = 3;
			rc = DOT11_RC_INVAL_CLASS_3;
			break;

		/* All other frame types are class 1 */
		default:
			goto done;
		}
		break;

	case FC_TYPE_DATA:
		/* Data frames with no DS bits set are class 1 */
		if (!(fc & (FC_TODS | FC_FROMDS)))
			goto done;

		/* Data frames with both DS bits set are WDS (class 4) */
		if ((fc & (FC_TODS | FC_FROMDS)) == (FC_TODS | FC_FROMDS)) {
			/* 802.11 does not define class 4, just used here for filtering */
			class = 4;
			rc = DOT11_RC_UNSPECIFIED;
		} else {
			/* Data frames with DS bits set are class 3 */
			class = 3;
			rc = DOT11_RC_INVAL_CLASS_3;
		}

		break;

	bad:
	default:
		WL_ERROR(("wl%d: %s: bad frame control 0x%.4x\n",
		          wlc->pub->unit, __FUNCTION__, fc));
		rc = DOT11_RC_UNSPECIFIED;
		WLCNTINCR(wlc->pub->_cnt->rxbadcm);
		goto done;
	}

	/* by this point, incoming packets are either class 2, 3, or 4 (WDS) */

	scb = wlc_scbfindband(wlc, &h->a2, rx_bandunit);
	if (scb != NULL) {
		bsscfg = SCB_BSSCFG(scb);
		ASSERT(bsscfg != NULL);
		/* Allow specified Class 3 control and management frames in
		 * IBSS mode to pass through.
		 * Current HT or .11 spec do not address how to handle
		 * this types of frame in IBSS network
		 */
		if (BSSCFG_STA(bsscfg) && !bsscfg->BSS && bsscfg->associated &&
		    ((fk == FC_BLOCKACK) ||
		     (fk == FC_BLOCKACK_REQ) ||
		     ((fk == FC_ACTION) && bcmp(&bsscfg->BSSID, &h->a3, ETHER_ADDR_LEN) == 0)))
			ibss_accept = TRUE;
	}

	if (class == 4) {
#ifdef AP
		/* create an scb for every station in "Lazy WDS" mode */
		if (scb == NULL &&
		    !WIN7_OS(wlc->pub) && wlc->ap->lazywds) {
			wlc_bsscfg_t *bc;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
			char da[ETHER_ADDR_STR_LEN];
#endif


			WL_INFORM(("wl%d: Creating wds link\n", wlc->pub->unit));

			if ((bc = wlc_bsscfg_find_by_hwaddr(wlc, &h->a1)) == NULL) {
				WL_INFORM(("wl%d: BSS %s not found, ignore WDS link from %s\n",
				           wlc->pub->unit, bcm_ether_ntoa(&h->a1, da), sa));
			}
			else if (!BSSCFG_AP(bc)) {
				WL_INFORM(("wl%d: BSS %s isn't an AP, ignore WDS link from %s\n",
				           wlc->pub->unit, bcm_ether_ntoa(&h->a1, da), sa));
			}
			else if (bc != wlc->cfg) {
				WL_INFORM(("wl%d: BSS %s not allow WDS, ignore WDS link from %s\n",
				           wlc->pub->unit, bcm_ether_ntoa(&h->a1, da), sa));
			}
			else if ((scb = wlc_scblookup(wlc, &h->a2)) == NULL) {
				WL_ERROR(("wl%d: unable to create SCB for WDS link %s\n",
				          wlc->pub->unit, sa));
			}
			else {
				/* Set up WDS on this interface now */
				int err;
				wlc_scb_set_bsscfg(scb, bc);
				if ((err = wlc_wds_create(wlc, scb, 0)) != BCME_OK) {
					WL_ERROR(("wl%d: Error %s creating WDS interface\n",
					          wlc->pub->unit, bcmerrorstr(err)));
					wlc_scbfree(wlc, scb);
					scb = NULL;
				}
			}
		}
#endif /* AP */
		if (scb == NULL) {
			WL_ASSOC(("wl%d: %s: unhandled WDS frame from unknown station %s\n",
				wlc->pub->unit, __FUNCTION__, sa));
			WLCNTINCR(wlc->pub->_cnt->rxbadproto);
		}
		else if (!SCB_WDS(scb)) {
			WL_ASSOC(("wl%d: %s: invalid WDS frame from non-WDS station %s\n",
				wlc->pub->unit, __FUNCTION__, sa));
			WLCNTINCR(wlc->pub->_cnt->rxbadproto);
		}
#ifdef WLBTAMP
		else if (BSS_BTA_ENAB(wlc, bsscfg) && !SCB_ASSOCIATED(scb)) {
			WL_BTA(("wl%d: %s: invalid WDS frame from non-associated BT-AMP peer %s\n",
				wlc->pub->unit, __FUNCTION__, sa));
		}
#endif
		else {
			rc = 0;	/* Accept frame */
		}
	}
	/* early bail-out, all frames accepted at associated or wds state */
	/* BAXXX: This allows all packets thru a WDS link; probably not a good idea */
	/* Need to restrict to some subset */
	else if (scb && (SCB_ASSOCIATED(scb) || SCB_WDS(scb) ||
	                 ibss_accept)) {
		rc = 0;		/* Accept frame */
	}
	/* Toss if nonauthenticated */
	else if (!scb || !SCB_AUTHENTICATED(scb)) {
		if (scb == NULL)
			WL_ASSOC(("wl%d: %s: invalid class %d frame from unknown station %s\n",
			          wlc->pub->unit, __FUNCTION__, class, sa));
		else
			WL_ASSOC(("wl%d: %s: invalid class %d frame from non-authenticated "
			          "station %s\n", wlc->pub->unit, __FUNCTION__, class, sa));
		/* do not send a deauth if we are on the way to authenticating since
		 * our deauth and an incoming auth response may cross paths
		 * also, don't send if we're not currently on-channel
		 */
		if (!ETHER_ISMULTI(&h->a1) && !(scb && (scb->state & PENDING_AUTH)) &&
		    (rx_bandunit == (int) wlc->band->bandunit)) {
			struct ether_addr *cur_etheraddr;

			if ((fc & (FC_TODS | FC_FROMDS)) == FC_TODS)
				bssid = &h->a1;
			else if ((fc & (FC_TODS | FC_FROMDS)) == FC_FROMDS)
				bssid = &h->a2;
			else
				bssid = &h->a3;

			/* If scb is NULL, the bsscfg will be NULL, either.
			 * Search list with the desired bssid to locate the
			 * correct bsscfg.
			 */
			if (bsscfg == NULL)
				bsscfg = wlc_bsscfg_find_by_bssid(wlc, bssid);

			if (bsscfg)
				cur_etheraddr = &bsscfg->cur_etheraddr;
			else
				/* bsscfg not found, use default */
				cur_etheraddr = &wlc->pub->cur_etheraddr;

			(void)wlc_senddeauth(wlc, &h->a2, bssid, cur_etheraddr, scb, rc);

			wlc_deauth_complete(wlc, NULL, WLC_E_STATUS_SUCCESS, &h->a2, rc, 0);
		}
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);
	}
	/* Toss if nonassociated */
	else if (class == 3 && !SCB_ASSOCIATED(scb)) {
		WL_ASSOC(("wl%d: %s: invalid class %d frame from non-associated station %s\n",
			wlc->pub->unit, __FUNCTION__, class, sa));
		/* do not send a disassoc if we are on the way to associating since
		 * our disassoc and an incoming assoc response may cross paths
		 */
		if (!ETHER_ISMULTI(&h->a1) && !(scb->state & PENDING_ASSOC) &&
		    (rx_bandunit == (int) wlc->band->bandunit)) {

			bsscfg = SCB_BSSCFG(scb);
			ASSERT(bsscfg != NULL);

			wlc_senddisassoc(wlc, &h->a2, &bsscfg->BSSID,
			                 &bsscfg->cur_etheraddr, scb, rc);
		}
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);
	}
	/* Accept frame */
	else
		rc = 0;

done:
	if (pscb)
		*pscb = scb;
	return rc;
}

void
wlc_csa_timeout(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;
	wlc_info_t *wlc = cfg->wlc;
#ifdef STA
	wlc_bsscfg_t *active_assoc_cfg = wlc->assoc_req[0];
#endif
	wlc_csa_t *csa = cfg->csa;

	if (!wlc->pub->up)
		return;

	if (DEVICEREMOVED(wlc)) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		wl_down(wlc->wl);
		return;
	}

#ifdef STA
	if ((active_assoc_cfg != NULL) &&
	    ((active_assoc_cfg->assoc->state == AS_WAIT_FOR_AP_CSA) ||
	     (active_assoc_cfg->assoc->state == AS_WAIT_FOR_AP_CSA_ROAM_FAIL))) {
		active_assoc_cfg->csa->spect_state &= ~NEED_TO_SWITCH_CHANNEL;
		/* stop the ap  */
		wlc_stop_ap(wlc, TRUE, active_assoc_cfg, -1);
		WL_ASSOC(("wl%d.%d: stop ap and call wlc_join_bss\n",
		          wlc->pub->unit, active_assoc_cfg->_idx));
		if (active_assoc_cfg->assoc->state == AS_WAIT_FOR_AP_CSA) {
			wlc_join_BSS(active_assoc_cfg,
			             wlc->join_targets->ptrs[wlc->join_targets_last]);
		}
		else {
			wlc_roam_complete(active_assoc_cfg, WLC_E_STATUS_FAIL,
			                  &active_assoc_cfg->BSSID,
			                  WLC_DOT11_BSSTYPE(active_assoc_cfg->target_bss->infra));
		}
		return;
	}
#endif /* STA */

	if ((BSSCFG_AP(cfg) || csa->csa.count == 0 || csa->channel_sw.secs) &&
	    (csa->spect_state & NEED_TO_SWITCH_CHANNEL)) {
		if (BSSCFG_STA(cfg))
			csa->channel_sw.secs = 0;
		/* time to switch channels... */
		wlc_do_chanswitch(cfg, csa->csa.chspec);
		csa->spect_state &= ~NEED_TO_SWITCH_CHANNEL;
	}

	/* Send Channel Switch Indication to upper (OS) layer. */
	if (BSSCFG_STA(cfg))
		wlc_bss_mac_event(wlc, cfg, WLC_E_CSA_COMPLETE_IND, NULL,
			WLC_E_STATUS_SUCCESS, 0, 0, 0, 0);
}

/* Can be called in either STA or AP context.
 * In STA mode, we received a Channel Switch announcement.
 * In AP, we detected radar and need to move off channel.
 */
void
wlc_do_chanswitch(wlc_bsscfg_t *cfg, chanspec_t newchspec)
{
	wlc_info_t *wlc = cfg->wlc;
	bool band_chg = FALSE;
	bool bw_chg = FALSE;

	WL_INFORM(("wl%d: %s: new channel %d\n", wlc->pub->unit, __FUNCTION__,
		CHSPEC_CHANNEL(newchspec)));

	if (!wlc_valid_chanspec_db(wlc->cmi, newchspec)) {
		WL_REGULATORY(("%s: Received invalid channel - ignoring\n", __FUNCTION__));
		/* something needs to be done here ?? */
		return;
	}

	/* evaludate band or bandwidth change here before wlc->home_chanspec gets changed */
	if (CHSPEC_WLCBANDUNIT(wlc->home_chanspec) != CHSPEC_WLCBANDUNIT(newchspec))
		band_chg = TRUE;
	if (CHSPEC_BW(wlc->home_chanspec) != CHSPEC_BW(newchspec))
		bw_chg = TRUE;

	if (WL11H_ENAB(wlc)) {
		/* restore the current channel's quiet bit */
		if (wlc_radar_chanspec(wlc->cmi, wlc->home_chanspec) ||
		    wlc_restricted_chanspec(wlc->cmi, wlc->home_chanspec))
			wlc_set_quiet_chanspec(wlc->cmi, wlc->home_chanspec);
		WL_REGULATORY(("%s: switching to channel %d\n", __FUNCTION__,
		               CHSPEC_CHANNEL(newchspec)));
	}

#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub)) {
		WL_MCHAN(("wl%d.%d: %s: chansw command issued, change chanctx to 0x%x\n",
		          wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, newchspec));
		wlc_mchan_create_bss_chan_context(wlc, cfg, newchspec);
		/* Make sure cfg->current_bss and cfg->target_bss chanspec changed also */
		cfg->current_bss->chanspec = newchspec;
		cfg->target_bss->chanspec = newchspec;
	}
#endif
	wlc_set_home_chanspec(wlc, newchspec);

	wlc_suspend_mac_and_wait(wlc);
	wlc_set_chanspec(wlc, newchspec);
#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub) && cfg->chan_context->qi != wlc->primary_queue) {
		wlc_primary_queue_set(wlc, cfg->chan_context->qi);
	}
#endif
	if (BSSCFG_AP(cfg)) {
		wlc->bcn_rspec = wlc_lowest_basic_rspec(wlc, &cfg->current_bss->rateset);
		ASSERT(wlc_valid_rate(wlc, wlc->bcn_rspec,
		                      CHSPEC_IS2G(cfg->current_bss->chanspec) ?
		                      WLC_BAND_2G : WLC_BAND_5G, TRUE));
		wlc_beacon_phytxctl(wlc, wlc->bcn_rspec);
		wlc_bss_update_beacon(wlc, cfg);
		wlc_bss_update_probe_resp(wlc, cfg, FALSE);
	}
	wlc_enable_mac(wlc);

	WL_REGULATORY(("%s: switched to channel %d\n", __FUNCTION__, CHSPEC_CHANNEL(newchspec)));

	if (band_chg) {
		wlc_scb_update_band_for_cfg(wlc, cfg, newchspec);
	}
	/* if AP is active restart AP */
	if (AP_ACTIVE(wlc))
		wlc_restart_ap(wlc->ap);

	/* force a rate selection init. */
	if (bw_chg)
		wlc_scb_ratesel_init_bss(wlc, cfg);

	/* perform a reassoc procedure to sync up everything with the AP. */
	if (band_chg || bw_chg) {
		if (BSSCFG_STA(cfg) && cfg->BSS) {
			wl_reassoc_params_t assoc_params;

			assoc_params.bssid = cfg->BSSID;
			assoc_params.chanspec_num = 1;
			assoc_params.chanspec_list[0] = newchspec;
#ifdef STA
			wlc_reassoc(cfg, &assoc_params);
#endif
		}
	}
}

bool
wlc_csa_quiet(wlc_info_t *wlc, uint8 *tag, uint tag_len)
{
	bool quiet = FALSE;
#if defined(WL11H) || defined(WL11D)
	dot11_chan_switch_ie_t *csa_ie;

	if (!tag || tag_len <= DOT11_BCN_PRB_LEN)
		return quiet;

	tag_len = tag_len - DOT11_BCN_PRB_LEN;
	tag = tag + DOT11_BCN_PRB_LEN;

	csa_ie = (dot11_chan_switch_ie_t *)bcm_parse_tlvs(tag, tag_len,
		DOT11_MNG_CHANNEL_SWITCH_ID);
	if (csa_ie && csa_ie->mode)
		quiet = TRUE;
#endif /* WL11H || WL11D */
	return quiet;
}

#ifdef STA

/* STA: Handle Power Constraint IE */
static void
wlc_11h_pwr(wlc_info_t *wlc, dot11_power_cnst_t *local_pwr)
{
	uint8 local;

	if (local_pwr->len < 1)
		return;

	local = local_pwr->power;

	if (local == wlc->txpwr_local_constraint)
		return;

	WL_REGULATORY(("wl%d: adjusting local power constraint from %d to %d dBm\n",
		wlc->pub->unit, wlc->txpwr_local_constraint, local));

	wlc->txpwr_local_constraint = local;

	/* only update power targets if we are up and on the BSS home channel */
	if (wlc->pub->up && wlc->pub->associated &&
	    (wlc->chanspec == wlc->home_chanspec)) {

		/* Set the power limits for this locale after computing
		 * any 11h local tx power constraints.
		 */
		wlc_channel_set_txpower_limit(wlc->cmi, wlc_local_constraint_qdbm(wlc));

		/* wlc_phy_cal_txpower_recalc_sw(wlc->band->pi); */
	}
}

/* STA: Handle incoming Channel Switch Anouncement */
static void
wlc_csa_channel_switch(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	wlc_bss_info_t *current_bss = cfg->current_bss;
	uint32 bi_us = (uint32)current_bss->beacon_period * DOT11_TU_TO_US;
	uint32 secs;
#ifdef AP
	wlc_bsscfg_t *ap_bsscfg;
	int idx;
#endif /* AP */
	wlc_csa_t *csa = cfg->csa;

	if (!wlc_valid_chanspec_db(wlc->cmi, csa->csa.chspec)) {
		WL_ERROR(("wl%d: %s: Received invalid channel: %d\n",
			wlc->pub->unit, __FUNCTION__, CHSPEC_CHANNEL(csa->csa.chspec)));
		/* Received bogus, malformed or otherwise screwed CSA.
		 * Err on the side of caution and goto an active A band channel now
		 */
		csa->csa.chspec = wlc_next_chanspec(wlc->cmi,
			CH20MHZ_CHSPEC((CH_MAX_2G_CHANNEL+1)), CHAN_TYPE_CHATTY, 0);
		if (csa->csa.chspec == wlc->home_chanspec)
			csa->csa.chspec =
				wlc_next_chanspec(wlc->cmi, csa->csa.chspec, CHAN_TYPE_CHATTY, 0);
		csa->csa.count = 1;
	}

	secs = (bi_us * csa->csa.count)/1000000;

	if (csa->csa.mode && WL11H_ENAB(wlc) && !CHSPEC_IS2G(wlc->home_chanspec)) {
		wlc_set_quiet_chanspec(wlc->cmi, wlc->home_chanspec);
		if (WLC_BAND_PI_RADIO_CHANSPEC == wlc->home_chanspec)
			wlc_mute(wlc, ON, 0);
	}

	if (csa->channel_sw.secs != 0) {
		WL_REGULATORY(("%s: ignoring csa: mode %d, channel %d, count %d, secs %d\n",
			__FUNCTION__,
			csa->csa.mode, CHSPEC_CHANNEL(csa->csa.chspec), csa->csa.count, secs));
		return;
	}

	WL_REGULATORY(("%s: Recved CSA: mode %d, channel %d, count %d, secs %d\n",
	               __FUNCTION__,
	               csa->csa.mode, CHSPEC_CHANNEL(csa->csa.chspec), csa->csa.count, secs));

	/* If target < than 2 second and we need to be quiet until switch time
	 * then might as well switch now.
	 */
	if (secs < 2 && (csa->csa.mode || secs == 0)) {
		WL_REGULATORY(("%s: switch is only %d secs, switching now\n", __FUNCTION__, secs));
		wlc_do_chanswitch(cfg, csa->csa.chspec);

		/* Send Channel Switch Indication to upper (OS) layer. */
		wlc_bss_mac_event(wlc, cfg, WLC_E_CSA_COMPLETE_IND, NULL,
		                  WLC_E_STATUS_SUCCESS, 0, 0, 0, 0);

		return;
	}

	WL_REGULATORY(("%s: Scheduling channel switch in %d tbtts\n", __FUNCTION__,
	               csa->csa.count));

	/* Now we only use cfg->channel_sw.secs as a flag */
	csa->channel_sw.secs = secs;
	csa->channel_sw.chanspec = csa->csa.chspec;
	csa->spect_state |= NEED_TO_SWITCH_CHANNEL;
	wl_add_timer(wlc->wl, csa->csa_timer, current_bss->beacon_period * csa->csa.count, 0);

#ifdef AP
	/* if we have an ap that is up and (sradar || ap_noradar_chan) enabled */
#ifdef WLMCHAN
	if (!MCHAN_ENAB(wlc->pub) ||
	    wlc_mchan_stago_is_disabled(wlc->mchan))
#endif
	{
	FOREACH_UP_AP(wlc, idx, ap_bsscfg) {
		bool special_ap = (WL11H_AP_ENAB(wlc) &&
		                   (BSSCFG_SRADAR_ENAB(ap_bsscfg) ||
		                    BSSCFG_AP_NORADAR_CHAN_ENAB(ap_bsscfg)));
		if (special_ap &&
		    (ap_bsscfg->current_bss->chanspec == cfg->current_bss->chanspec)) {
			/* copy over the csa info */
			bcopy(&csa->csa, &ap_bsscfg->csa->csa, sizeof(wl_chan_switch_t));
			/* decrement by 1 since this is for our next beacon */
			ap_bsscfg->csa->csa.count--;
			/* send csa action frame and update bcn, prb rsp */
			wlc_ap_apply_channel_switch(ap_bsscfg);
		}
	}
	}
#endif /* AP */
}

#define FIFO_DRAIN_TIME	33	/* Use worst case: 33 millisecs */
/*
 *    Theory of quiet mode:
 *	AP sends quiet mode info element.
 *	wlc_11h_quiet()-parses IE. Take into account the overhead in
 *	to shutting down the FIFOs (FIFO_DRAIN_TIME) and determine
 *	proper interval and offset. Register quiet0 to be called when
 *	we have reached the target beacon interval.
 *
 *	step0() -	Now in correct beacon interval but need to wait
 *			for the right offset within beacon.  Use OS timer
 *			then proceed to step1().
 *
 *	step1()-	Timer dinged and we are now at the right place to start
 *			shutting down FIFO's. Wait for FIFO drain interrupts.
 *
 *	step2()-	Interrupts came in. We are now mute. Set timer
 *			when its time to come out of quiet mode.
 *
 *	step3()-	Timer dinged. Resume normal operation.
 *
 */

/* Came from: wlc_parse_11h()
 * Will go to: wlc_start_quiet0()
 */
static void
wlc_11h_quiet(wlc_info_t *wlc, dot11_quiet_t *quiet, struct dot11_bcn_prb *bcn)
{
	wlc_bsscfg_t *cfg = wlc->cfg;
	uint32 bi_us = (uint32)cfg->current_bss->beacon_period * DOT11_TU_TO_US;
	uint32 tsf_h, tsf_l;
	uint32 offset, beacon_start;
	int32 countdown;

	/* Ignore further requests for quiet if we are already handling one. */
	if (QUIET_STATE(wlc) != 0) {
		WL_REGULATORY(("quiet: rcvd but ignoring:count %d, period %d, duration %d, offset"
			" %d\n",
			quiet->count, quiet->period, ltoh16(quiet->duration),
			ltoh16(quiet->offset)));
		return;
	}

	/* Parse info and setup to wait for the right beacon interval */
	WL_REGULATORY(("quiet: count %d, period %d, duration %d, offset %d\n",
		quiet->count, quiet->period, ltoh16(quiet->duration), ltoh16(quiet->offset)));

	wlc->quiet->duration = ltoh16(quiet->duration);	/* TU's */
	wlc->quiet->offset = ltoh16(quiet->offset);	/* TU's offset from TBTT in Count field */
	wlc->quiet->period = quiet->period;
	countdown = quiet->count;			/* num beacons until start */

	if (!countdown)
		return;
	if (countdown == 1 && wlc->quiet->offset < FIFO_DRAIN_TIME) {
		WL_REGULATORY(("wl%d: %s: Not enough lead time for quiet period\n",
			wlc->pub->unit, __FUNCTION__));
		return;
	}

	/* The FIFO's will take a while to drain.  If the offset is less than that
	 * time, back up into the previous beacon interval.
	 */
	if (wlc->quiet->offset < FIFO_DRAIN_TIME) {
		countdown--;
	}

	/* Calculate absolute TSF of when to start preparing to be quiet */
	tsf_l = ltoh32_ua(&bcn->timestamp[0]);
	tsf_h = ltoh32_ua(&bcn->timestamp[1]);
	offset = wlc_calc_tbtt_offset(ltoh16(bcn->beacon_interval), tsf_h, tsf_l);
	beacon_start = tsf_l - offset;

	/* usecs for starting quiet period */
	wlc->quiet->start_tsf = beacon_start + (bi_us * quiet->count) + (wlc->quiet->offset *
		DOT11_TU_TO_US);
	wlc->quiet->start_prep_tsf = wlc->quiet->start_tsf - FIFO_DRAIN_TIME * 1000;
	wlc->quiet->end_tsf = wlc->quiet->start_tsf + wlc->quiet->duration * DOT11_TU_TO_US;

	if ((!WIN7_OS(wlc->pub) || AP_ACTIVE(wlc)) && APSTA_ENAB(wlc->pub)) {
		uint32 qoffset;
		uint32 mytsf_l, mytsf_h, myoffset;

		wlc_read_tsf(wlc, &mytsf_l, &mytsf_h);
		myoffset = wlc_calc_tbtt_offset(cfg->current_bss->beacon_period, mytsf_h, mytsf_l);
		qoffset = (uint32)(wlc->quiet->offset) + (myoffset - offset);
		if (qoffset < FIFO_DRAIN_TIME) {
			if (quiet->count == 1) {
				WL_APSTA_TSF(("wl%d: %s: After URE conversion, not enough lead time"
					" for quiet period\n",
					wlc->pub->unit, __FUNCTION__));
				return;
			}
			if (countdown == quiet->count) {
				countdown--;
			}
		}

		wlc->quiet->offset = (int)qoffset;
		wlc->quiet->start_tsf += (mytsf_l - tsf_l);
		wlc->quiet->start_prep_tsf = wlc->quiet->start_tsf - FIFO_DRAIN_TIME * 1000;
		wlc->quiet->end_tsf = wlc->quiet->start_tsf + wlc->quiet->duration * DOT11_TU_TO_US;
	}

	/* Save this for last cuz this is what the dpc looks at */
	wlc->quiet->_state = WAITING_FOR_INTERVAL;
	wlc->quiet->countdown = countdown;
	wl_add_timer(wlc->wl, wlc->quiet->timer, cfg->current_bss->beacon_period * countdown, 0);

	/* When the quiet timer expires, wlc_start_quiet0() will be called in timer handler
	 * wlc_quiet_timer()
	 */
}

/* Now in correct beacon interval but need to wait for offset.
 * Came from: quiet timer handler wlc_quiet_timer()
 * Will go to: wlc_start_quiet1() via wlc_quiet_timer()
 */
static void
wlc_start_quiet0(wlc_info_t *wlc)
{
	uint32 tsf_hi, tsf_lo;
	uint32 start_prep_ms;

	ASSERT(wlc->quiet->_state & WAITING_FOR_INTERVAL);
	WL_REGULATORY(("Entering %s\n", __FUNCTION__));

	wlc->quiet->_state = WAITING_FOR_OFFSET;

	wlc_read_tsf(wlc, &tsf_lo, &tsf_hi);
	if (((tsf_lo == (uint32)-1) && (tsf_hi == (uint32)-1)) ||
	    (tsf_lo < wlc->quiet->start_tsf) || (tsf_lo > wlc->quiet->end_tsf) ||
	    (tsf_lo >= wlc->quiet->start_prep_tsf)) {
		/* Already late so call routine directly instead of through timer. */
		wlc_start_quiet1(wlc);
	} else {
		start_prep_ms = (wlc->quiet->start_prep_tsf - tsf_lo) / 1000;
		/* Set timer for difference (in millisecs) */
		WL_REGULATORY(("%s: Setting timer for %d millisecs\n",
			__FUNCTION__, start_prep_ms));
		wl_add_timer(wlc->wl, wlc->quiet->timer, start_prep_ms, 0);
	}
}

/* Triple use timer handler: Either
 *	- Waiting to advance to 'count' tbtts into offset waiting
 *	- Or waiting to advance to 'offset' usecs into bcn interval to start quiet period.
 *	- Or waiting for end of quiet period.
 *	Came from:  wlc_11h_quiet() via timer interrupt, wlc_start_quiet0() via timer interrupt, or
 *		wlc_start_quiet2() via timer interrupt.
 *	Will go to: wlc_start_quiet0(), wlc_start_quiet1() or wlc_start_quiet3()
 */
void
wlc_quiet_timer(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t*)arg;

	if (!wlc->pub->up)
		return;

	if (DEVICEREMOVED(wlc)) {
		WL_ERROR(("wl%d: %s: dead chip\n", wlc->pub->unit, __FUNCTION__));
		wl_down(wlc->wl);
		return;
	}

	WL_REGULATORY(("Entering %s\n", __FUNCTION__));
	if (QUIET_STATE(wlc) & WAITING_FOR_INTERVAL) {
		wlc_start_quiet0(wlc);
		return;
	}
	if (QUIET_STATE(wlc) & WAITING_FOR_OFFSET) {
		wlc_start_quiet1(wlc);
	}
	if (QUIET_STATE(wlc) & WAITING_FOR_DURATION) {
		wlc_start_quiet3(wlc);
	}
}

/* Called from wlc_quiet_timer() when we are at proper offset within
 * proper beacon.  Need to initiate quiet period now.
 * Came from: wlc_start_quiet0() via wlc->quiet_timer.
 * Will go to: wlc_start_quiet2().
 */
static void
wlc_start_quiet1(wlc_info_t *wlc)
{

	WL_REGULATORY(("Entering %s\n", __FUNCTION__));

	ASSERT(wlc->quiet->_state & WAITING_FOR_OFFSET);
	wlc->quiet->_state &= ~WAITING_FOR_OFFSET;

	if (wlc_mac_request_entry(wlc, NULL, WLC_ACTION_QUIET) != BCME_OK) {
		/* blocked from entry, cancel quiet period */
		wlc->quiet->_state = 0;	/* All done */
		return;
	}

	/* reject future scans until done with quiet */
	wlc->quiet->_state |= SILENCE;

	/* Send feedback upstream */
	wlc_mac_event(wlc, WLC_E_QUIET_START, NULL, WLC_E_STATUS_SUCCESS, 0, 0, 0, 0);

	wlc_bmac_tx_fifo_suspend(wlc->hw, TX_DATA_FIFO);
	wlc_bmac_tx_fifo_suspend(wlc->hw, TX_CTL_FIFO);

	wlc->quiet->_state |= WAITING_FOR_FLUSH_COMPLETE;

	/* Now wait for FIFO drain interrupt and proceed to wlc_start_quiet2() */
}

/* Fifo's have drained, now be quiet.
 * Came from: wlc_start_quiet1() via dpc FIFO drain handler.
 * Will go to: wlc_start_quiet3() via wlc_quiet_timer.
 */
void
wlc_start_quiet2(wlc_info_t *wlc)
{
	uint32 tsf_hi, tsf_lo;

	WL_REGULATORY(("Entering %s\n", __FUNCTION__));
	ASSERT(!(wlc->quiet->_state & WAITING_FOR_FLUSH_COMPLETE));

	/* zero the address match register so we do not send ACKs */
	wlc_set_addrmatch(wlc, RCM_MAC_OFFSET, &ether_null);

	wlc_read_tsf(wlc, &tsf_lo, &tsf_hi);

	wlc->quiet->_state |= WAITING_FOR_DURATION;

	if (((tsf_lo == (uint32)-1) && (tsf_hi == (uint32)-1)) ||
	    (tsf_lo < wlc->quiet->start_tsf) || (tsf_lo > wlc->quiet->end_tsf)) {
		/* wlc_read_tsf failed, or end the quiet period immediately */
		wlc_start_quiet3(wlc);
	}
	else {
		/* Set timer for difference (in millisecs) */
		wl_add_timer(wlc->wl, wlc->quiet->timer, (wlc->quiet->end_tsf - tsf_lo) / 1000, 0);
	}
}

/* Done with quiet period.
 * Called from: timer via wlc_start_quiet2().
 * Will go to: wlc_quiet_timer()->dpc handler.
 */
static void
wlc_start_quiet3(wlc_info_t *wlc)
{
	WL_REGULATORY(("Entering %s\n", __FUNCTION__));
	ASSERT(wlc->quiet->_state & WAITING_FOR_DURATION);
	wlc->quiet->_state &= ~WAITING_FOR_DURATION;

	wlc_mute(wlc, OFF, 0);

	wlc_mac_event(wlc, WLC_E_QUIET_END, NULL, WLC_E_STATUS_SUCCESS, 0, 0, 0, 0);

	WL_REGULATORY(("%s:Quiet Complete\n", __FUNCTION__));
	wlc->quiet->_state = 0;	/* All done */
}

#ifdef BCMDBG
static void
wlc_11h_ibss(wlc_info_t *wlc, dot11_ibss_dfs_t *tag)
{
}

static void
wlc_tpc_report(wlc_info_t *wlc, dot11_tpc_rep_t *ie)
{
	if (ie->len < 2) {
		WL_ERROR(("wl%d: wlc_tpc_report: TPC Report IE len %d too short, expected 2.\n",
			wlc->pub->unit, ie->len));
		return;
	}

	WL_NONE(("wl%d: wlc_tpc_report: TPC Report TX Pwr %d dBm, Link Margin %d dB.\n",
		wlc->pub->unit, (int)ie->tx_pwr, (int)ie->margin));
}
#endif /* BCMDBG */

#if defined(WL11H) || defined(WL11D)
int
wlc_parse_country_ie(wlc_info_t *wlc, const bcm_tlv_t *ie, char *country,
	chanvec_t *valid_channels, int8 *tx_pwr)
{
	const uint8 *cp;
	char ie_len = ie->len;
	int8 channel_txpwr;
	uchar channel, channel_len;
	uint8 ch_sep;

	ASSERT(ie->id == DOT11_MNG_COUNTRY_ID);

	bzero(country, 4);
	bzero(valid_channels, sizeof(chanvec_t));

	if (ie_len >= WLC_MIN_CNTRY_ELT_SZ) {
		/* parse country string */
		cp = ie->data;
		country[0] = *(cp++);
		country[1] = *(cp++);
		country[2] = *(cp++);
		country[3] = 0;	/* terminate */
		ie_len -= 3;

		/* Parse all first channel/num channels/tx power triples */
		while (ie_len >= 3) {
			channel = cp[0];
			channel_len = cp[1];
			channel_txpwr = (int8)cp[2];

			ch_sep = (channel <= CH_MAX_2G_CHANNEL)? CH_5MHZ_APART: CH_20MHZ_APART;
			for (; channel_len && channel < MAXCHANNEL; channel += ch_sep,
				channel_len--) {
				setbit(valid_channels->vec, channel);
				tx_pwr[(int)channel] = channel_txpwr;
			}
			ie_len -= 3;
			cp += 3;
		}
	} else {
		WL_REGULATORY(("wl%d: %s: malformed country ie: len %d\n",
			wlc->pub->unit, __FUNCTION__, ie_len));
		return BCME_ERROR;
	}

	return 0;
}
#endif /* WL11H || WL11D */

static void
wlc_parse_11h(wlc_info_t *wlc, uint8 *params, int len, struct dot11_bcn_prb *bcn)
{
	bcm_tlv_t *tag = (bcm_tlv_t*)params;
	uint8 *end = params + len;


	if ((params < end) && (tag = bcm_parse_tlvs(params, (int)(end - params),
		DOT11_MNG_PWR_CONSTRAINT_ID)) != NULL) {
		wlc_11h_pwr(wlc, (dot11_power_cnst_t *)tag);
	}

	if ((params < end) && (tag = bcm_parse_tlvs(params, (int)(end - params),
		DOT11_MNG_QUIET_ID)) != NULL) {
		wlc_11h_quiet(wlc, (dot11_quiet_t *)tag, bcn);
	}
#ifdef BCMDBG
	if ((params < end) && (tag = bcm_parse_tlvs(params, (int)(end - params),
		DOT11_MNG_IBSS_DFS_ID)) != NULL) {
		wlc_11h_ibss(wlc, (dot11_ibss_dfs_t *)tag);
	}

	if ((params < end) && (tag = bcm_parse_tlvs(params, (int)(end - params),
		DOT11_MNG_TPC_REPORT_ID)) != NULL) {
		wlc_tpc_report(wlc, (dot11_tpc_rep_t *)tag);
	}
#endif /* BCMDBG */
}

static bool
wlc_parse_csa_ie(wlc_bsscfg_t *cfg, uint8 *params, int len)
{
	wlc_info_t *wlc = cfg->wlc;
	bcm_tlv_t *tag = (bcm_tlv_t*)params;
	uint8 *end = params + len;
	uint8 extch = DOT11_EXT_CH_NONE;
	uint8 type;
	bool csa_ie_found = FALSE;
	wlc_csa_t *csa = cfg->csa;

	/* 11n & 11y csa takes president */
	if ((params < end) &&
	    (tag = bcm_parse_tlvs(params, (int)(end - params),
	                          DOT11_MNG_EXT_CSA_ID)) != NULL) {
		dot11_ext_csa_ie_t *csa_ie = (dot11_ext_csa_ie_t *)tag;
		if (tag->len >= DOT11_EXT_CSA_IE_LEN) {
			csa_ie_found = TRUE;
			csa->csa.mode = csa_ie->b.mode;
			csa->csa.count = csa_ie->b.count;
			extch = wlc_rclass_extch_get(wlc->cmi, csa_ie->b.reg);
			csa->csa.chspec = wlc_ht_chanspec(wlc, csa_ie->b.channel, extch);
			csa->csa.reg = csa_ie->b.reg;
		} else
			WL_INFORM(("wl%d: %s: CSA IE length != 4\n", wlc->pub->unit, __FUNCTION__));

	}

	if (!csa_ie_found && (params < end) &&
	    (tag = bcm_parse_tlvs(params, (int)(end - params),
	                          DOT11_MNG_CHANNEL_SWITCH_ID)) != NULL) {
		bool err = FALSE;
		dot11_chan_switch_ie_t *csa_ie = (dot11_chan_switch_ie_t *)tag;
		/* look for brcm extch IE first, if exist, use it,
		 * otherwise look for IEEE extch IE
		 */
		if (tag->len < DOT11_SWITCH_IE_LEN)
			err = TRUE;

		csa_ie_found = TRUE;
		type = BRCM_EXTCH_IE_TYPE;
		tag = (bcm_tlv_t *)wlc_find_vendor_ie((uchar *)tag, (uint)(end-(uint8 *)tag),
			(const uchar*)BRCM_PROP_OUI, &type, sizeof(type));
		if (tag && tag->len == BRCM_EXTCH_IE_LEN)
			extch = ((dot11_brcm_extch_ie_t *)tag)->extch;
		else {
			tag = bcm_parse_tlvs(params, (int)(end - params),
				DOT11_MNG_EXT_CHANNEL_OFFSET);
			if (tag) {
				if (tag->len >= DOT11_EXTCH_IE_LEN) {
					extch = ((dot11_extch_ie_t *)tag)->extch;
					if (extch != DOT11_EXT_CH_LOWER &&
					    extch != DOT11_EXT_CH_UPPER &&
					    extch != DOT11_EXT_CH_NONE)
						extch = DOT11_EXT_CH_NONE;
				} else
					WL_ERROR(("wl%d: wlc_parse_11h: extension channel offset"
						" len %d don't match\n", wlc->pub->unit, tag->len));
			} else if (!csa_ie_found)
				err = TRUE;
		}

		if (!err) {
			csa->csa.mode = csa_ie->mode;
			csa->csa.count = csa_ie->count;
			csa->csa.chspec = wlc_ht_chanspec(wlc, csa_ie->channel, extch);
			csa->csa.reg = 0;
		}
	}

	/* Should reset the csa.count back to zero if csa_ie not found */
	if (!csa_ie_found && csa->csa.count) {
		WL_ASSOC(("wl%d.%d: %s: no csa ie found, reset csa.count %d to 0\n",
		          wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__, csa->csa.count));
		csa->csa.count = 0;
	}

	return (csa_ie_found);
}
#endif	/* STA */

/* Decode the WMM 2.1.1 QoS Info field, as sent by WMM STA, and save in scb */
void
wlc_qosinfo_update(struct scb *scb, uint8 qosinfo)
{
	/* Nybble swap; QoS Info bits are in backward order from AC bitmap */
	static const ac_bitmap_t qi_bitmap_to_ac_bitmap[16] = {
		0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15
	};
	/* Max USP Length field decoding (WMM 2.2.1) */
	static const uint16 maxsp[4] = {
		0xfff, 2, 4, 6
	};

	scb->apsd.maxsplen =
	        maxsp[(qosinfo & WME_QI_STA_MAXSPLEN_MASK) >> WME_QI_STA_MAXSPLEN_SHIFT];

	/* ACs negotiated to be APSD-enabled during association. */
	scb->apsd.ac_defl = qi_bitmap_to_ac_bitmap[qosinfo & WME_QI_STA_APSD_ALL_MASK];

	/* Initial config; can be updated by TSPECs, and revert back to ac_defl on DELTS. */
	scb->apsd.ac_trig = scb->apsd.ac_defl;
	scb->apsd.ac_delv = scb->apsd.ac_defl;
}

/* This function should be called only when receiving mgmt packets.
 * The channel returned will always be a 20MHz channel.
 */
static uint16
wlc_recv_mgmt_rx_channel_get(wlc_d11rxhdr_t *wrxh)
{
	uint16 channel;

	channel = WLC_RX_CHANNEL(&wrxh->rxhdr);
	/* This tells us that we received a 20MHz packet on a 40MHz channel */
	if (WLC_RX_CHAN_IS_BW40(&wrxh->rxhdr)) {
		/* channel reported by WLC_RX_CHANNEL() macro will be the 40MHz channel.
		 * Since we know if we're in this function, the packet was received on
		 * the control channel, we need to find which sideband is cntrl channel
		 * and adjust the channel value to reflect the true RX channel.
		 */
		if (wrxh->rxhdr.PhyRxStatus_0 & PRXS0_RXANT_UPSUBBAND) {
			channel = UPPER_20_SB(channel);
		}
		else {
			channel = LOWER_20_SB(channel);
		}
	}

	return (channel);
}

/* This function is called only when receiving mgmt packets.
 * The assumption made in this function is that the received packet is always on 20Mhz channel.
 * This assumption holds as long as we only call this function when receiving mgmt packets.
 */
void
wlc_recv_prep_event_rx_frame_data(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, uint8 *plcp,
                             wl_event_rx_frame_data_t *rxframe_data)
{
	uint16 channel;
	uint32 tsf, rate;
	int rssi;

	bzero(rxframe_data, sizeof(*rxframe_data));
	rxframe_data->version = hton16(BCM_RX_FRAME_DATA_VERSION);
	channel = wlc_recv_mgmt_rx_channel_get(wrxh);
	channel = CH20MHZ_CHSPEC(channel);
	rxframe_data->channel = hton16(channel);
	rssi = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);
	rxframe_data->rssi = hton32(rssi);
	tsf = wlc_recover_tsf32(wlc, wrxh);
	rxframe_data->mactime = hton32(tsf);
	rate = wlc_recv_compute_rspec(wrxh, plcp);
	rxframe_data->rate = hton32(rate);
}

/* Action Frame: byte 0: Category; byte 1: Action field */
static void
wlc_recv_mgmtact(wlc_info_t *wlc, struct scb *scb, struct dot11_management_header *hdr,
                 uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh, uint8 *plcp)
{
	uint action_category;
	uint action_id = 0;
	wlc_bsscfg_t *bsscfg = NULL;
	int8 rssi;
	ratespec_t rspec;
#if defined(WLP2P) && defined(BCMDBG)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif

	rssi = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);
	rspec = wlc_recv_compute_rspec(wrxh, plcp);

	if (body_len < 1) {
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);
		return;
	}

	action_category = body[DOT11_ACTION_CAT_OFF];
	if (body_len >= DOT11_ACTION_HDR_LEN)
		action_id = body[DOT11_ACTION_ACT_OFF];

#if defined(WLP2P) && defined(BCMDBG)
	WL_P2P(("wl%d: action frame received from %s on channel %d, "
	        "seqnum %d, action_actegory %d, action_id %d\n",
	        wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf), WLC_RX_CHANNEL(&wrxh->rxhdr),
	        (ltoh16(hdr->seq) >> SEQNUM_SHIFT), action_category, action_id));
#endif


	/* bsscfg is looked up mainly for sending event, use it otherwise with caution! */
	if (scb != NULL) {
		bsscfg = SCB_BSSCFG(scb);
		ASSERT(bsscfg != NULL);
	}
	else if ((bsscfg = wlc_bsscfg_find_by_bssid(wlc, &hdr->bssid)) != NULL ||
	         (bsscfg = wlc_bsscfg_find_by_hwaddr(wlc, &hdr->da)) != NULL) {
		;	/* empty */
	}
#if defined(BCM_DCS) && defined(AP)
	if (action_category == DOT11_ACTION_CAT_VS && wlc->ap->dcs_enabled)
		wlc_bss_mac_event(wlc, bsscfg, WLC_E_DCS_REQUEST, &hdr->sa, 0, 0, 0,
		                  body, body_len);
#endif /* BCM_DCS && AP */
	/* Send the action frame to the host */
	if ((action_category == DOT11_ACTION_CAT_PUBLIC) ||
	    (action_category == DOT11_ACTION_CAT_VS)) {
		wlc_bss_mac_event(wlc, bsscfg, WLC_E_ACTION_FRAME, &hdr->sa, 0, 0, 0,
		                  body, body_len);
#ifndef MACOSX
		if (wlc_eventq_test_ind(wlc->eventq, WLC_E_ACTION_FRAME_RX))
#endif
		{
			wl_event_rx_frame_data_t rxframe_data;
			wlc_recv_prep_event_rx_frame_data(wlc, wrxh, plcp, &rxframe_data);
			wlc_bss_mac_rxframe_event(wlc, bsscfg, WLC_E_ACTION_FRAME_RX, &hdr->sa,
			                          0, 0, 0,
			                          body, body_len, &rxframe_data);
		}
	}

	switch (action_category) {
	case DOT11_ACTION_CAT_SPECT_MNG:
		/* Spectrum Management */
		if (!WL11H_ENAB(wlc))
			break;
		if (body_len < DOT11_ACTION_HDR_LEN)
			goto rxbadproto;
		wlc_recv_frameaction_specmgmt(action_id, wlc, hdr, body, body_len, rssi, rspec);
		break;
	case DOT11_ACTION_NOTIFICATION:
		/* WME Management Notification */
		if (!WME_ENAB(wlc->pub))
			break;
		if (body_len <
		    (int)(DOT11_MGMT_NOTIFICATION_LEN + WME_TSPEC_HDR_LEN + WME_TSPEC_LEN))
			goto rxbadproto;
		if (!CAC_ENAB(wlc->pub))
			break;
		wlc_frameaction_cac(action_id, wlc->cac, hdr, body, body_len);
		break;
#ifdef WLBA
	case DOT11_ACTION_CAT_BLOCKACK:
		/* BA management frames */
		if (!WLBA_ENAB(wlc->pub))
			break;
		wlc_frameaction_ba(wlc->bastate, scb, hdr, body, body_len);
		break;
#endif
	case DOT11_ACTION_CAT_VS:
		/* Vendor specific action frame */
		wlc_frameaction_vs(wlc, hdr, body, body_len);
		break;
#ifdef WL11K
	case DOT11_ACTION_CAT_RRM:
		if (!WL11K_ENAB(wlc->pub))
			break;
		if (body_len < DOT11_RM_ACTION_LEN)
			goto rxbadproto;
		wlc_frameaction_rrm(wlc->rrm_info, action_id, hdr, body, body_len, rssi, rspec);
		break;
#endif
#ifdef WLWNM
	case DOT11_ACTION_CAT_BSSMGMT:
		if (!WLWNM_ENAB(wlc->pub))
			break;
		if (body_len < DOT11_BSS_TRANS_REQ_LEN)
			goto rxbadproto;
		wlc_send_bssmgmt_response(wlc, &hdr->sa, wlc->cfg, body, body_len);
		break;
#endif
#ifdef STA
#ifdef WLFBT
	case DOT11_ACTION_CAT_FBT:
		if (WLFBT_ENAB(wlc->pub)) {
			WL_ASSOC(("wl%d: %s: FT_RES\n", WLCWLUNIT(wlc), __FUNCTION__));

			if (body_len < DOT11_FT_RES_FIXED_LEN)
				goto rxbadproto;

			wlc_ftresp_client(bsscfg, hdr, body, body_len);
		}
		break;
#endif /* WLFBT */
#endif /* STA */

#ifdef WL11N
	case DOT11_ACTION_CAT_HT:
		/* Process HT Management */
		if (!N_ENAB(wlc->pub))
			break;
		wlc_frameaction_ht(wlc, action_id, scb, hdr, body, body_len);
		break;
#endif /* WL11N */
	case DOT11_ACTION_CAT_PUBLIC:
		/* Public Management */
		wlc_frameaction_public(wlc, hdr, body, body_len, wrxh);
		break;
#ifdef MFP
	case DOT11_ACTION_CAT_SA_QUERY: {
		/* SA Query Management */
		if (scb == NULL)
			break;
		wlc_scb_sa_query(wlc, action_id, scb, hdr, body, body_len);
		break;
	}
#endif /* MFP */

	default:
#ifdef WLAMPDU
		/* AMPDU management frames */
		if ((action_category & DOT11_ACTION_CAT_MASK) == DOT11_ACTION_CAT_BLOCKACK) {
			/* Process BA */
			wlc_frameaction_ampdu(wlc->ampdu, scb, hdr, body, body_len);
			break;
		}
#endif
		if ((action_category & DOT11_ACTION_CAT_ERR_MASK) != 0) {
			break;
		}
		/* Unrecognized (or disabled) action category */
		wlc_send_action_err(wlc, hdr, body, body_len);
		break;
	}

	return;

rxbadproto:
	wlc_send_action_err(wlc, hdr, body, body_len);
	WLCNTINCR(wlc->pub->_cnt->rxbadproto);
}

#ifdef STA
/* Update beacon listen interval in shared memory */
void
wlc_bcn_li_upd(wlc_info_t *wlc)
{
	if (AP_ENAB(wlc->pub))
		return;

	wlc_roam_thresh_upd(wlc->bsscfg[0]);
	/* wake up every DTIM is the default */
	if (wlc->bcn_li_dtim == 1)
		wlc_write_shm(wlc, M_BCN_LI, 0);
	else
		wlc_write_shm(wlc, M_BCN_LI, (wlc->bcn_li_dtim << 8) | wlc->bcn_li_bcn);
}

static void
wlc_recv_PSpoll_resp(wlc_bsscfg_t *cfg, uint16 fc)
{
	wlc_info_t *wlc = cfg->wlc;

	/* If there's more, send another PS-Poll */
	if (fc & FC_MOREDATA) {
		if (wlc_sendpspoll(wlc, cfg) == FALSE) {
			WL_ERROR(("wl%d: FC_MOREDATA: wlc_sendpspoll() failed\n",
			          wlc->pub->unit));
		}
		return;
	}

	/* Done, let the core go back to sleep */
	wlc_set_pspoll(cfg, FALSE);
}
#endif /* STA */

#ifdef WLPROBRESP_SW
static void
wlc_send_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
	struct ether_addr *da)
{
	void *p;
	uint8 *pbody;
	int len = BCN_TMPL_LEN;

	ASSERT(bsscfg != NULL);

	ASSERT(wlc->pub->up);

	/* build response and send */
	if ((p = wlc_frame_get_mgmt(wlc, FC_PROBE_RESP, da, &bsscfg->cur_etheraddr,
	                            &bsscfg->BSSID, len, &pbody)) == NULL) {
		WL_ERROR(("wl%d.%d: %s: wlc_frame_get_mgmt failed\n",
			wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__));
		return;
	}

	/* Generate probe response body */
	wlc_bcn_prb_body(wlc, FC_PROBE_RESP, bsscfg, pbody, &len, FALSE);
	PKTSETLEN(wlc->osh, p, len + DOT11_MGMT_HDR_LEN);

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, NULL);
}

#ifdef WL11U
static bool
wlc_check_probe_req_iw(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bcm_tlv_t *iw)
{
	bool sendProbeResp = TRUE;
	uint8 ap_iw_len;
	(void)wlc;

	if (cfg->iw_ie == NULL)
		return sendProbeResp;

	ap_iw_len = cfg->iw_ie[TLV_LEN_OFF];
	if (iw && iw->len && ap_iw_len) {
		uint8 sta_ant = (iw->data[0] & 0x0F);
		uint8 ap_ant = (cfg->iw_ie[2] & 0x0F);
		if ((sta_ant != 0x0F) && (ap_ant != 0x0F) && (sta_ant != ap_ant)) {
			sendProbeResp = FALSE;
		} else if ((iw->len > ETHER_ADDR_LEN) && (ap_iw_len > ETHER_ADDR_LEN)) {
			uint8 *hessid = (iw->len >= 9) ? (&iw->data[3]) : (&iw->data[1]);
			uint8 *hessid_ap = (ap_iw_len >= 9) ? (&cfg->iw_ie[5]) : (&cfg->iw_ie[3]);
			if ((!ETHER_ISBCAST(hessid)) && (!ETHER_ISBCAST(hessid_ap)) &&
				bcmp(hessid, hessid_ap, ETHER_ADDR_LEN))
					sendProbeResp = FALSE;
		}
	}
	return sendProbeResp;
}
#endif /* WL11U */
#endif /* WLPROBRESP_SW */

static void
wlc_recvctl(wlc_info_t *wlc, osl_t *osh, wlc_d11rxhdr_t *wrxh, void *p)
{
	struct dot11_management_header *hdr;
	void *wl;
	int len_mpdu, body_len, htc_len;
	uint8 *plcp, *body;
	struct scb *scb;
	uint16 fc, ft, fk;
	uint16 reason;
	bool htc = FALSE;
	bool multi;
	bool tome = FALSE;
	bool short_preamble;
	/* - bsscfg_current is the bsscfg whose BSSID matches the incoming frame's BSSID
	 * - bsscfg_target is the bsscfg whose target_bss->BSSID matches the incoming frame's
	 *   BSSID
	 * - bsscfg_hwaddr is the first bsscfg whose cur_etheraddr matches the incoming
	 *   frame's DA
	 */
	wlc_bsscfg_t *bsscfg_current = NULL, *bsscfg_target = NULL, *bsscfg_hwaddr = NULL;
	/* bsscfg is a summary pointer whose value is equal to either bsscfg_current
	 * or bsscfg_target.
	 * - check bsscfg before directly reference it in cases where bsscfg_current
	 *   and bsscfg_target don't matter
	 * - check bsscfg_current and then reference bsscfg in cases where bsscfg_current
	 *   is interested
	 * - check bsscfg_target and then reference bsscfg in cases where bsscfg_target
	 *   is interested
	 */
	wlc_bsscfg_t *bsscfg = NULL;
	int rx_bandunit;
#if defined(BCMDBG) || defined(BCMDBG_ERR) || defined(WLMSG_ASSOC) || defined(WLEXTLOG) \
	|| defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif
#if defined(BCMDBG) || defined(WLMSG_ASSOC)
	char bss_buf[ETHER_ADDR_STR_LEN];
#endif

	WL_TRACE(("wl%d: wlc_recvctl\n", wlc->pub->unit));

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		wlc_lmac_recvctl(wlc->lmac_info, wlc->osh, wrxh, p);
		return;
	}
#endif

	wl = wlc->wl;


	plcp = PKTDATA(osh, p);
	hdr = (struct dot11_management_header*)(plcp + D11_PHY_HDR_LEN);
	ASSERT(ISALIGNED((uintptr)hdr, sizeof(uint16)));
#if defined(BCMDBG) || defined(BCMDBG_ERR) || defined(WLMSG_ASSOC) || defined(WLEXTLOG) \
	|| defined(WLMSG_INFORM)
	bcm_ether_ntoa(&hdr->sa, eabuf);
#endif /* BCMDBG || BCMDBG_ERR || WLMSG_ASSOC */

	fc = ltoh16(hdr->fc);
	ft = FC_TYPE(fc);
	fk = (fc & FC_KIND_MASK);
#ifdef WL11N
	htc = ((wrxh->rxhdr.PhyRxStatus_0 & PRXS0_FT_MASK) == PRXS0_PREN) &&
	       (fc & FC_ORDER) && (ft == FC_TYPE_MNG);
#endif
	ASSERT((ft == FC_TYPE_CTL) || (ft == FC_TYPE_MNG));
	short_preamble = ((wrxh->rxhdr.PhyRxStatus_0 & PRXS0_SHORTH) != 0);

	/* mac header+body length, exclude CRC and plcp header */
	len_mpdu = PKTLEN(osh, p) - D11_PHY_HDR_LEN - DOT11_FCS_LEN;

	/* check for runts */
	htc_len = htc ? DOT11_HTC_LEN : 0;
	if (((ft == FC_TYPE_MNG) && (len_mpdu < (DOT11_MGMT_HDR_LEN + htc_len))) ||
	    (((fk == FC_PS_POLL) || (fk == FC_BLOCKACK_REQ) || (fk == FC_BLOCKACK)) &&
	     (len_mpdu < DOT11_CTL_HDR_LEN))) {
		WLCNTINCR(wlc->pub->_cnt->rxrunt);
		goto toss;
	}

	multi = ETHER_ISMULTI(&hdr->da);

	/* Is this unicast sent to me? */
	if (!multi) {
		bsscfg_hwaddr = wlc_bsscfg_find_by_hwaddr(wlc, &hdr->da);
		tome = bsscfg_hwaddr != NULL;
	}

	if (ft == FC_TYPE_MNG) {
		/* Is this in our BSS? */
		bsscfg = bsscfg_current = wlc_bsscfg_find_by_bssid(wlc, &hdr->bssid);

		/* Is this in the BSS we are associating to? */
		if (bsscfg == NULL) {
			bsscfg = bsscfg_target = wlc_bsscfg_find_by_target_bssid(wlc, &hdr->bssid);
		}
	}

	if (MONITOR_ENAB(wlc) || PROMISC_ENAB(wlc->pub)) {

		/* In monitor or promiscuous mode
		 * don't continue processing packets that aren't for us.
		 */

		/* ctl pkts: only handle PS-Poll/BAR/BA, must be unicast */
		if ((fk == FC_PS_POLL || fk == FC_BLOCKACK_REQ || fk == FC_BLOCKACK) &&
		    tome) {
			/* accept */
		}
		/* continue to process Bcns or Probe Resp, since we are normally promisc to these */
		else if (fk == FC_BEACON || fk == FC_PROBE_RESP) {
			/* accept */
		}
		/* Management frames can match unicast DA or
		 * broadcast DA with matching BSSID or broadcast BSSID
		 */
		else if ((ft == FC_TYPE_MNG) &&
		         (tome || (ETHER_ISBCAST(&hdr->da) &&
		                   (bsscfg != NULL || ETHER_ISBCAST(&hdr->bssid))))) {
			/* accept */
		}
		/* Toss otherwise */
		else
			goto toss;
	} else {
		/* a race window exists while changing the RX MAC addr match registers where
		 * we may receive a fame that does not have our MAC address
		 */
		if (!multi && (!tome ||
		               /* In MBSS environment also allow frames sent to us but
				* w/o a BSSID we know about, i.e, DEAUTH frame from WDS
				* peer using it's AP's hwaddr as BSSID when key is out
				* of sync.
				*/
		               (MBSS_ENAB(wlc->pub) && ft == FC_TYPE_MNG &&
		                bsscfg == NULL && bsscfg_hwaddr == NULL))) {
			WLCNTINCR(wlc->pub->_cnt->rxbadda);
			goto toss;
		}
	}

	if (!MONITOR_ENAB(wlc)) {
		wlc_bsscfg_t *cfg = bsscfg ? bsscfg : wlc->cfg;
		if (WLC_SENDUP_MGMT_ENAB(cfg))
			wlc_monitor(wlc, wrxh, p, cfg->wlcif);
	}

	/* CTL Frames with missing a2 need to be tossed, else scbfind
	 * will attempt to find SCB for them
	 */
	if (ft == FC_TYPE_CTL &&
	    !(fk == FC_CTS || fk == FC_ACK) &&
	    (ETHER_ISNULLADDR(&hdr->sa) || ETHER_ISMULTI(&hdr->sa))) {
		goto toss;
	}

	/* strip off CRC and plcp */
	PKTPULL(osh, p, D11_PHY_HDR_LEN);
	PKTSETLEN(osh, p, len_mpdu);

	WLCNTINCR(wlc->pub->_cnt->rxctl);

	/* MAC is promisc wrt beacons and probe responses, trace other packets */
	if ((fk != FC_PROBE_RESP) && (fk != FC_PROBE_REQ) && (fk != FC_BEACON)) {
		WL_PRHDRS(wlc, "rxpkt hdr (ctrl/mgmt)", plcp, NULL, wrxh, len_mpdu + D11_PHY_HDR_LEN
			+ DOT11_FCS_LEN);
		WL_PRPKT("rxpkt (ctrl/mgmt)", (uchar*)plcp, len_mpdu + D11_PHY_HDR_LEN
			+ DOT11_FCS_LEN);
	}

	body_len = PKTLEN(osh, p);	/* w/o 4 bytes CRC */
	if (wlc_recvfilter(wlc, (struct dot11_header *)hdr, wrxh, &scb, body_len)) {
		WLCNTINCR(wlc->pub->_cnt->rxfilter);
		goto toss;
	}

	/* Update scb used as we just received a control frame from the STA */
	if (scb)
		scb->used = wlc->pub->now;

	/* a. ctl pkts, we only process PS_POLL/BAR/BA, others are handled in ucode */
	if (ft == FC_TYPE_CTL) {

		/* set pointer to frame body and set frame body length */
		body = (uchar*)PKTPULL(osh, p, sizeof(struct dot11_ctl_header));
		if (htc)
			body = (uchar*)PKTPULL(osh, p, DOT11_HTC_LEN);
		body_len = PKTLEN(osh, p);	/* w/o 4 bytes CRC */

		if (fk == FC_PS_POLL) {
			ASSERT(scb != NULL);
			if (BSSCFG_AP(scb->bsscfg) && SCB_PS(scb))
				wlc_apps_send_psp_response(wlc, scb, fc);
		}
		else
#ifdef WLAMPDU
		if (AMPDU_ENAB(wlc->pub) &&
		    ((fk == FC_BLOCKACK_REQ) || (fk == FC_BLOCKACK))) {
			wlc_ampdu_recv_ctl(wlc->ampdu, scb, body, body_len, fk);
		}
		else
#endif
#ifdef WLBA
		if (WLBA_ENAB(wlc->pub) &&
		    ((fk == FC_BLOCKACK_REQ) || (fk == FC_BLOCKACK))) {
			wlc_ba_recv_ctl(wlc->bastate, scb, body, body_len, fk);
		}
		else
#endif
		{
			WL_ERROR(("wl%d: wlc_recvctl: unhandled frametype (0x%x)\n",
			          wlc->pub->unit, fc));
		}
		goto toss;
	}

	/* b. mgmt pkts, ATIM, probe_request and beacon are handled in ucode first */

	rx_bandunit = CHANNEL_BANDUNIT(wlc, WLC_RX_CHANNEL(&wrxh->rxhdr));

	/* Detect and discard duplicates */
	if (!multi) {
		uint16 seqctl = ltoh16(hdr->seq);

		if (!scb)
			scb = wlc_scbfindband(wlc, &hdr->sa, rx_bandunit);
		if ((fc & FC_RETRY) &&
		    scb != NULL &&
		    scb->seqctl_nonqos == seqctl) {
			WL_TRACE(("wl%d: %s: discarding duplicate MMPDU seq %04x from %s\n",
			          wlc->pub->unit, __FUNCTION__, seqctl, eabuf));
			WLCNTINCR(wlc->pub->_cnt->rxdup);
			goto toss;
		}

		/* Update cached seqctl */
		if (scb != NULL)
			scb->seqctl_nonqos = seqctl;

		/* Duplicate detection based on sa w/o creating an SCB which is heavy on memory */
		if (!scb) {
			uint8 dup_idx = 0;
			struct sa_seqctl *ea_seq = NULL;

			/* Look up the table for if matching ea already exists */
			for (; dup_idx <= wlc->ctl_dup_det_idx; dup_idx++) {
				/* Reached empty entry -- bail out */
				if (ETHER_ISNULLADDR(&wlc->ctl_dup_det[dup_idx].sa))
					break;

				/* Match found */
				if (!bcmp(hdr->sa.octet, wlc->ctl_dup_det[dup_idx].sa.octet,
				          ETHER_ADDR_LEN)) {
					ea_seq = &wlc->ctl_dup_det[dup_idx];
					break;
				}
			}

			if ((fc & FC_RETRY) &&
			    ea_seq != NULL &&
			    ea_seq->seqctl_nonqos == seqctl) {
				WL_TRACE(("wl%d: %s: discarding duplicate MMPDU using ea seq %04x"
				          " from %s\n",
				           wlc->pub->unit, __FUNCTION__, seqctl, eabuf));
				WLCNTINCR(wlc->pub->_cnt->rxdup);
				goto toss;
			}

			/* Create the entry since one didn't exist */
			if (!ea_seq) {
				ea_seq = &wlc->ctl_dup_det[wlc->ctl_dup_det_idx++];
				bcopy((const char*)&hdr->sa, (char*)&ea_seq->sa, ETHER_ADDR_LEN);
				wlc->ctl_dup_det_idx %= SA_SEQCTL_SIZE;
			}
			ea_seq->seqctl_nonqos = seqctl;
		}
	}

#ifdef STA
	/* Check if this was response to PSpoll sent by associated AP to STA */
	if (tome &&
	    bsscfg_current != NULL && BSSCFG_STA(bsscfg) &&
	    bsscfg->pm->PSpoll)
	        wlc_recv_PSpoll_resp(bsscfg, fc);
#endif

	/* set pointer to frame body and set frame body length */
	body = (uchar*)PKTPULL(osh, p, sizeof(struct dot11_management_header));
	if (htc)
		body = (uchar*)PKTPULL(osh, p, DOT11_HTC_LEN);
	body_len = PKTLEN(osh, p);	/* w/o 4 bytes CRC */


	/* deal with encrypted frame */
	if (fc & FC_WEP) {
		if (body_len < WLC_WEP_IV_SIZE + WLC_WEP_ICV_SIZE) {
			WLCNTINCR(wlc->pub->_cnt->rxrunt);
			goto toss;
		}
#ifndef MFP
		if (fk != FC_AUTH) {
			WLCNTINCR(wlc->pub->_cnt->rxundec);
			goto toss;
		}
		/*
		   decryption error is now checked in authresp_ap so we can
		   check if it was supposed to use a different key for another ssid.
		*/
#endif /* !MFP */
	}

#ifdef MFP
	/* Following 802.11REVmb-2.04 clause 8.7.2.3a closely.  covers all the cases. */
	/* MFP: case table for unicast frames */
	/*
				Have Key			No Key
	-----------------------------------------------------------------------------------
				Encrpted      Not Encrypted     Encrypted	Not Encrypted
	deauth or disassoc	ok		toss		toss		ok
	action robust		ok		toss		toss		toss
	action non-robust	toss		ok		toss		ok

	so the psudo code logic:
		if (enc) {
			if (have key) {
				decrypt frame
				if (action && !robust)
					toss
				else
					ok
			else
				toss
		} else {
			if ((have key) && (deauth or disassoc))
				toss
			if (action robust)
				toss
		}
	*/
	if (SCB_MFP(scb) && bsscfg && IS_WPA2_AUTH(bsscfg->WPA_auth) &&
		(fk == FC_DEAUTH || fk == FC_DISASSOC || fk == FC_ACTION)) {

		WL_WSEC(("wl%d: %s: MFP: deauth/disassoc/action management frame from %s,"
			"type = 0x%02x, subtype = 0x%02x\n",
			WLCWLUNIT(wlc), __FUNCTION__, bcm_ether_ntoa(&hdr->sa, bss_buf),
			FC_TYPE(fc), FC_SUBTYPE(fc)));

		/* MFP enabled, unprotected management frames NOT allowed */
		if (!ETHER_ISMULTI(&hdr->da)) {
			/* unicast */
			if (fc & FC_WEP) {
				if (scb->key) {
					/* have key and encrypted */
					WL_WSEC(("wl%d: %s: MFP: received protected unicast"
						" mgmt frame from %s, decrypting\n",
						WLCWLUNIT(wlc), __FUNCTION__,
						bcm_ether_ntoa(&hdr->sa, bss_buf)));
					if (wlc_mfp_rx_ucast(wlc, &wrxh->rxhdr, hdr, p, scb)) {
						WL_WSEC(("wl%d: %s: MFP: decryption failed for"
							" protected unicast mgmt frame from %s,"
							" toss\n",
							WLCWLUNIT(wlc), __FUNCTION__,
							bcm_ether_ntoa(&hdr->sa, bss_buf)));
						WLCNTINCR(wlc->pub->_cnt->rxundec);
						goto toss;
					}
					body = (uchar*)PKTDATA(osh, p);
					body_len = PKTLEN(osh, p);
					if ((fk == FC_ACTION) && !IS_ROBUSTABLE_CAT(body[0])) {
						WL_WSEC(("wl%d: %s: MFP: received encrypted"
							" non-robust action frame from %s, toss\n",
							WLCWLUNIT(wlc), __FUNCTION__,
							bcm_ether_ntoa(&hdr->sa, bss_buf)));
						WLCNTINCR(wlc->pub->_cnt->rxbadproto);
						goto toss;
					}
				}
				else {
					WL_WSEC(("wl%d: %s: MFP: have no key, discarding"
						" protected mgmt frame from %s, toss\n",
						WLCWLUNIT(wlc), __FUNCTION__,
						bcm_ether_ntoa(&hdr->sa, bss_buf)));
					WLCNTINCR(wlc->pub->_cnt->rxundec);
					goto toss;
				}
			} else {
				if (scb->key && (fk == FC_DEAUTH || fk == FC_DISASSOC)) {
					/* MFP: have key and unencrypted deauth or disassoc */
					WL_WSEC(("wl%d: %s: MFP: have key, discarding"
						" unprotected mgmt frame from %s, start SA Query\n",
						WLCWLUNIT(wlc), __FUNCTION__,
						bcm_ether_ntoa(&hdr->sa, bss_buf)));
					WLCNTINCR(wlc->pub->_cnt->wepexcluded);
					goto toss;
				}
				if (fk == FC_ACTION) {
					if (body_len == 0) {
						WLCNTINCR(wlc->pub->_cnt->rxrunt);
						goto toss;
					}
					body = (uchar*)PKTDATA(osh, p);
					/* MFP: if IS_ROBUSTABLE_CAT() toss */
					if (IS_ROBUSTABLE_CAT(body[0])) {
						WL_WSEC(("wl%d: %s: MFP: received robust action"
							" frame unprotected from %s, toss\n",
							WLCWLUNIT(wlc), __FUNCTION__,
							bcm_ether_ntoa(&hdr->sa, bss_buf)));
						WLCNTINCR(wlc->pub->_cnt->rxbadproto);
						goto toss;
					}
				}
			}
		} else {
				/* bcast/mcast */
				body = (uchar*)PKTDATA(osh, p);
				if (!wlc_mfp_rx_mcast(&bsscfg->igtk, &wrxh->rxhdr, hdr, body,
					body_len)) {
					WL_ERROR(("wl%d: %s: MFP: decryption failed for"
						" protected bcast/mcast mgmt frame from %s,"
						" toss\n",
						WLCWLUNIT(wlc), __FUNCTION__,
						bcm_ether_ntoa(&hdr->sa, bss_buf)));
					WLCNTINCR(wlc->pub->_cnt->rxundec);
					goto toss;
				}
				WL_ERROR(("wl%d: %s: MFP: decryption success"
					" protected multicast mgmt frame from %s\n",
					WLCWLUNIT(wlc), __FUNCTION__,
					bcm_ether_ntoa(&hdr->sa, bss_buf)));
		}
	} else

	/* only auth  mgmt frame seq 3  can be encrypted(WEP) */
	/* deal with encrypted frame */
	if (fc & FC_WEP) {

		if (fk != FC_AUTH) {
			WLCNTINCR(wlc->pub->_cnt->rxundec);
			goto toss;
		}
		/*
		   decryption error is now checked in authresp_ap so we can
		   check if it was supposed to use a different key for another ssid.
		*/
	}
#endif /* MFP */

	switch (fk) {

	case FC_AUTH:
		WL_MBSS(("RX: Auth pkt on BSS %s\n", bcm_ether_ntoa(&hdr->bssid, bss_buf)));

		if (body_len < DOT11_AUTH_FIXED_LEN)
			goto rxbadproto;

		if (bsscfg == NULL) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_AUTH: no bsscfg for BSS %s\n",
			          WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;  /* we couldn't match the incoming frame to a BSS config */
		}

		/* Is this request for an AP config or a STA config */
		if (BSSCFG_AP(bsscfg) && bsscfg->up) {
#ifdef MFP
			if (SCB_MFP(scb) && SCB_AUTHENTICATED(scb)) {
				/* send auth packet */
				wlc_sendauth(bsscfg, &scb->ea, &bsscfg->target_bss->BSSID, scb,
					DOT11_OPEN_SYSTEM, 2, DOT11_SC_SUCCESS,
					(WSEC_SCB_KEY_VALID(scb)? scb->key : NULL), NULL,
					DOT11_CAP_SHORT);
			}
			else
#endif /* MFP */			
			wlc_ap_authresp(wlc->ap, bsscfg, hdr, (struct dot11_auth *)body, body_len,
				short_preamble, (wrxh->rxhdr.RxStatus1 & RXS_DECATMPT));
		} else if (BSSCFG_STA(bsscfg) && (wlc->default_bss->infra)) {
#ifdef STA
			wlc_authresp_client(bsscfg, hdr, body, body_len, short_preamble);
#endif
		} else {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_AUTH: unknown bsscfg _ap %d infra %d\n",
			          WLCWLUNIT(wlc), bsscfg->_ap, wlc->default_bss->infra));
		}
		break;

#ifdef STA
	case FC_ASSOC_RESP:
	case FC_REASSOC_RESP:

		WL_MBSS(("RX: (Re)AssocResp pkt on BSS %s\n",
		         bcm_ether_ntoa(&hdr->bssid, bss_buf)));

		if (body_len < DOT11_ASSOC_RESP_FIXED_LEN)
			goto rxbadproto;

		if (bsscfg == NULL) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_(RE)ASSOC_RESP: no bsscfg for BSS %s\n",
			          WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;  /* we couldn't match the incoming frame to a BSS config */
		}
		if (!BSSCFG_STA(bsscfg)) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_(RE)ASSOC_RESP: bsscfg for BSS %s is an "
			          "AP\n", WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;
		}

		wlc_assocresp_client(bsscfg, hdr, body, body_len, scb);
		break;
#endif /* STA */

	case FC_PROBE_REQ:
		/* forward probe requests to higher level  */
#ifdef WLPROBRESP_SW
		{
			bcm_tlv_t *ssid;
#ifdef WL11U
			bcm_tlv_t *iw;
			iw = bcm_parse_tlvs(body, body_len, DOT11_MNG_INTERWORKING_ID);
#endif /* WL11U */
			if ((ssid = bcm_parse_tlvs(body, body_len, DOT11_MNG_SSID_ID)) != NULL) {
				wlc_bsscfg_t *cfg;
				int idx;
				if (bsscfg || bsscfg_hwaddr) {
					cfg = bsscfg ? bsscfg : bsscfg_hwaddr;
					if (BSSCFG_AP(cfg) && cfg->up && cfg->enable &&
						((bsscfg == bsscfg_hwaddr) ||
						ETHER_ISBCAST(&hdr->da) ||
						ETHER_ISBCAST(&hdr->bssid)) &&
						((ssid->len == 0) ||
						((ssid->len == cfg->SSID_len) &&
						(bcmp(ssid->data, cfg->SSID, ssid->len) == 0)))) {
#ifdef WL11U
						if (wlc_check_probe_req_iw(wlc, cfg, iw))
#endif /* WL11U */
							wlc_send_probe_resp(wlc, cfg, &hdr->sa);
					}
				} else if (ETHER_ISBCAST(&hdr->da) && ETHER_ISBCAST(&hdr->bssid)) {
					FOREACH_UP_AP(wlc, idx, cfg) {
						if (cfg->enable && ((ssid->len == 0) ||
							((ssid->len == cfg->SSID_len) &&
							(bcmp(ssid->data, cfg->SSID,
							ssid->len) == 0)))) {
#ifdef WL11U
							if (!wlc_check_probe_req_iw(wlc, cfg, iw))
								continue;
#endif /* WL11U */
							wlc_send_probe_resp(wlc, cfg, &hdr->sa);
						}
					}
				}
			}
		}
#endif /* WLPROBRESP_SW */
		if (wlc_eventq_test_ind(wlc->eventq, WLC_E_PROBREQ_MSG))
			wlc_mac_event(wlc, WLC_E_PROBREQ_MSG, &hdr->sa, 0, 0, 0, (char *)hdr,
			              body_len + DOT11_MGMT_HDR_LEN);

		/* Probe responses are handled thru the PRQ Fifo */


#ifdef WLP2P
#if defined(BCMDBG)
		WL_TMP(("wl%d: probe req frame received from %s on channel %d, seqnum %d\n",
		        wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf),
		        WLC_RX_CHANNEL(&wrxh->rxhdr), (ltoh16(hdr->seq) >> SEQNUM_SHIFT)));
#endif
		if (P2P_ENAB(wlc->pub))
			wlc_p2p_recv_process_prbreq(wlc->p2p, hdr, body, body_len, wrxh, plcp);
#endif /* WLP2P */

		break;

	case FC_PROBE_RESP: {
		WL_MBSS(("RX: Probe resp on BSS %s\n", bcm_ether_ntoa(&hdr->bssid, bss_buf)));
		if (body_len < DOT11_BCN_PRB_LEN)
			goto rxbadproto;

		/* if there is any restricted chanspec in the locale, convert the channel */
		/* receiving the probe_resp to active channel if needed */
		if (wlc_has_restricted_chanspec(wlc->cmi))
			wlc_convert_restricted_chanspec(wlc, bsscfg_current, wrxh,
				hdr, body, body_len);


#ifdef WLP2P
#if defined(BCMDBG)
		WL_P2P(("wl%d: probe resp frame received from %s on channel %d, seqnum %d\n",
		        wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf),
		        WLC_RX_CHANNEL(&wrxh->rxhdr), (ltoh16(hdr->seq) >> SEQNUM_SHIFT)));
#endif
		if (P2P_ENAB(wlc->pub))
			wlc_p2p_recv_process_prbresp(wlc->p2p, body, body_len);
#endif /* WLP2P */

		/* check for our probe responses:
		 * - must be a packet with our MAC addr
		 * (but if we're no longer scanning, ignore it)
		 */
		if (SCAN_IN_PROGRESS(wlc->scan) && tome)
			wlc_recv_scan_parse(wlc, wrxh, plcp, hdr, body, body_len);
#ifdef STA
#endif /* STA */
		break;
	}

	case FC_BEACON: {
		struct dot11_bcn_prb *bcn = (struct dot11_bcn_prb *)body;
#ifdef STA
		wlc_bsscfg_t *bsscfg_bcn;
#endif

		ASSERT(ISALIGNED((uintptr)body, sizeof(uint16)));

		if (body_len < DOT11_BCN_PRB_LEN)
			goto rxbadproto;

#ifdef STA
#if defined(BCMDBG) || defined(WLMSG_PRPKT)
		if (WL_PRPKT_ON() &&
		    bsscfg != NULL) {
			printf("\nrxpkt (beacon)\n");
			wlc_print_bcn_prb((uint8*)plcp, len_mpdu + D11_PHY_HDR_LEN);
		}
#ifdef DEBUG_TBTT
		if (WL_INFORM_ON() && bsscfg_current != NULL) {
			uint32 bcn_tsf_h, bcn_tsf_l, rx_tsf_l;
			uint32 bi;
			uint32 offset;
			uint32 rxstart2tsf;
			ratespec_t rx_rspec;

			bcn_tsf_l = ltoh32_ua(&bcn->timestamp[0]);
			bcn_tsf_h = ltoh32_ua(&bcn->timestamp[1]);

			rx_rspec = wlc_recv_compute_rspec(wrxh, plcp);
			rxstart2tsf = wlc_compute_bcn_payloadtsfoff(wlc, rx_rspec);
			rx_tsf_l = wlc_recover_tsf32(wlc, wrxh);

			WL_INFORM(("wl%d: RxTime 0x%04x RxTime32 0x%08x TSF Offset 0x%x "
				"local TSF 0x%08x Bcn TSF 0x%x:%08x Diff 0x%04x\n",
				wlc->pub->unit, (int)wrxh->rxhdr.RxTSFTime, rx_tsf_l,
				(int)rxstart2tsf,
				(int)(rx_tsf_l + rxstart2tsf), bcn_tsf_h, bcn_tsf_l,
				(int)((rx_tsf_l + rxstart2tsf) - bcn_tsf_l)));

			bi = ltoh16(bcn->beacon_interval);

			if (bi != 0) {	/* bad AP, skip division */
				offset = wlc_calc_tbtt_offset(bi, bcn_tsf_h, bcn_tsf_l);

				WL_INFORM(("BCN_INFO: seq 0x%x BCN_TSF 0x%08x:%08x OFFSET 0x%x "
					   "preTBTT 0x%x (tsf_l-preTBTT) 0x%x %s\n",
					   ltoh16(hdr->seq), bcn_tsf_h, bcn_tsf_l,
					   offset, wlc->prev_TBTT, (bcn_tsf_l - wlc->prev_TBTT),
					   wlc->bad_TBTT ? " badTBTT" : ""));
			}
		}
#endif /* DEBUG_TBTT */
#endif /* BCMDBG || WLMSG_PRPKT */
#endif /* STA */

		/* if there is any restricted chanspec in the locale,  convert the channel */
		/*  receiving the beacon to active channel if needed */
		if (wlc_has_restricted_chanspec(wlc->cmi))
			wlc_convert_restricted_chanspec(wlc, bsscfg_current, wrxh,
				hdr, body, body_len);

		wlc_recv_process_beacon(wlc, bsscfg_current, wrxh, plcp, hdr, body, body_len);

		if (SCAN_IN_PROGRESS(wlc->scan) ||
		    FALSE) {
			wlc_recv_scan_parse(wlc, wrxh, plcp, hdr, body, body_len);
		}

		/* If we get an AP beacon on a radar quiet channel, signal
		 * that the channel is temporarily clear for transmissions.
		 * On the 2G band, insist on [matching] DS_PARMS element.
		 */
		if ((ltoh16(bcn->capability) & DOT11_CAP_ESS) &&
		    !wlc_csa_quiet(wlc, body, body_len)) {
			uint8 chan;
			bcm_tlv_t *ds_params;

			chan = WLC_RX_CHANNEL(&wrxh->rxhdr);

			if (CHSPEC_BAND(WLC_CHAN2SPEC(chan)) == WL_CHANSPEC_BAND_2G) {
				ds_params = bcm_parse_tlvs(body + DOT11_BCN_PRB_LEN,
				                           body_len - DOT11_BCN_PRB_LEN,
				                           DOT11_MNG_DS_PARMS_ID);
				if ((ds_params && ds_params->len >= 1) &&
				    (ds_params->data[0] == chan) &&
				    (chan == CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC))) {
					wlc_scan_radar_clear(wlc->scan);
				}
			} else {
				if (chan == CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC)) {
					wlc_scan_radar_clear(wlc->scan);
				}
			}
		}

#ifdef STA
		/* See if we are waiting for this beacon to join a BSS/IBSS */
		if (((bsscfg_bcn = bsscfg_target) != NULL ||
		     (bsscfg_bcn = wlc_bsscfg_find_by_target_bssid(wlc, &hdr->bssid)) != NULL) &&
		    BSSCFG_STA(bsscfg_bcn)) {
			wlc_assoc_t *as = bsscfg_bcn->assoc;
			wlc_roam_t *roam = bsscfg_bcn->roam;
			bcm_tlv_t *ssid_ie =
			        bcm_parse_tlvs(body + DOT11_BCN_PRB_LEN,
			                       body_len - DOT11_BCN_PRB_LEN, DOT11_MNG_SSID_ID);

			if (as->state == AS_WAIT_RCV_BCN) {
				WL_ASSOC(("wl%d: JOIN: got the desired beacon...update TBTT...\n",
				          WLCWLUNIT(wlc)));
				wlc_join_complete(bsscfg_bcn, wrxh, plcp, bcn, body_len);
			} else if (ASSOC_RECREATE_ENAB(wlc->pub) &&
			           as->state == AS_RECREATE_WAIT_RCV_BCN) {
				WL_ASSOC(("wl%d: JOIN: RECREATE got the desired beacon...\n",
				          WLCWLUNIT(wlc)));
				wlc_join_recreate_complete(bsscfg_bcn, wrxh, plcp, bcn, body_len);
			}
			/* we need to mark whether we can piggyback roam scans on the
			 * periodic scans for this ESS
			 */
			if (bsscfg_bcn->BSS && roam->piggyback_enab &&
			    SCAN_IN_PROGRESS(wlc->scan)) {
				bool ssid_match = wlc_scan_ssid_match(wlc->scan, ssid_ie, TRUE);
				if (ssid_match && !roam->roam_scan_piggyback) {
					WL_ASSOC(("wl%d: JOIN: AP is broadcasting its SSID, will "
					          "use periodic scans as full roams scans\n",
					          wlc->pub->unit));
					roam->roam_scan_piggyback = TRUE;
				} else if (!ssid_match && roam->roam_scan_piggyback) {
					WL_ASSOC(("wl%d: JOIN: AP is not broadcasting its SSID, "
					          "not using periodic scans as full roams scans\n",
					          wlc->pub->unit));
					roam->roam_scan_piggyback = FALSE;
				}
			}
		}

		if (bsscfg_current != NULL &&
		    bsscfg->assoc->state == AS_SYNC_RCV_BCN) {
			WL_APSTA_UPDN(("wl%d: wlc_recvctl: got resync beacon, update TSF/TBTT\n",
			               wlc->pub->unit));
			wlc_tsf_adopt_bcn(bsscfg, wrxh, plcp, bcn);
			wlc_assoc_change_state(bsscfg, AS_IDLE);
			/* APSTA: complete any deferred AP bringup */
			if (AP_ENAB(wlc->pub))
				wlc_restart_ap(wlc->ap);
			/* update PM state for STA */
			else
				wlc_set_pmstate(bsscfg, bsscfg->pm->PMenabled);
		}
#endif /* STA */

		break;
	}

	case FC_DISASSOC:
		WL_MBSS(("RX: Disassoc on BSS %s\n", bcm_ether_ntoa(&hdr->bssid, bss_buf)));
		if (body_len < 2)
			goto rxbadproto;

		if (bsscfg == NULL) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_DISASSOC: no bsscfg for BSS %s\n",
			          WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;  /* we couldn't match the incoming frame to a BSS config */
		}

		reason = ltoh16(*(uint16*)body);

		wlc_smfstats_update(wlc, bsscfg, SMFS_TYPE_DISASSOC_RX, reason);

		/* wlc_recvfilter(): frame tossed if node not authenticated with us */
		ASSERT(scb && SCB_AUTHENTICATED(scb));

		WLC_EXTLOG(wlc, LOG_MODULE_ASSOC, FMTSTR_DISASSOC_ID,
		           WL_LOG_LEVEL_ERR, 0, reason, eabuf);

		if (BSSCFG_STA(bsscfg)) {
			wlc_scb_disassoc_cleanup(wlc, scb);

			if (!(scb->flags & SCB_MYAP)) {
				WL_ERROR(("wl%d: wlc_recvctl: STA DISASSOC from non-AP SCB %s\n",
					wlc->pub->unit, eabuf));
			}
#ifdef STA
			/* STA */
			WL_ASSOC(("wl%d: %s%s from %s (reason %d)\n", wlc->pub->unit,
				ETHER_ISBCAST(&hdr->da) ? "broadcast " : "",
				  "disassociation", eabuf, reason));
			if (SCB_ASSOCIATED(scb)) {
				wlc_scb_clearstatebit(scb, ASSOCIATED);
				if (!(scb->state & PENDING_ASSOC))
					wlc_disassoc_ind_complete(wlc, bsscfg, WLC_E_STATUS_SUCCESS,
						&hdr->sa, reason, 0, body, body_len);
			}


			/* allow STA to roam back to disassociating AP */
			if (bsscfg_current != NULL) {
				if (bsscfg->assoc->state != AS_IDLE)
					wlc_assoc_abort(bsscfg);

#ifdef WLP2P
				if (!BSS_P2P_ENAB(wlc, bsscfg))
#endif
					wlc_roamscan_start(bsscfg, WLC_E_REASON_DISASSOC);
			}
#endif /* STA */
		} else if (scb->bsscfg == bsscfg) { /* AP */
			/* Only clean up if this SCB is still pointing to the BSS config to
			 * which the packet was destined.
			 */
			wlc_scb_disassoc_cleanup(wlc, scb);

			if (SCB_ASSOCIATED(scb)) {
				WL_ASSOC(("DIASSOC: wl%d: %s disassociated (reason %d)\n",
				          wlc->pub->unit, eabuf, reason));
				/* return node to state 2 */
				wlc_scb_clearstatebit(scb, ASSOCIATED | AUTHORIZED);
				wlc_disassoc_ind_complete(wlc, bsscfg, WLC_E_STATUS_SUCCESS,
					&hdr->sa, reason, 0, body, body_len);
			} else {
				WL_ASSOC(("DIASSOC: wl%d: rcvd disassociation from unassociated "
				          "STA %s (reason %d)\n", wlc->pub->unit, eabuf, reason));
				wlc_scb_clearstatebit(scb, AUTHORIZED);
			}
		}
		break;

	case FC_DEAUTH: {
		wlc_bsscfg_t *bsscfg_deauth;

		WL_MBSS(("RX: Deauth on BSS %s\n", bcm_ether_ntoa(&hdr->bssid, bss_buf)));
		if (body_len < 2)
			goto rxbadproto;

		/* Allow it in case the frame is for us but w/o a BSSID that we know
		 * about, i.e, frame from WDS peer using it's AP's hwaddr as the BSSID.
		 */
		if ((bsscfg_deauth = bsscfg) == NULL &&
		    (bsscfg_deauth = bsscfg_hwaddr) == NULL) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_DEAUTH: no bsscfg for BSS %s\n",
			          WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;
		}

		reason = ltoh16(*(uint16*)body);

		if (bsscfg)
			wlc_smfstats_update(wlc, bsscfg, SMFS_TYPE_DEAUTH_RX, reason);

		if (!scb)
			scb = wlc_scbfindband(wlc, &hdr->sa, rx_bandunit);
		if (scb)
			wlc_scb_disassoc_cleanup(wlc, scb);

		WLC_EXTLOG(wlc, LOG_MODULE_ASSOC, FMTSTR_DEAUTH_ID,
		           WL_LOG_LEVEL_ERR, 0, reason, eabuf);

		if (BSSCFG_STA(bsscfg_deauth)) {
			if (scb && !(scb->flags & SCB_MYAP) && !SCB_IS_IBSS_PEER(scb)) {
				WL_ERROR(("wl%d: wlc_recvctl: STA DEAUTH from "
				          "non-AP SCB %s\n", wlc->pub->unit, eabuf));
			}
#ifdef STA
			/* STA */
			WL_ASSOC(("wl%d: %s%s from %s (reason %d)\n", wlc->pub->unit,
				ETHER_ISBCAST(&hdr->da) ? "broadcast " : "",
				  "deauthentication", eabuf, reason));
			if (scb) {
				wlc_scb_clearstatebit(scb, ASSOCIATED | AUTHORIZED);
				if (SCB_AUTHENTICATED(scb) || SCB_IS_IBSS_PEER(scb)) {
					wlc_scb_clearstatebit(scb, AUTHENTICATED);
					/* DEAUTH w/reason 13-22 is considered a 4-way handshake
					 * failure
					 */
					if (reason > 12 && reason < 23)
						WLCNTINCR(wlc->pub->_cnt->fourwayfail);
#ifdef WLEXTLOG
					if (reason == DOT11_RC_4WH_TIMEOUT) {
						WLC_EXTLOG(wlc, LOG_MODULE_ASSOC,
							FMTSTR_PWD_MISMATCH_ID,
							WL_LOG_LEVEL_ERR, 0, 0, NULL);
					}
#endif
#if defined(BCMSUP_PSK)
					if (bsscfg_deauth->sup_type == SUP_WPAPSK) {
						wlc_wpa_send_sup_status(bsscfg_deauth->sup,
						                      WLC_E_SUP_DEAUTH);
					}
#endif /* defined(BCMSUP_PSK) */
					if (!(scb->state & PENDING_AUTH))
						wlc_deauth_ind_complete(wlc, bsscfg_deauth,
							WLC_E_STATUS_SUCCESS,
							&hdr->sa, reason,
							(SCB_IS_IBSS_PEER(scb) ?
						         DOT11_BSSTYPE_INDEPENDENT :
						         DOT11_BSSTYPE_INFRASTRUCTURE),
						        body, body_len);

					SCB_UNSET_IBSS_PEER(scb);
				}
			}


			/* allow STA to roam back to deauthenticating AP */
			if (bsscfg_current != NULL && bsscfg->BSS) {
				/* do not abort roaming */
				if ((bsscfg->assoc->type != AS_ROAM) ||
				    (bsscfg->assoc->state < AS_SENT_ASSOC))  {
					if (bsscfg->assoc->state != AS_IDLE)
						wlc_assoc_abort(bsscfg);

#ifdef WLP2P
					if (!BSS_P2P_ENAB(wlc, bsscfg))
#endif
						wlc_roamscan_start(bsscfg, WLC_E_REASON_DEAUTH);
				}
			}
#endif /* STA */
		} else if ((scb != NULL) && (scb->bsscfg == bsscfg_deauth)) { /* AP */
			if (SCB_WDS(scb)) {
				WL_ASSOC(("wl%d: wlc_recvctl: FC_DEAUTH frame over WDS link %s\n",
				          WLCWLUNIT(wlc), eabuf));
				scb->flags &= ~SCB_WDS_LINKUP;
			}
			/* Only clean up if this SCB is still pointing to the BSS config to
			 * which the packet was destined.
			 */
			if (SCB_AUTHENTICATED(scb)) {
				WL_ASSOC(("wl%d: %s deauthenticated (reason %d)\n",
				          wlc->pub->unit, eabuf, reason));
				wlc_deauth_ind_complete(wlc, bsscfg_deauth, WLC_E_STATUS_SUCCESS,
					&hdr->sa, reason, 0, body, body_len);
				/* remove all known state on this node (deauthenticate it) */
				wlc_scbfree(wlc, scb);
			}
		}
		break;
	}

	case FC_ASSOC_REQ:
	case FC_REASSOC_REQ:
		WL_MBSS(("RX: (Re)Assoc on from %s on BSS %s\n", bcm_ether_ntoa(&hdr->sa, eabuf),
			bcm_ether_ntoa(&hdr->bssid, bss_buf)));
		if (body_len < 4)
			goto rxbadproto;

		if (bsscfg == NULL) {
			WL_ASSOC(("wl%d: wlc_recvctl: FC_(RE)ASSOC_REQ: no bsscfg for BSS %s\n",
			          WLCWLUNIT(wlc), bcm_ether_ntoa(&hdr->bssid, bss_buf)));
			break;
		}

		ASSERT(scb && SCB_AUTHENTICATED(scb));

		if (!bsscfg->up || !BSSCFG_AP(bsscfg))
			break;

		/* Check that this (re)associate is for us */
		if (!bcmp(hdr->bssid.octet, bsscfg->BSSID.octet, ETHER_ADDR_LEN))
			wlc_ap_process_assocreq(wlc->ap, bsscfg, hdr, body, body_len, scb,
				short_preamble);
		break;

	case FC_ACTION:
		wlc_recv_mgmtact(wlc, scb, hdr, body, body_len, wrxh, plcp);
		break;

	rxbadproto:
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);

	default:
		break;
	}

toss:
	PKTFREE(osh, p, FALSE);
}

static void
wlc_recv_scan_parse(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, uint8 *plcp,
	struct dot11_management_header *hdr, uint8 *body, int body_len)
{
	struct dot11_bcn_prb *bcn = (struct dot11_bcn_prb *)body;
	struct dot11_bcn_prb *bcn_prb = NULL;
	uint16 cap = ltoh16(bcn->capability);
	wlc_bss_info_t bi;
	wlc_bss_info_t *BSS;
	bcm_tlv_t *ssid_ie;
	bool beacon, filter;
#ifdef STA
	chanspec_t chanspec = 0;
#endif
	wlc_scan_info_t *scan = wlc->scan;

	beacon = ((ltoh16(hdr->fc) & FC_KIND_MASK) == FC_BEACON);
	filter = beacon && !(scan->state & SCAN_STATE_PASSIVE) &&
		!wlc_quiet_chanspec(wlc->cmi, WLC_RX_CHANNEL(&wrxh->rxhdr));

	/* find and validate the SSID IE */
	ssid_ie = bcm_parse_tlvs(body + DOT11_BCN_PRB_LEN, body_len - DOT11_BCN_PRB_LEN,
	                         DOT11_MNG_SSID_ID);

	/*
	 * check for probe responses/beacons:
	 * - must have the correct Infra mode
	 * - must have the SSID(s) we were looking for,
	 *   unless we were doing a broadcast SSID request (ssid len == 0)
	 * - must have matching BSSID (if unicast was specified)
	 */
	if ((scan->bss_type == DOT11_BSSTYPE_ANY ||
	     (scan->bss_type == DOT11_BSSTYPE_INFRASTRUCTURE &&
	      ((cap & DOT11_CAP_ESS) ||
#ifdef WLP2P
	       (P2P_ENAB(wlc->pub) && !(cap & DOT11_CAP_IBSS)) ||
#endif
	       FALSE)) ||
	     (scan->bss_type == DOT11_BSSTYPE_INDEPENDENT && (cap & DOT11_CAP_IBSS))) &&
	    wlc_scan_ssid_match(scan, ssid_ie, filter) &&
	    (ETHER_ISMULTI(&scan->bssid) ||
	     bcmp(&scan->bssid, &hdr->bssid, ETHER_ADDR_LEN) == 0)) {
#if defined(BCMDBG) || defined(WLMSG_SCAN)
		char eabuf[ETHER_ADDR_STR_LEN];
#endif
		WL_SCAN(("wl%d: found BSS %s on chanspec 0x%x\n",
		         wlc->pub->unit, bcm_ether_ntoa(&hdr->bssid, eabuf),
		         WLC_BAND_PI_RADIO_CHANSPEC));
		WL_PRHDRS(wlc, beacon ? "rxpkt hdr (beacon)" : "rxpkt hdr (probersp)", plcp, NULL,
			wrxh, body_len + D11_PHY_HDR_LEN);
#if defined(BCMDBG) || defined(WLMSG_PRPKT)
		if (WL_PRPKT_ON()) {
			printf(beacon?"\nrxpkt (beacon)\n":"\nrxpkt (probersp)\n");
			wlc_print_bcn_prb((uint8*)plcp, body_len + D11_PHY_HDR_LEN);
		}
#endif
		if (wlc_recv_parse_bcn_prb(wlc, wrxh, &hdr->bssid, beacon, body, body_len, &bi)) {
			/* parse fail, discard this new bi */
			WL_INFORM(("wl%d: wlc_scan_parse: tossing bcn/prb resp "
			           "collected on channel %d wlc_parse_bcn_prb failed\n",
			           wlc->pub->unit, WLC_RX_CHANNEL(&wrxh->rxhdr)));
			return;
		}
		/* check bssid, ssid AND band matching */
		BSS = wlc_BSSlookup(wlc, (uchar *)&hdr->bssid, bi.chanspec, bi.SSID, bi.SSID_len);

		/* do not allow beacon data to update the data recd from a probe response */
		if (BSS && beacon && !(BSS->flags & WLC_BSS_BEACON))
			return;

		if (BSS) {
			if ((BSS->flags & WLC_BSS_RSSI_ON_CHANNEL) ==
			    (bi.flags & WLC_BSS_RSSI_ON_CHANNEL)) {
				/* preserve max RSSI if the measurements are
				 * both on-channel or both off-channel
				 */
				bi.RSSI = MAX(BSS->RSSI, bi.RSSI);
			} else if ((BSS->flags & WLC_BSS_RSSI_ON_CHANNEL) &&
			           (bi.flags & WLC_BSS_RSSI_ON_CHANNEL) == 0) {
				/* preserve the on-channel rssi measurement
				 * if the new measurement is off channel
				 */
				bi.RSSI = BSS->RSSI;
				bi.flags |= WLC_BSS_RSSI_ON_CHANNEL;
			}
		}
#ifdef STA
		else if (wlc->scanresults_minrssi &&
		           bi.RSSI < (int16) (wlc->scanresults_minrssi)) {
			/* filter this one out if the user specified a minimum signal strength */
			WL_INFORM(("wl%d: wlc_scan_parse: tossing bcn/prb resp "
				   "for BSS on channel spec %d since target rssi was %d\n",
				   wlc->pub->unit, bi.chanspec, bi.RSSI));
			return;
		}

		if (ESCAN_IN_PROGRESS(wlc->scan)) {
			wl_escan_result_t *escan_result;
			uint escan_result_len;

			bi.bcn_prb_len = 0;

			if (scan->state & SCAN_STATE_SAVE_PRB) {
			       /* save raw probe response frame */
			       if ((bi.bcn_prb = (struct dot11_bcn_prb *)
			            MALLOC(wlc->osh, body_len)) != NULL) {
				       bcopy((char*)body, (char*)bi.bcn_prb, body_len);
				       bi.bcn_prb_len = (uint16)body_len;
			       } else {
				       WL_ERROR(("wl: wlc_scan_parse: out of memory, malloc-ed %d"
				                 " bytes\n", MALLOCED(wlc->osh)));
				       /* No point proceeding any further, since malloc */
				       /* failed here, it will fail again, most likely. */
				       return;
			       }
			}

			escan_result_len = sizeof(wl_escan_result_t) + bi.bcn_prb_len;

			if ((escan_result = (wl_escan_result_t *)
			     MALLOC(wlc->osh, escan_result_len)) == NULL) {
				WL_ERROR(("wl: wlc_scan_parse: out of memory,"
				          "malloc-ed %d bytes\n", MALLOCED(wlc->osh)));
				if (bi.bcn_prb_len) {
					MFREE(wlc->osh, bi.bcn_prb, bi.bcn_prb_len);
				}
				return;
			}

			if (wlc_bss2wl_bss(wlc, &bi, &escan_result->bss_info[0],
			                   sizeof(wl_bss_info_t) + bi.bcn_prb_len,
			                   TRUE) != BCME_OK) {
				WL_ERROR(("escan: results buffer too short %s()\n", __FUNCTION__));
			}
			else {
				escan_result->sync_id = wlc->escan_sync_id;
				escan_result->version = WL_BSS_INFO_VERSION;
				escan_result->bss_count = 1;
				escan_result->buflen = WL_ESCAN_RESULTS_FIXED_SIZE +
				        escan_result->bss_info[0].length;
				wlc_bss_mac_event(wlc, wlc_scan_bsscfg(wlc->scan),
				                  WLC_E_ESCAN_RESULT, NULL, WLC_E_STATUS_PARTIAL,
				                  0, 0,	escan_result, escan_result->buflen);
			}
			MFREE(wlc->osh, escan_result, escan_result_len);
			if (bi.bcn_prb_len) {
				MFREE(wlc->osh, bi.bcn_prb, bi.bcn_prb_len);
			}
			return;
		}

#ifdef WLPFN
		/* if this is a pfn scan, update preferred networks information */
		if (wl_pfn_scan_in_progress(wlc->pfn)) {
			wl_pfn_process_scan_result(wlc->pfn, &bi);
			return;
		}
#endif

		/* Iscan: add new BSS only if not previously reported (update existing is ok). */
		if (!BSS && ISCAN_IN_PROGRESS(wlc)) {
			/* use actual bcn_prb rx channel for comparison chanspec */
			chanspec = (((wrxh->rxhdr.RxChan & RXS_CHAN_ID_MASK) >> RXS_CHAN_ID_SHIFT)
			    << WL_CHANSPEC_CHAN_SHIFT);

			/* OR in the other bits */
			chanspec |= (chanspec_t)(bi.chanspec & ~(WL_CHANSPEC_CHAN_MASK));
			/* ignore if it's in the ignore list; add otherwise */
			if (wlc_BSSignore(wlc, (uchar *)&hdr->bssid, chanspec, bi.SSID,
			                  bi.SSID_len))
				return;
		}
#endif /* STA */

		/* make sure we have enough space before proceeding */
		if (scan->state & SCAN_STATE_SAVE_PRB) {
			bcn_prb = (struct dot11_bcn_prb *) MALLOC(wlc->osh, body_len);
			if (!bcn_prb) {
				WL_ERROR(("wl%d: wlc_scan_parse: out of memory %d bytes\n",
					wlc->pub->unit, body_len));
				return;
			}
		}

		/* add it if it was not already in the list */
		if (!BSS)
			BSS = wlc_BSSadd(wlc);

		if (BSS) {
			/* free the prb pointer, prevent memory leakage */
			if (BSS->bcn_prb) {
				MFREE(wlc->osh, BSS->bcn_prb, BSS->bcn_prb_len);
				BSS->bcn_prb = NULL;
				BSS->bcn_prb_len = 0;
			}
			/* update the entry regardless existing or new */
			bcopy((char*)&bi, (char*)BSS, sizeof(wlc_bss_info_t));
#ifdef WLSCANCACHE
			BSS->timestamp = OSL_SYSUPTIME();
#endif
			if (scan->state & SCAN_STATE_SAVE_PRB) {
				/* scan completion responsible for freeing frame */
				ASSERT(!BSS->bcn_prb);
				ASSERT(bcn_prb != NULL);

				/* save raw probe response frame */
				BSS->bcn_prb = bcn_prb;
				bcopy((char*)body, (char*)BSS->bcn_prb, body_len);
				BSS->bcn_prb_len = (uint16) body_len;
			}
#ifdef WLP2P
			if (P2P_ENAB(wlc->pub)) {
				BSS->rx_tsf_l = wlc_recover_tsf32(wlc, wrxh);
				BSS->rx_tsf_l += wlc_compute_bcn_payloadtsfoff(wlc,
					wlc_recv_compute_rspec(wrxh, plcp));
			}
#endif
		} else {
			if (bcn_prb)
				MFREE(wlc->osh, bcn_prb, body_len);
#ifdef STA
			if (ISCAN_IN_PROGRESS(wlc)) {
				wlc->iscan_chanspec_last = chanspec;
				WL_INFORM(("wlc_scan_parse ending iscan on channel %d\n",
				           CHSPEC_CHANNEL(wlc->iscan_chanspec_last)));
			}
			/* no room in list or out of memory */
			WL_INFORM(("wlc_scan_parse: can't add BSS: "
			           "terminating scan in process\n"));
			wlc_scan_terminate(scan, WLC_E_STATUS_PARTIAL);
			return;
#endif /* STA */
		}

		{
#ifdef WLP2P
		if (P2P_ENAB(wlc->pub)) {
			wlc_bsscfg_t *cfg = wlc_scan_bsscfg(wlc->scan);
#ifndef MACOSX
			if (wlc_eventq_test_ind(wlc->eventq, WLC_E_PROBRESP_MSG))
#endif
			{
				wl_event_rx_frame_data_t rxframe_data;

				wlc_recv_prep_event_rx_frame_data(wlc, wrxh, plcp, &rxframe_data);

				wlc_bss_mac_rxframe_event(wlc, cfg, WLC_E_PROBRESP_MSG, &hdr->sa,
				                          0, 0,
				                          0, (char *)hdr,
				                          body_len + DOT11_MGMT_HDR_LEN,
				                          &rxframe_data);
			}

			/* advance assoc state machine */
			if (BSS_P2P_ENAB(wlc, cfg) &&
			    cfg->assoc != NULL && cfg->assoc->state != AS_IDLE &&
			    bcmp(&scan->bssid, &hdr->bssid, ETHER_ADDR_LEN) == 0) {
				WL_SCAN(("wl%d.%d: match BSSID %s and move to association\n",
				         wlc->pub->unit, WLC_BSSCFG_IDX(cfg),
				         bcm_ether_ntoa(&scan->bssid, eabuf)));
				wlc_scan_terminate(scan, WLC_E_STATUS_SUCCESS);
			}
		}
#endif /* WLP2P */
		}
	}
}

#ifdef STA
static void
wlc_reset_cfpstart(wlc_info_t *wlc, struct dot11_bcn_prb *bcn)
{
	uint32 bcn_l, bcn_h;
	uint32 tbtt_offset, bi;
	uint32 bi_us;
	uint32 tbtt_l, tbtt_h;

	bcn_l = ltoh32_ua(&bcn->timestamp[0]);
	bcn_h = ltoh32_ua(&bcn->timestamp[1]);

	bi = ltoh16(bcn->beacon_interval);

	/* set beacon interval to WECA maximum, if 0 */
	if (bi == 0)
		bi = 1024;

	bi_us = bi * DOT11_TU_TO_US;

	tbtt_offset = wlc_calc_tbtt_offset(bi, bcn_h, bcn_l);

	tbtt_l = bcn_l;
	tbtt_h = bcn_h;

	wlc_uint64_sub(&tbtt_h, &tbtt_l, 0, tbtt_offset);

	wlc_uint64_add(&tbtt_h, &tbtt_l, 0, bi_us);

	/* CFP start is the next beacon interval after timestamp */
	W_REG(wlc->osh, &wlc->regs->tsf_cfpstart, tbtt_l);

	WL_ERROR(("wl%d:%s(): current bcn_tsf 0x%x:0x%x, reset CFPSTART to 0x%x \n",
		wlc->pub->unit, __FUNCTION__, bcn_h, bcn_l, tbtt_l));

}
#endif /* STA */


/*
 * Convert a restricted channel to non-restricted if we recieve a Beacon
 * or Probe Response from an AP on the channel.
 *
 * An active AP on a channel is an indication that use of the channel is
 * allowed in the current country, so we can remove the channel restriction.
 */
static void
wlc_convert_restricted_chanspec(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, wlc_d11rxhdr_t *wrxh,
        struct dot11_management_header *hdr, uint8 *body, int bcn_len)
{
	struct dot11_bcn_prb *bcn = (struct dot11_bcn_prb *)body;
	uint8 *tag_params;
	int tag_params_len;
	bcm_tlv_t *ds_params;
	chanspec_t rx_chanspec;
	ht_add_ie_t *add_ie = NULL;
	uint16 cap = ltoh16(bcn->capability);
#if defined(BCMDBG)
	char chanbuf[CHANSPEC_STR_LEN];
#endif

	/* only convert channel of BSS AP */
	if (!(cap & DOT11_CAP_ESS) || (cap & DOT11_CAP_IBSS))
		return;

	ASSERT(ISALIGNED((uintptr)(bcn), sizeof(uint16)));
	tag_params = ((uint8*)bcn + DOT11_BCN_PRB_LEN);
	tag_params_len = bcn_len - DOT11_BCN_PRB_LEN;

	/*
	* Determine the operational channel of the AP
	*/

	add_ie = wlc_read_ht_add_ies(wlc, tag_params, tag_params_len);
	if (add_ie) {
		/* use channel info from HT IEs if present */
		rx_chanspec = wlc_ht_chanspec(wlc, add_ie->ctl_ch, add_ie->byte1);
	}
	else if ((ds_params = bcm_parse_tlvs(tag_params, tag_params_len, DOT11_MNG_DS_PARMS_ID)) &&
		(ds_params->len == 1)) {
		/* use channel info from DS Params IE if present */
		rx_chanspec = CH20MHZ_CHSPEC(ds_params->data[0]);
	}
	else {
		/* use the channel to which we were tuned when we recieved the packet */
		rx_chanspec = CH20MHZ_CHSPEC(WLC_RX_CHANNEL(&wrxh->rxhdr));
	}

	/* if the channel of the Bcn/ProbeResp is not restricted, nothing to do */
	if (!wlc_restricted_chanspec(wlc->cmi, rx_chanspec))
		return;

	WL_REGULATORY(("wl%d:%s(): convert channel %s to non-restricted\n",
		wlc->pub->unit, __FUNCTION__, wf_chspec_ntoa(rx_chanspec, chanbuf)));

	wlc_clr_restricted_chanspec(wlc->cmi, rx_chanspec);

	/* clear the quiet bit if this channel is only quiet due to the restricted bit
	* and not radar.
	*/
	if (wlc_quiet_chanspec(wlc->cmi, rx_chanspec) &&
		!wlc_radar_chanspec(wlc->cmi, rx_chanspec)) {
		wlc_clr_quiet_chanspec(wlc->cmi, rx_chanspec);

		/* if we are on this channel, we can unmute since we just cleared the quiet bit */
		if (rx_chanspec == wlc->chanspec)
			wlc_mute(wlc, OFF, 0);
	}

	return;
}

/* 'bsscfg' is from wlc_bsscfg_find_by_bssid(wlc, &hdr->bssid) */
static void
wlc_recv_process_beacon(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, wlc_d11rxhdr_t *wrxh, uint8 *plcp,
	struct dot11_management_header *hdr, uint8 *body, int bcn_len)
{
	struct scb *scb;
	struct dot11_bcn_prb *bcn = (struct dot11_bcn_prb *)body;
	uint8 *tag_params;
	int tag_params_len;
	bcm_tlv_t *ds_params;
	bcm_tlv_t *rate_ie;
#if defined(STA) || defined(BCMDBG)
	bcm_tlv_t *ssid_ie;
#endif
#ifdef STA
	bcm_tlv_t *wme_ie;
	wme_param_ie_t *wme_ie_body;
	uint8 *parse;
	uint parse_len;
#endif /* STA */
	uint8 *erp;
	int erp_len;
	bool is_erp;
	bool on_home_channel;
	bool on_control_channel = FALSE;
	bool current_bss_bcn;
	chanspec_t new_chanspec = 0;
	uint8 rx_channel;
	int rx_bandunit;
	bool short_preamble;
	ratespec_t rspec;
	ht_add_ie_t *add_ie = NULL;
	ht_cap_ie_t *cap_ie = NULL;
	obss_params_t *obss_ie = NULL;
#ifdef BCMDBG
	char eabuf[ETHER_ADDR_STR_LEN];
	char ssidbuf[SSID_FMT_BUF_LEN];
#endif
	uint16 cap = ltoh16(bcn->capability);
#ifdef STA
	wlc_roam_t *roam = NULL;
#endif
	chanspec_t home_chspec = wlc->home_chanspec;
	bool cur_bw_is40 = FALSE;

	ASSERT(ISALIGNED((uintptr)(bcn), sizeof(uint16)));
	tag_params = ((uint8*)bcn + DOT11_BCN_PRB_LEN);
	tag_params_len = bcn_len - DOT11_BCN_PRB_LEN;

	rx_channel = (uint8)wlc_recv_mgmt_rx_channel_get(wrxh);
	rx_bandunit = CHANNEL_BANDUNIT(wlc, rx_channel);
	short_preamble = ((wrxh->rxhdr.PhyRxStatus_0 & PRXS0_SHORTH) != 0);
	rspec = wlc_recv_compute_rspec(wrxh, plcp);

	/* lookup the scb in case we already have info on it */
	scb = wlc_scbfindband(wlc, &hdr->sa, rx_bandunit);

	/* check for an ERP info elt */
	erp_len = 0;
	erp = NULL;
	if (!wlc_erp_find(wlc, bcn, bcn_len, &erp, &erp_len))
		wlc_nonerp_find(wlc, bcn, bcn_len, &erp, &erp_len);

	/* check rates for ERP capability */
	is_erp = FALSE;
	if (scb && (scb->flags & SCB_NONERP)) {
		/* This STA was already marked as NonERP */
	} else {
		rate_ie = bcm_parse_tlvs(tag_params, tag_params_len, DOT11_MNG_EXT_RATES_ID);
		if (rate_ie && wlc_rateset_isofdm(rate_ie->len, rate_ie->data))
			is_erp = TRUE;
		if (!is_erp) {
			rate_ie = bcm_parse_tlvs(tag_params, tag_params_len, DOT11_MNG_RATES_ID);
			if (rate_ie && wlc_rateset_isofdm(rate_ie->len, rate_ie->data))
				is_erp = TRUE;
		}
		if (scb && !is_erp)
			scb->flags |= SCB_NONERP;
	}

	/* check for a beacon on our channel */
	ds_params = bcm_parse_tlvs(tag_params, tag_params_len, DOT11_MNG_DS_PARMS_ID);
	if (!ds_params || ds_params->len < 1) {
		/* if no channel info, use the channel on which we received the beacon */
		/* For 40MHz, rx_channel can be either the center or side channel */
		on_home_channel = wlc->pub->associated &&
			((CHSPEC_CHANNEL(home_chspec) == rx_channel) ||
		         (wf_chspec_ctlchan(home_chspec) == rx_channel));
	}
	else {
		on_home_channel = wlc->pub->associated &&
			(wf_chspec_ctlchan(home_chspec) == ds_params->data[0]);
		on_control_channel = on_home_channel;
	}

	/* check for beacon in our BSS (STA's AP or IBSS member) */
	current_bss_bcn = on_home_channel && (bsscfg != NULL);
#ifdef WLMCHAN
	/* For mchan, make sure the beacon we received is on our bsscfg's channel */
	if (MCHAN_ENAB(wlc->pub) && current_bss_bcn &&
	    !((CHSPEC_CHANNEL(bsscfg->chanspec) == rx_channel) ||
	      (wf_chspec_ctlchan(bsscfg->chanspec) == rx_channel))) {
		WL_MCHAN(("wl%d.%d: beacon received on ch%d, not on bsscfg chanspec 0x%x\n",
		          wlc->pub->unit, bsscfg->_idx, rx_channel, bsscfg->chanspec));
		current_bss_bcn = FALSE;
	}
#endif /* WLMCHAN */

	if (on_home_channel)
		cur_bw_is40 = CHSPEC_IS40(wlc->home_chanspec);

	if (N_ENAB(wlc->pub)) {
		if ((AP_ACTIVE(wlc) || !current_bss_bcn ||
		     (bsscfg->current_bss->flags & WLC_BSS_HT))) {
			cap_ie = wlc_read_ht_cap_ies(wlc, tag_params, tag_params_len);
			add_ie = wlc_read_ht_add_ies(wlc, tag_params, tag_params_len);
			if (COEX_ENAB(wlc->pub))
				obss_ie = wlc_ht_read_obss_scanparams_ie(wlc, tag_params,
				                                         tag_params_len);
		}
	}

	/* if AP control channel has changed, then don't consider it to be ours.
	 * But if the bandwidith changed, with same control channel,
	 * then consider it is ours.
	 */
	if (N_ENAB(wlc->pub) &&
	    current_bss_bcn && BSSCFG_STA(bsscfg) && !bsscfg->csa->csa.count &&
	    add_ie && cap_ie) {
		chanspec_t bss_chspec = wlc_ht_chanspec(wlc, add_ie->ctl_ch, add_ie->byte1);
		wlcband_t *cur_band = wlc->bandstate[CHSPEC_IS2G(home_chspec) ?
		                       BAND_2G_INDEX : BAND_5G_INDEX];
		/* current node chanspec is 40MHz */
		/* current node is 40MHz capable */
		bool node_cap40 =
		        (((wlc_channel_locale_flags_in_band(wlc->cmi, cur_band->bandunit) &
		           WLC_NO_40MHZ) == 0) &&
		         cur_band->mimo_cap_40);

		/* check if current BSS support 40MHz */
		bool bss_allow40 = (ltoh16_ua(&cap_ie->cap) & HT_CAP_40MHZ) ?
		        (add_ie->byte1 & HT_BW_ANY) != 0 : FALSE;

		/* check if the control channel has changed, AP may
		 * be upgrade/downgrade to/from 40MHz from/to 20MHz
		 */
		if (cur_bw_is40 && bss_chspec != home_chspec) {
			if (wf_chspec_ctlchan(bss_chspec) == wf_chspec_ctlchan(home_chspec)) {
#ifdef WLMCHAN
				bool mchan_allow_20mhz_downgrade = TRUE;
				/* When multiple bsscfg share the same chan context, only
				 * allow downgrade to 20MHz if both bsscfg's are now 20MHz.
				 * Otherwise, reject the downgrade.
				 */
				if (MCHAN_ENAB(wlc->pub) && (bsscfg->chan_context != NULL)) {
					/* our bsscfg needs downgrade so update bsscfg->chanspec */
					bsscfg->chanspec = bss_chspec;
					/* check for any 40MHz bsscfg on our chan_context */
					if (mchan_chan_context_has_40mhz_cfg(wlc,
						bsscfg->chan_context, NULL)) {
						mchan_allow_20mhz_downgrade = FALSE;
						WL_MCHAN(("wl%d.%d: chan context shared, "
						          "is 40MHz, not changed to 20MHz\n",
						          wlc->pub->unit, bsscfg->_idx));
					}
					else {
						/* no 40MHz bsscfg on chan_context, down grade
						 * chan_context also.
						 */
						bsscfg->chan_context->chanspec = bss_chspec;
					}
				}
				if (mchan_allow_20mhz_downgrade)
#endif /* WLMCHAN */
				{
				new_chanspec = bss_chspec;
				WL_COEX(("wl%d: %s: BSS bandwidth changed to 20MHz detected\n",
				         wlc->pub->unit, __FUNCTION__));
				}
			} else
				current_bss_bcn = FALSE;
		}
		/* BSS operate at 40MHz, upgrade to 40 MHz if device support 40 */
		if (!cur_bw_is40 && node_cap40 && bss_allow40 && CHSPEC_IS40(bss_chspec)) {
			if (wf_chspec_ctlchan(bss_chspec) == wf_chspec_ctlchan(home_chspec)) {
#ifdef WLMCHAN
				/* when changing chanspec, also change chan_context->chanspec */
				if (MCHAN_ENAB(wlc->pub) && bsscfg->chan_context != NULL) {
					bsscfg->chanspec = bss_chspec;
					bsscfg->chan_context->chanspec = bss_chspec;
				}
#endif
				new_chanspec = bss_chspec;
				WL_COEX(("wl%d: %s: BSS bandwidth changed to 40MHz detected\n",
				         wlc->pub->unit, __FUNCTION__));
			} else
				current_bss_bcn = FALSE;
		}
	}


	/* For G APs or IBSSs, check overlapping beacon information */
	if (wlc->band->gmode && on_home_channel) {
		int i;
		wlc_bsscfg_t *bc;

		FOREACH_BSS(wlc, i, bc) {
			wlc_prot_cfg_t *prot = bc->prot_cfg;
			wlc_prot_to_t *to = bc->prot_to;

			if (!bc->associated)
				continue;

			if (BSSCFG_STA(bc) && bc->BSS)
				continue;

#ifdef WLMCHAN
			if (MCHAN_ENAB(wlc->pub) &&
			    bc->chan_context != NULL &&
			    !CHSPEC_CTLOVLP(wlc->home_chanspec, bc->chan_context->chanspec,
			                    CH_10MHZ_APART))
				continue;
#endif
			/* Check for overlapping Barker long-preamble-only signaled */
			if (prot->barker_overlap_control &&
			    erp_len > 0 && (erp[0] & DOT11_MNG_BARKER_PREAMBLE))
				to->barker_detect_timeout = WLC_IBSS_BCN_TIMEOUT;

			/* Check for overlapping NonERP long-preamble-only beacons */
			if (prot->barker_overlap_control &&
			    !is_erp && (cap & DOT11_CAP_SHORT) == 0)
				to->longpre_detect_timeout = WLC_IBSS_BCN_TIMEOUT;

			/* Check for overlapping NonERP beacon
			 * Consider as NonERP beacon if there are no OFDM rates
			 * or the ERP Info indicates that NonERP STAs are associated
			 */
			if (!is_erp ||
			    (erp_len > 0 && (erp[0] & DOT11_MNG_NONERP_PRESENT))) {
#ifdef BCMDBG
				if (WL_INFORM_ON() &&
				    to->nonerp_ovlp_timeout == 0) {
					ssid_ie = bcm_parse_tlvs(tag_params, tag_params_len,
					                         DOT11_MNG_SSID_ID);
					if (ssid_ie) {
						wlc_format_ssid(ssidbuf,
						                ssid_ie->data, ssid_ie->len);
					} else {
						bzero(ssidbuf, sizeof(ssidbuf));
						strncpy(ssidbuf, "<unknown>", sizeof(ssidbuf) - 1);
					}

					WL_INFORM(("wl%d: %s: detected legacy beacon %s \"%s\"\n",
					           wlc->pub->unit, __FUNCTION__,
					           bcm_ether_ntoa(&hdr->bssid, eabuf), ssidbuf));
				}
#endif /* BCMDBG */
				to->nonerp_ovlp_timeout = WLC_IBSS_BCN_TIMEOUT;
			}

			wlc_update_gbss_modes(bc);
		}
	}

	/* For HT APs or IBSSs, check overlapping beacon information */
	if (N_ENAB(wlc->pub) && on_home_channel) {
		int i;
		wlc_bsscfg_t *bc;

		FOREACH_BSS(wlc, i, bc) {
			wlc_prot_to_t *to = bc->prot_to;
			bool cap_40, bw_40;

			if (!bc->associated)
				continue;

			if (BSSCFG_STA(bc) && bc->BSS)
				continue;

#ifdef WLMCHAN
			if (MCHAN_ENAB(wlc->pub) &&
			    bc->chan_context != NULL &&
			    !CHSPEC_CTLOVLP(wlc->home_chanspec, bc->chan_context->chanspec,
			                    CH_20MHZ_APART))
				continue;
#endif

			/* Check for overlapping NonMIMO OFDM BSS
			 * Consider as OFDM BSS if not MIMO and has BSS OFDM rates
			 * or the HT ADD Info indicates that OFDM STAs are associated,
			 */
			if ((!add_ie && is_erp) ||
			    (add_ie && HT_MIXEDMODE_PRESENT(add_ie)))
				to->ofdm_ovlp_timeout = WLC_IBSS_BCN_TIMEOUT;
			if (add_ie && HT_HT20_PRESENT(add_ie) && cur_bw_is40)
				to->ht20in40_ovlp_timeout = WLC_IBSS_BCN_TIMEOUT;

			/* Check for overlapping BSS with 20MHz Operation only */
			if (cap_ie && add_ie) {
				cap_40 = ((ltoh16_ua(&cap_ie->cap) & HT_CAP_40MHZ) != 0);
				bw_40 = add_ie->byte1 & HT_BW_ANY;
				if (!cap_40 && bw_40 && cur_bw_is40)
					to->ht20in40_ovlp_timeout = WLC_IBSS_BCN_TIMEOUT;
			}

			wlc_update_n_protection(bc);
		}
	}

	/* For HT APs with COEX, check for Trigger Event A :
	 * a non-HT beacon is detected
	 */
#ifdef WL11N
	if (AP_ENAB(wlc->pub) && COEX_ACTIVE(wlc) && !on_control_channel) {
		if (wlc_ht_ap_coex_tea_chk(wlc, cap_ie)) {
			wlc_ht_coex_update_permit(wlc, FALSE);
			wlc_ht_coex_update_fid_time(wlc);
			if (CHSPEC_IS40(home_chspec))
				wlc_ht_coex_switch_bw(wlc, TRUE);
		}
	}
#endif

	/* process the brcm_ie and ht ie in a beacon frame */
	if (scb && SCB_WDS(scb)) {
		wlc_process_brcm_ie(wlc, scb, (brcm_ie_t*)wlc_find_vendor_ie(tag_params,
			tag_params_len, (const uchar*)BRCM_OUI, NULL, 0));
		if (N_ENAB(wlc->pub)) {
			if (cap_ie)
				wlc_ht_update_scbstate(wlc, scb, cap_ie, add_ie, obss_ie);
			else if (SCB_HT_CAP(scb)) {
				/* Ensure HT based features are cleared here */
				wlc_ht_update_scbstate(wlc, scb, NULL, NULL, NULL);
			}
		}
	}

	/* end of AP processing */

#ifdef STA
	if (wlc->stas_associated == 0)
		return;

	if (bsscfg != NULL)
		roam = bsscfg->roam;

	if (current_bss_bcn) {
		/* the cap and additional IE are only in the bcn/prb response pkts,
		 * when joining a bss parse the bcn_prb to check for these IE's.
		 */
		if (N_ENAB(wlc->pub)) {
			/* create an scb if one does not exist (for ibss's) */
			if (!bsscfg->BSS && !scb)
				scb = wlc_scblookupband(wlc, &hdr->sa, rx_bandunit);
			if (scb) {
				/* update ht state or if we are in IBSS mode then clear HT state */
				if (cap_ie) {
#ifdef WLP2P
					if (BSS_P2P_ENAB(wlc, bsscfg))
						bsscfg->p2p_flags |= WLC_BSSCFG_P2P_IGN_SMPS;
#endif
					wlc_ht_update_scbstate(wlc, scb, cap_ie, add_ie, obss_ie);
#ifdef WLP2P
					bsscfg->p2p_flags &= ~WLC_BSSCFG_P2P_IGN_SMPS;
#endif
				} else if (!bsscfg->BSS && (scb->flags & SCB_HTCAP))
					/* Ensure HT based features are cleared for IBSS STAs */
					wlc_ht_update_scbstate(wlc, scb, NULL, NULL, NULL);
				wlc_process_coex_mgmt_ie(wlc, tag_params, tag_params_len, scb);
			}
		}

		wlc_lq_rssi_update_ma(bsscfg, wlc_lq_rssi_pktrxh_cal(wlc, wrxh));
		wlc_lq_rssi_event_update(bsscfg);
		wlc_phy_update_snr_ma(bsscfg, wlc_recv_snr_compute(wlc, wrxh));

		if (BSSCFG_STA(bsscfg)) {
			bsscfg->current_bss->RSSI = (int16)bsscfg->link->rssi;
			bsscfg->current_bss->SNR = (int16)bsscfg->link->snr;
			if (bsscfg->BSS &&
#ifdef WLP2P
			    !BSS_P2P_ENAB(wlc, bsscfg) &&
#endif
			    !roam->off)
				wlc_roamscan_start(bsscfg, WLC_E_REASON_LOW_RSSI);
		}
		roam->time_since_bcn = 0;
		roam->tbtt_since_bcn = 0;

		/* If we are in an IBSS, indicate link up if we are currently down.
		 * bcns_lost indicates whether the link is marked 'down' or not
		 */
		if (!bsscfg->BSS && roam->bcns_lost == TRUE) {
			roam->bcns_lost = FALSE;
#ifdef WLAMPDU
			/* detect link up/down for IBSS so that ba sm can be cleaned up */
			scb_ampdu_cleanup_all(wlc->ampdu);
#endif
			wlc_bss_mac_event(wlc, bsscfg, WLC_E_BEACON_RX, NULL,
				WLC_E_STATUS_SUCCESS, 0, 0, 0, 0);
		}

	}

	/* Check for retrograde TSF; wraparound is treated as a retrograde TSF */
	if (bsscfg != NULL && BSSCFG_STA(bsscfg) && bsscfg->BSS) {
		uint32 bcn_l, bcn_h;

		bcn_l = ltoh32_ua(&bcn->timestamp[0]);
		bcn_h = ltoh32_ua(&bcn->timestamp[1]);
		if ((roam->tsf_h || roam->tsf_l) &&
		    (bcn_h < roam->tsf_h ||
		     (bcn_h == roam->tsf_h && bcn_l < roam->tsf_l))) {
			wlc_bss_mac_event(wlc, bsscfg, WLC_E_RETROGRADE_TSF,
			                  &hdr->bssid, 0, 0, 0, 0, 0);
			wlc_tsf_adopt_bcn(bsscfg, wrxh, plcp, bcn);
			if (on_home_channel) {
				struct ether_addr *bssid = WLC_BSS_CONNECTED(bsscfg) ?
				        &bsscfg->BSSID : &bsscfg->prev_BSSID;

				wlc_sendnulldata(wlc, bssid, 0, 0, PRIO_8021D_BE);
			}
		}
		roam->tsf_l = bcn_l;
		roam->tsf_h = bcn_h;
	}

	/* Check for a BSS beacon from our associated AP */
	if (current_bss_bcn && BSSCFG_STA(bsscfg) && bsscfg->BSS) {
		bool bcmc; /* Ignored (ucode automatically stays awake for bcmc traffic) */
		uint dtim_count; /* Ignored */
		bool intim = wlc_InTIM(bsscfg, bcn, bcn_len, &bcmc, &dtim_count);
		wlc_pm_st_t *pm = bsscfg->pm;
		wlc_prot_cfg_t *prot = bsscfg->prot_cfg;
		wlc_prot_to_t *to = bsscfg->prot_to;

		WL_NONE(("wl%d: wlc_process_beacon: intim:%d bcmc:%d dtim_count:%d\n",
		         wlc->pub->unit, intim, bcmc, dtim_count));

#ifdef WLMCHAN
		if (MCHAN_ENAB(wlc->pub)) {
			if (bsscfg->mchan_tbtt_since_bcn >
			    wlc_mchan_tbtt_since_bcn_thresh(wlc->mchan)) {
				/* force p2p module to update tbtt */
				bsscfg->p2p_flags |= WLC_BSSCFG_P2P_UPD_BSS;
				WL_MCHAN(("wl%d.%d: force tbtt upd, mchan tbtt_since_bcn = %d\n",
				          wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg),
				          bsscfg->mchan_tbtt_since_bcn));
			}
			bsscfg->mchan_tbtt_since_bcn = 0;
#ifdef BCMDBG
			/* Print out some useful beacon receive timing information */
			if (WL_INFORM_ON() &&
			    (bsscfg->p2p_flags & WLC_BSSCFG_P2P_VAL_TBTT)) {
				uint32 bcn_l, bcn_l_adj, tsf_l, l_diff, tsf_offset;
				ratespec_t rspec = wlc_recv_compute_rspec(wrxh, plcp);
				uint32 bcn_offset = wlc_compute_bcn_payloadtsfoff(wlc, rspec);

				tsf_offset = bsscfg->tsfo_l;
				/* This is the rx bcn's time */
				bcn_l = ltoh32_ua(&bcn->timestamp[0]);
				/* This is the local time of the bcn */
				tsf_l = wlc_recover_tsf32(wlc, wrxh) + bcn_offset;
				/* convert the bcn's time to local time */
				bcn_l_adj = bcn_l + tsf_offset;
				/* the difference between the two is our offset */
				l_diff = bcn_l_adj-tsf_l;
				WL_MCHAN(("cfg%d: bcn_l = 0x%x, tsf_l = 0x%x, bcn_l_adj = 0x%x\n",
				          bsscfg->_idx, bcn_l, tsf_l, bcn_l_adj));
				WL_MCHAN(("cfg%d: l_diff = %d, tsf_offset = 0x%x%x\n",
				          bsscfg->_idx, (int32)l_diff, bsscfg->tsfo_h, tsf_offset));
			}
#endif /* BCMDBG */
			/* fetch dtim count from beacon */
			bsscfg->sw_dtim_cnt = (uint16)dtim_count;
			WL_MCHAN(("wl%d.%d: dtim_count = %d\n",
			          wlc->pub->unit, bsscfg->_idx, dtim_count));
		}
#endif /* WLMCHAN */

		/* Check the TIM to see if data is buffered for us...
		 * else if PSpoll was sent, then cancel it
		 */
		if (!wlc->PMblocked) {
			if (intim) {
				/* Fast PM mode: leave PS mode */
				if (pm->PM == PM_FAST) {
					WL_RTDC(wlc, "wlc_proc_bcn: inTIM PMep=%02u AW=%02u xPS",
					       (pm->PMenabled ? 10 : 0) | pm->PMpending,
					       (PS_ALLOWED(bsscfg) ? 10 : 0) | STAY_AWAKE(wlc));
					wlc_set_pmstate(bsscfg, FALSE);
					wlc_pm2_sleep_ret_timer_start(bsscfg);
					/* Start the receive throttle timer to limit how
					 * long we can receive data before returning to
					 * PS mode.
					 */
					if (PM2_RCV_DUR_ENAB(bsscfg)) {
						wlc_pm2_rcv_timer_start(bsscfg);
					}
				}
				else if (!WME_ENAB(wlc->pub) || !wlc->wme_apsd ||
				         (scb != NULL && scb->apsd.ac_delv != AC_BITMAP_ALL)) {
					if (pm->PMenabled) {
						if (wlc_sendpspoll(wlc, bsscfg) == FALSE) {
							WL_ERROR(("wl%d: wlc_sendpspoll() failed\n",
								wlc->pub->unit));
						}
					} else {
						/* we do not have PS enabled but AP thinks
						 * we do (it has the tim bit set),
						 * so send a null frame to bring in sync
						 */
						wlc_sendnulldata(wlc, &bsscfg->BSSID, 0, 0, -1);
						WL_PS(("wl%d.%d: unexpected tim bit set, send"
						       " null frame\n",
						       wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
					}
				}
				/* Send APSD trigger frames to get the buffered
				 * packets
				 */
				else if (wlc->apsd_auto_trigger) {

					/* clear the scb flag to force transmit a trigger frame */
					if (pm->PMenabled) {
						if (scb != NULL)
							scb->flags &= ~SCB_SENT_APSD_TRIG;
						wlc_apsd_trigger_timeout(bsscfg);
					}

					/* force core awake if above trigger frame succeeded */
					wlc_set_ps_ctrl(bsscfg);
				}
			}
			else {
				/* If periodic ps-poll is enabled, ignore beacon with no TIM
				 * bit set since the pspoll and beacon may cross paths and the
				 * AP will attempt to send a data frame after we go to sleep.
				 */
				if (pm->PSpoll && pm->pspoll_prd == 0) {
					WL_PS(("wl%d.%d: PS-Poll timeout...go to sleep (%d)\n",
					       wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg),
					       STAY_AWAKE(wlc)));
					wlc_set_pspoll(bsscfg, FALSE);
				}

				if (PM2_RCV_DUR_ENAB(bsscfg) && pm->PM == PM_FAST &&
				    pm->pm2_rcv_state == PM2RD_WAIT_BCN) {
					WL_RTDC(wlc, "wlc_proc_bcn: !inTIM WBCN PMep=%02u AW=%02u",
					    (pm->PMenabled ? 10 : 0) | pm->PMpending,
					    (PS_ALLOWED(bsscfg) ? 10 : 0) | STAY_AWAKE(wlc));
					wlc_pm2_rcv_reset(bsscfg);
				}
			}
		}

		/* If we were waiting for a beacon before allowing doze,
		 * clear the flag and update ps_ctrl
		 */
		if (pm->PMawakebcn) {
#ifdef BCMDBG
			WL_PS(("wl%d.%d: got beacon, clearing PMawakebcn\n",
			       wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
#endif
			wlc_set_pmawakebcn(bsscfg, FALSE);
		}


		if (!pm->check_for_unaligned_tbtt &&
#ifdef WLP2P
		    !P2P_ENAB(wlc->pub) &&
#endif
		    wlc_check_tbtt(bsscfg))
			wlc_set_uatbtt(bsscfg, TRUE);

		if (pm->check_for_unaligned_tbtt) {
#ifdef WLP2P
			/* update connection specific TSF */
			if (P2P_ENAB(wlc->pub))
				;	/* empty */
			else
#endif
			wlc_tbtt_align(bsscfg, short_preamble, rspec, bcn);
			/* allow core to sleep again */
			wlc_set_uatbtt(bsscfg, FALSE);
		}

		/* Track 11g modes */
		if (wlc->band->gmode) {
			/* Track network ShortSlotTime */
			wlc_switch_shortslot(wlc, (cap & DOT11_CAP_SHORTSLOT) != 0);

			if (erp && erp_len > 0) {

				/* Track protection mode */
				if (prot->g_override == WLC_PROTECTION_AUTO) {
					bool tmp = ((erp[0] & DOT11_MNG_USE_PROTECTION) != 0);
					if (prot->_g != tmp)
						wlc_protection_upd(bsscfg, WLC_PROT_G_SPEC, tmp);
				}

				/* Track Barker Preamble Mode */
				if (erp[0] & DOT11_MNG_BARKER_PREAMBLE)
					prot->barker_preamble = WLC_BARKER_LONG_ONLY;
				else
					prot->barker_preamble = WLC_BARKER_SHORT_ALLOWED;

				/* update our shortpreamble use */
				if (prot->barker_preamble == WLC_BARKER_LONG_ONLY ||
				    to->barker_detect_timeout > 0)
					prot->shortpreamble = FALSE;
				else
					prot->shortpreamble = TRUE;

				/* update the AP's scb */
				if (scb) {
					scb->flags &= ~SCB_SHORTPREAMBLE;
					if (prot->barker_preamble == WLC_BARKER_SHORT_ALLOWED)
						scb->flags |= SCB_SHORTPREAMBLE;
				}
			}
		}

		/* As STA, Track HT protection */
		if (N_ENAB(wlc->pub) && add_ie) {
			if (prot->n_cfg_override == WLC_PROTECTION_AUTO) {
				int8 tmp;
				tmp = GET_HT_OPMODE(add_ie);
				if (prot->n_cfg != tmp)
					wlc_protection_upd(bsscfg, WLC_PROT_N_CFG, tmp);
				tmp = HT_NONGF_PRESENT(add_ie);
				if (prot->nongf != tmp)
					wlc_protection_upd(bsscfg, WLC_PROT_N_NONGF, tmp);
				tmp = DOT11N_OBSS_NONHT_PRESENT(add_ie);
				if (prot->n_obss != tmp)
					wlc_protection_upd(bsscfg, WLC_PROT_N_OBSS, tmp);
			} else
				prot->n_cfg =
					((prot->n_cfg_override == WLC_PROTECTION_ON) ?
					WLC_N_PROTECTION_MIXEDMODE : WLC_N_PROTECTION_OFF);
		}

		/* . Make sure this part is done before wlc_parse_11h, which will
		 * process Channel Switch Announcement (CSA) information.
		 * . if this channel is marked as quiet, we can clear the bit and un-mute
		 * since we reestablished our AP connection
		 */
		if (wlc_quiet_chanspec(wlc->cmi, home_chspec)) {
			wlc_clr_quiet_chanspec(wlc->cmi, home_chspec);
			if (WLC_BAND_PI_RADIO_CHANSPEC == home_chspec) {
				wlc_mute(wlc, OFF, 0);
			}
		}

		/* WME: check if the AP has supplied new acparams */
		if (scb && SCB_WME(scb)) {
			/* find the params ie */
			parse = tag_params;
			parse_len = tag_params_len;
			while ((wme_ie = bcm_parse_tlvs(parse, parse_len, DOT11_MNG_PROPR_ID)))
				if (wlc_is_wme_ie(wlc, (uint8 *)wme_ie, &parse, &parse_len))
					break;
			if (wme_ie) {
				wme_ie_body = (wme_param_ie_t *)&wme_ie->data;
				/* check if it's a Params IE where the count field has changed */
				if (wme_ie_body->subtype == WME_SUBTYPE_PARAM_IE &&
				    ((wme_ie_body->qosinfo & WME_QI_AP_COUNT_MASK) !=
				     (wlc->wme_param_ie.qosinfo & WME_QI_AP_COUNT_MASK))) {
					/* save and apply new params ie */
					bcopy(wme_ie_body, &wlc->wme_param_ie,
					      sizeof(wme_param_ie_t));
					if (APSTA_ENAB(wlc->pub))
						wlc->ap->wme_param_ie_ap = wlc->wme_param_ie;
					wlc_edcf_setparams(bsscfg, TRUE);
				}
			} else {
				WL_ERROR(("wl%d: wlc_process_beacon: wme params ie missing\n",
					wlc->pub->unit));
				/* for non-wme association, BE ACI is 2 */
				wlc->wme_param_ie.acparam[0].ACI = NON_EDCF_AC_BE_ACI_STA;
				wlc_edcf_setparams(bsscfg, TRUE);
			}
		}

		/* process any BRCM info element */
		if (scb != NULL)
			wlc_process_brcm_ie(wlc, scb,
			        (brcm_ie_t*)wlc_find_vendor_ie(tag_params,
			                tag_params_len, (const uchar*)BRCM_OUI, NULL, 0));

		/* Perform channel switch if csa_ie found */
		if (wlc_parse_csa_ie(bsscfg, tag_params, tag_params_len) == TRUE) {
			wlc_csa_channel_switch(wlc, bsscfg);
		}

		/* Perform channel switch if bandwidth has changed */
		if (new_chanspec != 0 && bsscfg->csa->csa.count == 0) {
			WL_COEX(("wl%d: %s: Update BSS bandwidth (chanspec 0x%x)\n",
				wlc->pub->unit, __FUNCTION__, new_chanspec));
			wlc_do_chanswitch(bsscfg, new_chanspec);
		}

		if (WL11H_ENAB(wlc) && bsscfg == wlc->cfg) {
			wlc_parse_11h(wlc, tag_params, tag_params_len, bcn);
		}

#if defined(WET) && defined(WET_TUNNEL)
		/* parse for wet tunneling capability */
		wlc_wet_parse_tunnel_ie(wlc, tag_params, tag_params_len);
#endif /* WET && WET_TUNNEL */

#ifdef WLP2P
		/* sync up TSF */
		if (P2P_ENAB(wlc->pub))
			wlc_p2p_adopt_bcn(wlc->p2p, bsscfg, wrxh, plcp, bcn);
		/* sync up TSF on P2P connections */
		if (BSS_P2P_ENAB(wlc, bsscfg))
			wlc_p2p_recv_process_beacon(wlc->p2p, bsscfg, wrxh, plcp, bcn, bcn_len);
#endif
	}
	/* Check for an IBSS beacon with the same BSSID */
	else if (current_bss_bcn && !bsscfg->BSS) {
		bool shortpreamble;
		wlc_prot_to_t *to = bsscfg->prot_to;

		shortpreamble = (is_erp || (cap & DOT11_CAP_SHORT));

		/* Record short preamble capability and process brcm ie */
		if (scb) {
			if (shortpreamble)
				scb->flags |= SCB_SHORTPREAMBLE;
			else
				scb->flags &= ~SCB_SHORTPREAMBLE;

			wlc_process_brcm_ie(wlc, scb, (brcm_ie_t*)wlc_find_vendor_ie(tag_params,
				tag_params_len, (const uchar*)BRCM_OUI, NULL, 0));
		}

		if (wlc->band->gmode) {
			if (erp_len > 0) {
				/* Check for Barker Long preamble only signaled in our IBSS */
				if (erp[0] & DOT11_MNG_BARKER_PREAMBLE) {
					to->barker_detect_timeout = WLC_IBSS_BCN_TIMEOUT;
				}
				/* Check for Use_Protection signaled in our IBSS */
				if (erp[0] & DOT11_MNG_USE_PROTECTION)
					to->g_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;
			}

			/* Check for NonERP beacons */
			if (!is_erp)
				to->nonerp_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;

			/* Check for long-preamble-only STAs in our IBSS */
			if (!shortpreamble)
				to->longpre_detect_timeout = WLC_IBSS_BCN_TIMEOUT;

			wlc_update_gbss_modes(bsscfg);
		}
		if (N_ENAB(wlc->pub)) {
			/* Check for Mixedmode_Protection signaled in our IBSS */
			if (add_ie && HT_MIXEDMODE_PRESENT(add_ie))
				to->n_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;

			if (cap_ie) {
				uint16 cap_ie_cap = ltoh16_ua(&cap_ie->cap);
				/* Check for Non-GF cap in beacons */
				if (!(cap_ie_cap & HT_CAP_GF))
					to->non_gf_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;
				/* Check for 20in40_Protection signaled in our IBSS */
				if (!(cap_ie_cap & HT_CAP_40MHZ) && cur_bw_is40) {
					to->ht20in40_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;
				}
			}

			/* Check for OFDM beacons */
			if (!add_ie && is_erp)
				to->ofdm_ibss_timeout = WLC_IBSS_BCN_TIMEOUT;

			wlc_update_n_protection(bsscfg);
		}

#if defined(IBSS_PEER_DISCOVERY_EVENT)
		/* IBSS peer discovery */
		if (IBSS_PEER_DISCOVERY_EVENT_ENAB(wlc->pub)) {
			if (!scb && !(scb = wlc_scblookupband(wlc, &hdr->sa, rx_bandunit))) {
				WL_ERROR(("wl%d: wlc_process_beacon: no scb for IBSS peer\n",
				          wlc->pub->unit));
				wlc->pub->_cnt->rxnoscb++;
			} else if (!SCB_IS_IBSS_PEER(scb)) {
				bcm_tlv_t *wpa2ie = NULL;

				SCB_SET_IBSS_PEER(scb);

				parse = tag_params;
				parse_len = tag_params_len;
				wpa2ie = bcm_parse_tlvs(parse, parse_len, DOT11_MNG_RSN_ID);

				wlc_mac_event(wlc, WLC_E_IBSS_ASSOC, &scb->ea, 0, 0,
				              DOT11_BSSTYPE_INDEPENDENT, wpa2ie,
				              wpa2ie ? wpa2ie->len + TLV_HDR_LEN : 0);
			}
			if (scb)
				scb->used = wlc->pub->now;
		}
#endif /* defined(IBSS_PEER_DISCOVERY_EVENT) */

#ifdef STA
		/* Reset CFPSTART if tbtt is too far in the future which will cause
		 * IBSS to stop beacon
		*/
		if (!AP_ACTIVE(wlc) && bsscfg == wlc->cfg) {
			if (wlc_check_tbtt(bsscfg)) {
				wlc_reset_cfpstart(wlc, bcn);
			}
		}
	}
#endif
	/* Check for an IBSS Coalesce, when we get a beacon with a different
	 * BSSID, but the same SSID, and a later TSF.
	 */
	else if (wlc->ibss_coalesce_allowed &&
	         on_home_channel &&
	         (cap & DOT11_CAP_IBSS) &&
	         ((ssid_ie =
	           bcm_parse_tlvs(tag_params, tag_params_len, DOT11_MNG_SSID_ID)) != NULL) &&
	         (bsscfg = wlc_bsscfg_find_by_ssid(wlc, ssid_ie->data, ssid_ie->len)) != NULL &&
	         !bsscfg->BSS &&
	         wlc_bcn_tsf_later(bsscfg, wrxh, plcp)) {
		wlc_bss_info_t *target_bss = bsscfg->target_bss;
#if defined(BCMDBG) || defined(WLMSG_ASSOC)
		if (WL_ASSOC_ON()) {
			char from_id[ETHER_ADDR_STR_LEN];
			char to_id[ETHER_ADDR_STR_LEN];
			bcm_ether_ntoa(&bsscfg->BSSID, from_id);
			bcm_ether_ntoa(&hdr->bssid, to_id);
			WL_ASSOC(("JOIN: IBSS Coalesce from BSSID %s to BSSID %s\n",
			          from_id, to_id));
			wlc_print_bcn_prb((uint8*)plcp,
				bcn_len + DOT11_MGMT_HDR_LEN + D11_PHY_HDR_LEN);
		}
#endif /* BCMDBG || WLMSG_ASSOC */
		/* The received beacon has a greater TSF time, so adopt its parameters */
		if (wlc_recv_parse_bcn_prb(wlc, wrxh, &hdr->bssid, TRUE, bcn, bcn_len,
		                      target_bss) == 0) {
			wlc_rate_hwrs_filter_sort_validate(&target_bss->rateset,
				&wlc->band->hw_rateset, FALSE,
				wlc->stf->txstreams);
			wlc_join_complete(bsscfg, wrxh, plcp, bcn, bcn_len);
		}
	}
#endif /* STA */
}

static void
wlc_frameaction_vs(wlc_info_t *wlc,
	struct dot11_management_header *hdr, uint8 *body, int body_len)
{
#ifdef WLP2P
	/* P2P action frame */
	if (P2P_ENAB(wlc->pub) &&
	    body_len >= P2P_AF_FIXED_LEN &&
	    bcmp(((wifi_p2p_action_frame_t *)body)->OUI, WFA_OUI, WFA_OUI_LEN) == 0 &&
	    ((wifi_p2p_action_frame_t *)body)->type == WFA_OUI_TYPE_P2P) {
		ASSERT(((wifi_p2p_action_frame_t *)body)->category == DOT11_ACTION_CAT_VS);
		wlc_p2p_process_action(wlc->p2p, hdr, body, body_len);
		return;
	}
#endif
#if defined(WIFI_REFLECTOR) || defined(RWL_WIFI)
	/* this is a Remote WL command */
	if (body_len > DOT11_OUI_LEN &&
	    ((body[1+DOT11_OUI_LEN] == RWL_WIFI_FIND_MY_PEER) ||
	     (body[1+DOT11_OUI_LEN] == RWL_WIFI_FOUND_PEER) ||
	     (body[1+DOT11_OUI_LEN] == RWL_WIFI_DEFAULT) ||
	     (body[1+DOT11_OUI_LEN] == RWL_ACTION_WIFI_FRAG_TYPE))) {
		wlc_recv_wifi_mgmtact(wlc->rwl, body, &hdr->sa);
		return;
	}
#endif
}

static void
wlc_frameaction_public(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh)
{
#ifdef WLP2P
	/* P2P public action frame */
	if (P2P_ENAB(wlc->pub) &&
	    body_len >= P2P_PUB_AF_FIXED_LEN &&
	    ((wifi_p2p_pub_act_frame_t *)body)->action == P2P_PUB_AF_ACTION &&
	    bcmp(((wifi_p2p_pub_act_frame_t *)body)->oui, WFA_OUI, WFA_OUI_LEN) == 0 &&
	    ((wifi_p2p_pub_act_frame_t *)body)->oui_type == WFA_OUI_TYPE_P2P) {
		ASSERT(((wifi_p2p_pub_act_frame_t *)body)->category == DOT11_ACTION_CAT_PUBLIC);
		wlc_p2p_process_public_action(wlc->p2p, hdr, body, body_len);
		return;
	}
#endif /* WLP2P */
#ifdef WL11N
	if (N_ENAB(wlc->pub) &&
	    body_len >= DOT11_ACTION_HDR_LEN)
		wlc_ht_publicaction(wlc, hdr, body, body_len, wrxh);
#endif
}

/*
 * Frame received, frame type FC_ACTION,
 *  action_category DOT11_ACTION_CAT_SPECT_MNG
 */
static void
wlc_recv_frameaction_specmgmt(uint action_id, wlc_info_t *wlc,
	struct dot11_management_header *hdr, uint8 *body, int body_len,
	int8 rssi, ratespec_t rspec)
{
	/* Spectrum Management action_id's */
	if (action_id == DOT11_SM_ACTION_M_REQ) {
		wlc_recv_measure_request(wlc, hdr, body, body_len);
	} else if (action_id == DOT11_SM_ACTION_M_REP) {
		wlc_recv_measure_report(wlc, hdr, body, body_len);
	} else if (action_id == DOT11_SM_ACTION_TPC_REQ) {
		wlc_recv_tpc_request(wlc, hdr, body, body_len, rssi, rspec);
	} else if (action_id == DOT11_SM_ACTION_TPC_REP) {
		wlc_recv_tpc_report(wlc, hdr, body, body_len, rssi, rspec);
	} else if (action_id == DOT11_SM_ACTION_CHANNEL_SWITCH) {
		wlc_recv_csa_action(wlc, hdr, body, body_len);
	} else if (action_id == DOT11_SM_ACTION_EXT_CSA) {
		wlc_recv_ext_csa_action(wlc, hdr, body, body_len);
	} else {
		wlc_send_action_err(wlc, hdr, body, body_len);
	}
}

static int wlc_find_nominal_req_pwr(ratespec_t rspec)
{
	int i;
	int rate;
	int nominal_req_pwr;
	static const struct {int rate; int pwr;} nominal_req_pwr_table[] = {
		{WLC_RATE_1M, -80},
		{WLC_RATE_2M, -80},
		{WLC_RATE_5M5, -76},
		{WLC_RATE_11M, -76},
		{WLC_RATE_6M, -82},
		{WLC_RATE_9M, -81},
		{WLC_RATE_12M, -79},
		{WLC_RATE_18M, -77},
		{WLC_RATE_24M, -74},
		{WLC_RATE_36M, -70},
		{WLC_RATE_48M, -66},
		{WLC_RATE_54M, -65},
		{0, -100}
	};

	if (IS_MCS(rspec)) {
		rate = WLC_RATE_6M;
	} else {
		rate = RSPEC2RATE(rspec);
	}

	/* Find the nominal required power for the request packet's rate */
	i = 0;
	nominal_req_pwr = 0;
	while (nominal_req_pwr_table[i].rate != 0) {
		if (nominal_req_pwr_table[i].rate == rate) {
			nominal_req_pwr = nominal_req_pwr_table[i].pwr;
			break;
		}
		i++;
	}

	return nominal_req_pwr;
}

static void
wlc_recv_tpc_request(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, int8 rssi, ratespec_t rspec)
{
	struct dot11_action_measure * action_hdr;
	struct ether_addr *ea = &hdr->sa;
	struct ether_addr *bssid = &hdr->bssid;
#if defined(BCMDBG_ERR) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG_ERR || WLMSG_INFORM */


	if (body_len < 3) {
		WL_ERROR(("wl%d: wlc_recv_tpc_request: got TPC Request from %s, but frame body len"
			" was %d, expected 3\n",
			wlc->pub->unit, bcm_ether_ntoa(ea, eabuf), body_len));
		return;
	}

	action_hdr = (struct dot11_action_measure *)body;

	WL_INFORM(("wl%d: wlc_recv_tpc_request: got TPC Request (token %d) from %s\n",
	           wlc->pub->unit, action_hdr->token, bcm_ether_ntoa(ea, eabuf)));

	wlc_send_tpc_report(wlc, ea, bssid, action_hdr->token, rssi, rspec);
}

static void
wlc_recv_tpc_report(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, int8 rssi, ratespec_t rspec)
{

	struct dot11_action_measure * action_hdr;
	int len;
	dot11_tpc_rep_t* rep_ie;
#ifdef BCMDBG
	char da[ETHER_ADDR_STR_LEN];
	char sa[ETHER_ADDR_STR_LEN];
	char bssid[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG */
#if defined(WL_AP_TPC)
	struct scb *scb;
	int nominal_req_pwr;
	uint8 reg_chan_pwr, cur_chan, txpwr_max;
#endif /* WL_AP_TPC */

	WL_REGULATORY(("Action Frame: DA %s SA %s BSSID %s\n",
	       bcm_ether_ntoa(&hdr->da, da), bcm_ether_ntoa(&hdr->sa, sa),
	       bcm_ether_ntoa(&hdr->bssid, bssid)));

	if (body_len < 3) {
		WL_INFORM(("Action frame body len was %d, expected > 3\n", body_len));
		return;
	}

	/* re-using action measure struct here also */
	action_hdr = (struct dot11_action_measure *)body;
	rep_ie = (dot11_tpc_rep_t*)action_hdr->data;
	len = body_len - DOT11_ACTION_MEASURE_LEN;

	WL_REGULATORY(("Action Frame: category %d action %d dialog token %d\n",
	       action_hdr->category, action_hdr->action, action_hdr->token));

	if (action_hdr->category != DOT11_ACTION_CAT_SPECT_MNG) {
		WL_INFORM(("Unexpected category, expected Spectrum Management %d\n",
			DOT11_ACTION_CAT_SPECT_MNG));
		return;
	}

	if (action_hdr->action != DOT11_SM_ACTION_TPC_REP) {
		WL_INFORM(("Unexpected action type (%d)\n", action_hdr->action));
		return;
	}

	if (len < 4) {
		WL_INFORM(("Malformed Action frame, less that an IE header length (4 bytes)"
			" remaining in buffer\n"));
		return;
	}

	if (rep_ie->id != DOT11_MNG_TPC_REPORT_ID) {
		WL_INFORM(("Unexpected IE (id %d len %d):\n", rep_ie->id, rep_ie->len));
		prhex(NULL, (uint8*)rep_ie + TLV_HDR_LEN, rep_ie->len);
		return;
	}

	if (rep_ie->len != 2) {
		WL_INFORM(("Unexpected TPC report IE len != 2\n"));
		return;
	}

	WL_REGULATORY(("%s (id %d len %d): tx_pwr:%d margin:%d\n", "TPC Report", rep_ie->id,
		rep_ie->len, (int8)rep_ie->tx_pwr, (int8)rep_ie->margin));

#if defined(WL_AP_TPC)

	nominal_req_pwr = wlc_find_nominal_req_pwr(rspec);

	cur_chan = CHSPEC_CHANNEL(wlc->home_chanspec);

	reg_chan_pwr = wlc_get_reg_max_power_for_channel(wlc->cmi, cur_chan, TRUE);

	txpwr_max = (wlc_phy_txpower_get_target_max((wlc_phy_t *)wlc->band->pi) +
		wlc->band->antgain) / WLC_TXPWR_DB_FACTOR;

	WL_REGULATORY(("wl%d: %s: Nominal req pwr: %d RSSI of packet:%d current channel:%d "
		"regulatory pwr for channel:%d max tx pwr:%d\n",
		wlc->pub->unit, __FUNCTION__,
		nominal_req_pwr, rssi, cur_chan, reg_chan_pwr, txpwr_max));

	/* Record the STA link margin now */
	if ((scb = wlc_scbfind(wlc, &hdr->sa)) != NULL) {

		/* record sta's link margin */
		scb->sta_link_margin = (int8)rep_ie->margin + (reg_chan_pwr - txpwr_max);

		/* record ap's link margin */
		scb->ap_link_margin = rssi - (nominal_req_pwr) + (reg_chan_pwr - rep_ie->tx_pwr);

		WL_REGULATORY(("wl%d:%s STAs link margin:%d APs link margin:%d\n", wlc->pub->unit,
			__FUNCTION__, scb->sta_link_margin, scb->ap_link_margin));
	} else {
		WL_INFORM(("did not find scb\n"));
		return;
	}

#endif /* WL_AP_TPC */
}

/* Validate the source of a measurement request */
bool
wlc_validate_measure_req(wlc_info_t *wlc, wlc_bsscfg_t *cfg,
	struct dot11_management_header *hdr)
{
	struct scb *scb;
	char eabuf[ETHER_ADDR_STR_LEN];

	BCM_REFERENCE(eabuf);

	/* is this a request from someone we should care about? */
	if (!cfg->associated) {
		WL_INFORM(("wl%d: wlc_recv_measure_request: ignoring request from %s since we are"
			" not in a BSS or IBSS\n",
			wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf)));
		return FALSE;
	} else if (BSSCFG_AP(cfg)) {
		if (ETHER_ISMULTI(&hdr->sa) ||
		    (scb = wlc_scbfind(wlc, &hdr->sa)) == NULL ||
		    !SCB_ASSOCIATED(scb)) {
			/* AP only accepts reqs from associated STAs */
			WL_INFORM(("wl%d: wlc_recv_measure_request: ignoring request from"
				" unassociated STA %s\n",
				wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf)));
			return FALSE;
		} else if (ETHER_ISMULTI(&hdr->da)) {
			/* AP only accepts unicast reqs */
			WL_INFORM(("wl%d: wlc_recv_measure_request: ignoring bcast/mcast request %s"
				" from associated STA %s\n",
				wlc->pub->unit, bcm_ether_ntoa(&hdr->da, eabuf),
				bcm_ether_ntoa(&hdr->sa, eabuf)));
			return FALSE;
		}
	} else if (cfg->BSS) {
		if (bcmp(hdr->sa.octet, cfg->BSSID.octet, ETHER_ADDR_LEN)) {
			/* STAs should only get requests from the AP */
			WL_INFORM(("wl%d: wlc_recv_measure_request: ignoring request from %s since"
				" it is not our AP\n",
				wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf)));
			return FALSE;
		}
	} else if (bcmp(hdr->bssid.octet, cfg->BSSID.octet, ETHER_ADDR_LEN)) {
		/* IBSS STAs should only get requests from other IBSS members */
		WL_INFORM(("wl%d: wlc_recv_measure_request: ignoring request from %s since it is in"
			" a foreign IBSS %s\n",
			wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf),
			bcm_ether_ntoa(&hdr->bssid, eabuf)));
			return FALSE;
	}

	return TRUE;
}

static void
wlc_recv_measure_request(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len)
{
	struct dot11_action_measure * action_hdr;
	int len;
	int ie_tot_len;
	int report_len;
	uint8 *report;
	dot11_meas_req_t* ie;
	dot11_meas_rep_t* report_ie;
#ifdef BCMDBG_ERR
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG_ERR */
	wlc_bsscfg_t *cfg = wlc->cfg;

#ifdef BCMDBG
	if (WL_INFORM_ON())
		wlc_print_measure_req_rep(wlc, hdr, body, body_len);
#endif /* BCMDBG */

	if (body_len < 3) {
		WL_ERROR(("wl%d: wlc_recv_measure_request: got Measure Request from %s, "
			  "but frame body len was %d, expected > 3\n",
			  wlc->pub->unit, bcm_ether_ntoa(&hdr->sa, eabuf), body_len));
		return;
	}

	action_hdr = (struct dot11_action_measure *)body;

	if (wlc_validate_measure_req(wlc, cfg, hdr) == FALSE)
		return;

	/* calculate the length of the report */
	report_len = 0;
	ie = (dot11_meas_req_t*)action_hdr->data;
	len = body_len - DOT11_ACTION_MEASURE_LEN;

	/* for each measurement request, calc the length of the report in the response */
	while (len > 2) {
		ie_tot_len = TLV_HDR_LEN + ie->len;

		if (ie->id != DOT11_MNG_MEASURE_REQUEST_ID ||
		    ie->len < DOT11_MNG_IE_MREQ_LEN ||
		    (ie->len >= 3 && (ie->mode & DOT11_MEASURE_MODE_ENABLE))) {
			/* ignore non-measure ie, short, or Mode == ENABLED requests */
		} else if (ie->type == DOT11_MEASURE_TYPE_BASIC) {
			/* Basic report with Unmeasured set */
			report_len += TLV_HDR_LEN + DOT11_MNG_IE_MREP_FIXED_LEN +
				DOT11_MEASURE_BASIC_REP_LEN;
		} else {
			/* CCA, RPI, or other req: Measure report with Incapable */
			report_len += TLV_HDR_LEN + DOT11_MNG_IE_MREP_FIXED_LEN;
		}

		ie = (dot11_meas_req_t*)((int8*)ie + ie_tot_len);
		len -= ie_tot_len;
	}

	/* allocate space and create the report */
	report = (uint8*)MALLOC(wlc->osh, report_len);
	if (report == NULL) {
		WL_ERROR(("wl%d: wlc_recv_measure_request: out of memory, malloced %d bytes\n",
			wlc->pub->unit, MALLOCED(wlc->osh)));
		return;
	}

	report_ie = (dot11_meas_rep_t*)report;
	ie = (dot11_meas_req_t*)action_hdr->data;
	len = body_len - DOT11_ACTION_MEASURE_LEN;

	/* for each measurement request, generate the report for the response */
	while (len > 2) {
		ie_tot_len = TLV_HDR_LEN + ie->len;
		if (ie->id != DOT11_MNG_MEASURE_REQUEST_ID) {
			WL_INFORM(("wl%d: wlc_recv_measure_request: got unexpected IE (id %d len"
				" %d), ignoring\n",
				wlc->pub->unit, ie->id, ie->len));
		} else if (ie->len >= 3 && (ie->mode & DOT11_MEASURE_MODE_ENABLE)) {
			WL_INFORM(("wl%d: wlc_recv_measure_request: got Measure Request mode Enable"
				" bit, ignoring\n",
				wlc->pub->unit));
		} else if (ie->len < DOT11_MNG_IE_MREQ_LEN) {
			WL_ERROR(("wl%d: wlc_recv_measure_request: got short Measure Request IE len"
				" %d, ignoring\n",
				wlc->pub->unit, ie->len));
		} else {
			if (ie->type == DOT11_MEASURE_TYPE_BASIC) {
				/* Basic report with Unmeasured set */
				report_ie->id = DOT11_MNG_MEASURE_REPORT_ID;
				report_ie->len = DOT11_MNG_IE_MREP_FIXED_LEN +
					DOT11_MEASURE_BASIC_REP_LEN;
				bzero((uint8*)&report_ie->token, report_ie->len);
				report_ie->token = ie->token;
				report_ie->mode = 0;
				report_ie->type = ie->type;
				report_ie->rep.basic.channel = ie->channel;
				bcopy(ie->start_time, report_ie->rep.basic.start_time, 8);
				bcopy(&ie->duration, &report_ie->rep.basic.duration, 2);
				report_ie->rep.basic.map = DOT11_MEASURE_BASIC_MAP_UNMEAS;
			} else {
				/* CCA, RPI, or other req: Measure report with Incapable */
				report_ie->id = DOT11_MNG_MEASURE_REPORT_ID;
				report_ie->len = DOT11_MNG_IE_MREP_FIXED_LEN;
				bzero((uint8*)&report_ie->token, report_ie->len);
				report_ie->token = ie->token;
				report_ie->mode = DOT11_MEASURE_MODE_INCAPABLE;
				report_ie->type = ie->type;
			}
			report_ie = (dot11_meas_rep_t*)((int8*)report_ie + TLV_HDR_LEN +
				report_ie->len);
		}

		ie = (dot11_meas_req_t*)((int8*)ie + ie_tot_len);
		len -= ie_tot_len;
	}

	ASSERT(((uint8*)report_ie - report) == (int)report_len);

	wlc_send_measure_report(wlc, &hdr->sa, &hdr->bssid, action_hdr->token, report, report_len);
	MFREE(wlc->osh, report, report_len);
}

static void
wlc_recv_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body, int body_len)
{
	struct dot11_action_frmhdr *action_hdr;
	dot11_chan_switch_ie_t *csa_ie;
	bcm_tlv_t *ext_ie;
	bcm_tlv_t *ies;
	uint ies_len;
	uint8 extch = DOT11_EXT_CH_NONE;

	action_hdr = (struct dot11_action_frmhdr *)body;

	ies = (bcm_tlv_t*)action_hdr->data;
	ies_len = body_len - DOT11_ACTION_HDR_LEN;

	csa_ie = (dot11_chan_switch_ie_t*)
	        bcm_parse_tlvs(ies, ies_len, DOT11_MNG_CHANNEL_SWITCH_ID);

	if (csa_ie == NULL || csa_ie->len < DOT11_SWITCH_IE_LEN) {
		WL_REGULATORY(("wl%d:%s: Bad CSA Spectrum Mngmt Action frame\n",
		               wlc->pub->unit, __FUNCTION__));
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);
		wlc_send_action_err(wlc, hdr, body, body_len);
		return;
	}

	/* check if we have an extension channel ie */
	if (N_ENAB(wlc->pub)) {
		/* Check for 11n spec IE first */
		ext_ie = bcm_parse_tlvs(ies, ies_len, DOT11_MNG_EXT_CHANNEL_OFFSET);
		if (ext_ie != NULL &&
		    ext_ie->len == DOT11_EXTCH_IE_LEN) {
			extch = ((dot11_extch_ie_t *)ext_ie)->extch;
		} else {
			uint8 extch_subtype = BRCM_EXTCH_IE_TYPE;

			/* Check for BRCM OUI format */
			ext_ie = wlc_find_vendor_ie(ies, ies_len, (const uint8*)BRCM_PROP_OUI,
			                            &extch_subtype, 1);
			if (ext_ie != NULL &&
			    ext_ie->len == BRCM_EXTCH_IE_LEN) {
				extch = ((dot11_brcm_extch_ie_t *)ext_ie)->extch;
			}
		}
	}

	WL_REGULATORY(("wl%d: wlc_recv_csa_action: mode %d, channel %d, count %d, extension %d\n",
	               wlc->pub->unit, csa_ie->mode, csa_ie->channel, csa_ie->count, extch));

#if defined(BCMDBG) && defined(AP)
	if (BSSCFG_AP(wlc->cfg)) {
		chanspec_t chspec;
		if (extch == DOT11_EXT_CH_NONE) {
			chspec = CH20MHZ_CHSPEC(csa_ie->channel);
		} else if (extch == DOT11_EXT_CH_UPPER) {
			chspec = CH40MHZ_CHSPEC(csa_ie->channel, WL_CHANSPEC_CTL_SB_UPPER);
		} else {
			chspec = CH40MHZ_CHSPEC(csa_ie->channel, WL_CHANSPEC_CTL_SB_LOWER);
		}

		wlc_ap_switch_channel(wlc->cfg, chspec, csa_ie->mode, csa_ie->count, 0);
	}
#endif

	return;
}

static void
wlc_recv_ext_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len)
{
	struct dot11_action_ext_csa *action_hdr;
	dot11_ext_csa_ie_t *req_ie;

	action_hdr = (struct dot11_action_ext_csa *)body;
	req_ie = &action_hdr->chan_switch_ie;
	/* valid the IE in this action frame */
	if (N_ENAB(wlc->pub) &&
	    body_len >= (int)(sizeof(struct dot11_action_ext_csa))) {
		if (req_ie->id == DOT11_MNG_EXT_CSA_ID) {
			WL_REGULATORY(("wl%d: wlc_recv_ext_csa_action: mode %d, reg %d, channel %d,"
				"count %d\n", wlc->pub->unit, req_ie->b.mode,
				req_ie->b.reg, req_ie->b.channel, req_ie->b.count));
			return;
		}
	}
	WL_REGULATORY(("wl%d: wlc_recv_ext_csa_action: unknown ID %d", wlc->pub->unit, req_ie->id));
}

#ifdef WL11N
static void
wlc_recv_public_csa_action(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len)
{
	wlc_bsscfg_t *cfg;
	struct dot11y_action_ext_csa *action_hdr;
	uint8 extch;
	wlc_csa_t *csa;

	if ((cfg = wlc_bsscfg_find_by_bssid(wlc, &hdr->bssid)) == NULL &&
	    (cfg = wlc_bsscfg_find_by_hwaddr(wlc, &hdr->da)) == NULL) {
#define	rxnobss	rxnoscb
		WLCNTINCR(wlc->pub->_cnt->rxnobss);
		return;
	}

	csa = cfg->csa;

	if (!BSSCFG_STA(cfg)) {
		WL_ERROR(("wl%d.%d: %s: not a STA\n",
		          wlc->pub->unit, WLC_BSSCFG_IDX(cfg), __FUNCTION__));
		return;
	}

	if (body_len != (sizeof(struct dot11y_action_ext_csa))) {
		WL_ERROR(("wl%d: %s: Invalid len %d != %d\n",	wlc->pub->unit, __FUNCTION__,
			body_len, (int)(TLV_HDR_LEN + sizeof(struct dot11_csa_body))));
		return;
	}

	action_hdr = (struct dot11y_action_ext_csa *)body;
	/* valid the IE in this action frame */
	WL_INFORM(("wl%d: %s: mode %d, reg %d, channel %d, count %d\n",
		wlc->pub->unit, __FUNCTION__, action_hdr->b.mode, action_hdr->b.reg,
		action_hdr->b.channel, action_hdr->b.count));
	csa->csa.mode = action_hdr->b.mode;
	csa->csa.count = action_hdr->b.count;
	extch = wlc_rclass_extch_get(wlc->cmi, action_hdr->b.reg);
	csa->csa.chspec = wlc_ht_chanspec(wlc, action_hdr->b.channel, extch);
	csa->csa.reg = action_hdr->b.reg;

#ifdef STA
	if (cfg->associated &&
	    bcmp(&hdr->bssid, &cfg->BSSID, ETHER_ADDR_LEN) == 0) {
		wlc_csa_channel_switch(wlc, cfg);
	}
#endif /* STA */
}
#endif /* WL11N */

static void
wlc_recv_measure_report(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len)
{
#ifdef BCMDBG
	if (WL_INFORM_ON())
		wlc_print_measure_req_rep(wlc, hdr, body, body_len);
#endif /* BCMDBG */
}

#ifdef BCMDBG
static void
wlc_print_measure_req_rep(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body,
	int body_len)
{
	struct dot11_action_measure * action_hdr;
	int len;
	int ie_tot_len;
	dot11_meas_req_t* req_ie;
	uint32 start_h, start_l;
	uint16 dur;
	const char *action_name;
	uint8 legal_id;
	bool is_request;
	char da[ETHER_ADDR_STR_LEN];
	char sa[ETHER_ADDR_STR_LEN];
	char bssid[ETHER_ADDR_STR_LEN];

	printf("Action Frame: DA %s SA %s BSSID %s\n",
	       bcm_ether_ntoa(&hdr->da, da), bcm_ether_ntoa(&hdr->sa, sa),
	       bcm_ether_ntoa(&hdr->bssid, bssid));

	if (body_len < 3) {
		printf("Action frame body len was %d, expected > 3\n", body_len);
		return;
	}

	action_hdr = (struct dot11_action_measure *)body;
	req_ie = (dot11_meas_req_t*)action_hdr->data;
	len = body_len - DOT11_ACTION_MEASURE_LEN;

	printf("Action Frame: category %d action %d dialog token %d\n",
	       action_hdr->category, action_hdr->action, action_hdr->token);

	if (action_hdr->category != DOT11_ACTION_CAT_SPECT_MNG) {
		printf("Unexpected category, expected Spectrum Management %d\n",
			DOT11_ACTION_CAT_SPECT_MNG);
		return;
	}

	if (action_hdr->action == DOT11_SM_ACTION_M_REQ) {
		action_name = "Measurement Request";
		legal_id = DOT11_MNG_MEASURE_REQUEST_ID;
		is_request = TRUE;
	} else if (action_hdr->action == DOT11_SM_ACTION_M_REP) {
		action_name = "Measurement Report";
		legal_id = DOT11_MNG_MEASURE_REPORT_ID;
		is_request = FALSE;
	} else {
		printf("Unexpected action type, expected Measurement Request (%d) or Report (%d)\n",
		       DOT11_MNG_MEASURE_REQUEST_ID, DOT11_MNG_MEASURE_REPORT_ID);
		return;
	}

	while (len > 0) {
		if (len < 2) {
			printf("Malformed Action frame, less that an IE header length (2 bytes)"
				" remaining in buffer\n");
			break;
		}
		if (req_ie->id != legal_id) {
			printf("Unexpected IE (id %d len %d):\n", req_ie->id, req_ie->len);
			prhex(NULL, (uint8*)req_ie + TLV_HDR_LEN, req_ie->len);
			goto next_ie;
		}
		if (req_ie->len < DOT11_MNG_IE_MREQ_FIXED_LEN) {
			printf("%s (id %d len %d): len less than minimum of %d\n",
			       action_name, req_ie->id, req_ie->len, DOT11_MNG_IE_MREQ_FIXED_LEN);
			prhex("IE data", (uint8*)req_ie + TLV_HDR_LEN, req_ie->len);
			goto next_ie;
		}
		printf("%s (id %d len %d): measure token %d mode 0x%02x type %d%s\n",
		       action_name, req_ie->id, req_ie->len, req_ie->token, req_ie->mode,
		       req_ie->type,
		       (req_ie->type == DOT11_MEASURE_TYPE_BASIC) ? " \"Basic\"" :
		       ((req_ie->type == DOT11_MEASURE_TYPE_CCA) ? " \"CCA\"" :
			((req_ie->type == DOT11_MEASURE_TYPE_RPI) ? " \"RPI Histogram\"" : "")));

		/* more data past fixed length portion of request/report? */

		if (req_ie->len <= DOT11_MNG_IE_MREP_FIXED_LEN) {
			/* just the fixed bytes of request/report present */
			goto next_ie;
		}

		/* here if more than fixed length portion of request/report */

		if (is_request && (req_ie->mode & DOT11_MEASURE_MODE_ENABLE)) {
			prhex("Measurement Request variable data (should be null since mode Enable"
				" is set)",
				&req_ie->channel, req_ie->len - 3);
			goto next_ie;
		}

		if (!is_request &&
		    (req_ie->mode & (DOT11_MEASURE_MODE_LATE |
			DOT11_MEASURE_MODE_INCAPABLE |
			DOT11_MEASURE_MODE_REFUSED))) {
			prhex("Measurement Report variable data (should be null since mode"
				" Late|Incapable|Refused is set)",
				&req_ie->channel, req_ie->len - DOT11_MNG_IE_MREP_FIXED_LEN);
			goto next_ie;
		}

		if (req_ie->type != DOT11_MEASURE_TYPE_BASIC &&
		    req_ie->type != DOT11_MEASURE_TYPE_CCA &&
		    req_ie->type != DOT11_MEASURE_TYPE_RPI) {
			prhex("variable data", &req_ie->channel, req_ie->len -
				DOT11_MNG_IE_MREP_FIXED_LEN);
			goto next_ie;
		}

		bcopy(req_ie->start_time, &start_l, 4);
		bcopy(&req_ie->start_time[4], &start_h, 4);
		bcopy(&req_ie->duration, &dur, 2);
		start_l = ltoh32(start_l);
		start_h = ltoh32(start_h);
		dur = ltoh16(dur);

		printf("%s variable data: channel %d start time %08X:%08X dur %d TU\n",
		       action_name, req_ie->channel, start_h, start_l, dur);

		if (req_ie->len > DOT11_MNG_IE_MREQ_LEN) {
			prhex("additional data", (uint8*)req_ie + TLV_HDR_LEN +
				DOT11_MNG_IE_MREQ_LEN, req_ie->len - DOT11_MNG_IE_MREQ_LEN);
		}

	next_ie:
		ie_tot_len = TLV_HDR_LEN + req_ie->len;
		req_ie = (dot11_meas_req_t*)((int8*)req_ie + ie_tot_len);
		len -= ie_tot_len;
	}
}
#endif /* BCMDBG */

#ifdef WL11N
static void
wlc_recv_public_ht_action(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh)
{
	uint8 *tlvs;
	uint tlvs_len;
	bcm_tlv_t *obss_coex_tlv;
	uint8 coex_bits;
	int rx_bandunit;
	struct scb *scb;
	wlc_bsscfg_t *cfg = NULL;

	rx_bandunit = CHANNEL_BANDUNIT(wlc, WLC_RX_CHANNEL(&wrxh->rxhdr));
	scb = wlc_scbfindband(wlc, &hdr->sa, rx_bandunit);

	if (scb != NULL) {
		cfg = SCB_BSSCFG(scb);
		ASSERT(cfg != NULL);
	}
	else if ((cfg = wlc_bsscfg_find_by_bssid(wlc, &hdr->bssid)) == NULL &&
	         (cfg = wlc_bsscfg_find_by_hwaddr(wlc, &hdr->da)) == NULL) {
#define	rxnobss	rxnoscb
		WLCNTINCR(wlc->pub->_cnt->rxnobss);
		return;
	}

	if (!N_ENAB(wlc->pub) || !COEX_ACTIVE(wlc))
		return;

	/* check validity of action frame before update */
	tlvs_len = body_len - DOT11_ACTION_HDR_LEN;
	tlvs = (uint8 *)body + DOT11_ACTION_HDR_LEN;

	obss_coex_tlv = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_HT_BSS_COEXINFO_ID);

	coex_bits = wlc_ht_coex_ie_chk(wlc, obss_coex_tlv);
	WL_COEX(("wl%d: %s: OBSS Coexistence Public Action frame received, Coex"
	         " Info bits 0x%02x\n", wlc->pub->unit, __FUNCTION__, coex_bits));

	if (coex_bits) {
		uint8 chan;
		if (CHSPEC_IS40(wlc->home_chanspec))
			chan = wf_chspec_ctlchan(wlc->home_chanspec);
		else
			chan = CHSPEC_CHANNEL(wlc->home_chanspec);
		if (chan <= CH_MAX_2G_CHANNEL)
			/* update coexistence bits for current channel */
			wlc->obss->coex_map[chan] = coex_bits & ~WL_COEX_INFO_REQ;
	}

	/* need to notify the current AP, 40-intolerant detected
	 * from from a STA or non-associated AP
	 */
	if (cfg->associated && !SCAN_IN_PROGRESS(wlc->scan) &&
	    (coex_bits & WL_COEX_40MHZ_INTOLERANT)) {
		if (!scb && !WLC_IS_CURRENT_BSSID(cfg, &hdr->bssid))
			wlc_ht_send_action_obss_coex(wlc, WL_COEX_WIDTH20, NULL,
			                             wlc_scbfind(wlc, &cfg->BSSID));
	}

	if (AP_ENAB(wlc->pub) && COEX_ACTIVE(wlc)) {
		bcm_tlv_t *obss_chanlist_tlv =
		        bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID);

		(void)obss_chanlist_tlv;

		/* AP received Trigger event B or C (TE-B, TE-C) */
		if ((coex_bits & WL_COEX_40MHZ_INTOLERANT) ||
		    (coex_bits & WL_COEX_WIDTH20))
			wlc_ht_ap_coex_tebc_proc(wlc);

		/* AP process the channel list received
		 * This is Trigger Event D (TE-D)
		 */
		if (wlc_ht_ap_coex_ted_chk(wlc, obss_chanlist_tlv, coex_bits)) {
			wlc_ht_coex_update_permit(wlc, FALSE);
			wlc_ht_coex_update_fid_time(wlc);
			if (CHSPEC_IS40(wlc->home_chanspec))
				wlc_ht_coex_switch_bw(wlc, TRUE);
		}
	}

	/* reply if INFO_REQ bit is set and from associated AP */
	if (scb && (coex_bits & WL_COEX_INFO_REQ)) {
		coex_bits = 0;
		if (WLC_WIDTH20_DET(wlc))
			coex_bits |= WL_COEX_WIDTH20;
		if (WLC_INTOL40_DET(wlc))
			coex_bits |= WL_COEX_40MHZ_INTOLERANT;
		wlc_ht_send_action_obss_coex(wlc, coex_bits, NULL, scb);
	}

	return;
}

static void
wlc_ht_publicaction(wlc_info_t *wlc, struct dot11_management_header *hdr,
	uint8 *body, int body_len, wlc_d11rxhdr_t *wrxh)
{
	uint8 action_id;

	WL_TRACE(("wl%d: wlc_ht_publicaction\n", wlc->pub->unit));

	if (body_len < DOT11_ACTION_HDR_LEN + TLV_HDR_LEN) {
		WL_ERROR(("wl%d: %s: Invalid len %d\n",	wlc->pub->unit, __FUNCTION__, body_len));
		return;
	}

	action_id = body[DOT11_ACTION_ACT_OFF];

	WL_INFORM(("wl%d: %s: recv Action frame %d\n", wlc->pub->unit, __FUNCTION__, action_id));

	switch (action_id) {
	case DOT11_PUB_ACTION_BSS_COEX_MNG:
		wlc_recv_public_ht_action(wlc, hdr, body, body_len, wrxh);
		break;
	case DOT11_PUB_ACTION_CHANNEL_SWITCH:
		wlc_recv_public_csa_action(wlc, hdr, body, body_len);
		break;
	default:
		WL_INFORM(("wl %d: unrecognised Public action frame\n", wlc->pub->unit));
		break;
	}
}

static void
wlc_frameaction_ht(wlc_info_t *wlc, uint action_id, struct scb *scb,
	struct dot11_management_header *hdr, uint8 *body, int body_len)
{
	struct dot11_action_ht_mimops *ht_mimops;
	struct dot11_action_ht_ch_width *ht_ch_width;
	uint32 scb_is40_old;
	wlc_bsscfg_t *cfg;

	if (scb == NULL)
		return;

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

	WL_INFORM(("wl%d: Rcvd HT action frame with id %d\n", wlc->pub->unit, action_id));

	switch (action_id) {
	case DOT11_ACTION_ID_HT_MIMO_PS:
		ht_mimops = (struct dot11_action_ht_mimops *)body;

		/* update the cached mimo_psmode */
		if (N_ENAB(wlc->pub)) {
			bool mimops_enabled = scb->ht_mimops_enabled;
			bool mimops_rtsmode = scb->ht_mimops_rtsmode;
			/* 802.11n Draft 1.04 spec support 4 bytes format
			 * and Draft 1.06 spec support 3 bytes format
			 */
			if (body_len == 3) {
				mimops_enabled = ((ht_mimops->control & SM_PWRSAVE_ENABLE) ?
				                  TRUE:FALSE);
				mimops_rtsmode = ((ht_mimops->control & SM_PWRSAVE_MODE) ?
				                  TRUE:FALSE);
			} else if (body_len == 4) {
				mimops_enabled = (ht_mimops->control ? TRUE:FALSE);
				mimops_rtsmode = (*(&ht_mimops->control+1) ? TRUE:FALSE);
			} else
				break;

			if ((scb->ht_mimops_enabled != mimops_enabled) ||
			    (scb->ht_mimops_rtsmode != mimops_rtsmode)) {
				scb->ht_mimops_enabled = mimops_enabled;
				scb->ht_mimops_rtsmode = mimops_rtsmode;
				wlc_scb_ratesel_init(wlc, scb);
			}
		}
		break;

	case DOT11_ACTION_ID_HT_CH_WIDTH:
		ht_ch_width = (struct dot11_action_ht_ch_width *)body;

		/* select the desired tx bandwidth (per frametype) */
		scb_is40_old = scb->flags & SCB_IS40;
		if (ht_ch_width->ch_width && (scb->ht_capabilities & HT_CAP_40MHZ)) {
			scb->flags |= SCB_IS40;
		} else {
			scb->flags &= ~SCB_IS40;
		}

		/* if bandwidth changed, reinit rate selection */
		if (scb_is40_old != (scb->flags & SCB_IS40)) {
			wlc_scb_ratesel_init(wlc, scb);
		}

		/* Check for association of a 20MHz only HT STA in 40MHz operating */
		if (BSSCFG_AP(cfg) &&
		    !(scb->flags & SCB_IS40) &&
		    CHSPEC_IS40(wlc->home_chanspec))
			cfg->prot_cond->ht20in40_assoc = TRUE;
		break;

	default:
		WL_ERROR(("wl %d: unrecognised HT action frame\n", wlc->pub->unit));
		break;
	}
}

void *
wlc_send_action_ht_mimops(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, uint8 mimops_mode)
{
	void *p;
	uint8* pbody;
	uint body_len;
	struct dot11_action_ht_mimops * action_hdr;
	const struct ether_addr *ea;
	struct scb *scb;

	ASSERT(mimops_mode != 2);
	if ((mimops_mode == 2) || (mimops_mode > 3))
		return NULL;

	body_len = sizeof(struct dot11_action_ht_mimops);

	if (BSSCFG_STA(bsscfg)) {
		ea = &bsscfg->BSSID;
		scb = wlc_scbfindband(wlc, ea, CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec));
	} else {
		ea = &ether_bcast;
		scb = WLC_BCMCSCB_GET(wlc, bsscfg);
	}
	ASSERT(scb != NULL);

	if ((p = wlc_frame_get_action(wlc, FC_ACTION, ea, &bsscfg->cur_etheraddr,
	        &bsscfg->BSSID, body_len, &pbody, DOT11_ACTION_CAT_HT)) == NULL) {
		return NULL;
	}

	action_hdr = (struct dot11_action_ht_mimops *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_HT;
	action_hdr->action = DOT11_ACTION_ID_HT_MIMO_PS;

	/* The frame format meets the 802.11n Draft 1.06 spec */
	switch (mimops_mode) {
		case 0: action_hdr->control = SM_PWRSAVE_ENABLE;
			break;
		case 1: action_hdr->control = (SM_PWRSAVE_ENABLE | SM_PWRSAVE_MODE);
			break;
		case 2: ASSERT(0); /* invalid case */
		case 3: action_hdr->control = 0;
			break;
	}

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, scb);

	return p;
}

void
wlc_mimops_action_ht_send(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, uint8 mimops_mode)
{
	void *p;


	if (BSSCFG_STA(bsscfg) && (bsscfg->mimops_ActionPending) &&
	    !(bsscfg->mimops_ActionRetry & WLC_MIMOPS_RETRY_NOACK))
		return;

	p = wlc_send_action_ht_mimops(wlc, bsscfg, mimops_mode);

	if (BSSCFG_AP(bsscfg))
		return;
	if (!p)
		bsscfg->mimops_ActionRetry |= WLC_MIMOPS_RETRY_SEND;
	else {
		bsscfg->mimops_ActionRetry &= ~WLC_MIMOPS_RETRY_SEND;
		bsscfg->mimops_ActionPending = TRUE;
		bsscfg->mimops_ActionPM = mimops_mode;
		wlc_pkt_callback_register(wlc, wlc_mimops_action_ht_complete,
		                          (void *)(uintptr)bsscfg->ID, p);
	}
}

void
wlc_ht_mimops_cap_update(wlc_info_t *wlc, uint8 mimops_mode)
{
	wlc->ht_cap.cap &= ~HT_CAP_MIMO_PS_MASK;
	wlc->ht_cap.cap |= (mimops_mode << HT_CAP_MIMO_PS_SHIFT);

	if (AP_ENAB(wlc->pub) && wlc->clk) {
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, TRUE);
	}
}

static void
wlc_mimops_action_ht_complete(wlc_info_t *wlc, uint txstatus, void *arg)
{
	wlc_bsscfg_t *cfg = wlc_bsscfg_find_by_ID(wlc, (uint16)(uintptr)arg);

	/* in case bsscfg is freed before this callback is invoked */
	if (cfg == NULL) {
		WL_ERROR(("wl%d: %s: unable to find bsscfg by ID %p\n",
		          wlc->pub->unit, __FUNCTION__, arg));
		return;
	}

	/* no ack */
	if (!(txstatus & TX_STATUS_ACK_RCV)) {
		WL_ERROR(("wlc_mimops_action_ht_complete(): no ACK received!\n"));
		/* keep retry in watch_dog, send HT MS Power Save Action Frame again */
		cfg->mimops_ActionRetry |= WLC_MIMOPS_RETRY_NOACK;
		return;
	}

	cfg->mimops_ActionRetry &= ~WLC_MIMOPS_RETRY_NOACK;
	if (cfg->mimops_ActionPM == HT_CAP_MIMO_PS_ON) {
		wlc_ht_mimops_cap_update(wlc, HT_CAP_MIMO_PS_ON);
		/* only when HT action frame is ACKed, do we update the Rx chain HW state */
		wlc_phy_stf_chain_set(wlc->band->pi, wlc->stf->txchain, wlc->stf->rxchain);
	}
	cfg->mimops_ActionPending = FALSE;

	if (cfg->mimops_ActionPM != cfg->mimops_PM)
		wlc_mimops_action_ht_send(wlc, cfg, cfg->mimops_PM);

}

static uint8*
wlc_write_obss_coex_ie(uint8* cp, uint8 coex_bits)
{
	dot11_obss_coex_t *coex_ie = (dot11_obss_coex_t *)cp;

	coex_ie->id = DOT11_MNG_HT_BSS_COEXINFO_ID;
	coex_ie->len = DOT11_OBSS_COEXINFO_LEN;
	coex_ie->info = 0;
	if (coex_bits & WL_COEX_INFO_REQ)
		coex_ie->info |= DOT11_OBSS_COEX_INFO_REQ;
	if (coex_bits & WL_COEX_40MHZ_INTOLERANT)
		coex_ie->info |= DOT11_OBSS_COEX_40MHZ_INTOLERANT;
	if (coex_bits & WL_COEX_WIDTH20)
		coex_ie->info |= DOT11_OBSS_COEX_20MHZ_WIDTH_REQ;

	cp += (TLV_HDR_LEN + DOT11_OBSS_COEXINFO_LEN);
	return cp;
}

static uint8*
wlc_write_obss_intol_chanlist_ie(wlc_info_t *wlc, uint8* cp, uint8 len, uint8 *coex_map)
{
	uint8 *p, buf_len;
	dot11_obss_chanlist_t *chanlist_ie = (dot11_obss_chanlist_t *)cp;

	ASSERT(CHSPEC_IS2G(wlc->home_chanspec));

	if (!coex_map || len == 0) {
		WL_ERROR(("NO channel list\n"));
		return cp;
	}

	p = cp;
	buf_len = len;
	if ((wlc_japan(wlc) == TRUE) && coex_map[14] && len) {
		/* Japan can have 2 regclass in 2G band,
		 * take care first IE (chan 14)
		 */
		chanlist_ie->id = DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID;
		chanlist_ie->len = DOT11_OBSS_CHANLIST_FIXED_LEN + 1;
		chanlist_ie->regclass = wlc_get_regclass(wlc->cmi, CH20MHZ_CHSPEC(14));
		chanlist_ie->chanlist[0] = 14;
		len -= (TLV_HDR_LEN + chanlist_ie->len);	/* first IE takes 4 bytes */
		cp += (TLV_HDR_LEN + chanlist_ie->len);		/* adjust the pointer */
	}
	/* take care all remaining channel in 2G band */
	chanlist_ie = (dot11_obss_chanlist_t *)cp;
	chanlist_ie->id = DOT11_MNG_HT_BSS_CHANNEL_REPORT_ID;
	/* the len includes id & len */
	chanlist_ie->len = len - TLV_HDR_LEN;
	chanlist_ie->regclass = wlc_get_regclass(wlc->cmi, CH20MHZ_CHSPEC(1));
	cp = chanlist_ie->chanlist;
	if (chanlist_ie->len > DOT11_OBSS_CHANLIST_FIXED_LEN) {
		uint8 i;
		for (i = 0; i <= CH_MAX_2G_CHANNEL; i++) {
			if (coex_map[i]) {
				*cp++ = i;
				WL_ERROR(("coex channel %d\n", i));
			}
		}
	}
	ASSERT((cp - p) == (int)buf_len);
	return cp;
}

static uint
wlc_get_BSSintol_2Gchanlist_len(wlc_info_t *wlc, uint8 *coex_map)
{
	uint i, len;

	ASSERT(CHSPEC_IS2G(wlc->home_chanspec));

	WL_TRACE(("wl%d: wlc_get_BSSintol_2Gchanlist_len\n", wlc->pub->unit));
	if (!coex_map)
		return 0;
	/* regulatory class in 2.4G band, for chan 1-13 */
	for (i = 0, len = 0; i <= 13; i++) {
		if (coex_map[i])
			len++;
	}
	/* include header if there are interference channels to report */
	if (len)
		len += TLV_HDR_LEN + DOT11_OBSS_CHANLIST_FIXED_LEN;

	/* Japan has second regulatory class in 2.4G band, chan 14 & regulatory class */
	if ((wlc_japan(wlc) == TRUE) && coex_map[14])
		len += TLV_HDR_LEN + DOT11_OBSS_CHANLIST_FIXED_LEN + 1;

	return len;
}

static int
wlc_ht_send_action_obss_coex(wlc_info_t *wlc, uint8 coex_bits, uint8 *coex_map, struct scb *scb)
{
	void *p;
	uint8 *end, *pbody;
	uint body_len;
	struct dot11_action_frmhdr *action_hdr;
	uint chanlist_len = 0;

	WL_TRACE(("wl%d: %s\n", wlc->pub->unit, __FUNCTION__));

	if (!CHSPEC_IS2G(wlc->home_chanspec)) {
		WL_ERROR(("wl%d: %s: Not in 2G band\n", wlc->pub->unit, __FUNCTION__));
	        return BCME_BADBAND;
	}

	if (!scb) {
		WL_ERROR(("wl%d: %s: scb = NULL\n", wlc->pub->unit, __FUNCTION__));
		return -1;
	}

	if (!SCB_COEX_CAP(scb)) {
		WL_COEX(("wl%d: %s: scb don't support Coexistence\n",
		         wlc->pub->unit, __FUNCTION__));
		return -1;
	}

	/* Coexistence action frame consist of 20/40 BSS Coexistence IE +
	 * 20/40 BSS Intolerant Channel Report.
	 * 20/40 BSS Coexistence IE:
	 * -------------------
	 * | ID | LEN | INFO |
	 * -------------------
	 * 20/40 BSS Intolerant Channel Report IE:
	 * ------------------------------------
	 * | ID | LEN | RClass | Channel list |
	 * ------------------------------------
	 * Variable len : Channel list
	 */
	body_len = DOT11_ACTION_HDR_LEN + sizeof(dot11_obss_coex_t);
	/* chanlist_len include IE hdr + 1 or more BSS intolerant
	 * Channel Report IE.
	 */
	chanlist_len = wlc_get_BSSintol_2Gchanlist_len(wlc, coex_map);
	body_len += chanlist_len;

	if ((p = wlc_frame_get_action(wlc, FC_ACTION, &scb->ea, &scb->bsscfg->cur_etheraddr,
		&scb->bsscfg->BSSID, body_len, &pbody, DOT11_ACTION_CAT_PUBLIC)) == NULL)
		return -1;

	action_hdr = (struct dot11_action_frmhdr *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_PUBLIC;
	action_hdr->action = DOT11_PUB_ACTION_BSS_COEX_MNG;
	end = wlc_write_obss_coex_ie(action_hdr->data, coex_bits);
	end = wlc_write_obss_intol_chanlist_ie(wlc, end, (uint8)chanlist_len, coex_map);

	ASSERT((end - pbody) == (int)body_len);

#ifdef BCMDBG
	{
	char da[ETHER_ADDR_STR_LEN];
	WL_COEX(("wl%d: %s: send action frame to %s\n", wlc->pub->unit, __FUNCTION__,
		bcm_ether_ntoa(&scb->ea, da)));
	}
#endif

	wlc_sendmgmt(wlc, p, SCB_WLCIFP(scb)->qi, scb);

	return 0;
}

#ifdef BCMDBG
static void
wlc_get_mcsset(wlc_info_t *wlc, void *arg, bool istx)
{
	uint8 streams = istx ? wlc->stf->txstreams : wlc->stf->rxstreams;
	uint8 *mcs = (uint8*)arg;
	int i;

	memset(mcs, 0, MCSSET_LEN);
	for (i = 0; i < streams; i++)
		mcs[i] = 0xff;
}
#endif /* BCMDBG */
#endif /* WL11N */

#if defined(BCM_DCS) && defined(STA)
static int
wlc_send_action_brcm_dcs(wlc_info_t *wlc, wl_bcmdcs_data_t *data, struct scb *scb)
{
	void *p;
	uint8 *pbody;
	uint body_len;
	dot11_action_vs_frmhdr_t *action_vs_hdr;
	uint32 reason;
	chanspec_t channel_spec;

	if (!scb) {
		WL_ERROR(("wl%d: %s: scb = NULL\n", wlc->pub->unit, __FUNCTION__));
		return BCME_ERROR;
	}

	body_len = DOT11_ACTION_VS_HDR_LEN + sizeof(wl_bcmdcs_data_t);

	if ((p = wlc_frame_get_action(wlc, FC_ACTION, &scb->ea, &scb->bsscfg->cur_etheraddr,
		&scb->bsscfg->BSSID, body_len, &pbody, DOT11_ACTION_CAT_VS)) == NULL)
		return BCME_NOMEM;

	action_vs_hdr = (dot11_action_vs_frmhdr_t *)pbody;

	action_vs_hdr->category  = DOT11_ACTION_CAT_VS;
	action_vs_hdr->OUI[0]    = BCM_ACTION_OUI_BYTE0;
	action_vs_hdr->OUI[1]    = BCM_ACTION_OUI_BYTE1;
	action_vs_hdr->OUI[2]    = BCM_ACTION_OUI_BYTE2;
	action_vs_hdr->type      = BCM_ACTION_RFAWARE;
	action_vs_hdr->subtype   = BCM_ACTION_RFAWARE_DCS;

	reason = htol32(data->reason);
	bcopy(&reason, &action_vs_hdr->data[0], sizeof(uint32));
	channel_spec = htol16(data->chspec);
	bcopy(&channel_spec, &action_vs_hdr->data[4], sizeof(chanspec_t));

#ifdef BCMDBG
	{
		char da[ETHER_ADDR_STR_LEN];
		WL_INFORM(("wl%d: %s: send action frame to %s\n", wlc->pub->unit, __FUNCTION__,
			bcm_ether_ntoa(&scb->ea, da)));
	}
#endif
	wlc_sendmgmt(wlc, p, SCB_WLCIFP(scb)->qi, scb);

	return 0;
}

#endif /* BCM_DCS && STA */

uint8 *
wlc_write_csa_body(wl_chan_switch_t *csa, uint8 *cp)
{
	struct dot11_csa_body *b = (struct dot11_csa_body *)cp;
	b->mode = csa->mode;
	b->reg = csa->reg;
	b->channel = wf_chspec_ctlchan(csa->chspec);
	b->count = csa->count;
	cp += sizeof(struct dot11_csa_body);
	return cp;
}

uint8 *
wlc_write_ext_csa_ie(wl_chan_switch_t *csa, uint8 *cp)
{
	dot11_ext_csa_ie_t *chan_switch_ie = (dot11_ext_csa_ie_t *)cp;
	chan_switch_ie->id = DOT11_MNG_EXT_CSA_ID;
	chan_switch_ie->len = DOT11_EXT_CSA_IE_LEN;
	cp += TLV_HDR_LEN;
	cp = wlc_write_csa_body(csa, cp);
	return cp;
}

uint8 *
wlc_write_csa_ie(wl_chan_switch_t *csa, uint8 *cp, int buflen)
{
	dot11_chan_switch_ie_t *chan_switch_ie;

	/* perform buffer length check. */
	/* if not big enough, return buffer untouched */
	BUFLEN_CHECK_AND_RETURN((TLV_HDR_LEN + DOT11_SWITCH_IE_LEN), buflen, cp);

	chan_switch_ie = (dot11_chan_switch_ie_t *)cp;
	chan_switch_ie->id = DOT11_MNG_CHANNEL_SWITCH_ID;
	chan_switch_ie->len = DOT11_SWITCH_IE_LEN;
	chan_switch_ie->mode = csa->mode;
	chan_switch_ie->channel = wf_chspec_ctlchan(csa->chspec);
	chan_switch_ie->count = csa->count;
	cp += (TLV_HDR_LEN + DOT11_SWITCH_IE_LEN);
	return cp;
}

uint8 *
wlc_write_extch_ie(chanspec_t chspec, uint8 *cp, int buflen)
{
	dot11_extch_ie_t *extch_ie = (dot11_extch_ie_t *)cp;

	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN((TLV_HDR_LEN + DOT11_EXTCH_IE_LEN), buflen, cp);

	extch_ie->id = DOT11_MNG_EXT_CHANNEL_OFFSET;
	extch_ie->len = DOT11_EXTCH_IE_LEN;
	if (!CHSPEC_IS40(chspec))
		extch_ie->extch = DOT11_EXT_CH_NONE;
	else
		extch_ie->extch = CHSPEC_SB_UPPER(chspec) ?
			DOT11_EXT_CH_LOWER : DOT11_EXT_CH_UPPER;
	cp += (TLV_HDR_LEN + DOT11_EXTCH_IE_LEN);
	return cp;
}

void
wlc_send_tpc_request(wlc_info_t *wlc, struct ether_addr *da)
{
	void *p;
	uint8* pbody;
	uint8* end;
	uint body_len;
	struct dot11_action_measure * action_hdr;
	wlc_bsscfg_t *bsscfg = wlc->cfg;
	struct scb *scb = NULL;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */

	WL_INFORM(("wl%d: %s: sending TPC Request to %s\n",
	           wlc->pub->unit, __FUNCTION__, bcm_ether_ntoa(da, eabuf)));

	/* TPC Request frame is
	 * 3 bytes Action Measure Req frame
	 * 2 bytes empty TPC Request IE
	 */
	body_len = DOT11_ACTION_MEASURE_LEN + TLV_HDR_LEN;

	p = wlc_frame_get_action(wlc, FC_ACTION, da, &bsscfg->cur_etheraddr, &bsscfg->BSSID,
	                       body_len, &pbody, DOT11_ACTION_CAT_SPECT_MNG);
	if (p == NULL) {
		WL_INFORM(("wl%d: %s: no memory for TPC Request\n",
		           wlc->pub->unit, __FUNCTION__));
		return;
	}

	action_hdr = (struct dot11_action_measure *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_SPECT_MNG;
	action_hdr->action = DOT11_SM_ACTION_TPC_REQ;
	/* Token needs to be non-zero, so burn the high bit */
	action_hdr->token = (uint8)(wlc->counter | 0x80);
	end = wlc_write_info_elt(action_hdr->data, DOT11_MNG_TPC_REQUEST_ID, 0, NULL);

	ASSERT((end - pbody) == (int)body_len);

	if (!ETHER_ISMULTI(da)) {
		scb = wlc_scbfindband(wlc, da, CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec));
	}
	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, scb);
}

void
wlc_tpc_rep_build(wlc_info_t *wlc, int8 rssi, ratespec_t rspec, dot11_tpc_rep_t *tpc_rep)
{
	int txpwr, link_margin;
	int nominal_req_pwr;

	/* tx power for the outgoing frame will be our current txpwr setting
	 * include the antenna gain value to get radiated power, EIRP.
	 * Adjust from internal units to dbm.
	 */
	txpwr = (wlc_phy_txpower_get_target_max((wlc_phy_t *)wlc->band->pi) + wlc->band->antgain)
		/ WLC_TXPWR_DB_FACTOR;

	nominal_req_pwr = wlc_find_nominal_req_pwr(rspec);

	link_margin = rssi;
	link_margin -= nominal_req_pwr;
	link_margin -= 3; /* TPC Report Safety Margin, 3 dB */
	/* clamp link_margin value if we overflow an int8 */
	link_margin = MIN(link_margin, 127);
	link_margin = MAX(link_margin, -128);

	tpc_rep->id = DOT11_MNG_TPC_REPORT_ID;
	tpc_rep->len = DOT11_MNG_IE_TPC_REPORT_LEN;
	tpc_rep->tx_pwr = (int8)txpwr;
	tpc_rep->margin = (int8)link_margin;
#if defined(WLTEST)
	if (wlc->tpc_rpt_override) {
		tpc_rep->tx_pwr = (int8)((wlc->tpc_rpt_override >> 8) & 0xff);
		tpc_rep->margin = (int8)(wlc->tpc_rpt_override & 0xff);
	}
#endif 

	WL_INFORM(("wl%d: wlc_build_tpc_report: TPC Report: txpwr %d, link margin"
		" %d\n",
		wlc->pub->unit, txpwr, link_margin));
}

static void
wlc_send_tpc_report(wlc_info_t *wlc, struct ether_addr *da, struct ether_addr *bssid, uint8 token,
	int8 rssi, ratespec_t rspec)
{
	wlc_bsscfg_t *bsscfg = wlc->cfg;
	void *p;
	uint8* pbody;
	uint body_len;
	struct dot11_action_measure * action_hdr;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */
	WL_INFORM(("wl%d: %s: sending TPC Report to %s\n",
	           wlc->pub->unit, __FUNCTION__, bcm_ether_ntoa(da, eabuf)));

	/* TPC Report frame is
	 * 3 bytes Action Measure Req frame
	 * 4 bytes TPC Report IE
	 */
	body_len = DOT11_ACTION_MEASURE_LEN + TLV_HDR_LEN + DOT11_MNG_IE_TPC_REPORT_LEN;

	p = wlc_frame_get_action(wlc, FC_ACTION, da, &bsscfg->cur_etheraddr, bssid,
	                       body_len, &pbody, DOT11_ACTION_CAT_SPECT_MNG);
	if (p == NULL) {
		WL_INFORM(("wl%d: %s: no memory for TPC Report\n",
		           wlc->pub->unit, __FUNCTION__));
		return;
	}

	action_hdr = (struct dot11_action_measure *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_SPECT_MNG;
	action_hdr->action = DOT11_SM_ACTION_TPC_REP;
	action_hdr->token = token;

	wlc_tpc_rep_build(wlc, rssi, rspec, (dot11_tpc_rep_t *)&action_hdr->data[0]);

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, NULL);
}

static void
wlc_send_measure_request(wlc_info_t *wlc, struct ether_addr *da, uint8 measure_type)
{
	wlc_bsscfg_t *bsscfg = wlc->cfg;
	void *p;
	uint8* pbody;
	uint body_len;
	struct dot11_action_measure * action_hdr;
	dot11_meas_req_t *req;
	uint32 tsf_l, tsf_h;
	uint32 measure_tsf_l, measure_tsf_h;
	uint16 duration;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */

	WL_INFORM(("wl%d: %s: sending Measure Request type %d to %s\n",
	           wlc->pub->unit, __FUNCTION__, measure_type, bcm_ether_ntoa(da, eabuf)));
	/* Channel Measure Request frame is
	 * 3 bytes Action Measure Req frame
	 * 16 bytes Measure Request IE
	 */
	body_len = DOT11_ACTION_MEASURE_LEN + TLV_HDR_LEN + DOT11_MNG_IE_MREQ_LEN;

	p = wlc_frame_get_action(wlc, FC_ACTION, da, &bsscfg->cur_etheraddr, &bsscfg->BSSID,
	                       body_len, &pbody, DOT11_ACTION_CAT_SPECT_MNG);
	if (p == NULL) {
		WL_INFORM(("wl%d: %s: no memory for Measure Request\n",
		           wlc->pub->unit, __FUNCTION__));
		return;
	}

	/* read the tsf from our chip */
	wlc_read_tsf(wlc, &tsf_l, &tsf_h);
	/* set the measure time to now + 100ms */
	measure_tsf_l = tsf_l + 100 * 1000;
	measure_tsf_h = tsf_h;
	if (measure_tsf_l < tsf_l)
		measure_tsf_h++; /* carry from addition */

	action_hdr = (struct dot11_action_measure *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_SPECT_MNG;
	action_hdr->action = DOT11_SM_ACTION_M_REQ;
	/* Token needs to be non-zero, so burn the high bit */
	action_hdr->token = (uint8)(wlc->counter | 0x80);
	req = (dot11_meas_req_t *)action_hdr->data;
	req->id = DOT11_MNG_MEASURE_REQUEST_ID;
	req->len = DOT11_MNG_IE_MREQ_LEN;
	req->token = (uint8)(action_hdr->token + 1);
	req->mode = 0;
	req->type = measure_type;
	req->channel = CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC);
	measure_tsf_l = htol32(measure_tsf_l);
	measure_tsf_h = htol32(measure_tsf_h);
	bcopy(&measure_tsf_l, req->start_time, 4);
	bcopy(&measure_tsf_h, &req->start_time[4], 4);
	duration = htol16(50);
	bcopy(&duration, &req->duration, 2);

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, NULL);
}

static void
wlc_send_measure_report(wlc_info_t *wlc, struct ether_addr *da, struct ether_addr *bssid,
	uint8 token, uint8 *report, uint report_len)
{
	wlc_bsscfg_t *bsscfg = wlc->cfg;
	void *p;
	uint8* pbody;
	uint body_len;
	struct dot11_action_measure * action_hdr;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */
	WL_INFORM(("wl%d: %s: sending Measure Report (token %d) to %s\n",
		wlc->pub->unit, __FUNCTION__, token, bcm_ether_ntoa(da, eabuf)));

	/* Measure Report frame is
	 * 3 bytes Action Measure Req frame
	 * variable len report
	 */
	body_len = DOT11_ACTION_MEASURE_LEN + report_len;

	p = wlc_frame_get_action(wlc, FC_ACTION, da, &bsscfg->cur_etheraddr, bssid,
	                       body_len, &pbody, DOT11_ACTION_CAT_SPECT_MNG);
	if (p == NULL) {
		WL_INFORM(("wl%d: %s: no memory for Measure Report\n",
		           wlc->pub->unit, __FUNCTION__));
		return;
	}

	action_hdr = (struct dot11_action_measure *)pbody;
	action_hdr->category = DOT11_ACTION_CAT_SPECT_MNG;
	action_hdr->action = DOT11_SM_ACTION_M_REP;
	action_hdr->token = token;

	bcopy(report, action_hdr->data, report_len);

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, NULL);
}

void
wlc_send_action_err(wlc_info_t *wlc, struct dot11_management_header *hdr, uint8 *body, int body_len)
{
	void *p;
	uint8* pbody;
	uint8 action_category;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */
	wlc_bsscfg_t *bsscfg = wlc->cfg;

	if (ETHER_ISMULTI(&hdr->da)) {
		WL_INFORM(("wl%d: %s: suppressing error reply to %s due to multicast address %s\n",
			wlc->pub->unit, __FUNCTION__, bcm_ether_ntoa(&hdr->sa, eabuf),
			bcm_ether_ntoa(&hdr->da, eabuf)));
		return;
	}

	action_category = (uint8)body[0];

	if (body_len < 2) {
		WL_INFORM(("wl%d: %s: sending error reply to %s for Category %d "
		           " with missing Action field\n", wlc->pub->unit, __FUNCTION__,
		           bcm_ether_ntoa(&hdr->sa, eabuf), action_category));
	} else {
		WL_INFORM(("wl%d: %s: sending error reply to %s for Category/Action %d/%d\n",
		           wlc->pub->unit, __FUNCTION__,
		           bcm_ether_ntoa(&hdr->sa, eabuf), action_category, (int)body[1]));
	}

	action_category |= DOT11_ACTION_CAT_ERR_MASK;

	p = wlc_frame_get_action(wlc, FC_ACTION, &hdr->sa, &bsscfg->cur_etheraddr, &bsscfg->BSSID,
	                       body_len, &pbody, action_category);
	if (p == NULL) {
		WL_INFORM(("wl%d: %s: no memory for Action Error\n",
		           wlc->pub->unit, __FUNCTION__));
		return;
	}

	bcopy(body, pbody, body_len);
	pbody[0] = (action_category | DOT11_ACTION_CAT_ERR_MASK);

	wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, NULL);
}

static wlc_bss_info_t *
wlc_BSSadd(wlc_info_t *wlc)
{
	wlc_bss_info_t	*BSS;

	if (wlc->scan_results->count == (uint)wlc->pub->tunables->maxbss)
		return (NULL);

	/* allocate a new entry */
	BSS = (wlc_bss_info_t *)MALLOC(wlc->osh, sizeof(wlc_bss_info_t));
	if (BSS) {
		bzero((char*)BSS, sizeof(wlc_bss_info_t));
		BSS->RSSI = WLC_RSSI_MINVAL;
		wlc->scan_results->ptrs[wlc->scan_results->count++] = BSS;
	}
	return BSS;
}

static wlc_bss_info_t *
wlc_BSSlookup(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec, uchar ssid[], uint ssid_len)
{
	wlc_bss_info_t	*BSS;
	uint indx;

	BSS = NULL;

	/* search for the BSS descriptor which matches
	 * the bssid AND band(2G/5G) AND SSID
	 */
	for (indx = 0; indx < wlc->scan_results->count; indx++) {
		BSS = wlc->scan_results->ptrs[indx];
		if (!bcmp(bssid, (char*)&BSS->BSSID, ETHER_ADDR_LEN) &&
		    CHSPEC_BAND(chanspec) == CHSPEC_BAND(BSS->chanspec) &&
		    ssid_len == BSS->SSID_len &&
		    !bcmp(ssid, BSS->SSID, ssid_len))
			break;
	}

	if (indx != wlc->scan_results->count)
		return (BSS);
	else
		return (NULL);
}

#ifdef STA
static int
wlc_BSSignorelookup(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec, uchar ssid[],
                    uint ssid_len, bool add)
{
	uint indx;
	uint16 ssid_sum = 0;
	iscan_ignore_t match;
	uint16 band = CHSPEC_BAND(chanspec);

	/* memory savings: compute the sum of the ssid bytes */
	for (indx = 0; indx < ssid_len; ++indx)
		ssid_sum += ssid[indx];

	/* match on bssid/ssid_sum/ssid_len/band */
	bcopy(bssid, &match.bssid, ETHER_ADDR_LEN);
	match.ssid_sum = ssid_sum;
	match.ssid_len = (uint8) ssid_len;

	/* ignore it if it's already in the list */
	for (indx = 0; indx < wlc->iscan_ignore_count; indx++) {
		if (!bcmp(&match, &wlc->iscan_ignore_list[indx], IGNORE_LIST_MATCH_SZ) &&
		    band == CHSPEC_BAND(wlc->iscan_ignore_list[indx].chanspec)) {
			return (int)indx;
		}
	}

	if (add && indx < WLC_ISCAN_IGNORE_MAX) {
		match.chanspec = chanspec;
		bcopy(&match, &wlc->iscan_ignore_list[wlc->iscan_ignore_count++],
		      sizeof(iscan_ignore_t));
	}

	return -1;
}

static bool
wlc_BSSignore(wlc_info_t *wlc, uchar *bssid, chanspec_t chanspec, uchar ssid[], uint ssid_len)
{
	int indx;

	indx = wlc_BSSignorelookup(wlc, bssid, chanspec, ssid, ssid_len, TRUE);
	return (indx >= 0);
}
#endif /* STA */

void
wlc_bss_list_free(wlc_info_t *wlc, wlc_bss_list_t *bss_list)
{
	uint indx;
	wlc_bss_info_t *bi;

	/* inspect all BSS descriptor */
	for (indx = 0; indx < bss_list->count; indx++) {
		bi = bss_list->ptrs[indx];
		if (bi) {
			if (bi->bcn_prb) {
				MFREE(wlc->osh, bi->bcn_prb, bi->bcn_prb_len);
			}
			MFREE(wlc->osh, bi, sizeof(wlc_bss_info_t));
			bss_list->ptrs[indx] = NULL;
		}
	}
	bss_list->count = 0;
}

void
wlc_bss_list_xfer(wlc_bss_list_t *from, wlc_bss_list_t *to)
{
	uint size;

	ASSERT(to->count == 0);
	size = from->count * sizeof(wlc_bss_info_t*);
	bcopy((char*)from->ptrs, (char*)to->ptrs, size);
	bzero((char*)from->ptrs, size);

	to->count = from->count;
	from->count = 0;
}

#ifdef WLNINTENDO2
void
wlc_rcvlog(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, void *p, int len)
{
	uint16 fc = 0;
	int32 rssi = 0;
	struct dot11_header *hdr = NULL;

	if (!wlc || !wrxh || !p)
		return;

	if (!wlc->_lqstats.enable)
		return;

	hdr = (struct dot11_header *)(PKTDATA(wlc->pub->osh, p) + D11_PHY_HDR_LEN);

	if (len >= D11_PHY_HDR_LEN + sizeof(hdr->fc))
		fc = ltoh16(hdr->fc);

	if (FC_TYPE(fc) == FC_TYPE_DATA) {
		rssi = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);
		/* snr = wlc_phy_compute_snr(wlc, rxh); */

		if (rssi != WLC_RSSI_INVALID) {
			MINMAXSUM(rssi, wlc->_lqstats.rssi);
			/* MINMAXSUM(snr, wlc->_lqstats.snr); */
			++wlc->_lqstats.rssicnt;
		}
	} /* FC_TYPE_DATA */
} /* wlc_rcvlog */

void
wlc_get_lq_stats(wlc_info_t *wlc, wl_lq_t *xs)
{
	int rssicnt = 0;

	if (!wlc) {
		return;
	}

	xs->isvalid = wlc->_lqstats.enable;

	if (!wlc->_lqstats.enable)
		return;

	/* RSSI */
	rssicnt = wlc->_lqstats.rssicnt;
	xs->rssi[LQ_IDX_MIN] = wlc->_lqstats.rssi[LQ_IDX_MIN];
	xs->rssi[LQ_IDX_MAX] = wlc->_lqstats.rssi[LQ_IDX_MAX];
	xs->rssi[LQ_IDX_AVG] = (rssicnt ? wlc->_lqstats.rssi[LQ_IDX_SUM] / rssicnt: 0);
} /* wlc_get_lq_stats */

void
wlc_clear_lq_stats(wlc_info_t *wlc)
{
	if (!wlc)
		return;

	bzero(&wlc->_lqstats, sizeof(wl_lq_stats_t));
	wlc->_lqstats.rssi[LQ_IDX_MAX] = -9999;
	wlc->_lqstats.version = LINKQUAL_V1;
} /* wlc_clear_lq_stats */
#endif /* WLNINTENDO2 */

/* Process received frames */
/*
 * Return TRUE if more frames need to be processed. FALSE otherwise.
 * Param 'bound' indicates max. # frames to process before break out.
 */
/* WLC_HIGH_API */
void BCMFASTPATH
wlc_recv(wlc_info_t *wlc, void *p)
{
	wlc_d11rxhdr_t *wrxh;
	d11rxhdr_t *rxh;
	struct dot11_header *h;
	osl_t *osh;
	uint16 fc;
	uint len;
	bool is_amsdu;
#ifdef BCMDBG_ERR
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG_ERR */

	WL_TRACE(("wl%d: wlc_recv\n", wlc->pub->unit));

	osh = wlc->osh;

	/* frame starts with rxhdr */
	wrxh = (wlc_d11rxhdr_t *)PKTDATA(osh, p);
	rxh = &wrxh->rxhdr;

	/* strip off rxhdr */
	PKTPULL(osh, p, wlc->hwrxoff);


	/* fixup rx header endianness */
	ltoh16_buf((void*)rxh, sizeof(d11rxhdr_t));

	/* MAC inserts 2 pad bytes for a4 headers or QoS or A-MSDU subframes */
	if (rxh->RxStatus1 & RXS_PBPRES) {
		if (PKTLEN(osh, p) < 2) {
			WLCNTINCR(wlc->pub->_cnt->rxrunt);
			WL_ERROR(("wl%d: wlc_recv: rcvd runt of len %d\n",
			          wlc->pub->unit, PKTLEN(osh, p)));
			goto toss;
		}
		PKTPULL(osh, p, 2);
	}

	h = (struct dot11_header *)(PKTDATA(osh, p) + D11_PHY_HDR_LEN);
	len = PKTLEN(osh, p);

	/* monitor mode. Send all runt/bad fcs/bad proto up as well */
	if (MONITOR_ENAB(wlc)) {
		wlc_monitor(wlc, wrxh, p, NULL);

		if ((rxh->RxStatus1 & RXS_FCSERR) == RXS_FCSERR) {
			goto toss;
		}
	}

	ASSERT((rxh->RxStatus1 & RXS_FCSERR) == 0);

	/* check received pkt has at least frame control field */
	if (len >= D11_PHY_HDR_LEN + sizeof(h->fc)) {
		fc = ltoh16(h->fc);
	} else {
		WLCNTINCR(wlc->pub->_cnt->rxrunt);
		goto toss;
	}

#if defined(WLNINTENDO2)
	wlc_rcvlog(wlc, wrxh, p, PKTLEN(osh, p));
#endif

	is_amsdu = rxh->RxStatus2 & RXS_AMSDU_MASK;

	/* explicitly test bad src address to avoid sending bad deauth */
	if (!is_amsdu) {
		/* CTS and ACK CTL frames are w/o a2 */
		if (FC_TYPE(fc) == FC_TYPE_DATA || FC_TYPE(fc) == FC_TYPE_MNG) {
			if ((ETHER_ISNULLADDR(&h->a2) || ETHER_ISMULTI(&h->a2))) {
				WL_ERROR(("wl%d: wlc_recv: dropping a frame with invalid"
				          " src mac address %s\n", wlc->pub->unit,
				          bcm_ether_ntoa(&h->a2, eabuf)));
				WLCNTINCR(wlc->pub->_cnt->rxbadsrcmac);
				goto toss;
			}
			WLCNTINCR(wlc->pub->_cnt->rxfrag);
		}
	}

	if (is_amsdu) {
#ifdef WLAMSDU
		if (wlc->_amsdu_rx)
			/*
			 * check, qualify, chain MSDUs,
			 * calls wlc_recvdata() when AMSDU is completely received
			 */
			wlc_recvamsdu(wlc->ami, wrxh, p);
		else
#endif
			goto toss;

	} else if (FC_TYPE(fc) == FC_TYPE_DATA) {
#ifdef WL11N
#ifdef BCMDBG
		if (rxh->PhyRxStatus_0 & PRXS0_RXANT_UPSUBBAND) {
			WL_PROTO(("wlc_recv: receive frame on 20U side band!\n"));
		}

		if (rxh->PhyRxStatus_3) {
			WL_PROTO(("wlc_recv: nphy, mixedmode, MMPlcplength %d, rate %d\n",
			           rxh->PhyRxStatus_3 & 0x0FFF,
			           (rxh->PhyRxStatus_3 & 0xF000) >> 12));
		}
#endif
#endif	/* WL11N */
		/*
		 * Call common receive, dispatch, and sendup code.
		 * The latter drops the perimeter lock and anything can happen!
		 */

		wlc_recvdata(wlc, osh, wrxh, p);

	} else if ((FC_TYPE(fc) == FC_TYPE_MNG) || (FC_TYPE(fc) == FC_TYPE_CTL)) {

		/* Complete the mapping of the remaining buffer before processing
		 * control or mgmt frames.
		 */
		PKTCTFMAP(osh, p);

		wlc_recvctl(wlc, osh, wrxh, p);

	} else {
		WLCNTINCR(wlc->pub->_cnt->rxbadproto);
		goto toss;
	}

	return;

toss:
	PKTFREE(osh, p, FALSE);
}

int
wlc_wsec(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, uint32 val)
{
	uint32 wsec_prev;
	int i;

	WL_WSEC(("wl%d: wlc_wsec: setting wsec 0x%x\n", wlc->pub->unit, val));

	wsec_prev = bsscfg->wsec;

	bsscfg->wsec = val & (WEP_ENABLED|TKIP_ENABLED|AES_ENABLED|WSEC_SWFLAG|
	                      SES_OW_ENABLED);

#ifdef MFP
	/* fail if result will have MFPR but MFPC clear */
	if (((bsscfg->wsec | val) & MFP_REQUIRED) && !((bsscfg->wsec | val) & MFP_CAPABLE)) {
		WL_WSEC(("wl%d: %s: MFPR/MFPC mismatch, old wsec: 0x%04x,"
			" attempted wsec: 0x%04x\n",
			WLCWLUNIT(wlc), __FUNCTION__, wsec_prev, val));
		bsscfg->wsec = wsec_prev;
		return (BCME_BADARG);
	}
	bsscfg->wsec |= val & (MFP_CAPABLE | MFP_REQUIRED | MFP_SHA256);
#endif
#ifdef BCMWAPI_WPI
	bsscfg->wsec |= val & (SMS4_ENABLED);
	if (!WAPI_HW_ENAB(wlc) && (val & SMS4_ENABLED))
		bsscfg->wsec |= WSEC_SWFLAG;
#endif /* BCMWAPI_WPI */

#ifdef STA
	/* change of wsec may modify the PS_ALLOWED state */
	if (BSSCFG_STA(bsscfg))
		wlc_set_pmstate(bsscfg, bsscfg->pm->PMenabled);
#endif /* STA */

	if (!wlc->pub->up)
		return (0);

	/* update the hardware keys if we are changing the WSEC_SW flag */
	if ((wsec_prev & WSEC_SWFLAG) != (bsscfg->wsec & WSEC_SWFLAG))
	{
		for (i = 0; i < WLC_MAX_WSEC_HW_KEYS(wlc); i++) {
			if (!WSEC_KEY(wlc, i))
				continue;
			wlc_key_hw_init(wlc, i, bsscfg);
		}
	}

	return (0);
}

/* return the multicast cipher defined as the weakest
 * enabled encryption in the order: WEP, TKIP, AES
 */
static uint8
wlc_wpa_mcast_cipher(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	wsec_key_t *key;
	uint32 wsec = cfg->wsec;
	uint8 cipher = 0;

	if (WSEC_WEP_ENABLED(wsec)) {
		/* wsec does not specify WEP key size, so use the default key algo */

		key = WSEC_BSS_DEFAULT_KEY(cfg);

		if (key && key->algo == CRYPTO_ALGO_WEP128) {
			cipher = WPA_CIPHER_WEP_104;
		} else if (key && key->algo == CRYPTO_ALGO_WEP1) {
			cipher = WPA_CIPHER_WEP_40;
		} else {
			if (!key)
				WL_ERROR(("wl%d: wlc_wpa_mcast_cipher: WEP encryption enabled but"
					" key is not plumbed\n",
					wlc->pub->unit));
			else
				WL_ERROR(("wl%d: wlc_wpa_mcast_cipher: WEP encryption enabled but"
					" default key algo (%d) is not WEP1 or WEP128\n",
					wlc->pub->unit, key->algo));
			cipher = WPA_CIPHER_WEP_40;
		}
	} else if (WSEC_TKIP_ENABLED(wsec)) {
		cipher = WPA_CIPHER_TKIP;
	} else if (WSEC_AES_ENABLED(wsec)) {
		cipher = WPA_CIPHER_AES_CCM;
	}
#ifdef BCMWAPI_WAI
	else if (WSEC_SMS4_ENABLED(wsec)) {
		cipher = WAPI_CIPHER_SMS4;
	}
#endif /* BCMWAPI_WAI */

	return cipher;
}

/* calculate frame duration for Mixed-mode L-SIG spoofing, return
 * number of bytes goes in the length field
 *
 * Formula given by HT PHY Spec v 1.13
 *   len = 3(nsyms + nstream + 3) - 3
 */
uint16 BCMFASTPATH
wlc_calc_lsig_len(wlc_info_t *wlc, ratespec_t ratespec, uint mac_len)
{
	uint nsyms, len = 0, kNdps;

	WL_TRACE(("wl%d: wlc_calc_lsig_len: rate %d, len%d\n", wlc->pub->unit,
		RSPEC2RATE(ratespec), mac_len));

	if (IS_MCS(ratespec)) {
		uint mcs = ratespec & RSPEC_RATE_MASK;
		/* MCS_TXS(mcs) returns num tx streams - 1 */
		int tot_streams = (MCS_TXS(mcs) + 1) + RSPEC_STC(ratespec);

		ASSERT(WLC_PHY_11N_CAP(wlc->band));
		/* the payload duration calculation matches that of regular ofdm */
		/* 1000Ndbps = kbps * 4 */
		kNdps = MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec), RSPEC_ISSGI(ratespec)) * 4;

		if (RSPEC_STC(ratespec) == 0)
			/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
			nsyms = CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS)*1000,
			             kNdps);
		else
			/* STBC needs to have even number of symbols */
			nsyms = 2 * CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS)*1000,
			                 2 * kNdps);

		nsyms += (tot_streams + 3);	/* (+3) account for HT-SIG(2) and HT-STF(1) */
		/* 3 bytes/symbol @ legacy 6Mbps rate */
		len = (3 * nsyms) - 3;	/* (-3) excluding service bits and tail bits */
	}

	return (uint16)len;
}

/* calculate frame duration of a given rate and length, return time in usec unit */
uint BCMFASTPATH
wlc_calc_frame_time(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type, uint mac_len)
{
	uint nsyms, dur = 0, Ndps, kNdps;
	uint rate = RSPEC2RATE(ratespec);

	if (rate == 0) {
		ASSERT(0);
		WL_ERROR(("wl%d: WAR: using rate of 1 mbps\n", wlc->pub->unit));
		rate = WLC_RATE_1M;
	}

	WL_TRACE(("wl%d: wlc_calc_frame_time: rspec 0x%x, preamble_type %d, len%d\n",
		wlc->pub->unit, ratespec, preamble_type, mac_len));

	if (IS_MCS(ratespec)) {
		uint mcs = ratespec & RSPEC_RATE_MASK;
		int tot_streams = MCS_TXS(mcs) + RSPEC_STC(ratespec);
		ASSERT(WLC_PHY_11N_CAP(wlc->band));
		ASSERT(WLC_IS_MIMO_PREAMBLE(preamble_type));

		dur = PREN_PREAMBLE + (tot_streams*PREN_PREAMBLE_EXT);
		if (preamble_type == WLC_MM_PREAMBLE)
			dur += PREN_MM_EXT;
		/* 1000Ndbps = kbps * 4 */
		kNdps = MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec), RSPEC_ISSGI(ratespec)) * 4;

		if (RSPEC_STC(ratespec) == 0)
			/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
			nsyms = CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS)*1000,
			             kNdps);
		else
			/* STBC needs to have even number of symbols */
			nsyms = 2 * CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS)*1000,
			                 2 * kNdps);

		dur += APHY_SYMBOL_TIME * nsyms;
		if (BAND_2G(wlc->band->bandtype))
			dur += DOT11_OFDM_SIGNAL_EXTENSION;
	} else if (IS_OFDM(rate)) {
		dur = APHY_PREAMBLE_TIME;
		dur += APHY_SIGNAL_TIME;
		/* Ndbps = Mbps * 4 = rate(500Kbps) * 2 */
		Ndps = rate*2;
		/* NSyms = CEILING((SERVICE + 8*NBytes + TAIL) / Ndbps) */
		nsyms = CEIL((APHY_SERVICE_NBITS + 8 * mac_len + APHY_TAIL_NBITS), Ndps);
		dur += APHY_SYMBOL_TIME * nsyms;
		if (BAND_2G(wlc->band->bandtype))
			dur += DOT11_OFDM_SIGNAL_EXTENSION;
	} else {
		/* calc # bits * 2 so factor of 2 in rate (1/2 mbps) will divide out */
		mac_len = mac_len * 8 * 2;
		/* calc ceiling of bits/rate = microseconds of air time */
		dur = (mac_len + rate-1) / rate;
		if (preamble_type & WLC_SHORT_PREAMBLE)
			dur += BPHY_PLCP_SHORT_TIME;
		else
			dur += BPHY_PLCP_TIME;
	}
	return dur;
}

/* The opposite of wlc_calc_frame_time */
static uint
wlc_calc_frame_len(wlc_info_t *wlc, ratespec_t ratespec, uint8 preamble_type, uint dur)
{
	uint nsyms, mac_len, Ndps, kNdps;
	uint rate = RSPEC2RATE(ratespec);

	WL_TRACE(("wl%d: wlc_calc_frame_len: rspec 0x%x, preamble_type %d, dur %d\n",
		wlc->pub->unit, ratespec, preamble_type, dur));

	if (IS_MCS(ratespec)) {
		uint mcs = ratespec & RSPEC_RATE_MASK;
		int tot_streams = MCS_TXS(mcs) + RSPEC_STC(ratespec);
		ASSERT(WLC_PHY_11N_CAP(wlc->band));
		dur -= PREN_PREAMBLE + (tot_streams*PREN_PREAMBLE_EXT);
		/* payload calculation matches that of regular ofdm */
		if (BAND_2G(wlc->band->bandtype))
			dur -= DOT11_OFDM_SIGNAL_EXTENSION;
		/* kNdbps = kbps * 4 */
		kNdps = MCS_RATE(mcs, RSPEC_IS40MHZ(ratespec), RSPEC_ISSGI(ratespec)) * 4;
		nsyms = dur / APHY_SYMBOL_TIME;
		mac_len = ((nsyms * kNdps) - ((APHY_SERVICE_NBITS + APHY_TAIL_NBITS)*1000)) / 8000;
	} else if (IS_OFDM(ratespec)) {
		dur -= APHY_PREAMBLE_TIME;
		dur -= APHY_SIGNAL_TIME;
		if (WLCISGPHY(wlc->band))
			dur -= DOT11_OFDM_SIGNAL_EXTENSION;
		/* Ndbps = Mbps * 4 = rate(500Kbps) * 2 */
		Ndps = rate*2;
		nsyms = dur / APHY_SYMBOL_TIME;
		mac_len = ((nsyms * Ndps) - (APHY_SERVICE_NBITS + APHY_TAIL_NBITS)) / 8;
	} else {
		if (preamble_type & WLC_SHORT_PREAMBLE)
			dur -= BPHY_PLCP_SHORT_TIME;
		else
			dur -= BPHY_PLCP_TIME;
		mac_len = dur * rate;
		/* divide out factor of 2 in rate (1/2 mbps) */
		mac_len = mac_len / 8 / 2;
	}
	return mac_len;
}

#ifdef WL11N
static uint
wlc_calc_ba_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
{
	WL_TRACE(("wl%d: wlc_calc_ba_time: rspec 0x%x, preamble_type %d\n",
		wlc->pub->unit, rspec, preamble_type));
	/* Spec 9.6: ack rate is the highest rate in BSSBasicRateSet that is less than
	 * or equal to the rate of the immediately previous frame in the FES
	 */
	rspec = WLC_BASIC_RATE(wlc, rspec);
	ASSERT(VALID_RATE_DBG(wlc, rspec));

	/* BA len == 32 == 16(ctl hdr) + 4(ba len) + 8(bitmap) + 4(fcs) */
	return wlc_calc_frame_time(wlc, rspec, preamble_type,
		(DOT11_BA_LEN + DOT11_BA_BITMAP_LEN + DOT11_FCS_LEN));
}
#endif /* WL11N */

static uint BCMFASTPATH
wlc_calc_ack_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
{
	uint dur = 0;

	WL_TRACE(("wl%d: wlc_calc_ack_time: rspec 0x%x, preamble_type %d\n", wlc->pub->unit, rspec,
		preamble_type));
	/* Spec 9.6: ack rate is the highest rate in BSSBasicRateSet that is less than
	 * or equal to the rate of the immediately previous frame in the FES
	 */
	rspec = WLC_BASIC_RATE(wlc, rspec);
	ASSERT(VALID_RATE_DBG(wlc, rspec));

	/* ACK frame len == 14 == 2(fc) + 2(dur) + 6(ra) + 4(fcs) */
	dur = wlc_calc_frame_time(wlc, rspec, preamble_type, (DOT11_ACK_LEN + DOT11_FCS_LEN));
	return dur;
}

static uint
wlc_calc_cts_time(wlc_info_t *wlc, ratespec_t rspec, uint8 preamble_type)
{
	WL_TRACE(("wl%d: wlc_calc_cts_time: ratespec 0x%x, preamble_type %d\n", wlc->pub->unit,
	        rspec, preamble_type));
	return wlc_calc_ack_time(wlc, rspec, preamble_type);
}


/* derive wlc->band->basic_rate[] table from 'rateset' */
void
wlc_rate_lookup_init(wlc_info_t *wlc, wlc_rateset_t *rateset)
{
	uint8 rate;
	uint8 mandatory;
	uint8 cck_basic = 0;
	uint8 ofdm_basic = 0;
	uint8 *br = wlc->band->basic_rate;
	uint i;

	/* incoming rates are in 500kbps units as in 802.11 Supported Rates */
	bzero(br, WLC_MAXRATE + 1);

	/* For each basic rate in the rates list, make an entry in the
	 * best basic lookup.
	 */
	for (i = 0; i < rateset->count; i++) {
		/* only make an entry for a basic rate */
		if (!(rateset->rates[i] & WLC_RATE_FLAG))
			continue;

		/* mask off basic bit */
		rate = (rateset->rates[i] & RATE_MASK);

		if (rate > WLC_MAXRATE) {
			WL_ERROR(("wlc_rate_lookup_init: invalid rate 0x%X in rate set\n",
				rateset->rates[i]));
			continue;
		}

		br[rate] = rate;
	}

	/* The rate lookup table now has non-zero entries for each
	 * basic rate, equal to the basic rate: br[basicN] = basicN
	 *
	 * To look up the best basic rate corresponding to any
	 * particular rate, code can use the basic_rate table
	 * like this
	 *
	 * basic_rate = wlc->band->basic_rate[tx_rate]
	 *
	 * Make sure there is a best basic rate entry for
	 * every rate by walking up the table from low rates
	 * to high, filling in holes in the lookup table
	 */

	for (i = 0; i < wlc->band->hw_rateset.count; i++) {
		rate = wlc->band->hw_rateset.rates[i];
		ASSERT(rate <= WLC_MAXRATE);

		if (br[rate] != 0) {
			/* This rate is a basic rate.
			 * Keep track of the best basic rate so far by
			 * modulation type.
			 */
			if (IS_OFDM(rate))
				ofdm_basic = rate;
			else
				cck_basic = rate;

			continue;
		}

		/* This rate is not a basic rate so figure out the
		 * best basic rate less than this rate and fill in
		 * the hole in the table
		 */

		br[rate] = IS_OFDM(rate) ? ofdm_basic : cck_basic;

		if (br[rate] != 0)
			continue;

		/* This is a weird setup where the lowest basic rate
		 * of a modulation type is non-existent or higher than
		 * some supported rates in the same modulation
		 */
		WL_RATE(("wl%d: no basic rate with the same modulation less than or equal to rate"
			" %d%s\n",
			 wlc->pub->unit, rate/2, (rate % 2)?".5":""));

		if (IS_OFDM(rate)) {
			/* In 11g and 11a, the OFDM mandatory rates are 6, 12, and 24 Mbps */
			if (rate >= WLC_RATE_24M)
				mandatory = WLC_RATE_24M;
			else if (rate >= WLC_RATE_12M)
				mandatory = WLC_RATE_12M;
			else
				mandatory = WLC_RATE_6M;
		} else {
			/* In 11b, all the CCK rates are mandatory 1 - 11 Mbps */
			mandatory = rate;
		}

		br[rate] = mandatory;
	}
}

/* read rate table direct address map from shm */
static void
wlc_read_rt_dirmap(wlc_info_t *wlc)
{
	int i;

	for (i = 0; i < D11_RT_DIRMAP_SIZE; i ++)
		wlc->rt_dirmap_a[i] = wlc_read_shm(wlc, (M_RT_DIRMAP_A + i * 2));

	for (i = 0; i < D11_RT_DIRMAP_SIZE; i ++)
		wlc->rt_dirmap_b[i] = wlc_read_shm(wlc, (M_RT_DIRMAP_B + i * 2));
}

static void
wlc_write_rate_shm(wlc_info_t *wlc, uint8 rate, uint8 basic_rate)
{
	uint8 phy_rate, indx;
	uint8 basic_phy_rate, basic_index;
	uint16 basic_table;
	uint16 *rt_dirmap;

	/* Find the direct address map table we are reading */
	rt_dirmap = IS_OFDM(basic_rate) ? wlc->rt_dirmap_a : wlc->rt_dirmap_b;

	/* Shared memory address for the table we are writing */
	basic_table = IS_OFDM(rate) ? M_RT_BBRSMAP_A : M_RT_BBRSMAP_B;

	/*
	 * for a given rate, the LS-nibble of the PLCP SIGNAL field is
	 * the index into the rate table.
	 */
	phy_rate = rate_info[rate] & RATE_MASK;
	basic_phy_rate = rate_info[basic_rate] & RATE_MASK;
	indx = phy_rate & 0xf;
	basic_index = basic_phy_rate & 0xf;

	/* Update the SHM BSS-basic-rate-set mapping table with the pointer
	 * to the correct basic rate for the given incoming rate
	 */
	wlc_write_shm(wlc, (basic_table + indx * 2), rt_dirmap[basic_index]);
}

static const wlc_rateset_t *
wlc_rateset_get_hwrs(wlc_info_t *wlc)
{
	const wlc_rateset_t *rs_dflt;

	if (WLC_PHY_11N_CAP(wlc->band)) {
		if (BAND_5G(wlc->band->bandtype))
			rs_dflt = &ofdm_mimo_rates;
		else
			rs_dflt = &cck_ofdm_mimo_rates;
	} else if (WLCISLPPHY(wlc->band)) {
		if (BAND_5G(wlc->band->bandtype))
			rs_dflt = &ofdm_rates;
		else
			rs_dflt = &cck_ofdm_rates;
	} else if (WLCISAPHY(wlc->band))
		rs_dflt = &ofdm_rates;
	else if (wlc->band->gmode)
		rs_dflt = &cck_ofdm_rates;
	else
		rs_dflt = &cck_rates;

	return rs_dflt;
}

void
wlc_set_ratetable(wlc_info_t *wlc)
{
	const wlc_rateset_t *rs_dflt;
	wlc_rateset_t rs;
	uint8 rate, basic_rate;
	uint i;

	rs_dflt = wlc_rateset_get_hwrs(wlc);
	ASSERT(rs_dflt != NULL);

	wlc_rateset_copy(rs_dflt, &rs);
#ifdef WL11N
	wlc_rateset_mcs_upd(&rs, wlc->stf->txstreams);
#endif

	/* walk the phy rate table and update SHM basic rate lookup table */
	for (i = 0; i < rs.count; i++) {
		rate = rs.rates[i] & RATE_MASK;

		/* for a given rate WLC_BASIC_RATE returns the rate at
		 * which a response ACK/CTS should be sent.
		 */
		basic_rate = WLC_BASIC_RATE(wlc, rate);
		if (basic_rate == 0) {
			/* This should only happen if we are using a
			 * restricted rateset.
			 */
			WL_RATE(("wl%d: set_ratetable: Adding rate %d to ratetable\n",
				wlc->pub->unit, rate));
			basic_rate = rs.rates[0] & RATE_MASK;
		}

		wlc_write_rate_shm(wlc, rate, basic_rate);
	}
}

/*
 * Return true if the specified rate is supported by the specified band.
 * WLC_BAND_AUTO indicates the current band.
 */
bool
wlc_valid_rate(wlc_info_t *wlc, ratespec_t rspec, int band, bool verbose)
{
	wlc_rateset_t *hw_rateset;
	uint i;

	if ((band == WLC_BAND_AUTO) || (band == wlc->band->bandtype)) {
		hw_rateset = &wlc->band->hw_rateset;
	} else if (NBANDS(wlc) > 1) {
		hw_rateset = &wlc->bandstate[OTHERBANDUNIT(wlc)]->hw_rateset;
	} else {
		/* other band specified and we are a single band device */
		return (FALSE);
	}

	/* check if this is a mimo rate */
	if (IS_MCS(rspec)) {
		if (!VALID_MCS((rspec & RSPEC_RATE_MASK)))
			goto error;

		return isset(hw_rateset->mcs, (rspec & RSPEC_RATE_MASK));
	}

	for (i = 0; i < hw_rateset->count; i++)
		if (hw_rateset->rates[i] == RSPEC2RATE(rspec))
			return (TRUE);
error:
	if (verbose) {
		WL_ERROR(("wl%d: wlc_valid_rate: rate spec 0x%x not in hw_rateset\n",
		          wlc->pub->unit, rspec));
#ifdef BCMDBG
		wlc_rateset_show(wlc, hw_rateset, NULL);
#endif
	}

	return (FALSE);
}

#ifdef WL11N
static void
wlc_update_mimo_band_bwcap(wlc_info_t *wlc, uint8 bwcap)
{
	uint i;
	wlcband_t *band;

	for (i = 0; i < NBANDS(wlc); i++) {
		if (IS_SINGLEBAND_5G(wlc->deviceid))
			i = BAND_5G_INDEX;
		band = wlc->bandstate[i];
		if (band->bandtype == WLC_BAND_5G) {
			if ((bwcap == WLC_N_BW_40ALL) || (bwcap == WLC_N_BW_20IN2G_40IN5G))
				band->mimo_cap_40 = TRUE;
			else
				band->mimo_cap_40 = FALSE;
		} else {
			ASSERT(band->bandtype == WLC_BAND_2G);
			if (bwcap == WLC_N_BW_40ALL)
				band->mimo_cap_40 = TRUE;
			else
				band->mimo_cap_40 = FALSE;
		}
	}

	wlc->mimo_band_bwcap = bwcap;
	wlc_ht_update_coex_support(wlc, wlc->pub->_coex);
}
#endif /* WL11N */

void
wlc_mod_prb_rsp_rate_table(wlc_info_t *wlc, uint frame_len)
{
	const wlc_rateset_t *rs_dflt;
	wlc_rateset_t rs;
	uint8 rate;
	uint16 entry_ptr;
	uint8 plcp[D11_PHY_HDR_LEN];
	uint16 dur, sifs;
	uint i;

	sifs = SIFS(wlc->band);

	rs_dflt = wlc_rateset_get_hwrs(wlc);
	ASSERT(rs_dflt != NULL);

	wlc_rateset_copy(rs_dflt, &rs);
#ifdef WL11N
	wlc_rateset_mcs_upd(&rs, wlc->stf->txstreams);
#endif

	/* walk the phy rate table and update MAC core SHM basic rate table entries */
	for (i = 0; i < rs.count; i++) {
		rate = rs.rates[i] & RATE_MASK;

		entry_ptr = wlc_rate_shm_offset(wlc, rate);

		/* Calculate the Probe Response PLCP for the given rate */
		wlc_compute_plcp(wlc, rate, frame_len, plcp);

		/* Calculate the duration of the Probe Response frame plus SIFS for the MAC */
		dur = (uint16)wlc_calc_frame_time(wlc, rate, WLC_LONG_PREAMBLE, frame_len);
		dur += sifs;

		/* Update the SHM Rate Table entry Probe Response values */
		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS,
		              (uint16)(plcp[0] + (plcp[1] << 8)));
		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_PLCP_POS + 2,
		              (uint16)(plcp[2] + (plcp[3] << 8)));
		wlc_write_shm(wlc, entry_ptr + M_RT_PRS_DUR_POS, dur);
	}
}

/* compute the offset in usec from the first symbol in the payload (PHY-RXSTART),
 * to the first symbol of the TSF
 */
uint16
wlc_compute_bcn_payloadtsfoff(wlc_info_t *wlc, ratespec_t rspec)
{
	uint bcntsfoff = 0;

	if (IS_MCS(rspec)) {
		WL_ERROR(("wl%d: recd beacon with mcs rate; rspec 0x%x\n",
			wlc->pub->unit, rspec));
	} else if (IS_OFDM(rspec)) {
		/* PLCP SERVICE + MAC header time (SERVICE + FC + DUR + A1 + A2 + A3 + SEQ == 26
		 * bytes at beacon rate)
		 */
		bcntsfoff += wlc_compute_airtime(wlc, rspec, APHY_SERVICE_NBITS/8 +
			DOT11_MAC_HDR_LEN);
	} else {
		/* MAC header time (FC + DUR + A1 + A2 + A3 + SEQ == 24 bytes at beacon rate) */
		bcntsfoff += wlc_compute_airtime(wlc, rspec, DOT11_MAC_HDR_LEN);
	}
	return (uint16)(bcntsfoff);
}

/* compute the offset in usec from the beginning of the preamble,
 * to the first symbol of the TSF
 */
uint16
wlc_compute_bcntsfoff(wlc_info_t *wlc, ratespec_t rspec, bool short_preamble, bool phydelay)
{
	uint bcntsfoff = 0;

	/* compute the air time for the preamble */
	if (IS_MCS(rspec)) {
		WL_ERROR(("wl%d: recd beacon with mcs rate; rspec 0x%x\n",
			wlc->pub->unit, rspec));
	} else if (IS_OFDM(rspec)) {
		/* tx delay from MAC through phy to air (2.1 usec) +
		 * phy header time (preamble + PLCP SIGNAL == 20 usec) +
		 * PLCP SERVICE + MAC header time (SERVICE + FC + DUR + A1 + A2 + A3 + SEQ == 26
		 * bytes at beacon rate)
		 */
		bcntsfoff += phydelay ? D11A_PHY_TX_DELAY : 0;
		bcntsfoff += APHY_PREAMBLE_TIME + APHY_SIGNAL_TIME;
	} else {
		/* tx delay from MAC through phy to air (3.4 usec) +
		 * phy header time (long preamble + PLCP == 192 usec) +
		 * MAC header time (FC + DUR + A1 + A2 + A3 + SEQ == 24 bytes at beacon rate)
		 */
		bcntsfoff += phydelay ? D11B_PHY_TX_DELAY : 0;
		bcntsfoff += short_preamble ? D11B_PHY_SPREHDR_TIME: D11B_PHY_LPREHDR_TIME;
	}

	/* add the time from the end of the preamble/beginning of payload to the tsf field */
	bcntsfoff += wlc_compute_bcn_payloadtsfoff(wlc, rspec);

	return (uint16)(bcntsfoff);
}

/* decode wpa IE to retrieve mcast/unicast ciphers and auth modes */
static int
wlc_parse_wpa_ie(wlc_info_t *wlc, wpa_ie_fixed_t *wpaie, wlc_bss_info_t *bi)
{
	int len = wpaie->length;	/* value length */
	wpa_suite_mcast_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *mgmt;
	uint16 count;
	uint i, j;

	/*
	* The TLV tag is generic for all vendor-specific IEs. We need
	* to check OUI as well to make sure this TLV is indeed WPA,
	* and quietly discard the IE if it is not WPA IE.
	*/
	if ((len < WPA_IE_OUITYPE_LEN) ||
	    bcmp(wpaie->oui, WPA_OUI"\01", WPA_IE_OUITYPE_LEN))
		return 0;

	if ((len < WPA_IE_TAG_FIXED_LEN) ||
	    (ltoh16_ua(&wpaie->version) != WPA_VERSION)) {
		WL_ERROR(("wl%d: unsupported WPA version %d\n", wlc->pub->unit,
			ltoh16_ua(&wpaie->version)));
		return BCME_UNSUPPORTED;
	}
	len -= WPA_IE_TAG_FIXED_LEN;

	/* Default WPA parameters */
	bi->wpa.flags = RSN_FLAGS_SUPPORTED;
	bi->wpa.multicast = WPA_CIPHER_TKIP;
	bi->wpa.ucount = 1;
	bi->wpa.unicast[0] = WPA_CIPHER_TKIP;
	bi->wpa.acount = 1;
	bi->wpa.auth[0] = RSN_AKM_UNSPECIFIED;


	/* Check for multicast cipher suite */
	if (len < WPA_SUITE_LEN) {
		WL_INFORM(("wl%d: no multicast cipher suite\n", wlc->pub->unit));
		/* it is ok to not have multicast cipher */
		return 0;
	}
	/* pick up multicast cipher if we know what it is */
	mcast = (wpa_suite_mcast_t *)&wpaie[1];
	len -= WPA_SUITE_LEN;
	if (!bcmp(mcast->oui, WPA_OUI, WPA_OUI_LEN)) {
		if (IS_WPA_CIPHER(mcast->type))
			bi->wpa.multicast = mcast->type;
		else
			WL_INFORM(("wl%d: unsupported WPA multicast cipher %d\n",
				wlc->pub->unit, mcast->type));
	} else
		WL_INFORM(("wl%d: unsupported proprietary multicast cipher OUI "
			   "%02X:%02X:%02X\n", wlc->pub->unit,
			   mcast->oui[0], mcast->oui[1], mcast->oui[2]));

	/* Check for unicast suite(s) */
	if (len < WPA_IE_SUITE_COUNT_LEN) {
		WL_INFORM(("wl%d: no unicast suite\n", wlc->pub->unit));
		/* it is ok to not have unicast cipher(s) */
		return 0;
	}
	/* walk thru unicast cipher list and pick up what we recognize */
	ucast = (wpa_suite_ucast_t *)&mcast[1];
	count = ltoh16_ua(&ucast->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wpa.unicast) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(ucast->list[i].oui, WPA_OUI, WPA_OUI_LEN)) {
			if (IS_WPA_CIPHER(ucast->list[i].type))
				bi->wpa.unicast[j++] = ucast->list[i].type;
			else
				WL_INFORM(("wl%d: unsupported WPA unicast cipher %d\n",
					wlc->pub->unit, ucast->list[i].type));
		} else
			WL_INFORM(("wl%d: unsupported proprietary unicast cipher OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   ucast->list[i].oui[0], ucast->list[i].oui[1],
				   ucast->list[i].oui[2]));
	}
	bi->wpa.ucount = (uint8)j;

	/* jump to auth key mgmt suites */
	len -= (count - i) * WPA_SUITE_LEN;

	/* Check for auth key management suite(s) */
	if (len < WPA_IE_SUITE_COUNT_LEN) {
		WL_INFORM(("wl%d: auth key mgmt suite\n", wlc->pub->unit));
		/* it is ok to not have auth key mgmt suites */
		return 0;
	}
	/* walk thru auth management suite list and pick up what we recognize */
	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[count];
	count = ltoh16_ua(&mgmt->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wpa.auth) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(mgmt->list[i].oui, WPA_OUI, WPA_OUI_LEN)) {
			if (IS_WPA_AKM(mgmt->list[i].type))
				bi->wpa.auth[j++] = mgmt->list[i].type;
			else
				WL_INFORM(("wl%d: unsupported WPA auth %d\n",
					wlc->pub->unit, mgmt->list[i].type));
		} else
			WL_INFORM(("wl%d: unsupported proprietary auth OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   mgmt->list[i].oui[0], mgmt->list[i].oui[1],
				   mgmt->list[i].oui[2]));
	}
	bi->wpa.acount = (uint8)j;

	bi->flags |= WLC_BSS_WPA;


	return 0;
}

/* decode wpa2 IE to retrieve mcast/unicast ciphers and auth modes */
static int
wlc_parse_wpa2_ie(wlc_info_t *wlc, bcm_tlv_t *wpa2ie, wlc_bss_info_t *bi)
{
	int len = wpa2ie->len;		/* value length */
	wpa_suite_mcast_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *mgmt;
	uint8 *cap;
	uint16 count;
	uint i, j;

	/* Check min length and version */
	if ((len < WPA2_VERSION_LEN) ||
	    (ltoh16_ua(wpa2ie->data) != WPA2_VERSION)) {
		WL_ERROR(("wl%d: unsupported WPA2 version %d\n", wlc->pub->unit,
			ltoh16_ua(wpa2ie->data)));
		return BCME_UNSUPPORTED;
	}
	len -= WPA2_VERSION_LEN;

	/* Default WPA2 parameters */
	bi->wpa2.flags = RSN_FLAGS_SUPPORTED;
	bi->wpa2.multicast = WPA_CIPHER_AES_CCM;
	bi->wpa2.ucount = 1;
	bi->wpa2.unicast[0] = WPA_CIPHER_AES_CCM;
	bi->wpa2.acount = 1;
	bi->wpa2.auth[0] = RSN_AKM_UNSPECIFIED;


	/* Check for multicast cipher suite */
	if (len < WPA_SUITE_LEN) {
		WL_INFORM(("wl%d: no multicast cipher suite\n", wlc->pub->unit));
		/* it is ok to not have multicast cipher */
		return 0;
	}
	/* pick up multicast cipher if we know what it is */
	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];
	len -= WPA_SUITE_LEN;
	if (!bcmp(mcast->oui, WPA2_OUI, DOT11_OUI_LEN)) {
		if (IS_WPA_CIPHER(mcast->type))
			bi->wpa2.multicast = mcast->type;
		else
			WL_INFORM(("wl%d: unsupported WPA2 multicast cipher %d\n",
				wlc->pub->unit, mcast->type));
	} else
		WL_INFORM(("wl%d: unsupported proprietary multicast cipher OUI "
			   "%02X:%02X:%02X\n", wlc->pub->unit,
			   mcast->oui[0], mcast->oui[1], mcast->oui[2]));

	/* Check for unicast suite(s) */
	if (len < WPA_IE_SUITE_COUNT_LEN) {
		WL_INFORM(("wl%d: no unicast suite\n", wlc->pub->unit));
		/* it is ok to not have unicast cipher(s) */
		return 0;
	}
	/* walk thru unicast cipher list and pick up what we recognize */
	ucast = (wpa_suite_ucast_t *)&mcast[1];
	count = ltoh16_ua(&ucast->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wpa2.unicast) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(ucast->list[i].oui, WPA2_OUI, DOT11_OUI_LEN)) {
			if (IS_WPA_CIPHER(ucast->list[i].type))
				bi->wpa2.unicast[j++] = ucast->list[i].type;
			else
				WL_INFORM(("wl%d: unsupported WPA2 unicast cipher %d\n",
					wlc->pub->unit, ucast->list[i].type));
		} else
			WL_INFORM(("wl%d: unsupported proprietary unicast cipher OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   ucast->list[i].oui[0], ucast->list[i].oui[1],
				   ucast->list[i].oui[2]));
	}
	bi->wpa2.ucount = (uint8)j;

	/* jump to auth key mgmt suites */
	len -= (count - i) * WPA_SUITE_LEN;

	/* Check for auth key management suite(s) */
	if (len < WPA_IE_SUITE_COUNT_LEN) {
		WL_INFORM(("wl%d: auth key mgmt suite\n", wlc->pub->unit));
		/* it is ok to not have auth key mgmt suites */
		return 0;
	}
	/* walk thru auth management suite list and pick up what we recognize */
	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[count];
	count = ltoh16_ua(&mgmt->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wpa2.auth) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(mgmt->list[i].oui, WPA2_OUI, DOT11_OUI_LEN)) {
			if (IS_WPA2_AKM(mgmt->list[i].type))
				bi->wpa2.auth[j++] = mgmt->list[i].type;
#ifdef WLFBT
			else if (WLFBT_ENAB(wlc->pub) && IS_FBT_AKM(mgmt->list[i].type)) {
				bi->wpa2.auth[j++] = mgmt->list[i].type;
				bi->wpa2.flags |= RSN_FLAGS_FBT;
			}
#endif
#ifdef MFP
			else if (IS_MFP_AKM(mgmt->list[i].type)) {
				bi->wpa2.auth[j++] = mgmt->list[i].type;
			}
#endif
			else
				WL_INFORM(("wl%d: unsupported WPA2 auth %d\n",
					wlc->pub->unit, mgmt->list[i].type));
		} else
#if defined(IBSS_PSK)
		if (!bcmp(mgmt->list[i].oui, BRCM_OUI, DOT11_OUI_LEN)) {
			switch (mgmt->list[i].type) {
#if defined(IBSS_PSK)
			case BRCM_AKM_PSK:
				bi->wpa2.auth[j++] = mgmt->list[i].type;
				break;
#endif /* IBSS_PSK */
			default:
				WL_INFORM(("wl%d: unsupported BRCM auth %d\n",
					wlc->pub->unit, mgmt->list[i].type));
			}
		} else
#endif 
			WL_INFORM(("wl%d: unsupported proprietary auth OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   mgmt->list[i].oui[0], mgmt->list[i].oui[1],
				   mgmt->list[i].oui[2]));
	}
	bi->wpa2.acount = (uint8)j;

	bi->flags |= WLC_BSS_WPA2;

	/* jump to RSN Cap */
	len -= (count - i) * WPA_SUITE_LEN;

	if (len < RSN_CAP_LEN) {
		WL_INFORM(("wl%d: no rsn cap\n", wlc->pub->unit));
		/* it is ok to not have RSN Cap */
		return 0;
	}

	/* parse RSN capabilities */
	cap = (uint8 *)&mgmt->list[count];
	if (cap[0] & WPA_CAP_WPA2_PREAUTH)
		bi->wpa2.flags |= RSN_FLAGS_PREAUTH;

#ifdef MFP
	/* pick up MFP flags */
	if (cap[0] & RSN_CAP_MFPC) {
		bool mfp_akm = FALSE;
		for (i = 0; i < bi->wpa2.acount; i++) {
			/* pick AKM */
			if (IS_MFP_AKM(bi->wpa2.auth[i])) {
				mfp_akm = TRUE;
				break;
			}
		}
		if (!mfp_akm) {
			WL_ERROR(("wl%d: %s: peer advertised MFP but no MFP_AKM\n",
			WLCWLUNIT(wlc), __FUNCTION__));
		}
		bi->wpa2.flags |= RSN_FLAGS_MFPC;
	}
	if (cap[0] & RSN_CAP_MFPR)
		bi->wpa2.flags |= RSN_FLAGS_MFPR;

#ifdef MFP_DBG
	WL_ERROR(("wl%d: %s: peer advertised capabilities of 0x%02x 0x%02x\n",
		WLCWLUNIT(wlc), __FUNCTION__, cap[1], cap[0]));
#endif
#endif /* MFP */

	return 0;
}

#ifdef BCMWAPI_WAI
/* decode wapi IE to retrieve mcast/unicast ciphers and auth modes */
static int
wlc_parse_wapi_ie(wlc_info_t *wlc, bcm_tlv_t *wapiie, wlc_bss_info_t *bi)
{
	int len = wapiie->len;		/* value length */
	wpa_suite_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *mgmt;
	uint8 *cap;
	uint16 count;
	uint i, j;

	/* Check min length and version */
	if (len < WAPI_IE_MIN_LEN) {
		WL_ERROR(("wl%d: WAPI IE illegally short %d\n", wlc->pub->unit, len));
		return BCME_UNSUPPORTED;
	}

	if ((len < WAPI_VERSION_LEN) ||
	    (ltoh16_ua(wapiie->data) != WAPI_VERSION)) {
		WL_ERROR(("wl%d: unsupported WAPI version %d\n", wlc->pub->unit,
			ltoh16_ua(wapiie->data)));
		return BCME_UNSUPPORTED;
	}
	len -= WAPI_VERSION_LEN;

	/* Default WAPI parameters */
	bi->wapi.flags = RSN_FLAGS_SUPPORTED;
	bi->wapi.multicast = WAPI_CIPHER_SMS4;
	bi->wapi.ucount = 1;
	bi->wapi.unicast[0] = WAPI_CIPHER_SMS4;
	bi->wapi.acount = 1;
	bi->wapi.auth[0] = RSN_AKM_UNSPECIFIED;

	/* Check for auth key management suite(s) */
	/* walk thru auth management suite list and pick up what we recognize */
	mgmt = (wpa_suite_auth_key_mgmt_t *)&wapiie->data[WAPI_VERSION_LEN];
	count = ltoh16_ua(&mgmt->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wapi.auth) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(mgmt->list[i].oui, WAPI_OUI, DOT11_OUI_LEN)) {
			if (IS_WAPI_AKM(mgmt->list[i].type))
				bi->wapi.auth[j++] = mgmt->list[i].type;
			else
				WL_INFORM(("wl%d: unsupported WAPI auth %d\n",
					wlc->pub->unit, mgmt->list[i].type));
		} else
			WL_INFORM(("wl%d: unsupported proprietary auth OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   mgmt->list[i].oui[0], mgmt->list[i].oui[1],
				   mgmt->list[i].oui[2]));
	}
	bi->wapi.acount = (uint8)j;
	bi->flags |= WLC_BSS_WAPI;

	/* jump to unicast suites */
	len -= (count - i) * WPA_SUITE_LEN;

	/* Check for unicast suites */
	if (len < WPA_IE_SUITE_COUNT_LEN) {
		WL_INFORM(("wl%d: no unicast suite\n", wlc->pub->unit));
		return BCME_UNSUPPORTED;
	}

	/* walk thru unicast cipher list and pick up what we recognize */
	ucast = (wpa_suite_ucast_t *)&mgmt->list[count];
	count = ltoh16_ua(&ucast->count);
	len -= WPA_IE_SUITE_COUNT_LEN;
	for (i = 0, j = 0;
	     i < count && j < ARRAYSIZE(bi->wapi.unicast) && len >= WPA_SUITE_LEN;
	     i ++, len -= WPA_SUITE_LEN) {
		if (!bcmp(ucast->list[i].oui, WPA2_OUI, DOT11_OUI_LEN)) {
			if (IS_WAPI_CIPHER(ucast->list[i].type))
				bi->wapi.unicast[j++] = WAPI_CSE_WPI_2_CIPHER(ucast->list[i].type);
			else
				WL_INFORM(("wl%d: unsupported WAPI unicast cipher %d\n",
					wlc->pub->unit, ucast->list[i].type));
		} else
			WL_INFORM(("wl%d: unsupported proprietary unicast cipher OUI "
				   "%02X:%02X:%02X\n", wlc->pub->unit,
				   ucast->list[i].oui[0], ucast->list[i].oui[1],
				   ucast->list[i].oui[2]));
	}
	bi->wapi.ucount = (uint8)j;

	/* jump to mcast suites */
	len -= (count - i) * WPA_SUITE_LEN;

	/* Check for multicast cipher suite */
	if (len < WPA_SUITE_LEN) {
		WL_INFORM(("wl%d: no multicast cipher suite\n", wlc->pub->unit));
		return BCME_UNSUPPORTED;
	}

	/* pick up multicast cipher if we know what it is */
	mcast = (wpa_suite_mcast_t *)&ucast->list[count];
	len -= WPA_SUITE_LEN;
	if (!bcmp(mcast->oui, WAPI_OUI, DOT11_OUI_LEN)) {
		if (IS_WAPI_CIPHER(mcast->type))
			bi->wapi.multicast = WAPI_CSE_WPI_2_CIPHER(mcast->type);
		else
			WL_INFORM(("wl%d: unsupported WAPI multicast cipher %d\n",
				wlc->pub->unit, mcast->type));
	} else
		WL_INFORM(("wl%d: unsupported proprietary multicast cipher OUI "
			   "%02X:%02X:%02X\n", wlc->pub->unit,
			   mcast->oui[0], mcast->oui[1], mcast->oui[2]));

	/* RSN capabilities is optional */
	if (len < RSN_CAP_LEN) {
		WL_INFORM(("wl%d: no rsn cap\n", wlc->pub->unit));
		/* it is ok to not have RSN Cap */
		return 0;
	}

	/* parse RSN capabilities */
	cap = (uint8 *)&mcast[1];
	if (cap[0] & WAPI_CAP_PREAUTH)
		bi->wapi.flags |= RSN_FLAGS_PREAUTH;

	return 0;
}
#endif /* BCMWAPI_WAI */

int
wlc_recv_parse_bcn_prb(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, struct ether_addr *bssid, bool beacon,
	void *body, uint body_len, wlc_bss_info_t *bi)
{
	struct dot11_bcn_prb *fixed = (struct dot11_bcn_prb *) body;
	uint16 cap;
	uint8 chan = 0;
	uint8 rx_chan;
	uint8 *tlvs;
	uint tlvs_len;
	uint8 *parse;
	uint parse_len;
	bcm_tlv_t *ie;
	wpa_ie_fixed_t *wpaie;
	ht_cap_ie_t *cap_ie;
	ht_add_ie_t *add_ie;

	if (body_len < sizeof(struct dot11_bcn_prb)) {
		WL_INFORM(("wl%d: %s: invalid frame length\n", wlc->pub->unit, __FUNCTION__));
		return (-1);
	}

	/* check validity of beacon before update */
	tlvs_len = body_len - DOT11_BCN_PRB_LEN;
	tlvs = (uint8 *)body + DOT11_BCN_PRB_LEN;

	/* grab the channel from the rxheader, need conversion for b/g phy */
	rx_chan = (uint8)wlc_recv_mgmt_rx_channel_get(wrxh);

	/* check the freq. */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_DS_PARMS_ID)) != NULL) {
		chan = ie->data[0];
		if (!wlc_valid_chanspec_db(wlc->cmi, CH20MHZ_CHSPEC(chan)) &&
			!(wlc->scan->state & SCAN_STATE_PROHIBIT)) {
			WL_INFORM(("Bad channel in beacon: %d\n", chan));
			return (-1);
		}
	} else {
		/* 802.11a beacons don't have a DS tlv in them.
		 * Figure it out from the current mac channel.
		 */
		chan = rx_chan;
	}

	/* Fill in bss with new info */
	bzero((char*)bi, sizeof(wlc_bss_info_t));

	bcopy((char *)bssid, (char *)&bi->BSSID, ETHER_ADDR_LEN);

	cap = ltoh16_ua(&fixed->capability);
	if ((cap & DOT11_CAP_ESS) && !(cap & DOT11_CAP_IBSS))
		bi->infra = 1;
	bi->capability = cap;

	bi->flags |= beacon ? WLC_BSS_BEACON : 0;

	bi->RSSI = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);

#ifdef STA
	/* extract SNR from rxh */
	bi->SNR = (int16)wlc_recv_snr_compute(wlc, wrxh);
#endif

	/* flag if this is an RSSI reading on same channel as the bcn/prb was transmitted */
	if (rx_chan == chan)
		bi->flags |= WLC_BSS_RSSI_ON_CHANNEL;

	/* extract phy_noise from the channel indexed array */
	bi->phy_noise = wlc->phy_noise_list[chan];

	bi->beacon_period = ltoh16_ua(&fixed->beacon_interval);

	/* process tagged fields */

	/* SSID */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_SSID_ID)) != NULL &&
	    ie->len <= DOT11_MAX_SSID_LEN) {
		bi->SSID_len = ie->len;
		bcopy(ie->data, bi->SSID, bi->SSID_len);
	} else {
		WL_INFORM(("Missing SSID info in beacon\n"));
		bi->SSID_len = 0;
	}

	/* parse rateset and pull out raw rateset */
	if (wlc_parse_rates(wlc, tlvs, tlvs_len, bi, NULL) != 0) {
		WL_INFORM(("Missing or Invalid rate info in beacon\n"));
		return (-1);
	}

	/* Check for a legacy 54G bcn/proberesp by looking for more than 8 rates
	 * in the Supported Rates elt
	 */
	ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_RATES_ID);
	if (ie && ie->len > 8) {
		bi->flags |= WLC_BSS_54G;
	}

	/* DS parameters */
	bi->chanspec = CH20MHZ_CHSPEC(chan);

	/* IBSS parameters */
	if (cap & DOT11_CAP_IBSS) {
		if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_IBSS_PARMS_ID)) != NULL &&
		    ie->len >= DOT11_MNG_IBSS_PARAM_LEN) {
			bi->atim_window = ltoh16_ua(ie->data);
		}
	}

	if (SCAN_IN_PROGRESS(wlc->scan) &&
	    !wlc_scan_recv_parse_bcn_prb(wlc->scan, beacon, bi, wrxh, body, body_len)) {
		WL_INFORM(("wl%d: %s: wlc_scan_parse_bcn_prb failed\n",
		           wlc->pub->unit, __FUNCTION__));
		return -1;
	}

#ifdef WLBTAMP
	/* 802.11e parameters */
	if (BTA_ENAB(wlc->pub)) {
		parse = tlvs;
		parse_len = tlvs_len;
		while ((ie = bcm_parse_tlvs(parse, parse_len, DOT11_MNG_EDCA_PARAM_ID)))
			break;
		if (ie) {
			edca_param_ie_t *edcaie = (edca_param_ie_t *)&ie->data;

			bi->flags |= WLC_BSS_11E;
			bi->wme_qosinfo = edcaie->qosinfo;
		}
	}
#endif /* WLBTAMP */

	/* WPA2 parameters */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_RSN_ID)) != NULL)
		wlc_parse_wpa2_ie(wlc, ie, bi);
#ifdef WLFBT
	if (WLFBT_ENAB(wlc->pub) &&
		(ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_MDIE_ID)) != NULL) {
		dot11_mdid_ie_t* mdieptr = (dot11_mdid_ie_t*)ie;

		bi->mdid = ltoh16_ua(&mdieptr->mdid);

		bi->flags |= WLC_BSS_FBT;
		if (mdieptr->cap & FBT_MDID_CAP_OVERDS)
			bi->flags2 |= WLC_BSS_OVERDS_FBT;
	}
#endif

#ifdef BCMWAPI_WAI
	/* WAPI parameters */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_WAPI_ID)) != NULL)
		wlc_parse_wapi_ie(wlc, ie, bi);
#endif /* BCMWAPI_WAI */

	/* WPA parameters */
	parse = tlvs;
	parse_len = tlvs_len;
	if ((wpaie = bcm_find_wpaie(parse, parse_len)) != NULL)
		wlc_parse_wpa_ie(wlc, wpaie, bi);

	/* WME parameters */
	if (WME_ENAB(wlc->pub)) {
		parse = tlvs;
		parse_len = tlvs_len;
		while ((ie = bcm_parse_tlvs(parse, parse_len, DOT11_MNG_PROPR_ID)))
			if (wlc_is_wme_ie(wlc, (uint8 *)ie, &parse, &parse_len))
				break;
		if (ie) {
			wme_param_ie_t *wmeie_body = (wme_param_ie_t *)&ie->data;
			bi->flags |= WLC_BSS_WME;
			bi->wme_qosinfo = wmeie_body->qosinfo;
		}
	}

	/* Is the AP from Broadcom */
	if (wlc_find_vendor_ie(tlvs, tlvs_len, (const uchar*)BRCM_OUI, NULL, 0) != NULL)
		bi->flags |= WLC_BSS_BRCM;

	/* find the 11n HT capability ie, mark the bss as 11n (HT) and save the mcs set */
	bi->flags &= ~(WLC_BSS_HT | WLC_BSS_40MHZ | WLC_BSS_40INTOL);
	bi->flags &= ~(WLC_BSS_SGI_20 | WLC_BSS_SGI_40);

	cap_ie = wlc_read_ht_cap_ies(wlc, tlvs, tlvs_len);
	if (cap_ie) {
		uint16 ht_cap = ltoh16_ua(&cap_ie->cap);

		/* Mark the BSS as HT capable */
		bi->flags |= WLC_BSS_HT;

		/* Mark the BSS as 40 Intolerant if bit is set */
		if (ht_cap & HT_CAP_40MHZ_INTOLERANT) {
			bi->flags |= WLC_BSS_40INTOL;

#ifdef WL11N
			/* for AP, this is trigger event B (teb) */
			if (AP_ENAB(wlc->pub) && COEX_ACTIVE(wlc))
				wlc_ht_ap_coex_tebc_proc(wlc);
#endif
		}

		/* Set SGI flags */
		if (ht_cap & HT_CAP_SHORT_GI_20)
			bi->flags |= WLC_BSS_SGI_20;
		if (ht_cap & HT_CAP_SHORT_GI_40)
			bi->flags |= WLC_BSS_SGI_40;

		/* copy the raw mcs set into the bss rateset struct */
		bcopy(&cap_ie->supp_mcs[0], &bi->rateset.mcs[0], MCSSET_LEN);
		add_ie = wlc_read_ht_add_ies(wlc, tlvs, tlvs_len);
		if (add_ie) {
			bi->chanspec = wlc_ht_chanspec(wlc, add_ie->ctl_ch, add_ie->byte1);
			/* Set 40MHZ employed bit on bss */
			if (ht_cap & HT_CAP_40MHZ)
				if (add_ie->byte1 & HT_BW_ANY)
					bi->flags |= WLC_BSS_40MHZ;
		}
	}

	return 0;
}

bool
wlc_erp_find(wlc_info_t *wlc, void *body, uint body_len, uint8 **erp, int *len)
{
	bcm_tlv_t *ie;
	uint8 *tlvs = (uint8 *)body + DOT11_BCN_PRB_LEN;
	int tlvs_len = body_len - DOT11_BCN_PRB_LEN;

	ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_ERP_ID);

	if (ie == NULL)
		return FALSE;

	*len = ie->len;
	*erp = ie->data;

	return TRUE;
}

/* Look for the 802.11g 4.0 draft NonERP information elt
 * for legacy drivers that implemented it.
 */
bool
wlc_nonerp_find(wlc_info_t *wlc, void *body, uint body_len, uint8 **erp, int *len)
{
	bcm_tlv_t *ie;
	uint nonerp_len;
	uint8 *tlvs = (uint8 *)body + DOT11_BCN_PRB_LEN;
	int tlvs_len = body_len - DOT11_BCN_PRB_LEN;

	ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_NONERP_ID);

	if (ie == NULL)
		return FALSE;

	/* Use specific details to validate the element as the legacy
	 * NonERP. Since the NonERP ID is not reserved, it may be used
	 * in the future for some other Info Element. The validation
	 * is an effort to avoid incorrectly identifying a future Info
	 * Element as a legacy NonERP.  This validation can be dropped
	 * if ID 47 is reserved for legacy NonERP.
	 */

	nonerp_len = ie->len;

	/* validate the legacy NonERP info elt as 1 or 2 bytes long
	 * and that only bits 0 and 1 may be set, all others are zero
	 */
	if ((nonerp_len == 1 && (ie->data[0] & 0xFC) == 0) ||
	    (nonerp_len == 2 && (ie->data[0] & 0xFC) == 0 && ie->data[1] == 0)) {
		*len = nonerp_len;
		*erp = ie->data;

		return TRUE;
	}

	return FALSE;
}

/*	Max buffering needed for beacon template/prb resp template is 142 bytes.
 *
 *	PLCP header is 6 bytes.
 *	802.11 A3 header is 24 bytes.
 *	Max beacon frame body template length is 112 bytes.
 *	Max probe resp frame body template length is 110 bytes.
 *
 *      *len on input contains the max length of the packet available.
 *
 *	The *len value is set to the number of bytes in buf used, and starts with the PLCP
 *	and included up to, but not including, the 4 byte FCS.
 */
static void
wlc_bcn_prb_template(wlc_info_t *wlc, uint type, ratespec_t bcn_rspec, wlc_bsscfg_t *cfg,
                     uint16 *buf, int *len)
{
	cck_phy_hdr_t *plcp;
	struct dot11_management_header *h;
	int hdr_len, body_len;

	ASSERT(*len >= 142);
	ASSERT(type == FC_BEACON || type == FC_PROBE_RESP);

	if (MBSS_BCN_ENAB(cfg) && type == FC_BEACON)
		hdr_len = DOT11_MAC_HDR_LEN;
	else
		hdr_len = D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN;
	body_len = *len - hdr_len; /* calc buffer size provided for frame body */

	wlc_bcn_prb_body(wlc, type, cfg, (uint8 *)buf + hdr_len, &body_len, FALSE);

	*len = hdr_len + body_len; /* return actual size */

	/* format PHY and MAC headers */
	bzero((char*)buf, hdr_len);

	plcp = (cck_phy_hdr_t *)buf;

	/* PLCP for Probe Response frames are filled in from core's rate table */
	if (type == FC_BEACON && !MBSS_BCN_ENAB(cfg)) {
		/* fill in PLCP */
		wlc_compute_plcp(wlc, bcn_rspec, (DOT11_MAC_HDR_LEN + body_len + DOT11_FCS_LEN),
			(uint8*)plcp);

	}
	/* "Regular" and 16 MBSS but not for 4 MBSS */
	/* Update the phytxctl for the beacon based on the rspec */
	if (!SOFTBCN_ENAB(cfg) && (type == FC_BEACON)) {
		wlc_beacon_phytxctl_txant_upd(wlc, bcn_rspec);
	}

	if (MBSS_BCN_ENAB(cfg) && type == FC_BEACON)
		h = (struct dot11_management_header *)&plcp[0];
	else
		h = (struct dot11_management_header *)&plcp[1];

	/* fill in 802.11 header */
	h->fc = htol16((uint16)type);

	/* DUR is 0 for multicast bcn, or filled in by MAC for prb resp */
	/* A1 filled in by MAC for prb resp, broadcast for bcn */
	if (type == FC_BEACON)
		bcopy((const char*)&ether_bcast, (char*)&h->da, ETHER_ADDR_LEN);
	bcopy((char*)&cfg->cur_etheraddr, (char*)&h->sa, ETHER_ADDR_LEN);
	bcopy((char*)&cfg->BSSID, (char*)&h->bssid, ETHER_ADDR_LEN);

	/* SEQ filled in by MAC */

	return;
}


/* Update a beacon for a particular BSS
 * For MBSS, this updates the software template and sets "latest" to the index of the
 * template updated.
 * Otherwise, it updates the hardware template.
 */
void
wlc_bss_update_beacon(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	int len = BCN_TMPL_LEN;

	/* Clear the soft intmask */
	wlc->defmacintmask &= ~MI_BCNTPL;

	if (!cfg->up) { /* Only allow updates on an UP bss */
		return;
	}

	if (MBSS_BCN_ENAB(cfg)) { /* Optimize:  Some of if/else could be combined */
#if defined(MBSS)
		int idx;
		wlc_pkt_t pkt;

		/* Find a non-inuse buffer */
		if ((idx = SPT_PAIR_AVAIL(cfg->bcn_template)) == -1) {
			ASSERT(0 && "Beacon template not available");
			return;
		}
		pkt = cfg->bcn_template->pkts[idx];
		ASSERT(pkt != NULL);

		/* Pull off space so that d11hdrs below works */
		PKTPULL(wlc->osh, pkt, D11_PHY_HDR_LEN + D11_TXH_LEN);

		wlc->bcn_rspec = wlc_lowest_basic_rspec(wlc, &cfg->current_bss->rateset);
		ASSERT(wlc_valid_rate(wlc, wlc->bcn_rspec,
		                      CHSPEC_IS2G(cfg->current_bss->chanspec) ?
		                      WLC_BAND_2G : WLC_BAND_5G, TRUE));
		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg,
			(uint16 *)PKTDATA(wlc->osh, pkt), &len);
		PKTSETLEN(wlc->osh, pkt, len);
		wlc_d11hdrs(wlc, pkt, wlc->band->hwrs_scb, FALSE, 0, 0,
			TX_ATIM_FIFO, 0, NULL, wlc->bcn_rspec);

		/* Indicate most recently updated index */
		cfg->bcn_template->latest_idx = idx;
		cfg->bcn_template->bcn_modified = TRUE;
#endif /* MBSS */
	} else if (HWBCN_ENAB(cfg)) { /* Hardware beaconing for this config */
		uint16	bcn[BCN_TMPL_LEN / 2];
		uint32	both_valid = MCMD_BCN0VLD | MCMD_BCN1VLD;
		d11regs_t *regs = wlc->regs;
		osl_t *osh = NULL;

		osh = wlc->osh;

		/* Check if both templates are in use, if so sched. an interrupt
		 *	that will call back into this routine
		 */
		if ((R_REG(osh, &regs->maccommand) & both_valid) == both_valid) {
			/* clear any previous status */
			W_REG(osh, &regs->macintstatus, MI_BCNTPL);
		}
		/* Check that after scheduling the interrupt both of the
		 *	templates are still busy. if not clear the int. & remask
		 */
		if ((R_REG(osh, &regs->maccommand) & both_valid) == both_valid) {
			wlc->defmacintmask |= MI_BCNTPL;
			return;
		}

		wlc->bcn_rspec = wlc_lowest_basic_rspec(wlc, &cfg->current_bss->rateset);
		ASSERT(wlc_valid_rate(wlc, wlc->bcn_rspec,
		                      CHSPEC_IS2G(cfg->current_bss->chanspec) ?
		                      WLC_BAND_2G : WLC_BAND_5G, TRUE));

		/* update the template and ucode shm */
		wlc_bcn_prb_template(wlc, FC_BEACON, wlc->bcn_rspec, cfg, bcn, &len);
		wlc_write_hw_bcntemplates(wlc, bcn, len, FALSE);
	}
}

#ifdef MBSS

/* Internal macro to set SSID length register values properly */
#define _MBSS_SSID_LEN_SET(idx, reg_val, set_val) do { \
		if ((idx) % 2) { \
			(reg_val) &= ~0xff00; \
			(reg_val) |= ((set_val) & 0xff) << 8; \
		} else { \
			(reg_val) &= ~0xff; \
			(reg_val) |= (set_val) & 0xff; \
		} \
	} while (0)

/* Use to set a specific SSID length */
static void
wlc_mbss_ssid_len_set(wlc_info_t *wlc, int idx, uint8 in_val)
{
	uint16 tmp_val;
	tmp_val = wlc_read_shm(wlc, _MBSS_SSID_LEN_SELECT(wlc, idx));
	_MBSS_SSID_LEN_SET(idx, tmp_val, in_val);
	wlc_write_shm(wlc, _MBSS_SSID_LEN_SELECT(wlc, idx), tmp_val);
}
#endif /* MBSS */

/*
 * Update all beacons for the system.
 */
void
wlc_update_beacon(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *bsscfg;

	/* update AP or IBSS beacons */
	FOREACH_BSS(wlc, idx, bsscfg) {
		if (bsscfg->up &&
		    (BSSCFG_AP(bsscfg) || !bsscfg->BSS))
			wlc_bss_update_beacon(wlc, bsscfg);
	}
}

/* Write ssid into shared memory */
void
wlc_shm_ssid_upd(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	uint8 *ssidptr = cfg->SSID;
	uint16 base = M_SSID;
	uint8 ssidbuf[DOT11_MAX_SSID_LEN];


#ifdef MBSS
	if (MBSS_ENAB(wlc->pub)) { /* Update based on uCode index of BSS */
		int uc_idx;

		if (MBSS_ENAB16(wlc->pub)) {
			wlc_mbss16_updssid(wlc, cfg);
			/* tell ucode where to find the probe responses */
			if (D11REV_GE(wlc->pub->corerev, 16))
				/* for corerev >= 16 the value is in multiple of 4 */
				wlc_write_shm(wlc, SHM_MBSS_PRS_TPLPTR,
					(MBSS_PRS_BLKS_START(wlc->max_ap_bss) >> 2));
			else
				wlc_write_shm(wlc, SHM_MBSS_PRS_TPLPTR,
					MBSS_PRS_BLKS_START(wlc->max_ap_bss));

			wlc_write_shm(wlc, SHM_MBSS_BC_FID1, wlc->mbss_ucidx_mask);
			return;
		}
		uc_idx = WLC_BSSCFG_UCIDX(cfg);
		base = SHM_MBSS_SSID_ADDR(uc_idx); /* Update base addr for ssid */
		wlc_mbss_ssid_len_set(wlc, uc_idx, cfg->SSID_len);
	}
#endif /* MBSS */

	/* padding the ssid with zero and copy it into shm */
	bzero(ssidbuf, DOT11_MAX_SSID_LEN);
	bcopy(ssidptr, ssidbuf, cfg->SSID_len);

	wlc_copyto_shm(wlc, base, ssidbuf, DOT11_MAX_SSID_LEN);

	if (!MBSS_BCN_ENAB(cfg))
		wlc_write_shm(wlc, M_SSIDLEN, (uint16)cfg->SSID_len);
}

void
wlc_update_probe_resp(wlc_info_t *wlc, bool suspend)
{
	int idx;
	wlc_bsscfg_t *bsscfg;

	/* update AP or IBSS probe responses */
	FOREACH_BSS(wlc, idx, bsscfg) {
		if (bsscfg->up &&
		    (BSSCFG_AP(bsscfg) || !bsscfg->BSS))
			wlc_bss_update_probe_resp(wlc, bsscfg, suspend);
	}
}

void
wlc_bss_update_probe_resp(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bool suspend)
{
	int len = BCN_TMPL_LEN;

#ifdef WLPROBRESP_SW
	return;
#endif

	/* write the probe response to hardware, or save in the config structure */
	if (!MBSS_PRB_ENAB(cfg)) {
		uint16 prb_resp[BCN_TMPL_LEN/2];

		/* create the probe response template */
		wlc_bcn_prb_template(wlc, FC_PROBE_RESP, 0, cfg, prb_resp, &len);

		if (suspend)
			wlc_suspend_mac_and_wait(wlc);

		/* write the probe response into the template region */
		wlc_bmac_write_template_ram(wlc->hw, T_PRS_TPL_BASE, (len + 3) & ~3, prb_resp);

		/* write the length of the probe response frame (+PLCP/-FCS) */
		wlc_write_shm(wlc, M_PRB_RESP_FRM_LEN, (uint16)len);

		/* write the SSID and SSID length */
		wlc_shm_ssid_upd(wlc, cfg);

		/*
		 * Write PLCP headers and durations for probe response frames at all rates.
		 * Use the actual frame length covered by the PLCP header for the call to
		 * wlc_mod_prb_rsp_rate_table() by subtracting the PLCP len and adding the FCS.
		 */
		len += (-D11_PHY_HDR_LEN + DOT11_FCS_LEN);
		wlc_mod_prb_rsp_rate_table(wlc, (uint16)len);

		if (suspend)
			wlc_enable_mac(wlc);
	} else { /* Generating probe resp in sw; update local template */
#if defined(MBSS)
		uint8 *pbody;
		wlc_pkt_t pkt;

		/* Probe response template includes everything from the PLCP header on */
		if ((pkt = cfg->probe_template) == NULL) {
			pkt = wlc_frame_get_mgmt(wlc, FC_PROBE_RESP, &ether_null,
				&cfg->cur_etheraddr, &cfg->BSSID, BCN_TMPL_LEN, &pbody);
			if (pkt == NULL) {
				WL_ERROR(("Could not allocate SW probe template\n"));
				return;
			}
			cfg->probe_template = pkt;
		} else {
			/* Pull back PLCP and TX headers since wlc_d11hdrs puts them back */
			PKTPULL(wlc->osh, pkt, D11_PHY_HDR_LEN + D11_TXH_LEN);
			/* PKTDATA is now at start of D11 hdr; find packet body */
			pbody = (uint8 *)PKTDATA(wlc->osh, pkt) + DOT11_MGMT_HDR_LEN;
		}

		/* At this point, PKTDATA is at start of D11 hdr; pbody past D11 hdr */

		/* Generate probe body */
		wlc_bcn_prb_body(wlc, FC_PROBE_RESP, cfg, pbody, &len, FALSE);

		/* Set the length and set up the D11, PLCP and transmit headers */
		PKTSETLEN(wlc->osh, pkt, len + DOT11_MGMT_HDR_LEN);
		wlc_d11hdrs(wlc, pkt, wlc->band->hwrs_scb, FALSE, 0, 0, TX_ATIM_FIFO, 0, NULL, 0);

#ifdef WLLPRS
		if (N_ENAB(wlc->pub) && D11REV_ISMBSS16(wlc->pub->corerev)) {
			/* Probe response template includes everything from the PLCP
			 * header on.
			 */
			if ((pkt = cfg->lprs_template) == NULL) {
				pkt = wlc_frame_get_mgmt(wlc, FC_PROBE_RESP, &ether_null,
					&cfg->cur_etheraddr, &cfg->BSSID, LPRS_TMPL_LEN, &pbody);
				if (pkt == NULL) {
					WL_ERROR(("Could not alloc SW 11g probe template\n"));
					return;
				}
				cfg->lprs_template = pkt;
			} else {
				/* Pull back PLCP and TX headers since wlc_d11hdrs
				 * pushes them.
				 */
				PKTPULL(wlc->osh, pkt, D11_PHY_HDR_LEN + D11_TXH_LEN);

				/* PKTDATA is now at start of D11 hdr; find packet body */
				pbody = (uint8 *)PKTDATA(wlc->osh, pkt) + DOT11_MGMT_HDR_LEN;
			}

			/* At this point, PKTDATA is at start of D11 hdr; pbody past D11 hdr */

			/* Generate probe body */
			len = LPRS_TMPL_LEN;
			wlc_bcn_prb_body(wlc, FC_PROBE_RESP, cfg, pbody, &len, TRUE);

			/* Set the length and set up the D11, PLCP and transmit headers */
			PKTSETLEN(wlc->osh, pkt, len + DOT11_MGMT_HDR_LEN);
			wlc_d11hdrs(wlc, pkt, wlc->band->hwrs_scb, FALSE, 0, 0,
				TX_ATIM_FIFO, 0, NULL, 0);
		}
#endif /* WLLPRS */

		cfg->prb_modified = TRUE;

		if (UCTPL_MBSS_ENAB(cfg)) {
			/* Update HW template for MBSS16 */
			wlc_ap_mbss16_write_prbrsp(wlc, cfg, suspend);
		}
#else
		ASSERT(0 && "No software probe response support without MBSS");
#endif /* MBSS */
	}
}

static uint8 *
wlc_write_wpa_ie_safe(wlc_info_t *wlc, uint8 *cp, int buflen, uint16 WPA_auth,
	uint32 wsec, wlc_bsscfg_t *bsscfg, wlc_bss_info_t *current_bss)
{
	uint WPA_len = 0;	/* tag length */

	if (! INCLUDES_WPA_AUTH(bsscfg->WPA_auth) || ! WSEC_ENABLED(wsec))
		return cp;

	WL_WSEC(("wl%d: adding WPA IE, wsec = 0x%x\n", wlc->pub->unit, wsec));

	/* IBSS WPA info element */
	if (!current_bss->infra) {
		/* copy WPA info element template */
		WPA_len = WPA_info_element[1];

		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN((TLV_HDR_LEN + WPA_len), buflen, cp);

		bcopy(WPA_info_element, cp, TLV_HDR_LEN + WPA_len);

		/* select multicast cipher */
		/* - use highest encryption status enabled */
		if (WSEC_AES_ENABLED(wsec))
		    cp[11] = WPA_CIPHER_AES_CCM;
		else if (WSEC_TKIP_ENABLED(wsec))
		    cp[11] = WPA_CIPHER_TKIP;
		else {
			/* - w/ v.22 client, IE must specify WEP key size
			 *   which isn't available from config, so use the key...
			 */
			wsec_key_t *key = WSEC_BSS_DEFAULT_KEY(bsscfg);

			if (key != NULL) {
				if (key->algo == CRYPTO_ALGO_WEP1) {
					cp[11] = WPA_CIPHER_WEP_40;
				} else if (key->algo == CRYPTO_ALGO_WEP128) {
					cp[11] = WPA_CIPHER_WEP_104;
				} else {
					WL_ERROR(("wl%d: wlc_bcn_prb_body: key->algo %d"
						  " doesn't match wsec 0x%x\n",
						  wlc->pub->unit, key->algo, wsec));
					cp[11] = WPA_CIPHER_WEP_40;
				}
			} else {
				cp[11] = WPA_CIPHER_WEP_40;
			}
		}

		/* set unicast cipher and authenticated key management */
		cp[17] = WPA_CIPHER_NONE;
		cp[23] = RSN_AKM_NONE;

		/* WPA capabilities */
		wlc_wpa_cap(wlc, bsscfg, &cp[24], WPA_CAP_LEN);
	} else {
		wpa_ie_fixed_t *wpaie = (wpa_ie_fixed_t *)cp;
		wpa_suite_mcast_t *mcast;
		wpa_suite_ucast_t *ucast;
		wpa_suite_auth_key_mgmt_t *auth;
		uint16 count;
		uint8 *orig_cp = cp;
		int totlen;

		/* fixed portion */

		/* length check */
		/* if buffer too small, return untouched buffer */
		totlen = (TLV_HDR_LEN + WPA_IE_TAG_FIXED_LEN) +
			WPA_SUITE_LEN + WPA_IE_SUITE_COUNT_LEN;
		BUFLEN_CHECK_AND_RETURN(totlen, buflen, orig_cp);
		buflen -= totlen;

		wpaie->tag = DOT11_MNG_WPA_ID;
		bcopy(WPA_OUI, wpaie->oui, sizeof(wpaie->oui));
		wpaie->oui_type = 1;
		wpaie->version.low = (uint8)WPA_VERSION;
		wpaie->version.high = (uint8)(WPA_VERSION>>8);
		WPA_len = WPA_IE_TAG_FIXED_LEN;

		/* multicast suite */
		mcast = (wpa_suite_mcast_t *)&wpaie[1];
		bcopy(WPA_OUI, mcast->oui, DOT11_OUI_LEN);
		mcast->type = wlc_wpa_mcast_cipher(wlc, bsscfg);
		WPA_len += WPA_SUITE_LEN;

		/* unicast suite list */
		ucast = (wpa_suite_ucast_t *)&mcast[1];
		count = 0;
		WPA_len += WPA_IE_SUITE_COUNT_LEN;

		if (WSEC_AES_ENABLED(wsec)) {
			/* length check */
			/* if buffer too small, return untouched buffer */
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA_OUI, ucast->list[count].oui, DOT11_OUI_LEN);
			ucast->list[count++].type = WPA_CIPHER_AES_CCM;
			WPA_len += WPA_SUITE_LEN;
			buflen -= WPA_SUITE_LEN;
		}
		if (WSEC_TKIP_ENABLED(wsec)) {
			/* length check */
			/* if buffer too small, return untouched buffer */
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA_OUI, ucast->list[count].oui, DOT11_OUI_LEN);
			ucast->list[count++].type = WPA_CIPHER_TKIP;
			WPA_len += WPA_SUITE_LEN;
			buflen -= WPA_SUITE_LEN;
		}
		ASSERT(count);
		ucast->count.low = (uint8)count;
		ucast->count.high = (uint8)(count>>8);

		/* authenticated key management suite list */
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_IE_SUITE_COUNT_LEN, buflen, orig_cp);
		auth = (wpa_suite_auth_key_mgmt_t *)&ucast->list[count];
		count = 0;
		WPA_len += WPA_IE_SUITE_COUNT_LEN;
		buflen -= WPA_IE_SUITE_COUNT_LEN;

		ASSERT(!(WPA_auth & WPA_AUTH_NONE));
		if (WPA_auth & WPA_AUTH_UNSPECIFIED) {
			/* length check */
			/* if buffer too small, return untouched buffer */
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA_OUI, auth->list[count].oui, DOT11_OUI_LEN);
			auth->list[count++].type = RSN_AKM_UNSPECIFIED;
			WPA_len += WPA_SUITE_LEN;
			buflen -= WPA_SUITE_LEN;
		}
		if (WPA_auth & WPA_AUTH_PSK) {
			/* length check */
			/* if buffer too small, return untouched buffer */
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA_OUI, auth->list[count].oui, DOT11_OUI_LEN);
			auth->list[count++].type = RSN_AKM_PSK;
			WPA_len += WPA_SUITE_LEN;
			buflen -= WPA_SUITE_LEN;
		}
		ASSERT(count);
		auth->count.low = (uint8)count;
		auth->count.high = (uint8)(count>>8);

#ifndef MACOSX
		/* WPA capabilities */
		{
			uint8 *cap;

			/* length check */
			/* if buffer too small, return untouched buffer */
			BUFLEN_CHECK_AND_RETURN(WPA_CAP_LEN, buflen, orig_cp);
			cap = (uint8 *)&auth->list[count];
			wlc_wpa_cap(wlc, bsscfg, cap, WPA_CAP_LEN);
			WPA_len += WPA_CAP_LEN;
			buflen -= WPA_CAP_LEN;
		}
#endif /* MACOSX */

		/* update tag length */
		wpaie->length = (uint8)WPA_len;
	}

	if (WPA_len)
	    cp += TLV_HDR_LEN + WPA_len;

	return (cp);
}

static uint8 *
wlc_write_rsn_ie_safe(wlc_info_t *wlc, uint8 *cp, int buflen, uint16 WPA_auth,
	uint32 wsec, wlc_bsscfg_t *bsscfg)
{
	/* Infrastructure WPA info element */
	uint WPA_len = 0;	/* tag length */
	bcm_tlv_t *wpa2ie = (bcm_tlv_t *)cp;
	wpa_suite_mcast_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *auth;
	uint16 count;
	uint8 *cap;
	uint8 *orig_cp = cp;
	int totlen;

	if (! INCLUDES_WPA2_AUTH(bsscfg->WPA_auth) || ! WSEC_ENABLED(wsec))
		return cp;

	WL_WSEC(("wl%d: adding RSN IE, wsec = 0x%x\n", wlc->pub->unit, wsec));

	/* perform length check */
	/* if buffer too small, return untouched buffer */
	totlen = (int)(&wpa2ie->data[WPA2_VERSION_LEN] - &wpa2ie->id) +
		WPA_SUITE_LEN + WPA_IE_SUITE_COUNT_LEN;
	BUFLEN_CHECK_AND_RETURN(totlen, buflen, orig_cp);
	buflen -= totlen;

	/* fixed portion */
	wpa2ie->id = DOT11_MNG_RSN_ID;
	wpa2ie->data[0] = (uint8)WPA2_VERSION;
	wpa2ie->data[1] = (uint8)(WPA2_VERSION>>8);
	WPA_len = WPA2_VERSION_LEN;

	/* multicast suite */
	mcast = (wpa_suite_mcast_t *)&wpa2ie->data[WPA2_VERSION_LEN];

	{
		bcopy(WPA2_OUI, mcast->oui, DOT11_OUI_LEN);
		mcast->type = wlc_wpa_mcast_cipher(wlc, bsscfg);
	}
	WPA_len += WPA_SUITE_LEN;

	/* unicast suite list */
	ucast = (wpa_suite_ucast_t *)&mcast[1];
	count = 0;

	WPA_len += WPA_IE_SUITE_COUNT_LEN;

	if (WSEC_AES_ENABLED(wsec)) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);

		bcopy(WPA2_OUI, ucast->list[count].oui, DOT11_OUI_LEN);
		ucast->list[count++].type = WPA_CIPHER_AES_CCM;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}
	if (WSEC_TKIP_ENABLED(wsec)) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);

		bcopy(WPA2_OUI, ucast->list[count].oui, DOT11_OUI_LEN);
		ucast->list[count++].type = WPA_CIPHER_TKIP;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}
	ASSERT(count);
	ucast->count.low = (uint8)count;
	ucast->count.high = (uint8)(count>>8);

	/* authenticated key management suite list */
	auth = (wpa_suite_auth_key_mgmt_t *)&ucast->list[count];
	count = 0;

	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_IE_SUITE_COUNT_LEN, buflen, orig_cp);

	WPA_len += WPA_IE_SUITE_COUNT_LEN;
	buflen -= WPA_IE_SUITE_COUNT_LEN;

	if (WPA_auth & WPA2_AUTH_UNSPECIFIED) {
#ifdef MFP
		if (!(bsscfg->wsec & MFP_REQUIRED)) {
#endif
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(WPA2_OUI, auth->list[count].oui, DOT11_OUI_LEN);
		auth->list[count++].type = RSN_AKM_UNSPECIFIED;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
#ifdef MFP
		}
		if (bsscfg->wsec & MFP_CAPABLE) {
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA2_OUI, auth->list[count].oui, DOT11_OUI_LEN);
			auth->list[count++].type = RSN_AKM_MFP_1X;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
		}
#endif /* MFP */
	}
	if (WPA_auth & WPA2_AUTH_PSK) {
#ifdef MFP
		if (!(bsscfg->wsec & MFP_REQUIRED)) {
#endif
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(WPA2_OUI, auth->list[count].oui, DOT11_OUI_LEN);
		auth->list[count++].type = RSN_AKM_PSK;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
#ifdef MFP
		}
		if (bsscfg->wsec & MFP_CAPABLE) {
			BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
			bcopy(WPA2_OUI, auth->list[count].oui, DOT11_OUI_LEN);
			auth->list[count++].type = RSN_AKM_MFP_PSK;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
		}
#endif /* MFP */
	}
#if defined(IBSS_PSK)
	if (WPA_auth & BRCM_AUTH_PSK) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(BRCM_OUI, auth->list[count].oui, DOT11_OUI_LEN);
		auth->list[count++].type = BRCM_AKM_PSK;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}
#endif /* IBSS_PSK */
	ASSERT(count);
	auth->count.low = (uint8)count;
	auth->count.high = (uint8)(count>>8);

	/* WPA capabilities */
	cap = (uint8 *)&auth->list[count];
	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_CAP_LEN, buflen, orig_cp);
	wlc_wpa_cap(wlc, bsscfg, cap, WPA_CAP_LEN);
	WPA_len += WPA_CAP_LEN;
	buflen -= WPA_CAP_LEN;

	/* update tag length */
	wpa2ie->len = (uint8)WPA_len;

	if (WPA_len)
	    cp += TLV_HDR_LEN + WPA_len;
	return (cp);
}

#ifdef BCMWAPI_WAI
static uint8 *
wlc_write_wapi_ie_safe(wlc_info_t *wlc, uint8 *cp, int buflen, uint16 WPA_auth,
	uint32 wsec, wlc_bsscfg_t *bsscfg)
{
	/* Infrastructure WAPI info element */
	uint WPA_len = 0;	/* tag length */
	bcm_tlv_t *wapiie = (bcm_tlv_t *)cp;
	wpa_suite_mcast_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *auth;
	uint16 count;
	uint8 *cap;
	uint8 *orig_cp = cp;

	WL_WSEC(("wl%d: adding RSN IE, wsec = 0x%x\n", wlc->pub->unit, wsec));

	/* perform length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN((&wapiie->data[WAPI_VERSION_LEN] - &wapiie->id), buflen, orig_cp);

	/* fixed portion */
	wapiie->id = DOT11_MNG_WAPI_ID;
	wapiie->data[0] = (uint8)WAPI_VERSION;
	wapiie->data[1] = (uint8)(WAPI_VERSION>>8);
	WPA_len = WAPI_VERSION_LEN;

	/* authenticated key management suite list */
	auth = (wpa_suite_auth_key_mgmt_t *)&wapiie->data[WAPI_VERSION_LEN];
	count = 0;

	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_IE_SUITE_COUNT_LEN, buflen, orig_cp);

	WPA_len += WPA_IE_SUITE_COUNT_LEN;
	buflen -= WPA_IE_SUITE_COUNT_LEN;

	if (WPA_auth & WAPI_AUTH_UNSPECIFIED) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(WAPI_OUI, auth->list[count].oui, DOT11_OUI_LEN);
		auth->list[count++].type = RSN_AKM_UNSPECIFIED;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}
	if (WPA_auth & WAPI_AUTH_PSK) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(WAPI_OUI, auth->list[count].oui, DOT11_OUI_LEN);
		auth->list[count++].type = RSN_AKM_PSK;
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}

	ASSERT(count);
	auth->count.low = (uint8)count;
	auth->count.high = (uint8)(count>>8);

	/* unicast suite list */
	ucast = (wpa_suite_ucast_t *)&auth->list[count];
	count = 0;

	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_IE_SUITE_COUNT_LEN, buflen, orig_cp);

	WPA_len += WPA_IE_SUITE_COUNT_LEN;
	buflen -= WPA_IE_SUITE_COUNT_LEN;

	if (WSEC_SMS4_ENABLED(wsec)) {
		/* length check */
		/* if buffer too small, return untouched buffer */
		BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
		bcopy(WAPI_OUI, ucast->list[count].oui, DOT11_OUI_LEN);
		ucast->list[count++].type = WAPI_CIPHER_2_CSE_WPI(WAPI_CIPHER_SMS4);
		WPA_len += WPA_SUITE_LEN;
		buflen -= WPA_SUITE_LEN;
	}
	ASSERT(count);
	ucast->count.low = (uint8)count;
	ucast->count.high = (uint8)(count>>8);

	/* multicast suite */
	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_SUITE_LEN, buflen, orig_cp);
	mcast = (wpa_suite_mcast_t *)&ucast->list[count];
	bcopy(WAPI_OUI, mcast->oui, DOT11_OUI_LEN);
	mcast->type = WAPI_CIPHER_2_CSE_WPI(wlc_wpa_mcast_cipher(wlc, bsscfg));
	WPA_len += WPA_SUITE_LEN;
	buflen -= WPA_SUITE_LEN;

	/* WAPI capabilities */
	/* length check */
	/* if buffer too small, return untouched buffer */
	BUFLEN_CHECK_AND_RETURN(WPA_CAP_LEN, buflen, orig_cp);

	cap = (uint8 *)&mcast[1];
	cap[0] = 0;
	cap[1] = 0;
	if (BSSCFG_AP(bsscfg) && (bsscfg->WPA_auth & WAPI_AUTH_UNSPECIFIED) &&
	    (bsscfg->wai_preauth == TRUE))
	    cap[0] = WAPI_CAP_PREAUTH;
	WPA_len += WPA_CAP_LEN;
	buflen -= WPA_CAP_LEN;

	/* update tag length */
	wapiie->len = (uint8)WPA_len;

	if (WPA_len)
	    cp += TLV_HDR_LEN + WPA_len;

	return (cp);
}
#endif /* BCMWAPI_WAI */

uint8 *
wlc_write_info_elt(uint8 *cp, int id, int len, const void* data)
{
	ASSERT(len < 256);
	ASSERT(len >= 0);

	cp[0] = (uint8)id;
	cp[1] = (uint8)len;
	if (len > 0)
		bcopy(data, (char*)cp+2, len);

	return (cp + 2 + len);
}

uint8 *
wlc_copy_info_elt(uint8 *cp, const void* data)
{
	uint totlen = 2 + ((const uint8*)data)[1];

	bcopy(data, (char*)cp, totlen);

	return (cp + totlen);
}

uint8 *
wlc_write_info_elt_safe(uint8 *buf, int buflen, int id, int len, const void* data)
{
	ASSERT(len < 256);
	ASSERT(len >= 0);

	/* if len + ie hdr len is more than buflen, don't do anything */
	/* just return the buffer untouched */
	BUFLEN_CHECK_AND_RETURN((len+2), buflen, buf);

	buf[0] = (uint8)id;
	buf[1] = (uint8)len;
	if (len > 0)
		bcopy(data, (char*)buf+2, len);

	return (buf + 2 + len);
}

uint8 *
wlc_copy_info_elt_safe(uint8 *buf, int buflen, const void* data)
{
	uint totlen = 2 + ((const uint8*)data)[1];

	/* if totlen is more than buflen, don't do anything */
	/* just return the buffer untouched */
	BUFLEN_CHECK_AND_RETURN(totlen, buflen, buf);

	bcopy(data, (char*)buf, totlen);

	return (buf + totlen);
}

/* Beacon and Probe Response frame body
 *  max sz  order
 *  8       1 Timestamp
 *  2       2 Beacon interval
 *  2       3 Capability information
 *  34      4 SSID
 *  10      5 Supported rates
 *  (0)     6 FH Params             (not supported)
 *  3       7 DS Parameter Set
 *  (0)     8 CF Params             (not supported)
 *  4       9 IBSS Parameter Set    (IBSS only)
 *  6(256)  10 TIM                  (BSS-Beacon only)
 *  8(113)  11 Country Information  (11d)
 *  3       15 Channel Switch Announcement (11h)
 *  6       16 Quiet period	    (11h)
 *  3       19 ERP Information      (11g)
 *  10(257) 20 Ext. Sup. Rates      (11g)
 *  7          BRCM proprietary
 *  27         WME params
 *
 *  The TIM can be 256 bytes long in general. For a beacon template,
 *  a NULL TIM is used, which is 6 bytes long.
 *
 *  Country element is minimum of 8 which includes a base of 5 plus
 *  possibly 3 bytes per supported channel (less if the channel numbers
 *  are monotonic and can be compressed.
 *
 *  Max template beacon frame body length is 112 bytes. (items 1-7 and 10, 19, 20, 221)
 *  Max template probe response frame body length is 110 bytes. (items 1-7 and 9, 19, 20, 221)
 */

void
wlc_bcn_prb_body(wlc_info_t *wlc, uint type, wlc_bsscfg_t *bsscfg, uint8 *bcn, int *len,
	bool legacy_tpl)
{
	struct dot11_bcn_prb *fixed;
	wlc_rateset_t sup_rates, ext_rates;
	uint8 *cp;
	int bcn_len;
	uint32 wsec;
	int16 WPA_auth;
	bool add_csa_ie = FALSE;
	wlc_bss_info_t *current_bss;
	uint8 *bufend;
	wlc_csa_t *csa;
	uint8 ext_cap[DOT11_EXTCAP_LEN_MAX];
	uint8 ext_cap_len = 0;

	ASSERT(bsscfg != NULL);
	ASSERT(len != NULL);

	bzero(ext_cap, sizeof(ext_cap));
	current_bss = bsscfg->current_bss;
	csa = bsscfg->csa;

	wsec = bsscfg->wsec;
	WPA_auth = bsscfg->WPA_auth;

	ASSERT(*len >= 112);
	ASSERT(ISALIGNED((uintptr)bcn, sizeof(uint16)));
	ASSERT(type == FC_BEACON || type == FC_PROBE_RESP);

	bzero(&sup_rates, sizeof(wlc_rateset_t));
	bzero(&ext_rates, sizeof(wlc_rateset_t));

	/* save the end of buffer, used for buffer length checks */
	bufend = bcn + *len;

#if defined(MBSS) && defined(WLLPRS)
	/* reset the probe ie info structure */
	if (type == FC_PROBE_RESP)
		bzero(&bsscfg->prb_ieinfo, sizeof(prb_ie_info_t));
#endif /* MBSS && WLLPRS */

	/* check for a supported rates override, add back iBSS Gmode setting */
	if (wlc->sup_rates_override.count > 0)
		wlc_rateset_copy(&wlc->sup_rates_override, &sup_rates);
	else if ((!AP_ENAB(wlc->pub)) && (wlc->band->gmode == GMODE_LRS))
		wlc_rateset_copy(&cck_rates, &sup_rates);
	else if ((!AP_ENAB(wlc->pub)) && (wlc->band->gmode == GMODE_PERFORMANCE))
		wlc_default_rateset(wlc, &sup_rates);

	wlc_rateset_elts(wlc, bsscfg, &current_bss->rateset, &sup_rates, &ext_rates);

	fixed = (struct dot11_bcn_prb *)bcn;

	/* fill in fixed info, Timestamp, Beacon interval, and Capability */
	bzero((char*)fixed, sizeof(*fixed));
	/* Timestamp is zero in bcn template, filled in by MAC */
	/* [N.B.: fixed->timestamp is misaligned but unreferenced, so "safe".] */

	fixed->beacon_interval = htol16((uint16)current_bss->beacon_period);
	if (current_bss->infra)
		fixed->capability = DOT11_CAP_ESS;
#ifdef WLP2P
	else if (BSS_P2P_DISC_ENAB(wlc, bsscfg))
		fixed->capability = 0;
#endif
	else
		fixed->capability = DOT11_CAP_IBSS;
	if (WSEC_ENABLED(bsscfg->wsec) &&
	    (bsscfg->wsec_restrict || (WIN7_OS(wlc->pub) && BSSCFG_AP(bsscfg))))
		fixed->capability |= DOT11_CAP_PRIVACY;
	/* Advertise short preamble capability if we have not been forced long AND we
	 * are not an APSTA
	 */
	if (!APSTA_ENAB(wlc->pub) && BAND_2G(wlc->band->bandtype) &&
	    (current_bss->capability & DOT11_CAP_SHORT))
		fixed->capability |= DOT11_CAP_SHORT;
	if (wlc->band->gmode && wlc->shortslot)
		fixed->capability |= DOT11_CAP_SHORTSLOT;
	if (BSS_WL11H_ENAB(wlc, bsscfg) && current_bss->infra)
		fixed->capability |= DOT11_CAP_SPECTRUM;

	fixed->capability = htol16(fixed->capability);

	/* fill in Info elts, SSID, Sup Rates, DS params, and IBSS params */
	cp = (uint8 *)&fixed[1];

	/* SSID */
	if ((type == FC_BEACON) && bsscfg->closednet_nobcnssid) {
		/* in the closed net case the ssid is faked to be all zero */
		uint8 closed_ssid[DOT11_MAX_SSID_LEN];
		bzero(closed_ssid, bsscfg->SSID_len);

		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_SSID_ID,
			bsscfg->SSID_len, closed_ssid);
	} else {
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_SSID_ID,
			bsscfg->SSID_len, bsscfg->SSID);
	}

	/* Supported Rates */
	cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_RATES_ID,
		sup_rates.count, sup_rates.rates);

	/* The *other* 11a products do not send channel info elements */
	if (CHSPEC_IS2G(current_bss->chanspec)) {
		/* DS Parameters */
		uint8 data = wf_chspec_ctlchan(current_bss->chanspec);

		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_DS_PARMS_ID, 1,
			&data);
	}

	/* TIM */
	if (current_bss->infra && (type == FC_BEACON)) {
		int tim_len = wlc_create_tim(wlc, &cp[0], BUFLEN(cp, bufend),
			WLC_BSSCFG_IDX(bsscfg));
		/* store TIM pointer and TIM count */
#if defined(MBSS)
		bsscfg->bcn_template->tim_ie = &cp[0];
#endif /* MBSS */
		cp += tim_len;
	}

	/* IBSS Params */
	if (!current_bss->infra &&
#ifdef WLP2P
	    !BSS_P2P_DISC_ENAB(wlc, bsscfg) &&
#endif
	    TRUE) {
		uint8 ibssBuf[2];

		ibssBuf[0] = (uint8)(current_bss->atim_window & 0xff);
		ibssBuf[1] = (uint8)((current_bss->atim_window >> 8) & 0xff);
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_IBSS_PARMS_ID, 2,
			ibssBuf);
	}

	/* 802.11d, 802.11h Country Element */
	if ((BSS_WL11H_ENAB(wlc, bsscfg) || WL11D_ENAB(wlc)) && current_bss->infra) {
#ifdef BCMDBG
		if (wlc->country_ie_override)
			cp = wlc_copy_info_elt_safe(cp, BUFLEN(cp, bufend),
				wlc->country_ie_override);
		else
			cp = wlc_write_country_ie(wlc, cp, BUFLEN(cp, bufend));
#else

		if (!WLC_AUTOCOUNTRY_ENAB(wlc) ||
			(WLC_AUTOCOUNTRY_ENAB(wlc) && wlc->autocountry_adopted_from_ap)) {

			cp = wlc_write_country_ie(wlc, cp, BUFLEN(cp, bufend));
		}
#endif
	}

#ifdef WLBTAMP
	/* 802.11e EDCA Parameter Set Element */
	if (BSS_BTA_ENAB(wlc, bsscfg) && wlc_bta_qos(wlc->bta)) {

		WL_BTA(("wl%d: wlc_bcn_prb_body: adding EDCA Parameter Set IE\n", wlc->pub->unit));

		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_EDCA_PARAM_ID, sizeof(edca_param_ie_t),
			(char *)((uintptr)&wlc->wme_param_ie + OFFSETOF(wme_param_ie_t, qosinfo)));

	}
#endif /* WLBTAMP */

	/* 802.11h Power Constraint, Channel Switch Announcement */
	if (BSS_WL11H_ENAB(wlc, bsscfg) && current_bss->infra) {
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_PWR_CONSTRAINT_ID, 1, &wlc->pwr_constraint);
	}
	if (csa->csa.count && current_bss->infra) {
		cp = wlc_write_csa_ie(&csa->csa, cp, BUFLEN(cp, bufend));
		add_csa_ie = TRUE;
	}

	/* 802.11h Quiet */
#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg) &&
	    wlc_p2p_write_ie_quiet_len(wlc->p2p, bsscfg, type) <= BUFLEN(cp, bufend))
		cp += wlc_p2p_write_ie_quiet(wlc->p2p, bsscfg, type, cp);
	else
#endif
	if (BSS_WL11H_ENAB(wlc, bsscfg) && current_bss->infra) {
		/* faster to do it this way instead of calling wlc_write_info_elt_safe() */
		if (csa->quiet_cmd.count && (BUFLEN(cp, bufend) >= (int)sizeof(dot11_quiet_t))) {
			dot11_quiet_t *quiet = (dot11_quiet_t *)cp;
			quiet->id = DOT11_MNG_QUIET_ID;
			quiet->len = 6;
			quiet->count = csa->quiet_cmd.count--;
			quiet->period = csa->quiet_cmd.period;
			quiet->duration = htol16(csa->quiet_cmd.duration);
			quiet->offset = htol16(csa->quiet_cmd.offset);
			cp += sizeof(dot11_quiet_t);
		} else if (csa->quiet_cmd.count) {
			WL_ERROR(("%s, line %d, quiet ie dropped, buffer too short\n",
			  __FUNCTION__, __LINE__));
		}
	}

	/* 802.11h TPC report */
	if (BSS_WL11H_ENAB(wlc, bsscfg) && current_bss->infra) {
		int8 tpc_report[DOT11_MNG_IE_TPC_REPORT_LEN];

		/* 802.11H Sec 7.3.2.18 */
		/* Current target + ant_gain converted to dbm */
		tpc_report[0] = (wlc_phy_txpower_get_target_max((wlc_phy_t *)wlc->band->pi) +
			wlc->band->antgain) / WLC_TXPWR_DB_FACTOR;
		tpc_report[1] = 0;  /* Link Margin set to 0 */
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_TPC_REPORT_ID, DOT11_MNG_IE_TPC_REPORT_LEN, tpc_report);
	}

	/* ERP IE */
	if (wlc->band->gmode) {
		uint8 erp_flags[DOT11_MNG_ERP_LEN] = { 0 };
		wlc_prot_cfg_t *prot = bsscfg->prot_cfg;

		if (prot->erp_ie_nonerp)
			erp_flags[0] |= DOT11_MNG_NONERP_PRESENT;
		if (prot->erp_ie_use_protection)
			erp_flags[0] |= DOT11_MNG_USE_PROTECTION;
		if (prot->barker_preamble)
			erp_flags[0] |= DOT11_MNG_BARKER_PREAMBLE;

		/* ERP Information Element */
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_ERP_ID, DOT11_MNG_ERP_LEN, erp_flags);

		/* Legacy NonERP Information Element if required */
		if (prot->include_legacy_erp) {
			cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
				DOT11_MNG_NONERP_ID, 1, erp_flags);
		}
	}

	/* RSN IE  if appropriate */
	cp = wlc_write_rsn_ie_safe(wlc, cp, BUFLEN(cp, bufend), WPA_auth, wsec, bsscfg);

#ifdef BCMWAPI_WAI
	/* WAPI IE */
	if (INCLUDES_WAPI_AUTH(WPA_auth) && WSEC_ENABLED(wsec)) {
		cp = wlc_write_wapi_ie_safe(wlc, cp, BUFLEN(cp, bufend), WPA_auth, wsec, bsscfg);
	}
#endif /* BCMWAPI_WAI */

	if (wlc->band->gmode || wlc->htphy_membership) {
		/* Extended Supported Rates Information Element if any */
		if (ext_rates.count > 0) {
			cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
				DOT11_MNG_EXT_RATES_ID, ext_rates.count, ext_rates.rates);
		}
	}

#ifdef WL11U
	if (bsscfg->iw_ie) {
		setbit(ext_cap, DOT11_EXT_CAP_IW);
		if (ext_cap_len < DOT11_EXTCAP_LEN_IW)
			ext_cap_len = DOT11_EXTCAP_LEN_IW;
	}
#endif /* WL11U */

	/* add ANA HT Information Elements */
	if (BSS_N_ENAB(wlc, bsscfg) && !legacy_tpl) {
		ht_cap_ie_t cap_ie;
		ht_add_ie_t add_ie;
		uint8 *mcs;
#if defined(MBSS) && defined(WLLPRS)
		uint8 *ie_cp = cp;
		uint8 ie_offset = (uint8) (cp - bcn);
		uint8 ie_length = 0;
#endif /* MBSS && WLLPRS */

		mcs = &current_bss->rateset.mcs[0];
		wlc_write_ht_cap_ie(bsscfg, &cap_ie, mcs, BAND_2G(wlc->band->bandtype));
		wlc_write_ht_add_ie(bsscfg, &add_ie);
		if (add_csa_ie)
			cp = wlc_write_ext_csa_ie(&csa->csa, cp);
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_HT_CAP, HT_CAP_IE_LEN, &cap_ie);
		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
			DOT11_MNG_HT_ADD, HT_ADD_IE_LEN, &add_ie);

		if (COEX_ACTIVE(wlc)) {
			/* need to convert to 802.11 little-endian format */
			obss_params_t params;
			bcopy((uint8 *)&wlc->obss->ap_params, (uint8 *)&params,
			      WL_OBSS_SCAN_PARAM_LEN);
			/* convert params to 802.11 network order */
			wlc_ht_obss_scanparams_hostorder(wlc, &params, FALSE);
			cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend),
				DOT11_MNG_HT_OBSS_ID, DOT11_OBSS_SCAN_IE_LEN, &params);
			/* Support for HT Information 20/40MHz Exchange */
			setbit(ext_cap, DOT11_EXT_CAP_OBSS_COEX_MGMT);
			if (ext_cap_len < DOT11_EXTCAP_LEN_COEX)
				ext_cap_len = DOT11_EXTCAP_LEN_COEX;
		}

		if (ext_cap_len) {
			/* extended capabilities */
			cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_EXT_CAP_ID,
				ext_cap_len, ext_cap);
		}
		/* include ANA Extension Channel IE if bw is 40MHz */
		if (current_bss->infra && csa->csa.count && CHSPEC_IS40(current_bss->chanspec))
			cp = wlc_write_extch_ie(csa->csa.chspec, cp, BUFLEN(cp, bufend));

#if defined(MBSS) && defined(WLLPRS)
		ie_length = (uint8) (cp - ie_cp);
		if (ie_length && (type == FC_PROBE_RESP)) {
			PRB_HTIE(bsscfg).present = TRUE;
			PRB_HTIE(bsscfg).offset = ie_offset;
			PRB_HTIE(bsscfg).length = ie_length;
		}
#endif /* MBSS && WLLPRS */
	} else {
		if (ext_cap_len) {
			/* extended capabilities */
			cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_EXT_CAP_ID,
				ext_cap_len, ext_cap);
		}
	}

#ifdef WL11U

	if (bsscfg->iw_ie) {
#ifdef AP
		uint8 *iwap_ie = wlc_vndr_ie_find_by_type(bsscfg,
			DOT11_MNG_ADVERTISEMENT_ID);
		uint8 *iwrc_ie = wlc_vndr_ie_find_by_type(bsscfg,
			DOT11_MNG_ROAM_CONSORT_ID);
#endif /* AP */
		/* 11u interworking */
		cp = wlc_copy_info_elt_safe(cp, BUFLEN(cp, bufend), bsscfg->iw_ie);

#ifdef AP
		/* 11u advertisement protocol */
		if (iwap_ie != NULL) {
			if (iwap_ie[TLV_BODY_OFF+1] != DOT11_MNG_PROPR_ID) {
				cp = wlc_copy_info_elt_safe(cp, BUFLEN(cp, bufend), iwap_ie);
			} else {
				uint8 *iwap_ie_dst = cp;
				cp[TLV_TAG_OFF] = DOT11_MNG_ADVERTISEMENT_ID;
				cp[TLV_BODY_OFF] = iwap_ie[TLV_BODY_OFF];
				cp += (TLV_BODY_OFF+1);
				cp = wlc_vndr_ie_write(bsscfg, cp, BUFLEN(cp, bufend),
					VNDR_IE_IWAPID_FLAG);
				iwap_ie_dst[TLV_LEN_OFF] = cp - iwap_ie_dst - TLV_HDR_LEN;
				if (iwap_ie_dst[TLV_LEN_OFF] == 1) {
					/* if no matched vendor IE,
					 * discard this advertisement protocol IE
					 */
					cp = iwap_ie_dst;
					WL_ERROR(("%s, line %d, discard IW AP IE\n",
						__FUNCTION__, __LINE__));
				}
			}
		}
		/* 11u IW roaming consortium IE */
		if (iwrc_ie != NULL) {
			cp = wlc_copy_info_elt_safe(cp, BUFLEN(cp, bufend), iwrc_ie);
		}
#endif /* AP */
	}
#endif /* WL11U */

	/* Write the Vendor IEs */
#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg))
		;
	else
#endif
	cp = wlc_vndr_ie_write(bsscfg, cp, BUFLEN(cp, bufend),
		(type == FC_BEACON)? VNDR_IE_BEACON_FLAG : VNDR_IE_PRBRSP_FLAG);

	/* BRCM proprietary Information Element */
	if (bsscfg->brcm_ie[TLV_LEN_OFF] > 0)
		cp = wlc_copy_info_elt_safe(cp, BUFLEN(cp, bufend), bsscfg->brcm_ie);

	/* WPA Information Element if appropriate */
	cp = wlc_write_wpa_ie_safe(wlc, cp, BUFLEN(cp, bufend),
	                           WPA_auth, wsec, bsscfg, current_bss);

	/* WME parameter info element in infrastructure beacons responses only */
	if (BSSCFG_AP(bsscfg) && BSS_WME_ENAB(wlc, bsscfg)) {
		uint8 i = 0;
		wlc_ap_info_t *ap = wlc->ap;
		edcf_acparam_t *acp_ie = &ap->wme_param_ie_ap.acparam[0];

		if (wlc->wme_apsd)
			wlc->wme_param_ie.qosinfo |= WME_QI_AP_APSD_MASK;
		else
			wlc->wme_param_ie.qosinfo &= ~WME_QI_AP_APSD_MASK;

		/* update the ACM value in WME IE */
		for (i = 0; i < AC_COUNT; i++, acp_ie++) {
			if (acp_ie->ACI & EDCF_ACM_MASK)
				wlc->wme_param_ie.acparam[i].ACI |= EDCF_ACM_MASK;
			else
				wlc->wme_param_ie.acparam[i].ACI &= ~EDCF_ACM_MASK;
		}

		cp = wlc_write_info_elt_safe(cp, BUFLEN(cp, bufend), DOT11_MNG_PROPR_ID,
		                sizeof(wlc->wme_param_ie), (char *)&wlc->wme_param_ie);
	}



#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg)) {
		cp = wlc_p2p_vndr_ie_write(bsscfg, type, cp, BUFLEN(cp, bufend),
			(type == FC_BEACON)? VNDR_IE_BEACON_FLAG : VNDR_IE_PRBRSP_FLAG);
		if (wlc_p2p_write_ie_len(wlc->p2p, bsscfg, type) <= BUFLEN(cp, bufend)) {
			cp += wlc_p2p_write_ie(wlc->p2p, bsscfg, type, cp);
		}
		else {
			WL_ERROR(("%s, line %d, p2p IE dropped: buf too short\n",
			  __FUNCTION__, __LINE__));
		}
		if (wlc_p2p_write_ie_extra_len(wlc->p2p, bsscfg, type) <= BUFLEN(cp, bufend)) {
			cp += wlc_p2p_write_ie_extra(wlc->p2p, bsscfg, type, cp);
		}
		else {
			WL_ERROR(("%s, line %d, p2p IE extra dropped: buf too short\n",
			  __FUNCTION__, __LINE__));
		}
	}
#endif /* WLP2P */

	bcn_len = (int)(cp - bcn);
	ASSERT(bcn_len <= *len);
	*len = bcn_len;

	return;
}

static uint8*
wlc_write_country_ie(wlc_info_t *wlc, uint8 *cp, int buflen)
{
	uint bandunit;
	uint8 cur_chan, first_chan, group_pwr, chan_pwr;
	int valid_channel;
	char seen_valid;
	const char *country_str;
	bcm_tlv_t *country_ie = (bcm_tlv_t*)cp;
	uint8 *orig_cp = cp;

	/* What bandunit is the current BSS?  We want to only process a single band. */
	bandunit = CHSPEC_WLCBANDUNIT(wlc->home_chanspec);

	/* make sure we have enough for fixed fields of counrty ie */
	/* if not, return original buffer pointer */
	BUFLEN_CHECK_AND_RETURN(5, buflen, orig_cp);

	country_ie->id = DOT11_MNG_COUNTRY_ID;

	/* Country name */
	country_str = wlc_channel_country_abbrev(wlc->cmi);
	country_ie->data[0] = country_str[0];
	country_ie->data[1] = country_str[1];
	country_ie->data[2] = ' '; /* handling both indoor and outdoor */

	cp += 5;
	/* update buflen */
	buflen -= 5;

	/* Fill in channels & txpwr */
	seen_valid = 0;
	group_pwr = 0;
	for (first_chan = cur_chan = 0; cur_chan <= MAXCHANNEL; cur_chan++) {
		valid_channel = (cur_chan < MAXCHANNEL) &&
			VALID_CHANNEL20_IN_BAND(wlc, bandunit, cur_chan);
		if (valid_channel)
			chan_pwr = wlc_get_reg_max_power_for_channel(wlc->cmi, cur_chan, TRUE);
		else
			chan_pwr = 0;

		if (!valid_channel || chan_pwr != group_pwr) {
			if (seen_valid) {
				/* make sure buffer big enough for 3 byte data */
				/* if not, return original buffer pointer */
				BUFLEN_CHECK_AND_RETURN(3, buflen, orig_cp);
				*cp++ = first_chan;
				*cp++ = cur_chan - first_chan;
				*cp++ = group_pwr;
				/* update buflen */
				buflen -= 3;
				seen_valid = 0;
			}
		}

		if (valid_channel) {
			if (!seen_valid) {
				group_pwr = chan_pwr;
				first_chan = cur_chan;
				seen_valid = 1;
			}
		}
	}

	/* Pad if odd length.  Len excludes ID and len itself. */
	country_ie->len = (uint8)(cp - country_ie->data);
	if (country_ie->len & 1) {
		/* make sure buffer big enough for 1 byte pad */
		/* if not, return original buffer pointer */
		BUFLEN_CHECK_AND_RETURN(1, buflen, orig_cp);
		country_ie->len++;
		*cp++ = 0;
		buflen--;
	}

	return cp;
}

uchar
wlc_assocscb_getcnt(wlc_info_t *wlc)
{
	struct scb *scb;
	uchar assoc = 0;
	struct scb_iter scbiter;
	ASSERT(wlc->pub->tunables->maxscb <= 255);

	FOREACHSCB(wlc->scbstate, &scbiter, scb) {
		if (SCB_ASSOCIATED(scb))
			assoc++;
	}
	return assoc;
}

static uint8
wlc_bss_scb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg, bool (*scb_test_cb)(struct scb *scb))
{
	struct scb *scb;
	uint8 assoc = 0;
	struct scb_iter scbiter;
	ASSERT(wlc->pub->tunables->maxscb <= 255);

	FOREACHSCB(wlc->scbstate, &scbiter, scb) {
		if (scb->bsscfg == cfg && scb_test_cb(scb))
			assoc++;
	}
	return assoc;
}

static bool
wlc_scb_associated_cb(struct scb *scb)
{
	return SCB_ASSOCIATED(scb);
}

uint8
wlc_bss_assocscb_getcnt(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	return wlc_bss_scb_getcnt(wlc, cfg, wlc_scb_associated_cb);
}

/* return TRUE if cfg->brcm_ie[] changed, FALSE if not */
bool
wlc_update_brcm_ie(wlc_info_t *wlc)
{
	int idx;
	wlc_bsscfg_t *cfg;
	bool update = FALSE;

	FOREACH_BSS(wlc, idx, cfg) {
		update |= wlc_bss_update_brcm_ie(wlc, cfg);
	}

	return update;
}

bool
wlc_bss_update_brcm_ie(wlc_info_t *wlc, wlc_bsscfg_t *cfg)
{
	uint8 assoc;
	brcm_ie_t *brcm_ie;
	volatile uint8 flags = 0, flags1 = 0;


	brcm_ie = (brcm_ie_t *)&cfg->brcm_ie[0];

	flags = 0;

#ifdef WLAFTERBURNER
	flags = (wlc->ab_wds_timeout << BRF_ABCOUNTER_SHIFT);
	flags |= ((wlc->afterburner_override != OFF) ? BRF_ABCAP : 0);
	flags |= (wlc->afterburner ? BRF_ABRQRD : 0);
#endif /* WLAFTERBURNER */

#ifdef AP
	if (BSSCFG_AP(cfg)) {
		if (wlc->ap->lazywds && cfg == wlc->cfg)
			flags |= BRF_LZWDS;
#ifdef BCM_DCS
		/* enable BCM_DCS for BCM AP */
		if (wlc->ap->dcs_enabled)
			flags1 |= BRF1_RFAWARE_DCS;
#endif
		/* As long as WME is enabled, AP does the right thing
		 * when a WME STA goes to PS mode as opposed to some versions of BRCM AP
		 * that would not buffer traffic going to a WME STA in PS mode
		 */
		if (WME_ENAB(wlc->pub))
			flags1 |= BRF1_WMEPS;
#ifdef SOFTAP
		flags1 |= BRF1_SOFTAP;
#endif
		flags1 |= BRF1_PSOFIX;
	}
#endif /* AP */

	/* enable capability of receiving large aggregate if STA is
	 * HTPHY and AMPDU_ENAB
	 */
	if (WLCISHTPHY(wlc->band) && AMPDU_ENAB(wlc->pub))
		flags1 |= BRF1_RX_LARGE_AGG;

#ifdef BCM_DCS
	/* enable BCM_DCS for BCM AP */
	if (AP_ENAB(wlc->pub))
		flags1 |= BRF1_RFAWARE_DCS;
#endif /* BCM_DCS */


	/* count the total number of associated stas */
	assoc = wlc_bss_assocscb_getcnt(wlc, cfg);

	/* no change? */
	if ((brcm_ie->assoc == assoc) && (brcm_ie->flags == flags) && (brcm_ie->flags1 == flags1))
		return (FALSE);

	brcm_ie->assoc = assoc;
	brcm_ie->flags = flags;
	brcm_ie->flags1 = flags1;

	ASSERT((cfg->brcm_ie[TLV_LEN_OFF]+TLV_HDR_LEN) < WLC_MAX_BRCM_ELT);

	return (TRUE);
}

/* process received BRCM info element */
void
wlc_process_brcm_ie(wlc_info_t *wlc, struct scb *scb, brcm_ie_t *brcm_ie)
{
#ifdef WLAFTERBURNER
	bool abrqrd;
#endif /* WLAFTERBURNER */


	if (!brcm_ie || brcm_ie->len < 4) {
#ifdef BRCMAPIVTW
		wlc->brcm_ap_iv_tw = FALSE;
#endif
		return;
	}

	ASSERT(scb != NULL);

	/* remote station is BRCM AP/STA */
	scb->flags |= SCB_BRCM;

	/* legacy AES implementations */
	if (brcm_ie->ver <= BRCM_IE_LEGACY_AES_VER)
		scb->flags |= SCB_LEGACY_AES;
	else
		scb->flags &= ~SCB_LEGACY_AES;

	/* early brcm_ie is only 7 bytes in length */
	if (brcm_ie->len <= (OFFSETOF(brcm_ie_t, flags) - TLV_HDR_LEN)) {
#ifdef WLAFTERBURNER
		/* legacy beacon frame means no afterburner support */
		if (SCB_WDS(scb))
			wlc->ab_wds_timeout = AB_WDS_TIMEOUT_MAX - 1;
#endif /* WLAFTERBURNER */
		return;
	}

#ifdef WLAFTERBURNER
	/* remote station is afterburner capable? */
	if (brcm_ie->flags & BRF_ABCAP) {
		scb->flags |= SCB_ABCAP;
		/* CRAM transmit can be present in AP only */
		if (AP_ONLY(wlc->pub))
			wlc_txmod_config(wlc, scb, TXMOD_CRAM);
	} else {
		scb->flags &= ~SCB_ABCAP;
		/* CRAM transmit can be present in AP only */
		if (AP_ONLY(wlc->pub))
			wlc_txmod_unconfig(wlc, scb, TXMOD_CRAM);
	}

	/* for AP only */
	if (SCB_WDS(scb)) {
		uint32 recvCount;

		recvCount = (brcm_ie->flags >> BRF_ABCOUNTER_SHIFT);

		/* Should never happen but ... */
		if (recvCount > AB_WDS_TIMEOUT_MAX) {
			WL_ERROR(("wl%d: wlc_process_brcm_ie: spurious recvd ab count 0x%x\n",
			wlc->pub->unit, recvCount));
			return;
		}

		/* recvCount of zero means downrev AP, not ab capable */
		if (recvCount > wlc->ab_wds_timeout) {
			wlc->ab_wds_timeout = recvCount - 1;
		} else if (recvCount == 0) {
			wlc->ab_wds_timeout = AB_WDS_TIMEOUT_MAX - 1;
		}

	}

	abrqrd = (brcm_ie->flags & BRF_ABRQRD)? TRUE : FALSE;
#endif /* WLAFTERBURNER */

#ifdef STA

#ifdef WLAFTERBURNER
	/* AP tells STA to change our afterburner mode */
	if ((wlc->afterburner_override == AUTO) && (wlc->afterburner != abrqrd) &&
	    !AP_ACTIVE(wlc) && SCB_ASSOCIATED(scb) && (scb->flags & SCB_MYAP) &&
	    !SCB_AMPDU(scb))
		wlc_afterburner(wlc, abrqrd);
#endif /* WLAFTERBURNER */

	if (brcm_ie->len <= (OFFSETOF(brcm_ie_t, flags1) - TLV_HDR_LEN))
		return;

	if (brcm_ie->flags1 & BRF1_WMEPS)
		scb->flags |= SCB_WMEPS;
	else
		scb->flags &= ~SCB_WMEPS;

#ifdef BCM_DCS
	if (brcm_ie->flags1 & BRF1_RFAWARE_DCS)
		scb->flags2 |= SCB2_BCMDCS;
	else
		scb->flags2 &= ~SCB2_BCMDCS;

#endif /* BCM_DCS */

#endif /* STA */

	scb->flags2 &= ~SCB2_RX_LARGE_AGG;
	if (brcm_ie->flags1 & BRF1_RX_LARGE_AGG)
		scb->flags2 |= SCB2_RX_LARGE_AGG;

#ifdef BRCMAPIVTW
	wlc->brcm_ap_iv_tw = (brcm_ie->flags1 & BRF1_PSOFIX) ? FALSE : TRUE;
#endif
}

/* Fill in the TIM element */
static uint16
wlc_create_tim(wlc_info_t *wlc, uchar *tim, int timlen, uint bss_idx)
{
	/* make sure tim buffer is big enough to hold fixed fields */
	/* if not, return 0 */
	BUFLEN_CHECK_AND_RETURN(6, timlen, 0);

	tim[0] = DOT11_MNG_TIM_ID;
	tim[1] = DOT11_MNG_TIM_FIXED_LEN + 1;
	tim[2] = (uint8)((wlc->default_bss->dtim_period-1) & 0xff);
	tim[3] = (uint8)(wlc->default_bss->dtim_period & 0xff);
	tim[4] = 0;
	tim[5] = 0;

	if (AP_ENAB(wlc->pub)) {
		wlc_apps_tim_create(wlc, tim, timlen, bss_idx);
	}

	/* return the length including the element id and len field */
	return (tim[1] + 2);
}

/* recover 32bit TSF value from the 16bit TSF value */
/* assumption is passed in rxh is with in 65ms of the current tsf */
uint32
wlc_recover_tsf32(wlc_info_t *wlc, wlc_d11rxhdr_t *rxhdr)
{
	uint16 	rxh_tsf;
	uint32	tsf_l;
	uint32	rx_tsf_l;

	rxh_tsf = rxhdr->rxhdr.RxTSFTime;
	tsf_l = rxhdr->tsf_l;

	rx_tsf_l = (tsf_l & 0xFFFF0000) | rxh_tsf;
	/* a greater tsf time indicates the low 16 bits of
	 * tsf_l wrapped, so decrement the high 16 bits.
	 */
	if (rxh_tsf > (tsf_l & 0xffff))
		rx_tsf_l -= 0x10000;
	return rx_tsf_l;
}

/* recover 64bit TSF value from the 16bit TSF value */
/* assumption is passed in rxh is with in 65ms of the current tsf */
void
wlc_recover_tsf64(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, uint32 *tsf_h, uint32 *tsf_l)
{
	uint16 rxh_tsf_0_15;
	uint16 rx_tsf_16_31;

	*tsf_h = R_REG(wlc->osh, &wlc->regs->tsf_timerhigh);
	*tsf_l = wrxh->tsf_l;

	rx_tsf_16_31 = (uint16)(*tsf_l >> 16);

	rxh_tsf_0_15 = wrxh->rxhdr.RxTSFTime;

	/* a greater tsf time indicates the low 16 bits of
	 * tsf_l wrapped, so decrement the high 16 bits.
	 */
	if ((uint16)*tsf_l < rxh_tsf_0_15) {
		rx_tsf_16_31 -= 1;
		if (rx_tsf_16_31 == 0xffff)
			*tsf_h -= 1;
	}

	*tsf_l = ((uint32)rx_tsf_16_31 << 16) + rxh_tsf_0_15;
}


#ifdef STA
static void *
wlc_frame_get_ps_ctl(wlc_info_t *wlc, const struct ether_addr *bssid,
	const struct ether_addr *sa)
{
	void *p;
	struct dot11_ps_poll_frame *hdr;

	if ((p = wlc_frame_get_ctl(wlc, DOT11_PS_POLL_LEN)) == NULL) {
		return (NULL);
	}

	/* construct a PS-Poll frame */
	hdr = (struct dot11_ps_poll_frame *)PKTDATA(wlc->osh, p);
	hdr->fc = htol16(FC_PS_POLL);
	hdr->durid = htol16(wlc->AID);
	bcopy((const char*)bssid, (char*)&hdr->bssid, ETHER_ADDR_LEN);
	bcopy((const char*)sa, (char*)&hdr->ta, ETHER_ADDR_LEN);

	return (p);
}
#endif /* STA */

void*
wlc_frame_get_ctl(wlc_info_t *wlc, uint len)
{
	void *p;
	osl_t *osh;

	ASSERT(len != 0);

	osh = wlc->osh;
	if ((p = PKTGET(osh, (TXOFF + len), TRUE)) == NULL) {
		WL_ERROR(("wl%d: wlc_frame_get_ctl: pktget error for len %d\n",
			wlc->pub->unit, (TXOFF + len)));
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		return (NULL);
	}
	ASSERT(ISALIGNED((uintptr)PKTDATA(osh, p), sizeof(uint32)));

	/* reserve TXOFF bytes of headroom */
	PKTPULL(osh, p, TXOFF);
	PKTSETLEN(osh, p, len);

	PKTSETPRIO(p, 0);

	return (p);
}

/* MFP test only */
#ifdef MFP_TEST
static void*
wlc_frame_get_mgmt_dbg(wlc_info_t *wlc, uint16 fc, const struct ether_addr *da,
	const struct ether_addr *sa, const struct ether_addr *bssid, uint body_len,
	uint8 **pbody)
{
	uint len;
	void *p = NULL;
	osl_t *osh;
	struct dot11_management_header *hdr;
	uint iv_len = 0, tail_len = 0;

	osh = wlc->osh;


	len = DOT11_MGMT_HDR_LEN + iv_len + body_len + tail_len;

	if ((p = PKTGET(osh, (TXOFF + len), TRUE)) == NULL) {
#if defined(MFP)
		if (iv_len || tail_len)
			WL_ERROR(("wl%d: wlc_frame_get_mgmt: MFP: pktget error for len %d fc %x\n",
				wlc->pub->unit, (TXOFF + len), fc));
		else
#endif 
		WL_ERROR(("wl%d: wlc_frame_get_mgmt: pktget error for len %d fc %x\n",
			wlc->pub->unit, (TXOFF + len), fc));
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		return (NULL);
	}
	ASSERT(ISALIGNED((uintptr)PKTDATA(osh, p), sizeof(uint32)));

	/* reserve TXOFF bytes of headroom */
	PKTPULL(osh, p, TXOFF - iv_len);
	PKTSETLEN(osh, p, len + iv_len - tail_len);

	/* construct a management frame */
	hdr = (struct dot11_management_header *)PKTDATA(osh, p);
	hdr->fc = htol16(fc);
	hdr->durid = 0;
	bcopy((const char*)da, (char*)&hdr->da, ETHER_ADDR_LEN);
	bcopy((const char*)sa, (char*)&hdr->sa, ETHER_ADDR_LEN); /* Was &wlc->pub->cur_etheraddr */
	bcopy((const char*)bssid, (char*)&hdr->bssid, ETHER_ADDR_LEN);
	hdr->seq = 0;

	*pbody = (uint8*)&hdr[1] + iv_len;

	/* Set MAX Prio for MGMT packets */
	PKTSETPRIO(p, MAXPRIO);

	return (p);
}
#endif /* MFP_TEST */

static void*
wlc_frame_get_mgmt_int(wlc_info_t *wlc, uint16 fc, const struct ether_addr *da,
	const struct ether_addr *sa, const struct ether_addr *bssid, uint body_len,
	uint8 **pbody, uint8 cat)
{
	uint len;
	void *p = NULL;
	osl_t *osh;
	struct dot11_management_header *hdr;
	uint iv_len = 0, tail_len = 0;

#ifdef MFP
	wlc_bsscfg_t *bsscfg = NULL;
#if defined(BCMDBG) || defined(WLMSG_ASSOC)
	char bss_buf[ETHER_ADDR_STR_LEN];
#endif /* defined(BCMDBG) || defined(WLMSG_ASSOC) */
	bool mfp = FALSE;
#endif /* MFP */

	osh = wlc->osh;

#ifdef MFP

	/* Is this in our BSS? */
	bsscfg = wlc_bsscfg_find_by_bssid(wlc, (struct ether_addr *)bssid);
	/* Is this in the BSS we are associating to? */
	if (bsscfg == NULL) {
		bsscfg = wlc_bsscfg_find_by_target_bssid(wlc, (struct ether_addr *)bssid);
	}

	WL_WSEC(("wl%d: %s: MFP: management frame to %s, type = 0x%02x, subtype = 0x%02x,"
		" cat = 0x%02x\n",
		WLCWLUNIT(wlc), __FUNCTION__, bcm_ether_ntoa(da, bss_buf), FC_TYPE(fc),
		FC_SUBTYPE(fc), cat));

	if (bsscfg && IS_WPA2_AUTH(bsscfg->WPA_auth) && (bsscfg->wsec & MFP_CAPABLE) &&
		((fc == FC_DEAUTH) || (fc == FC_DISASSOC) ||
		((fc == FC_ACTION) && IS_ROBUSTABLE_CAT(cat)))) {
		struct scb *scb = NULL;

		WL_WSEC(("wl%d: %s: MFP: robust frame to %s, type = 0x%02x,"
			" subtype = 0x%02x, cat = 0x%02x\n",
			WLCWLUNIT(wlc), __FUNCTION__, bcm_ether_ntoa(da, bss_buf),
			FC_TYPE(fc), FC_SUBTYPE(fc), cat));

		if (!ETHER_ISMULTI(da)) {
			scb = wlc_scbfindband(wlc, da,
				CHSPEC_WLCBANDUNIT(wlc->cfg->current_bss->chanspec));
		}
		if (BSSCFG_AP(bsscfg) && ETHER_ISMULTI(da) && (fc == FC_DISASSOC)) {
				if (bsscfg->igtk.len) {
					WL_ERROR(("wl%d: %s: MFP: multicast, robust, have IGTK,"
						" protecting\n", WLCWLUNIT(wlc), __FUNCTION__));
					mfp = TRUE;
				} else {
					WL_ERROR(("wl%d: %s: MFP: multicast, MFPR, no IGTK,"
					" not encrypting\n", WLCWLUNIT(wlc), __FUNCTION__));
				}

		}
		else if (SCB_MFP(scb)) {
			/* Protect/Discard/Send Unprotected decision tree */
			/* 802.11w-2007 claims we should discard unicast frames if we don't
			*  have a key even when the peer does NOT set MFPC. We're do not
			*  implement that discard.
			*/
			if (!ETHER_ISMULTI(da)) {
				/* unicast */
				if (scb->key) {
					WL_WSEC(("wl%d: %s: MFP: unicast, peer MFPC, robust,"
					" have key, protecting\n", WLCWLUNIT(wlc), __FUNCTION__));
					mfp = TRUE;
					/* reserve iv, icv and mic space for mfp if enabled */
					wlc_mfp_tx_mod_len(wlc, scb, &iv_len, &tail_len);
					if (iv_len || tail_len)
						WL_ERROR(("wl%d: %s: MFP: allocate %d bytes for"
							" iv and %d bytes for tail\n",
							WLCWLUNIT(wlc), __FUNCTION__, iv_len,
							tail_len));
				} else if (fc == FC_ACTION && IS_ROBUSTABLE_CAT(cat)) {
					WL_WSEC(("wl%d: %s: MFP: unicast, peer MFPC, robust"
						" action, no key, discarding\n", WLCWLUNIT(wlc),
						__FUNCTION__));
					return (p);
				} else {
					/* should never reach this case as a STA in infrastructure
					   mode, join targets should prune the AP
					*/
					WL_WSEC(("wl%d: %s: MFP: unicast, MFPR, no peer MFPC,"
						" discarding\n", WLCWLUNIT(wlc), __FUNCTION__));
				}
			} else {
				/* bcast/mcast */
				WL_WSEC(("wl%d: %s: MFP: multicast not supported for STA,"
					" falling through\n", WLCWLUNIT(wlc), __FUNCTION__));
			}
		} else {
			WL_WSEC(("wl%d: %s: MFP: peer not MFP enabled, sending frame unprotected\n",
				WLCWLUNIT(wlc), __FUNCTION__));
		}
	} else {
		WL_WSEC(("wl%d: %s: MFP: sending frame unprotected\n",
			WLCWLUNIT(wlc), __FUNCTION__));
	}
#endif /* MFP */

	len = DOT11_MGMT_HDR_LEN + iv_len + body_len + tail_len;

	if ((p = PKTGET(osh, (TXOFF + len), TRUE)) == NULL) {
#if defined(MFP)
		if (iv_len || tail_len)
			WL_ERROR(("wl%d: wlc_frame_get_mgmt: MFP: pktget error for len %d fc %x\n",
				wlc->pub->unit, (TXOFF + len), fc));
		else
#endif 
		WL_ERROR(("wl%d: wlc_frame_get_mgmt: pktget error for len %d fc %x\n",
			wlc->pub->unit, (TXOFF + len), fc));
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		return (NULL);
	}
	ASSERT(ISALIGNED((uintptr)PKTDATA(osh, p), sizeof(uint32)));

	/* reserve TXOFF bytes of headroom */
	PKTPULL(osh, p, TXOFF - iv_len);
	PKTSETLEN(osh, p, len + iv_len - tail_len);

	/* construct a management frame */
	hdr = (struct dot11_management_header *)PKTDATA(osh, p);
	hdr->fc = htol16(fc);
	hdr->durid = 0;
	bcopy((const char*)da, (char*)&hdr->da, ETHER_ADDR_LEN);
	bcopy((const char*)sa, (char*)&hdr->sa, ETHER_ADDR_LEN); /* Was &wlc->pub->cur_etheraddr */
	bcopy((const char*)bssid, (char*)&hdr->bssid, ETHER_ADDR_LEN);
	hdr->seq = 0;

	*pbody = (uint8*)&hdr[1] + iv_len;

	/* Set MAX Prio for MGMT packets */
	PKTSETPRIO(p, MAXPRIO);

#ifdef MFP
	if (mfp) {
		WL_ERROR(("wl%d: %s: MFP: setting WLF_MFP flag\n", WLCWLUNIT(wlc), __FUNCTION__));
		WLPKTTAG(p)->flags |= WLF_MFP;
	}
#endif /* MFP */

#if defined(WLP2P) && defined(BCMDBG)
	if (fc == FC_ACTION || fc == FC_PROBE_REQ || fc == FC_PROBE_RESP) {
		char eabuf[ETHER_ADDR_STR_LEN];
		char *frmtype_str = NULL;
		switch (fc) {
			case FC_ACTION:
				frmtype_str = "ACTION";
				break;
			case FC_PROBE_REQ:
				frmtype_str = "PROBE_REQ";
				break;
			case FC_PROBE_RESP:
				frmtype_str = "PROBE_RESP";
				break;
		}
		WL_P2P(("wl%d: prep %s frame tx to %s, pkt %p\n",
		        wlc->pub->unit, frmtype_str,
		        bcm_ether_ntoa(&hdr->da, eabuf), p));
	}
#endif /* WLP2P && BCMDBG */
	return (p);
}

void*
wlc_frame_get_mgmt(wlc_info_t *wlc, uint16 fc, const struct ether_addr *da,
	const struct ether_addr *sa, const struct ether_addr *bssid, uint body_len,
	uint8 **pbody)
{
	return wlc_frame_get_mgmt_int(wlc, fc, da, sa, bssid, body_len, pbody, 0);
}

void*
wlc_frame_get_action(wlc_info_t *wlc, uint16 fc, const struct ether_addr *da,
	const struct ether_addr *sa, const struct ether_addr *bssid, uint body_len,
	uint8 **pbody, uint8 cat)
{
	return wlc_frame_get_mgmt_int(wlc, fc, da, sa, bssid, body_len, pbody, cat);
}

bool
wlc_queue_80211_frag(wlc_info_t *wlc, void *p, wlc_txq_info_t *qi, struct scb *scb,
                     bool short_preamble, wsec_key_t *key, ratespec_t rate_override)
{
	int prio;
	uint fifo = TX_CTL_FIFO;
#ifdef BCMDBG
	uint16 fk = 0;
	struct dot11_management_header *hdr;
#endif

	ASSERT(wlc->pub->up);

#ifdef BCMDBG
	hdr = (struct dot11_management_header*)PKTDATA(wlc->osh, p);
	fk = (ltoh16(hdr->fc) & FC_KIND_MASK);
#endif


	/* use hw rateset scb if the one passed in is NULL */
	if (scb == NULL)
		scb = wlc->band->hwrs_scb;

	prio = PKTPRIO(p);
	ASSERT(prio <= MAXPRIO);

	/* In WME mode, send mgmt frames based on priority setting */
	if ((SCB_QOS(scb) && EDCF_ENAB(wlc->pub)) || LMAC_ENAB(wlc->pub))
		fifo = prio2fifo[prio];

#ifdef MFP
	if (WLPKTTAG(p)->flags & WLF_MFP) {
		struct dot11_management_header *hdr;
		hdr = (struct dot11_management_header*)PKTDATA(wlc->osh, p);

		if (ETHER_ISMULTI(&hdr->da)) {
			/* ucast */
		} else {
			/* ucast */
			if (scb->key) {
				WL_ERROR(("wl%d: %s: MFP: WLF_MFP flag set, unicast frame,"
					" have key, will encrypt\n", WLCWLUNIT(wlc), __FUNCTION__));
				if (wlc_mfp_tx_ucast(wlc, p, scb)) {
					WL_ERROR(("wl%d: %s: MFP: encrypt of unicast management"
					" frame failed, tossing\n", WLCWLUNIT(wlc), __FUNCTION__));
					goto toss;
				}
			}
		}
	}
#endif /* MFP */
	WLPKTTAGSCBSET(p, scb);

	/* save the tx options for wlc_prep_pdu */
	wlc_pdu_push_txparams(wlc, p, short_preamble ? WLC_TX_PARAMS_SHORTPRE : 0,
	                      key, rate_override, fifo);

#ifdef BCMDBG
	if (fk == FC_REASSOC_REQ || fk == FC_ASSOC_REQ) {
		WL_ERROR(("wl%d: wlc_sendmgmt: send %sASSOC Req include tx (16)options len %d\n",
			wlc->pub->unit, fk == FC_REASSOC_REQ ? "RE" : "",
			PKTLEN(wlc->osh, p)));
	}
#endif

	if (BSSCFG_AP(scb->bsscfg) && SCB_PS(scb) && !(WLPKTTAG(p)->flags & WLF_PSDONTQ)) {
		if (wlc_apps_psq(wlc, p, WLC_PRIO_TO_HI_PREC(prio)))
			return TRUE;
		goto toss;
	}

	if (wlc_prec_enq(wlc, &qi->q, p, WLC_PRIO_TO_HI_PREC(prio))) {
		wlc_send_q(wlc, qi);
		return TRUE;
	}
toss:
	PKTFREE(wlc->osh, p, TRUE);
	WLCNTINCR(wlc->pub->_cnt->txnobuf);
	WLCIFCNTINCR(scb, txnobuf);
	WLCIFCNTINCR(scb, txnobuf);
	return FALSE;
}

bool
wlc_sendmgmt(wlc_info_t *wlc, void *p, wlc_txq_info_t *qi, struct scb *scb)
{
	return wlc_queue_80211_frag(wlc, p, qi, scb, FALSE, NULL, 0);
}

bool
wlc_sendctl(wlc_info_t *wlc, void *p, wlc_txq_info_t *qi, struct scb *scb, uint fifo,
	ratespec_t rate_override, bool enq_only)
{
	int prio;

	ASSERT(wlc->pub->up);

	/* SCB must not be NULL */
	ASSERT(scb != NULL);


	prio = PKTPRIO(p);
	ASSERT(prio <= MAXPRIO);

	/* WME: send frames based on priority setting */
	if (SCB_QOS(scb) && EDCF_ENAB(wlc->pub))
		fifo = prio2fifo[prio];

	WLPKTTAGSCBSET(p, scb);

	/* save the tx options for wlc_prep_pdu */
	wlc_pdu_push_txparams(wlc, p, 0, NULL, rate_override, fifo);

	if (BSSCFG_AP(SCB_BSSCFG(scb)) && SCB_PS(scb) && !(WLPKTTAG(p)->flags & WLF_PSDONTQ)) {
		if (wlc_apps_psq(wlc, p, WLC_PRIO_TO_HI_PREC(prio)))
			return TRUE;
		goto toss;
	}

	if (wlc_prec_enq(wlc, &qi->q, p, WLC_PRIO_TO_HI_PREC(prio))) {
		if (!enq_only)
			wlc_send_q(wlc, qi);
		return TRUE;
	}
toss:
	PKTFREE(wlc->osh, p, TRUE);
	WLCNTINCR(wlc->pub->_cnt->txnobuf);
	return FALSE;
}

/* Send a raw 802.11 MAC layer packet.
 */
bool
wlc_send80211_raw(wlc_info_t *wlc, wlc_if_t *wlcif, void *p, uint ac)
{
	struct scb *scb;
	wlc_txq_info_t *qi;
	uint fifo;
	int prio;
	static const uint ac2prio[] = {
		PRIO_8021D_BE,	/* AC_BE index */
		PRIO_8021D_BK, 	/* AC_BK index */
		PRIO_8021D_VI, 	/* AC_VI index */
		PRIO_8021D_VO	/* AC_VO index */
	};

	ASSERT(wlc->pub->up);
	ASSERT(ac < AC_COUNT);

	prio = ac2prio[ac];
	PKTSETPRIO(p, prio);

	if (wlc->pub->associated)
		scb = wlc->bandstate[CHSPEC_WLCBANDUNIT(wlc->home_chanspec)]->hwrs_scb;
	else
		scb = wlc->band->hwrs_scb;

	/* WME: send frames based on priority setting */
	if (SCB_QOS(scb) && EDCF_ENAB(wlc->pub))
		fifo = prio2fifo[ac];
	else
		fifo = TX_CTL_FIFO;

	/* add headers */
	wlc_d11hdrs(wlc, p, scb, 0, 0, 1, fifo, 0, NULL, 0);

	WLPKTTAGSCBSET(p, scb);

	if (wlcif == NULL)
		wlcif = wlc->cfg->wlcif;

	qi = wlcif->qi;

	if (wlc_prec_enq(wlc, &qi->q, p, WLC_PRIO_TO_HI_PREC(prio))) {
		wlc_send_q(wlc, qi);
		return TRUE;
	} else {
		PKTFREE(wlc->osh, p, TRUE);
		WLCNTINCR(wlc->pub->_cnt->txnobuf);
		WLCIFCNTINCR(scb, txnobuf);
		return FALSE;
	}
}

#ifdef BCMWAPI_WAI
void
wlc_wapi_station_event(wlc_info_t* wlc, wlc_bsscfg_t *bsscfg, const struct ether_addr *addr,
	void *ie, uint8 *gsn, uint16 msg_type)
{
	uint8 ie_len;
	struct wapi_sta_msg_t wapi_sta_msg;
	uint32 *dst_iv, *src_iv;
	int i, swap_len = IV_LEN / sizeof(uint32) - 1;

	memset(&wapi_sta_msg, 0, sizeof(struct wapi_sta_msg_t));

	switch (msg_type) {
	case WAPI_STA_AGING:
	case WAPI_UNICAST_REKEY:
	case WAPI_MUTIL_REKEY:
	case WAPI_STA_STATS:
		break;

	case WAPI_WAI_REQUEST:
		ASSERT(gsn);
		ASSERT(ie);
		dst_iv = (uint32 *)wapi_sta_msg.gsn;
		src_iv = (uint32 *)gsn;
		src_iv += swap_len;
		for (i = 0; i <= swap_len; i++) {
			memcpy(dst_iv, src_iv, sizeof(uint32));
			dst_iv++;
			src_iv--;
		}
		ie_len = ((uint8*)ie)[1] + 2; /* +2: wapi ie id+ wapi ie len */
		memcpy(wapi_sta_msg.wie, ie, ie_len);
		break;

	default:
		WL_ERROR(("wl%d: wlc_wapi_station_event failed, unknown msg_type %d\n",
			wlc->pub->unit, msg_type));
		return;
	}

	wapi_sta_msg.msg_type = msg_type;
	wapi_sta_msg.datalen = sizeof(struct wapi_sta_msg_t);
	memcpy(wapi_sta_msg.vap_mac, bsscfg->cur_etheraddr.octet, 6);
	memcpy(wapi_sta_msg.sta_mac, addr, 6);

	wlc_bss_mac_event(wlc, bsscfg, WLC_E_WAI_STA_EVENT, addr, 0, 0, 0,
		&wapi_sta_msg, wapi_sta_msg.datalen);

	return;
}

/* WAI rekey for mcast/unicast key */
static void
wlc_wai_rekey(wlc_info_t *wlc, wlc_bsscfg_t *cfg, struct ether_addr *addr)
{
	/* sendup a rekey event */
	wlc_wapi_station_event(wlc, cfg, addr, NULL, NULL,
		ETHER_ISNULLADDR(addr) ? WAPI_MUTIL_REKEY : WAPI_UNICAST_REKEY);

	return;
}
#endif /* BCMWAPI_WAI */

#ifdef WLLMAC
int
wlc_prep_80211sdu(wlc_info_t *wlc, void **pkts, int *npkts, uint *fifop)
{
	struct scb *scb;
	uint nfrags;
	void *pdu;
	wsec_key_t *key;
	uint8 prio = 0;
	wlc_bsscfg_t *bsscfg;
	wlc_pkttag_t *pkttag;
	struct dot11_header *h;
	bool	encrypt = FALSE;
	uint16 fc, type;
	bool qos, wds;
	uint8 *pbody;
	bool	short_preamble = FALSE;
	uint8	fifo;
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_INFORM */
	uint pkt_len;

	pdu = pkts[0];
	pkttag = WLPKTTAG(pdu);
	ASSERT(pdu != NULL);

#ifndef WLLMAC_ONLY
	if (!LMAC_ENAB(wlc->pub)) {
		WL_ERROR(("Only LMAC uses this for now\n"));
		ASSERT(0);
	}
#endif /* !WLLMAC_ONLY */

	pkt_len = PKTLEN(wlc->osh, pdu);

	if (!wlc->pub->up) {
		WL_INFORM(("wl%d: wlc_prep_80211sdu: wl is not up\n", wlc->pub->unit));
		WLCNTINCR(wlc->pub->_cnt->txnoassoc);
		goto toss;
	}

	/* Something is blocking data packets */
	if (wlc->block_datafifo)
		return BCME_BUSY;

	scb = WLPKTTAGSCBGET(pdu);

	if (SCB_ISMULTI(scb) && bcmc_pkt_q_check(wlc, scb, pdu)) {
		/* Does BCMC pkt need to go to BSS's PS queue? */
		/* Force caller to give up packet and not tx */
		return BCME_NOTREADY;
	}

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	WL_APSTA_TX(("wl%d.%d: wlc_prep_sdu: pkt %p dst %s\n", wlc->pub->unit,
	             WLC_BSSCFG_IDX(bsscfg), pdu,
	             bcm_ether_ntoa(&scb->ea, eabuf)));


	/* Toss the frame if scb's band does not match our current band
	 * this is possible if the STA has roam'ed while the packet was on txq
	 */
	if (scb->bandunit != CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec)) {
		WL_INFORM(("wl%d: frame destined to %s sent on incorrect band %d\n", wlc->pub->unit,
		           bcm_ether_ntoa(&scb->ea, eabuf),
		           scb->bandunit));
		WLCNTINCR(wlc->pub->_cnt->txnoassoc);
		goto toss;
	}
	fifo = wme_ac2fifo[WLPKTTAG(pdu)->ac_override];

	*fifop = fifo;

	/*
	 * Apply FIFO admission control to reduce "rate lag"
	 * by limiting the amount of data queued to the hardware.
	 */
	if ((TXPKTPENDGET(wlc, fifo) >= wlc->pub->txmaxpkts) && (fifo <= TX_AC_VO_FIFO)) {
		/* Mark precedences related to this FIFO, unsendable */
		WLC_TX_FIFO_CLEAR(wlc, fifo);
		return BCME_BUSY;
	}
	WLCNTINCR(wlc->pub->_cnt->txcmiss);

	h = (struct dot11_header *)PKTDATA(wlc->osh, pdu);
	fc = ltoh16(h->fc);
	if (fc & FC_WEP)
		encrypt = TRUE;

	key = NULL;
	if (encrypt) {
		/* Use a paired key or primary group key if present, toss otherwise */
		if (scb->key) {
			key = scb->key;
			WL_WSEC(("wl%d.%d: %s: using per-path key, algo %d\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__, key->algo));
		} else if ((key = WSEC_BSS_DEFAULT_KEY(bsscfg)) != NULL) {
			WL_WSEC(("wl%d.%d: %s: using group key at key-ID %d, algo %d\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__,
				bsscfg->wsec_index, key->algo));
		} else {
			WL_WSEC(("wl%d.%d: %s: tossing unencryptable frame\n",
				wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg), __FUNCTION__));
			goto toss;
		}
	} else {	/* Do not encrypt packet */
		WL_WSEC(("wl%d.%d: wlc_prep_sdu: not encrypting frame, encryption disabled\n",
			wlc->pub->unit, WLC_BSSCFG_IDX(bsscfg)));
		WL_WSEC(("wl%d.%d: wlc_prep_sdu: wsec 0x%x \n", wlc->pub->unit,
			WLC_BSSCFG_IDX(bsscfg), bsscfg->wsec));
		key = NULL;
	}

	nfrags = 1;

	if (!PIO_ENAB(wlc->pub)) {
		uint max_nsegs = MAX_DMA_SEGS;
		if (BCM4331_CHIP_ID == CHIPID(wlc->pub->sih->chip))
			max_nsegs *= 2;
		/* bail if there is insufficient room in the ring to hold all fragments */
		if ((uint)TXAVAIL(wlc, fifo) < (nfrags * max_nsegs)) {
			WL_ERROR(("%s: avail %d, frags %d, fifo %d\n", __FUNCTION__,
				TXAVAIL(wlc, fifo), (nfrags * max_nsegs), fifo));
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		} else {
			WL_TRACE(("%s: avail %d, frags %d\n", __FUNCTION__,
				TXAVAIL(wlc, fifo), (nfrags * max_nsegs)));
		}
	} else {
		uint sz;

		/* calculate required "flow-control" amount of all fragments */

		/* per frag header overhead */
		sz = D11_TXH_LEN + D11_PHY_HDR_LEN + pkttotlen(wlc->osh, pdu);
		/* bail if there is insufficient room in the fifo to hold all fragments */
		if (!wlc_pio_txavailable(wlc->hw->pio[fifo], sz, nfrags)) {
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}
	}

	type = FC_TYPE(fc);
	qos = (type == FC_TYPE_DATA && FC_SUBTYPE_ANY_QOS(FC_SUBTYPE(fc)));
	wds = (fc & (FC_TODS | FC_FROMDS)) == (FC_TODS | FC_FROMDS);

	pbody = (uint8 *)PKTDATA(wlc->osh, pdu) + DOT11_A3_HDR_LEN;
	if (qos) {
		prio = (uint8)(QOS_PRIO(ltoh16_ua(pbody)));
		pbody += DOT11_QOS_LEN;
	}
	if (wds)
		pbody += ETHER_ADDR_LEN;
#ifdef WL11N
	if ((FC_TYPE(fc) == FC_TYPE_DATA || FC_TYPE(fc) == FC_TYPE_MNG) && (fc & FC_ORDER)) {
		uint8 temp_hdr[48];
		uint8 hdr_size;
		uint8 *start_buf = PKTDATA(wlc->osh, pdu);

		hdr_size = pbody - start_buf;
		bcopy(start_buf, &temp_hdr[0], hdr_size);
		PKTPULL(wlc->osh, pdu, DOT11_HTC_LEN);
		bcopy(&temp_hdr[0], PKTDATA(wlc->osh, pdu), hdr_size);
		h = (struct dot11_header *)PKTDATA(wlc->osh, pdu);
		fc &= ~FC_ORDER;
		h->fc = htol16(fc);
		pbody = (uchar *)h;
		pbody += hdr_size;
	}
#endif /* WL11N */

#ifdef STA
	if (BSSCFG_STA(bsscfg))
		wlc_pm_tx_upd(wlc, bsscfg, scb, FALSE, fifo, prio);
#endif /* STA */

#ifdef WLBA
	if (SCB_BA(scb))
		wlc_ba_process_data_pkt(wlc->bastate, scb, prio, pkts, nfrags);
#endif

	if (key) {
#ifdef BCMWAPI_WAI
		if (key->algo == CRYPTO_ALGO_SMS4 &&
		   (ETHER_ISNULLADDR(&key->ea)) &&
		   (key->wapi_tx % WAPI_MSK_REKEY_COUNT) == 0) {
			wlc_wapi_station_event(wlc, bsscfg, &ether_bcast, NULL,
				NULL, WAPI_MUTIL_REKEY);
		}
#endif /* BCMWAPI_WPI */

		wlc_key_iv_update(wlc, scb->bsscfg, key, pbody, TRUE);

		/* Packet has pre filled IV/ICV/MIC fields */
		pbody += key->iv_len;
		WL_INFORM(("%s: IV len is %d\n", __FUNCTION__, key->iv_len));

		/* Packet HAS IV and ICV already init..so reduce the len of packet by ICV len */
		WL_INFORM(("Adjusting the Packet Length because of ICV %d actual %d\n",
			key->icv_len, PKTLEN(wlc->osh, pdu)));
		pkt_len -= key->icv_len;

		if (key->algo == CRYPTO_ALGO_TKIP) {
			WL_INFORM(("Adjusting the Packet Length because of MIC, %d actual %d\n",
				TKIP_MIC_SIZE, PKTLEN(wlc->osh, pdu)));
			pkt_len -= TKIP_MIC_SIZE;
#ifndef WLLMAC_ONLY
			if (!LMAC_ENAB(wlc->pub) && !WSEC_HW_TKMIC_KEY(wlc, key, bsscfg)) {
				struct ether_header eh;
				struct  ether_addr *da, *sa;

				h = (struct dot11_header *)PKTDATA(wlc->osh, pdu);
				WL_INFORM(("Adding the MIC in the software\n"));

				if ((fc & FC_TODS) == 0) {
					da = &h->a1;
					if ((fc & FC_FROMDS) == 0)
						sa = &h->a2;
					else
						sa = &h->a3;

				} else {
					da = &h->a3;
					if ((fc & FC_FROMDS) == 0)
						sa = &h->a2;
					else
						sa = &h->a4;
				}
				bcopy(da, &eh.ether_dhost, ETHER_ADDR_LEN);
				bcopy(sa, &eh.ether_shost, ETHER_ADDR_LEN);

				wlc_dofrag_tkip(wlc->pub, pdu, 0, 1, wlc->osh,
					bsscfg, scb, &eh, key, prio,
					(uint)((uintptr)pbody -
					(uintptr)PKTDATA(wlc->osh, pdu)));
			}
			else
#endif /* WLLMAC_ONLY */
				WL_INFORM(("Add MIC is in UCODE\n"));
		}
#ifdef BCMWAPI_WPI
		else if (key->algo == CRYPTO_ALGO_SMS4) {
			if (WSEC_SOFTKEY(wlc, key, bsscfg)) {
				int err;
				err = sms4_wpi_pkt_encrypt(&key->data[0], &key->data[SMS4_KEY_LEN],
					pkt_len, (uint8 *)h);
				if (err != 0) {
					WL_ERROR(("%s: SMS4 Crypt Error: %d, for packet %p\n",
						__FUNCTION__, err, pdu, pkt_len));
					ASSERT(0);
				}
			}
#ifdef BCMWAPI_WAI
			/* Increment transmit multicast cipher packets counter */
			if (ETHER_ISNULLADDR(&key->ea))
				key->wapi_tx++;
#endif /* BCMWAPI_WAI */
		}
#endif /* BCMWAPI_WPI */
		PKTSETLEN(wlc->osh, pdu, pkt_len);	/* adjust the packet length */
	}

	short_preamble = ((scb->flags & SCB_SHORTPREAMBLE) != 0);

	wlc_d11hdrs(wlc, pdu, scb, short_preamble, 0, 1, fifo, 0, key, 0);

	/* Free the original SDU if not shared */
	if (pkts[nfrags - 1] != pdu)
		PKTFREE(wlc->osh, pdu, TRUE);

	*npkts = nfrags;

	wlc_update_txpktsuccess_stats(wlc, scb, pkt_len, prio);
	return 0;
toss:
	WL_ERROR(("%s: tossing packet\n", __FUNCTION__));
	*npkts = 0;
	wlc_update_txpktfail_stats(wlc, pkt_len, prio);

	PKTFREE(wlc->osh, pdu, TRUE);
	return BCME_ERROR;
}
#endif /* WLLMAC */

/* push a tx_params structure on the head of a packet when creating an
 * MPDU packet without a d11 hardware txhdr
 */
static void
wlc_pdu_push_txparams(wlc_info_t *wlc, void *p,
                      uint32 flags, wsec_key_t *key, ratespec_t rate_override, uint fifo)
{
	wlc_pdu_tx_params_t tx_params;

	/* push on the tx params */
	tx_params.flags = flags;
	tx_params.key = key;
	tx_params.rspec_override = rate_override;
	tx_params.fifo = fifo;

	PKTPUSH(wlc->osh, p, sizeof(wlc_pdu_tx_params_t));
	memcpy(PKTDATA(wlc->osh, p), &tx_params, sizeof(wlc_pdu_tx_params_t));

	/* Mark the pkt as an MPDU (802.11 header) but no hardware txhdr */
	WLPKTTAG(p)->flags |= WLF_MPDU;
}

/* create the d11 hardware txhdr for an MPDU packet that does not have a txhrd.
 * The packet begins with a tx_params structure used to supply some
 * parameters to wlc_d11hdrs()
 */
static void
wlc_pdu_txhdr(wlc_info_t *wlc, void *p, struct scb *scb)
{
	wlc_pdu_tx_params_t tx_params;
	bool short_preamble;

	/* pull off the saved tx params */
	memcpy(&tx_params, PKTDATA(wlc->osh, p), sizeof(wlc_pdu_tx_params_t));
	PKTPULL(wlc->osh, p, sizeof(wlc_pdu_tx_params_t));

	short_preamble = (tx_params.flags & WLC_TX_PARAMS_SHORTPRE) != 0;

	/* add headers */
	wlc_d11hdrs(wlc, p, scb, short_preamble, 0, 1, tx_params.fifo, 0,
	            tx_params.key, tx_params.rspec_override);
}

/* prepares pdu for transmission. returns BCM error codes */
int
wlc_prep_pdu(wlc_info_t *wlc, void *pdu, uint *fifop)
{
	uint nbytes;
	osl_t *osh;
	uint fifo;
	d11txh_t *txh;
	struct dot11_header *h;
	struct scb *scb;
	uint16 fc;
	wlc_bsscfg_t *cfg;

	/* Make sure that it's a PDU */
	ASSERT(WLPKTTAG(pdu)->flags & WLF_MPDU);

	scb = WLPKTTAGSCBGET(pdu);
	ASSERT(scb != NULL);

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

	if (SCB_ISMULTI(scb) && bcmc_pkt_q_check(wlc, scb, pdu)) {
		/* Does BCMC pkt need to go to BSS's PS queue? */
		/* Force caller to give up packet and not tx */
		return BCME_NOTREADY;
	}

	/* Drop the frame if it's not on the current band */
	/* Note: We drop it instead of returning as this can result in head-of-line
	 * blocking for Probe request frames during the scan
	 */
	if (scb->bandunit != CHSPEC_WLCBANDUNIT(WLC_BAND_PI_RADIO_CHANSPEC)) {
		PKTFREE(wlc->osh, pdu, TRUE);
		WLCNTINCR(wlc->pub->_cnt->txchanrej);
		return BCME_BADBAND;
	}

	osh = wlc->osh;

	/* add the txhdr if not present */
	if ((WLPKTTAG(pdu)->flags & WLF_TXHDR) == 0)
		wlc_pdu_txhdr(wlc, pdu, scb);

	txh = (d11txh_t *)PKTDATA(osh, pdu);
	h = (struct dot11_header *)((uint8 *)(txh + 1) + D11_PHY_HDR_LEN);
	fc = ltoh16(h->fc);

	/* get the pkt queue info. This was put at wlc_sendctl or wlc_send for PDU */
	fifo = ltoh16(txh->TxFrameID) & TXFID_QUEUE_MASK;

	/*
	 * If the STA is in PS mode, this must be a PS Poll response or APSD delivery frame;
	 * fix the MPDU accordingly.
	 */
	if (BSSCFG_AP(cfg) && SCB_PS(scb)) {
		wlc_apps_ps_prep_mpdu(wlc, pdu);
		if (SCB_ISMULTI(scb)) {
			uint16 frameid;

			/* In APSTA mode, our STA can't ever be in PS Mode */
			ASSERT(BSSCFG_AP(cfg));
			fifo = TX_BCMC_FIFO;
			frameid = bcmc_fid_generate(wlc, cfg, txh);
			txh->TxFrameID = htol16(frameid);
		}
	}

	*fifop = fifo;

#if defined(STA) && defined(WME)
	/* If sending APSD trigger frame, stay awake until EOSP */
	if (BSSCFG_STA(cfg)) {
		wlc_pm_st_t *pm = cfg->pm;

		if (pm->PMenabled &&
		    WME_ENAB(wlc->pub) &&
		    (fifo <= TX_AC_VO_FIFO) &&
		    AC_BITMAP_TST(scb->apsd.ac_trig, wme_fifo2ac[fifo]) &&
		    FC_TYPE(fc) == FC_TYPE_DATA && FC_SUBTYPE_ANY_QOS(FC_SUBTYPE(fc))) {
			if (!pm->apsd_sta_usp) {
				WL_PS(("wl%d.%d: APSD ctl wake\n",
				       wlc->pub->unit, WLC_BSSCFG_IDX(cfg)));
				wlc_set_apsd_stausp(cfg, TRUE);
			}
			scb->flags |= SCB_SENT_APSD_TRIG;
		}
	}
#endif /* defined(STA) && defined(WME) */

	if (!PIO_ENAB(wlc->pub)) {
		uint max_nsegs = MAX_DMA_SEGS;
		if (BCM4331_CHIP_ID == CHIPID(wlc->pub->sih->chip))
			max_nsegs *= 2;
		/* return if insufficient dma resources */
		if ((uint)TXAVAIL(wlc, fifo) < max_nsegs) {
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}

		if ((fifo == TX_BCMC_FIFO) &&
			(TXPKTPENDGET(wlc, fifo) >= TXFID_MAX_BCMC_FID)) {
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}
	} else {
		nbytes = pkttotlen(osh, pdu);

		/* return if insufficient pio resources */
		if (!wlc_pio_txavailable(wlc->hw->pio[fifo], nbytes, 1)) {
			/* Mark precedences related to this FIFO, unsendable */
			WLC_TX_FIFO_CLEAR(wlc, fifo);
			return BCME_BUSY;
		}
	}

	if (FC_TYPE(ltoh16(txh->MacFrameControl)) != FC_TYPE_DATA)
		WLCNTINCR(wlc->pub->_cnt->txctl);

	return 0;
}

void
wlc_sendprobe(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg,
	uint8 ssid[], int ssid_len, const struct ether_addr *da, const struct ether_addr *bssid,
	ratespec_t ratespec_override, uint8 *extra_ie, int extra_ie_len)
{
	void *p;
	uint8 *pbody, *bufend;
	const wlc_rateset_t *rs;
	wlc_rateset_t sup_rates, ext_rates;
	int body_len;
#ifdef WL11U
	uint8 ext_cap[DOT11_EXTCAP_LEN_MAX];
	uint8 ext_cap_len = 0;
	bzero(ext_cap, sizeof(ext_cap));
#endif /* WL11U */

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		wlc_lmac_sendprobe(wlc->lmac_info, ssid, ssid_len, da, bssid, ratespec_override);
		return;
	}
#endif /* WLLMAC */

	bzero(&sup_rates, sizeof(wlc_rateset_t));
	bzero(&ext_rates, sizeof(wlc_rateset_t));
	if ((BAND_2G(wlc->band->bandtype)) && (wlc->band->gmode == GMODE_LEGACY_B))
		rs = &cck_rates;	/* only advertise 11b rates */
	else
		rs = &wlc->band->hw_rateset;

	/* For 2.4Ghz band probe requests, CCK-only in sup_rates, OFDM in ext_rates */
	if ((BAND_2G(wlc->band->bandtype)) && wlc->legacy_probe)
		wlc_rateset_copy(&cck_rates, &sup_rates);

	wlc_rateset_elts(wlc, bsscfg, rs, &sup_rates, &ext_rates);

	/*
	 * get a packet - probe req has the following contents:
	 * InfoElt   SSID
	 * InfoElt   Supported rates
	 * InfoElt   Extended Supported rates (11g)
	 * InfoElt   DS Params
	 * InfoElt   BRCM proprietary
	 */

	body_len = TLV_HDR_LEN + ssid_len;
	body_len += TLV_HDR_LEN + sup_rates.count;

	if (ext_rates.count > 0)
		body_len += TLV_HDR_LEN + ext_rates.count;
	if (bsscfg->brcm_ie[TLV_LEN_OFF] > 0)
		body_len += TLV_HDR_LEN + bsscfg->brcm_ie[TLV_LEN_OFF];

	if (BSS_N_ENAB(wlc, bsscfg)) {
		/* account for the length of both the prop ie and ana-assigned ie */
		body_len += TLV_HDR_LEN + (HT_CAP_IE_LEN + HT_PROP_IE_OVERHEAD);
		body_len += TLV_HDR_LEN + HT_CAP_IE_LEN;
	}

	if (CHSPEC_IS2G(bsscfg->current_bss->chanspec))
		body_len += TLV_HDR_LEN + 1; /* 1 byte to specify chanspec */

	body_len += wlc_vndr_ie_getlen(bsscfg, VNDR_IE_PRBREQ_FLAG, NULL);

#ifdef WL11K
	if (WL11K_ENAB(wlc->pub))
		body_len += TLV_HDR_LEN + 7; /* 7 byte according to 11k spec appendix D */
#endif


#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg))
		body_len += wlc_p2p_write_ie_len(wlc->p2p, bsscfg, FC_PROBE_REQ);
#endif

#ifdef WL11U
	if (bsscfg->iw_ie) {
		/* 11u interworking, extended capabilities */
		setbit(ext_cap, DOT11_EXT_CAP_IW);
		if (ext_cap_len < DOT11_EXTCAP_LEN_IW)
			ext_cap_len = DOT11_EXTCAP_LEN_IW;
		body_len += TLV_HDR_LEN + bsscfg->iw_ie[TLV_LEN_OFF];
	}
#endif /* WL11U */

#ifdef WL11U
	if (ext_cap_len)
		body_len += TLV_HDR_LEN + ext_cap_len;
#endif /* WL11U */

	if ((p = wlc_frame_get_mgmt(wlc, FC_PROBE_REQ, da,
		&bsscfg->cur_etheraddr, bssid, body_len, &pbody)) == NULL) {
		return;
	}

	/* save end of buffer location */
	bufend = pbody + body_len;

	/* fill out the probe request body */

	/* SSID */
	pbody = wlc_write_info_elt(pbody, DOT11_MNG_SSID_ID, ssid_len, ssid);

	/* Supported Rates */
	pbody = wlc_write_info_elt(pbody, DOT11_MNG_RATES_ID, sup_rates.count, sup_rates.rates);

	/* Extended Supported Rates */
	if (ext_rates.count > 0)
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_EXT_RATES_ID, ext_rates.count,
			ext_rates.rates);

	if (BSS_N_ENAB(wlc, bsscfg)) {
		ht_cap_ie_t cap_ie;
		wlc_write_ht_cap_ie(bsscfg, &cap_ie,
		                    &wlc->band->hw_rateset.mcs[0],
		                    BAND_2G(wlc->band->bandtype));
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_HT_CAP, HT_CAP_IE_LEN, &cap_ie);
	}

#ifdef WL11U
	if (ext_cap_len) {
		/* extended capabilities */
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_EXT_CAP_ID, ext_cap_len, ext_cap);
	}
#endif /* WL11U */

	/* If 2.4 Ghz, add DS Parameters. New in 802.11k, see 7.2.3.8 */
	if (CHSPEC_IS2G(bsscfg->current_bss->chanspec)) {
		pbody[0] = DOT11_MNG_DS_PARMS_ID;
		pbody[1] = 1;
		pbody[2] = wf_chspec_ctlchan(wlc->chanspec);
		pbody += 3;
	}

#ifdef WL11U
	if (bsscfg->iw_ie) {
		/* 11u interworking */
		pbody = wlc_copy_info_elt(pbody, bsscfg->iw_ie);
	}
#endif /* WL11U */

	/* Write the Vendor IEs */
	pbody = wlc_vndr_ie_write(bsscfg, pbody, BUFLEN(pbody, bufend), VNDR_IE_PRBREQ_FLAG);

	/* BRCM proprietary elt */
	if (bsscfg->brcm_ie[TLV_LEN_OFF] > 0)
		pbody = wlc_copy_info_elt(pbody, bsscfg->brcm_ie);



	if (BSS_N_ENAB(wlc, bsscfg)) {
		ht_cap_ie_t cap_ie;
		wlc_write_ht_cap_ie(bsscfg, &cap_ie,
		                    &wlc->band->hw_rateset.mcs[0],
		                    BAND_2G(wlc->band->bandtype));
		pbody = wlc_write_brcm_ht_cap_ie(wlc, pbody, BUFLEN(pbody, bufend), &cap_ie);
	}

#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg))
		pbody += wlc_p2p_write_ie(wlc->p2p, bsscfg, FC_PROBE_REQ, pbody);
#endif

#ifdef WL11K
	if (WL11K_ENAB(wlc->pub))
		pbody = wlc_write_brcm_tpc_ie(wlc, pbody, BUFLEN(pbody, bufend));
#endif

#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, bsscfg))
		wlc_p2p_sendprobe(wlc->p2p, bsscfg, p);
	else
#endif
	wlc_sendmgmt(wlc, p, wlc->active_queue, NULL);
}

void *
wlc_sendauth(
	wlc_bsscfg_t *cfg,
	struct ether_addr *ea,
	struct ether_addr *bssid,
	struct scb *scb,
	int auth_alg,
	int auth_seq,
	int auth_status,
	wsec_key_t *scb_key,
	uint8 *challenge_text,
	bool short_preamble
)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_txq_info_t *qi;
	void *p = NULL;
	uint8 *pbody, *bufend;
	struct dot11_auth *auth;
	uint16 fc;
	int body_len;
	wsec_key_t *key = NULL;

	ASSERT(cfg != NULL);

	/* assert:  (status == success) -> (scb is not NULL) */
	ASSERT((auth_status != DOT11_SC_SUCCESS) || (scb != NULL));

	/* All Authentication frames have a common 6 byte contents:
	 * 2 bytes Authentication Alg Number
	 * 2 bytes Authentication Transaction Number
	 * 2 bytes Status Code
	 */
	body_len = 6;

	/* Authentications frames 2 and 3 for Shared Key auth have a 128 byte
	 * Challenge Text Info element
	 */
	if ((auth_alg == DOT11_SHARED_KEY) && (auth_status == DOT11_SC_SUCCESS) &&
	    ((auth_seq == 2) || (auth_seq == 3))) {
		ASSERT(challenge_text != NULL);
		body_len += (2 + challenge_text[1]);

		/* frame 3 is also WEP encrypted */
		if (auth_seq == 3) {
			if (scb_key)
				key = scb_key;
			else
				key = WSEC_BSS_DEFAULT_KEY(cfg);

			if (key == NULL) {
				WL_ERROR(("wl%d: transmit key absent\n", wlc->pub->unit));
#ifdef STA
				wlc_auth_tx_complete(wlc, TX_STATUS_NO_ACK,
				                     (void *)(uintptr)cfg->ID);
#endif /* STA */
				return NULL;
			}
		}
	} else {
		ASSERT(challenge_text == NULL);
	}

	/* get a packet */
	if (key) {
		fc = (FC_AUTH | FC_WEP);
		body_len += key->iv_len;
	} else
		fc = FC_AUTH;

	body_len += wlc_vndr_ie_getlen(cfg, VNDR_IE_AUTHRSP_FLAG, NULL);

#if defined(BCMSUP_PSK) && defined(WLFBT)
	if (WLFBT_ENAB(wlc->pub) &&	(auth_alg == DOT11_FAST_BSS)) {
		body_len += wlc_sup_ftauth_getlen(cfg->sup);
	}
#endif
	if (cfg->brcm_ie[TLV_LEN_OFF] > 0)
		body_len += TLV_HDR_LEN + cfg->brcm_ie[TLV_LEN_OFF];

	if ((p = wlc_frame_get_mgmt(wlc, fc, ea, &cfg->cur_etheraddr,
	                            bssid, body_len, &pbody)) == NULL) {
#ifdef STA
#endif /* STA */
		return NULL;
	}

	/* save end of buffer location */
	bufend = pbody + body_len;

	if (key) {
		wlc_key_iv_update(wlc, cfg, key, pbody, 0);
		auth = (struct dot11_auth *)(pbody + key->iv_len);
	} else {
		auth = (struct dot11_auth *)pbody;
	}

	auth->alg = htol16((uint16)auth_alg);
	auth->seq = htol16((uint16)auth_seq);
	auth->status = htol16((uint16)auth_status);

	pbody = (void*)(&auth[1]);

	if (challenge_text) {
		bcopy((char*)challenge_text, pbody, 2 + challenge_text[1]);
#ifdef BCMDBG
		if (WL_ASSOC_ON()) {
			prhex("Authentication challenge text", challenge_text, 2 +
				challenge_text[1]);
		}
#endif /* BCMDBG */
		pbody = (void*)(pbody + 2 + challenge_text[1]);
	}

#if defined(BCMSUP_PSK) && defined(WLFBT)
	if (WLFBT_ENAB(wlc->pub) && (auth_alg == DOT11_FAST_BSS))
		pbody = wlc_sup_ft_authreq(cfg->sup, pbody);
#endif

	/* Write the Vendor IEs */
	pbody = wlc_vndr_ie_write(cfg, pbody, BUFLEN(pbody, bufend), VNDR_IE_AUTHRSP_FLAG);

	/* BRCM proprietary elt */
	if (cfg->brcm_ie[TLV_LEN_OFF] > 0)
		pbody = wlc_copy_info_elt(pbody, cfg->brcm_ie);

	/* As an AP, send using the bsscfg queue so that the auth response will go out on the bsscfg
	 * channel.
	 *
	 * As a STA, send using the active_queue instead of the bsscfg queue. When roaming, the
	 * bsscfg queue will be associated with the current associated channel, not the roam target
	 * channel.
	 */
	if (BSSCFG_AP(cfg))
		qi = cfg->wlcif->qi;
	else
		qi = wlc->active_queue;

	if (wlc_queue_80211_frag(wlc, p, qi, scb, short_preamble, key, 0))
		return p;

	return NULL;
}

void *
wlc_senddisassoc(wlc_info_t *wlc, const struct ether_addr *da, const struct ether_addr *bssid,
	const struct ether_addr *sa, struct scb *scb, uint16 reason_code)
{
	void *p = NULL;
	uint8 *pbody;
	uint16 *reason;
	wlc_bsscfg_t *bsscfg;

	if (scb)
		bsscfg = scb->bsscfg;
	else
		bsscfg = wlc->cfg;

	/*
	 * get a packet - disassoc pkt has the following contents:
	 * 2 bytes Reason Code
	 */

	if ((p = wlc_frame_get_mgmt(wlc, FC_DISASSOC, da, sa, bssid, 2, &pbody)) == NULL)
		return p;

	/* fill out the disassociation reason code */
	reason = (uint16 *) pbody;
	reason[0] = htol16(reason_code);

	if (bsscfg) {
		if (wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, scb))
			return p;

		wlc_smfstats_update(wlc, bsscfg, SMFS_TYPE_DISASSOC_TX, reason_code);
	}
	return NULL;
}

#ifdef MFP_TEST
void *
wlc_send_disassoc_deauth(wlc_info_t *wlc, const struct ether_addr *da,
	const struct ether_addr *bssid, const struct ether_addr *sa,
	struct scb *scb, uint16 fc, uint16 reason_code, int flag)
{
	void *p = NULL;
	uint8 *pbody;
	uint16 *reason;
	wlc_bsscfg_t *bsscfg;

	WL_ASSOC(("wl%d: %s ...\n",  WLCWLUNIT(wlc), __FUNCTION__));
	if (scb)
		bsscfg = scb->bsscfg;
	else
		bsscfg = wlc->cfg;

	ASSERT(fc == FC_DISASSOC || fc == FC_DEAUTH);
	/*
	 * get a packet - disassoc pkt has the following contents:
	 * 2 bytes Reason Code
	 */

	if (BSSCFG_AP(bsscfg) && ETHER_ISMULTI(da)) {
		uint body_len = 2 + sizeof(struct wifi_mmie_ie);
		if (flag) {
			if ((p = wlc_frame_get_mgmt(wlc, fc, da, sa, bssid, body_len, &pbody))
				== NULL)
				return p;
		} else {
			if ((p = wlc_frame_get_mgmt_dbg(wlc, fc, da, sa, bssid, 2, &pbody))
				== NULL)
				return p;
		}
	}
	else if (flag) {
		if (flag == 1) {
#ifdef BCMDBG
			wl_wsec_key_t key_param;
			bcopy(da, &key_param.ea, sizeof(struct ether_addr));
			wlc_key_set_error(wlc,
				fc == FC_DISASSOC?
				WSEC_GEN_MFP_DISASSOC_ERROR : WSEC_GEN_MFP_DEAUTH_ERROR,
				&key_param);
#endif
		}
		if ((p = wlc_frame_get_mgmt(wlc, fc, da, sa, bssid, 2, &pbody)) == NULL)
			return p;
	}
	else {
		/* bypass normal path so no encryption is used */
		if ((p = wlc_frame_get_mgmt_dbg(wlc, fc, da, sa, bssid, 2, &pbody)) == NULL)
			return p;
	}

	/* fill out the disassociation reason code */
	reason = (uint16 *) pbody;
	reason[0] = htol16(reason_code);

	if (flag && BSSCFG_AP(bsscfg) && ETHER_ISMULTI(da)) {
		wlc_mfp_tx_mcast(wlc, p, bsscfg, pbody, 2 + sizeof(struct wifi_mmie_ie));
		if (flag == 1) {
			/* to send a frame with incorrect key, just flip first byte of mic */
			wifi_mmie_ie_t *ie;
			ie = (wifi_mmie_ie_t *) (pbody + 2);
			ie->mic[0] = ~ie->mic[0];
		}
	}
	if (wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, scb))
		return p;

	WL_ASSOC(("wl%d: %s exit\n",  WLCWLUNIT(wlc), __FUNCTION__));
	return NULL;
}
#endif /* MFP_TEST */


#if (defined(BCMSUP_PSK) && defined(WLFBT))
void *
wlc_sendftreq(
	wlc_bsscfg_t *cfg,
	struct ether_addr *ea,
	struct scb *scb,
	wsec_key_t *scb_key,
	bool short_preamble)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_txq_info_t *qi;
	void *p = NULL;
	uint8 *pbody, *bufend;
	dot11_ft_req_t *ft_req;
	uint16 fc;
	int body_len;
	wsec_key_t *key = NULL;

	ASSERT(cfg != NULL);

	/* assert:  (status == success) -> (scb is not NULL) */
	ASSERT(scb != NULL);

	body_len = DOT11_FT_REQ_FIXED_LEN + wlc_sup_ftauth_getlen(cfg->sup);

	if (scb_key)
		key = scb_key;

	/* get a packet */
	if (key) {
		fc = (FC_ACTION | FC_WEP);
		body_len += key->iv_len;
	} else
		fc = FC_ACTION;

	if ((p = wlc_frame_get_mgmt(wlc, fc, &cfg->BSSID, &cfg->cur_etheraddr,
	                            &cfg->BSSID, body_len, &pbody)) == NULL) {
#ifdef STA
#endif /* STA */
		return NULL;
	}

	/* save end of buffer location */
	bufend = pbody + body_len;
	if (key) {
		wlc_key_iv_update(wlc, cfg, key, pbody, 0);
		ft_req = (dot11_ft_req_t*)(pbody + key->iv_len);
	} else {
		ft_req = (dot11_ft_req_t*)pbody;
	}

	ft_req->category = DOT11_ACTION_CAT_FBT;
	ft_req->action = DOT11_FT_ACTION_FT_REQ;
	bcopy(&cfg->cur_etheraddr, ft_req->sta_addr, ETHER_ADDR_LEN);
	bcopy(&cfg->target_bss->BSSID, ft_req->tgt_ap_addr, ETHER_ADDR_LEN);

	pbody = (void*)(&ft_req[1]);

	pbody = wlc_sup_ft_authreq(cfg->sup, pbody);

#if defined(BCMDBG) || defined(WLMSG_INFORM)
	prhex("ft_req", bufend - body_len, body_len);
#endif /* defined(BCMDBG) || defined(WLMSG_INFORM) */

	/*
	  Send using the bsscfg queue so that the FT Req will go out on the current
	  associated channel, not the roam target channel.
	 */
	qi = cfg->wlcif->qi;

	if (wlc_queue_80211_frag(wlc, p, qi, scb, short_preamble, key, 0))
		return p;

	return NULL;
}
#endif /* defined(BCMSUP_PSK) && defined(WLFBT) */


/*
 * For non-WMM association: sends a Null Data frame.
 *
 * For WMM association: if prio is -1, sends a Null Data frame;
 * otherwise sends a QoS Null frame with priority prio.
 */
void *
wlc_sendnulldata(wlc_info_t *wlc, struct ether_addr *da, ratespec_t rate_override,
                 uint32 pktflags, int prio)
{
	void *p;
	uint8 *pbody;
	uint16 fc;
	int qos, body_len;
	struct ether_addr *bssid;
	struct scb *scb;
	wlc_bsscfg_t *bsscfg;
#if defined(BCMDBG) || defined(WLMSG_PS)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return wlc_lmac_sendnulldata(wlc->lmac_info, da, rate_override, pktflags, prio);
#endif

	if (!(scb = wlc_scbfind(wlc, da)))
		return NULL;

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	if (prio < 0) {
		qos = 0;
		prio = PRIO_8021D_BE;
	} else
		qos = SCB_QOS(scb);

	if (qos) {
		fc = FC_QOS_NULL;
		body_len = 2;
	} else {
		fc = FC_NULL_DATA;
		body_len = 0;
	}

	if (SCB_WDS(scb)) {
		fc |= FC_FROMDS | FC_TODS;
		/* WDS Data Frame...so four addresses */
		body_len += ETHER_ADDR_LEN;
	}
	else if (BSSCFG_STA(bsscfg)) {
		if (bsscfg->BSS)
			fc |= FC_TODS;
	} else {
		fc |= FC_FROMDS;
	}

	bssid = &bsscfg->BSSID;

	if ((p = wlc_frame_get_mgmt(wlc, fc, da, &bsscfg->cur_etheraddr,
	                            bssid, body_len, &pbody)) == NULL)
		return p;

	WLPKTTAG(p)->flags |= pktflags;

	PKTSETPRIO(p, prio);

	/* For WDS addresses, mgmt has correct RA and TA, but DA and SA need fixup */
	if (SCB_WDS(scb)) {
		struct dot11_header *hdr = (struct dot11_header *)PKTDATA(wlc->osh, p);
		ASSERT(PKTLEN(wlc->osh, p) >= DOT11_A4_HDR_LEN);
		bcopy(da->octet, hdr->a3.octet, ETHER_ADDR_LEN);
		bcopy((char*)&wlc->pub->cur_etheraddr, hdr->a4.octet, ETHER_ADDR_LEN);
	}

	if (qos) {
		uint16 *pqos;
		/* Initialize the QoS Control field that comes after all addresses. */
		pqos = (uint16 *)((uint8 *)PKTDATA(wlc->osh, p) +
		                  DOT11_MGMT_HDR_LEN + body_len - DOT11_QOS_LEN);
		ASSERT(ISALIGNED((uintptr)pqos, sizeof(*pqos)));
		if (wlc->wme_noack == QOS_ACK_NO_ACK)
			WLPKTTAG(p)->flags |= WLF_WME_NOACK;
		*pqos = htol16(((prio << QOS_PRIO_SHIFT) & QOS_PRIO_MASK) |
		               ((wlc->wme_noack << QOS_ACK_SHIFT) & QOS_ACK_MASK));
	}

	WL_PS(("wl%d.%d: sending null frame to %s\n", wlc->pub->unit,
	       WLC_BSSCFG_IDX(bsscfg), bcm_ether_ntoa(da, eabuf)));

	/* use sendctl to send packet */
	if (wlc_sendctl(wlc, p, bsscfg->wlcif->qi, scb, TX_DATA_FIFO, rate_override, FALSE))
		return p;

	return NULL;
}

#ifdef STA
void *
wlc_sendapsdtrigger(wlc_info_t *wlc, struct scb *scb)
{
	/* Select the prio based on valid values and user override. */
	int prio = (int)acbitmap2maxprio[wlc->apsd_trigger_ac & scb->apsd.ac_trig];

	return wlc_sendnulldata(wlc, &scb->ea, 0, 0, prio);
}

void
wlc_rateprobe(wlc_info_t *wlc, struct ether_addr *ea, ratespec_t rate_override)
{
	void *pkt;

	pkt = wlc_sendnulldata(wlc, ea, rate_override, 0, PRIO_8021D_BE);

	if (pkt == NULL)
		return;

	WLPKTFLAG2_TYPESET(pkt, WLF2_TYPE_RATE);
}

static void
wlc_rateprobe_complete(wlc_info_t *wlc, void *pkt, uint txs)
{
	struct scb *scb;
	wlc_bsscfg_t *bsscfg;

	/* no ack */
	if (!(txs & TX_STATUS_ACK_RCV))
		return;

	/* make sure the scb is still around */
	if ((scb = WLPKTTAGSCBGET(pkt)) == NULL)
		return;

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	/* upgrade the scb rateset to all supported network rates */
	wlc_rateset_filter((bsscfg->associated ? &bsscfg->current_bss->rateset :
		&bsscfg->target_bss->rateset), &scb->rateset,
		FALSE, WLC_RATES_CCK_OFDM, RATE_MASK, (SCB_HT_CAP(scb) != 0));
	wlc_scb_ratesel_init(wlc, scb);
}

static void
wlc_rateprobe_scan(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	struct scb *scb;
	struct scb_iter scbiter;

	/*
	 * Send ofdm rate probe to any station
	 * which does not yet have an ofdm rate in its scb rateset
	 * and has been active within the past 60 seconds.
	 */

	FOREACHSCB(wlc->scbstate, &scbiter, scb) {
		if (SCB_BSSCFG(scb) != cfg)
			continue;
		if (!IS_OFDM(scb->rateset.rates[scb->rateset.count-1]) &&
		    ((wlc->pub->now - scb->used) < 60))
			wlc_rateprobe(wlc, &scb->ea, WLC_RATEPROBE_RATE);
	}
}

bool
wlc_sendpspoll(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg)
{
	void *p;
	struct scb *scb;
	struct ether_addr *bssid = &bsscfg->BSSID;
#if defined(BCMDBG) || defined(BCMDBG_ERR)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif

	if (!(scb = wlc_scbfind(wlc, bssid))) {
		WL_ERROR(("wl%d: wlc_sendpspoll: wlc_scbfind failed, BSSID %s bandunit %d\n",
		          wlc->pub->unit, bcm_ether_ntoa(bssid, eabuf),
		          wlc->band->bandunit));
		return FALSE;
	}

	/* If a pspoll is still pending, don't send another one */
	if (scb->flags & SCB_PENDING_PSPOLL)
		return TRUE;

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub)) {
		if ((p = (void *)wlc_lmac_pspoll_get(wlc->lmac_info)) == NULL)
			return FALSE;
	}
	else
#endif
	if ((p = wlc_frame_get_ps_ctl(wlc, bssid, &bsscfg->cur_etheraddr)) == NULL)
		return FALSE;

	/* Force d11 to wake */
	wlc_set_pspoll(bsscfg, TRUE);

	/* Send pspoll and register the completion callback */
	if (wlc_sendctl(wlc, p, bsscfg->wlcif->qi, scb, TX_CTL_FIFO, 0, FALSE)) {
		WLPKTFLAG2_TYPESET(p, WLF2_TYPE_PSP);
		scb->flags |= SCB_PENDING_PSPOLL;
		return TRUE;
	}

	WL_ERROR(("wl%d: wlc_sendpspoll: wlc_sendctl failed\n", wlc->pub->unit));

	/* Failed, allow d11 to sleep */
	wlc_set_pspoll(bsscfg, FALSE);
	return FALSE;
}

static void
wlc_sendpspoll_complete(wlc_info_t *wlc, void *pkt, uint txstatus)
{
	struct scb *scb;
#if defined(BCMDBG) || defined(BCMDBG_ERR)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || BCMDBG_ERR */

	/* Is this scb still around */
	if ((scb = WLPKTTAGSCBGET(pkt)) == NULL)
		return;

	if ((txstatus & TX_STATUS_MASK) == TX_STATUS_NO_ACK) {
		wlc_bsscfg_t *cfg;

		WL_ERROR(("wl%d: wlc_pspoll_complete: no ACK from %s for PS-Poll\n",
		          wlc->pub->unit, bcm_ether_ntoa(&scb->ea, eabuf)));

		cfg = SCB_BSSCFG(scb);
		ASSERT(cfg != NULL);

		wlc_set_pspoll(cfg, FALSE);
	}

	scb->flags &= ~SCB_PENDING_PSPOLL;
}

void
wlc_pspoll_timer(void *arg)
{
	wlc_bsscfg_t *cfg = (wlc_bsscfg_t *)arg;
	wlc_info_t *wlc = cfg->wlc;
	wlc_pm_st_t *pm = cfg->pm;

	ASSERT(cfg->associated && pm->PMenabled && pm->pspoll_prd != 0);

	if (wlc->PMblocked || AS_IN_PROGRESS(wlc))
		return;

	if (pm->PMpending)
		return;

	if (wlc_sendpspoll(wlc, cfg) == FALSE) {
		WL_ERROR(("wl%d: wlc_pspoll_timer: wlc_sendpspoll() failed\n", wlc->pub->unit));
	}
}

static void
wlc_pm2_radio_shutoff_dly_timer(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t *)arg;

	wlc->pm2_radio_shutoff_pending = FALSE;
	wlc_set_wake_ctrl(wlc);
	return;
}

static void
wlc_iscan_timeout(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t *)arg;

	if (ISCAN_IN_PROGRESS(wlc) && wlc->custom_iscan_results_state != WL_SCAN_RESULTS_SUCCESS) {
		WL_INFORM(("wlc_iscan_timeout ending on chan %d, i %d\n",
		           CHSPEC_CHANNEL(wlc->iscan_chanspec_last),
		           wlc->scan_results->count));
		wlc_scan_terminate(wlc->scan, WLC_E_STATUS_PARTIAL);
	}
}
#endif /* STA */

void *
wlc_senddeauth(wlc_info_t *wlc, struct ether_addr *da, struct ether_addr *bssid,
	struct ether_addr *sa, struct scb *scb, uint16 reason_code)
{
	void *p;
	uint8 *pbody;
	uint16 *reason;
	wlc_bsscfg_t *bsscfg;

	if (scb)
		bsscfg = scb->bsscfg;
	else
		bsscfg = wlc->cfg;

	/*
	 * get a packet - deauth pkt has the following contents:
	 * 2 bytes Reason Code
	 */
	if ((p = wlc_frame_get_mgmt(wlc, FC_DEAUTH, da, sa, bssid, 2, &pbody)) == NULL)
		return NULL;

	/* fill out the deauthentication reason code */
	reason = (uint16 *)pbody;
	reason[0] = htol16(reason_code);

	if (bsscfg) {
		if (wlc_sendmgmt(wlc, p, bsscfg->wlcif->qi, scb))
			return p;

		wlc_smfstats_update(wlc, bsscfg, SMFS_TYPE_DEAUTH_TX, reason_code);
	}
	return NULL;
}

/* Look for vendor-specific IE with specified OUI and optional type */
bcm_tlv_t *
wlc_find_vendor_ie(void *tlvs, int tlvs_len, const uint8 *voui, uint8 *type, int type_len)
{
	bcm_tlv_t *ie;
	uint8 ie_len;

	ie = (bcm_tlv_t*)tlvs;

	/* make sure we are looking at a valid IE */
	if (ie == NULL ||
	    !bcm_valid_tlv(ie, tlvs_len))
		return NULL;

	/* Walk through the IEs looking for an OUI match */
	do {
		ie_len = ie->len;
		if ((ie->id == DOT11_MNG_PROPR_ID) &&
		    (ie_len >= (DOT11_OUI_LEN + type_len)) &&
		    !bcmp(ie->data, voui, DOT11_OUI_LEN))
		{
			/* compare optional type */
			if (type_len == 0 ||
			    !bcmp(&ie->data[DOT11_OUI_LEN], type, type_len)) {
				return (ie);		/* a match */
			}
		}
	} while ((ie = bcm_next_tlv(ie, &tlvs_len)) != NULL);

	return NULL;
}

#if defined(BCMDBG) || defined(WLMSG_PRPKT) || defined(WLMSG_ASSOC)
static const bcm_bit_desc_t cap_flags[] = {
	{DOT11_CAP_ESS, "ESS"},
	{DOT11_CAP_IBSS, "IBSS"},
	{DOT11_CAP_POLLABLE, "Pollable"},
	{DOT11_CAP_POLL_RQ, "PollReq"},
	{DOT11_CAP_PRIVACY, "WEP"},
	{DOT11_CAP_SHORT, "ShortPre"},
	{DOT11_CAP_PBCC, "PBCC"},
	{DOT11_CAP_AGILITY, "Agility"},
	{DOT11_CAP_SHORTSLOT, "ShortSlot"},
	{DOT11_CAP_CCK_OFDM, "CCK-OFDM"},
	{0, NULL}
};

static void
wlc_print_bcn_prb(uint8 *frame, int len)
{
	struct dot11_bcn_prb *fixed;
	uint16 *sp;
	uint8 *cp;
	uint32 t_hi, t_lo;
	uint16 cap;
	char flagstr[128];
	char hexbuf[65];
	static const char *id_names[] = {
		"SSID",
		"Rates",
		"FH Params",
		"DS Params",
		"CF Params",
		"TIM",
		"IBSS Params"
	};

	ASSERT(ISALIGNED((uintptr)frame, sizeof(uint16)));

	wlc_print_dot11hdr(frame, len);

	fixed = (struct dot11_bcn_prb *)(frame + D11_PHY_HDR_LEN + DOT11_MAC_HDR_LEN);

	sp = (uint16*)fixed;
	t_lo = ltoh16(sp[0]) | ltoh16(sp[1]) << NBITS(uint16);
	t_hi = ltoh16(sp[2]) | ltoh16(sp[3]) << NBITS(uint16);
	if (t_hi) {
		printf("timestamp: %X:%08X\n", t_hi, t_lo);
	} else {
		printf("timestamp: %08X\n", t_lo);
	}
	printf("beacon interval: %d\n", ltoh16(fixed->beacon_interval));

	cap = ltoh16(fixed->capability);

	bcm_format_flags(cap_flags, cap, flagstr, 128);

	if (flagstr[0] != '\0') {
		printf("capabilities: %04x (%s)\n", cap, flagstr);
	} else {
		printf("capabilities: %04x\n", cap);
	}

	cp = (uint8*)&fixed[1];
	while (cp - frame < len) {
		const char* name = "";
		char* valstr = NULL;
		char ssidbuf[SSID_FMT_BUF_LEN + 2];

		if (cp[0] < 7)
			name = id_names[cp[0]];
		else if (cp[0] == DOT11_MNG_CHALLENGE_ID)
			name = "Challenge text";
		else if (cp[0] == DOT11_MNG_ERP_ID)
			name = "ERP Info";
		else if (cp[0] == DOT11_MNG_NONERP_ID)
			name = "Legacy ERP Info";
		else if (cp[0] == DOT11_MNG_EXT_RATES_ID)
			name = "Extended Rates";
		else if (cp[0] == DOT11_MNG_PROPR_ID)
			name = "Proprietary IE";

		if (cp[0] == DOT11_MNG_SSID_ID) {
			int i = wlc_format_ssid(ssidbuf+1, cp+2, cp[1]);
			ssidbuf[0] = '\"';
			ssidbuf[i+1] = '\"';
			ssidbuf[i+2] = '\0';
			valstr = ssidbuf;
		} else if (cp[1] <= 32) {
			bcm_format_hex(hexbuf, cp+2, cp[1]);
			valstr = hexbuf;
		}

		if (valstr != NULL) {
			printf("ID %d %s [%d]: %s\n", cp[0], name, cp[1], valstr);
		} else {
			printf("ID %d %s [%d]:\n", cp[0], name, cp[1]);
			prhex(NULL, cp+2, cp[1]);
		}

		cp += 2 + cp[1];
	}
	printf("\n");
}
#endif /* BCMDBG || WLMSG_PRPKT || WLMSG_ASSOC */

#if ((defined(BCMDBG) || defined(WLMSG_PRPKT)) && defined(STA)) || ((defined(BCMDBG) || \
	defined(BCMDBG_DUMP)) && !defined(WLLMAC_ONLY))
static const char*
wlc_lookup_name(const wlc_id_name_table_t tbl, int id)
{
	const struct wlc_id_name_entry *elt = tbl;
	static char unknown[16];

	for (elt = tbl; elt->name != NULL; elt++) {
		if (id == elt->id)
			return elt->name;
	}

	snprintf(unknown, sizeof(unknown), "ID:%d", id);

	return unknown;
}
#endif /* ((BCMDBG || WLMSG_PRPKT) && STA) || ((BCMDBG || BCMDBG_DUMP) && !WLLMAC_ONLY) */

#if defined(BCMDBG) || defined(BCMDBG_DUMP)
void
wlc_dump_ie(wlc_info_t *wlc, bcm_tlv_t *ie, struct bcmstrbuf *b)
{
	const char* name = wlc_lookup_name(dot11_ie_names, ie->id);
	int j;

	bcm_bprintf(b, "ID: %d %s [%d]: ", ie->id, name, ie->len);
	for (j = 0; j < ie->len; j ++)
		bcm_bprintf(b, "%02x", ie->data[j]);
}
#endif /* BCMDBG || BCMDBG_DUMP */

#ifdef STA
#if defined(BCMDBG) || defined(WLMSG_PRPKT)
void
wlc_print_ies(wlc_info_t *wlc, uint8 *ies, uint ies_len)
{
	bcm_tlv_t *ie;
	char hexbuf[65];
#ifdef BCMDBG
	uint ies_len_save = ies_len;
	uint8 *ies_save = ies;

	printf("wlc_print_ies: ies_len=%d\n", ies_len_save);
#endif /* BCMDBG */

	ie = (bcm_tlv_t*)ies;
	while (ies_len >= 2) {
		const char* name;
		char* valstr = NULL;
		uint8 id = ie->id;
		char ssidbuf[SSID_FMT_BUF_LEN + 2];

		if (ies_len < (uint)(ie->len + 2)) {
#ifdef BCMDBG
			prhex("wlc_print_ies: All TLVs IE data", ies_save, ies_len_save);
#endif /* BCMDBG */
			break;
		}

		name = wlc_lookup_name(dot11_ie_names, id);

		if (id == DOT11_MNG_SSID_ID) {
			int i = wlc_format_ssid(ssidbuf+1, ie->data, ie->len);
			ssidbuf[0] = '\"';
			ssidbuf[i+1] = '\"';
			ssidbuf[i+2] = '\0';
			valstr = ssidbuf;
		} else if (ie->len <= 32) {
			bcm_format_hex(hexbuf, ie->data, ie->len);
			valstr = hexbuf;
		}

		if (valstr != NULL) {
			printf("wl%d: ID %d %s [%d]: %s\n",
			       wlc->pub->unit, id, name, ie->len, valstr);
		} else {
			printf("wl%d: ID %d %s [%d]:\n",
			       wlc->pub->unit, id, name, ie->len);
			prhex(NULL, ie->data, ie->len);
		}

		ies += (2 + ie->len);
		ies_len -= (2 + ie->len);
		ie = (bcm_tlv_t*)ies;
	}

	if (ies_len > 0) {
		printf("wl%d: Unknown bytes at end of IEs [%d bytes]\n", wlc->pub->unit, ies_len);
		prhex(NULL, ies, ies_len);
	}
}

static void
wlc_print_assoc(wlc_info_t *wlc, struct dot11_management_header *mng, int len)
{
	bool is_assoc;
	uint8* body;
	uint body_len;
	uint8 *ies;
	uint ies_len;
	uint16 fc;
	uint16 cap;
	uint16 listen_interval;
	struct ether_addr *current_ap = NULL;
	char flagstr[128];

	ASSERT(ISALIGNED((uintptr)mng, sizeof(uint16)));

	if (len < DOT11_MGMT_HDR_LEN) {
		printf("wl%d: 802.11 frame too short to be a management frame\n", wlc->pub->unit);
		printf("wl%d: packet [%d bytes]:\n", wlc->pub->unit, len);
		prhex(NULL, (uint8*)mng, len);
		return;
	}

	fc = ltoh16(mng->fc);

	body_len = len - DOT11_MGMT_HDR_LEN;
	body = (uint8*)((uint8*)mng + DOT11_MGMT_HDR_LEN);

	if ((fc & FC_KIND_MASK) == FC_ASSOC_REQ) {
		is_assoc = TRUE;
	} else if ((fc & FC_KIND_MASK) == FC_REASSOC_REQ) {
		is_assoc = FALSE;
	} else {
		printf("wl%d: 802.11 frame was not Assoc Req or Reassoc Req\n", wlc->pub->unit);
		printf("wl%d: frame body [%d bytes]:\n", wlc->pub->unit, body_len);
		prhex(NULL, body, body_len);
		return;
	}

	if ((is_assoc && body_len < DOT11_ASSOC_REQ_FIXED_LEN) ||
	    (!is_assoc && body_len < DOT11_REASSOC_REQ_FIXED_LEN)) {
		printf("wl%d: 802.11 %s Req body too short [%d bytes]:\n", wlc->pub->unit,
		       is_assoc?"Assoc":"Reassoc", body_len);
		prhex(NULL, body, body_len);
		return;
	}

	if (is_assoc) {
		struct dot11_assoc_req *assoc;
		assoc = (struct dot11_assoc_req *)body;
		cap = ltoh16(assoc->capability);
		listen_interval = ltoh16(assoc->listen);

		ies = body + DOT11_ASSOC_REQ_FIXED_LEN;
		ies_len = body_len - DOT11_ASSOC_REQ_FIXED_LEN;
	} else {
		struct dot11_reassoc_req *reassoc;
		reassoc = (struct dot11_reassoc_req *)body;
		cap = ltoh16(reassoc->capability);
		listen_interval = ltoh16(reassoc->listen);
		current_ap = &reassoc->ap;

		ies = body + DOT11_REASSOC_REQ_FIXED_LEN;
		ies_len = body_len - DOT11_REASSOC_REQ_FIXED_LEN;
	}

	bcm_format_flags(cap_flags, cap, flagstr, 128);

	if (flagstr[0] != '\0') {
		printf("wl%d: capabilities: %04x (%s)\n", wlc->pub->unit, cap, flagstr);
	} else {
		printf("wl%d: capabilities: %04x\n", wlc->pub->unit, cap);
	}

	printf("wl%d: listen interval: %u BIs\n", wlc->pub->unit, listen_interval);

	if (current_ap) {
		char eabuf[ETHER_ADDR_STR_LEN];
		printf("wl%d: current ap: %s\n", wlc->pub->unit, bcm_ether_ntoa(current_ap, eabuf));
	}

	wlc_print_ies(wlc, ies, ies_len);

	printf("\n");
}
#endif /* BCMDBG || WLMSG_PRPKT */

static void
wlc_rsn_build_ie(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, struct rsn_parms *rsn, void *pmcast)
{
	wpa_suite_mcast_t *mcast;
	wpa_suite_ucast_t *ucast;
	wpa_suite_auth_key_mgmt_t *mgmt;
	uint8 *cap;

	/* copy multicast cipher */
	mcast = (wpa_suite_mcast_t *)pmcast;
	mcast->type = (uint8)rsn->multicast;

	/* select unicast cipher */
	ucast = (wpa_suite_ucast_t *)&mcast[1];
	ucast->list[0].type = WPA_CIPHER_NONE;
	if (WSEC_AES_ENABLED(bsscfg->wsec) && !UCAST_NONE(rsn))
		ucast->list[0].type = WPA_CIPHER_AES_CCM;
	else if (!WSEC_AES_ENABLED(bsscfg->wsec) &&
		WSEC_TKIP_ENABLED(bsscfg->wsec) && !UCAST_NONE(rsn))
		ucast->list[0].type = WPA_CIPHER_TKIP;

	/* copy authenticated key management */
	mgmt = (wpa_suite_auth_key_mgmt_t *)&ucast->list[1];
	if (bsscfg->WPA_auth == WPA_AUTH_UNSPECIFIED)
		mgmt->list[0].type = RSN_AKM_UNSPECIFIED;
	else if (bsscfg->WPA_auth == WPA_AUTH_PSK)
		mgmt->list[0].type = RSN_AKM_PSK;
	else if (bsscfg->WPA_auth == WPA2_AUTH_UNSPECIFIED) {
#if defined(WLFBT)
		if (WLFBT_ENAB(wlc->pub) && (rsn->flags & RSN_FLAGS_FBT))
			mgmt->list[0].type = RSN_AKM_FBT_1X;
		else
#endif
#if defined(MFP)
		if ((bsscfg->wsec & MFP_CAPABLE) && (rsn->flags & RSN_FLAGS_MFPC))
			mgmt->list[0].type = RSN_AKM_MFP_1X;
		/* special test mode: ignore AP settings */
		else if (bsscfg->wsec & MFP_SHA256)
			mgmt->list[0].type = RSN_AKM_MFP_1X;
		else
#endif /* MFP */
		mgmt->list[0].type = RSN_AKM_UNSPECIFIED;
	}
	else if (bsscfg->WPA_auth == WPA2_AUTH_PSK) {
#ifdef WLFBT
		if (WLFBT_ENAB(wlc->pub) && (rsn->flags & RSN_FLAGS_FBT)) {
			mgmt->list[0].type = RSN_AKM_FBT_PSK;
		} else
#endif
#ifdef MFP
		if ((bsscfg->wsec & MFP_CAPABLE) && (rsn->flags & RSN_FLAGS_MFPC))
			mgmt->list[0].type = RSN_AKM_MFP_PSK;
		/* special test mode: ignore AP settings */
		else if (bsscfg->wsec & MFP_SHA256)
			mgmt->list[0].type = RSN_AKM_MFP_PSK;
		else
#endif /* MFP */
			mgmt->list[0].type = RSN_AKM_PSK;
	}

	/* WPA capabilities */
	cap = (uint8 *)&mgmt->list[1];
	wlc_wpa_cap(wlc, bsscfg, cap, WPA_CAP_LEN);

}

void *
wlc_sendassocreq(wlc_info_t *wlc, wlc_bss_info_t *bi, struct scb *scb, bool reassoc)
{
	uint len, assoc_req_len, ssid_len, WPA_len, parse_len;
	wlc_rateset_t sup_rates, ext_rates;
	void *pkt = NULL;
	uint8 *pbody, *elt, *parse, *pkt_hdr, *bufend;
	struct dot11_assoc_req *assoc;
	uint16 type;
	uchar *ssid;
	wpa_ie_fixed_t *wpa_ie = NULL;
	bcm_tlv_t *wpa2_ie = NULL;
	uint8 *pmkid[MAXPMKID];
	uint npmkid = 0;
	bcm_tlv_t *ie;
	bcm_tlv_t *sup_rates_ovrd, *ext_rates_ovrd;
	dot11_power_cap_t pwr_cap;
	uint16 WPA_auth;
	wlc_bsscfg_t *bsscfg;
	wlc_assoc_t *as;
	uint8 ext_cap[DOT11_EXTCAP_LEN_MAX];
	uint8 ext_cap_len = 0;
	bzero(ext_cap, sizeof(ext_cap));

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	ASSERT(bsscfg != NULL);

	as = bsscfg->assoc;

	/* get a packet
	 * (Re)Assoc Request packet has the following contents:
	 * 2 bytes Capability
	 * 2 bytes Listen Interval
	 * 6 bytes current BSSID (Reassoc only)
	 * InfoElt SSID
	 * InfoElt Supported rates
	 * InfoElt Power Capability (11h)
	 * InfoElt Supported channels (11h)
	 * InfoElt Extended Supported rates (11g)
	 * InfoElt BRCM proprietary
	 * InfoElt BRCM N Capability
	 * InfoElt WME
	 */

	/* SSID */
	ie = bcm_parse_tlvs(as->ie, as->ie_len, DOT11_MNG_SSID_ID);
	if (ie) {
		ssid = ie->data;
		ssid_len = ie->len;
	} else {
		ssid = bi->SSID;
		ssid_len = bi->SSID_len;
	}

	/* Supported Rates and Extended Supported Rates */

	/* We may have 1 or 2 ratesets.
	 * One or both may be overridden by a configured set of info elements.
	 */
	bzero(&sup_rates, sizeof(wlc_rateset_t));
	bzero(&ext_rates, sizeof(wlc_rateset_t));
	sup_rates_ovrd = bcm_parse_tlvs(as->ie, as->ie_len, DOT11_MNG_RATES_ID);
	ext_rates_ovrd = bcm_parse_tlvs(as->ie, as->ie_len,
		DOT11_MNG_EXT_RATES_ID);

	/* Supported Rates override */
	if (sup_rates_ovrd) {
		/* subtract the length for the elt from the total and
		 * we will add it back in below if needed
		 */
		if (sup_rates_ovrd->len <= WLC_NUMRATES) {
			sup_rates.count = sup_rates_ovrd->len;
			bcopy(sup_rates_ovrd->data, sup_rates.rates, sup_rates.count);
		} else {
			/* Supported Rates override is invalid */
			sup_rates_ovrd = NULL;
		}
	}

	/* Extended Supported Rates override */
	if (ext_rates_ovrd) {
		/* subtract the length for the elt from the total and
		 * we will add it back in below if needed
		 */
		if (ext_rates_ovrd->len <= WLC_NUMRATES) {
			ext_rates.count = ext_rates_ovrd->len;
			bcopy(ext_rates_ovrd->data, ext_rates.rates, ext_rates.count);
		} else {
			/* Extended Supported Rates override is invalid */
			ext_rates_ovrd = NULL;
		}
	}

	if ((bi->flags & WLC_BSS_54G) &&
	    (wlc->band->gmode != GMODE_LEGACY_B)) {
		/* Legacy 54g AP, so ignore rates overrides and put
		 * all rates in the supported rates elt
		 */
		sup_rates.count = wlc->band->hw_rateset.count;
		bcopy(wlc->band->hw_rateset.rates, sup_rates.rates, sup_rates.count);
#ifdef WLP2P
		if (BSS_P2P_ENAB(wlc, bsscfg))
			wlc_p2p_rateset_filter(wlc->p2p, bsscfg, &sup_rates);
#endif
		ext_rates.count = 0;
	} else {
		/* create the ratesets with overrides taken into account
		 * target rateset has been filtered against our hw_rateset
		 */
		wlc_rateset_elts(wlc, bsscfg, &bi->rateset, &sup_rates, &ext_rates);
	}

	/* Default WPA */
	WPA_auth = bsscfg->WPA_auth;
	WPA_len = 0;

	parse = as->ie;
	parse_len = as->ie_len;
	if ((wpa_ie = bcm_find_wpaie(parse, parse_len)) != NULL) {
		WPA_len = wpa_ie->length;
	} else if ((wpa2_ie = bcm_parse_tlvs(parse, parse_len,
		DOT11_MNG_RSN_ID)) != NULL) {
		WPA_len = wpa2_ie->len;
	} else if (IS_WPA2_AUTH(WPA_auth) && WSEC_ENABLED(bsscfg->wsec)) {
		WPA_len = WPA2_info_element[TLV_LEN_OFF];

		/* PMKID in cache? */
		if (WPA_auth == WPA2_AUTH_UNSPECIFIED) {
			uint i;

			for (i = 0; i < bsscfg->npmkid; i++) {
				if (bcmp((void *)&bi->BSSID,
				         (void *)&bsscfg->pmkid[i].BSSID, ETHER_ADDR_LEN) == 0) {
#ifdef BCMDBG
					if (WL_WSEC_ON()) {
						char eabuf[ETHER_ADDR_STR_LEN];
						uint j;

						WL_WSEC(("wl%d: PMKID cache hit: %s = ",
							wlc->pub->unit,
							bcm_ether_ntoa(&bi->BSSID,
							eabuf)));
						for (j = 0; j < WPA2_PMKID_LEN; j++)
							WL_WSEC(("%02x ",
								bsscfg->pmkid[i].PMKID[j]));
						WL_WSEC(("\n"));
					}
#endif /* BCMDBG */
					pmkid[npmkid++] = bsscfg->pmkid[i].PMKID;
				}
			}
#ifdef BCMDBG
			if (WL_WSEC_ON()) {
				if (npmkid == 0)
					WL_WSEC(("wl%d: PMKID cache miss\n", wlc->pub->unit));
			}
#endif /* BCMDBG */
		}
	} else if (WPA_auth != WPA_AUTH_DISABLED && WSEC_ENABLED(bsscfg->wsec)) {
		WPA_len = WPA_info_element[TLV_LEN_OFF];
	}

	/* get a control packet */
	type = (uint16)(reassoc ? FC_REASSOC_REQ : FC_ASSOC_REQ);
	if ((pkt = wlc_frame_get_mgmt(wlc, type, &bi->BSSID, &bsscfg->cur_etheraddr, &bi->BSSID,
	                              ETHER_MAX_LEN, &pbody)) == NULL) {
		wlc_assocreq_complete(wlc, TX_STATUS_NO_ACK, (void *)(uintptr)bsscfg->ID);
		return NULL;
	}
	/* save bufend location */
	bufend = pbody + ETHER_MAX_LEN;

	pkt_hdr = pbody - DOT11_MGMT_HDR_LEN;	/* point to beginning of packet */

	/* fill out the association request body */
	assoc = (struct dot11_assoc_req *) pbody;

	/* Capability information */
	if (as->capability)
		assoc->capability = htol16(as->capability);
	else {
		assoc->capability = DOT11_CAP_ESS;
		if (WSEC_ENABLED(bsscfg->wsec))
			assoc->capability |= DOT11_CAP_PRIVACY;
		if (BAND_2G(wlc->band->bandtype) &&
		    ((bsscfg->PLCPHdr_override == WLC_PLCP_SHORT) ||
		     (bsscfg->PLCPHdr_override == WLC_PLCP_AUTO)))
			assoc->capability |= DOT11_CAP_SHORT;
		/* Nokia A032 AP (11b-only AP) rejects association req if
		 * capability - [short slot time, spectrum management] bit is set.
		 * The solution for interoperability
		 * with such AP is to
		 * (1) set DOT11_CAP_SHORTSLOT only for gmode-ofdm case
		 * (2) set DOT11_CAP_SPECTRUM only if beacon has it set.
		 */
		if (wlc->band->gmode &&
		    wlc_rateset_isofdm(bi->rateset.count, bi->rateset.rates) &&
		    (wlc->shortslot_override != WLC_SHORTSLOT_OFF))
			assoc->capability |= DOT11_CAP_SHORTSLOT;
		if (BSS_WL11H_ENAB(wlc, bsscfg) &&
		    (bi->capability & DOT11_CAP_SPECTRUM))
			assoc->capability |= DOT11_CAP_SPECTRUM;
		if (WL11K_ENAB(wlc->pub))
			assoc->capability |= DOT11_CAP_RRM;

		assoc->capability = htol16(assoc->capability);
	}

	/* Listen interval */
	assoc->listen = htol16(as->listen);


	pbody = (uint8*)&assoc[1];

	/* Current AP address */
	if (reassoc) {
		if (!ETHER_ISNULLADDR(&as->bssid))
			bcopy(&as->bssid, pbody, ETHER_ADDR_LEN);
		else
			bcopy(&bsscfg->prev_BSSID, pbody, ETHER_ADDR_LEN);
		pbody += ETHER_ADDR_LEN;
	}

	/* SSID */
	pbody = wlc_write_info_elt(pbody, DOT11_MNG_SSID_ID, ssid_len, ssid);

	/* Supported Rates */
	pbody = wlc_write_info_elt(pbody, DOT11_MNG_RATES_ID, sup_rates.count, sup_rates.rates);

	/* 802.11h supported channels IE */
	if (BSS_WL11H_ENAB(wlc, bsscfg)) {
		uint8 min_pwr, max_pwr;

		/* Power Capability */
		wlc_phy_txpower_sromlimit(wlc->band->pi, wf_chspec_ctlchan(bi->chanspec),
			&min_pwr, &max_pwr, -1);

		pwr_cap.min = (int8)min_pwr / WLC_TXPWR_DB_FACTOR; /* convert .25 dBm to dBm */
		pwr_cap.max = (int8)max_pwr / WLC_TXPWR_DB_FACTOR; /* convert .25 dBm to dBm */
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_PWR_CAP_ID, sizeof(pwr_cap), &pwr_cap);

#ifdef WL11H
		/* Supported Channels */
		pbody = wlc_write_sup_chan_ie(wlc, pbody);
#endif
	}

#ifdef WLBTAMP
	/* Include an 802.11e QoS Capability info element if the peer supports 802.11e */
	if (BSS_BTA_ENAB(wlc, bsscfg) && wlc_bta_qos(wlc->bta) && (bi->flags & WLC_BSS_11E)) {
		qos_cap_ie_t qos_cap_ie;

		WL_BTA(("wl%d: wlc_sendassocreq: adding QoS Capability IE\n", wlc->pub->unit));

		qos_cap_ie.qosinfo = 0;
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_QOS_CAP_ID,
		     sizeof(qos_cap_ie), (char*)&qos_cap_ie);
	}
#endif /* WLBTAMP */

	/* WPA2 IE */
	if (WPA_len) {
		if (
#if defined(WLFBT)
			(!(WLFBT_ENAB(wlc->pub) &&
				(bi->wpa2.flags & RSN_FLAGS_FBT) && reassoc)) &&
#endif /* WLFBT */
			(wpa2_ie)) {
			/* copy WPA2 info element */
			pbody = wlc_copy_info_elt(pbody, wpa2_ie);
		} else if (IS_WPA2_AUTH(WPA_auth)) {
			/* copy WPA2 info element template */
			wpa2_ie = (bcm_tlv_t *)pbody;
			pbody = wlc_copy_info_elt(pbody, WPA2_info_element);

			/* fill in cipher suites, AKM, etc. */
			wlc_rsn_build_ie(wlc, bsscfg, &(bi->wpa2),
			                 &wpa2_ie->data[WPA2_VERSION_LEN]);
#if defined(WLFBT)
			if (WLFBT_ENAB(wlc->pub) &&
				(bi->wpa2.flags & RSN_FLAGS_FBT) && reassoc) {
				WL_WSEC(("FBT override preauth\n"));
				npmkid = 1;
				pmkid[0] = wlc_sup_ft_pmkr1name(bsscfg->sup);
			}
#endif /* WLFBT */

			/* use cached PMKIDs */
			if (npmkid) {
				wpa_pmkid_list_t *pmkid_list;
				uint i;

				pmkid_list =
					(wpa_pmkid_list_t *)&wpa2_ie->data[wpa2_ie->len];

				/* fill in PMKID count */
				pmkid_list->count.low = (uint8)npmkid;
				pmkid_list->count.high = (uint8)(npmkid >> 8);
				wpa2_ie->len += 2;
				pbody += 2;

				/* fill in PMKID list */
				for (i = 0; i < npmkid; i++) {
#ifdef BCMDBG
					if (WL_WSEC_ON()) {
						uint j;

						WL_WSEC(("wl%d: try PMKID: ", wlc->pub->unit));
						for (j = 0; j < WPA2_PMKID_LEN; j++)
							WL_WSEC(("%02x ", pmkid[i][j]));
						WL_WSEC(("\n"));
					}
#endif /* BCMDBG */

					bcopy(pmkid[i], &pmkid_list->list[i], WPA2_PMKID_LEN);
					wpa2_ie->len += WPA2_PMKID_LEN;
					pbody += WPA2_PMKID_LEN;
				}
			}
		}
	}

	/* Extended Supported Rates */
	if (ext_rates.count > 0)
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_EXT_RATES_ID, ext_rates.count,
			ext_rates.rates);

#if defined(BCMSUP_PSK) && defined(WLFBT)
	if (WLFBT_ENAB(wlc->pub) && (bi->wpa2.flags & RSN_FLAGS_FBT)) {
		uint8 *md_parse;
		uint md_len;
		bcm_tlv_t *md_ie;

		md_len = bi->bcn_prb_len - sizeof(struct dot11_bcn_prb);
		md_parse = (uint8 *)bi->bcn_prb + sizeof(struct dot11_bcn_prb);
		if ((md_ie = bcm_parse_tlvs(md_parse, md_len, DOT11_MNG_MDIE_ID)) != NULL) {
			pbody = wlc_copy_info_elt(pbody, md_ie);
		}

		if (reassoc) {
			pbody = wlc_sup_ft_assocreq(bsscfg->sup, pbody, md_ie, wpa2_ie);
			WL_WSEC(("FBT reassoc req\n"));
		}
	}
#endif /* BCMSUP_PSK && WLFBT */

	/* Merge in additional elements */
	for (elt = as->ie;
		elt && (elt < &as->ie[as->ie_len]);
		elt += 2 + elt[1]) {
		/* Sanity check */
		if ((uint)(elt - as->ie + 2 + elt[1]) > as->ie_len)
			break;

		/* skip the wpa_ie if present since we add separately */
		if ((uint8*)wpa_ie == elt)
			break;

		switch (elt[0]) {
		case DOT11_MNG_SSID_ID:
		case DOT11_MNG_RATES_ID:
		case DOT11_MNG_RSN_ID:
			/* Already added above */
			break;
		default:
			bcopy(elt, pbody, 2 + elt[1]);
			pbody += TLV_HDR_LEN + elt[1];
			break;
		}
	}

#if defined(WLFBT)
	if (WLFBT_ENAB(wlc->pub))
	{
		setbit(ext_cap, DOT11_EXT_CAP_BSS_TRANSITION_MGMT);
		if (ext_cap_len < DOT11_EXTCAP_LEN_BT)
			ext_cap_len = DOT11_EXTCAP_LEN_BT;
	}
#endif

#ifdef WL11U
	if (bsscfg->iw_ie) {
		setbit(ext_cap, DOT11_EXT_CAP_IW);
		if (ext_cap_len < DOT11_EXTCAP_LEN_IW)
			ext_cap_len = DOT11_EXTCAP_LEN_IW;
	}
#endif /* WL11U */

	/* HT capability IE, mcs set is merge of our supported rates and AP's rates */
	if (N_ENAB(wlc->pub) && SCB_HT_CAP(scb)) {
		ht_cap_ie_t cap_ie;
#ifdef NOT_YET
		uint8 rclist[MAXRCLISTSIZE], rclen = 0;
		bzero(rclist, MAXRCLISTSIZE);
		rclen = wlc_get_regclass_list(wlc->cmi, rclist, MAXRCLISTSIZE,
			bi->chanspec, TRUE);
#endif /* NOT_YET */
		wlc_write_ht_cap_ie(bsscfg, &cap_ie,
		                    &wlc->band->hw_rateset.mcs[0],
		                    BAND_2G(wlc->band->bandtype));
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_HT_CAP, HT_CAP_IE_LEN, &cap_ie);
#ifdef NOT_YET
		if (rclen)
			pbody = wlc_write_info_elt(pbody, DOT11_MNG_REGCLASS_ID, rclen, rclist);
#endif /* NOT_YET */
	}

	if (ext_cap_len) {
		/* extended capabilities */
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_EXT_CAP_ID, ext_cap_len, ext_cap);
	}

#ifdef WL11K
	if (WL11K_ENAB(wlc->pub)) {
		dot11_rrm_cap_ie_t rrm_ie;
		bzero(&rrm_ie, DOT11_RRM_CAP_LEN);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_LINK);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_NEIGHBOR_REPORT);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_BCN_ACTIVE);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_BCN_PASSIVE);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_AP_CHANREP);
		setbit(rrm_ie.cap, DOT11_RRM_CAP_BCN_TABLE);
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_RRM_CAP_ID, DOT11_RRM_CAP_LEN, &rrm_ie);
	}
#endif

#ifdef WL11U
	if (bsscfg->iw_ie) {
		/* 11u interworking */
		pbody = wlc_copy_info_elt(pbody, bsscfg->iw_ie);
	}
#endif /* WL11U */

	/* BRCM proprietary elt */
	if (bsscfg->brcm_ie[TLV_LEN_OFF] > 0)
		pbody = wlc_copy_info_elt(pbody, bsscfg->brcm_ie);

	/* HT capability IE, mcs set is merge of our supported rates and AP's rates */
	if (N_ENAB(wlc->pub) && SCB_HT_CAP(scb)) {
		ht_cap_ie_t cap_ie;
		wlc_write_ht_cap_ie(bsscfg, &cap_ie,
		                    &wlc->band->hw_rateset.mcs[0],
		                    BAND_2G(wlc->band->bandtype));
		pbody = wlc_write_brcm_ht_cap_ie(wlc, pbody, BUFLEN(pbody, bufend), &cap_ie);
	}

	/* Include a WME info element if the AP supports WME */
	if (BSS_WME_ENAB(wlc, bsscfg) && (bi->flags & WLC_BSS_WME)) {
		wme_ie_t wme_ie;
		ASSERT(sizeof(wme_ie) == WME_IE_LEN);
		bcopy(WME_OUI, (char*)&wme_ie.oui[0], DOT11_OUI_LEN);
		wme_ie.type = WME_TYPE;
		wme_ie.subtype = WME_SUBTYPE_IE;
		wme_ie.version = WME_VER;
		/* Send QoS Info in request only if both STA and AP support APSD */
		wme_ie.qosinfo = (wlc->wme_apsd && (bi->wme_qosinfo & WME_QI_AP_APSD_MASK) ?
		                  wlc->apsd_sta_qosinfo : 0);
		pbody = wlc_write_info_elt(pbody, DOT11_MNG_PROPR_ID,
		                           sizeof(wme_ie), (char*)&wme_ie);
	}

	if (WPA_len) {
		/* copy WPA info element */
		if (wpa_ie) {
			pbody = wlc_copy_info_elt(pbody, wpa_ie);
		} else if (!IS_WPA2_AUTH(WPA_auth)) {
			/* copy WPA info element template */
			wpa_ie = (wpa_ie_fixed_t *)pbody;
			pbody = wlc_copy_info_elt(pbody, WPA_info_element);

			/* fill in cipher suites, AKM, etc. */
			wlc_rsn_build_ie(wlc, bsscfg, &(bi->wpa), &wpa_ie[1]);
		}
	}

	/* Update SCB crypto based on highest WSEC settings */
	if (WSEC_AES_ENABLED(bsscfg->wsec))
		scb->wsec = AES_ENABLED;
	else if (WSEC_TKIP_ENABLED(bsscfg->wsec))
		scb->wsec = TKIP_ENABLED;
	else if (WSEC_WEP_ENABLED(bsscfg->wsec))
		scb->wsec = WEP_ENABLED;
	else
		scb->wsec = 0;

	/* Based on wsec for the link, update AMPDU feature in the transmission path
	 * By spec, 11n device can send AMPDU only with Open or CCMP crypto
	 */
	if (N_ENAB(wlc->pub)) {
		if (((scb->wsec == WEP_ENABLED) || (scb->wsec == TKIP_ENABLED)) &&
		    SCB_AMPDU(scb))
			wlc_txmod_unconfig(wlc, scb, TXMOD_AMPDU);
		else if (SCB_AMPDU(scb)) {
			wlc_txmod_config(wlc, scb, TXMOD_AMPDU);
			/* only turn off ampdu when full TDM is used. */
			if (WL_BTC_FULLTDM == wlc_btc_mode_get(wlc)) {
				if (wlc->btch->bth_period &&
					wlc->btch->bth_period < BT_AMPDU_THRESH) {
					/* wlc_txmod_config() will make both
					 *  Tx ON, which is NOT desired if BT in ON
					 */
#ifdef WLAMPDU
					wlc_ampdu_agg_state_update_tx(wlc, OFF);
#endif /* WLAMPDU */
				}
			}
#ifdef MFP
			else if (SCB_MFP(scb)) {
				wlc_ampdu_agg_state_update_tx(wlc, OFF);
			}
#endif
		}
	}


	/* add vendor's ies at end of pkt */
	pbody = wlc_vndr_ie_write(bsscfg, pbody, BUFLEN(pbody, bufend), VNDR_IE_ASSOCREQ_FLAG);

	len = (uint)(pbody - pkt_hdr);	/* 802.11 packet length */
	ASSERT(len <= ETHER_MAX_LEN);
	PKTSETLEN(wlc->osh, pkt, len);	/* adjust the packet length */

	/* Save a copy of the last association request */
	if (as->req)
		MFREE(wlc->osh, as->req, as->req_len);

	assoc_req_len = len - (uint)((uint8 *)assoc - pkt_hdr);
	if (!(as->req = MALLOC(wlc->osh, assoc_req_len)))
		WL_ERROR(("wl%d: wlc_sendassocreq: out of memory, malloced %d bytes\n",
			wlc->pub->unit, MALLOCED(wlc->osh)));
	else {
		as->req_len = assoc_req_len;
		as->req_is_reassoc = reassoc;
		bcopy((char*)assoc, (char*)as->req, assoc_req_len);
	}

#if defined(BCMDBG) || defined(WLMSG_PRPKT)
	WL_ASSOC(("wl%d: JOIN: sending %s REQ ...\n",
	            WLCWLUNIT(wlc), (reassoc ? "REASSOC" : "ASSOC")));

	if (WL_ASSOC_ON())
		wlc_print_assoc(wlc, (struct dot11_management_header *)pkt_hdr, len);
#endif

#ifdef BCMDBG
	WL_ERROR(("wl%d: wlc_sendassocreq: include 802.11 mgmt hdr and (re)assoc hdr, len %d\n",
		wlc->pub->unit, PKTLEN(wlc->osh, pkt)));
#endif

	/* Send using the active_queue instead of the bsscfg queue. When roaming, the bsscfg queue
	 * will be associated with the current associated channel, not the roam target channel.
	 */
	if (wlc_queue_80211_frag(wlc, pkt, wlc->active_queue, scb,
	                         ((bi->capability & DOT11_CAP_SHORT) != 0), NULL, 0))
		return pkt;

	return NULL;
}

/* Disable IBSS operation in hardware */
void
wlc_ibss_disable(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	WL_TRACE(("wl%d: wlc_ibss_disable\n", wlc->pub->unit));

	/* Switch to BSS STA mode so that MAC will not send IBSS Beacons
	 * or respond to probe requests
	 */
	wlc->bcnmisc_ibss = FALSE;
	wlc_mac_bcn_promisc(wlc);
	wlc_mctrl(wlc, MCTL_INFRA, MCTL_INFRA);

	/* disable IBSS security mode */
	if (IBSS_PEER_GROUP_KEY_ENAB(wlc->pub))
		wlc_mhf(wlc, MHF4, MHF4_IBSS_SEC, 0, WLC_BAND_ALL);
}

/* Enable IBSS operations in hardware */
void
wlc_ibss_enable(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;

	WL_TRACE(("wl%d: wlc_ibss_enable\n", wlc->pub->unit));

	/* Switch back to IBSS STA mode */
	wlc->bcnmisc_ibss = TRUE;
	wlc_mac_bcn_promisc(wlc);

	ASSERT(wlc_valid_beacon_phytxctl(wlc));

	wlc_mctrl(wlc, MCTL_INFRA, 0);

	/* disable IBSS security mode */
	if (IBSS_PEER_GROUP_KEY_ENAB(wlc->pub))
		wlc_mhf(wlc, MHF4, MHF4_IBSS_SEC, MHF4_IBSS_SEC, WLC_BAND_ALL);
}

static void
wlc_tkip_countermeasures(wlc_info_t *wlc, void *pkt, uint txs)
{
	struct scb *scb;
#if defined(BCMDBG) || defined(WLMSG_WSEC)
	char eabuf[ETHER_ADDR_STR_LEN];
#endif /* BCMDBG || WLMSG_WSEC */
	wlc_bsscfg_t *cfg;

	/* no ack */
	if ((txs & TX_STATUS_MASK) == TX_STATUS_NO_ACK) {
	}

	/* make sure the scb still exists */
	if ((scb = WLPKTTAGSCBGET(pkt)) == NULL) {
		WL_ERROR(("wl%d: wlc_tkip_countermeasures: unable to find scb from the pkt %p\n",
		          wlc->pub->unit, pkt));
		return;
	}

	WL_WSEC(("wl%d: wlc_tkip_countermeasures: TKIP countermeasures: txstatus received for 2nd"
		" MIC failure indication...\n", wlc->pub->unit));

	cfg = SCB_BSSCFG(scb);
	ASSERT(cfg != NULL);

	/* no need to deauth/disassoc...already gone */
	if (ETHER_ISNULLADDR(cfg->BSSID.octet)) {
		WL_WSEC(("wl%d: %s: ignore deauth/disassoc BSS is gone\n",
		         wlc->pub->unit, __FUNCTION__));
		return;
	}

#if defined(BCMDBG) || defined(WLMSG_WSEC)
	bcm_ether_ntoa(&cfg->BSSID, eabuf);
#endif /* BCMDBG || WLMSG_WSEC */

	WL_WSEC(("wl%d: wlc_tkip_countermeasures: disassociating %s, BSS under attack\n",
		wlc->pub->unit, eabuf));

	ASSERT(SCB_ASSOCIATED(scb));

	/* send deauth packet */
	wlc_senddeauth(wlc, &cfg->BSSID, &cfg->BSSID, &cfg->cur_etheraddr,
	               scb, DOT11_RC_MIC_FAILURE);
	wlc_scb_disassoc_cleanup(wlc, scb); /* cleanup keys, etc */

	/* change scb state */
	wlc_scb_clearstatebit(scb, AUTHENTICATED | ASSOCIATED | AUTHORIZED);
	wlc_deauth_complete(wlc, cfg, WLC_E_STATUS_SUCCESS, &cfg->BSSID,
		DOT11_RC_MIC_FAILURE, DOT11_BSSTYPE_INFRASTRUCTURE);

	/* establish blocking timer */
	cfg->tk_cm_bt = WPA_TKIP_CM_BLOCK;

	/* Timestamp TKIP Counter Measure Timer Activation */
	cfg->tk_cm_bt_tmstmp = OSL_SYSUPTIME();

	/* force STA to roam (allowing it to roam back) */
	wlc_bss_clear_bssid(cfg);
}


static int
wlc_is_4way_msg(wlc_info_t *wlc, void *pkt, int offset, wpa_msg_t msg)
{
	struct dot11_llc_snap_header * lsh;
	eapol_hdr_t *eapol = NULL;
	eapol_wpa_key_header_t *ek;
	unsigned short us_tmp;
	int pair, ack, mic, kerr, req, sec, install;
	bool is_4way_msg = FALSE;
	osl_t *osh = wlc->osh;
	uint body_len = pkttotlen(osh, pkt) - offset;
	uchar *pbody = (uchar*)(PKTDATA(osh, pkt) + offset);
	uint len1;

	if (body_len <
	    (DOT11_LLC_SNAP_HDR_LEN +
	     EAPOL_HDR_LEN +
	     EAPOL_WPA_KEY_LEN))
		return FALSE;

	len1 = PKTLEN(osh, pkt) - offset;
	if (len1 >= DOT11_LLC_SNAP_HDR_LEN)
	lsh = (struct dot11_llc_snap_header *)(pbody);
	else
		return FALSE;
	len1 -= DOT11_LLC_SNAP_HDR_LEN;
	pbody += DOT11_LLC_SNAP_HDR_LEN;

	if (!(lsh->dsap == 0xaa &&
	      lsh->ssap == 0xaa &&
	      lsh->ctl == 0x03 &&
	      lsh->oui[0] == 0 &&
	      lsh->oui[1] == 0 &&
	      lsh->oui[2] == 0 &&
	      ntoh16(lsh->type) == ETHER_TYPE_802_1X)) {
		return FALSE;
	}

	/* assuming the eapol msg at the start of the pkt->next */
	if (len1 < EAPOL_HDR_LEN)
		pbody = PKTDATA(osh, PKTNEXT(osh, pkt));

	eapol = (eapol_hdr_t*)pbody;

	/* make sure it is an EAPOL-Key frame big enough for an 802.11 Key desc */
	if ((eapol->version != WPA_EAPOL_VERSION && eapol->version != WPA2_EAPOL_VERSION) ||
	    (eapol->type != EAPOL_KEY) ||
	    (ntoh16(eapol->length) < EAPOL_WPA_KEY_LEN))
		return FALSE;

	ek = (eapol_wpa_key_header_t*)((int8*)eapol + EAPOL_HDR_LEN);
	if (ek->type != EAPOL_WPA2_KEY)
		return FALSE;

	us_tmp = ntoh16_ua(&ek->key_info);

	pair = 0 != (us_tmp & WPA_KEY_PAIRWISE);
	ack = 0 != (us_tmp & WPA_KEY_ACK);
	mic = 0 != (us_tmp & WPA_KEY_MIC);
	kerr = 0 != (us_tmp & WPA_KEY_ERROR);
	req = 0 != (us_tmp & WPA_KEY_REQ);
	sec = 0 != (us_tmp & WPA_KEY_SECURE);
	install = 0 != (us_tmp & WPA_KEY_INSTALL);

	switch (msg) {
		case PMSG4:
	/* check if it matches 4-Way M4 signature */
			if (pair && !req && mic && !ack && !kerr && ek->data_len == 0)
				is_4way_msg = TRUE;

			break;

		case PMSG1:
			/* check if it matches 4-way M1 signature */
			if (!sec && !mic && ack && !install && pair && !kerr && !req)
				is_4way_msg = TRUE;

			break;
		default:
			break;
	}

	return is_4way_msg;
}

#ifdef BCMSUP_PSK
/* called from per-port mic_error handlers because they can't see sup ptr */
bool
wlc_sup_mic_error(wlc_bsscfg_t *cfg, bool group)
{
	if ((cfg->sup == NULL) || (cfg->sup_type == SUP_UNUSED))
		return FALSE;
	wlc_sup_send_micfailure(cfg->sup, group);
	return TRUE;
}
#endif /* BCMSUP_PSK */
#endif /* STA */

#ifdef MFP_TEST
void *wlc_bypass_send_action_sa_query(wlc_info_t *wlc, struct scb *scb, uint8 action, uint16 id)
{
	void *p;
	uint8* pbody;
	uint body_len;
	struct dot11_action_sa_query *af;

	body_len = sizeof(struct dot11_action_sa_query);

	/* bypass normal path so no encryption is used */
	if ((p = wlc_frame_get_mgmt_dbg(wlc, FC_ACTION, &scb->ea,
		&scb->bsscfg->cur_etheraddr, &scb->bsscfg->BSSID,
		body_len, &pbody)) == NULL)
		return p;

	af = (struct dot11_action_sa_query *)pbody;
	af->category = DOT11_ACTION_CAT_SA_QUERY;
	af->action = action;
	af->id = id;

	wlc_sendmgmt(wlc, p, scb->bsscfg->wlcif->qi, scb);

	return p;
}


static void
wlc_disassociate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag, int flag2)
{
	struct scb *scb;

	if (ETHER_ISNULLADDR(bsscfg->BSSID.octet)) {
		/* no need to deauth/disassoc...already gone */
		return;
	}

	if (BSSCFG_AP(bsscfg)) {
		if (flag2) {
			WL_WSEC(("wl: %s: send bcast disassoc", __FUNCTION__));
			wlc_send_disassoc_deauth(wlc, (struct ether_addr*)&ether_bcast,
				&bsscfg->BSSID, &bsscfg->cur_etheraddr,
				NULL, FC_DISASSOC, DOT11_RC_DISASSOC_LEAVING, flag);
		}
		else {
			struct scb_iter scbiter;
			WL_WSEC(("wl: %s: send unicast disassoc", __FUNCTION__));

			FOREACHSCB(wlc->scbstate, &scbiter, scb) {
				if (scb->bsscfg == bsscfg && SCB_ASSOCIATED(scb)) {
					wlc_send_disassoc_deauth(wlc, &scb->ea, &bsscfg->BSSID,
						&bsscfg->cur_etheraddr,
						scb, FC_DISASSOC, DOT11_RC_DISASSOC_LEAVING, flag);
				}
			}
		}
	} else {
		scb = wlc_scbfind(wlc, &bsscfg->BSSID);
		ASSERT(scb != NULL);
		ASSERT(SCB_ASSOCIATED(scb));

		WL_WSEC(("wl: %s: send unicast disassoc", __FUNCTION__));
		/* send disassoc packet */
		wlc_send_disassoc_deauth(wlc, &bsscfg->BSSID, &bsscfg->BSSID,
			&bsscfg->cur_etheraddr,
			scb, FC_DISASSOC, DOT11_RC_DISASSOC_LEAVING, flag);
	}
}

static void
wlc_deauth_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag, int flag2)
{
	struct scb *scb;

	if (ETHER_ISNULLADDR(bsscfg->BSSID.octet)) {
		/* no need to deauth/disassoc...already gone */
		return;
	}

	if (BSSCFG_AP(bsscfg)) {
		if (flag2) {
			WL_WSEC(("wl: %s: send bcast disassoc", __FUNCTION__));
			wlc_send_disassoc_deauth(wlc, (struct ether_addr*)&ether_bcast,
				&bsscfg->BSSID,
				&bsscfg->cur_etheraddr,
				NULL, FC_DEAUTH, DOT11_RC_INACTIVITY, flag);
		}
		else {
			struct scb_iter scbiter;
			WL_WSEC(("wl: %s: send unicast disassoc", __FUNCTION__));

			FOREACHSCB(wlc->scbstate, &scbiter, scb) {
				if (scb->bsscfg == bsscfg && SCB_ASSOCIATED(scb)) {
					wlc_send_disassoc_deauth(wlc, &scb->ea, &bsscfg->BSSID,
						&bsscfg->cur_etheraddr,
						scb, FC_DEAUTH, DOT11_RC_INACTIVITY, flag);
				}
			}
		}
	} else {

	scb = wlc_scbfind(wlc, &bsscfg->BSSID);
	ASSERT(scb != NULL);
	ASSERT(SCB_ASSOCIATED(scb));

	if (flag == 2)
		wlc_senddeauth(wlc, &bsscfg->BSSID, &bsscfg->BSSID, &bsscfg->cur_etheraddr,
			scb, DOT11_RC_INACTIVITY);
	else
	/* send disassoc packet */
			wlc_send_disassoc_deauth(wlc, &bsscfg->BSSID, &bsscfg->BSSID,
				&bsscfg->cur_etheraddr,
				scb, FC_DEAUTH, DOT11_RC_INACTIVITY, flag);
	}
}


static void
wlc_associate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag)
{
	struct scb *scb;

	if (ETHER_ISNULLADDR(bsscfg->BSSID.octet)) {
		/* no need to deauth/disassoc...already gone */
		return;
	}

	scb = wlc_scbfind(wlc, &bsscfg->BSSID);
	ASSERT(scb != NULL);
	ASSERT(SCB_ASSOCIATED(scb));

	/* send assoc packet */
	wlc_sendassocreq(wlc, bsscfg->target_bss, scb, FALSE);
}

static void
wlc_auth_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag)
{
	struct scb *scb;

	if (ETHER_ISNULLADDR(bsscfg->BSSID.octet)) {
		/* no need to deauth/disassoc...already gone */
		return;
	}

	scb = wlc_scbfind(wlc, &bsscfg->BSSID);
	ASSERT(scb != NULL);
	ASSERT(SCB_ASSOCIATED(scb));

	/* send auth packet */
	wlc_sendauth(bsscfg, &scb->ea, &bsscfg->target_bss->BSSID, scb,
		DOT11_OPEN_SYSTEM, 1, DOT11_SC_SUCCESS,
		(WSEC_SCB_KEY_VALID(scb)? scb->key : NULL), NULL, DOT11_CAP_SHORT);
}

static void
wlc_reassociate_mfp(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, int flag)
{
	struct scb *scb;

	if (ETHER_ISNULLADDR(bsscfg->BSSID.octet)) {
		/* no need to deauth/disassoc...already gone */
		return;
	}

	scb = wlc_scbfind(wlc, &bsscfg->BSSID);
	ASSERT(scb != NULL);
	ASSERT(SCB_ASSOCIATED(scb));

	/* send assoc packet */
	wlc_sendassocreq(wlc, bsscfg->target_bss, scb, TRUE);
}

#endif /* MFP_TEST */

/* return true if pkt idx matches with idx value */
bool
wlc_ifpkt_chk_cb(void *p, int idx)
{
	return (WLPKTTAGBSSCFGGET(p) == idx);
}

void
wlc_getrand(wlc_info_t *wlc, uint8 *buf, int buflen)
{
	int rand;

	if (buf != NULL) {
		while (buflen > 1) {
			rand = R_REG(wlc->osh, &wlc->regs->tsf_random);
			*buf++ = (rand >> 8) & 0xff;
			*buf++ = rand & 0xff;
			buflen -= 2;
		}
		/* Was buflen odd? */
		if (buflen == 1) {
			rand = R_REG(wlc->osh, &wlc->regs->tsf_random);
			*buf = rand & 0xff;
		}
	}
}

/* Append pkt's callback list to new_pkt. This is useful mainly for cram or A-MSDU */
void
wlc_pkt_callback_append(wlc_info_t *wlc, void *new_pkt, void *pkt)
{
	uint8 idx = WLPKTTAG(pkt)->callbackidx;

	if (!idx)
		return;

	/* Go to the end of the chain */
	while (wlc->pkt_callback[idx].nextidx)
		idx = wlc->pkt_callback[idx].nextidx;

	wlc->pkt_callback[idx].nextidx = WLPKTTAG(new_pkt)->callbackidx;
	WLPKTTAG(new_pkt)->callbackidx = idx;
	WLPKTTAG(pkt)->callbackidx = 0;
}

int
wlc_pkt_callback_register(wlc_info_t *wlc, pkcb_fn_t fn, void *arg, void *pkt)
{
	pkt_cb_t *pcb;
	uint8 i;

	/* find a free entry */
	for (i = 1; i <= wlc->pub->tunables->maxpktcb; i++) {
		if (wlc->pkt_callback[i].fn == NULL)
			break;
	}

	if (i > wlc->pub->tunables->maxpktcb) {
		WLCNTINCR(wlc->pub->_cnt->pkt_callback_reg_fail);
		WL_ERROR(("wl%d: failed to register callback %p\n", wlc->pub->unit, fn));
		ASSERT(0);
		return (-1);
	}

	/* alloc and init next free callback struct */
	pcb = &wlc->pkt_callback[i];
	pcb->fn = fn;
	pcb->arg = arg;
	pcb->entered = FALSE;
	/* Chain this callback */
	pcb->nextidx = WLPKTTAG(pkt)->callbackidx;
	WLPKTTAG(pkt)->callbackidx = i;

	return (0);
}

static bool
wlc_pkt_cb_ignore(wlc_info_t *wlc, uint txs)
{
	/* skip power save (PMQ) */
	uint txs_ignore = TX_STATUS_SUPR_PMQ;

#ifdef WLP2P
	/* skip P2P (NACK_ABS) */
	if (P2P_ENAB(wlc->pub))
		txs_ignore |= TX_STATUS_SUPR_NACK_ABS;
#endif

	/* If the frame has been suppressed for deferred delivery, skip the callback 
	 * now as it will be attempted later.
	 */
	return (txs & txs_ignore) != 0;
}

/* Invokes the callback chain attached to a packet either
 * at the end of attempt to transmit it (success or fail)
 * or when it's freed by OSL.
 */
void BCMFASTPATH
wlc_pkt_callback(void *ctx, void *pkt, uint txs)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	wlc_pkttag_t *pkttag = WLPKTTAG(pkt);
	pkt_cb_t *pcb;
	uint8 idx = pkttag->callbackidx;

	/* No callbacks to this packet. Do nothing */
	if (idx == 0)
		return;

	/* If the frame txs indicates one of the ignorance condition skip the callback */
	if (wlc_pkt_cb_ignore(wlc, txs))
		return;

	ASSERT(idx <= wlc->pub->tunables->maxpktcb && wlc->pkt_callback[idx].fn != NULL);
	while (idx != 0 && idx <= wlc->pub->tunables->maxpktcb) {
		pcb = &wlc->pkt_callback[idx];

		/* ensure the callback is not called recursively */
		ASSERT(pcb->entered == FALSE);
		ASSERT(pcb->fn != NULL);
		pcb->entered = TRUE;
		/* call the function */
		(pcb->fn)(wlc, txs, pcb->arg);
		pcb->fn = NULL;
		pcb->entered = FALSE;
		idx = pcb->nextidx;
		pcb->nextidx = 0;
	}
	pkttag->callbackidx = 0;
}

/* packet callbacks based on packet type */
typedef void (*wlc_pkt_type_cb_t)(wlc_info_t *wlc, void *pkt, uint txs);
static const wlc_pkt_type_cb_t wlc_pkt_type_cb_tbl[] = {
	NULL,
	/* type WLF2_TYPE_APSD */
#ifdef AP
	wlc_apps_apsd_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_PSP_RSP */
#ifdef AP
	wlc_apps_psp_resp_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_PRB */
#ifdef AP
	wlc_ap_probe_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_PSP */
#ifdef STA
	wlc_sendpspoll_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_AF */
#ifdef WIFI_ACT_FRAME
	wlc_actionframetx_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_HCI_ACL */
#ifdef WLBTAMP
	wlc_bta_tx_hcidata_complete,
#else
	NULL,
#endif
	/* type WLF2_TYPE_TKIP_CM */
#ifdef STA
	wlc_tkip_countermeasures,
#else
	NULL,
#endif
	/* type WLF2_TYPE_RATE */
#ifdef STA
	wlc_rateprobe_complete,
#else
	NULL,
#endif
	NULL
};

static void BCMFASTPATH
wlc_pkt_type_cb(void *ctx, void *pkt, uint txs)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	uint idx = WLPKTFLAG2_TYPEGET(pkt);
	wlc_pkt_type_cb_t cb;

	/* No callbacks to this type of packet. Do nothing */
	if (idx == 0)
		return;

	/* If the frame txs indicates one of the ignorance condition skip the callback */
	if (wlc_pkt_cb_ignore(wlc, txs))
		return;

	ASSERT(idx < ARRAYSIZE(wlc_pkt_type_cb_tbl));
	cb = wlc_pkt_type_cb_tbl[idx];
	if (cb != NULL)
		(cb)(wlc, pkt, txs);
	WLPKTFLAG2_TYPECLR(pkt);
}

/* packet callback when packet is freed */
static void BCMFASTPATH
wlc_pkt_free_cb(void *ctx, void *pkt, uint txs)
{
	wlc_pkt_callback(ctx, pkt, txs);
	wlc_pkt_type_cb(ctx, pkt, txs);
}

static uint8
wlc_get_antennas(wlc_info_t *wlc)
{
	if (WLCISHTPHY(wlc->band))
		return ANTENNA_NUM_3;
	else if (WLCISNPHY(wlc->band))
		return ANTENNA_NUM_2;
	else if ((wlc->stf->ant_rx_ovr == ANT_RX_DIV_FORCE_0) ||
	    (wlc->stf->ant_rx_ovr == ANT_RX_DIV_FORCE_1))
		return ANTENNA_NUM_1;
	else
		return ANTENNA_NUM_2;
}

/* init tx reported rate mechanism */
void
wlc_reprate_init(wlc_info_t *wlc)
{
	int i;
	wlc_bsscfg_t *bsscfg;

	FOREACH_BSS(wlc, i, bsscfg) {
		wlc_bsscfg_reprate_init(bsscfg);
	}
}

/* per bsscfg init tx reported rate mechanism */
void
wlc_bsscfg_reprate_init(wlc_bsscfg_t *bsscfg)
{
	bsscfg->txrspecidx = 0;
	bzero((char*)bsscfg->txrspec, sizeof(bsscfg->txrspec));
}

/*
 * Loop over bsscfg specific txrspec history, looking up rate bins, and summing
 * nfrags into appropriate supported rate bin. Return pointers to
 * most used ratespec and highest used ratespec.
 */
static void
wlc_get_rate_histo_bsscfg(wlc_bsscfg_t *bsscfg, ratespec_t *hw_rates, ratespec_t *hw_mcs,
	ratespec_t *most_used_ratespec, ratespec_t *highest_used_ratespec)
{
	int i, mcs;
	ratespec_t rspec;
	uint max_frags = 0;
	uint rate;
	uint high_frags = 0;

	/* [0] = rate, [1] = nfrags */
	for (i = 0; i < NTXRATE; i++) {
		if (IS_MCS(bsscfg->txrspec[i][0])) {
			mcs = bsscfg->txrspec[i][0] & RSPEC_RATE_MASK;
			hw_mcs[mcs] += bsscfg->txrspec[i][1];
			if (hw_mcs[mcs] > max_frags) {
				max_frags = hw_mcs[mcs];
				*most_used_ratespec = bsscfg->txrspec[i][0];
			}
		} else {
			rspec = RSPEC2RATE(bsscfg->txrspec[i][0]);
			hw_rates[rspec] += bsscfg->txrspec[i][1];
			if (hw_rates[rspec] > max_frags) {
				max_frags = hw_rates[rspec];
				*most_used_ratespec = rspec;
			}
		}

		rate = RSPEC2KBPS(bsscfg->txrspec[i][0]);
		if (rate > high_frags) {
			high_frags = rate;
			*highest_used_ratespec = bsscfg->txrspec[i][0];
		}
	}
	return;
}

uint32
wlc_get_current_highest_rate(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	/* return a default value for rate */
	ratespec_t reprspec;
	bool isbw40cap = FALSE;
	bool sgi = (wlc->sgi_tx) ? TRUE : FALSE;
	wlcband_t *cur_band = wlc->band;
	wlc_bss_info_t *current_bss = cfg->current_bss;

	if (cfg->associated) {
		if (N_ENAB(wlc->pub))
			isbw40cap = CHSPEC_IS40(current_bss->chanspec);
		/* associated, so return the max supported rate */
		reprspec = wlc_get_highest_rate(&current_bss->rateset,
		                                isbw40cap, sgi, wlc->stf->txstreams);
	} else {
		if (N_ENAB(wlc->pub)) {
			isbw40cap =
			        (((wlc->ht_cap.cap & HT_CAP_40MHZ) != 0) &&
			         ((wlc_channel_locale_flags_in_band(wlc->cmi, cur_band->bandunit) &
			           WLC_NO_40MHZ) == 0)) &&
			        cur_band->mimo_cap_40;
		}

		/* not associated, so return the max rate we can send */
		reprspec = wlc_get_highest_rate(&cur_band->hw_rateset, isbw40cap, sgi,
		                                wlc->stf->txstreams);

		/* Report the highest CCK rate if gmode == GMODE_LEGACY_B */
		if (BAND_2G(cur_band->bandtype) && (cur_band->gmode == GMODE_LEGACY_B)) {
			wlc_rateset_t rateset;
			wlc_rateset_filter(&cur_band->hw_rateset, &rateset,
			                   FALSE, WLC_RATES_CCK, RATE_MASK_FULL,
			                   BSS_N_ENAB(wlc, cfg));
			reprspec = rateset.rates[rateset.count - 1];
		}
	}
	return reprspec;
}

/* return the "current tx rate" as a ratespec */
uint32
wlc_get_rspec_history(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	ratespec_t hw_rates_used[WLC_MAXRATE + 1];
	ratespec_t hw_mcs_used[WLC_MAXMCS + 1];
	ratespec_t reprspec, highest_used_ratespec = 0;
	wlcband_t *cur_band = wlc->band;
	wlc_bss_info_t *current_bss = cfg->current_bss;

	if (cfg->associated)
		cur_band = wlc->bandstate[CHSPEC_IS2G(current_bss->chanspec) ?
			BAND_2G_INDEX : BAND_5G_INDEX];

	reprspec = cur_band->rspec_override ? cur_band->rspec_override : 0;
	if (reprspec) {
		if (IS_MCS(reprspec)) {
			if (cfg->associated &&
			    CHSPEC_IS40(current_bss->chanspec))
				reprspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);
			else if (!cfg->associated &&
			         CHSPEC_IS40(WLC_BAND_PI_RADIO_CHANSPEC))
				reprspec |= (PHY_TXC1_BW_40MHZ << RSPEC_BW_SHIFT);

			if (wlc->sgi_tx == ON)
				reprspec |= RSPEC_SHORT_GI;
		}
		return reprspec;
	}


	/*
	 * Loop over txrspec history, looking up rate bins, and summing
	 * nfrags into appropriate supported rate bin.
	 */
	bzero((char*)hw_rates_used, sizeof(hw_rates_used));
	bzero((char*)hw_mcs_used, sizeof(hw_mcs_used));
	wlc_get_rate_histo_bsscfg(cfg, hw_rates_used, hw_mcs_used,
		&reprspec, &highest_used_ratespec);

	/* check for an empty history */
	if (reprspec == 0)
		return wlc_get_current_highest_rate(cfg);

	return (wlc->rpt_hitxrate ? highest_used_ratespec : reprspec);
}

/* Retrieve a consolidated set of revision information,
 * typically for the WLC_GET_REVINFO ioctl
 */
int
wlc_get_revision_info(wlc_info_t *wlc, void *buf, uint len)
{
	wlc_rev_info_t *rinfo = (wlc_rev_info_t *)buf;

	if (len < WL_REV_INFO_LEGACY_LENGTH)
		return BCME_BUFTOOSHORT;

	rinfo->vendorid = wlc->vendorid;
	rinfo->deviceid = wlc->deviceid;
	rinfo->radiorev = (wlc->band->radiorev << IDCODE_REV_SHIFT) |
		(wlc->band->radioid << IDCODE_ID_SHIFT);
	rinfo->chiprev = wlc->pub->sih->chiprev;
	rinfo->corerev = wlc->pub->corerev;
	rinfo->boardid = wlc->pub->sih->boardtype;
	rinfo->boardvendor = wlc->pub->sih->boardvendor;
	rinfo->boardrev = wlc->pub->boardrev;
	rinfo->ucoderev = wlc->ucode_rev;
	rinfo->driverrev = EPI_VERSION_NUM;
	rinfo->bus = wlc->pub->sih->bustype;
	rinfo->chipnum = wlc->pub->sih->chip;

	if (len >= (OFFSETOF(wlc_rev_info_t, chippkg))) {
		rinfo->phytype = wlc->band->phytype;
		rinfo->phyrev = wlc->band->phyrev;
		rinfo->anarev = 0;	/* obsolete stuff, suppress */
	}

	if (len >= sizeof(*rinfo)) {
		rinfo->chippkg = wlc->pub->sih->chippkg;
	}

	return BCME_OK;
}

#if defined(STA) && defined(WL11H)
/* Supported Channels IE */
static uint8*
wlc_write_sup_chan_ie(wlc_info_t* wlc, uint8 *cp)
{
	uint8 run_count = 0, len = 0;
	bcm_tlv_t *sup_channel_ie = (bcm_tlv_t*)cp;
	uint8 cur_chan, first_chan = 0, seen_valid = 0, max_channel, ch_sep;
	bool valid_channel;
	uint subband_idx = 0, end_subband, j;

	/* 1-14, 34-46, 36-48, 52-64, 100-140, 149-161, 165, 184-196 */
	struct {
		uint8 start;
		uint8 cnt;
	} subbands[] =
	          {
			  {1, 14}, {34, 4}, {36, 4}, {52, 4},
			  {100, 11}, {149, 4}, {165, 1}, {184, 4} };

	sup_channel_ie->id = DOT11_MNG_SUPP_CHANNELS_ID;
	cp += 2; /* Skip over ID and Len */

	if (wlc->band->bandtype == WLC_BAND_2G) {
		subband_idx = 0;
		end_subband = 1;
		max_channel = CH_MAX_2G_CHANNEL + 1;
		ch_sep = CH_5MHZ_APART;
	} else {
		end_subband = ARRAYSIZE(subbands);
		max_channel = MAXCHANNEL;
		ch_sep = CH_20MHZ_APART;

		/* Handle special case for JP where subband could be 34-46 or 36-48 */
		/* Arbitrarily decided to give 36-48 priority as 34-46 is legacy passive anyway */
		if (VALID_CHANNEL20_IN_BAND(wlc, BAND_5G_INDEX, 34) &&
		    !VALID_CHANNEL20_IN_BAND(wlc, BAND_5G_INDEX, 36))
			subband_idx = 1;
		else
			subband_idx = 2;
	}

	for (; subband_idx < end_subband; subband_idx++) {
		run_count = 0;
		seen_valid = 0;

		for (cur_chan = subbands[subband_idx].start, j = 0;
		     (j < subbands[subband_idx].cnt) && (cur_chan < max_channel);
		     j++, cur_chan += ch_sep) {

			valid_channel = VALID_CHANNEL20_IN_BAND(wlc,
			                                        wlc->band->bandunit, cur_chan);
			if (valid_channel) {
				if (!seen_valid) {
					first_chan = cur_chan;
					seen_valid = 1;
				}
				run_count++;
			}
		}

		if (seen_valid) {
			*cp++ = first_chan;
			*cp++ = run_count;
			len += 2;
			run_count = 0;
			seen_valid = 0;
		}

		/* If subband 34-46 was present then skip over 36-48 */
		if (subband_idx == 1)
			subband_idx = 2;
	}

	/* This would happen if CH_MAX_2G_CHANNEL is valid */
	if (seen_valid) {
		*cp++ = first_chan;
		*cp++ = run_count;
		len += 2;
	}

	sup_channel_ie->len = len;
	return cp;
}
#endif /* defined(STA) && defined(WL11H) */

void
wlc_default_rateset(wlc_info_t *wlc, wlc_rateset_t *rs)
{
	wlc_rateset_default(rs, NULL, wlc->band->phytype, wlc->band->bandtype,
		FALSE, RATE_MASK_FULL, (bool)N_ENAB(wlc->pub),
		CHSPEC_WLC_BW(wlc->default_bss->chanspec), wlc->stf->op_rxstreams);

	WL_RATE(("wl%d: %s: bandunit 0x%x phy_type 0x%x gmode 0x%x\n", wlc->pub->unit,
		__FUNCTION__, wlc->band->bandunit, wlc->band->phytype, wlc->band->gmode));
#ifdef BCMDBG
	wlc_rateset_show(wlc, rs, &wlc->default_bss->BSSID);
#endif
}

static void
BCMATTACHFN(wlc_bss_default_init)(wlc_info_t *wlc)
{
	chanspec_t chanspec;
	wlcband_t * band;
	wlc_bss_info_t * bi = wlc->default_bss;

	/* init default and target BSS with some sane initial values */
	bzero((char*)(bi), sizeof(wlc_bss_info_t));
	bi->beacon_period = ISSIM_ENAB(wlc->pub->sih) ? BEACON_INTERVAL_DEF_QT :
		BEACON_INTERVAL_DEFAULT;
	bi->dtim_period = ISSIM_ENAB(wlc->pub->sih) ? DTIM_INTERVAL_DEF_QT :
	        DTIM_INTERVAL_DEFAULT;

	/* fill the default channel as the first valid channel
	 * starting from the 2G channels
	 */
	chanspec = wlc_next_chanspec(wlc->cmi, CH20MHZ_CHSPEC(0), CHAN_TYPE_ANY, TRUE);

	/* if there are no valid channels, use the first phy supported channel
	 * for the current band
	 */
	if (chanspec == INVCHANSPEC)
		chanspec = wlc_phy_chanspec_band_firstch(wlc->band->pi, wlc->band->bandtype);

	wlc->home_chanspec = bi->chanspec = chanspec;

	/* find the band of our default channel */
	band = wlc->band;
	if (NBANDS(wlc) > 1 && band->bandunit != CHSPEC_WLCBANDUNIT(chanspec))
		band = wlc->bandstate[OTHERBANDUNIT(wlc)];

	/* init bss rates to the band specific default rate set */
	wlc_rateset_default(&bi->rateset, NULL, band->phytype, band->bandtype,
		FALSE, RATE_MASK_FULL, (bool)N_ENAB(wlc->pub),
		CHSPEC_WLC_BW(chanspec), wlc->stf->op_rxstreams);

	if (N_ENAB(wlc->pub))
		bi->flags |= WLC_BSS_HT;
}

/*
 * Parse a legacy rateset from a TLV section, optionally copy the raw version
 * into a *bss, sanitize and sort it, then optionally copy it into an scb.
 * Return 0 on success, nonzero on error.
 */
int
wlc_parse_rates(wlc_info_t *wlc, uchar *tlvs, uint tlvs_len, wlc_bss_info_t *bi,
	wlc_rateset_t *rates)
{
	wlc_rateset_t rs;
	int ext_count;
	bcm_tlv_t *ie;

	bzero(&rs, sizeof(wlc_rateset_t));

	/* pick out rateset from tlv section */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_RATES_ID)) == NULL)
		return (-1);

	rs.count = MIN(ie->len, WLC_NUMRATES);
	bcopy(ie->data, (char*)rs.rates, rs.count);

	/* pick out extended rateset from tlv section */
	if ((ie = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_EXT_RATES_ID)) != NULL) {
		ext_count = MIN(ie->len, WLC_NUMRATES - (int)rs.count);
		bcopy(ie->data, (char*)(rs.rates + rs.count), ext_count);
		rs.count += ext_count;
	}

	/* copy raw set to bss_info */
	if (bi)
		bcopy((char*)&rs, (char*) &bi->rateset, sizeof(wlc_rateset_t));

	/* sort and sanitize them */
	if (!wlc_rate_hwrs_filter_sort_validate(&rs, &wlc->band->hw_rateset, FALSE,
		wlc->stf->txstreams)) {
		/* filter bss membership out of rateset */
		if (!wlc->htphy_membership || !wlc_bss_membership_filter(&rs))
			return (-1);
		if (bi)
			bcopy((char*)&rs, (char*) &bi->rateset, sizeof(wlc_rateset_t));
	}

	ASSERT(rs.count <= WLC_NUMRATES);

	if (rates)
		bcopy((char*)&rs, (char*)rates, sizeof(wlc_rateset_t));

	return (0);
}


void
wlc_rateset_elts(wlc_info_t *wlc, wlc_bsscfg_t *cfg, const wlc_rateset_t *rates,
	wlc_rateset_t *sup_rates, wlc_rateset_t *ext_rates)
{
	uint8 sup_bin[WLC_MAXRATE+1];
	uint8 ext_bin[WLC_MAXRATE+1];
	uint8 sup_pref_bin[WLC_MAXRATE+1];
	const wlc_rateset_t *sup_pref_rates;
	const wlc_rateset_t *hw_rs = &wlc->band->hw_rateset;
	uint8 r;
	uint sup_count, ext_count;
	uint i;
	int j;

	ASSERT(rates->count <= WLC_NUMRATES);
	ASSERT(sup_rates != NULL);

	bzero(sup_bin, sizeof(sup_bin));
	bzero(ext_bin, sizeof(ext_bin));
	bzero(sup_pref_bin, sizeof(sup_pref_bin));

	if (!wlc->band->gmode ||
#ifdef WLP2P
	    BSS_P2P_ENAB(wlc, cfg) ||
#endif
	    FALSE) {
#ifdef WLP2P
		wlc_rateset_t rs;

		if (BSS_P2P_ENAB(wlc, cfg)) {
			wlc_rateset_copy(rates, &rs);
			wlc_p2p_rateset_filter(wlc->p2p, cfg, &rs);
			rates = &rs;
		}
#endif
		/* All rates end up in the Supported Rates elt */
		sup_rates->count = rates->count;
		bcopy(rates->rates, sup_rates->rates, rates->count);
		/* setting ht phy membership */
		if (wlc->htphy_membership) {
			ASSERT(ext_rates != NULL);
			if (sup_rates->count < 8)
				sup_rates->rates[sup_rates->count++] = wlc->htphy_membership;
			else if (ext_rates->count < 8)
				ext_rates->rates[ext_rates->count++] = wlc->htphy_membership;
			else
				WL_ERROR(("Cannot support HT PHY Membership, rate IEs are full\n"));
		}
		return;
	}

	/* check for a supported rates override */
	if (sup_rates->count > 0) {
		/* split the rateset into supported and extended using the provided sup_rates
		 * as the guide
		 */
		sup_pref_rates = sup_rates;
	} else {
		/* use the default rate split of LRS rates (wlc_lrs_rates -> 1 2 5.5 11 18 24 36 54)
		 * in the supported rates, and others in extended rates
		 */
		sup_pref_rates = &wlc_lrs_rates;
	}

	/* init the supported rates preferred lookup */
	for (i = 0; i < sup_pref_rates->count; i++) {
		r = sup_pref_rates->rates[i] & RATE_MASK;
		sup_pref_bin[r] = r;
	}

	sup_count = 0;
	ext_count = 0;

	/* split the rates into a supported and ext supported using the preferred split. */
	for (i = 0; i < rates->count; i++) {
		uint8 rate = rates->rates[i];
		r = rate & RATE_MASK;
		if (sup_pref_bin[r]) {
			sup_bin[r] = rate;
			sup_count++;
		} else {
			ext_bin[r] = rate;
			ext_count++;
		}
	}

	if (sup_rates->count == 0 && ext_rates->count == 0) {
		/* fill up the supported rates to the full 8 rates unless there was an override */
		j = (int)hw_rs->count;
		for (i = sup_count; i < 8 && ext_count > 0; i++) {
			for (; j >= 0; j--) {
				r = hw_rs->rates[j] & RATE_MASK;
				if (ext_bin[r] != 0) {
					sup_bin[r] = ext_bin[r];
					sup_count++;
					ext_bin[r] = 0;
					ext_count--;
					break;
				}
			}
		}
	}

	/* fill out the sup_rates and ext_rates in sorted order */
	bzero(sup_rates, sizeof(wlc_rateset_t));
	bzero(ext_rates, sizeof(wlc_rateset_t));
	for (i = 0; i < hw_rs->count; i++) {
		r = hw_rs->rates[i] & RATE_MASK;
		if (sup_bin[r] != 0)
			sup_rates->rates[sup_rates->count++] = sup_bin[r];
		if (ext_bin[r] != 0)
			ext_rates->rates[ext_rates->count++] = ext_bin[r];
	}

	/* setting ht phy membership */
	if (wlc->htphy_membership) {
		if (sup_rates->count < 8)
			sup_rates->rates[sup_rates->count++] = wlc->htphy_membership;
		else if (ext_rates->count < 8)
			ext_rates->rates[ext_rates->count++] = wlc->htphy_membership;
		else
			WL_ERROR(("Cannot support BSS Membership, rate IEs are full\n"));
	}
}

/* Deferred event processing */
static void
wlc_process_eventq(void *arg)
{
	wlc_info_t *wlc = (wlc_info_t *)arg;
	wlc_event_t *etmp;

#ifdef WLLMAC
	if (LMAC_ENAB(wlc->pub))
		return;
#endif /* WLLMAC */
	while ((etmp = wlc_eventq_deq(wlc->eventq))) {
		/* Perform OS specific event processing */
		wl_event(wlc->wl, etmp->event.ifname, etmp);
		/* Perform common event notification */
		wlc_eventq_handle_ind(wlc->eventq, etmp);
		if (etmp->data) {
			MFREE(wlc->osh, etmp->data, etmp->event.datalen);
			etmp->data = NULL;
		}
		wlc_event_free(wlc->eventq, etmp);
	}
}

/* Immediate event processing.
 * Process the event and any events generated during the processing,
 * and queue all these events for deferred processing as well.
 */
void
wlc_process_event(wlc_info_t *wlc, wlc_event_t *e)
{
#if defined(BCMDBG) || defined(BCMDBG_ERR)
	wlc_print_event(wlc, e);
#endif /* BCMDBG || BCMDBG_ERR */

	/* deliver event to the port OS right now */
	wl_event_sync(wlc->wl, e->event.ifname, e);

	/* queue the event for 0 delay timer delivery */
	wlc_eventq_enq(wlc->eventq, e);
}

/* Record the destination interface pointer dst_wlcif in e->wlcif field and
 * init e->event.ifname field with a string that each port maintains for
 * the OS interface associated with the source interface pointed by src_wlcif.
 * dst_wlcif may become stale if one deletes the bsscfg associated with it
 * due to the async nature of events processing therefore an explicit flush
 * of all generated events is required when deleteing a bsscfg.
 * See wlc_eventq_flush() in wlc_bsscfg_free().
 */
void
_wlc_event_if(wlc_info_t *wlc, wlc_event_t *e,
	wlc_bsscfg_t *src_bsscfg, wlc_if_t *src_wlcif, wlc_if_t *dst_wlcif)
{
	wl_if_t *wlif = NULL;

	ASSERT(dst_wlcif != NULL);

	e->wlcif = dst_wlcif;

	if (src_bsscfg != NULL)
		e->event.bsscfgidx = WLC_BSSCFG_IDX(src_bsscfg);
	else {
		e->event.bsscfgidx = 0;
		e->event.flags |= WLC_EVENT_MSG_UNKBSS;
	}
	if (src_wlcif != NULL)
		e->event.ifidx = src_wlcif->index;
	else {
		e->event.ifidx = 0;
		e->event.flags |= WLC_EVENT_MSG_UNKIF;
	}

	if (src_wlcif != NULL)
		wlif = src_wlcif->wlif;

	strncpy(e->event.ifname, wl_ifname(wlc->wl, wlif), sizeof(e->event.ifname) - 1);
	e->event.ifname[sizeof(e->event.ifname) - 1] = 0;
}

/* Send the event to the OS interface associated with the scb (used by WDS,
 * looked up by the addr parm if valid) or the bsscfg. In case the bsscfg
 * parm is unknown (NULL) or the bsscfg doesn't have an OS visible interface
 * send the event to the primary interface.
 */
void
wlc_event_if(wlc_info_t *wlc, wlc_bsscfg_t *cfg, wlc_event_t *e, const struct ether_addr *addr)
{
	struct scb *scb;
	wlc_if_t *wlcif;

	if (addr != NULL && !ETHER_ISMULTI(addr)) {
		bcopy(addr->octet, e->event.addr.octet, ETHER_ADDR_LEN);
		e->addr = &(e->event.addr);
	}

	if (addr != NULL && !ETHER_ISMULTI(addr) &&
	    (scb = wlc_scbfind(wlc, addr)) != NULL &&
	    (wlcif = SCB_WDS(scb)) != NULL && wlcif->wlif != NULL)
		_wlc_event_if(wlc, e, SCB_BSSCFG(scb), wlcif, wlcif);
	else if (cfg != NULL && (wlcif = cfg->wlcif) != NULL) {
		if (wlcif->wlif != NULL)
			_wlc_event_if(wlc, e, cfg, wlcif, wlcif);
		else
			_wlc_event_if(wlc, e, cfg, wlcif, wlc->cfg->wlcif);
	}
	else
		_wlc_event_if(wlc, e, NULL, NULL, wlc->cfg->wlcif);
}

/* Some events require specifying the BSS config (assoc in particular). */
void
wlc_bss_mac_event(wlc_info_t* wlc, wlc_bsscfg_t *bsscfg, uint msg, const struct ether_addr* addr,
	uint result, uint status, uint auth_type, void *data, int datalen)
{
	wlc_bss_mac_rxframe_event(wlc, bsscfg, msg, addr, result, status, auth_type,
	                          data, datalen, NULL);
}

void
wlc_bss_mac_rxframe_event(wlc_info_t* wlc, wlc_bsscfg_t *bsscfg, uint msg,
                          const struct ether_addr* addr,
                          uint result, uint status, uint auth_type, void *data, int datalen,
                          wl_event_rx_frame_data_t *rxframe_data)
{
	wlc_event_t *e;

#ifdef WLLMAC
	/* LMAC doesn't use the mac events */
	if (LMAC_ENAB(wlc->pub))
		return;
#endif
	/* There are many WLC_E_TXFAIL but currently no special handling;
	 * possible optimization is to drop it here unless requested.
	 *
	 * if (msg == WLC_E_TXFAIL)
	 * 	if (!wlc_eventq_test_ind(eq, e->event.event_type))
	 *		return;
	 */
	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_mac_event wlc_event_alloc failed\n", wlc->pub->unit));
		return;
	}

	e->event.event_type = msg;
	e->event.status = result;
	e->event.reason = status;
	e->event.auth_type = auth_type;

	if (rxframe_data)
		datalen += sizeof(wl_event_rx_frame_data_t);

	e->event.datalen = datalen;
	if ((e->event.datalen > 0) && (data != NULL)) {
		e->data = MALLOC(wlc->osh, e->event.datalen);
		if (e->data == NULL) {
			wlc_event_free(wlc->eventq, e);
			WL_ERROR(("wl%d: wlc_mac_event MALLOc failed\n", wlc->pub->unit));
			return;
		}

		if (rxframe_data) {
			bcopy(rxframe_data, e->data, sizeof(wl_event_rx_frame_data_t));
			bcopy(data, ((wl_event_rx_frame_data_t *)(e->data)) + 1,
			      e->event.datalen - sizeof(wl_event_rx_frame_data_t));
		} else
			bcopy(data, e->data, e->event.datalen);
	}

	wlc_event_if(wlc, bsscfg, e, addr);

	wlc_process_event(wlc, e);
}

/* Wrapper for wlc_bss_mac_event when no BSS is specified. */
void
wlc_mac_event(wlc_info_t* wlc, uint msg, const struct ether_addr* addr,
	uint result, uint status, uint auth_type, void *data, int datalen)
{
	wlc_bss_mac_event(wlc, NULL, msg, addr, result, status, auth_type, data, datalen);
}

void
wlc_enable_btc_ps_protection(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, bool protect)
{
	if ((wlc_btc_wire_get(wlc) >= WL_BTC_3WIRE) &&
		wlc_btc_mode_get(wlc)) {
		wlc_bsscfg_t *pc;
		int btc_flags = wlc_bmac_btc_flags_get(wlc->hw);
		uint16 protections;
		uint16 active;
		uint16 ps;

		pc = wlc->cfg;

		/* if radio is disable, driver may be down, quit here */
		if (wlc->pub->radio_disabled || !wlc->pub->up)
			return;

#if defined(STA)
		/* ??? if ismpc, driver should be in down state if up/down is allowed */
		if (wlc->mpc && wlc_ismpc(wlc))
			return;
#endif
		wlc_btc_rssi_threshold_get(wlc);

		/* enable protection for hybrid mode when rssi below certain threshold */
		if ((wlc->btch->prot_rssi_thresh &&
			-wlc->cfg->link->rssi > wlc->btch->prot_rssi_thresh) ||
			(btc_flags & WL_BTC_FLAG_ACTIVE_PROT))
			active = MHF3_BTCX_ACTIVE_PROT;
		else
			active = 0;

		ps = (btc_flags & WL_BTC_FLAG_PS_PROTECT) ? MHF3_BTCX_PS_PROTECT : 0;

#ifdef STA
		/* Enable PS protection when the primary bsscfg is associated as
		 * an infra STA and is the only connection
		 */
		if (BSSCFG_STA(pc) && pc->current_bss->infra &&
		    WLC_BSS_CONNECTED(pc) && wlc->stas_connected == 1 &&
		    (wlc->aps_associated == 0 || wlc_ap_stas_associated(wlc->ap) == 0)) {
			/* when WPA/PSK security is enabled wait until WLC_PORTOPEN() is TRUE */
			if (pc->WPA_auth == WPA_AUTH_DISABLED || !WSEC_ENABLED(pc->wsec) ||
			    WLC_PORTOPEN(pc))
				protections = active | ps;
			else
				protections = 0;
		}
		/* Enable CTS-to-self protection if there is any non primary bsscfg
		 * associated as infra STA, or the primary bsscfg as IBSS STA, or the
		 * primary bsscfg associated but not connected (roaming)
		 */
		else if (wlc->stas_connected > 0)
			protections = active;
		/* Enable CTS-to-self protection when AP(s) are up and there are
		 * STAs associated
		 */
		else
#endif /* STA */
#ifdef AP
		if (wlc->aps_associated > 0 && wlc_ap_stas_associated(wlc->ap) > 0)
			protections = active;
		/* No protection */
		else
#endif /* AP */
			protections = 0;

		wlc_mhf(wlc, MHF3, MHF3_BTCX_ACTIVE_PROT | MHF3_BTCX_PS_PROTECT,
		        protections, WLC_BAND_2G);
	}
}

/*
 * The struct ether_addr arg is (when non-NULL) the mac addr
 * of the AP to which we're associating. It's used by nas supplicant
 * in the ap-sta build variant.
 *
 */
void
wlc_link(wlc_info_t *wlc, bool isup, struct ether_addr *addr, wlc_bsscfg_t *bsscfg, uint reason)
{
	wlc_event_t *e;
	wlc_assoc_t *as;
	wlc_bss_info_t *current_bss;

	ASSERT(bsscfg != NULL);

	as = bsscfg->assoc;
	current_bss = bsscfg->current_bss;

#ifdef STA
	/* When the link goes down, driver is no longer preserving the association */
	if (!isup)
		as->preserved = FALSE;
#endif

	/* Allow for link-up suppression */
	if (isup && wlc->nolinkup)
		return;

	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_link wlc_event_alloc failed\n", wlc->pub->unit));
		return;
	}

	e->event.event_type = WLC_E_LINK;
	e->event.flags = isup ? WLC_EVENT_MSG_LINK : 0;
	e->event.reason = reason;

#ifdef STA
	/* send WPA/WPA2 IEs in the probe resp as event data */
	if (BSSCFG_STA(bsscfg) && bsscfg->associated &&
	    WSEC_ENABLED(bsscfg->wsec) &&
	    current_bss->bcn_prb != NULL &&
	    current_bss->bcn_prb_len > DOT11_BCN_PRB_LEN) {
		uint8 *parse;
		uint len;
		bcm_tlv_t *ie;

		parse = (uint8 *)current_bss->bcn_prb + sizeof(struct dot11_bcn_prb);
		len = current_bss->bcn_prb_len - sizeof(struct dot11_bcn_prb);

		if ((IS_WPA_AUTH(bsscfg->WPA_auth) &&
		     (ie = (bcm_tlv_t *)bcm_find_wpaie(parse, len)) != NULL) ||
		    (IS_WPA2_AUTH(bsscfg->WPA_auth) &&
		     (ie = bcm_parse_tlvs(parse, len, DOT11_MNG_RSN_ID)) != NULL)) {

#if defined(WLFBT)
			/* Don't report the association event if it's a fast transition */
			if (WLFBT_ENAB(wlc->pub) && (IS_WPA2_AUTH(wlc->cfg->WPA_auth)) &&
				isup && reason) {
				wlc_event_free(wlc->eventq, e);
				return;
			}
#endif /* WLFBT */

			e->data = MALLOC(wlc->osh, ie->len + TLV_HDR_LEN);
			if (e->data != NULL) {
				e->event.datalen = ie->len + TLV_HDR_LEN;
				bcopy(ie, e->data, e->event.datalen);
			}
		}
	}
#endif /* STA */

	wlc_event_if(wlc, bsscfg, e, addr);

	wlc_process_event(wlc, e);
}

#if !defined(WLNOEIND)
/* Send BRCM encapsulated EAPOL Events to applications. */
void
wlc_bss_eapol_event(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, const struct ether_addr *ea,
	uint8 *data, uint32 len)
{
	wlc_pub_t *pub = wlc->pub;
	wlc_event_t *e;

	/* `data' should point to a WPA info element */
	if (data == NULL || len == 0) {
		WL_ERROR(("wl%d: 802.1x missing", pub->unit));
		return;
	}

	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_eapol_event wlc_event_alloc failed\n", pub->unit));
		return;
	}

	e->event.event_type = WLC_E_EAPOL_MSG;
	e->event.status = WLC_E_STATUS_SUCCESS;
	e->event.reason = 0;
	e->event.auth_type = 0;

	e->event.datalen = len;
	e->data = MALLOC(pub->osh, e->event.datalen);
	if (e->data == NULL) {
		wlc_event_free(wlc->eventq, e);
		WL_ERROR(("wl%d: wlc_eapol_event MALLOc failed\n", pub->unit));
		return;
	}

	bcopy(data, e->data, e->event.datalen);

	wlc_event_if(wlc, bsscfg, e, ea);

	WL_WSEC(("wl%d: notify NAS of 802.1x frame data len %d\n", pub->unit, len));
	wlc_process_event(wlc, e);
}

#ifdef BCMWAPI_WAI
/* Send BRCM encapsulated WAI Events to applications. */
void
wlc_bss_wai_event(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, const struct ether_addr *ea,
	uint8 *data, uint32 len)
{
	wlc_pub_t *pub = wlc->pub;
	wlc_event_t *e;

	/* `data' should point to a WAI header */
	if (data == NULL || len == 0) {
		WL_ERROR(("wl%d: wai missing", pub->unit));
		return;
	}

	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_eapol_event wlc_event_alloc failed\n", pub->unit));
		return;
	}

	e->event.event_type = WLC_E_WAI_MSG;
	e->event.status = WLC_E_STATUS_SUCCESS;
	e->event.reason = 0;
	e->event.auth_type = 0;

	e->event.datalen = len;
	e->data = MALLOC(pub->osh, e->event.datalen);
	if (e->data == NULL) {
		wlc_event_free(wlc->eventq, e);
		WL_ERROR(("wl%d: wlc_eapol_event MALLOc failed\n", pub->unit));
		return;
	}

	bcopy(data, e->data, e->event.datalen);

	wlc_event_if(wlc, bsscfg, e, ea);

	WL_WSEC(("wl%d: notify WAPID of WAI frame data len %d\n", pub->unit, len));
	wlc_process_event(wlc, e);
}
#endif /* BCMWAPI_WAI */

#endif /* !defined(WLNOEIND) */

#if defined(BCMDBG) || defined(BCMDBG_ERR)
static void
wlc_print_event(wlc_info_t *wlc, wlc_event_t *e)
{
	uint msg = e->event.event_type;
	struct ether_addr *addr = e->addr;
	uint result = e->event.status;
	uint auth_type = e->event.auth_type;
	const char *auth_str;
	const char *event_name;
	uint i;
	char eabuf[ETHER_ADDR_STR_LEN];
#if defined(BCMDBG) || defined(WLMSG_INFORM)
	uint status = e->event.reason;
	char ssidbuf[SSID_FMT_BUF_LEN];
#endif

	if (addr != NULL)
		bcm_ether_ntoa(addr, eabuf);
	else
		strncpy(eabuf, "<NULL>", 7);

	event_name = "UNKNOWN";
	for (i = 0; i < (uint)bcmevent_names_size; i++)
		if (bcmevent_names[i].event == msg)
			event_name = bcmevent_names[i].name;

	switch (msg) {
	case WLC_E_START:
	case WLC_E_DEAUTH:
	case WLC_E_ASSOC_IND:
	case WLC_E_REASSOC_IND:
	case WLC_E_DISASSOC:
	case WLC_E_EAPOL_MSG:
	case WLC_E_BCNRX_MSG:
	case WLC_E_BCNSENT_IND:
	case WLC_E_ROAM_PREP:
	case WLC_E_BCNLOST_MSG:
	case WLC_E_PROBREQ_MSG:
#ifdef WLP2P
	case WLC_E_PROBRESP_MSG:
	case WLC_E_P2P_PROBREQ_MSG:
#endif
#ifdef BCMWAPI_WAI
	case WLC_E_WAI_STA_EVENT:
	case WLC_E_WAI_MSG:
#endif /* BCMWAPI_WAI */
#ifdef WIN7
	case WLC_E_ASSOC_IND_NDIS:
	case WLC_E_REASSOC_IND_NDIS:
#endif
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s\n",
		WLCWLUNIT(wlc), event_name, eabuf));
		break;

	case WLC_E_ASSOC:
	case WLC_E_REASSOC:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, SUCCESS\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_TIMEOUT) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, TIMEOUT\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_ABORT) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, ABORT\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_NO_ACK) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, NO_ACK\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_UNSOLICITED) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, UNSOLICITED\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_FAIL) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, FAILURE, status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, (int)status));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, unexpected status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, (int)result));
		}
		break;

	case WLC_E_DEAUTH_IND:
	case WLC_E_DISASSOC_IND:
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, reason %d\n",
		    WLCWLUNIT(wlc), event_name, eabuf, (int)status));
		break;

	case WLC_E_AUTH:
	case WLC_E_AUTH_IND: {
		char err_msg[32];

		if (auth_type == DOT11_OPEN_SYSTEM)
			auth_str = "Open System";
		else if (auth_type == DOT11_SHARED_KEY)
			auth_str = "Shared Key";
		else {
			snprintf(err_msg, sizeof(err_msg), "AUTH unknown: %d", (int)auth_type);
			auth_str = err_msg;
		}
		if (msg == WLC_E_AUTH_IND) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, %s\n",
			    WLCWLUNIT(wlc), event_name, eabuf, auth_str));
		} else if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, %s, SUCCESS\n",
			    WLCWLUNIT(wlc), event_name, eabuf, auth_str));
		} else if (result == WLC_E_STATUS_TIMEOUT) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, %s, TIMEOUT\n",
			    WLCWLUNIT(wlc), event_name, eabuf, auth_str));
		} else if (result == WLC_E_STATUS_FAIL) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, %s, FAILURE, status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, auth_str, (int)status));
		}

		break;
	}
	case WLC_E_JOIN:
	case WLC_E_ROAM:
	case WLC_E_SET_SSID:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_FAIL) {
			WL_INFORM(("wl%d: MACEVENT: %s, failed\n",
			    WLCWLUNIT(wlc), event_name));
		} else if (result == WLC_E_STATUS_NO_NETWORKS) {
			WL_INFORM(("wl%d: MACEVENT: %s, no networks found\n",
			    WLCWLUNIT(wlc), event_name));
		} else if (result == WLC_E_STATUS_ABORT) {
			WL_INFORM(("wl%d: MACEVENT: %s, ABORT\n",
			    wlc->pub->unit, event_name));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, unexpected status %d\n",
			    WLCWLUNIT(wlc), event_name, (int)result));
		}
		break;

	case WLC_E_BEACON_RX:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, SUCCESS\n",
			    WLCWLUNIT(wlc), event_name));
		} else if (result == WLC_E_STATUS_FAIL) {
			WL_INFORM(("wl%d: MACEVENT: %s, FAIL\n",
			    WLCWLUNIT(wlc), event_name));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, result %d\n",
			    WLCWLUNIT(wlc), event_name, result));
		}
		break;

	case WLC_E_NDIS_LINK:

	case WLC_E_LINK:
		WL_INFORM(("wl%d: MACEVENT: %s %s\n",
		    WLCWLUNIT(wlc), event_name,
		    (e->event.flags&WLC_EVENT_MSG_LINK)?"UP":"DOWN"));
		break;

	case WLC_E_MIC_ERROR:
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, Group: %s, Flush Q: %s\n",
		           WLCWLUNIT(wlc), event_name, eabuf,
		           (e->event.flags&WLC_EVENT_MSG_GROUP)?"Yes":"No",
		           (e->event.flags&WLC_EVENT_MSG_FLUSHTXQ)?"Yes":"No"));
		break;

	case WLC_E_ICV_ERROR:
	case WLC_E_UNICAST_DECODE_ERROR:
	case WLC_E_MULTICAST_DECODE_ERROR:
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s\n",
		           WLCWLUNIT(wlc), event_name, eabuf));
		break;

	case WLC_E_TXFAIL:
		/* TXFAIL messages are too numerous for WL_INFORM() */
		break;

	case WLC_E_COUNTRY_CODE_CHANGED: {
		char cstr[16];
		memset(cstr, 0, sizeof(cstr));
		memcpy(cstr, e->data, MIN(e->event.datalen, sizeof(cstr) - 1));
		WL_INFORM(("wl%d: MACEVENT: %s New Country: %s\n", WLCWLUNIT(wlc),
		           event_name, cstr));
		break;
	}
	case WLC_E_PMKID_CACHE:
	case WLC_E_PRUNE:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;

	case WLC_E_RETROGRADE_TSF:
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s\n",
		    WLCWLUNIT(wlc), event_name, eabuf));
		break;

#ifdef WIFI_ACT_FRAME
	case WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE:
#endif
	case WLC_E_SCAN_COMPLETE:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, SUCCESS\n",
			    WLCWLUNIT(wlc), event_name));
		} else if (result == WLC_E_STATUS_ABORT) {
			WL_INFORM(("wl%d: MACEVENT: %s, ABORTED\n",
			    WLCWLUNIT(wlc), event_name));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, result %d\n",
			    WLCWLUNIT(wlc), event_name, result));
		}
		break;

	case WLC_E_AUTOAUTH:
		WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, result %d\n",
			WLCWLUNIT(wlc), event_name, eabuf, (int)result));
		break;

	case WLC_E_ADDTS_IND:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, SUCCESS\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_TIMEOUT) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, TIMEOUT\n",
			    WLCWLUNIT(wlc), event_name, eabuf));
		} else if (result == WLC_E_STATUS_FAIL) {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, FAILURE, status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, (int)status));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, unexpected status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, (int)result));
		}
		break;

	case WLC_E_DELTS_IND:
		if (result == WLC_E_STATUS_SUCCESS) {
			WL_INFORM(("wl%d: MACEVENT: %s success ...\n",
			    WLCWLUNIT(wlc), event_name));
		} else if (result == WLC_E_STATUS_UNSOLICITED) {
			WL_INFORM(("wl%d: MACEVENT: DELTS unsolicited %s\n",
			    WLCWLUNIT(wlc), event_name));
		} else {
			WL_INFORM(("wl%d: MACEVENT: %s, MAC %s, unexpected status %d\n",
			    WLCWLUNIT(wlc), event_name, eabuf, (int)result));
		}
		break;

	case WLC_E_PFN_NET_FOUND:
	case WLC_E_PFN_NET_LOST:
		WL_INFORM(("wl%d: PFNEVENT: %s, SSID %s, SSID len %d\n",
		    WLCWLUNIT(wlc), event_name,
		    (wlc_format_ssid(ssidbuf, e->data, e->event.datalen), ssidbuf),
		    e->event.datalen));
		break;

	case WLC_E_PSK_SUP:
		WL_INFORM(("wl%d: MACEVENT: %s, state %d, reason %d\n", WLCWLUNIT(wlc),
		           event_name, result, status));
		break;

#if defined(IBSS_PEER_DISCOVERY_EVENT)
	case WLC_E_IBSS_ASSOC:
		WL_INFORM(("wl%d: MACEVENT: %s, PEER %s\n", WLCWLUNIT(wlc), event_name, eabuf));
		break;
#endif /* defined(IBSS_PEER_DISCOVERY_EVENT) */

	case WLC_E_PSM_WATCHDOG:
		WL_INFORM(("wl%d: MACEVENT: %s, psmdebug 0x%x, phydebug 0x%x, psm_brc 0x%x\n",
		           WLCWLUNIT(wlc), event_name, result, status, auth_type));
		break;


	case WLC_E_TRACE:
		/* We don't want to trace the trace event */
		break;
#ifdef WLBTAMP
	case WLC_E_BTA_HCI_EVENT:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;
#endif

#ifdef WLP2P
	case WLC_E_P2P_DISC_LISTEN_COMPLETE:
#endif
	case WLC_E_RADIO:
	case WLC_E_IF:
	case WLC_E_EXTLOG_MSG:
	case WLC_E_RSSI:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;

	case WLC_E_PFN_SCAN_COMPLETE:
		WL_INFORM(("wl%d: PFNEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;

#ifdef WIFI_ACT_FRAME
	case WLC_E_ACTION_FRAME:
	case WLC_E_ACTION_FRAME_RX:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;
	case WLC_E_ACTION_FRAME_COMPLETE:
		WL_INFORM(("wl%d: MACEVENT: %s status: %s\n", WLCWLUNIT(wlc), event_name,
		           (result == WLC_E_STATUS_NO_ACK?"NO ACK":"ACK")));
		break;
#endif /* WIFI_ACT_FRAME */

#ifdef WIN7
	case WLC_E_PRE_ASSOC_IND:
	case WLC_E_PRE_REASSOC_IND:
	case WLC_E_AP_STARTED:
	case WLC_E_DFS_AP_STOP:
	case WLC_E_DFS_AP_RESUME:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;
#endif /* WIN7 */
	case WLC_E_CSA_COMPLETE_IND:
	case WLC_E_ESCAN_RESULT:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;

	case WLC_E_FIFO_CREDIT_MAP:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));
		break;

	case WLC_E_DCS_REQUEST:
		WL_INFORM(("wl%d: MACEVENT: %s\n", WLCWLUNIT(wlc), event_name));

	default:
		WL_INFORM(("wl%d: MACEVENT: UNKNOWN %d, MAC %s, result %d, status %d, auth %d\n",
		    WLCWLUNIT(wlc), msg, eabuf, (int)result, (int)status, (int)auth_type));
		break;
	}
}
#if WLC_E_LAST != 79
#error "You need to add wlc_dump_event support for the new event"
#endif
#endif /* BCMDBG || BCMDBG_ERR */

#ifdef STA
void
wlc_pmkid_event(wlc_bsscfg_t *cfg)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_event_t *e;
	uint32 i, pmkid_list_len = cfg->npmkid_cand * sizeof(pmkid_cand_t) + sizeof(uint32);
	struct {
		pmkid_cand_list_t pmkids;
		pmkid_cand_t foo[MAXPMKID-1];
	} pmkid_list;
	pmkid_cand_t *cand = (pmkid_cand_t *)&pmkid_list.pmkids.pmkid_cand[0];

#ifdef WLLMAC
	/* LMAC doesn't use these event */
	if (LMAC_ENAB(wlc->pub))
		return;
#endif

	bzero((char*)&pmkid_list, pmkid_list_len);

	e = wlc_event_alloc(wlc->eventq);
	if (e == NULL) {
		WL_ERROR(("wl%d: wlc_pmkid_event wlc_event_alloc failed\n", wlc->pub->unit));
		return;
	}

	e->event.event_type = WLC_E_PMKID_CACHE;

	/* creat a copy of the pmkid cand list, store the list elements in network order */
	pmkid_list.pmkids.npmkid_cand = hton32(cfg->npmkid_cand);

	for (i = 0; i < cfg->npmkid_cand; i++) {
		bcopy(&cfg->pmkid_cand[i].BSSID.octet[0], &cand->BSSID.octet[0],
			ETHER_ADDR_LEN);
		cand->preauth = cfg->pmkid_cand[i].preauth;
		cand++;
	}

	/* point the event data at it */
	e->event.datalen = pmkid_list_len;
	e->data = MALLOC(wlc->osh, e->event.datalen);
	if (e->data == NULL) {
		wlc_event_free(wlc->eventq, e);
		WL_ERROR(("wl%d: wlc_pmkid_event MALLOc failed\n", wlc->pub->unit));
		return;
	}

	bcopy(&pmkid_list, e->data, e->event.datalen);

	wlc_event_if(wlc, cfg, e, NULL);

	wlc_process_event(wlc, e);
}
#endif /* defined (STA) */

#ifdef WLCQ
static int
wlc_lq_channel_qa_eval(wlc_info_t *wlc)
{
	int k;
	int sample_count;
	int rssi_avg;
	int noise_est;
	int quality_metric;

	sample_count = (int)wlc->channel_qa_sample_num;
	rssi_avg = 0;
	for (k = 0; k < sample_count; k++)
		rssi_avg += wlc->channel_qa_sample[k];
	rssi_avg = (rssi_avg + sample_count/2) / sample_count;

	noise_est = rssi_avg;

	if (noise_est < -85)
		quality_metric = 3;
	else if (noise_est < -75)
		quality_metric = 2;
	else if (noise_est < -65)
		quality_metric = 1;
	else
		quality_metric = 0;

	WL_INFORM(("wl%d: %s: samples rssi {%d %d} avg %d qa %d\n",
		wlc->pub->unit, __FUNCTION__,
		wlc->channel_qa_sample[0], wlc->channel_qa_sample[1],
		rssi_avg, quality_metric));

	return (quality_metric);
}

/* this callback chain must defer calling phy_noise_sample_request */
static void
wlc_lq_channel_qa_sample_cb(wlc_info_t *wlc, uint8 channel, int8 noise_dbm)
{
	bool moretest = FALSE;

	if (!wlc->channel_qa_active)
		return;

	if (channel != wlc->channel_qa_channel) {
		/* bad channel, try again */
		WL_INFORM(("wl%d: %s: retry, samples from channel %d instead of channel %d\n",
		           wlc->pub->unit, __FUNCTION__, channel, wlc->channel_qa_channel));
		moretest = TRUE;
	} else {
		/* save the sample */
		wlc->channel_qa_sample[wlc->channel_qa_sample_num++] = (int8)noise_dbm;
		if (wlc->channel_qa_sample_num < WLC_CHANNEL_QA_NSAMP) {
			/* still need more samples */
			moretest = TRUE;
		} else {
			/* done with the channel quality measurement */
			wlc->channel_qa_active = FALSE;

			/* evaluate the samples to a quality metric */
			wlc->channel_quality = wlc_lq_channel_qa_eval(wlc);
		}
	}

	if (moretest)
		wlc_lq_channel_qa_sample_req(wlc);

}

static int
wlc_lq_channel_qa_start(wlc_info_t *wlc)
{
	/* do nothing if there is already a request for a measurement */
	if (wlc->channel_qa_active)
		return 0;

	WL_INFORM(("wl%d: %s: starting qa measure\n", wlc->pub->unit, __FUNCTION__));

	wlc->channel_qa_active = TRUE;

	wlc->channel_quality = -1;	/* clear to invalid value */
	wlc->channel_qa_sample_num = 0;	/* clear the sample array */

	wlc_lq_channel_qa_sample_req(wlc);

	return 0;
}

void
wlc_lq_channel_qa_sample_req(wlc_info_t *wlc)
{
	/* wait until after a scan if one is in progress */
	if (SCAN_IN_PROGRESS(wlc->scan)) {
		WL_NONE(("wl%d: %s: deferring sample request until after scan\n", wlc->pub->unit,
			__FUNCTION__));
		return;
	}

	wlc->channel_qa_channel = CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC);

	WL_NONE(("wl%d: %s(): requesting samples for channel %d\n", wlc->pub->unit,
	         __FUNCTION__, wlc->channel_qa_channel));

	WL_INFORM(("wlc_noise_cb(): WLC_NOISE_REQUEST_CQ.\n"));

	wlc_lq_noise_sample_request(wlc, WLC_NOISE_REQUEST_CQ, wlc->channel_qa_channel);

}
#endif /* defined(WLCQ)  */

void
wlc_lq_noise_cb(wlc_info_t *wlc, uint8 channel, int8 noise_dbm)
{
	if (wlc->noise_req & WLC_NOISE_REQUEST_SCAN) {
		if (wlc->phynoise_chan_scan == channel)
			wlc->phy_noise_list[channel] = noise_dbm;

		/* TODO - probe responses may have been constructed, fixup those dummy values
		 *  if being blocked by CQRM sampling at different channels, make another request
		 *     if we are still in the requested scan channel and scan hasn't finished yet
		 */
		wlc->noise_req &= ~WLC_NOISE_REQUEST_SCAN;
	}

#ifdef WLCQ
	if (wlc->noise_req & WLC_NOISE_REQUEST_CQ) {
		wlc->noise_req &= ~WLC_NOISE_REQUEST_CQ;
		WL_INFORM(("wlc_noise_cb(): WLC_NOISE_REQUEST_CQ.\n"));
		wlc_lq_channel_qa_sample_cb(wlc, channel, noise_dbm);
	}
#endif

#if defined(STA) && defined(WLRM)
	if (wlc->noise_req & WLC_NOISE_REQUEST_RM) {
		wlc->noise_req &= ~WLC_NOISE_REQUEST_RM;
		WL_INFORM(("wlc_noise_cb(): WLC_NOISE_REQUEST_RM.\n"));
		if (wlc->rm_info->rm_state->rpi_active) {
			if (wlc_rm_rpi_sample(wlc->rm_info, noise_dbm))
				wlc_lq_noise_sample_request(wlc, WLC_NOISE_REQUEST_RM,
				                       CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC));
		}
	}
#endif

	return;

}

void
wlc_lq_noise_sample_request(wlc_info_t *wlc, uint8 request, uint8 channel)
{
	bool sampling_in_progress = (wlc->noise_req != 0);

	WL_TRACE(("%s(): request=%d, channel=%d\n", __FUNCTION__, request, channel));

	switch (request) {
	case WLC_NOISE_REQUEST_SCAN:

		/* fill in dummy value in case the sampling failed or channel mismatch */
		wlc->phy_noise_list[channel] = PHY_NOISE_FIXED_VAL_NPHY;
		wlc->phynoise_chan_scan = channel;

		wlc->noise_req |= WLC_NOISE_REQUEST_SCAN;
		break;

	case WLC_NOISE_REQUEST_CQ:

		wlc->noise_req |= WLC_NOISE_REQUEST_CQ;
		break;

	case WLC_NOISE_REQUEST_RM:

		wlc->noise_req |= WLC_NOISE_REQUEST_RM;
		break;

	default:
		ASSERT(0);
		break;
	}

	if (sampling_in_progress)
		return;

	wlc_phy_noise_sample_request_external(wlc->band->pi);

	return;
}

/* Convert RX hardware status to standard format and send to wl_monitor
 * assume p points to plcp header
 */
static void
wlc_monitor(wlc_info_t *wlc, wlc_d11rxhdr_t *wrxh, void *p, struct wlc_if *wlcif)
{
	struct wl_rxsts sts;
	uint32 rx_tsf_l;
	ratespec_t rspec;
	uint16 chan_bw, chan_band, chan_num;

	ASSERT(p != NULL);

	rx_tsf_l = wlc_recover_tsf32(wlc, wrxh);

	bzero((void *)&sts, sizeof(wl_rxsts_t));

	sts.wlif = wlcif ? wlcif->wlif : NULL;

	sts.mactime = rx_tsf_l;
	sts.antenna = (wrxh->rxhdr.PhyRxStatus_0 & PRXS0_RXANT_UPSUBBAND) ? 1 : 0;
	sts.signal = wlc_lq_rssi_pktrxh_cal(wlc, wrxh);

	chan_bw = (wrxh->rxhdr.RxChan & RXS_CHAN_40) ? WL_CHANSPEC_BW_40 : WL_CHANSPEC_BW_20;
	chan_band = (wrxh->rxhdr.RxChan & RXS_CHAN_5G) ? WL_CHANSPEC_BAND_5G : WL_CHANSPEC_BAND_2G;
	if (chan_bw == WL_CHANSPEC_BW_40) {
		if (WLC_RX_CHANNEL(&wrxh->rxhdr) == CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC)) {
			chan_num = WLC_CHAN_CHANNEL(wrxh->rxhdr.RxChan);
			sts.chanspec = WLC_BAND_PI_RADIO_CHANSPEC;
		} else {
			chan_num = (WLC_RX_CHANNEL(&wrxh->rxhdr) - CH_10MHZ_APART);
			sts.chanspec = (chanspec_t)(chan_num | chan_bw |
			                            WL_CHANSPEC_CTL_SB_UPPER | chan_band);
		}
	} else {
		chan_num = WLC_RX_CHANNEL(&wrxh->rxhdr);
		sts.chanspec = (chanspec_t)(chan_num | chan_bw |
		                            WL_CHANSPEC_CTL_SB_NONE | chan_band);
	}

	sts.noise = wlc_phy_noise_avg((wlc_phy_t *)
	                              wlc->bandstate[CHSPEC_WLCBANDUNIT(sts.chanspec)]->pi);

	rspec = wlc_recv_compute_rspec(wrxh, PKTDATA(wlc->osh, p));

	/* prepare rate/modulation info */
	if (IS_MCS(rspec)) {
		/* prepare HT rate/modulation info */
		sts.datarate = 0;
		sts.mcs = (rspec & RSPEC_RATE_MASK);

		if (chan_bw == WL_CHANSPEC_BW_40) {
			uint32 bw = RSPEC_GET_BW(rspec);

			if (bw == PHY_TXC1_BW_20MHZ)
				sts.htflags = WL_RXS_HTF_20L;
			else if (bw == PHY_TXC1_BW_20MHZ_UP)
				sts.htflags = WL_RXS_HTF_20U;
			else
				sts.htflags = WL_RXS_HTF_40;
		}

		if (RSPEC_ISSGI(rspec))
			sts.htflags |= WL_RXS_HTF_SGI;
		if (rspec & RSPEC_LDPC_CODING)
			sts.htflags |= WL_RXS_HTF_LDPC;
		sts.htflags |= (RSPEC_STC(rspec) << WL_RXS_HTF_STBC_SHIFT);
	} else {
		/* round non-HT data rate to nearest 500bkps unit */
		sts.datarate = RSPEC2KBPS(rspec)/500;
	}

	sts.pktlength = wrxh->rxhdr.RxFrameSize - D11_PHY_HDR_LEN;
	sts.sq = ((wrxh->rxhdr.PhyRxStatus_1 & PRXS1_SQ_MASK) >> PRXS1_SQ_SHIFT);

#if PHY_TYPE_A != WL_RXS_PHY_A
#error "RxChan phy type does not match"
#endif

	sts.phytype = WLC_CHAN_PHYTYPE(wrxh->rxhdr.RxChan);

	if (IS_CCK(rspec)) {
		sts.encoding = WL_RXS_ENCODING_DSSS_CCK;
		sts.preamble = (wrxh->rxhdr.PhyRxStatus_0 & PRXS0_SHORTH) ?
			WL_RXS_PREAMBLE_SHORT : WL_RXS_PREAMBLE_LONG;
	} else if (IS_OFDM(rspec)) {
		sts.encoding = WL_RXS_ENCODING_OFDM;
		sts.preamble = WL_RXS_PREAMBLE_SHORT;
	}
#ifdef WL11N
	else {	/* MCS rate */
		sts.encoding = WL_RXS_ENCODING_HT;
		if (WLCISHTPHY(wlc->band)) {
			sts.preamble = (D11HT_MMPLCPLen(&wrxh->rxhdr) != 0) ?
				WL_RXS_PREAMBLE_HT_MM : WL_RXS_PREAMBLE_HT_GF;
		} else {
			sts.preamble = (D11N_MMPLCPLen(&wrxh->rxhdr) != 0) ?
				WL_RXS_PREAMBLE_HT_MM : WL_RXS_PREAMBLE_HT_GF;
		}
	}
#endif
	/* translate error code */
	if (wrxh->rxhdr.RxStatus1 & RXS_DECERR)
		sts.pkterror |= WL_RXS_DECRYPT_ERR;
	if (wrxh->rxhdr.RxStatus1 & RXS_FCSERR)
		sts.pkterror |= WL_RXS_CRC_ERROR;

	/* If it's a runt frame or with FCS error, don't process it further */
	if (!((uint)PKTLEN(wlc->osh, p) >= D11_PHY_HDR_LEN + sizeof(uint16)) ||
	    (wrxh->rxhdr.RxStatus1 & RXS_FCSERR))
		goto sendup;

#ifdef WL11N
	{
		uint8 *plcp;
		struct dot11_header *h;
		uint16 subtype;

		plcp = PKTDATA(wlc->osh, p);
		h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);
		subtype = (ltoh16(h->fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT;

		if ((subtype == FC_SUBTYPE_QOS_DATA) || (subtype == FC_SUBTYPE_QOS_NULL)) {

			/* A-MSDU parsing */
			if (WLPKTTAG(p)->flags & WLF_HWAMSDU) {
				/* it's chained buffer, break it if necessary */
				sts.nfrmtype |= WL_RXS_NFRM_AMSDU_FIRST | WL_RXS_NFRM_AMSDU_SUB;
			}

			/* A-MPDU parsing */
			if ((wrxh->rxhdr.PhyRxStatus_0 & PRXS0_FT_MASK) == PRXS0_PREN) {
				if (WLC_IS_MIMO_PLCP_AMPDU(plcp)) {
					sts.nfrmtype |= WL_RXS_NFRM_AMPDU_FIRST;
				} else if (!(plcp[0] | plcp[1] | plcp[2])) {
					sts.nfrmtype |= WL_RXS_NFRM_AMPDU_SUB;
				}
			}
		}
	}
#endif	/* WL11N */


sendup:


	wl_monitor(wlc->wl, &sts, p);
}

#ifdef WLTXMONITOR
/* Convert TX hardware status to standard format and send to wl_tx_monitor
 * assume p points to plcp header
 */
void
wlc_tx_monitor(wlc_info_t *wlc, d11txh_t *txh, tx_status_t *txs, void *p, struct wlc_if *wlcif)
{
	struct wl_txsts sts;
	ratespec_t rspec;
	uint16 chan_bw, chan_band, chan_num;
	uint16 xfts;
	uint8 frametype, *plcp;
	uint16 phytxctl1, phytxctl;
	struct dot11_header *h;

	ASSERT(p != NULL);

	bzero((void *)&sts, sizeof(wl_txsts_t));

	sts.wlif = wlcif ? wlcif->wlif : NULL;

	sts.mactime = txs->lasttxtime;
	sts.retries = (txs->status & TX_STATUS_FRM_RTX_MASK) >> TX_STATUS_FRM_RTX_SHIFT;

	plcp = (uint8 *)(txh + 1);
	PKTPULL(wlc->osh, p, sizeof(d11txh_t));

	xfts = ltoh16(txh->XtraFrameTypes);
	chan_num = xfts >> XFTS_CHANNEL_SHIFT;
	phytxctl = ltoh16(txh->PhyTxControlWord);
	phytxctl1 = ltoh16(txh->PhyTxControlWord_1);
	chan_bw = ((phytxctl1 & PHY_TXC1_BW_MASK) == PHY_TXC1_BW_40MHZ)?
	        WL_CHANSPEC_BW_40: WL_CHANSPEC_BW_20;
#ifdef WL11N
	chan_band = (chan_num > CH_MAX_2G_CHANNEL) ? WL_CHANSPEC_BAND_5G : WL_CHANSPEC_BAND_2G;
	if ((phytxctl1 & PHY_TXC1_BW_MASK) == PHY_TXC1_BW_20MHZ_UP) {
		sts.chanspec = (chanspec_t)(chan_num | chan_bw |
		                            WL_CHANSPEC_CTL_SB_UPPER | chan_band);
	} else if (chan_bw == WL_CHANSPEC_BW_40) {
		if (chan_num == CHSPEC_CHANNEL(WLC_BAND_PI_RADIO_CHANSPEC)) {
			sts.chanspec = WLC_BAND_PI_RADIO_CHANSPEC;
		} else {
			sts.chanspec = (chanspec_t)(chan_num | chan_bw |
			                            WL_CHANSPEC_CTL_SB_UPPER | chan_band);
		}
	} else {
		sts.chanspec = (chanspec_t)(chan_num | chan_bw |
		                            WL_CHANSPEC_CTL_SB_NONE | chan_band);
	}
#endif /* WL11N */

	frametype = ltoh16(txh->PhyTxControlWord) & PHY_TXC_FT_MASK;
#ifdef WL11N
	if (frametype == FT_HT || frametype == FT_N) {
		/* prepare HT rate/modulation info */
		sts.datarate = 0;
		sts.mcs = plcp[0] & MIMO_PLCP_MCS_MASK;
		if (chan_bw == WL_CHANSPEC_BW_40) {
			sts.htflags = WL_RXS_HTF_40;
		} else if ((phytxctl1 & PHY_TXC1_BW_MASK) == PHY_TXC1_BW_20MHZ_UP) {
			sts.htflags = WL_RXS_HTF_20U;
		} else {
			sts.htflags = WL_RXS_HTF_20L;
		}

		if (PLCP3_ISSGI(plcp[3]))
			sts.htflags |= WL_RXS_HTF_SGI;
		sts.htflags |= (((plcp[3] & PLCP3_STC_MASK) >> PLCP3_STC_SHIFT)
		                << WL_RXS_HTF_STBC_SHIFT);

		sts.encoding = WL_RXS_ENCODING_HT;
		sts.preamble = (phytxctl & PHY_TXC_SHORT_HDR) ?
		        WL_RXS_PREAMBLE_HT_GF: WL_RXS_PREAMBLE_HT_MM;
	} else
#endif  /* WL11N */
		if (frametype == FT_OFDM) {
		rspec = ofdm_plcp_to_rspec(plcp[0]);
		sts.datarate = RSPEC2KBPS(rspec)/500;
		sts.encoding = WL_RXS_ENCODING_OFDM;
		sts.preamble = WL_RXS_PREAMBLE_SHORT;
	} else {
		ASSERT(frametype == FT_CCK);
		sts.datarate = plcp[0]/5;
		sts.encoding = WL_RXS_ENCODING_DSSS_CCK;
		sts.preamble = (phytxctl & PHY_TXC_SHORT_HDR) ?
		        WL_RXS_PREAMBLE_SHORT : WL_RXS_PREAMBLE_LONG;
	}

	sts.pktlength = PKTLEN(wlc->pub->osh, p) - D11_PHY_HDR_LEN;

#if PHY_TYPE_A != WL_RXS_PHY_A
#error "RxChan phy type does not match"
#endif

	h = (struct dot11_header *)(plcp + D11_PHY_HDR_LEN);

	if (!ETHER_ISMULTI(txh->TxFrameRA) &&
	    ((txs->status & TX_STATUS_MASK) == TX_STATUS_NO_ACK))
	        sts.txflags |= WL_TXS_TXF_FAIL;
	if (ltoh16(txh->MacTxControlLow) & TXC_SENDCTS)
		sts.txflags |= WL_TXS_TXF_CTS;
	else if (ltoh16(txh->MacTxControlLow) & TXC_SENDRTS)
		sts.txflags |= WL_TXS_TXF_RTSCTS;

#ifdef WL11N
	{
		uint8 *plcp;
		uint16 subtype;

		plcp = PKTDATA(wlc->osh, p);
		subtype = (ltoh16(h->fc) & FC_SUBTYPE_MASK) >> FC_SUBTYPE_SHIFT;

		if ((subtype == FC_SUBTYPE_QOS_DATA) || (subtype == FC_SUBTYPE_QOS_NULL)) {

			/* A-MSDU parsing */
			if (WLPKTTAG(p)->flags & WLF_AMSDU) {
				/* it's chained buffer, break it if necessary */
				sts.nfrmtype |= WL_RXS_NFRM_AMSDU_FIRST | WL_RXS_NFRM_AMSDU_SUB;
			} else if (frametype == FT_HT || frametype == FT_N) { /* A-MPDU parsing */
				if (WLC_IS_MIMO_PLCP_AMPDU(plcp)) {
					sts.nfrmtype |= WL_RXS_NFRM_AMPDU_FIRST;
				} else if (!(plcp[0] | plcp[1] | plcp[2])) {
					sts.nfrmtype |= WL_RXS_NFRM_AMPDU_SUB;
				}
			}
		}
	}
#endif	/* WL11N */

	wl_tx_monitor(wlc->wl, &sts, p);
}
#endif /* WLTXMONITOR */

void
wlc_uint64_add(uint32* high, uint32* low, uint32 inc_high, uint32 inc_low)
{
	uint32 old_l;
	uint32 new_l;

	old_l = *low;
	new_l = old_l + inc_low;
	*low = new_l;
	if (new_l < old_l) {
		/* carry */
		inc_high += 1;
	}
	*high += inc_high;
}

void
wlc_uint64_sub(uint32* a_high, uint32* a_low, uint32 b_high, uint32 b_low)
{
	if (b_low > *a_low) {
		/* low half needs a carry */
		b_high += 1;
	}
	*a_low -= b_low;
	*a_high -= b_high;
}

bool
wlc_uint64_lt(uint32 a_high, uint32 a_low, uint32 b_high, uint32 b_low)
{
	return (a_high < b_high ||
		(a_high == b_high && a_low < b_low));
}

#ifdef STA

static void
wlc_freqtrack(wlc_info_t *wlc)
{
	if (wlc->freqtrack_override != FREQTRACK_AUTO)
		return;

	ASSERT(wlc->pub->associated);

	if (!wlc->freqtrack && CHSPEC_IS2G(wlc->home_chanspec)) {
		WL_INFORM(("wl%d: FREQTRACK: Increasing freq tracking bw\n", wlc->pub->unit));
		wlc->freqtrack = TRUE;
		wlc->freqtrack_starttime = wlc->pub->now;
		wlc->freqtrack_attempts++;

		if (WLCISGPHY(wlc->band))
			wlc_phy_freqtrack_start(wlc->band->pi);
	}
}

void
wlc_freqtrack_reset(wlc_info_t *wlc)
{
	if (wlc->freqtrack_override != FREQTRACK_AUTO)
		return;

	wlc->freqtrack_attempts = 0;
	wlc->freqtrack_starttime = 0;

	if (wlc->freqtrack) {
		wlc->freqtrack = FALSE;

		if (WLCISGPHY(wlc->band))
			wlc_phy_freqtrack_end(wlc->band->pi);
	}
}

static void
wlc_freqtrack_verify(wlc_info_t *wlc)
{
	if (wlc->freqtrack_override != FREQTRACK_AUTO)
		return;

	ASSERT((wlc->freqtrack_attempts > 0) &&
		(wlc->freqtrack_attempts <= WLC_FREQTRACK_MIN_ATTEMPTS));

	if (wlc->freqtrack) {
		int idx;
		wlc_bsscfg_t *cfg;
		int count = 0;
		FOREACH_AS_STA(wlc, idx, cfg) {
			if (cfg->BSS && cfg->roam->time_since_bcn != 0)
				count ++;
		}
		if (count == 0) {
			/* Restore the frequency tracking bandwidth and check if we get
			 * beacons with the default settings. We will try this a few times
			 * before committing to the wide bandwidth
			 */
			WL_INFORM(("wl%d: FREQTRACK: Restoring freq tracking bw (attempts = %d)\n",
			           wlc->pub->unit, wlc->freqtrack_attempts));

			wlc->freqtrack = FALSE;

			if (WLCISGPHY(wlc->band))
				wlc_phy_freqtrack_end(wlc->band->pi);
		} else if ((wlc->pub->now - wlc->freqtrack_starttime) > WLC_FREQTRACK_DETECT_TIME) {
			/* We increased the bandwidth but did not get any beacons */
			wlc_freqtrack_reset(wlc);
		}
	}
	else if ((wlc->pub->now - wlc->freqtrack_starttime) > WLC_FREQTRACK_TIMEOUT) {
		/* Either the link is down or we have been receiving beacons with
		 * the default freq tracking b/w, for quite some time now. Clear
		 * the number of attempts.
		 */
		wlc_freqtrack_reset(wlc);
	}
}

#endif	/* STA */

#if defined(WL11N) || defined(WLTEST)
int
wlc_set_nrate_override(wlc_info_t *wlc, wlcband_t *cur_band, int32 int_val)
{
	uint8 stf = (int_val & NRATE_STF_MASK) >> NRATE_STF_SHIFT;
	uint8 rate = int_val & NRATE_RATE_MASK;
	ratespec_t rspec;
	bool ismcs = ((int_val & NRATE_MCS_INUSE) == NRATE_MCS_INUSE);
	bool issgi = ((int_val & NRATE_SGI_MASK) >> NRATE_SGI_SHIFT);
	bool override_mcs_only = ((int_val & NRATE_OVERRIDE_MCS_ONLY)
				   == NRATE_OVERRIDE_MCS_ONLY);
	int bcmerror = 0;

	/* validate the combination of rate/mcs/stf is allowed */
	if (N_ENAB(wlc->pub) && ismcs) {
		/* mcs only allowed when nmode */
		if (stf > PHY_TXC1_MODE_SDM) {
			bcmerror = BCME_RANGE;
			goto done;
		}

		/* mcs 32 is a special case, DUP mode 40 only */
		if (rate == 32) {
			if (!CHSPEC_IS40(wlc->home_chanspec) ||
			    ((stf != PHY_TXC1_MODE_SISO) && (stf != PHY_TXC1_MODE_CDD))) {
				bcmerror = BCME_RANGE;
				goto done;
			}
		} else if (rate > HIGHEST_SINGLE_STREAM_MCS) {
			/* mcs > 7 must use stf SDM */
			if (stf != PHY_TXC1_MODE_SDM) {
				WL_INFORM(("wl%d: forced SDM mode for mcs %d\n",
				wlc->pub->unit, rate));
				stf = PHY_TXC1_MODE_SDM;
			}

			if ((wlc->stf->txstreams == 2 && rate > 15) ||
				(wlc->stf->txstreams == 3 && rate > 23)) {
				WL_ERROR(("wl%d: %s: Invalid mcs %d for %d core(s) enabled\n",
					wlc->pub->unit, __FUNCTION__, rate, wlc->stf->txstreams));
				bcmerror = BCME_RANGE;
				goto done;
			}
		} else {
			/* MCS 0-7 may use SISO, CDD, and for phy_rev >= 3 STBC */
			if ((stf > PHY_TXC1_MODE_STBC) ||
			    (!WLC_STBC_CAP_PHY(wlc) && (stf == PHY_TXC1_MODE_STBC))) {
				bcmerror = BCME_RANGE;
				goto done;
			}
		}
	} else if (IS_OFDM(rate)) {
		if ((stf != PHY_TXC1_MODE_CDD) && (stf != PHY_TXC1_MODE_SISO)) {
			bcmerror = BCME_RANGE;
			goto done;
		}
	} else if (IS_CCK(rate)) {
		if ((cur_band->bandtype != WLC_BAND_2G) || (stf != PHY_TXC1_MODE_SISO)) {
			bcmerror = BCME_RANGE;
			goto done;
		}
	} else {
		bcmerror = BCME_RANGE;
		goto done;
	}
	/* make sure multiple antennae are available for non-siso rates */
	if ((stf != PHY_TXC1_MODE_SISO) && (wlc->stf->txstreams == 1)) {
		bcmerror = BCME_RANGE;
		goto done;
	}

	rspec = rate;
	if (ismcs) {
		rspec |= RSPEC_MIMORATE;
		/* For STBC populate the STC field of the ratespec */
		if (stf == PHY_TXC1_MODE_STBC) {
			uint8 stc;
			stc = 1;	/* Nss for single stream is always 1 */
			rspec |= (stc << RSPEC_STC_SHIFT);
		}
	}

	rspec |= (stf << RSPEC_STF_SHIFT);

	if (override_mcs_only)
		rspec |= RSPEC_OVERRIDE_MCS_ONLY;

	if (issgi)
		 rspec |= RSPEC_SHORT_GI;

	if ((rate != 0) && !wlc_valid_rate(wlc, rspec, cur_band->bandtype, TRUE)) {
		bcmerror = BCME_RANGE;
		goto done;
	}

	/* set the rspec_override [current band only] */
	cur_band->rspec_override = (rspec | RSPEC_OVERRIDE);
done:
	return bcmerror;
}
#endif /* defined(WL11N) || defined(WLTEST) */

/* set a legacy CCK/OFDM rate */
int
wlc_set_rate_override(wlc_info_t *wlc, int band, int32 rate, bool mcast)
{
	wlcband_t *bandp;

	if (rate == -1)
		rate = 0;

	switch (band) {
	case WLC_BAND_AUTO:
		if (IS_MBAND_UNLOCKED(wlc)) {
			WL_ERROR(("wl%d: wlc_set_rate_override: band must be set\n",
				wlc->pub->unit));
			return BCME_ERROR;
		}
		bandp = wlc->band;
		break;
	case WLC_BAND_5G:
		if (!BAND_5G(wlc->band->bandtype) && (NBANDS(wlc) <= 1)) {
			WL_ERROR(("wl%d: wlc_set_rate_override: 5G band not available\n",
				wlc->pub->unit));
			return BCME_ERROR;
		}
		bandp = wlc->bandstate[BAND_5G_INDEX];
		break;
	case WLC_BAND_2G:
		if (!BAND_2G(wlc->band->bandtype) && (NBANDS(wlc) <= 1)) {
			WL_ERROR(("wl%d: wlc_set_rate_override: 2.4G band not available\n",
				wlc->pub->unit));
			return BCME_ERROR;
		}
		bandp = wlc->bandstate[BAND_2G_INDEX];
		break;
	default:
		WL_ERROR(("wl%d: wlc_set_rate_override: invalid band %d\n", wlc->pub->unit, band));
		return BCME_ERROR;
	}

	/* check for a valid rate */
	if ((rate != 0) && (!wlc_valid_rate(wlc, rate, band, TRUE)))
		return BCME_ERROR;

	/* allow only CCK if gmode == GMODE_LEGACY_B */
	if (BAND_2G(bandp->bandtype) && (bandp->gmode == GMODE_LEGACY_B) &&
	    (rate != 0) && !IS_CCK(rate))
		return BCME_ERROR;

	/* make sure multiple antennae are available for non-siso rates */
	if ((RSPEC_STF(rate) != PHY_TXC1_MODE_SISO) && (wlc->stf->txstreams == 1))
		return BCME_ERROR;

	if (mcast) {
		bandp->mrspec_override = rate;
	} else {
		bandp->rspec_override = rate;
	}

	if (!mcast) {
		wlc_reprate_init(wlc);
	}

	return 0;
}

int
wlc_sta_info(wlc_info_t *wlc, wlc_bsscfg_t *bsscfg, const struct ether_addr *ea, void *buf, int len)
{
	sta_info_t sta;
	struct scb *scb;
	int bandunit;
	int copy_len;

	ASSERT(ea != NULL);
	if (ea == NULL)
		return (BCME_BADARG);

	ASSERT(bsscfg != NULL);
	if (bsscfg->up)
		bandunit = CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec);
	else
		bandunit = CHSPEC_WLCBANDUNIT(wlc->home_chanspec);

	if ((scb = wlc_scbfindband(wlc, ea, bandunit)) == NULL)
		return (BCME_BADADDR);

	/* fill in the sta_info struct */
	bzero(&sta, sizeof(sta_info_t));
	sta.ver = WL_STA_VER;
	sta.len = sizeof(sta_info_t);
	bcopy(ea, &sta.ea, ETHER_ADDR_LEN);
	bcopy(&scb->rateset, &sta.rateset, sizeof(wl_rateset_t));
	sta.idle = wlc->pub->now - scb->used;
	sta.flags = 0;
	sta.in = 0;
	if (scb->flags & SCB_BRCM)
		sta.flags |= WL_STA_BRCM;
	if (scb->flags & SCB_WMECAP)
		sta.flags |= WL_STA_WME;
#ifdef WLAFTERBURNER
	if (scb->flags & SCB_ABCAP)
		sta.flags |= WL_STA_ABCAP;
#endif /* WLAFTERBURNER */
	if (SCB_AUTHENTICATED(scb))
		sta.flags |= WL_STA_AUTHE;
	if (SCB_ASSOCIATED(scb)) {
		sta.flags |= WL_STA_ASSOC;
		sta.in = wlc->pub->now - scb->assoctime;
	}
	if (SCB_AUTHORIZED(scb))
		sta.flags |= WL_STA_AUTHO;
	if (AC_BITMAP_TST(scb->apsd.ac_defl, AC_BE))
		sta.flags |= WL_STA_APSD_BE;
	if (AC_BITMAP_TST(scb->apsd.ac_defl, AC_BK))
		sta.flags |= WL_STA_APSD_BK;
	if (AC_BITMAP_TST(scb->apsd.ac_defl, AC_VI))
		sta.flags |= WL_STA_APSD_VI;
	if (AC_BITMAP_TST(scb->apsd.ac_defl, AC_VO))
		sta.flags |= WL_STA_APSD_VO;
	sta.listen_interval_inms = 0;

	if (SCB_WDS(scb)) {
		sta.flags |= WL_STA_WDS;
		if (scb->flags & SCB_WDS_LINKUP)
			sta.flags |= WL_STA_WDS_LINKUP;
	}
	if (BSSCFG_AP(scb->bsscfg)) {
		if (SCB_PS(scb))
			sta.flags |= WL_STA_PS;
		sta.cap = scb->cap;
		sta.listen_interval_inms = scb->listen * wlc->default_bss->beacon_period;
	}
	if (SCB_HT_CAP(scb)) {
		sta.flags |= WL_STA_N_CAP;
	}

	if (len < (int)sizeof(sta_info_t))
		copy_len = WL_OLD_STAINFO_SIZE;
	else {
		copy_len = sizeof(sta_info_t);
#ifdef WLCNTSCB
		sta.flags |= WL_STA_SCBSTATS;
		sta.tx_pkts = scb->scb_stats.tx_pkts;
		sta.tx_failures = scb->scb_stats.tx_failures;
		sta.rx_ucast_pkts = scb->scb_stats.rx_ucast_pkts;
		sta.rx_mcast_pkts = scb->scb_stats.rx_mcast_pkts;
		sta.tx_rate = RSPEC2KBPS(scb->scb_stats.tx_rate);
		sta.rx_rate = RSPEC2KBPS(scb->scb_stats.rx_rate);
		sta.rx_decrypt_succeeds = scb->scb_stats.rx_decrypt_succeeds;
		sta.rx_decrypt_failures = scb->scb_stats.rx_decrypt_failures;
#endif /* WLCNTSCB */
	}

	/* bcopy to avoid alignment issues */
	bcopy(&sta, buf, copy_len);

	return (0);
}


#ifndef WLLMAC_ONLY
#if defined(BCMDBG_DUMP)
typedef struct _shmem_list {
	uint16	start;
	uint16	end;
} shmem_list_t;

static int
wlc_dump_shmem(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	uint i;
	uint16 val, addr;

	static const shmem_list_t shmem_list[] = {
		{0x0,	0x80},
		{0x100, 0x500},
		{0xbb6, 0xbc4}
	};

	/* if multiband, band must be set */
	if (IS_MBAND_UNLOCKED(wlc)) {
		WL_ERROR(("wl%d: %s: band must be locked\n", wlc->pub->unit, __FUNCTION__));
		return BCME_NOTBANDLOCKED;
	}
	if (!wlc->clk) {
		WL_ERROR(("wl%d: %s: clock must be on\n", wlc->pub->unit, __FUNCTION__));
		return BCME_NOCLK;
	}
	for (i = 0; i < ARRAYSIZE(shmem_list); i++) {
		for (addr = shmem_list[i].start; addr < shmem_list[i].end; addr += 2) {
			val = wlc_read_shm(wlc, addr);
			bcm_bprintf(b, "0x%03x * 2: 0x%03x 0x%04x\n", addr >> 1,
			            addr, val);
		}
	}

	return 0;
}
#endif 

#if defined(BCMDBG_DUMP)
static int
wlc_tsf_dump(wlc_info_t *wlc, struct bcmstrbuf *b)
{
	d11regs_t *regs;
	uint32 tsf_hi, tsf_lo;
	uint32 tsf_cfprep, tsf_cfpstart;
	osl_t *osh;

	/* Entry function checks clk due to IOVF_GET_CLK flag */
	if (!wlc->clk)
		return BCME_NOCLK;

	regs = wlc->regs;
	osh = wlc->osh;

	wlc_read_tsf(wlc, &tsf_lo, &tsf_hi);

	tsf_cfprep = R_REG(osh, &regs->tsf_cfprep);
	tsf_cfpstart = R_REG(osh, &regs->tsf_cfpstart);
	bcm_bprintf(b, "TSF: 0x%08x 0x%08x CFPSTART: 0x%08x CFPREP: 0x%08x\n",
		tsf_hi, tsf_lo, tsf_cfpstart, tsf_cfprep);

	return 0;
}
#endif 
#endif /* WLLMAC_ONLY */

#if defined(BCMDBG) || defined(WLNINTENDO2)
/* reset the TSF register to the given value */
static void
wlc_tsf_set(wlc_info_t *wlc, uint32 tsf_l, uint32 tsf_h)
{
	osl_t *osh;
	osh = wlc->osh;

	W_REG(osh, &wlc->regs->tsf_timerlow, tsf_l);
	W_REG(osh, &wlc->regs->tsf_timerhigh, tsf_h);
}
#endif /* BCMDBG */

#if defined(BCMDBG) || defined(WLMCHAN) || defined(WLNINTENDO2)
/* adjust the TSF register by a 32 bit delta */
void
wlc_tsf_adjust(wlc_info_t *wlc, int delta)
{
	uint32 tsf_l, tsf_h;
	uint32 delta_h;
	osl_t *osh;

	osh = wlc->osh;

	/* adjust the tsf time by offset */
	wlc_read_tsf(wlc, &tsf_l, &tsf_h);
	/* check for wrap:
	 * if we are close to an overflow (2 ms) from tsf_l to high,
	 * make sure we did not read tsf_h after the overflow
	 */
	if (tsf_l > (uint32)(-2000)) {
		uint32 tsf_l_new;
		tsf_l_new = R_REG(osh, &wlc->regs->tsf_timerlow);
		/* update the tsf_h if tsf_l rolled over since we do not know if we read tsf_h
		 * before or after the roll over
		 */
		if (tsf_l_new < tsf_l)
			tsf_h = R_REG(osh, &wlc->regs->tsf_timerhigh);
		tsf_l = tsf_l_new;
	}

	/* sign extend delta to delta_h */
	if (delta < 0)
		delta_h = -1;
	else
		delta_h = 0;

	wlc_uint64_add(&tsf_h, &tsf_l, delta_h, (uint32)delta);

	W_REG(osh, &wlc->regs->tsf_timerlow, tsf_l);
	W_REG(osh, &wlc->regs->tsf_timerhigh, tsf_h);
}
#endif /* BCMDBG || WLMCHAN */

int
wlc_txq_scb_init(void *ctx, struct scb *scb)
{
	/* Init the basic feature tx path to regular tx function */
	wlc_txmod_config((wlc_info_t *)ctx, scb, TXMOD_TRANSMIT);
	return 0;
}

static void
wlc_pktq_scb_free(wlc_info_t *wlc, struct pktq *q, struct scb *remove)
{
	int prec;
	void *head_pkt, *pkt;

	PKTQ_PREC_ITER(q, prec) {
		head_pkt = NULL;
		while (pktq_ppeek(q, prec) != head_pkt) {
			pkt = pktq_pdeq(q, prec);
			if (WLPKTTAGSCBGET(pkt) != remove) {
				if (!head_pkt)
					head_pkt = pkt;
				pktq_penq(q, prec, pkt);
			} else
				PKTFREE(wlc->osh, pkt, TRUE);
		}
	}
}

void
wlc_txq_scb_free_notify(void *context, struct scb *remove)
{
	wlc_info_t *wlc = (wlc_info_t *) context;
	wlc_txq_info_t *qi;

	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
		wlc_pktq_scb_free(wlc, &qi->q, remove);
	}

#ifdef WL_BSSCFG_TX_SUPR
	if (remove->bsscfg != NULL)
		wlc_pktq_scb_free(wlc, remove->bsscfg->psq, remove);
#endif
}

/* formula:  IDLE_BUSY_RATIO_X_16 = (100-duty_cycle)/duty_cycle*16 */
int
wlc_duty_cycle_set(wlc_info_t *wlc, int duty_cycle, bool isOFDM, bool writeToShm)
{
	int idle_busy_ratio_x_16 = 0;
	uint offset = isOFDM ? M_TX_IDLE_BUSY_RATIO_X_16_OFDM :M_TX_IDLE_BUSY_RATIO_X_16_CCK;
	if (duty_cycle > 100 || duty_cycle < 0) {
		WL_ERROR(("wl%d:  duty cycle value off limit\n", wlc->pub->unit));
		return BCME_RANGE;
	}
	if (duty_cycle)
		idle_busy_ratio_x_16 = (100 - duty_cycle) * 16 / duty_cycle;
	/* Only write to shared memory  when wl is up */
	if (writeToShm)
		wlc_write_shm(wlc, offset, (uint16)idle_busy_ratio_x_16);

	return BCME_OK;
}

/* Register the function to handle this feature */
void
wlc_txmod_fn_register(wlc_info_t *wlc, scb_txmod_t feature_id, void *ctx, txmod_fns_t fns)
{
	ASSERT(feature_id < TXMOD_LAST);
	/* tx_fn can't be NULL */
	ASSERT(fns.tx_fn != NULL && fns.pktcnt_fn != NULL);
	wlc->txmod_fns[feature_id].tx_fn = fns.tx_fn;
	wlc->txmod_fns[feature_id].deactivate_notify_fn = fns.deactivate_notify_fn;
	wlc->txmod_fns[feature_id].activate_notify_fn = fns.activate_notify_fn;
	wlc->txmod_fns[feature_id].pktcnt_fn = fns.pktcnt_fn;
	wlc->txmod_fns[feature_id].ctx = ctx;
}

/* Add the fid to handle packets for this SCB, if allowed */
void
wlc_txmod_config(wlc_info_t *wlc, struct scb *scb, scb_txmod_t fid)
{
	ASSERT(fid < TXMOD_LAST);

	/* Don't do anything if not yet registered or
	 * already configured
	 */
	if ((wlc->txmod_fns[fid].tx_fn == NULL) ||
	    (SCB_TXMOD_CONFIGURED(scb, fid)))
		return;

	/* Indicate that the feature is configured */
	scb->tx_path[fid].configured = TRUE;

	ASSERT(!SCB_TXMOD_ACTIVE(scb, fid));
	/* Try to activate this feature by adding it to the path
	 * If conflicting features exist in the path, then
	 *     - If this feature is of higher precedence, deactivate other features
	 *     - Else, mark this feature deactivated
	 * Note: When evicting other features, they remain 'configured'
	 */
	switch (fid) {
	case TXMOD_APPS:
		/* Deactivate CRAM/AMSDU */
		wlc_scb_txmod_deactivate(wlc, scb, TXMOD_CRAM);
		wlc_scb_txmod_deactivate(wlc, scb, TXMOD_AMSDU);
		break;
	case TXMOD_CRAM:
		/* Don't activate if AMSDU or APPS are active */
		if (SCB_TXMOD_ACTIVE(scb, TXMOD_AMSDU) ||
		    SCB_TXMOD_ACTIVE(scb, TXMOD_APPS))
			return;
		break;
	case TXMOD_AMSDU:
		/* Don't activate if APPS is active */
		if (SCB_TXMOD_ACTIVE(scb, TXMOD_APPS))
			return;
		/* Deactivate CRAM if on path */
		wlc_scb_txmod_deactivate(wlc, scb, TXMOD_CRAM);
		break;
	case TXMOD_BA:
		/* Don't activate if AMPDU is active */
		if (SCB_TXMOD_ACTIVE(scb, TXMOD_AMPDU))
			return;
		break;
	case TXMOD_AMPDU:
		/* Deactivate BA if on path */
		wlc_scb_txmod_deactivate(wlc, scb, TXMOD_BA);
		break;
	case TXMOD_DPT:
	case TXMOD_TRANSMIT:
		break;
	case TXMOD_START:
	case TXMOD_LAST:
		ASSERT(0);
	};

	wlc_scb_txmod_activate(wlc, scb, fid);
}

/* Remove the feature to handle packets for this SCB.
 * If just configured but not in path, just marked unconfigured
 * If in path, feature is removed and, if applicable, replaced by any other feature
 */
void
wlc_txmod_unconfig(wlc_info_t *wlc, struct scb *scb, scb_txmod_t fid)
{
	ASSERT(fid < TXMOD_LAST && fid != TXMOD_TRANSMIT);

	if (!SCB_TXMOD_CONFIGURED(scb, fid))
		return;

	scb->tx_path[fid].configured = FALSE;

	/* Nothing to do if not active */
	if (!SCB_TXMOD_ACTIVE(scb, fid))
		return;

	wlc_scb_txmod_deactivate(wlc, scb, fid);

	/* Restore any other features to the path */
	/* APPS unconfigured  => CRAM/AMSDU/BA can be active
	 * AMSDU unconfigured => CRAM can be active
	 */
	switch (fid) {
	case TXMOD_APPS:
		/* Activate AMSDU/BA/CRAM if configured
		 * Order below helps reduce redundant operations
		 * if both CRAM/AMSDU are configured
		 */
		if (SCB_TXMOD_CONFIGURED(scb, TXMOD_AMSDU))
			wlc_scb_txmod_activate(wlc, scb, TXMOD_AMSDU);
		else if (SCB_TXMOD_CONFIGURED(scb, TXMOD_CRAM))
			wlc_scb_txmod_activate(wlc, scb, TXMOD_CRAM);
		break;
	case TXMOD_AMSDU:
		/* Activate CRAM if configured and APPS is not active */
		if (SCB_TXMOD_CONFIGURED(scb, TXMOD_CRAM) &&
		    !SCB_TXMOD_ACTIVE(scb, TXMOD_APPS))
			wlc_scb_txmod_activate(wlc, scb, TXMOD_CRAM);
		break;
	case TXMOD_DPT:
	case TXMOD_CRAM:
	case TXMOD_BA:
	case TXMOD_AMPDU:
	case TXMOD_TRANSMIT:
	case TXMOD_START:
	case TXMOD_LAST:
		break;
	}
}

void
wlc_write_ht_cap_ie(wlc_bsscfg_t *cfg, ht_cap_ie_t *cap_ie, uint8 *supp_mcs, bool is2G)
{
	wlc_info_t *wlc = cfg->wlc;
	uint16 cap;

	/* update GF cap bit based on the override setting */
	if (wlc->protection->n_pam_override != AUTO) {
		if (wlc->protection->n_pam_override == WLC_N_PREAMBLE_MIXEDMODE)
			wlc->ht_cap.cap &= ~HT_CAP_GF;
		else
			wlc->ht_cap.cap |= HT_CAP_GF;
	}

	if (is2G)
		wlc->ht_cap.cap |= HT_CAP_DSSS_CCK;
	else
		wlc->ht_cap.cap &= ~HT_CAP_DSSS_CCK;

	cap = wlc->ht_cap.cap;

	/* clear 40MHz capability advertisement if
	 * - the locale does not allow 40MHz or
	 * - the band is not configured to support it or
	 * - chanspec was forced to 20MHz for AP/IBSS
	 */
	if ((wlc_channel_locale_flags(wlc->cmi) & WLC_NO_40MHZ) || (!wlc->band->mimo_cap_40) ||
	    (cfg != NULL && (BSSCFG_AP(cfg) || !cfg->BSS) &&
	     !CHSPEC_IS40(cfg->current_bss->chanspec)))
		cap &= ~HT_CAP_40MHZ;

	/* Set 40MHz Intolerant bit if
	 * - On 2G Band and
	 * - User has it configured or STA detected a intolerant device
	 * Disable 40MHz capability if an intolerant device is detected
	 */
	if (is2G && WLC_INTOL40_OVRD(wlc))
		cap |= HT_CAP_40MHZ_INTOLERANT;

	bzero(cap_ie, sizeof(ht_cap_ie_t));
	cap_ie->cap = htol16(cap);
	cap_ie->params = wlc->ht_cap.params;
	bcopy(wlc->band->hw_rateset.mcs, &cap_ie->supp_mcs[0], MCSSET_LEN);

	if ((!AP_ENAB(wlc->pub) && (WLC_BITSCNT(wlc->stf->hw_rxchain) == 1)) ||
		(AP_ENAB(wlc->pub) && (wlc->stf->rxstreams == 1))) {
		int i;
		/* yank advertised MCS rates above 7 when we are single stream rx */
		for (i = 1; i < MCSSET_LEN; i++)
			cap_ie->supp_mcs[i] = 0;
	}
}

uint8*
wlc_write_brcm_ht_cap_ie(wlc_info_t *wlc, uint8 *cp, int buflen, ht_cap_ie_t *cap_ie)
{
	ht_prop_cap_ie_t prop_cap_ie;

	prop_cap_ie.id = DOT11_MNG_PROPR_ID;
	prop_cap_ie.len = HT_CAP_IE_LEN + HT_PROP_IE_OVERHEAD;
	bcopy(BRCM_PROP_OUI, &prop_cap_ie.oui[0], DOT11_OUI_LEN);
	prop_cap_ie.type = HT_CAP_IE_TYPE;
	bcopy(cap_ie, &prop_cap_ie.cap_ie, sizeof(ht_cap_ie_t));

	cp = wlc_copy_info_elt_safe(cp, buflen, &prop_cap_ie);

	return cp;
}

#ifdef WL11K
static uint8*
wlc_write_brcm_tpc_ie(wlc_info_t *wlc, uint8 *cp, int buflen)
{
	uint8 target_pwr;

	target_pwr = wlc_phy_txpower_get_target_max((wlc_phy_t *)wlc->band->pi);

	*cp++ = DOT11_MNG_PROPR_ID;
	*cp++ = 7;
	bcopy(WPA_OUI, cp, WPA_OUI_LEN);
	cp += WPA_OUI_LEN;
	*cp++ = WFA_OUI_TYPE_TPC;
	*cp++ = 0; /* subtype = 0 */
	*cp++ = (target_pwr + wlc->band->antgain) / WLC_TXPWR_DB_FACTOR;
	*cp++ = 0; /* link margin = 0 */

	return cp;
}
#endif /* WL11K */

void
wlc_write_ht_add_ie(wlc_bsscfg_t *cfg, ht_add_ie_t *add_ie)
{
	wlc_info_t *wlc = cfg->wlc;
	wlc_bss_info_t *current_bss = cfg->current_bss;
	wlc_prot_cfg_t *prot = cfg->prot_cfg;

	bzero(add_ie, sizeof(ht_add_ie_t));
	add_ie->ctl_ch = wf_chspec_ctlchan(current_bss->chanspec);
	/* clear the ext channel bits, indicates no ext. channel */
	add_ie->byte1 &= ~DOT11_EXT_CH_MASK;
	switch (current_bss->chanspec & WL_CHANSPEC_CTL_SB_MASK) {
		case WL_CHANSPEC_CTL_SB_NONE:
			add_ie->byte1 |= DOT11_EXT_CH_NONE;
			break;
		case WL_CHANSPEC_CTL_SB_UPPER:
			add_ie->byte1 |= DOT11_EXT_CH_LOWER;
			break;
		case WL_CHANSPEC_CTL_SB_LOWER:
			add_ie->byte1 |= DOT11_EXT_CH_UPPER;
			break;
		default:
			ASSERT(0);
			break;
	}
	/* Set the MIMO b/w bit (and ext ch for 40Mhz mode) */
	add_ie->byte1 &= ~HT_BW_ANY;

	if (CHSPEC_IS40(current_bss->chanspec))
		add_ie->byte1 |= HT_BW_ANY;

	/* Set the operating mode */
	add_ie->opmode = 0;
	if (prot->n_cfg == WLC_N_PROTECTION_20IN40)
		add_ie->opmode |= htol16(HT_OPMODE_HT20IN40);
	else if (prot->n_cfg == WLC_N_PROTECTION_MIXEDMODE)
		add_ie->opmode |= htol16(HT_OPMODE_MIXED);
	else if (prot->n_cfg == WLC_N_PROTECTION_OPTIONAL)
		add_ie->opmode |= htol16(HT_OPMODE_OPTIONAL);

	if (prot->nongf)
		add_ie->opmode |= htol16(HT_OPMODE_NONGF);
	if (prot->n_obss)
		add_ie->opmode |= htol16(DOT11N_OBSS_NONHT);
	/* Set the RIFS mode enabled if no apsd STAs detected */
	add_ie->byte1 &= ~HT_RIFS_PERMITTED;
	wlc->rifs_mode = 0;
	if (wlc->rifs_advert && (prot->n_cfg != WLC_N_PROTECTION_MIXEDMODE)) {
		add_ie->byte1 |= HT_RIFS_PERMITTED;
		wlc->rifs_mode = 1;
	}

	wlc->txburst_limit = 0;
	if (wlc->txburst_limit_override == ON || cfg->prot_cond->non11n_apsd_assoc ||
	    (wlc->txburst_limit_override == AUTO && cfg->prot_cond->non11n_apsd_assoc)) {
		add_ie->opmode |= htol16(DOT11N_TXBURST);
		wlc->txburst_limit =
		        ((CHSPEC_WLCBANDUNIT(current_bss->chanspec) ==
		                       BAND_5G_INDEX) ?
		                      DOT11N_5G_TXBURST_LIMIT :
		                      DOT11N_2G_TXBURST_LIMIT);
	}

	/* set the basic mcs */
	bcopy(&wlc->ht_add.basic_mcs[0], &add_ie->basic_mcs[0], MCSSET_LEN);
}

uint8*
wlc_write_brcm_ht_add_ie(wlc_info_t *wlc, uint8 *cp, int buflen, ht_add_ie_t *add_ie)
{
	ht_prop_add_ie_t prop_add_ie;

	prop_add_ie.id = DOT11_MNG_PROPR_ID;
	prop_add_ie.len = HT_ADD_IE_LEN + HT_PROP_IE_OVERHEAD;
	bcopy(BRCM_PROP_OUI, &prop_add_ie.oui[0], DOT11_OUI_LEN);
	prop_add_ie.type = HT_ADD_IE_TYPE;
	bcopy(add_ie, &prop_add_ie.add_ie, sizeof(ht_add_ie_t));

	cp = wlc_copy_info_elt_safe(cp, buflen, &prop_add_ie);

	return cp;
}

ht_cap_ie_t *
wlc_read_ht_cap_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	bcm_tlv_t *cap_ie_tlv;

	/* check for the ana-assigned capability ie first */
	cap_ie_tlv = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_HT_CAP);
	if (cap_ie_tlv) {
		if (cap_ie_tlv->len >= HT_CAP_IE_LEN)
			return (ht_cap_ie_t *)&cap_ie_tlv->data;
		else
			WL_ERROR(("wl%d: %s: std len %d don't match\n",
			          wlc->pub->unit, __FUNCTION__, cap_ie_tlv->len));
	}

	return NULL;
}

static ht_cap_ie_t *
wlc_read_brcm_ht_cap_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	ht_prop_cap_ie_t *prop_cap_ie;
	uint8 type = HT_CAP_IE_TYPE;

	/* ana-assigned not found; look for prop one */
	prop_cap_ie = (ht_prop_cap_ie_t *)wlc_find_vendor_ie(tlvs, tlvs_len,
		(const uchar*)BRCM_PROP_OUI, &type, sizeof(type));

	if (prop_cap_ie) {
		if (prop_cap_ie->len >= (HT_CAP_IE_LEN + HT_PROP_IE_OVERHEAD))
			return &prop_cap_ie->cap_ie;
		else
			WL_ERROR(("wl%d: %s: len %d too short\n",
			          wlc->pub->unit, __FUNCTION__, prop_cap_ie->len));
	}

	return NULL;
}

/*
 * Find ht cap ie first. If not found look for brcm prop ht cap ie.
 */
ht_cap_ie_t *
wlc_read_ht_cap_ies(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	ht_cap_ie_t *cap_ie;

	cap_ie = wlc_read_ht_cap_ie(wlc, tlvs, tlvs_len);
	if (!cap_ie)
		cap_ie = wlc_read_brcm_ht_cap_ie(wlc, tlvs, tlvs_len);

	return cap_ie;
}

ht_add_ie_t *
wlc_read_ht_add_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	bcm_tlv_t *add_ie_tlv;

	/* check for the ana-assigned capability ie first */
	add_ie_tlv = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_HT_ADD);
	if (add_ie_tlv) {
		if (add_ie_tlv->len >= HT_ADD_IE_LEN)
			return (ht_add_ie_t *)&add_ie_tlv->data;
		else
			WL_ERROR(("wl%d: %s: std len %d don't match\n",
			          wlc->pub->unit, __FUNCTION__, add_ie_tlv->len));
	}

	return NULL;
}

static ht_add_ie_t *
wlc_read_brcm_ht_add_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	ht_prop_add_ie_t *prop_add_ie;
	uint8 type = HT_ADD_IE_TYPE;

	/* ana-assigned not found; look for prop one */
	prop_add_ie = (ht_prop_add_ie_t *)wlc_find_vendor_ie(tlvs, tlvs_len,
		(const uchar*)BRCM_PROP_OUI, &type, sizeof(type));

	if (prop_add_ie) {
		if (prop_add_ie->len >= (HT_ADD_IE_LEN + HT_PROP_IE_OVERHEAD))
			return &prop_add_ie->add_ie;
		else
			WL_ERROR(("wl%d: %s: len %d too short\n",
			          wlc->pub->unit, __FUNCTION__, prop_add_ie->len));
	}

	return NULL;
}

/*
 * Find ht additional ie first. If not found look for brcm prop ht additional ie.
 */
ht_add_ie_t *
wlc_read_ht_add_ies(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	ht_add_ie_t *add_ie;

	add_ie = wlc_read_ht_add_ie(wlc, tlvs, tlvs_len);
	if (!add_ie)
		add_ie = wlc_read_brcm_ht_add_ie(wlc, tlvs, tlvs_len);

	return add_ie;
}

obss_params_t *
wlc_ht_read_obss_scanparams_ie(wlc_info_t *wlc, uint8 *tlvs, int tlvs_len)
{
	bcm_tlv_t *obss_ie_tlv;
	obss_ie_tlv = bcm_parse_tlvs(tlvs, tlvs_len, DOT11_MNG_HT_OBSS_ID);
	if (obss_ie_tlv) {
		if (obss_ie_tlv->len >= DOT11_OBSS_SCAN_IE_LEN)
			return (obss_params_t *)obss_ie_tlv->data;
		else
			WL_ERROR(("wl%d: wlc_ht_read_obss_scanparams_ie: len %d too short\n",
				wlc->pub->unit, obss_ie_tlv->len));
	}
	return NULL;
}

void
wlc_process_coex_mgmt_ie(wlc_info_t *wlc, uint8 *tlvs, int len, struct scb *scb)
{
	bcm_tlv_t *coex_mgmt_ie_tlv;

	ASSERT(scb != NULL);

	scb->flags &= ~SCB_COEX_MGMT;

	coex_mgmt_ie_tlv = bcm_parse_tlvs(tlvs, len, DOT11_MNG_EXT_CAP_ID);
	if (!coex_mgmt_ie_tlv)
		return;

	if (coex_mgmt_ie_tlv->len >= DOT11_EXTCAP_LEN_COEX) {
		if (coex_mgmt_ie_tlv->data[0] & (1 << DOT11_EXT_CAP_OBSS_COEX_MGMT))
			scb->flags |= SCB_COEX_MGMT;
	}
}

/*
 * The routine extracts HT configuration info from the supplied capability and additional IEs
 * and stores it in the scb, currently this state includes:
 *	HT capable flag, AMPDU params, GF support, MIMO PS mode, RIFS support, AMSDU max size,
 *      preferred txbw for MIMO, ODFM and CCK
 * 'upd_mimo_ps' indicates if SM PS mode needs to be updated, and it's valid
 * only when cap_ie is not NULL.
 */
void
wlc_ht_update_scbstate(wlc_info_t *wlc, struct scb *scb,
	ht_cap_ie_t *cap_ie, ht_add_ie_t *add_ie, obss_params_t *obss_params)
{
#ifdef WL11N
	uint16 cap;
	bool allow_40Mhz = FALSE;
	bool reinit_ratesel = FALSE;
	bool scbwas40 = (scb->flags & SCB_IS40) != 0;
	bool ht_cap = (SCB_HT_CAP(scb) != 0);
	uint32 scb_old_sgi = scb->flags2 & (SCB2_SGI20_CAP | SCB2_SGI40_CAP);
	bool update_mcsset = FALSE;
#endif /* WL11N */
	wlc_bsscfg_t *bsscfg;

	ASSERT(scb != NULL);

	bsscfg = SCB_BSSCFG(scb);
	if (bsscfg == NULL) {
		ASSERT(bsscfg != NULL);
		return;
	}

	/* clear HT based features */
	scb->flags &= ~(SCB_HTCAP | SCB_AMSDUCAP | SCB_AMPDUCAP | SCB_BACAP |
		SCB_NONGF | SCB_IS40 | SCB_RIFSCAP | SCB_HT40INTOLERANT | SCB_STBCCAP);
	scb->flags2 &= ~(SCB2_SGI20_CAP | SCB2_SGI40_CAP | SCB2_LDPCCAP);

#ifdef WL11N
	/* check if there is a HT capability ie */
	if (cap_ie) {
		cap = ltoh16_ua(&cap_ie->cap);
		/* Store the HT config */
		scb->ht_capabilities = cap;
		scb->ht_ampdu_params = cap_ie->params;

		/* Mark the SCB as HT capable */
		scb->flags |= SCB_HTCAP;

#ifdef WLAMPDU
		/* mark ampdu flag and add AMPDU to txpath
		 * depending on the crypto settings for the SCB
		 * By spec, 11n device can send AMPDU only with Open or CCMP crypto
		 */
		if (AMPDU_ENAB(wlc->pub)) {
			scb->flags |= SCB_AMPDUCAP;
			if (!SCB_TXMOD_CONFIGURED(scb, TXMOD_AMPDU) &&
			    ((scb->wsec == AES_ENABLED) || (scb->wsec == 0) ||
#ifdef BCMWAPI_WPI
			    (scb->wsec == SMS4_ENABLED) ||
#endif
			    FALSE))
#ifdef MFP
				if (!SCB_MFP(scb))
#endif
				wlc_txmod_config(wlc, scb, TXMOD_AMPDU);
		} else
			wlc_txmod_unconfig(wlc, scb, TXMOD_AMPDU);
#endif /* WLAMPDU */

#ifdef WLAMSDU
		/* remote station is AMSDU capable? */
		if (AMSDU_ENAB(wlc->pub)) {
			uint32 old_mtu = scb->amsdu_mtu_pref;

			scb->flags |= SCB_AMSDUCAP;
			scb->amsdu_mtu_pref = (cap & HT_CAP_MAX_AMSDU) ?
				HT_MAX_AMSDU : HT_MIN_AMSDU;
			/* if mtu changed, update AMSDU agg bytes */
			if (old_mtu != scb->amsdu_mtu_pref)
				wlc_amsdu_scb_agglimit_upd(wlc->ami, scb);
			/* only active amsdu agg when it's enabled */
			wlc_txmod_config(wlc, scb, TXMOD_AMSDU);
		} else
			wlc_txmod_unconfig(wlc, scb, TXMOD_AMSDU);
#endif

#ifdef NOTYET
		/* remote station is is delayed blockack capable? */
		if (WLBA_ENAB(wlc->pub) && (cap & HT_CAP_DELAYED_BA)) {
			scb->flags |= SCB_BACAP;
			wlc_txmod_config(wlc, scb, SCB_BACAP);
		} else
			wlc_txmod_unconfig(wlc, scb, SCB_BACAP);
#endif

#ifdef WLP2P
		if (!(bsscfg->p2p_flags & WLC_BSSCFG_P2P_IGN_SMPS))
#endif
		{
			bool old_mimops = scb->ht_mimops_enabled;
			bool old_mimops_rtsmode = scb->ht_mimops_rtsmode;

			switch ((cap & HT_CAP_MIMO_PS_MASK) >> HT_CAP_MIMO_PS_SHIFT) {
			case HT_CAP_MIMO_PS_ON :
				scb->ht_mimops_enabled = TRUE;
				scb->ht_mimops_rtsmode = FALSE;
				break;
			case HT_CAP_MIMO_PS_RTS :
				scb->ht_mimops_enabled = TRUE;
				scb->ht_mimops_rtsmode = TRUE;
				break;
			case HT_CAP_MIMO_PS_OFF :
				scb->ht_mimops_enabled = FALSE;
				scb->ht_mimops_rtsmode = FALSE;
				break;
			default:
				scb->ht_mimops_enabled = FALSE;
				scb->ht_mimops_rtsmode = FALSE;
				WL_ERROR(("wl%d: wlc_ht_update_scbstate, incorrect psmode\n",
				          wlc->pub->unit));
				break;
			}

			if ((old_mimops != scb->ht_mimops_enabled) ||
			    (old_mimops_rtsmode != scb->ht_mimops_rtsmode))
				reinit_ratesel = TRUE;
		}

		/* mark peer as stbc capable if it supports ANY num of stbc streams */
		if (cap & HT_CAP_RX_STBC_MASK)
			scb->flags |= SCB_STBCCAP;

		if (cap & HT_CAP_LDPC_CODING)
			scb->flags2 |= SCB2_LDPCCAP;

		if (cap & HT_CAP_SHORT_GI_20)
			scb->flags2 |= SCB2_SGI20_CAP;

		if (cap & HT_CAP_SHORT_GI_40)
			scb->flags2 |= SCB2_SGI40_CAP;

		if (scb_old_sgi != (scb->flags2 & (SCB2_SGI20_CAP | SCB2_SGI40_CAP)))
			reinit_ratesel = TRUE;

		if (!(cap & HT_CAP_GF))
			scb->flags |= SCB_NONGF;

		if (cap & HT_CAP_40MHZ_INTOLERANT)
			scb->flags |= SCB_HT40INTOLERANT;

		allow_40Mhz = (cap & HT_CAP_40MHZ) != 0;
		if (add_ie) {
			bcopy(add_ie, &wlc->ht_add, sizeof(ht_add_ie_t));
			if (allow_40Mhz)
				allow_40Mhz = (add_ie->byte1 & HT_BW_ANY) != 0;
			if (add_ie->byte1 & HT_RIFS_PERMITTED)
				scb->flags |= SCB_RIFSCAP;
			if (DOT11N_TXBURST_PRESENT(add_ie)) {
				wlc->txburst_limit =
					(CHSPEC_WLCBANDUNIT(bsscfg->current_bss->chanspec) ==
					BAND_5G_INDEX) ?
					DOT11N_5G_TXBURST_LIMIT : DOT11N_2G_TXBURST_LIMIT;
			} else {
				wlc->txburst_limit = 0;
			}
		}

		if (COEX_ENAB(wlc->pub) && obss_params && BSSCFG_STA(bsscfg)) {
			obss_params_t params;
			bcopy((uint8 *)obss_params, (uint8 *)&params, WL_OBSS_SCAN_PARAM_LEN);
			/* convert params to host order */
			wlc_ht_obss_scanparams_hostorder(wlc, &params, TRUE);
			if (!wlc_ht_obss_scanparams_upd(wlc, &params, bsscfg)) {
				WL_ERROR(("Invalid OBSS Scan parameters (out-of-range): "
					" %d %d %d %d %d %d %d\n", params.passive_dwell,
					params.active_dwell, params.bss_widthscan_interval,
					params.passive_total, params.active_total,
					params.chanwidth_transition_dly,
					params.activity_threshold));
			}
		}
	} else {
		/* unconfig HT based features */
		wlc_txmod_unconfig(wlc, scb, TXMOD_AMSDU);
		wlc_txmod_unconfig(wlc, scb, TXMOD_AMPDU);
		wlc_txmod_unconfig(wlc, scb, TXMOD_BA);
	}

	/* update the mcs rateset when mcs rateset is changed */
	if (ht_cap && SCB_HT_CAP(scb)) {
		uint i;
		for (i = 0; i < MCSSET_LEN; i++) {
			if (cap_ie->supp_mcs[i] != scb->rateset.mcs[i]) {
				update_mcsset = TRUE;
				break;
			}
		}
	}

	/* update the mcs rateset when ht cap changes */
	if ((ht_cap != (SCB_HT_CAP(scb) != 0)) || update_mcsset) {
		if (scb->flags & SCB_HTCAP)
			bcopy(&cap_ie->supp_mcs[0], &scb->rateset.mcs[0], MCSSET_LEN);
		else
			bzero(&scb->rateset.mcs[0], MCSSET_LEN);
		reinit_ratesel = TRUE;
	}

	if (allow_40Mhz) {
		scb->flags |= SCB_IS40;
	}

	if (scbwas40 != allow_40Mhz)
		reinit_ratesel = TRUE;

	/* refresh rateselection if bw or psmode changed */
	if (reinit_ratesel) {
		wlc_scb_ratesel_init(wlc, scb);
	}
#endif /* WL11N */
}

#ifdef WL11N
static void
wlc_ht_chanlist_2g_init(wlc_info_t *wlc)
{
	uint i;

	for (i = 1; i <= CH_MAX_2G_CHANNEL; i++) {
		if (VALID_CHANNEL20_IN_BAND(wlc, BAND_2G_INDEX, i)) {
			setbit(wlc->obss->chanvec, i);
			wlc->obss->num_chan++;
		}
	}
	WL_COEX(("wl%d: %s: %d channels in 2G band\n", wlc->pub->unit, __FUNCTION__,
		wlc->obss->num_chan));
}

static void
wlc_ht_update_coex_support(wlc_info_t *wlc, int8 setting)
{
	bool old_obss_coex_support = wlc->obss->coex_enab;

	WL_TRACE(("wl%d: wlc_ht_update_coex_support\n", wlc->pub->unit));
	if (!N_ENAB(wlc->pub))
		return;


	wlc->pub->_coex = setting;
	if (setting == ON || (setting == AUTO && wlc->bandstate[BAND_2G_INDEX]->mimo_cap_40))
		wlc->obss->coex_enab = TRUE;
	else {
		wlc->obss->coex_enab = FALSE;
		wlc_ht_upd_coex_bits(wlc, 0, WL_COEX_WIDTH20);
	}

	if (old_obss_coex_support == wlc->obss->coex_enab)
		return;
	WL_COEX(("wl%d: %s: coex [%s] coex_enab %d\n", wlc->pub->unit, __FUNCTION__,
		(wlc->pub->_coex == AUTO ? "AUTO" : (wlc->pub->_coex == ON ? "ON" : "OFF")),
		wlc->obss->coex_enab));

	if (COEX_ACTIVE(wlc)) {
		wlc_ht_coex_update_fid_time(wlc);
		wlc_ht_obss_scan_reset(wlc);
		/* update scan param first before update beacon, scan
		 * param is part of beacon IE
		 */
		wlc_ht_obss_scanparam_init(&wlc->obss->ap_params);
		wlc_ht_obss_scanparam_init(&wlc->obss->sta_params);
		if (AP_ENAB(wlc->pub) && wlc->clk) {
			wlc_update_beacon(wlc);
			wlc_update_probe_resp(wlc, TRUE);
		}
		wlc_ht_chanlist_2g_init(wlc);
	}
}

void
wlc_ht_obss_scanparams_hostorder(wlc_info_t *wlc, obss_params_t *param, bool to_host_order)
{
	WL_TRACE(("wl%d: wlc_ht_obss_scanparams_hostorder\n", wlc->pub->unit));
	if (to_host_order) {
		/* convert to host order */
		param->passive_dwell = ltoh16(param->passive_dwell);
		param->active_dwell = ltoh16(param->active_dwell);
		param->bss_widthscan_interval = ltoh16(param->bss_widthscan_interval);
		param->passive_total = ltoh16(param->passive_total);
		param->active_total = ltoh16(param->active_total);
		param->chanwidth_transition_dly = ltoh16(param->chanwidth_transition_dly);
		param->activity_threshold = ltoh16(param->activity_threshold);
	} else {
		/* convert to 802.11 little-endian order */
		param->passive_dwell = htol16(param->passive_dwell);
		param->active_dwell = htol16(param->active_dwell);
		param->bss_widthscan_interval = htol16(param->bss_widthscan_interval);
		param->passive_total = htol16(param->passive_total);
		param->active_total = htol16(param->active_total);
		param->chanwidth_transition_dly = htol16(param->chanwidth_transition_dly);
		param->activity_threshold = htol16(param->activity_threshold);
	}
}

bool
wlc_ht_obss_scanparams_upd(wlc_info_t *wlc, obss_params_t *new_params, wlc_bsscfg_t *bsscfg)
{
	obss_params_t *params;

	WL_TRACE(("wl%d: wlc_ht_obss_scanparams_upd\n", wlc->pub->unit));
	if (BSSCFG_AP(bsscfg))
		params = &wlc->obss->ap_params;
	else
		params = &wlc->obss->sta_params;

	/* check if params are different */
	if (!bcmp((uint8 *)params, (uint8 *)new_params, DOT11_OBSS_SCAN_IE_LEN))
		return TRUE;

	if (new_params->passive_dwell < WLC_OBSS_SCAN_PASSIVE_DWELL_MIN ||
	    new_params->passive_dwell > WLC_OBSS_SCAN_PASSIVE_DWELL_MAX)
		return FALSE;

	if (new_params->active_dwell < WLC_OBSS_SCAN_ACTIVE_DWELL_MIN ||
	    new_params->active_dwell > WLC_OBSS_SCAN_ACTIVE_DWELL_MAX)
		return FALSE;

	if (new_params->bss_widthscan_interval < WLC_OBSS_SCAN_WIDTHSCAN_INTERVAL_MIN ||
	    new_params->bss_widthscan_interval > WLC_OBSS_SCAN_WIDTHSCAN_INTERVAL_MAX)
		return FALSE;

	if (new_params->chanwidth_transition_dly < WLC_OBSS_SCAN_CHANWIDTH_TRANSITION_DLY_MIN ||
	    new_params->chanwidth_transition_dly > WLC_OBSS_SCAN_CHANWIDTH_TRANSITION_DLY_MAX)
		return FALSE;

	if (new_params->passive_total < WLC_OBSS_SCAN_PASSIVE_TOTAL_PER_CHANNEL_MIN ||
	    new_params->passive_total > WLC_OBSS_SCAN_PASSIVE_TOTAL_PER_CHANNEL_MAX)
		return FALSE;

	if (new_params->active_total < WLC_OBSS_SCAN_ACTIVE_TOTAL_PER_CHANNEL_MIN ||
	    new_params->active_total > WLC_OBSS_SCAN_ACTIVE_TOTAL_PER_CHANNEL_MAX)
		return FALSE;

	if (new_params->activity_threshold > WLC_OBSS_SCAN_ACTIVITY_THRESHOLD_MAX)
		return FALSE;

	bcopy((uint8 *)new_params, (uint8 *)params, WL_OBSS_SCAN_PARAM_LEN);
	if (BSSCFG_STA(bsscfg))
		wlc_ht_obss_scan_reset(wlc);
	return TRUE;
}

static void
wlc_ht_obss_scanparam_init(obss_params_t *params)
{
	/* set Overlapping BSS scan parameters default */
	params->passive_dwell = WLC_OBSS_SCAN_PASSIVE_DWELL_DEFAULT;
	params->active_dwell = WLC_OBSS_SCAN_ACTIVE_DWELL_DEFAULT;
	params->bss_widthscan_interval = WLC_OBSS_SCAN_WIDTHSCAN_INTERVAL_DEFAULT;
	params->chanwidth_transition_dly = WLC_OBSS_SCAN_CHANWIDTH_TRANSITION_DLY_DEFAULT;
	params->passive_total = WLC_OBSS_SCAN_PASSIVE_TOTAL_PER_CHANNEL_DEFAULT;
	params->active_total = WLC_OBSS_SCAN_ACTIVE_TOTAL_PER_CHANNEL_DEFAULT;
	params->activity_threshold = WLC_OBSS_SCAN_ACTIVITY_THRESHOLD_DEFAULT;
}

#ifdef STA
static void
wlc_ht_obss_scan_timer(wlc_info_t *wlc)
{
	wl_scan_params_t params;
	uint16 scan_interval = wlc->obss->sta_params.bss_widthscan_interval;
	int err = 1;

	WL_TRACE(("wl%d: wlc_ht_obss_scan_timer\n", wlc->pub->unit));

	/* start obss scan only if condition meet */
	if (!wlc->cfg->current_bss->infra || wlc->stas_associated == 0 ||
	    !wlc->obss->scan_countdown)
		return;

	/* start obss scan only if join 11n BSS */
	if ((wlc->cfg->current_bss->flags & (WLC_BSS_HT | WLC_BSS_40MHZ)) !=
	    (WLC_BSS_HT | WLC_BSS_40MHZ))
		return;

	if (--wlc->obss->scan_countdown != 0)
		return;

	bzero((uint8 *)&params, WL_SCAN_PARAMS_FIXED_SIZE);
	memcpy(&params.bssid, &ether_bcast, ETHER_ADDR_LEN);
	params.bss_type = DOT11_BSSTYPE_ANY;
	params.scan_type = 0;
	params.nprobes = -1;
	params.active_time = wlc->obss->sta_params.active_dwell;
	params.passive_time = wlc->obss->sta_params.passive_dwell;
	params.home_time = -1;
	params.channel_num = 0;

	WL_COEX(("wl%d: %s: schedule a custom scan\n", wlc->pub->unit, __FUNCTION__));

	if (!SCAN_IN_PROGRESS(wlc->scan)) {
		err = wlc_custom_scan(wlc, (char *)&params, WL_SCAN_PARAMS_FIXED_SIZE,
		                      0, WLC_ACTION_SCAN, wlc->cfg);
		if (err) {
			if (err != BCME_NOTREADY)
				wlc->custom_scan_results_state = WL_SCAN_RESULTS_ABORTED;
			scan_interval = 5;
			WL_COEX(("wl%d: %s: OBSS scan failed [%d], delay for %dsec\n",
				wlc->pub->unit, __FUNCTION__, err, scan_interval));
		} else {
			/* invalidate results for other scan method's query */
			wlc->custom_iscan_results_state = WL_SCAN_RESULTS_ABORTED;
			wlc->custom_scan_results_state = WL_SCAN_RESULTS_PENDING;
			scan_interval = wlc->obss->sta_params.bss_widthscan_interval;
		}
	} else {
		scan_interval = 5;
		WL_COEX(("wl%d: %s: SCAN_IN_PROGRESS, reschedule %dsec\n", wlc->pub->unit,
			__FUNCTION__, scan_interval));
	}
	WL_COEX(("wl%d: %s: arm next scan period %dsec\n", wlc->pub->unit, __FUNCTION__,
		scan_interval));
	wlc->obss->scan_countdown = scan_interval;
}
#endif /* STA */

void
wlc_ht_obss_scan_reset(wlc_info_t *wlc)
{
	WL_TRACE(("wl%d: wlc_ht_obss_scan_reset\n", wlc->pub->unit));

	/* at each association, reset tracking variables */
	wlc->obss->coex_det = 0;
	wlc->obss->coex_bits_buffered = 0;
	wlc->obss->switch_bw_deferred = FALSE;

	/* support obss coexistence for infra mode */
	if (!wlc->cfg->current_bss->infra || !COEX_ACTIVE(wlc))
		return;

	/* start obss coexistence if associated */
	if (wlc->stas_associated == 0)
		return;

	/* start obss scan only if join 11n BSS */
	if ((wlc->cfg->current_bss->flags & (WLC_BSS_HT | WLC_BSS_40MHZ)) !=
	    (WLC_BSS_HT | WLC_BSS_40MHZ))
		return;

	wlc->obss->scan_countdown = wlc->obss->sta_params.bss_widthscan_interval;
	WL_COEX(("wl%d: %s: start obss_scan_timer\n", wlc->pub->unit, __FUNCTION__));
}

void
wlc_ht_coex_exclusion_range(wlc_info_t *wlc, uint8 *ch_min, uint8 *ch_max, uint8 *ch_ctl)
{
	chanspec_t chanspec = wlc->home_chanspec;
	uint8 center_ch;

	if (!CHSPEC_IS2G(chanspec))
		return;

	if (CHSPEC_IS40(chanspec))
		chanspec = wlc->home_chanspec;
	/* if AP has been downgraded from bw40, use
	   default.
	*/
	else if (CHSPEC_IS40(wlc->default_bss->chanspec))
		chanspec = wlc->default_bss->chanspec;
	else {
		/* we don't want to do 40 anyway ...  */
		*ch_min = 0;
		*ch_max = 0;
		*ch_ctl = 0;
		return;
	}

	center_ch = CHSPEC_CHANNEL(chanspec);
	if (center_ch < WLC_2G_25MHZ_OFFSET) {
		*ch_min = 1;
		*ch_max = center_ch + WLC_2G_25MHZ_OFFSET;
	} else {
		*ch_min = center_ch - WLC_2G_25MHZ_OFFSET;
		*ch_max = center_ch + WLC_2G_25MHZ_OFFSET;
	}
	*ch_ctl = CHSPEC_CTL_CHAN(chanspec);
}


static uint8
wlc_ht_coex_ie_chk(wlc_info_t *wlc, bcm_tlv_t *obss_coex_tlv)
{
	dot11_obss_coex_t *obss_coex;
	uint8 coex_bits = 0;

	WL_TRACE(("wl%d: wlc_ht_coex_ie_chk\n", wlc->pub->unit));

	if (!obss_coex_tlv) {
		WL_ERROR(("wl%d: %s: 20/40 BSS Coexence IE NOT found\n", wlc->pub->unit,
			__FUNCTION__));
		return coex_bits;
	}

	if (obss_coex_tlv->len < DOT11_OBSS_COEXINFO_LEN) {
		WL_ERROR(("wl%d: %s: Invalid 20/40 BSS Coexence IE len %d\n", wlc->pub->unit,
			__FUNCTION__, obss_coex_tlv->len));
		return coex_bits;
	}

	obss_coex = (dot11_obss_coex_t *)obss_coex_tlv;

	if (obss_coex->info & DOT11_OBSS_COEX_40MHZ_INTOLERANT)
		coex_bits |= WL_COEX_40MHZ_INTOLERANT;
	if (obss_coex->info & DOT11_OBSS_COEX_20MHZ_WIDTH_REQ)
		coex_bits |= WL_COEX_WIDTH20;
	if (obss_coex->info & DOT11_OBSS_COEX_INFO_REQ)
		coex_bits |= WL_COEX_INFO_REQ;

	return coex_bits;
}


static void
wlc_ht_coex_trigger_chk(wlc_info_t *wlc, struct scb *scb)
{
	uint8 coex_bits = 0;
	chanspec_t chanspec = wlc->home_chanspec;
	uint8 center_ch, chan;

	/* after a successful scan, both AP/STA enter this function to
	 * update the coexistence statemachine
	 */
	WL_TRACE(("wl%d: wlc_ht_coex_trigger_chk\n", wlc->pub->unit));

	if (!CHSPEC_IS2G(chanspec))
		return;

	if (CHSPEC_IS40(chanspec))
		chanspec = wlc->home_chanspec;
	else if (AP_ENAB(wlc->pub)) {
		/* if AP has been downgraded from bw40 need to continue
		 * process channel exclusion
		 */
		if (CHSPEC_IS40(wlc->default_bss->chanspec))
			chanspec = wlc->default_bss->chanspec;
	}

	ASSERT(COEX_ACTIVE(wlc));

	/* check for trigger event, with updated obss.coex_map */
	if (N_ENAB(wlc->pub)) {
		center_ch = CHSPEC_CHANNEL(chanspec);
		if (CHSPEC_IS40(chanspec))
			chan = wf_chspec_ctlchan(chanspec);
		else
			chan = CHSPEC_CHANNEL(chanspec);

		ASSERT(chan <= CH_MAX_2G_CHANNEL);
		/* 40 Intolerant bit on current channel */
		if (wlc->obss->coex_map[chan] & WL_COEX_40MHZ_INTOLERANT)
			coex_bits |= WL_COEX_40MHZ_INTOLERANT;

		if (CHSPEC_IS40(chanspec)) {
			uint8 i, min_chan, max_chan;

			if (center_ch < WLC_2G_25MHZ_OFFSET) {
				min_chan = 1;
				max_chan = center_ch + WLC_2G_25MHZ_OFFSET;
			} else {
				min_chan = center_ch - WLC_2G_25MHZ_OFFSET;
				max_chan = center_ch + WLC_2G_25MHZ_OFFSET;
			}
			WL_COEX(("wl%d: %s: center chan %d; exclusion range %d ~ %d\n",
				wlc->pub->unit, __FUNCTION__, center_ch, min_chan, max_chan));

			for (i = 0; i <= CH_MAX_2G_CHANNEL; i++) {
				/* check exclusion channel range */
				if ((i >= min_chan) && (i <= max_chan)) {
					if (wlc->obss->coex_map[i] & WL_COEX_WIDTH20)
						coex_bits |= WL_COEX_WIDTH20;
				}
			}
		}
		WL_COEX(("wl%d: %s: exclusion chan %d coex_bits 0x%x\n", wlc->pub->unit,
			__FUNCTION__, chan, coex_bits));

		wlc_ht_upd_coex_state(wlc, coex_bits);
	}
}

void
wlc_ht_coex_filter_scanresult(wlc_info_t *wlc)
{
	wlc_bss_info_t *bi;
	uint8 chan, indx;

	WL_TRACE(("wl%d: wlc_ht_coex_filter_scanresult\n", wlc->pub->unit));

	if (!CHSPEC_IS2G(wlc->home_chanspec))
		return;
	if (wlc->stas_associated == 0)
		return;

	bzero(wlc->obss->coex_map, CH_MAX_2G_CHANNEL + 1);
	/* inspect all BSS descriptor */
	for (indx = 0; indx < wlc->scan_results->count; indx++) {
		bi = wlc->scan_results->ptrs[indx];
		if (CHSPEC_IS40(bi->chanspec))
			chan = wf_chspec_ctlchan(bi->chanspec);
		else
			chan = CHSPEC_CHANNEL(bi->chanspec);
		if (chan <= 0 || chan > CH_MAX_2G_CHANNEL) {
			WL_INFORM(("wl%d: %s: channel %d out side of 2.4G band\n", wlc->pub->unit,
				__FUNCTION__, chan));
			continue;
		}

		ASSERT(chan <= CH_MAX_2G_CHANNEL);
		if (bi) {
			if (!(bi->flags & WLC_BSS_HT) || !(bi->flags & WLC_BSS_40MHZ))
				/* legacy beacon || chan width 20 only */
				wlc->obss->coex_map[chan] |= WL_COEX_WIDTH20;
			if (bi->flags &	WLC_BSS_40INTOL)	/* 40 intolerant BSS */
				wlc->obss->coex_map[chan] |= WL_COEX_40MHZ_INTOLERANT;
			WL_COEX(("wl%d: %s: chan %d flag 0x%x\n", wlc->pub->unit, __FUNCTION__,
				chan, wlc->obss->coex_map[chan]));
		}
	}
	wlc_ht_coex_trigger_chk(wlc, wlc_scbfind(wlc, &wlc->cfg->BSSID));
}

static int
wlc_ht_upd_coex_bits(wlc_info_t *wlc, uint8 coex_bits, uint8 mask)
{
	/* Changes from IOVARs */
	WL_TRACE(("wl%d: wlc_ht_upd_coex_bits\n", wlc->pub->unit));

	if (coex_bits & ~mask)
		return BCME_RANGE;

	wlc->obss->coex_ovrd &= ~mask;
	if (coex_bits)
		wlc->obss->coex_ovrd |= coex_bits & mask;

	WL_COEX(("wl%d: %s: update coex 0x%x\n", wlc->pub->unit, __FUNCTION__, coex_bits));

	if (AP_ENAB(wlc->pub) && wlc->clk) {
		wlc_update_beacon(wlc);
		wlc_update_probe_resp(wlc, TRUE);
	} else if (wlc->stas_associated > 0) {
		wlc_ht_upd_coex_state(wlc, coex_bits);
	}
	return 0;
}

static void
wlc_ht_obss_coex_watchdog(wlc_info_t *wlc)
{

	WL_TRACE(("wl%d: wlc_ht_obss_coex_watchdog\n", wlc->pub->unit));

	/* obss coexistence not triggered, no check needed */
	if (!wlc->obss->coex_det)
		return;

	/* process switch_bw_deferred first before processing timeout */
	if (wlc->obss->switch_bw_deferred) {
		uint8 detected;
		ASSERT(wlc->obss->coex_bits_buffered);
		detected = wlc->obss->coex_bits_buffered;
		wlc->obss->coex_bits_buffered = 0;
		wlc->obss->switch_bw_deferred = FALSE;
		WL_COEX(("wl%d: %s: switch_bw_deferred, buffered 0x%x\n", wlc->pub->unit,
		         __FUNCTION__, detected));
		wlc_ht_upd_coex_state(wlc, detected);
		/* don't move on until switch_bw_deferred is cleared */
		if (wlc->obss->switch_bw_deferred)
			return;
	}
}

void
wlc_ht_upd_coex_state(wlc_info_t *wlc, uint8 detected)
{
	chanspec_t cur_chanspec = wlc->home_chanspec;
	uint8 coex_det = 0;

	WL_TRACE(("wl%d: wlc_ht_upd_coex_state\n", wlc->pub->unit));

	if (!CHSPEC_IS2G(cur_chanspec) || !COEX_ACTIVE(wlc))
		return;

	/* if scan in progress, schedule coexistence check for later.
	 * the code below may require of channel bw switching and is
	 * not good do it in the middle of scan
	 */
	if (detected && SCAN_IN_PROGRESS(wlc->scan)) {
		WL_COEX(("wl%d: %s: rescheduled coexistence check\n",
		         wlc->pub->unit, __FUNCTION__));
		wlc->obss->switch_bw_deferred = TRUE;
		/* there may be multiple call to this function during scan */
		wlc->obss->coex_bits_buffered |= detected;
		return;
	}

	WL_COEX(("wl%d: %s: check for changes to current coex state, incoming coex flag 0x%x\n",
		wlc->pub->unit, __FUNCTION__, detected));

	if (detected)
		coex_det |= WL_COEX_WIDTH20;

	if (WLC_INTOL40_OVRD(wlc))
		coex_det |= WL_COEX_40MHZ_INTOLERANT;

	WL_COEX(("wl%d: %s: result coex_det 0x%02x\n", wlc->pub->unit, __FUNCTION__, coex_det));

	wlc->obss->coex_det = coex_det;

	/* check if STA need to send report to AP */

	if (wlc->cfg->associated) {
		uint8 coex_bits = 0;

		if (WLC_INTOL40_DET(wlc))
			coex_bits |= WL_COEX_40MHZ_INTOLERANT;
		if (WLC_WIDTH20_DET(wlc))
			coex_bits |= WL_COEX_WIDTH20;

		WL_COEX(("wl%d: %s: action frame send bits %02x\n", wlc->pub->unit,
			__FUNCTION__, coex_bits));

		/* send the action frame to notify the AP */
		wlc_ht_send_action_obss_coex(wlc, coex_bits, wlc->obss->coex_map,
			wlc_scbfind(wlc, &wlc->cfg->BSSID));
	}
}

#endif /* WL11N */

/* Given the band and the HT additional IE construct the chanspec */
static chanspec_t
wlc_ht_chanspec(wlc_info_t *wlc, uint8 chan, uint8 extch)
{
	uint16 radio_channel = chan;
	uint16 ctl_sb = WL_CHANSPEC_CTL_SB_NONE;
	uint16 bw = WL_CHANSPEC_BW_20;
	uint16 band;
	chanspec_t chanspec = 0;

	if (CHANNEL_BANDUNIT(wlc, chan) == BAND_5G_INDEX)
		band = WL_CHANSPEC_BAND_5G;
	else
		band = WL_CHANSPEC_BAND_2G;
	switch (extch & DOT11_EXT_CH_MASK) {
		case DOT11_EXT_CH_UPPER:
			radio_channel = UPPER_20_SB(chan);
			ctl_sb = WL_CHANSPEC_CTL_SB_LOWER;
			bw = WL_CHANSPEC_BW_40;
			break;
		case DOT11_EXT_CH_LOWER:
			radio_channel = LOWER_20_SB(chan);
			ctl_sb = WL_CHANSPEC_CTL_SB_UPPER;
			bw = WL_CHANSPEC_BW_40;
			break;
		case DOT11_EXT_CH_NONE:
			break;
		default:
			WL_ERROR(("wl%d: Unexpected channel ext in additional HT IE,"
				" default to 20MHz\n", wlc->pub->unit));
			break;
	}

	chanspec = radio_channel | ctl_sb | bw | band;
	return chanspec;
}

static void BCMFASTPATH
wlc_update_txpktsuccess_stats(wlc_info_t *wlc, struct scb *scb, uint32 pkt_len, uint8 prio)
{
	/* update stat counters */
	WLCNTINCR(wlc->pub->_cnt->txframe);
	WLCNTADD(wlc->pub->_cnt->txbyte, pkt_len);
	WLACTINCR(wlc->pub->_activity);

	/* update interface stat counters */
	if (SCB_WDS(scb)) {
		WLCNTINCR(scb->wds->_cnt.txframe);
		WLCNTADD(scb->wds->_cnt.txbyte, pkt_len);
	} else {
		wlc_bsscfg_t *bsscfg = SCB_BSSCFG(scb);
		if (bsscfg) {
			WLCNTINCR(bsscfg->wlcif->_cnt.txframe);
			WLCNTADD(bsscfg->wlcif->_cnt.txbyte, pkt_len);
		}
	}

	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->tx[WME_PRIO2AC(prio)].packets);
		WLCNTADD(wlc->pub->_wme_cnt->tx[WME_PRIO2AC(prio)].bytes, pkt_len);
	}
}

static void
wlc_update_txpktfail_stats(wlc_info_t *wlc, uint32 pkt_len, uint8 prio)
{
	if (WME_ENAB(wlc->pub)) {
		WLCNTINCR(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(prio)].packets);
		WLCNTADD(wlc->pub->_wme_cnt->tx_failed[WME_PRIO2AC(prio)].bytes, pkt_len);
	}
}
//#if defined(WLTEST)

/* Create a test frame and enqueue into tx fifo */
void *
wlc_tx_testframe(wlc_info_t *wlc, struct ether_addr *da, struct ether_addr *sa,
                 ratespec_t rate_override, int length)
{
	void *p;
	uint8 *pbody;
	uint16 fc;
	bool shortpreamble;
	int16 cnt, len;
	char *payload;

	fc = FC_DATA;

	if ((p = wlc_frame_get_mgmt(wlc, fc, da, sa, sa, length, &pbody)) == NULL)
		return NULL;

	/* Fill the data with known pattern 0xF0 */
	memset(pbody, 0xF0, length);

	/* check if the rate overrides are set */
	if (!RSPEC_ACTIVE(rate_override)) {
		if (ETHER_ISMULTI(da))
			rate_override = wlc->band->mrspec_override;
		else
			rate_override = wlc->band->rspec_override;

		if (!RSPEC_ACTIVE(rate_override))
			rate_override = wlc->band->hwrs_scb->rateset.rates[0] & RATE_MASK;
	}
	if (wlc->cfg->PLCPHdr_override == WLC_PLCP_LONG)
		shortpreamble = FALSE;
	else
		shortpreamble = TRUE;

	/* Fill the payload with a ramp data */
	/* With a constant data, there are issues in SM/txper of cck rates */
	payload = (char *)PKTDATA(wlc->osh, p) + DOT11_MGMT_HDR_LEN;
	len = PKTLEN(wlc->osh, p) - DOT11_MGMT_HDR_LEN;
	for (cnt = (len-1); cnt > 0; cnt--)
		payload[cnt] = (char)cnt+1;

	/* add headers */
	wlc_d11hdrs(wlc, p, wlc->band->hwrs_scb, shortpreamble, 0, 1,
	            TX_DATA_FIFO, 0, NULL, rate_override);

#ifndef WL_MULTIQUEUE
	WLPKTTAGSCBCLR(p);
#endif /* ifndef WL_MULTIQUEUE */
	if (WLC_WAR16165(wlc))
		wlc_war16165(wlc, TRUE);


	/* Originally, we would call wlc_txfifo() here */
	/* wlc_txfifo(wlc, TX_DATA_FIFO, p, TRUE, 1); */
	/* However, that job is now the job of wlc_pkteng() */
	/* We return the packet so we can pass it in */
	/* as a parameter to wlc_pkteng() */

	return p;
}
//#endif 


#ifdef WIFI_ACT_FRAME
static void
wlc_af_off_channel_callback(void * arg, int status, wlc_bsscfg_t *cfg)
{
	struct wlc_info *wlc = (struct wlc_info *)arg;
	wlc_scan_info_t	*scan = wlc->scan;

	/* if AF is aborted */
	if (scan->action_frame) {
		wlc_actionframetx_complete(wlc, scan->action_frame, TX_STATUS_NO_ACK);
		WLPKTFLAG2_TYPECLR(scan->action_frame);
		PKTFREE(wlc->pub->osh, scan->action_frame, TRUE);
		scan->action_frame = NULL;
	}

	/* Send back the channel switch indication to the host */
	wlc_bss_mac_event(wlc, cfg, WLC_E_ACTION_FRAME_OFF_CHAN_COMPLETE, NULL, status,
	                  0, 0, 0, 0);
}

void *
wlc_prepare_action_frame(wlc_info_t *wlc, wlc_bsscfg_t *cfg, const struct ether_addr *bssid,
	void *action_frame)
{
	void *pkt;
	uint8* pbody;
	uint16 body_len;
	struct ether_addr da;
	uint32 packetId;
	wlc_pkttag_t *pkttag;
	uint8 cat;

	bcopy((uint8*)action_frame +
		OFFSETOF(wl_action_frame_t, packetId), &packetId, sizeof(uint32));

	bcopy((uint8*)action_frame + OFFSETOF(wl_action_frame_t, len), &body_len, sizeof(body_len));

	bcopy((uint8*)action_frame + OFFSETOF(wl_action_frame_t, da), &da, ETHER_ADDR_LEN);

	ASSERT(body_len != 0);
	cat = *((uint8*)action_frame + OFFSETOF(wl_action_frame_t, data));

	if (bssid == NULL) {
		bssid = (WLC_BSS_CONNECTED(cfg)) ? &cfg->BSSID : &ether_bcast;
	}
	pkt = NULL;
	if (body_len) {
		/* get management frame */
		if ((pkt = wlc_frame_get_action(wlc, FC_ACTION, &da, &cfg->cur_etheraddr,
			bssid, body_len, &pbody, cat)) == NULL) {
			return NULL;
		}

		pkttag = WLPKTTAG(pkt);
		pkttag->shared.packetid = packetId;
		WLPKTTAGBSSCFGSET(pkt, cfg->_idx);

		bcopy((uint8*)action_frame + OFFSETOF(wl_action_frame_t, data), pbody, body_len);
	}

	return pkt;
}

int
wlc_tx_action_frame_now(wlc_info_t *wlc, wlc_bsscfg_t *cfg, void *pkt)
{
	ratespec_t rate_override = 0;

#ifdef WLP2P
	if (BSS_P2P_ENAB(wlc, cfg))
		rate_override = WLC_RATE_6M;
#endif

	if (!wlc_queue_80211_frag(wlc, pkt, wlc->active_queue, NULL, FALSE, NULL, rate_override))
		return BCME_ERROR;

	WLPKTFLAG2_TYPESET(pkt, WLF2_TYPE_AF);
	return BCME_OK;
}

int
wlc_send_action_frame_off_channel(struct wlc_info *wlc, struct wlc_bsscfg *bsscfg,
	uint32 channel, int32 dwell_time, struct ether_addr *bssid, void *action_frame)
{
	wlc_ssid_t ssid;
	chanspec_t chanspec_list[1];
	wlc_scan_info_t	*scan = wlc->scan;

	scan->action_frame = wlc_prepare_action_frame(wlc, bsscfg, bssid, action_frame);
	if (!scan->action_frame) {
		return BCME_NOMEM;
	}

	chanspec_list[0] = CH20MHZ_CHSPEC(channel);
	ssid.SSID_len = 0;

	return wlc_scan_request_ex(wlc, DOT11_BSSTYPE_ANY, &bsscfg->BSSID, 1, &ssid, -1, 1,
	                           dwell_time, dwell_time, -1, chanspec_list,
	                           1, 0, FALSE,
	                           wlc_af_off_channel_callback, wlc,
	                           WLC_ACTION_ACTFRAME, FALSE, bsscfg);
}

int
wlc_send_action_frame(wlc_info_t *wlc, wlc_bsscfg_t *cfg, const struct ether_addr *bssid,
	void *action_frame)
{
	void *pkt;
	pkt = wlc_prepare_action_frame(wlc, cfg, bssid, action_frame);
	if (!pkt) {
		return BCME_NOMEM;
	}

	return wlc_tx_action_frame_now(wlc, cfg, pkt);
}

static void
wlc_actionframetx_complete(wlc_info_t *wlc, void *pkt, uint txstatus)
{
	int err;
	int idx;
	wlc_bsscfg_t *cfg;
	uint status = WLC_E_STATUS_SUCCESS;
	uint32 packetId;

	if (!(txstatus & TX_STATUS_ACK_RCV))
		status = WLC_E_STATUS_NO_ACK;

	packetId = WLPKTTAG(pkt)->shared.packetid;

	idx = WLPKTTAGBSSCFGGET(pkt);
	cfg = wlc_bsscfg_find(wlc, idx, &err);

	/* Send back the Tx status to the host */
	wlc_bss_mac_event(wlc, cfg, WLC_E_ACTION_FRAME_COMPLETE, NULL, status,
	                  0, 0, &packetId, sizeof(packetId));
	return;
}
#endif /* WIFI_ACT_FRAME */

/*
 * This routine creates a chanspec with the current band and b/w using the channel
 * number passed in. For 40MHZ chanspecs it always chooses the lower ctrl SB.
 */
chanspec_t
wlc_create_chspec(wlc_info_t *wlc, uint8 channel)
{
	chanspec_t chspec = 0;

	if (BAND_2G(wlc->band->bandtype))
		chspec |= WL_CHANSPEC_BAND_2G;
	else
		chspec |= WL_CHANSPEC_BAND_5G;
	if (N_ENAB(wlc->pub) &&
	    wlc_valid_chanspec_db(wlc->cmi, wlc->chanspec) &&
	    CHSPEC_IS40(wlc->chanspec) &&
	    (wlc_channel_locale_flags(wlc->cmi) & WLC_NO_40MHZ) == 0 &&
	    wlc->band->mimo_cap_40) {
		chspec |= WL_CHANSPEC_BW_40;
		chspec |= WL_CHANSPEC_CTL_SB_LOWER;
	} else {
		chspec |= WL_CHANSPEC_BW_20;
		chspec |= WL_CHANSPEC_CTL_SB_NONE;
	}
	chspec |= channel;


	return chspec;
}

#ifdef STA
/* Change PCIE War override for some platforms */
void
wlc_pcie_war_ovr_update(wlc_info_t *wlc, uint8 aspm)
{
	 wlc_bmac_pcie_war_ovr_update(wlc->hw, aspm);
}

void
wlc_pcie_power_save_enable(wlc_info_t *wlc, bool enable)
{
	wlc_bmac_pcie_power_save_enable(wlc->hw, enable);
}

/* Given a GTK MSG2 packet, prepare the packet as if for transmission. The driver needs to program
 * the frame in the template and also provide d11txh equivalent information to it
 */
void *
wlc_prep_gtkmsg2_hdrs(wlc_info_t *wlc, void *sdu, struct scb *scb)
{
	void *pkt;
	wsec_key_t *key;
	uint8 prio = 0;
	bool is_8021x = TRUE;
	bool oldtxc;
	uint frag_length = 0;
	uint pkt_length, nfrags;

	/* wlc_hdr_proc --> Ether to 802.3 */
	pkt = wlc_hdr_proc(wlc, sdu, scb);

	if (pkt == NULL) {
		PKTFREE(wlc->osh, sdu, TRUE);
		return NULL;
	}

	ASSERT(sdu == pkt);

	key = scb->key;

	prio = 0;
	if (SCB_QOS(scb)) {
		prio = (uint8)PKTPRIO(sdu);
		ASSERT(prio <= MAXPRIO);
	}

	/* Turn-off TX Header cache as this header should not be installed to/from
	 * Header Cache
	 */
	oldtxc = wlc->txc;
	wlc->txc = FALSE;

	pkt_length = pkttotlen(wlc->osh, pkt);

	/* TKIP MIC space reservation */
	if (key->algo == CRYPTO_ALGO_TKIP)
		pkt_length += TKIP_MIC_SIZE;

	nfrags = wlc_frag(wlc, scb, TX_AC_BE_FIFO, pkt_length, &frag_length);
	ASSERT(nfrags == 1);

	/* wlc_dofrag --> Get the d11hdr put on it with TKIP MIC at the tail for TKIP */
	wlc_dofrag(wlc, pkt, 0, 1, 0, scb, is_8021x, TX_AC_BE_FIFO, key, prio, frag_length);

	wlc->txc = oldtxc;

	return pkt;
}
#endif /* STA */

#if defined(BCMTSTAMPEDLOGS)
/* Asynchronously output a timestamped log message */
void
wlc_log(wlc_info_t *wlc, const char* str, uint32 p1, uint32 p2)
{
	uint32 tstamp;

	/* Read a timestamp from the TSF timer register */
	tstamp = R_REG(wlc->osh, &wlc->regs->tsf_timerlow);

	/* Store the timestamp and the log message in the log buffer */
	bcmtslog(tstamp, (char*)str, p1, p2);
}
#endif /* defined(BCMTSTAMPEDLOGS) */

/* These chan_info[] & lookup routines replicate those from wlc_phy.c because of BMAC split */
static const struct chan_info {
	uint16	chan;	/* channel number */
	uint16	freq;	/* in MHz */
} chan_info[] = {
	/* 11b/11g */
/* 0 */		{1,	2412},
/* 1 */		{2,	2417},
/* 2 */		{3,	2422},
/* 3 */		{4,	2427},
/* 4 */		{5,	2432},
/* 5 */		{6,	2437},
/* 6 */		{7,	2442},
/* 7 */		{8,	2447},
/* 8 */		{9,	2452},
/* 9 */		{10,	2457},
/* 10 */	{11,	2462},
/* 11 */	{12,	2467},
/* 12 */	{13,	2472},
/* 13 */	{14,	2484},

#ifdef BAND5G
/* 11a japan high */
/* 14 */	{34,	5170},
/* 15 */	{38,	5190},
/* 16 */	{42,	5210},
/* 17 */	{46,	5230},

/* 11a usa low */
/* 18 */	{36,	5180},
/* 19 */	{40,	5200},
/* 20 */	{44,	5220},
/* 21 */	{48,	5240},
/* 22 */	{52,	5260},
/* 23 */	{56,	5280},
/* 24 */	{60,	5300},
/* 25 */	{64,	5320},

/* 11a Europe */
/* 26 */	{100,	5500},
/* 27 */	{104,	5520},
/* 28 */	{108,	5540},
/* 29 */	{112,	5560},
/* 30 */	{116,	5580},
/* 31 */	{120,	5600},
/* 32 */	{124,	5620},
/* 33 */	{128,	5640},
/* 34 */	{132,	5660},
/* 35 */	{136,	5680},
/* 36 */	{140,	5700},

/* 11a usa high, ref5 only */
/* 37 */	{149,	5745},
/* 38 */	{153,	5765},
/* 39 */	{157,	5785},
/* 40 */	{161,	5805},
/* 41 */	{165,	5825},

/* 11a japan */
/* 42 */	{184,	4920},
/* 43 */	{188,	4940},
/* 44 */	{192,	4960},
/* 45 */	{196,	4980},
/* 46 */	{200,	5000},
/* 47 */	{204,	5020},
/* 48 */	{208,	5040},
/* 49 */	{212,	5060},
/* 50 */	{216,	5080}
#endif /* BAND5G */
};

/*
 * Converts channel frequency to channel number.
 * Returns 0 if the frequency does not match any channel definition.
 */
uint
wlc_freq2channel(uint freq)
{
	uint i;

	for (i = 0; i < ARRAYSIZE(chan_info); i++) {
		if (chan_info[i].freq == freq)
			return (chan_info[i].chan);
	}
	WL_ERROR(("wlc_freq2channel: Cannot find freq %d\n", freq));
	return (0);
}

/*
 * Converts channel number to channel frequency.
 * Returns 0 if the channel is out of range.
 * Also used by some code in wlc_iw.c
 */
uint
wlc_channel2freq(uint channel)
{
	uint i;

	for (i = 0; i < ARRAYSIZE(chan_info); i++)
		if (chan_info[i].chan == channel)
			return (chan_info[i].freq);
	return (0);
}

/*
 * Function downgrades the edcf parameters
 */

#ifdef	WME
static int
wlc_wme_downgrade_fifo(wlc_info_t *wlc, uint* p_fifo, struct scb *scb)
{
	/* Downgrade the fifo if admission is not yet gained */

	if (wlc_cac_is_traffic_admitted(wlc->cac, wme_fifo2ac[*p_fifo], scb))
		return 0;

	if (AC_BITMAP_TST(wlc->wme_admctl, wme_fifo2ac[*p_fifo])) {
		do {
			if (*p_fifo == 0) {
				WL_ERROR(("No AC available; tossing pkt\n"));
				WLCNTINCR(wlc->pub->_cnt->txnobuf);
				WLCIFCNTINCR(scb, txnobuf);
				return BCME_ERROR;
			}

			(*p_fifo)--;
		} while (AC_BITMAP_TST(wlc->wme_admctl, wme_fifo2ac[*p_fifo]));

		/*
		 * Note: prio in packet is NOT updated.
		 * Original prio is also used below to determine APSD trigger AC.
		 */
	}

	return 0;
}

uint16
wlc_wme_get_frame_medium_time(wlc_info_t *wlc, ratespec_t rate, uint8 preamble_type, uint mac_len)
{
	uint16 duration;

	duration = (uint16)SIFS(wlc->band);
	duration += (uint16)wlc_calc_ack_time(wlc, rate, preamble_type);
	duration += (uint16)wlc_calc_frame_time(wlc, rate, preamble_type, mac_len);
	/* duration in us */
	return duration;
}
#endif /* WME */


#if defined(STA) && defined(AP)
bool
wlc_apup_allowed(wlc_info_t *wlc)
{
	bool busy = AS_IN_PROGRESS(wlc) ||
		SCAN_IN_PROGRESS(wlc->scan) ||
		WLC_RM_IN_PROGRESS(wlc);

#ifdef BCMDBG
	if (busy) {
		WL_APSTA_UPDN(("wl%d: wlc_apup_allowed: defer AP UP, STA associating: "
			"stas/aps/associated %d/%d/%d, AS_IN_PROGRESS() %d, scan %d, rm %d\n",
			wlc->pub->unit, wlc->stas_associated, wlc->aps_associated,
			wlc->pub->associated, AS_IN_PROGRESS(wlc),
			SCAN_IN_PROGRESS(wlc->scan), WLC_RM_IN_PROGRESS(wlc)));
	}
#endif
	return !busy;
}
#endif /* STA && AP */

uint16
wlc_rcvfifo_limit_get(wlc_info_t *wlc)
{
	uint16 rcvfifo;

	/* determine rx fifo. no register/shm, it's hardwired in RTL */

	if (D11REV_GE(wlc->pub->corerev, 13)) {
		/* The hardware now tells us */
		rcvfifo = ((wlc->machwcap & MCAP_RXFSZ_MASK) >> MCAP_RXFSZ_SHIFT) * 512;
	} else if (D11REV_GE(wlc->pub->corerev, 11)) {
		rcvfifo = 10240;
	} else if (D11REV_GE(wlc->pub->corerev, 8)) {
		rcvfifo = 4608;
	} else if (D11REV_GE(wlc->pub->corerev, 5)) {
		rcvfifo = 2560;
	} else if (D11REV_IS(wlc->pub->corerev, 4)) {
		rcvfifo = 5 * 1024;
	} else {
		/* EOL'd chips or chips that doesn't exist yet */
		ASSERT(0);
		return 0;
	}
	return rcvfifo;
}

#ifdef WLC_HIGH
/* Read a single uint16 from shared memory.
 * SHM 'offset' needs to be an even address
 */
uint16
wlc_read_shm(wlc_info_t *wlc, uint offset)
{
	return wlc_bmac_read_shm(wlc->hw, offset);
}

/* Write a single uint16 to shared memory.
 * SHM 'offset' needs to be an even address
 */
void
wlc_write_shm(wlc_info_t *wlc, uint offset, uint16 v)
{
	wlc_bmac_write_shm(wlc->hw, offset, v);
}

/* Set a range of shared memory to a value.
 * SHM 'offset' needs to be an even address and
 * Range length 'len' must be an even number of bytes
 */
void
wlc_set_shm(wlc_info_t *wlc, uint offset, uint16 v, int len)
{
	/* offset and len need to be even */
	ASSERT((offset & 1) == 0);
	ASSERT((len & 1) == 0);

	if (len <= 0)
		return;

	wlc_bmac_set_shm(wlc->hw, offset, v, len);
}

/* Copy a buffer to shared memory.
 * SHM 'offset' needs to be an even address and
 * Buffer length 'len' must be an even number of bytes
 */
void
wlc_copyto_shm(wlc_info_t *wlc, uint offset, const void* buf, int len)
{
	/* offset and len need to be even */
	ASSERT((offset & 1) == 0);
	ASSERT((len & 1) == 0);

	if (len <= 0)
		return;
	wlc_bmac_copyto_objmem(wlc->hw, offset, buf, len, OBJADDR_SHM_SEL);

}

/* Copy from shared memory to a buffer.
 * SHM 'offset' needs to be an even address and
 * Buffer length 'len' must be an even number of bytes
 */
void
wlc_copyfrom_shm(wlc_info_t *wlc, uint offset, void* buf, int len)
{
	/* offset and len need to be even */
	ASSERT((offset & 1) == 0);
	ASSERT((len & 1) == 0);

	if (len <= 0)
		return;

	wlc_bmac_copyfrom_objmem(wlc->hw, offset, buf, len, OBJADDR_SHM_SEL);
}
#endif	/* WLC_HIGH */

/* wrapper BMAC functions to for HIGH driver access */
void
wlc_mctrl(wlc_info_t *wlc, uint32 mask, uint32 val)
{
	wlc_bmac_mctrl(wlc->hw, mask, val);
}

void
wlc_corereset(wlc_info_t *wlc, uint32 flags)
{
	wlc_bmac_corereset(wlc->hw, flags);
}

void
wlc_suspend_mac_and_wait(wlc_info_t *wlc)
{
	wlc_bmac_suspend_mac_and_wait(wlc->hw);
}

void
wlc_enable_mac(wlc_info_t *wlc)
{
	wlc_bmac_enable_mac(wlc->hw);
}
void
wlc_mhf(wlc_info_t *wlc, uint8 idx, uint16 mask, uint16 val, int bands)
{
	wlc_bmac_mhf(wlc->hw, idx, mask, val, bands);
}

uint16
wlc_mhf_get(wlc_info_t *wlc, uint8 idx, int bands)
{
	return wlc_bmac_mhf_get(wlc->hw, idx, bands);
}

static int
wlc_xmtfifo_sz_get(wlc_info_t *wlc, uint fifo, uint *blocks)
{
	return wlc_bmac_xmtfifo_sz_get(wlc->hw, fifo, blocks);
}

#if defined(MACOSX)
static int
wlc_xmtfifo_sz_set(wlc_info_t *wlc, uint fifo, uint16 blocks)
{
	if (fifo >= NFIFO || blocks > 299)
		return BCME_RANGE;

	wlc_xmtfifo_sz_upd_high(wlc, fifo, blocks);

	wlc_bmac_xmtfifo_sz_set(wlc->hw, fifo, blocks);

	return BCME_OK;
}
#endif 

static void
wlc_xmtfifo_sz_upd_high(wlc_info_t *wlc, uint fifo, uint16 blocks)
{
	wlc->xmtfifo_szh[fifo] = blocks;

	if (fifo < AC_COUNT) {
		wlc->xmtfifo_frmmaxh[fifo] =
			(wlc->xmtfifo_szh[fifo] * 256 - 1300) / MAX_MPDU_SPACE;
		WL_INFORM(("%s: fifo sz blk %d entries %d\n",
			__FUNCTION__, wlc->xmtfifo_szh[fifo], wlc->xmtfifo_frmmaxh[fifo]));
	}
}

void
wlc_write_template_ram(wlc_info_t *wlc, int offset, int len, void *buf)
{
	wlc_bmac_write_template_ram(wlc->hw, offset, len, buf);
}

void
wlc_write_hw_bcntemplates(wlc_info_t *wlc, void *bcn, int len, bool both)
{
	wlc_bmac_write_hw_bcntemplates(wlc->hw, bcn, len, both);
}

void
wlc_set_addrmatch(wlc_info_t *wlc, int match_reg_offset, const struct ether_addr *addr)
{
	wlc_bmac_set_addrmatch(wlc->hw, match_reg_offset, addr);
}

#ifdef WLP2P
void
wlc_set_rcmta_type(wlc_info_t *wlc, int idx, uint16 mask, uint16 val)
{
	uint offset;
	uint16 orig_val;
	uint16 new_val;

	ASSERT((val & ~mask) == 0);

	if (idx < P2P_ADDR_STRT_INDX)
		return;

	offset = M_ADDR_BMP_BLK(idx - P2P_ADDR_STRT_INDX);

	new_val = orig_val = wlc_p2p_read_shm(wlc->p2p, offset);
	new_val = (orig_val & ~mask) | val;

	if (new_val == orig_val)
		return;

	/* Cannot be APSTA at the same time */
	ASSERT(((new_val & ADDR_BMP_STA) == 0 || (new_val & ADDR_BMP_AP) == 0));

	WL_NONE(("%s %d id:%d offset 0x%x old: 0x%x new: 0x%x\n", __FUNCTION__, __LINE__,
	         idx, offset, orig_val, new_val));

	wlc_p2p_write_shm(wlc->p2p, offset, new_val);
}
#endif /* WLP2P */

void
wlc_set_rcmta(wlc_info_t *wlc, int idx, const struct ether_addr *addr)
{
	wlc_bmac_set_rcmta(wlc->hw, idx, addr);
}

void
wlc_mute(wlc_info_t *wlc, bool on, mbool flags)
{
	wlc_bmac_mute(wlc->hw, on, flags);
}

void
wlc_read_tsf(wlc_info_t* wlc, uint32* tsf_l_ptr, uint32* tsf_h_ptr)
{
	wlc_bmac_read_tsf(wlc->hw, tsf_l_ptr, tsf_h_ptr);
}

void
wlc_set_cwmin(wlc_info_t *wlc, uint16 newmin)
{
	wlc->band->CWmin = newmin;
	wlc_bmac_set_cwmin(wlc->hw, newmin);
}

void
wlc_set_cwmax(wlc_info_t *wlc, uint16 newmax)
{
	wlc->band->CWmax = newmax;
	wlc_bmac_set_cwmax(wlc->hw, newmax);
}

void
wlc_fifoerrors(wlc_info_t *wlc)
{
	wlc_bmac_fifoerrors(wlc->hw);
}

void
wlc_ampdu_mode_upd(wlc_info_t *wlc, uint8 mode)
{
	uint j;
	wlc_bmac_ampdu_set(wlc->hw, mode);

	for (j = 0; j < NFIFO; j++) {
		uint fifo_size;
		wlc_xmtfifo_sz_get(wlc, j, &fifo_size);
		wlc_xmtfifo_sz_upd_high(wlc, j, (uint16)fifo_size);
	}
}

void
wlc_pllreq(wlc_info_t *wlc, bool set, mbool req_bit)
{
	wlc_bmac_pllreq(wlc->hw, set, req_bit);
}

void
wlc_update_phy_mode(wlc_info_t *wlc, uint32 phy_mode)
{
#ifdef WL11N
	/* Notify the rate selection module of the ACI state change */
	wlc_ratesel_aci_change(wlc->rsi, phy_mode & PHY_MODE_ACI);
#endif
}

void
wlc_reset_bmac_done(wlc_info_t *wlc)
{
#ifdef WLC_HIGH_ONLY
	wlc->reset_bmac_pending = FALSE;
#endif
}


#ifdef MCAST_REGEN
/*
 * Description: This function is called to do the reverse translation
 *
 * Input    eh - pointer to the ethernet header
 */
int
wlc_mcast_reverse_translation(struct ether_header *eh)
{
	uint8 *iph;
	uint32 dest_ip;

	iph = (uint8 *)eh + ETHER_HDR_LEN;
	dest_ip = ntoh32(*((uint32 *)(iph + IPV4_DEST_IP_OFFSET)));

	if (ntoh16(eh->ether_type) != ETHER_TYPE_IP)
	{
		/* Only IP packets are handled */
		return FALSE;
	}

	/* Non-IPv4 multicast packets are not handled */
	if (IP_VER(iph) != IP_VER_4)
	{
		return FALSE;
	}

	/*
	 * The packet has a multicast IP and unicast MAC. That means
	 * we have to do the reverse translation
	 */
	if (((dest_ip & 0xf0000000) == 0xe0000000) && !ETHER_ISMULTI(&eh->ether_dhost))
	{
		ETHER_FILL_MCAST_ADDR_FROM_IP(eh->ether_dhost, dest_ip);
	}

	return TRUE;
}
#endif /* MCAST_REGEN */

static int
wlc_txc_scb_init(void *ctx, struct scb *scb)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	struct txc_cubby *cubby_info = SCB_TXC_INFO(wlc, scb);
	txc_t *txc;
	uint8 txcidx;

	if (SCB_INTERNAL(scb) || !WLC_TXC_ENAB(wlc)) {
		WL_INFORM(("%s: Not allocating the cubby internal_scb %d txc_enab is %d\n",
			__FUNCTION__, SCB_INTERNAL(scb), WLC_TXC_ENAB(wlc)));
		cubby_info->txc = NULL;
		return 0;
	}

	cubby_info->txc = MALLOC(wlc->osh, sizeof(txc_params_t));
	if (!cubby_info->txc) {
		WL_ERROR(("wl%d: %s: failed to allocate txc_param space for txheader cache\n",
			wlc->pub->unit, __FUNCTION__));

		return BCME_NOMEM;
	}

	for (txcidx = 0; txcidx < MAX_TXC_ENTRIES; txcidx++) {
		txc = MALLOC(wlc->osh, sizeof(txc_t));
		if (!txc) {
			WL_ERROR(("wl%d: %s: failed to allocate cubby space for txheader cache\n",
				wlc->pub->unit, __FUNCTION__));

			/* Free whatever we allocated */
			wlc_txc_scb_free(ctx, scb);
			return BCME_NOMEM;
		}
		bzero(txc, sizeof(txc_t));
		cubby_info->txc->scb_cubby[txcidx] = txc;
	}
	return 0;
}

static void
wlc_txc_scb_free(void *ctx, struct scb *scb)
{
	wlc_info_t *wlc = (wlc_info_t *)ctx;
	struct txc_cubby *cubby_info = SCB_TXC_INFO(wlc, scb);
	uint8 txcidx;

	if (SCB_INTERNAL(scb) || !WLC_TXC_ENAB(wlc)) {
		WL_INFORM(("%s: Not Freeing the cubby internal_scb %d txc_enab is %d\n",
			__FUNCTION__, SCB_INTERNAL(scb), WLC_TXC_ENAB(wlc)));
		ASSERT(cubby_info->txc == NULL);
		return;
	}

	ASSERT(cubby_info->txc != NULL);

	for (txcidx = 0; txcidx < MAX_TXC_ENTRIES; txcidx++) {
		if (cubby_info->txc->scb_cubby[txcidx]) {
			MFREE(wlc->osh, cubby_info->txc->scb_cubby[txcidx], sizeof(txc_t));
			cubby_info->txc->scb_cubby[txcidx] = NULL;
		}
	}

	MFREE(wlc->osh, cubby_info->txc, sizeof(txc_params_t));
	cubby_info->txc	= NULL;
}

static uint8
wlc_txc_get_avail_idx(wlc_info_t *wlc, struct scb *scb)
{
	txc_params_t *txc_param = SCB_TXC_PARAMS(wlc, scb);
	uint8 idx = (txc_param != NULL) ? txc_param->txc_avail_idx : 0;
	return idx;
}

static void
wlc_txc_upd_avail_idx(wlc_info_t *wlc, struct scb *scb)
{
	txc_params_t *txc_params = SCB_TXC_PARAMS(wlc, scb);

	if (txc_params) {
		/* Get next free txc index; recycle index if txc is full */
		if (++txc_params->txc_avail_idx == MAX_TXC_ENTRIES)
			txc_params->txc_avail_idx = 0;
	}
}

void
wlc_txc_invalidate_cache(uint *ctx)
{
	txc_t *txc;
	uint8 txcidx;
	txc_params_t *txc_params = 	((struct txc_cubby *)ctx)->txc;

	if (txc_params) {
		for (txcidx = 0; txcidx < MAX_TXC_ENTRIES; txcidx++) {
			txc = txc_params->scb_cubby[txcidx];
			if (txc)
				txc->txhlen = 0;
		}
		txc_params->txc_avail_idx = 0;
	}
}

uint *
wlc_txc_get_cubby(struct wlc_info *wlc, struct scb *scb)
{
	return SCB_TXC_INFO(wlc, scb);
}

/* wlc_exptime_start() and wlc_exptime_stop() are just for RF awareness external log
 * filtering so we don't send an extlog for each suppressed frame
 */
void
wlc_exptime_start(wlc_info_t *wlc)
{
	uint32 curr_time = OSL_SYSUPTIME();

	if (wlc->exptime_cnt == 0) {
		WLC_EXTLOG(wlc, LOG_MODULE_COMMON, FMTSTR_EXPTIME_ID, WL_LOG_LEVEL_ERR, 0,
			wlc->pub->unit, NULL);
	}
	WL_ERROR(("wl%d: %s: packet lifetime (%d ms) expired: frame suppressed\n",
		wlc->pub->unit, __FUNCTION__, wlc->rfaware_lifetime/4));
	wlc->last_exptime = curr_time;
	wlc->exptime_cnt++;
}

/* Enter this only when we're in exptime state */
void
wlc_exptime_check_end(wlc_info_t *wlc)
{
	uint32 curr_time = OSL_SYSUPTIME();

	ASSERT(wlc->exptime_cnt);

	/* No lifetime expiration for WLC_EXPTIME_END_TIME means no interference.
	 * Leave the exptime state.
	 */
	if (curr_time - wlc->last_exptime > WLC_EXPTIME_END_TIME) {
		wlc->exptime_cnt = 0;
		wlc->last_exptime = 0;
	}
}

int
wlc_rfaware_lifetime_set(wlc_info_t *wlc, uint16 lifetime)
{
	int i, ret = BCME_OK;
	bool wme_lifetime = FALSE;

	for (i = 0; i < AC_COUNT; i++)
		if (wlc->lifetime[i])
			wme_lifetime = TRUE;

	/* Enable RF awareness only when wme lifetime is not used because they share same EXPTIME
	 * tx status
	 */
	if (wlc->txmsdulifetime || wme_lifetime) {
		wlc->rfaware_lifetime = 0;
		if ((wlc->rfaware_lifetime == 0) && lifetime) {
			WL_INFORM(("%s: can't turn on RFAWARE if WME is on\n", __FUNCTION__));
			ret = BCME_EPERM;
		}
	} else {
		wlc->rfaware_lifetime = lifetime;
	}

	if (wlc->pub->up) {
		wlc_suspend_mac_and_wait(wlc);
		wlc_write_shm(wlc, M_AGING_THRSH, wlc->rfaware_lifetime);
		wlc_mhf(wlc, MHF4, MHF4_AGING, (wlc->rfaware_lifetime ? MHF4_AGING : 0),
			WLC_BAND_ALL);
		wlc_enable_mac(wlc);
	}

	return ret;
}

/* BTC stuff */
int
wlc_btc_mode_set(wlc_info_t *wlc, int int_val)
{
	wlc->btch->mode = int_val;
	return wlc_bmac_btc_mode_set(wlc->hw, int_val);
}

int
wlc_btc_mode_get(wlc_info_t *wlc)
{
	return wlc->btch->mode;
}

int
wlc_btc_wire_set(wlc_info_t *wlc, int int_val)
{
	int err;
	wlc->btch->wire = int_val;
	err = wlc_bmac_btc_wire_set(wlc->hw, int_val);
	return err;
}

int
wlc_btc_wire_get(wlc_info_t *wlc)
{
	return wlc->btch->wire;
}

int
wlc_btc_flags_idx_set(wlc_info_t *wlc, int int_val, int int_val2)
{
	return wlc_bmac_btc_flags_idx_set(wlc->hw, int_val, int_val2);
}

int
wlc_btc_flags_idx_get(wlc_info_t *wlc, int int_val)
{
	return wlc_bmac_btc_flags_idx_get(wlc->hw, int_val);
}

int
wlc_btc_params_set(wlc_info_t *wlc, int int_val, int int_val2)
{
	return wlc_bmac_btc_params_set(wlc->hw, int_val, int_val2);
}

int
wlc_btc_params_get(wlc_info_t *wlc, int int_val)
{
	return wlc_bmac_btc_params_get(wlc->hw, int_val);
}

static void
wlc_btc_stuck_war50943(wlc_info_t *wlc, bool enable)
{
	wlc_bmac_btc_stuck_war50943(wlc->hw, enable);
}

static void
wlc_btc_rssi_threshold_get(wlc_info_t *wlc)
{
	wlc_bmac_btc_rssi_threshold_get(wlc->hw,
		&wlc->btch->prot_rssi_thresh,
		&wlc->btch->ampdutx_rssi_thresh,
		&wlc->btch->ampdurx_rssi_thresh);
}

#ifdef WLSCANCACHE
/* returns TRUE if scan cache looks valid and recent, FALSE otherwise */
bool
wlc_assoc_cache_validate_timestamps(wlc_info_t *wlc, wlc_bss_list_t *bss_list)
{
	uint current_time = OSL_SYSUPTIME(), oldest_time, i;

	/* if there are no hits, just return with no cache assistance */
	if (bss_list->count == 0)
		return FALSE;

	/* if there are hits, check how old they are */
	oldest_time = current_time;
	for (i = 0; i < bss_list->count; i++)
		oldest_time = MIN(bss_list->ptrs[i]->timestamp, oldest_time);

	/* If the results are all recent enough, then use the cached bss_list
	 * for the association attempt.
	 */
	if (current_time - oldest_time < BCMWL_ASSOC_CACHE_TOLERANCE) {
		WL_ASSOC(("wl%d: %s: %d hits, oldest %d sec, using cache hits\n",
		          wlc->pub->unit, __FUNCTION__,
		          bss_list->count, (current_time - oldest_time)/1000));
		return TRUE;
	}

	return FALSE;
}
#endif /* WLSCANCACHE */

/* check for the particular priority flow control bit being set */
bool
wlc_txflowcontrol_prio_isset(wlc_info_t *wlc, wlc_txq_info_t *q, int prio)
{
	uint prio_mask;

	if (prio == ALLPRIO) {
		prio_mask = TXQ_STOP_FOR_PRIOFC_MASK;
	} else {
		ASSERT(prio >= 0 && prio <= MAXPRIO);
		prio_mask = NBITVAL(prio);
	}

	return (q->stopped & prio_mask) == prio_mask;
}

/* check if a particular override is set for a queue */
bool
wlc_txflowcontrol_override_isset(wlc_info_t *wlc, wlc_txq_info_t *qi, uint override)
{
	/* override should have some bit on */
	ASSERT(override != 0);
	/* override should not have a prio bit on */
	ASSERT((override & TXQ_STOP_FOR_PRIOFC_MASK) == 0);

	return ((qi->stopped & override) != 0);
}


/* propogate the flow control to all interfaces using the given tx queue */
void
wlc_txflowcontrol(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, int prio)
{
	uint prio_bits;
	uint cur_bits;

	if (prio == ALLPRIO) {
		prio_bits = TXQ_STOP_FOR_PRIOFC_MASK;
	} else {
		ASSERT(prio >= 0 && prio <= MAXPRIO);
		prio_bits = NBITVAL(prio);
	}

	cur_bits = qi->stopped & prio_bits;

	/* Check for the case of no change and return early
	 * Otherwise update the bit and continue
	 */
	if (on) {
		if (cur_bits == prio_bits) {
			return;
		}
		mboolset(qi->stopped, prio_bits);
	} else {
		if (cur_bits == 0) {
			return;
		}
		mboolclr(qi->stopped, prio_bits);
	}

	/* If there is a flow control override we will not change the external
	 * flow control state.
	 */
	if (qi->stopped & ~TXQ_STOP_FOR_PRIOFC_MASK) {
		return;
	}

	wlc_txflowcontrol_signal(wlc, qi, on, prio);
}

void
wlc_txflowcontrol_override(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, uint override)
{
	uint prev_override;

	ASSERT(override != 0);
	ASSERT((override & TXQ_STOP_FOR_PRIOFC_MASK) == 0);

	ASSERT(qi != NULL);

	prev_override = (qi->stopped & ~TXQ_STOP_FOR_PRIOFC_MASK);

	/* Update the flow control bits and do an early return if there is
	 * no change in the external flow control state.
	 */
	if (on) {
		mboolset(qi->stopped, override);
		/* if there was a previous override bit on, then setting this
		 * makes no difference.
		 */
		if (prev_override) {
			return;
		}

		wlc_txflowcontrol_signal(wlc, qi, ON, ALLPRIO);
	} else {
		mboolclr(qi->stopped, override);
		/* clearing an override bit will only make a difference for
		 * flow control if it was the only bit set. For any other
		 * override setting, just return
		 */
		if (prev_override != override) {
			return;
		}

		if (qi->stopped == 0) {
			wlc_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
		} else {
			int prio;

			for (prio = MAXPRIO; prio >= 0; prio--) {
				if (!mboolisset(qi->stopped, NBITVAL(prio)))
					wlc_txflowcontrol_signal(wlc, qi, OFF, prio);
			}
		}
	}
}

void
wlc_txflowcontrol_reset_qi(wlc_info_t *wlc, wlc_txq_info_t *qi)
{
	ASSERT(qi != NULL);

	if (qi->stopped) {
		wlc_txflowcontrol_signal(wlc, qi, OFF, ALLPRIO);
		qi->stopped = 0;
	}
}

static void
wlc_txflowcontrol_reset(wlc_info_t *wlc)
{
	wlc_txq_info_t *qi;

	for (qi = wlc->tx_queues; qi != NULL; qi = qi->next) {
		wlc_txflowcontrol_reset_qi(wlc, qi);
	}
}

static void
wlc_txflowcontrol_signal(wlc_info_t *wlc, wlc_txq_info_t *qi, bool on, int prio)
{
	wlc_if_t *wlcif;
	uint curr_qi_stopped = qi->stopped;

	for (wlcif = wlc->wlcif_list; wlcif != NULL; wlcif = wlcif->next) {
		if (curr_qi_stopped != qi->stopped) {
			/* This tells us that while performing wl_txflowcontrol(),
			 * the qi->stopped state changed.
			 * This can happen when turning wl flowcontrol OFF since in
			 * the process of draining packets from wl layer, flow control
			 * can get turned back on.
			 */
			WL_ERROR(("wl%d: qi(%p) stopped changed from 0x%x to 0x%x, exit %s\n",
			          wlc->pub->unit, qi, curr_qi_stopped, qi->stopped, __FUNCTION__));
			break;
		}
		if (wlcif->qi == qi &&
		    wlcif->flags & WLC_IF_LINKED)
			wl_txflowcontrol(wlc->wl, wlcif->wlif, on, prio);
	}
}

wlc_if_t*
wlc_wlcif_alloc(wlc_info_t *wlc, osl_t *osh, uint8 type, wlc_txq_info_t *qi)
{
	wlc_if_t *wlcif;

	wlcif = (wlc_if_t*)wlc_calloc(osh, wlc->pub->unit, sizeof(wlc_if_t));
	if (wlcif != NULL) {
		wlcif->type = type;
		wlcif->qi = qi;

		/* add this interface to the global list */
		wlcif->next = wlc->wlcif_list;
		wlc->wlcif_list = wlcif;
	}

	return wlcif;
}

void
wlc_wlcif_free(wlc_info_t *wlc, osl_t *osh, wlc_if_t *wlcif)
{
	wlc_if_t *p;

	if (wlcif == NULL)
		return;

	/* remove the interface from the interface linked list */
	p = wlc->wlcif_list;
	if (p == wlcif)
		wlc->wlcif_list = p->next;
	else {
		while (p != NULL && p->next != wlcif)
			p = p->next;
		ASSERT((p != NULL) && (p->next == wlcif));
		if (p != NULL)
			p->next = p->next->next;
	}

	MFREE(osh, wlcif, sizeof(wlc_if_t));
}

/* Return the interface pointer for the BSS indexed by idx */
wlc_if_t *
wlc_wlcif_get_by_index(wlc_info_t *wlc, uint idx)
{
	wlc_bsscfg_t	*bsscfg;
	wlc_if_t	*wlcif = NULL;

	if (wlc == NULL)
		return NULL;

	if (idx >= WLC_MAXBSSCFG)
		return NULL;

	bsscfg = wlc->bsscfg[idx];
	if (bsscfg)
		wlcif = bsscfg->wlcif;

	return wlcif;
}

void
wlc_wlcif_stats_get(wlc_info_t *wlc, wlc_if_t *wlcif, wlc_if_stats_t *wlc_if_stats)
{
	if ((wlcif == NULL) || (wlc_if_stats == NULL))
		return;

	/*
	 * Aggregate errors from other errors
	 * These other errors are only updated when it makes sense
	 * that the error should be charged to a logical interface
	 */
	wlcif->_cnt.txerror = wlcif->_cnt.txnobuf + wlcif->_cnt.txrunt;
	wlcif->_cnt.rxerror = wlcif->_cnt.rxnobuf + wlcif->_cnt.rxrunt + wlcif->_cnt.rxfragerr;

	memcpy(wlc_if_stats, &(wlcif->_cnt), sizeof(wlc_if_stats_t));
}


wlc_txq_info_t*
wlc_txq_alloc(wlc_info_t *wlc, osl_t *osh)
{
	wlc_txq_info_t *qi, *p;

	qi = (wlc_txq_info_t*)wlc_calloc(osh, wlc->pub->unit, sizeof(wlc_txq_info_t));
	if (qi == NULL) {
		return NULL;
	}

	/* Have enough room for control packets along with HI watermark */
	/* Also, add room to txq for total psq packets if all the SCBs leave PS mode */
	/* The watermark for flowcontrol to OS packets will remain the same */
	pktq_init(&qi->q, WLC_PREC_COUNT,
	          (2 * wlc->pub->tunables->datahiwat) + PKTQ_LEN_DEFAULT +
	          wlc->pub->psq_pkts_total);

	/* add this queue to the the global list */
	p = wlc->tx_queues;
	if (p == NULL) {
		wlc->tx_queues = qi;
	} else {
		while (p->next != NULL)
			p = p->next;
		p->next = qi;
	}

	return qi;
}

void
wlc_txq_free(wlc_info_t *wlc, osl_t *osh, wlc_txq_info_t *qi)
{
	wlc_txq_info_t *p;

	if (qi == NULL)
		return;

	/* remove the queue from the linked list */
	p = wlc->tx_queues;
	if (p == qi)
		wlc->tx_queues = p->next;
	else {
		while (p != NULL && p->next != qi)
			p = p->next;
		ASSERT((p != NULL) && (p->next == qi));
		if (p != NULL)
			p->next = p->next->next;
	}

	MFREE(osh, qi, sizeof(wlc_txq_info_t));
}

#ifdef WL_MULTIQUEUE
void
wlc_attach_queue(wlc_info_t *wlc, wlc_txq_info_t *qi)
{
	ASSERT(wlc->active_queue != qi);

	if (wlc->active_queue != NULL) {
		wlc_detach_queue(wlc);
	}
	wlc->active_queue = qi;
}

void
wlc_detach_queue(wlc_info_t *wlc)
{
	ASSERT(wlc->active_queue != NULL);

	/* save the fifo that is being detached as the destination to re-enqueue
	 * packets from the txfifos if no previous detach pending
	 */
	if (!wlc->txfifo_detach_pending)
		wlc->txfifo_detach_transition_queue = wlc->active_queue;
	wlc->active_queue = NULL;

	/* no hardware to sync if we are down */
	if (!wlc->pub->up)
		return;

	/* If there are pending packets on the fifo, then stop the fifo
	 * processing and re-enqueue packets
	 */
	if ((TXPKTPENDTOT(wlc) > 0) && (!wlc->txfifo_detach_pending)) {

		/* Need this for split driver */
		wlc->txfifo_detach_pending = TRUE;

		/* flush the fifos and process txstatus from packets that
		 * were sent before the flush
		 * wlc_txfifo_sync_complete() will be called when all transmitted
		 * packets' txstatus have been processed. The call may be done
		 * before wlc_bmac_txfifo_sync() returns, or after in a split driver.
		 */
		wlc_bmac_tx_fifo_sync(wlc->hw, BITMAP_SYNC_ALL_TX_FIFOS, SYNCFIFO);
	}
}

void
wlc_tx_fifo_sync_complete(wlc_info_t *wlc, uint fifo_bitmap, uint8 flag)
{
	void *pkt_list;
	void *pkt;
	d11txh_t *txh;
	struct pktq *q;
	uint i;
	uint prec;
	uint fbmp;

	/* check for up first? If we down the driver, maybe we will
	 * get and ignore this call since we flush all txfifo pkts,
	 * and wlc->txfifo_detach_pending would be false.
	 */
	ASSERT(wlc->txfifo_detach_pending);

	WL_MQ(("MQ: %s: TXPEND = %d\n", __FUNCTION__, TXPKTPENDTOT(wlc)));

	pkt_list = NULL;

#ifdef WLC_HIGH_ONLY
	/* split driver:
	 *    loop fifo,rpctxq instead of DMA and PIO getnexttxp
	 */
	for (i = 0, fbmp = fifo_bitmap; fbmp; i++, fbmp = fbmp >> 1) {
		if ((fbmp & 0x01) == 0) /* not the right fifo to process */
			continue;

		if (!wlc_rpctx_fifo_enabled(wlc->rpctx, i))
			continue;

		while (NULL != (pkt = GETNEXTTXP(wlc, i))) {
			if (flag == FLUSHFIFO) {
				PKTFREE(wlc->osh, pkt, TRUE);
			} else { /* SYNCFIFO */
				PKTSETLINK(pkt, pkt_list);
				pkt_list = pkt;
			}
		}
	}
#else
	for (i = 0, fbmp = fifo_bitmap; fbmp; i++, fbmp = fbmp >> 1) {
		if ((fbmp & 0x01) == 0) /* not the right fifo to process */
			continue;

		if (!PIO_ENAB((wlc)->pub)) {
			if (wlc->hw->di[i] == NULL)
				continue;

			while (NULL != (pkt = dma_getnexttxp(wlc->hw->di[i], HNDDMA_RANGE_ALL))) {

				if (flag == FLUSHFIFO) {
					PKTFREE(wlc->osh, pkt, TRUE);
				} else { /* SYNCFIFO */
					PKTSETLINK(pkt, pkt_list);
					pkt_list = pkt;
					WL_MQ(("MQ: %s: recovering %p prio %d prec %d\n",
					       __FUNCTION__, pkt,
					       PKTPRIO(pkt), WLC_PRIO_TO_PREC(PKTPRIO(pkt))));
				}
			}
		} else {
			if (wlc->hw->pio[i] == NULL)
				continue;

			while (NULL != (pkt = wlc_pio_getnexttxp((wlc)->hw->pio[i]))) {
				if (flag == FLUSHFIFO) {
					PKTFREE(wlc->osh, pkt, TRUE);
				} else { /* SYNCFIFO */
					PKTSETLINK(pkt, pkt_list);
					pkt_list = pkt;
				}
			}
		}
	}
#endif /* WLC_HIGH_ONLY */

	q = &wlc->txfifo_detach_transition_queue->q;
	while (pkt_list != NULL) {
		pkt = pkt_list;
		pkt_list = PKTLINK(pkt);
		PKTSETLINK(pkt, NULL);

		txh = (d11txh_t *)PKTDATA(wlc->osh, pkt);

		WL_MQ(("MQ: %s: working on %p FID 0x%x\n",
		       __FUNCTION__, pkt, htol16(txh->TxFrameID)));

		/* restore the scb for the packet
		 * if there is no scb, the packet should be tossed
		 */
		if (!wlc_recover_pkt_scb(wlc, pkt, txh)) {
			/* tossed packet counter??? */
			WL_MQ(("MQ: %s: failed SCB recovery for %p\n",
			       __FUNCTION__, pkt));
			PKTFREE(wlc->osh, pkt, TRUE);
			continue;
		}

		prec = WLC_PRIO_TO_PREC(PKTPRIO(pkt));

		/* Mark as retrived from HW FIFO */
		WLPKTTAG(pkt)->flags |= WLF_FIFOPKT;

		if (pktq_pfull(q, prec)) {
			struct scb *scb = WLPKTTAGSCBGET(pkt);
			WL_MQ(("MQ: %s: PREC %d full! freeing pkt %p\n", __FUNCTION__,
			       prec, pkt));
			PKTFREE(wlc->osh, pkt, TRUE);
			WLCNTINCR(wlc->pub->_cnt->txnobuf);
			WLCIFCNTINCR(scb, txnobuf);
		} else {
			WL_MQ(("MQ: %s: PREC %d Re-Enqueue pkt %p\n", __FUNCTION__,
			       prec, pkt));
			pktq_penq_head(q, prec, pkt);
		}
	}

#ifdef WLC_HIGH_ONLY
	/* process completions from selected fifos */
	for (i = 0, fbmp = fifo_bitmap; fbmp; i++, fbmp = fbmp >> 1) {
		if ((fbmp & 0x01) == 0) /* not the right fifo to process */
			continue;

		if (!wlc_rpctx_fifo_enabled(wlc->rpctx, i))
			continue;

		WL_MQ(("MQ: %s: FIFO %d completing %d\n", __FUNCTION__,
			i, TXPKTPENDGET(wlc, i)));

		if (TXPKTPENDGET(wlc, i)) {
			wlc_txfifo_complete(wlc, i, (int8)TXPKTPENDGET(wlc, i));
		}
	}
#else
	/* process completions from selected fifos */
	for (i = 0, fbmp = fifo_bitmap; fbmp; i++, fbmp = fbmp >> 1) {
		if ((fbmp & 0x01) == 0) /* not the right fifo to process */
			continue;

		if ((!PIO_ENAB(wlc->pub) && wlc->hw->di[i] == NULL) ||
		    (PIO_ENAB(wlc->pub) && wlc->hw->pio[i] == NULL)) {
			continue;
		}

		WL_MQ(("MQ: %s: FIFO %d completing %d\n", __FUNCTION__,
		       i, TXPKTPENDGET(wlc, i)));

		if (TXPKTPENDGET(wlc, i)) {
			wlc_txfifo_complete(wlc, i, (int8)TXPKTPENDGET(wlc, i));
		}
	}
#endif /* WLC_HIGH_ONLY */

	wlc->txfifo_detach_pending = FALSE;

#ifdef WLC_HIGH_ONLY
	/* Restart send after switching the queue for split driver */
	if (wlc->active_queue != NULL)
	{
		if (!pktq_empty(&wlc->active_queue->q))
			wlc_send_q(wlc, wlc->active_queue);
	}
#endif /* WLC_HIGH_ONLY */
}

/* Start or continue an excursion from the currently active
 * tx queue context.
 * Switch to the dedicated excursion queue
 */
void
wlc_excursion_start(wlc_info_t *wlc)
{
	if (wlc->excursion_active) {
		WL_MQ(("MQ: %s: already active, exiting\n", __FUNCTION__));
		return;
	}
#ifdef WLMCHAN
	if (MCHAN_ENAB(wlc->pub) && wlc->excursion_queue == wlc->active_queue) {
		WL_MCHAN(("MCHAN: %s: same queue\n", __FUNCTION__));
		return;
	}
#endif
	WL_MQ(("MQ: %s:\n", __FUNCTION__));

	wlc->excursion_active = TRUE;

	/* if we are not in an excursion, the active_queue should be the primary_queue */
	ASSERT(wlc->primary_queue == wlc->active_queue);

	wlc_attach_queue(wlc, wlc->excursion_queue);
}

/* Terminate the excursion from the active tx queue context.
 * Switch from the excursion queue back to the current primary_queue
 */
void
wlc_excursion_end(wlc_info_t *wlc)
{
	if (!wlc->excursion_active) {
		WL_MQ(("MQ: %s: not in active excursion, exiting\n", __FUNCTION__));
		return;
	}

	WL_MQ(("MQ: %s:\n", __FUNCTION__));

	wlc->excursion_active = FALSE;

	wlc_attach_queue(wlc, wlc->primary_queue);
	/* Packets being sent during an excursion should only be valid
	 * for the duration of that excursion.  If any packets are still
	 * in the queue at the end of excursion should be flushed.
	 */
	pktq_flush(wlc->osh, &wlc->excursion_queue->q, TRUE, NULL, 0);
}

/* Use the given queue as the new primary queue
 * wlc->primary_queue is updated, detaching the former
 * primary_queue from the fifos if necessary
 */
void
wlc_primary_queue_set(wlc_info_t *wlc, wlc_txq_info_t *new_primary)
{
	wlc->primary_queue = new_primary;

	/* if an excursion is active the active_queue should remain on the
	 * excursion_queue. At the end of the excursion, the new primary_queue
	 * will be made active.
	 */
	if (wlc->excursion_active)
		return;

	wlc_attach_queue(wlc, new_primary);
}
#endif /* WL_MULTIQUEUE */

/* This function will read the PM duration accumulator maintained by ucode */
uint32
wlc_get_accum_pmdur(wlc_info_t *wlc)
{
	uint32 res;
	uint16 accumulator[2];

	accumulator[1] = wlc_read_shm(wlc, M_MAC_DOZE_H);
	accumulator[0] = wlc_read_shm(wlc, M_MAC_DOZE_L);
	if (wlc_read_shm(wlc, M_MAC_DOZE_H) != accumulator[1]) {
		accumulator[1] = wlc_read_shm(wlc, M_MAC_DOZE_H);
		accumulator[0] = wlc_read_shm(wlc, M_MAC_DOZE_L);
	}

	/* Approximate x/1000 as x/2^10 + x/2^16 */
	/* x/2^10 */
	res = accumulator[0] >> 10;
	res += accumulator[1] << 6;

	/* x/2^16 */
	res += accumulator[1];
	return res;
}

/* Reset the PM duration accumulator maintained by ucode */
int
wlc_reset_accum_pmdur(wlc_info_t *wlc)
{
	/* reset accumulator registers */
	wlc_write_shm(wlc, M_MAC_DOZE_L, 0);
	wlc_write_shm(wlc, M_MAC_DOZE_H, 0);
	return BCME_OK;
}

/* MHF2_SKIP_ADJTSF muxing, clear the flag when no one requests to skip the ucode
 * TSF adjustment.
 */
void
wlc_skip_adjtsf(wlc_info_t *wlc, bool skip, wlc_bsscfg_t *cfg, uint32 user, int bands)
{
	uint global_start = NBITS(wlc->skip_adjtsf) - WLC_SKIP_ADJTSF_USER_MAX;
	int b;

	ASSERT(cfg != NULL || user < WLC_SKIP_ADJTSF_USER_MAX);
	ASSERT(cfg == NULL || (uint32)WLC_BSSCFG_IDX(cfg) < global_start);

	b = (cfg == NULL) ? user + global_start : (uint32)WLC_BSSCFG_IDX(cfg);
	if (skip)
		setbit(&wlc->skip_adjtsf, b);
	else
		clrbit(&wlc->skip_adjtsf, b);

#ifdef BCMDBG
	if (cfg != NULL)
		WL_TMP(("wl%d.%d: wlc->skip_adjtsf 0x%x (skip %d)\n",
		        wlc->pub->unit, WLC_BSSCFG_IDX(cfg), wlc->skip_adjtsf, skip));
	else
		WL_TMP(("wl%d: wlc->skip_adjtsf 0x%x (user %d skip %d)\n",
		        wlc->pub->unit, wlc->skip_adjtsf, user, skip));
#endif

	wlc_mhf(wlc, MHF2, MHF2_SKIP_ADJTSF,
	        wlc->skip_adjtsf ? MHF2_SKIP_ADJTSF : 0, bands);
}

/* MCTL_AP muxing, set the bit when no one requests to stop the AP functions (beacon, prbrsp) */
void
wlc_stop_ap(wlc_info_t *wlc, bool stop, wlc_bsscfg_t *cfg, uint32 user)
{
	uint global_start = NBITS(wlc->stop_ap) - WLC_STOP_AP_USER_MAX;
	int b;

	ASSERT(cfg != NULL || user < WLC_STOP_AP_USER_MAX);
	ASSERT(cfg == NULL || (uint32)WLC_BSSCFG_IDX(cfg) < global_start);

	b = (cfg == NULL) ? user + global_start : (uint32)WLC_BSSCFG_IDX(cfg);
	if (stop)
		setbit(&wlc->stop_ap, b);
	else
		clrbit(&wlc->stop_ap, b);

#ifdef BCMDBG
	if (cfg != NULL)
		WL_TMP(("wl%d.%d: wlc->stop_ap 0x%x (stop %d)\n",
		        wlc->pub->unit, WLC_BSSCFG_IDX(cfg), wlc->stop_ap, stop));
	else
		WL_TMP(("wl%d: wlc->stop_ap 0x%x (user %d stop %d)\n",
		        wlc->pub->unit, wlc->stop_ap, user, stop));
#endif

	if (AP_ACTIVE(wlc))
		wlc_mctrl(wlc, MCTL_AP, wlc->stop_ap ? 0 : MCTL_AP);
}

#ifdef BCMDBG
void wlc_update_perf_stats(wlc_info_t *wlc, uint32 mask)
{
	wlc_perf_stats_t *stats = &wlc->perf_stats;

	if (mask & WLC_PERF_STATS_ISR) stats->n_isr++;
	if (mask & WLC_PERF_STATS_DPC) stats->n_dpc++;
	if (mask & WLC_PERF_STATS_TMR_DPC) stats->n_timer_dpc++;
	if (mask & WLC_PERF_STATS_GPTIMER) stats->n_gptimer++;
	if (mask & WLC_PERF_STATS_BCN) stats->n_beacon++;
	if (mask & WLC_PERF_STATS_PRB_REQ) stats->n_probe_req++;
}


void wlc_update_isr_stats(wlc_info_t *wlc, uint32 macintstatus)
{
	wlc_isr_stats_t *stats = &wlc->perf_stats.isr_stats;
	uint32 i;
	/* Update the overall Stats Count as well */
	if (macintstatus)
		wlc_update_perf_stats(wlc, WLC_PERF_STATS_ISR);

	for (i = 0; i < 32; i++)
		if (macintstatus & (1<<i)) 	{stats->n_counts[i]++;}

}
#endif /* BCMDBG */

#ifdef WLPKTDLYSTAT
void wlc_delay_stats_upd(wlc_scb_delay_stats_t *delay_stats, uint32 delay_val,
                         uint tr, bool ack_recd)
{
	WLCNTSCBINCR(delay_stats->txmpdu_cnt[tr]);
	WLCNTSCBADD(delay_stats->delay_sum[tr], delay);
	if (delay_stats->delay_min == 0) {
		delay_stats->delay_min = delay_val;
		delay_stats->delay_max = delay_val;
	} else {
		if (delay < delay_stats->delay_min)
			delay_stats->delay_min = delay_val;
		else if (delay > delay_stats->delay_max)
			delay_stats->delay_max = delay_val;
	}
	WLCNTSCBINCR(delay_stats->delay_hist[MIN(delay/500, WLPKTDLY_HIST_NBINS-1)]);
	if (!ack_recd)
		WLCNTSCBINCR(delay_stats->txmpdu_lost);
}
#endif /* WLPKTDLYSTAT */
